The "no generics" discussion sometimes get on my nerve. It sounds like it's the only thing that holds some people back from using Go, even though it has plenty to offer. I for one do not miss it... yet. &gt; "There are only two kinds of languages: the ones people complain about and the ones nobody uses" Looks like Stroustrup was right about that.
Go aims to be simple. Using and IDE and frameworks would be obscure and complicated
I completely agree that writing your own custom appender should be easy, I just asked to see if you had anything in mind for the custom data. Thanks for the response.
Of course not. A language can't control designers and programmers. But I like being encouraged to be as simple as possible by design. If something is getting complicated and obscure, it's most likely because I did a poor design and I must re-design it
We can make up hypotheticals all day, but the reality of the current situation is that the generic way to represent some things is with the empty interface. Don't get me wrong, I think that's just fine. A lot of people seem to get stuck on the idea of 'generic containers', as if there aren't other ways of writing generic code. Rob Pike has spoken quite a bit about how he thinks all the problems people are expressing can be solved with code transformation and program writers. From my own personal investigations of how Go's AST and reflect packages work, I have to agree with him. I think if the full notion of generic programming is possible with the language, without needing additions, that speaks the the strength of the language itself.
So, who's going to be the head of the gigantic robot? Or is that a gopher?
I think it's a bit of a stretch to say that it's the most used HTTP client library in the world, mainly because this is the first I've heard about it.
Yes?
Yes?
No.
No vim support, at all. Not even Vim keybindings.
Having generics let you use parametricity all the time, which strengthens the type safety a lot.
Definitely a good idea. How can you tell if you would have received more data than the limit amount so you can notify the sender that they've exceeded the limit?
Is go generate anything other than a shell script replacement in the code? People keep talking like it solves all kinds of problems, but all it has done for me is gotten rid of a few external script files and made them a bit uglier in code. I like that it gives a more consistent interface for people, but it really doesn't do anything on its own.
Yes?
Go has topped r/programming for the first time! :)
Is it just me or does that API look fairly unidiomatic for go?
&gt; If you take a look at two of Google’s other projects, Dart and Android you’ll notice that Google has created IDE’s for both Haven't the Go team already said that they're not interested in making an IDE? If you want one so bad just make one.
The go team doesn't need to build the IDE but it would be fairly awesome if Google put some support behind one being developed.
Support for internal modules is awesome. I've felt uncomfortable having all my source files in a single flat directory, but the only alternative was to break them out into completely separate, public modules. It's nice that now I can create internal modules vaguely similar to how I would do it in Python.
When you look closely at graphs, the GC pause time graph for 1.3 is 2x the scale of 1.4, so the line that looks the same in 1.3, is actually 2x bigger. So what it does show is that in 1.4 GC pauses are much shorter on average at the cost of being performed more often, which was the design goal of GC changes in 1.4. With GC many people (especially those writing games, networking servers, near real-time system) want the shortest possible GC pauses to minimize spikes in latency. They prefer 1ms pause 10 times a second to 2ms pause 5 times a second and this is the 1.4 improvement that the graphs shows. 
Remember to change your import paths: code.google.com/p/ is changing to golang.org/x/
Well done Gonto!
Cool, I did get the scale part, I just wasn't sure if more pauses was really a good thing. 
Personally I enjoy being able to develop using a package like structure for organization and separation of concerns, without needing to worry about accidentally providing a public API that people start programming against.
And? What you gonna do about that?
The key trade-off here is a small amount of precision for accuracy of percentiles. This is useful when it is unacceptable to sacrifice accuracy when generating percentiles, such as when trying to determine the long-tail latency of a distributed system. Most commonly used metrics libraries use reservoir sampling for their histograms, which leads to percentiles that may be quite far from the true 99.99th value, for example. This technique allows you to crank up the percentile arbitrarily, and get a result that is generally within 1% of its true value. The exception being for values between 0 and 1 - which this guarantee does not hold for. The PrintBenchmark is quite useful for rapid performance analysis of arbitrary code. This was used extensively while tuning the underlying library itself, and I've found myself relying on it pretty heavily for being aware of performance traps I encounter while writing Go, as well as for general purpose external service benchmarking by putting various client operations in the timed function.
Coming from C, I was always more comfortable directly accessing byte arrays as opposed to using ByteBuffers. Glad to see this is still useful in certain circumstances :) Great code overall!
The particularly great thing about this is that you get to take advantage of io.Copy's optimizations. This is probably a case where it'll end up using sendfile under the hood, which cuts out a lot of kernel&lt;-&gt;userspace chatter.
Just aesthetics. I prefer to break my applications up into smaller modules, and then the modules into individual source files. src/myapp/data_access/foo.go src/myapp/data_access/bar.go src/myapp/util/baz.go src/myapp/main.go
it is almost always a win though if the switches you have to make are obvious and clear...
I just added access by dot-notation (check the op for an example). Looking at the code in that repository, it looks like I could add support for yaml pretty easily using the library launchpad.net/~niemeyer/goyaml/beta Thanks for the link. Edit: It would clash with the name of the package quite badly though :P
In a nutshell : generics would be useful when you happen to use interface{} as they offer you both better type safety and better performance.
Correct. Although an example working out-of-the-box (rather than a "you juste have to implement a shell script") would be much more convincing IMO...
[Benchmarking could be really more intensive than you can imagine](https://github.com/julienschmidt/go-http-routing-benchmark). But nonetheless, its interesting
nice! I've written one that we use in production as well: https://github.com/pkieltyka/jwtauth it's written as Goji middleware so that it can pass the token object in the request context
Yes your probably right, these was more to give a idea of the speed not to pretend to be the fastest in every situation. And thanks for the comment.
Good point.
io.LimitReader returns an io.Reader. So you call its Read([]byte) method and look for an error of type io.EOF. An io.EOF error (in this case )means the client sent more than allowed.
Confirmed Android completely moving to Go in **1-2 years**. Hooray!
Thanks! and started to use: rss2fs (cat your feeds) https://github.com/hloeffler/rss2fs
Vim and Emacs are pretty much IDEs with the (Go) plugins available for it. I'd like to see a good debugger as well but I fail to see why it would need anything to do with an IDE.
https://github.com/fatih/vim-go is awesome -- just saying. 
What a shitty graph
It is funny to look at sometimes - especially because the vast majority of vocal, unconstructive whining is from people who don't use the language (and don't seem to spend their time productively). 
 func TestRouting(t *testing.T) { mux := New() call := false mux.Get("/a/:id", func(http.ResponseWriter, *http.Request) { call = true }) r, _ := http.NewRequest("GET", "/b/123", nil) w := httptest.NewRecorder() mux.ServeHTTP(w, r) if call { t.Error("handler should not be called") } } --- FAIL: TestRouting (0.00 seconds) bone_bench_test.go:32: handler should not be called FAIL exit status 1 FAIL github.com/squiidz/bone 1.459s 
Nice job, though I noticed a problem in your ServeHTTP handler. Currently if *any* route doesn't match the HTTP method it will call your BadRequest method and serve the not found handler. You need to change: if !r.MethCheck(req) { m.BadRequest(rw, req) return } To this: if !r.MethCheck(req) { continue } Here's a [gist](https://gist.github.com/1e79a4f0bf8bb640c0ab) that demonstrates this.
Heh, after reading this and the comment linking to the earlier vim discussion, I'm pretty much convinced---trying it out now. Thanks for the advice guys!
What a super-interesting data point!
Yes?
Great, thanks for the advice!
These graphs should really be overlaid. It would put measurements on identical scales and make it much easier to compare.
Awesome work
thanks! Remasis and I have been laughing and watching all the terrible toolkits roll in on the curl module. After a few growlers of top notch Idaho Brewing Company, we have deciding to roll a voting algorithm on best "dipshits of ssh" where you can vote on who had the dumbest session. We will also be making available the repository of all the toolkits people tried to drop onto the box. This has been fun!
I did some patent work on virtual honeypots. Placing servers like this within a network are excellent at detecting bad actors in an environment. Extending this to provide some commands such as ping and nmap that could lure an attacker to think they are discovering network elements that don't exist could be interesting. Potentially you could emulate the user connecting to other hosts and then offer a different set of commands to let them think they are hopping through the network. But in the end they never actually leave the SSH host. I will see what I can contribute back to this idea. Could be fun.
No relative imports, please. import ( "./fakeshell"
Hi I'm remasis and I made the front end. For anyone interested its angularjs with the new material design stuff, which I think looks pretty sexy. Troll project but as we have time and gumption we plan on adding fun things like rating a users frustration and viewing by popularity, randomness, archive search, etc.
Ask gri@golang.org. He likes these bugs and wrote/maintains that code.
Very nice. Look forward to see what those script kiddies are using these days. 
It really doesn't have to affect type safety at all. If you don't want type-unsafe code, don't write it.
&gt; The only language community (restricting to static languages, here) that are sceptical of generics, seems to be Go. Well, there's also [fantom](http://fantom.org). (But I don't disagree with you.)
You can't use parametricity theorems without generics.
You wouldn't _necessarily_ need a separate type in the type system for that. You might be able to achieve the same thing with annotations. FWIW I don't believe that precision is something that should be encoded into the type system, since there's no useful reasoning the compiler can do about precision. Overflows or loss of precision are things that are detectable at runtime, not at compile time.
Nice :)! You can give this one a try as well.
Just pushed the fix to check for token.Valid. Thanks for letting me know :).
A [reliable source](http://www.reddit.com/r/golang/comments/2oy3ls/go_14_is_released/cmsag25) told me this is true. Finally everything on Android will run at least 1000% faster and make unicorn rainbows!
You can write functions that sorts lists of any type, while the compiler still checks that there is sanity going in and sanity coming out of the function. Without generics, the sort function either has to be written per type, or would have to accept anything and send out anything, without the additional type checks by the compiler.
That is awesome!
You're just saying "you can't use generics without generics". I'm saying, you don't need generics. Or parametric polymorphism.
you won't be sad. vim-go is so much awesome it converted me to a vim user after years of failed attempts. Now i'm using vim movement commands everywhere and getting upset because Microsoft Word doesn't understand :wq 
Thanks! I ended up posting an issue on github and he talked about it with me. Turns out it's some form of 'neither'. Seems like it's an old tool that was written for specific purposes and changing the semantics now could be dangerous. So we're chalking it up to 'documentation deficiency' :-)
why you decided to use mongo as a dep for logs?
Relevant: https://www.youtube.com/watch?v=wCwoLPfm-PU&amp;list=UUIqfavBMIixvYZD-F1alC0w https://www.youtube.com/watch?v=fPypZSZiF3g&amp;list=UUIqfavBMIixvYZD-F1alC0w {o,o} |)__) -“-“- O RLY?
I really do like the material design buttons. but when you click far enough to the right on a button, the wave doesn't reach all the way left. arg! Not many material design frameworks do that right :&lt;
No, I just said "you can't easily understand specific kinds of programs without generics". By not specializing your types unnecessarily, you can eliminate whole classes of bugs. Anyway, since you seem to believe that it's optional to have generics in a good language, here are some examples of things that absolutely require generics: * In order to parse text, the correct tool is obviously parser combinators. Unfortunately, many programming languages don't provide a parser combinator library. Luckily, they are relatively easy to implement. Except in Go, because it lacks generics. * The same as above, but pretty printing or serialization instead. * The previous two, but with binary data instead. * The first two, but with JSON instead. Or XML. * We need to make a lot of forms. The correct tool is an Applicative interface. Languages don't provide that, but it can be implemented, except in Go. * We need to do stream transformations. Combinator library (see Haskell's `pipes` for an example). Except in Go. * Need to use [equational reasoning in practice](http://www.haskellforall.com/2014/07/equational-reasoning-at-scale.html). Composable types, which don't exist in Go. * Proper error handling? Okay, that might be cheating, since Go people don't care about that. * Randomized testing? No thanks, says Go, because that requires generics. * Working with immutable data? Lenses require generics, so that's not practical in Go. * Need to work with collections? Then you should probably abstract some commonly used collection functions... except in Go.
Deployed it on my own server, just for lulz.
the size itself.
Did the binaries of your own executables go up? Or only go? I think that's a silly way to determine efficiency...
because remasis told me to! I'll add the option to not use mongo and dump to files if people actually want it.
my bad. Fixed in in mainline thanks to opennota.
I did look at it. I also went through the "getting started" guide. It gave me a pretty rough idea of the workflow, but it would be cool if it demonstrated an example of a deployment cycle (repository structure, deployment, make a post/content-change, redeployment, etc). I've run several blogs on several platforms, and I've written several blog engines. I still don't know much about static site generators (what they are, why they're good, how to use). EDIT: I know Hugo is fast, and I understand that it is simple (it's a static site, after all), but what does deployment look like? Is it suitable for a blog? What are some good hosting providers, etc. These are the questions I'm hoping to answer in my experimentation. If you can provide some answers now, I'll have less experimentation to do, and I'll probably become a contributor faster. :)
Yes, Go 1.4 is better than Go 1.3.
The size of the go tool has no direct correlation to the size of the programs produced by the compiler/linker.
So, using that measurement rule, desktop computers are not as efficient than notebooks because they are bigger? Or it because you are trying it on windows and noticed latest windows versions need 15 Gb on disk to do the same old stuff and you are interpolating that to Go?
hmm.. any examples (except simpified "for" syntax and gc)?
One of the low hanging fruit reason s for the size increase is go.exe does more. It may have the same command line options but there could be better optimizations built-in to the compiler for example. I have done no research on the matter, so this is just guessing on my part. The thing is do your exe behave worse or better than before?
My bad. I apologize.
this is for 64 bit go taken from official go download location: https://golang.org/dl/ -&gt; https://storage.googleapis.com/golang/go1.4.windows-amd64.zip
My life would be easier if this project didn't exist. :-(
Welcome to the world of 64bit. My guess is that you know nothing about how compilers actually work. The added support and complexity of the memory addresses for the garbage collector and other various features is more than likely the cause for increased file size. File size does not determine efficiency. 
What things need in windows/linux and no need in mac os x? :) * windows 64bit: 9M -&gt; 21M * linux 64bit: 9M -&gt; 21M * darwin 64bit: 9M -&gt; 11M
thanks, not sure but thanks.
Haha - I love that 9.6T for emacs...it *is* a joke, right?
[surf](https://github.com/headzoo/surf) is a great package using goquery and cascadia that could use some love.
Why the hate, man? emacs is an extremely competent OS, and will take over the desktop as soon as it gets a decent text editor. 
lol wut edit: This comment made a lo more sense before the OP edited his submission to include formatting.
Just for my own curiosity: why, other than the support from Oracle's side, would you use Oracle DB?
I get something seriously weird when I try this in C too: #include &lt;stdio.h&gt; int main() { long sum = 0; int i, j; for (i = 0; i &lt; 100000; i++) { for (j = 0; j &lt; 100000; j++) { sum += i + j; } } printf("%ld\n", sum); return 0; } The fastest I can get this to run with gcc (with -O3 even) is in 2+ seconds, slower than both Java and Go. Clang with defaults runs very slowly too, but with -O3 must know how to unwind the loops because it runs instantly.
totally agree that this is not meaningful to real problem. But just curious is there a way to improve go perf in this case and why java is faster here.
maybe because you used different number? My example j &lt; 10000, not j &lt; 100000.
This benchmark is stupid.
That's of course completely (and always) true, and for that reason I think having an Oracle DB go driver is great. However, are there any real advantages of using Oracle DB on its own?
Ah ok, your inner loop is j &lt; 10000. Sorry, can't read.
You will have to look at the generated code for both to get any sense of what is different here.
Java is likely faster because of the JVM -- it's optimizing this code during runtime. I do not believe Go does anything of the sort at the moment. I personally don't see any reason to investigate why this is faster. You're comparing 15 years of JVM optimizations on a trivial and commonly used double-for-loop construct to a younger language that has other concerns. Edit: if you really do care, look at the Java bytecode and the assembly Go generates. You may not see an appreciable structural difference here, in which case Java's JVM is performing magic. 
While it might seem stupid and too simple, it still demonstrates something about tight loops, so dont defensively dismiss it all
Take a look at: https://github.com/mattn/go-oci8
im looking for project also. preferably on generics or related areas. https://github.com/anlhord
I wander if JWT are any better then macaroons (libmacaroons)?
I understand what you're trying to say... but it still isn't useful. This is too micro to be useful, and so small as to be subject to far too many whims of the compiler, optimizer, and details of the machine this is executing on to be relevant. In either language the for loop overhead is as close to zero as makes no difference. As it happens the other day I accidentally benchmarked an empty loop myself. (It had a body that was inlined away entirely.) Evidence suggested each loop was running in 2-3 cycles. Maybe on his machine Java is running in 2-3 cycles per loop and Go in 4. In neither case does this matter. In both cases this is still far faster than Python will get. In fact this is a benchmark even Javascript might be good at on a JIT. Nevertheless, Javascript is still a slower language. This isn't a useful benchmark, even by the low standards of benchmarks.
DM myself or Traetox if you want an API key to push to our database so your entries show up on shellsforshits.com
[It cannot handle simultaneous logins](https://github.com/mattn/go-oci8/issues/13). I found it buggy when using more than one connection or more than one go routine talking to that connection. But other than that it works very well. I re-wrote a SOAP price quoting system (serving 14M quotes a day) in go and it has been in production since the spring and it is rock solid. In fact when there was an NFS screw up, and the file system went away, the pricing servers just kept humming along not carring at all. Ditto when the QA environment's DB went down. But that resiliency is due to the structure of the pricing server. Since we never change historical prices and all newly inserted prices have to have future effective dates, the go pricing server simply has one go routine dedicated to waiting on a random timer, and then re-loading all DB tables into mem. All actual price quotes are served by doing a few array lookups (no db ops). The former pricing server was written in java, and it walked through a tree structure stored in an Oracle DB. So speed comparisons are laughable. The worst case scenario (querying all SKUs) used to take ~62 seconds and now take ~60ms. Individual queries are sub millisecond. So I'm happy with its speed and stability, but test it thorougly, and understand its limitations. If you plan to have multiple connections / connection pooling / multiple readers / multiple writers then expect panics.
It is stupid because it does no work, it can literally be optimized away entirely. A sane optimization would be simple to set sum to the grand total and be done with it while removing both loops and any reassignments. 
Microbenchmarks are stupid, but this one more than most, you created an internal loop that can properly be optimized away entirely... nothing uses sum while it is in flight, so it would be correct to just set its to its end value... 
Posting here not because this is anything serious (it's very crappy). More because I found it fun to write and thought I'd share.
Very interesting, do you know ocilib? I wonder if a port to go would address the pooling issues on go-oci8
Good point, thanks! (PR accepted if you feel like it.)
Would love to see the same (or similar) comparison when Go 1.5 is released! (With the graphs overlaid would be nice, as Zikes suggested.)
imo: the go's garbage collector is the reason for this slowness.
Just had a play, really nice :)
We managed to kill it.
Please don't kill it. I posted this on Hacker News, expecting less of them than /r/golang, but here it is just in case: &gt; A not-so-subtle reminder to people who are "curious" and want to break things: &gt; &gt;It's open source. Install it locally and break it to your heart's content. If you're flooding the public server, you're just ruining it for everyone else. &gt; &gt;Yes, there are no spam controls. Yes, there are bugs. This thing was built in a couple of days on my free time, and here I am sharing it with you. Please find bugs locally, fix them, and send a pull request. &gt; &gt;Enjoy. :) I'm off to sleep now, if it dies it stays dead.
I wasn't trying. Awesome idea, shazow!
For some businesses that's enough. A large number of organizations have standardized on Oracle. Pulling in a second database platform would mean hiring, training, new maintenance and so on. Of cause many of the same organizations have already picked a "standard" development language and is just as unlikely to change that as they are changing databases. 
A lot of this is true and false at the same time (if not blatantly false). It might be true that some kind of generic programming is needed (not generics as template like generics) but it is false to say it can't be done in Go. Go does allow for a brand of generic programming. And you missed Nate's point. The point being that if you use generic programming as a code writing convenience, then you don't really need it. He is not saying that generic programming is useless. And type parametricity is not necessarily the right model for multicore programming by the way and is actually more likely to introduce subpar performance for your algorithms, contrary to what you were saying. It is just that the design of Go is aiming at simplicity. You don't need complicated math-derived concepts such as monads and applicative functors to create great programs. Even better, applicative functors can be created easily, even in Go without being aware about it. If you really need Haskell it is there for you. But I don't want its complexity and neither do most people. I have other problems to tackle and we just need a simple language to be really productive. There is a beauty and power in nimbleness done right. Anyway, people are free to understand or not, but there is nothing wrong with Go. People have to control their desire for complexity a little. While Go will keep improving incrementally in its own way, given the problems it needs to solve and its future goals.
Don't count the 'print' time, that has nothing to do with your loop. In fact you should always calculate the time in a var and print it later.
I was working on OCI bindings for an internal company project, but I just didn't like how the project came together so I scrapped the direct bindings and went with a restful model. I handle the actual database communication with Java, and exposed a restful interface that my Go app used to query and update database data through. If it's not native Go, the library bindings always seem out of place in the Go ecosystem. The native PG driver works great from my limited testing, but I think it would take a concerted effort from Oracle directly to create a native Oracle driver for Go. I don't think that's ever going to happen.
Suggestion: trivial spam/flood control in the form of proof of work tokens for initial connect and for messages posted above a certain rate. Ban anyone who has an invalid or missing proof of work token. Essentially this makes attackers waste more cycles than they consume on the target server.
[Changelog](https://github.com/visualfc/liteide/blob/master/liteidex/deploy/welcome/en/changes.md).
"trivial", really? :P Also this would require a custom client experience, won't work for random people who just type `ssh chat.shazow.net`.
Go 1.3.3 on linux here. You should help the compiler i guess. Changeing sum += i + j to sum = (sum + i + j) improves 25% the performance here 
If `claw` is as buggy as `bone` and the author deals with bug reports the same way he does for that project, then I think I'll stick with other solutions.
... i always debug my project ! I don't know why you say that. And every bug that people report on bone have been solve ~15min after.
Uh go has a parser.. For the go programming language with pretty printing. Go has XML and JSON parsers. Go does stream transformations just fine unless you're talking about something other than a stream of bytes. Go actually has built in randomized testing. And composable types. The argument about collections is valid, I wish there were better ways to handle that... But that's probably the only place generics really are needed, but it's not been a big hurdle in my two years of using go. I don't know what lenses or equational reasoning or applicative interfaces are, though I suppose I could go look them up. But given that you seem to desperately want to dislike go, I don't think we'll get anywhere. I'll keep enjoying building useful robust software in go. 
Can anyone hook me up with an Arch package for 1.4? EDIT: Kidding, of course. Perks of a bleeding-edge distro :)
wat
I'm specifically referring to things such as `bone` being [essentially broken](https://github.com/squiidz/bone/issues/5) when you first announced it, which was a bug that even the mildest form of testing would've caught pre release, or issues such as [this](https://github.com/squiidz/bone/issues/1) being closed without a comment.
Yeah, somebody on the Slack gophers channel pointed this out to me, but I didn't have an implementation to link to for the post. I wrote a basic one and will push it to github in a bit. Update: https://github.com/dgryski/go-cuckoof
Something to start off with. Its very basic. https://github.com/sudharsh/henchman
Hash-based proof of work is pretty trivial tbh, simply make clients find some value that, appended to their request, makes its hash output (interpreted as a number) smaller than some preset value. However, I do take your point about compatibility with raw ssh, so point is likely moot: I don't think ssh clients can be given arbitrary algorithms to perform in this way? However, I wonder can you specify a ciphersuite for clients that is very costly to initialise? 
&gt; Uh go has a parser.. I'm talking about a combinator library for parsing generic text. Compare to things like Haskell's parsec. A parser combinator library is the right tool for the job of parsing things. &gt; Go has XML and JSON parsers. I'm not talking about something that converts text into XML/JSON structured types, I'm talking about something that converts XML/JSON structured types into something nice to work with. See Haskell's aeson library. &gt; Go does stream transformations just fine unless you're talking about something other than a stream of bytes. I am talking about more than just a stream of bytes. I told you to look at Haskell's `pipes` for an example, and it handles more than streams of bytes just fine. &gt; Go actually has built in randomized testing. Whoops, I should probably have looked that up. &gt; And composable types. Not in the 'equational reasoning at scale' manner. &gt; The argument about collections is valid, I wish there were better ways to handle that... But that's probably the only place generics really are needed, but it's not been a big hurdle in my two years of using go. Actually, the collections argument was the weakest of them, which is why I placed it in the end. &gt; But given that you seem to desperately want to dislike go, I don't think we'll get anywhere. I don't desperately want to dislike Go, I just use generics in pretty much all my programs, which means that I *really* don't get how you can write programs efficiently without generics.
Thats a perfect starting point, thanks! Im really surprised there isnt a more mature project that offers that functionality in Go. I feel like this is the perfect domain.
You don't need generics as template-like generics to have a functor. You need Higher order functions and the ability to discriminate between types. Actually depending on your definition of functor as a mere group homomorphism, you just need a generic datatype. Haskell does it differently as there is a tighter link between data and code there. But the point remains that it is possible to have similar behaviour in Go (because an interface is effectively a lattice of types). I think you are seeing everything through the Haskell lense and it's fine. If Haskell suits your need, why not just use it. Go does not follow Haskell's or C++'s or Java's or any other models blindly and I am grateful (very) for that. Designing a language is not about making a patchwork of whatever you find in the open. And you are making claims about massive code duplication in libraries when you clearly does not know Go enough. At least you should have a look at the standard library and judge for yourself. Go solves practical problems. Haskell is a (quite) fine product in terms of language theory but abstracting everything just for the sake of it is not the way to Go :). That's fine though if that's what you like/need. If we, gophers, wanted that, I guess we would have chosen Haskell. Ah and also about type parametricity (I'm employing the term loosely here, I don't mean function parametricity, maybe parametrization would be a better term) of your datastructures, you have to explain to me how it may not affect performance wrt to data access and the memory hierarchy. Anyway, I am not sure of the goal of this discussion. I am not trying to convince you that template-like generics are not good. Or that Go should replace Haskell or whatever. Don't feel threatened lol. I am just saying that in a practical way, in Go, it is rare that we need them and that it might not be such a good solution for us, at least not implemented by mere transposition. If you think Go is not simple, well, I can do nothing about it. :) But it definitely is a simple and easy language to use. Typically, because I don't need to understand any new abstract notions to code effectively with it. 
From the website: https://heapanalytics.com/docs/server-side Track Heap allows you to send custom events from any of your servers. A server-side event can be created by issuing a POST to https://heapanalytics.com/api/track with a JSON body. Identify You can also assign custom properties to any of your users from your servers. This can be done by issuing a POST to https://heapanalytics.com/api/identify 
Really great book. Recommended to everybody. 
&gt; You don't need generics as template-like generics to have a functor. You need Higher order functions and the ability to discriminate between types. Actually depending on your definition of functor as a mere group homomorphism, you just need a generic datatype. A functor is not a group homomorphism, it's a category homomorphism. Anyway, to make this simpler, could you show me an example of a non-built-in functor in Go? &gt; Haskell does it differently as there is a tighter link between data and code there. But the point remains that it is possible to have similar behaviour in Go (because an interface is effectively a lattice). I don't know what you mean here. Could you explain? &gt; I think you are seeing everything through the Haskell lense and it's fine. If Haskell suits your need, why not just use it. Go does not follow Haskell's or C++'s or Java's or any models blindly and I am grateful (very) for that. I do use Haskell (among others), but people keep writing about Go on /r/programming, and there is no /r/lolgo subreddit similar to /r/lolphp. &gt; And you are making claims about massive code duplication in libraries when you clearly does not know Go enough. At least you should have a look at the standard library and judge for yourself. I'm not saying there is massive code duplication, I'm saying that in order to do the things I mentioned, there *would be* massive code duplication. Since people don't want code duplication, it is effectively the case that Go *can't* do these things. &gt; Go solves practical problems. Haskell is a (quite) fine product in terms of language theory but abstracting everything just for the sake of it is not the way to Go :). That's fine though if that's what you like. If we, gophers, wanted that, I guess we would have chosen Haskell. Haskell solves practical problems too. We just use the right tools for the job and abstract in appropriate amounts using non-leaky abstractions, while Go favors duplication of effort (no parser combinators, for instance). &gt; Ah and also about type parametricity (I'm employing the term loosely here, I don't mean function parametricity, maybe parametrization would be a better term) of your datastructures, you have to explain to me how it may not affect performance wrt to data access and the memory hierarchy. Well, I was saying that parametricity didn't affect performance, not that parametrization/generics doesn't. Most languages with generics don't have parametricity, but if you are a bit disciplined you can recover it. Recovering parametricity doesn't hurt the performance. Parametricity is just a property of the type system and not a structure, which means that it obviously can't hurt performance. Anyway, generics may or may not hurt performance depending on how they are implemented. In particular, instantiation can't hurt performance while erasure requires boxing, which obviously hurts performance. Many languages (Haskell, Java, etc.) use erasure (erasure automatically guarantees some forms of parametricity, by the way), while others (C++, for instance) use instantiation. Also, given that Go already has generic data structures, I don't *necessarily* need more of them (again, that's why I placed it last). It is not so much the data structures I want generic as the... hmm... whatever you call the things that are built up in combinator libraries. &gt; I am just saying that in a practical way, in Go, it is rare that we need them and that it might not be such a good solution for us, at least not implemented by mere transposition. The thing is that it isn't necessarily that rare that you need them, you just don't notice how much code you could save by having them. &gt; If you think Go is not simple, well, I can do nothing about it. :) But it definitely is a simple and easy language to use. Typically, because I don't need to understand any new abstract notions to code effectively with it. You can code in Haskell like you would in any imperative language. The thing is that people who use Haskell realize the superiority of the "new abstract notions" and as a result want to use them. There is nothing in principle that prevents you from writing imperative Haskell programs, it just feels very silly when there are better ways of writing it.
Hey all, I'm writing a web service that allows simultaneous editing of a document, similar to google docs. It needs more testing but currently functions so I figured I'd put it out there. I have a "working" demonstration of this service in action at: [https://megrim.uk](https://megrim.uk), but it's currently hosted across four ARM micro computers underneath my sofa so expect them to melt under strain. The service is meant as an alternative to existing open source options such as ShareJS and TogetherJS, I thought Golang seemed a great language for this sort of problem.
I am using emacs with the following packages and configs: go-mode company-go go-eldoc go-projectile go-snippets helm-go-package ;; go-mode (setq gofmt-command "goimports") ;; set company popup delay in seconds (setq company-idle-delay 0) (defun my-go-mode-hook () (local-set-key (kbd "C-c m") 'gofmt) (local-set-key (kbd "M-.") 'godef-jump) (set (make-local-variable 'company-backends) '(company-go))) (add-hook 'before-save-hook 'gofmt-before-save) (add-hook 'go-mode-hook 'my-go-mode-hook) (add-hook 'go-mode-hook 'go-eldoc-setup) (add-hook 'go-mode-hook 'company-mode)
I hear you. I use PyCharm and RubyMine at work. A dedicated Go IDE from Jetbrains would be amazing 
Add me to the IntelliJ Idea list. It certainly needs work, primarily when writing code based on structs (the completion does not kick in unless you enter a colon or curly brace and then move back in front of it and start typing again). Also, false positive type errors are annoying when adding function names as arguments. However, overall, it works very well and I'm able to get a lot done with it. I especially like being able to run go vet and build from the interface, and being able to restart the entire process easily.
Wow, very detailed. Thanks.
Cool. Heap Analytics is awesome. BTW, you should make it close HTTP response bodies (e.g., https://github.com/augurysys/heapanalytics/blob/master/client.go#L77-L83). From the `net/http func (*Client).Do` godoc: &gt; Callers should close resp.Body when done reading from it. If resp.Body is not closed, the Client's underlying RoundTripper (typically Transport) may not be able to re-use a persistent TCP connection to the server for a subsequent "keep-alive" request.
That is a convention set by stringer (https://godoc.org/golang.org/x/tools/cmd/stringer). I personally wouldn't want the default to affect all structs as some packages / files can get pretty large. It would also be nice if it could work at the package or file level. 
liteide
You should start by reading the documentation for the [Reader interface](http://golang.org/pkg/io/#Reader). type Reader interface { Read(p []byte) (n int, err error) } &gt; Read reads up to len(p) bytes into p. It returns the number of bytes read (0 &lt;= n &lt;= len(p)) and any error encountered. So the Read method which you define on MyReader must fill the slice (p in this example) with A's, and return len(p) and nil.
Vim and Vim-go here as well. I started with Sublime + GoSublime but I decided to take the "environment switch" (.NET to Go..) as an opportunity to learn something else I have always wanted to learn. After a few months of forcing myself to use vim for my Go development, I am actually pretty decent with it now and enjoy the lightweight environment :)
I'm using the same, but the Go plugin is buggy, missing features, and it's awfully frustrating at times.
I actully learned Vim at the same time I started with Go because there was no real IDE for the 1.0 release. Best decision I ever made. It's definately worth the effort.
Emacs wit gocode, oracle and a couple of other modules. List is here https://github.com/emacs-tw/awesome-emacs/blob/master/README.org
Soon as LiteIDE makes it as easy to import external packages as GoSublime I'm sold. (CMD + . + P)
Me too!. I was using previously Sublime for Go development, because the Vim support for Go was not decent. However I really love Vim and was using it for anything else. One day I decided to start on vim-go just to have a great experience. Other people contributed to it to. Now after 8 Months I see that vim-go is really in a good shape and many other people using it too, which makes me happy! :)
good point, I thought its just for Get()
You're asked to write a Reader implementation that always emits 'A'. That is, whenever Read is called, it always writes 'A' into the provided buffer. Here is a a solution: func (reader MyReader) Read(b []byte) (int, error) { b[0] = 'A' return 1, nil }
LiteIDE or IntelliJ with the GO plugin. 
How do I compile using this IDE? In lite I just click build but I cannot figure it out for IntelliJ. 
Absolutely second to none, has been my workflow since vim-go released. Sublime + GoSublime comes in close second in terms of features.
Emacs. Works very well. 
I'm using 0.9.15.3, which seems to be the last stable release. I wouldn't even use the plugin if my workflow wasn't already fully integrated with IntelliJ.
Okay, but… this isn't safe. Writing is handled via: // If there were modifications, write them back to the database if err == nil &amp;&amp; todosMod != nil { b, err := json.Marshal(todosMod) if err == nil { err = ioutil.WriteFile(db, b, 0644) } } `ioutil.WriteFile()` [opens the file with `O_TRUNC`](http://golang.org/src/io/ioutil/ioutil.go?s=2520:2588#L66): func WriteFile(filename string, data []byte, perm os.FileMode) error { f, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm) if err != nil { return err } n, err := f.Write(data) if err == nil &amp;&amp; n &lt; len(data) { err = io.ErrShortWrite } if err1 := f.Close(); err == nil { err = err1 } return err } This leaves several failure modes. The most obvious is that `O_TRUNC` destroys the file on-disk before the new one is written and flushed to disk, so a `SIGKILL` from the outside or panic from a different goroutine is guaranteed to destroy the data. A safer way to do this is to use a second file: `open(2)`, `write(2)`, `close(2)`, and `rename(2)` the replacement file over the original filename. POSIX [guarantees](http://en.wikipedia.org/wiki/Rename_\(computing\)) that `rename(2)` is atomic, meaning that the database filename will a) always exist and b) always point to a complete copy of the database. This process can be interrupted by anything (including a power failure) without corrupting data at any point in the process. Given the focus on safety, I was expecting something like this: if err == nil &amp;&amp; todosMod != nil { // Open a temporary file to hold the new database var tempDb *os.File tempDb, err = ioutil.TempFile(filepath.Dir(db), filepath.Base(db)) // Write the data to the new file if err == nil { enc := json.NewEncoer(tempDb) err = enc.Encode(todosMod) } // Close the file if we succeeded in opening one if tempDb != nil { closeErr := tempDb.Close() if err == nil { err = closeErr } } // Rename the temporary database over the permanent database if err == nil { err = os.Rename(tempDb.Name(), db) } } 
hey guys look, an emacs user!
Eclipse with [GoClipse](https://github.com/GoClipse/goclipse)
Same here 
The golang.org/dl binaries *should* be installed to `/usr/local/go` as per the documentation.
The exercise just needed a type that you could hook the method to, and because it was so simple it didn't need any fields. Any real reader would likely have some fields. For this example you could add a field that contains the the letter, then change the reader to always return that letter instead of 'A'.
Ahh, thank you so much! 
Wow nice work!
Using LiteIDE as well. Sublime Text with Go plugin works well as well but costs money. LiteIDE is free. IntelliJ with GO plugin is kind of buggy I couldn't get used to it. Zeus IDE has Go support, I used it for a bit, but then it costs money as well. In the end I keep coming back to LiteIDE
This but with YouCompleteMe. I've used LiteIDE a bit for doing Go stuff on Windows, it's reasonable enough. Still prefer vim though.
I don't have any experience with deployment tools, but maybe this is useful... I wrote a library, just for fun, last year called geto[1]. It's very generic in that it is meant to execute any arbitrary task (and get results) to some number of machines and the commands are executed over ssh (and only ssh key authentication is supported[2]). I don't know how much sense it makes with the other available deployment tools out there, but it seems like the geto library could be used to build one on; the fundamental idea was to have the target nodes have no special code or setup (other than the ssh keys). There's some hopefully helpful documentation on the github README. I'd be happy to help out if anyone is actually interested in using it. [1] https://github.com/bgmerrell/geto, it was my first Go program so it may be a little rough. [2] Well.... it used to be supported, a change to https://code.google.com/p/go.crypto/ broke ssh authentication (rendering geto non-functional) a while back; but it should be pretty darn easy to fix.
It's very different. If we can say that vim-go is for command line fans and go-sublime is for notepad++ fans, you could say that LiteIDE is for eclipse fans, but without a lot of the bells and whistles... hence the Lite in LiteIDE. Coming from the world of Delphi, I've been using it for a month or so now and like it. A majority in the Go community are in the hard core command line camp and don't like it. Some even consider it unmanly. :) 
Thanks! There's a tool out there called cute chess cli. Check out https://github.com/michaeldv/donna/tree/master/scripts
Doesn’t setting `GOROOT` solve that?
Which of those modes would you most suggest looking into? I don't recognize most of them.
I built [this website](http://60plusadventures.com/) using Beego as per an earlier version of this book. There is a lot to learn, but once it starts to click, productivity and flexibility really benefit. The associated CS50 project has been submitted, but I still plan to add features and do some refactoring over the next couple of months. Check out the [source code on GitHub](https://github.com/emadera52/sixty). 
So cute chess coordinates the engines via UCI? Also is there any reason why you use a lot of raw strings in your code?
I use it for encoding/decoding UNIX timestamps to/from JSON and MongoDB. time.Time is marshalled to RFC date by encoding/json. Thanks for the Gob comment I made the changes, also removed pointer receivers where not needed.
I used to install go to my home directory and pointing GOROOT there. Everything works perfectly welll :)
Check out https://github.com/alecthomas/gometalinter It will install, run and normalize the output of all linters I'm aware of. Unfortunately none of them perform the deep static analysis you're imagining, though structcheck et al do more than most.
Yup.
The last two releases I noticed sort of messed up some completion. For instance I would press the dot on a core package struct and it was slow in completing or resolve chained methods.
&gt; check my code for any places where a value could be null I've actually wondered if such a mode would be easy to add to the [Oracle](https://docs.google.com/document/d/1SLk36YRjjMgKqe490mSRzOPYEDe0Y_WQNRv-EiFYUyw/view)
This is a good point, but why do not use any key/value permanent storage where all safe methods already exist. It's much easy, then reinvent the wheel
I use Gedit with an external shell for pretty much everything. I have started writing a Gedit plugin which bundles some existing go tools, but it's still way too early to be used.
actually i was gonna fork brackets most likely, jetbrains has really sweet ides but their java plugin system is just gonna take me forever to work with, im not a java dev
Ah, thank you. That's been on my wishlist for a while now.
Me too
This code from the example is not effective because we have only one process for running and writing (ProcessJob). These are not concurrent processes, all running sequentially. Much more effective to use concurrent processes for running and a channel for writing results.
Vim all the way
Isn't brackets more of a text editor? I'm using sublime for go programming. Intellij/Eclipse/,Visual studio community would be better as an IDE I think.
Working this out was actually somewhat confusing due to my use of gvm. In the Run/Debug Configuration you will need to include the GOPATH and GOROOT environment variables as they are shown in "gvm pkgset {your go version}". Then set the "Script" and "Working directory" to obvious values, and the "Output directory" to a project sub-directory that has been added to .gitignore (or wherever else you want it for development). "Build before run", "Single instance only", and "Run go vet before anything else" should be checked. In order for this to work smoothly, I also had to add a command to "Before launch: External tools" - * Click the plus, then click the plus in the pop-up. * Set "Name" to "rm previous build". * Set "Group" to "External Tools". * "Description" should be obvious. * I have "Sync files after exe...", and "Open console" checked. * "Show console when..." options are unchecked. Tool settings - * Set "Program" to "rm". * Set "Parameters" to "{the location of your build file as set in the Run Config above}". * Set "Working directory" to "$ProjectFileDir$". (I don't recall if this helps or works, but I've left it since I got it working.) * Click "Ok", then "Ok" again. All that's needed then is to click on "Run".
Acme.
Likewise I've settled on LiteIDE. The features I need without the overhead of something like Eclipse.
I haven't noticed slow completion for Go. I did have a problem with JS, but that was due to how I was setting up my scratch projects (api and front-end within one repo) combined with how I was configuring "Project Structure". Once I configured things correctly, everything worked quickly again.
Good question, I don't have idea. Maybe Amazon should take care of this situation
About sqlx integration, that would be awesome, but I'm not sure how to implement that. If you like generators, take a look at https://github.com/mijia/modelq, looks super nice!
To be clear, this is not a "don't use 3rd-party libraries" post. It's all about evaluating needs and costs; pros and cons. It reads more like a commentary than an argument. About dependency management (which does deviate from the title a bit, but is certainly related), I share a similar sentiment about high-quality releases and building trust in the Go community: http://mwholt.blogspot.com/2014/03/maybe-go-without-dependency-management.html.
(More direct link: http://golang.org/pkg/testing/#hdr-main)
This rules! I was going to have to figure out this crap myself sometime this week, so nice timing. Unfortunately, go get fails with this error: imports labix.org/v2/mgo/bson: exec: "bzr": executable file not found in $PATH
You have to install bazaar and mercurial (both are version control systems like git) to properly use go get with all kinds of weird packages
First time I've encountered that issue. Anyway, thanks. Brewed some bazaar and go get worked fine.
This is what I love about the Go community. It is one of the only programming communities that I have been a part of that as a whole recognize the cost of pulling in third party dependencies. I still write Ruby every day and love many parts of that community as well. But one thing that immediately bugged me was how willy 'nilly everybody was about pulling in this gem and that gem without any real consideration on the impact it may have on your app.
Wow. I didn't even catch that. I'm assuming this made it into 1.4?
"If it’s important enough to log then you should always log it." That seems way too generic, it certainly hasn't applied where I've needed it. Especially in a language that still lacks mature debugging features, so you'll often want to have lots of debug-related logging that you will just turn off before you ship it. Sometimes you should clean up all those debug statements, sometimes you'll want to be able to toggle them to find out why something works in dev but not prod. As you scale up, you also will find how valuable it is to be able to do things like have a view of only critical logs, where you don't care at all about standard usage but still want to see the more important things. Of course at that point you'll find that logging via text is very limiting and be better off logging in something like json so you can also do things like "show me all the logs from this user" or "show me all the logs from this machine" With that said I do agree with the overall mesage of the blog post, especially coming from a perl background where the availability of things to pull in is part of the selling point of the language. It's far too easy to find yourself depending on libs that have either been abandoned, or developed so far from when you last used them that you have to decide if its worth refactoring large parts of your code just to fit the new way to do it, without knowing how much of a shelf life this new way has.
its: http://golang.org/pkg/testing/#hdr-Main (capital 'M').
&gt;If Go threads in Reddit or HackerNews are any indication, nothing provokes feature-loving hackers into a rage like the existence of a minimalist language that they’re not obligated to use. This made my day.
This needs more detailed explanation. Real example.
This seems to be a conflict over how logging should be handled. For a number of years (primarily due to resource constraints), logging was done via configurable levels where you should only log X, and if I need more details I adjust the logging level and now both X and Y are logged. Now that resources are (relatively) cheap in combination with more complex software (concurrent, distributed, etc), a common practice is to always log everything, and you simply use tools for filtering/viewing the logs after the fact to narrow things down. This makes logging tools very important and if you don't have them it can be difficult to diagnose problems with all of the extra log information. Obviously logging everything is "wasteful" as far as resources, but it eliminates the need to go back and change the log level and then try to reproduce issues again (if your logging is not "detailed" enough due to the current log level). Just thought I'd provide some insight into the reason why someone would say something like "always log it" :)
Links are kind of not obvious, here's the essence: func TestMain(m *testing.M) { // your func setup() retCode := m.Run() // your func teardown() // call with result of m.Run() os.Exit(retCode) } And you can't use `defer` because `os.Exit()` won't run it.
I've found the opposite. You need logging most when you turned it off and it's too late. Storage is cheap and tools can filter log levels at query time. There's a balance to strike, but I favor logging over a silent app Especially as programs scale, since it's at scale that the most improbable events occur.
Actual pretty good blog entry. The absence of generics was bugging me when looking at go, but this provides a reasonable workaround, especially when considering all the good features that Go provides out of the box.
Search for the first instance of "Main" in the linked page.
So it runs all tests at once? No chance to insert cleanup between tests? Is this significantly different than just doing setup in init functions? Still pretty nice for tear down i suppose. Thanks for the example. 
thanks!
Wait, writing type-specific wrappers to `interface{}` or `void *` data structures is such a good call. Why have I never done this before?
OK has one of these raging hackers, let me explain my position for a minute. I *want* to use go. I like the syntax, and I want goroutines. I like the struct/interface system. I love statically typed first class functions. What I WANT is genetics. Ffs, if I wanted C++ I'd write in C++. But generics give you a lot of expressiveness in statically typed languages that I feel is missing in go- especially as I can't generically wrap the typed facilities (goroutine spawning and channels) and as a result have to violate DRY in projects that reuse common patterns. Easy example: write a generic future mechanism: a function that takes a proc P, spawns a goroutine with that P, and returns a channel which will contain the return value of P when it completes.
Yup. DRY is the biggest thing I miss with Go. It's vital to have frank discussions on any tradeoff in a programming language to learn the strengths &amp; weaknesses of your tools. ATM your comment is downvoted below zero, which is disappointing. I wonder if the new `go generate` could be used to auto-implement this blog post's workaround? Templates in usespace are not an optimal solution but it should work well enough, if you don't mind autogenerated code.
Yes, cute chess basically acts as UCI bridge dispatching and synchronizing command flow. I am using raw strings because that's what they basically are. Not sure why do you think there is a lot of them though.
If you want setup/teardown between tests, do it in your TestXxx() functions...
The proposal in the post works only for very simple container types. What I feel go is begging for is LINQ and Rx over channels. map, filter, reduce, groupby, throttle, etc.. shouldn't need to be re-written for each channel type. 
Library authors will just stick a number at the end of the existing name when its time for a major change: Foo -&gt; Foo2 -&gt; Foo3 
There's [this](http://clipperhouse.github.io/gen/) , which is a similar idea.
What do you mean by subtype ? And no, you would have to define a string type which is nothing more than an alias for the builtin string type I guess. (type MyString string) then define your methods on it. The thing is builtin types should be a mere building block for you to create your own types. We shouldn't overuse them. 
It sounds like your function should take anything that fulfills Stringer... so build a type on top of string, and it should have String(), then it will work with future types you haven't even thought of yet. Won't be able to pass in a naked string, but will have type safety. If you want to pass in a naked string (not recommended), you would have to take an interface{} and then check using a switch on .(type). 
It would help if you actually posted some (real) code demonstrating your problem. In the absense of such code, these are my assumptions: * by subtype, you mean `type S string. Here `S` is a completely *new* type. It's not an alias or extension of `string`. * by `string literal`, you mean the builtin `string` type. A `string literal` is a very well-defined thing http://golang.org/ref/spec#String_literals and they are untyped until you use them in some context that demands a type http://golang.org/ref/spec#Constants &gt; The idea that you can use interfaces to mimic generic-like behaviour is thrown about all the time, but I keep hitting cases where the language's design seems really incomplete in this area. IMO, the first question you should ask yourself is whether or not you actually *need* generics. In most cases, you're probably only ever going to have one implementation, and for that any kind of generics is overkill and is simply there to increase complexity. &gt; One of them right now is that I have a sub-type of string, and I have some functions that will be used on this sub-type and on strings, but as (as far as I know) native string has no methods attached I can't write an interface that accepts strings and string-likes. Am I mistaken here? This depends on the actual problem, which isn't clear (to me). My first question would be: why do you want to accept two different types? What do you plan to do with (both of) them? It sounds like you actually only plan to work with your new type, in which case you don't need generics or interfaces. Just take a concrete type. But it's not clear why you want to accept `string` as well so maybe that's why I don't get it. Is it not good enough for the caller to convert their string to your type instead? They don't even need to do this if they're using constants ("abc" is untyped). &gt; So, to clarify, when I'm constructing my string-like from string literals in a "New" function, I want to be able to check that the string literal contains only a certain set of characters supported by the sub-type. This is something I'll likely only run on a string, but I will also be writing functions that may operate on string literals or my sub-type. Do I really have to write two copies of each function, one for strings and one for the sub-type? Continuing from my previous point... Is it not enough to convert between the types? &gt; Do any native types besides error define a method set I can use to base an interface upon? No, but your problem (as I understand it), also don't seem to require any kind of interface. 
This is the closest to an answer, thank you. So, to work around the fact that you can't define interfaces for native types and subtypes of native types (which is a pretty obvious wart, to me), there is an interface for "stuff with a string()" method, which won't actually accept strings because they have no methods. Seriously, the fact that most of the answers I get to this one of: * "make a function for each type instead" (never heard of DRY?) * "are you sure you really need generics?" (why interfaces if multiple dispatch isn't desirable?) * "make a custom type and cast everything to that" (..so, fake generics, because the language lacks them?) ...should be a hint that Go is missing something here. Thanks anyway. I guess Golang's design is a bit too "purist" in some areas, and while it means it's lean/mean/clear about certain things it also means there's a lot of stinking `interface{}` accepting functions in the wild simply because "generics are bad".
&gt; My first question would be: why do you want to accept two different types? What do you plan to do with (both of) them? Let's rephrase that as "Why would you want to accept something that fulfils an interface? Why not a function for every possible thing you might need?", and hope that it illustrates why this is actually a problem, and why platitudes of "just do it the Go way" ignore a very large hole in Go's interface design. &gt; It sounds like you actually only plan to work with your new type No, I want to work with anything that can be interpreted cleanly as a string of runes, in other words strings and things defined as `type foo string`. The fact that Go makes this impossible without convolutions, type-checks, and other nonsense is.. boggling. Why can't I define an interface that covers a particular type of built-in, like "arrays of runes" (string and subtypes) or "32 bit unsigned numerics" (uint32 and subtypes)? Why, put another way, must I make functions that accept `interface{}` and then do explicit type-checking and *runtime* errors when I should be able to say "strings and string lookalikes" and get type safety and coding convenience?
To be clear, I *am* doing `type MyType string`, and I *am* defining methods on this new type. But I'd then like to write functions that will accept `MyType` *or* `string`, and which only require that the value passed is an array of `rune`s, in other words `MyType`, `string` and any other types defined using `string`. Go has a huge hole here, instead. I can define an interface on something that has methods, but not something that is a particular value-type. As the built-in `string` has no methods, I can't define an interface for `string` that doesn't also accept absolutely everything; the empty interface. Given that Go has this idea embedded in it that "interfaces suffice instead of generics", the fact that there's no way to define interfaces on value-types means their interface system is incomplete. If you could define interfaces of this kind, then I'd agree; generics aren't necessary (although it's another question whether they're better/worse in some cases) to code productively. Right now I'm coding a bunch of nonsense that wouldn't be necessary with an interface covering `string` and `type whatever string`.
As best I know, you can't define a method on a native string, but you can define a function which accepts both strings and string subtypes, like so: http://play.golang.org/p/0jbbheSiL4 This might not be what you need, but it is something to keep in mind.
What kinds of methods have you attached to your named string type? Have you considered making a package with functions that just operate on raw strings (like path or path/filepath)?
You may not be able to define an interface that covers string, but it's trivial to write a type that holds a string and implements an interface. For /u/robertmeta's example, type String string func (s String) String() string { return string(s) } Which I think is an example of the third item in your list of things you don't like, but I can't get too worked up about the concept. Yeah, it's mildly distasteful to have to wrap regular strings like this when calling your functions: func frob(s String){ … } … frob(String("hello")) But it's not really a big deal.
I usually search on godoc first: http://godoc.org/?q=XBRL
Also a user of Go, I miss generics, but not as much as I thought I would. How much you miss them depends a lot on what you're doing, I think. Your greater point about adoption doesn't hold, I don't think -- Go is doing amazingly well. What I do, which is silly, is when I feel the need for a list or map utility function, I just write it out as a private function at the bottom of the file, yes over and over again for different types. It's...inelegant. But in practice it's a minuscule fraction of my programming time and doesn't really hurt me overall. Having used languages like Python and C++, I really, really, *really* appreciate the simplicity of Go. I'd rather not have generics than have to use Boost, or, worse, things inspired by Boost but not as well tested. ;) Obviously that's a false choice, but I appreciate why the Go folks are proceeding with caution. I do suspect Go will eventually get generics. Here's the basic "generics dilema", from a core Go team member: http://research.swtch.com/generic Notice that the problem with (2) is basically an implementation problem; if you can find an elegant, fast way to solve it, you get to have generics. I suspect (w/o real reason) that such a thing exists. Time will tell.
Because that's not the go way. Go is about as opinionated language you can get. In this case, what you've come up with isn't the go way to solve your problem. If you want to get help on solving your problem, you'll need to ask about it, not about why your solution isn't possible. What your doing is asking why Python has no increment operator when really you have a problem that Python solves with something else.
How is that a "more clean exit" then letting the SIGINT default handler kill the process?
How will this work on Windows?
I'm wondering as well
It's just an example. You can use this example to make your program cleanly exit on SIGINT.
Builtin interfaces for native types is exactly what I'm asking for. Everyone's mistaking me for asking for generics; I'm not asking for generics. I'm asking to use interfaces that can represent native types, and types derived from them.
You are misunderstanding me. I'm asking for Go to support the "Go Way" fully, so that I can use interfaces to represent native types. There is no interface for `string`: why is that? There's no interface for `uint8`, why is that? Why can I write a function that accepts two struct tyoes based on an interface, but not two string types?
From a high level perspective, I agree. The builtin operators are basically methods for the builtin types. Looking into more details, I guess you have to look into how the different type kinds are encoded and whether you are not going to need some kind of constrained operator overloading. (i.e. method overloading for the builtin methods). If you can even put constraints there, that is. And probably a few other things to look into (amongst them, interface embedding for example). But that would be nice, I agree. Pretty sure they are/have been thinking about it at some point (when they introduced make and append for instance). I think that the Garbage Collector and the translation of the runtime is taking most of their time now. I wish I were savvy enough to look into this myself.
I examine redigo pool it will support asap.
 func sum(sumChan chan int, done chan int) { for i := 0; i &lt; 1000000; i++ { // sumChan has a buffer of size 1, so receiving blocks if there // is another goroutine currently incrementing the sum cur := &lt;-sumChan cur++ sumChan &lt;- cur } done &lt;- 1 } This is an overuse of channels. In Go for such cases one would use a mutex. [edit] Eventually sync/atomic.
Agreed! This was just an example to showcase the many use cases of channels.
The text you cited is under different example in different section. The reader unfamiliar with the topic has no way of knowing to what kind of use-case it refers to. My opinion is, especially for language comparison blog posts, one should be showing idiomatic usages of the languages compared.
Thanks, the Makefile is mostly just for linting, testing, and compressing the JavaScript, so if you're just experimenting with the Golang side then don't worry about it.
My implementation of the Vose method: https://github.com/dgryski/go-discreterand Currently GPL, but I'll relicense it if needed. The community is mostly MIT or Apache style. Also, naive solutions are O(1) time with high space overhead, or O(log n) with small space and prefix sums.
Oh well that's not really clear, I suggest you clarify it better. 
There is no need to iterate over the channel. This would do fine: import ( "os" "os/signal" ) func main() { done := make(chan os.Signal, 1) signal.Notify(done, os.Interrupt) go func() { &lt;-done os.Exit(0) }() // Do something here } Of course, there is also no reason signal.Notify cannot be called inside the newly spawned goroutine
You can let the default handler kill the process, or you can catch the signal as shown in this article and implement your own shutdown. This is useful for when it's essential that something needs to be done before shutdown. Like /u/verticle_tab example, or making sure a database transaction is complete before shutdown.
yea, my idea was to offer the features light table was supposed to have for other languages like go and lua (and i use coffeescript and php too)... so more like a text editor with repl and not-quite-debugger-but-logger/tracer and table mode, golang docs, and voice control (stretch goal), and some of the features from resharper.
I wanted to do something similar, I will fork the project
It is an interresting project but i hope the secret hardcoded in the code is juste for demo and not your real account.
What does this do ? I read the faq but it is missing the crucial question, *why should I join this service, what does it provide?*
I ran into a problem using the document id as part of the URL when sending requests to my web service. Is there an easy way around that problem ? Agree; its no big deal to display value.
Here's a basic example of what you could do: id := bson.NewObjectId() url := fmt.Sprintf("/url/%s/pretty-formatted-url", id.Hex())
At large, it provides connections to other devs who are logging similar work. In the @golang team, it provides a daily digest of what other @golang members are logging. An active way to keep track of what you're doing over time and a passive way to find other devs working on similar challenges.
That Go libraries will do things like have channels in their public interface when appropriate, and deeply expect to be in a threaded environment, and so on, whereas in C you're generally looking at libraries that certainly won't have chans themselves and _permit_ threaded execution, but don't necessarily _expect_ it, so, for instance, a common Go pattern where a library may spawn off its own goroutine to function as a server will have to be worked around in C, since a maximally-compatible C library won't count on threads. It matters what's in the base system, especially as all of the differences compose with each other throughout the layers of the system.
**"try and back off" example** OuterLoop: for { a := &lt;-ch1 select { case b := &lt;-ch2: break OuterLoop default: ch1 &lt;- a // wait } } // use a and b This example requires more context to be useful. If `ch1` isn't buffered, this is a deadlock. If `ch1` has a buffer size greater than 1, this doesn't reliably lock. If `ch1` has a buffer size of 1, you have a race condition deadlock if any other goroutines read without writing or vice versa. Also, using a labeled statement is a serious code smell. Mimicking the pthreads behavior would be much cleaner (fewer potential side effects) with mutexes, but that requires a custom mutex since Go's `sync.Mutex` has no `TryLock()` method (see [this thread](https://github.com/golang/go/issues/6123)). In the comparison between languages, I would put this down as weakness for Go. --- **timeout example** timeout := make(chan bool, 1) go func() { time.Sleep(1 * time.Second) timeout &lt;- true }() select { case &lt;-ch: // a read from ch has occurred case &lt;-timeout: // the read from ch has timed out } The paragraphs above and below indicate that you're demonstrating how to use a timeout in a select statement. The article you pulled this example from is demonstrating the internal mechanics of a timeout channel and explicitly mentions that you should use `time.After` in this use case. Why not use select { case &lt;-ch: // a read from ch has occured case &lt;-time.After(1 * time.Second): // the read from ch has time out } instead? --- **other notes** The links in your references aren't formatted properly. The indentation in your examples is inconsistent: some examples start one level in, and others start with zero indentation.
In other languages doing this would be a bit trickier I suspect. Due to the way embedding works in Go. As the Go example show you can selectively replace which methods are exposed. So the Push using generic `interface{}` is replaced with Push taking an `int`. Thus you can make sure the user of the stack API never insert the wrong type. If you tried force only correct types in a Java without generics e.g. you would have to reimplement every method on the contained and forward the call, even for methods which don't need to know the type. That gets cumbersome.
Cool, I'll check it out then!
Bon apetit :D
Yes, thanks, I saw that earlier when Isaac Gouy emailed me to tell me that the Benchmarks Game is not sponsored by Debian (whoops!). There were various formatting issues, since I converted it to markdown from latex with pandoc, and I'm sure I haven't caught them all yet. I've since fixed that particular one though. Thanks for reading!
I don't know where exactly I should handle the routings, right now I have [the following code for an Application Singleton](http://i.imgur.com/s3NxEUc.png). But I feel like I am using too many packages, and I am not sure where to put the helpers. Is it ok to make a Helpers package?
That's a good point. I hadn't thought about how this interacts with embedded fields.
The url is created in the web page javascript, so it would have to convert the value into valid text and then the Go web service would have to convert it back to a valid ObjectId.
&gt; I am trying to build a simple webservice in golang as an exercise One of the key lessons i've learned while using golang was to *NOT* overcomplicate and do not add excess amounts of structure to your code. I don't know exactly what your project is, but any sane definition of simple should not need multiple packages.
You're absolutely right about it being different from something like an AngularJS app, which is why you shouldn't attempt to mimic the file structure. It's a bit counterintuitive to dump everything into one directory but it alleviates much of the unforeseen complexity you introduce when you break up your project into separate packages, most if not all of which will never be used outside the scope your current project. I'm not just saying this because it's recommended, I have the privilege of having learned this the hard way. Nowadays my code lives in one directory under package main if I have no intentions of importing that code elsewhere. Otherwise the directory will include a cmd directory that will contain a main.go, this provides me with a way to run that package as well as import it in other projects. I build mostly web apps that sometimes rely on each other (i.e. imports) and sometimes they're standalone microservices, with anywhere from 4 to 20+ files in each project. I can't remember which one it was but one of the go talks had a slide about package structure. In the end I would say it all depends on context and ease of maintenance. 
Missed a chance to show of the brand new for range!
It's my hobby :)
So instead of splitting the code into **folders**, I split into **files**? Since it is true what you said, that almost every single package here (aside from the user package), will not be imported elsewhere whatsoever as it is just a personal service for my AngularJS Album app.
The Sum function claims: // sumChan has a buffer of size 1, so receiving blocks if there // is another goroutine currently incrementing the sum That's not really true and how it works also depends on how you start the go routines counting. If you launch all 4 go routines then get things moving with: sumChan &lt;- 0 Doesn't even matter if it's buffered or not. It will do one routine at a time and give the correct answer (no concurrency). It gets interesting when you prime with 4 starting values: sumChan &lt;- 0 sumChan &lt;- 0 sumChan &lt;- 0 sumChan &lt;- 0 Now you need to make a buffered channel of at least 4 and it will run in parallel. Just add up the sum for each routine at the end to get the value. Probably just stating the obvious, but it was interesting to play around and see how things worked. Here is the code I played with: http://play.golang.org/p/VjlclgJYKV 
It differs by project, but the smaller ones will have a file where I define my http handlers and a server file that has a setup function to map the routes to the handlers. Pretty basic stuff. The rest of the files are similarly organized with related code living together in a file that occasionally grows a bit long, so the most important logic is always at the top of the file. Browsing the code is intuitive, I can tell from the filenames what's where, and vim go tags make it even easier. If you check out the standard packages they're organized the same way, with lots of files in some and only a few in others. Also, Dave Cheney has an excellent writeup on this very topic. I'm on mobile so I don't have the link handy but search his blog for it, it's well worth it imho.
Yet another of these shitty blog spam articles where somebody tries to tell me something that is super easy to make. Downvote.
[ocilib](https://en.wikipedia.org/wiki/OCILIB) was mentionned in the comments. I found [Go bindings (gocilib)](https://github.com/tgulacsi/gocilib) but there is no indicator about its use, progress or stability. Has anyone tried it?
It does. I just checked. Ctrl+C is caught on Windows just like on Linux with the code supplied earlier in this discussion.
&gt; from top to bottom from head to toe
I see `func Stat(name string) (fi FileInfo, err error)`. Are we looking at different definitions?
If all you need to do is check for existence, don't use stat. It causes the filesystem to do a lookup, then gather all of the metadata about the file. At worst you're doing the stat operation twice per file, at best you're doing it needlessly. Stat can be very slow on a busy filesystem and this is an easy way to reduce the impact your app has. Use os.IsExist or IsNotExist as already suggested.
so, how would you sort / map / reduce / find item with maximum etc????
I suppose there's some merit in being able to view/edit the 'database' with just a text editor, but for a KV store, it's really much easier, safer and faster to use something like Level DB (i.e. Levigo) or Bolt DB.
A lot of good ideas there. Going through the std lib for clues makes sense. However, I need some clarification on something. If you have a slice of values like *[]BuoyStation* (listing 16), but you need to change some attribute, such as convert GMT to local time, which should you do? [The FAQ](https://golang.org/doc/faq#methods_on_values_or_pointers) tells me I should probably use pointers, but I've got a bunch of values. 
I'm not so sure that calling go "low level" is correct. I mean it feels higher than java, and has gc. C on the other hand sure, and ok maybe rust. I think go might be semi low level. (terminology it bugs me)
…what? `os.Stat()` is the lightest-weight method to determine if a single file exists. The alternatives are to 1) `os.Open()` the file or 2) `os.Open()` the containing directory and read its contents. The first method is significantly less efficient if you don't actually need the file's contents, and the second method is less efficient for a single file but more efficient for multiple files in the same directory. `os.IsExist(error) bool` and `IsNotExist(error) bool` are for gleaning information from platform-specific `error`s without needing platform-specific knowledge. This is useful because `IsNotExist` for `ENOENT` is true, but if you blindly said `ENOENT`, your code wouldn't build on Windows. These functions are implemented by [`src/os/error_unix.go`](http://golang.org/src/os/error_unix.go) and [`error_windows.go`](http://golang.org/src/os/error_windows.go) which are conditionally built to keep you from needing to do this yourself. They do **not** interact with the operating system.
I would share any individual value with a pointer to the function making that change. Or use a pointer receiver if I want to implement that with a method.
Idiomatic go probably doesn't use atomics (though it definitely can use mutexes). There has been some discussions about moving atomics into an internal/ package if/when there is a Go 2.
Although I admit, I'm not quite sure I understand how it's racing myself. The channel sends and receives are atomic, so they can't be incrementing the same sum at the same time, and each of them increments some number a million times.
Nevertheless, your original code seems kind of weird. Here is the way I would solve the problem using only channels http://play.golang.org/p/J0QNgVOiVJ It's more idiomatic with a waitgroup http://play.golang.org/p/IJyZPzxnam And probably best with a mutex for this particular problem http://play.golang.org/p/LYQ4XEkvwa
Oh yay! I've been looking for an explanation like this ever since I found that package. Thanks.
I was just showing possible aliases
Hmm, I feel I ought to warn you that trying to follow me around with a thesaurus and provide options could very easily turn into a full time job, except for how nobody will be paying you.
&gt; This example requires more context to be useful. If ch1 isn't buffered, this is a deadlock. If ch1 has a buffer size greater than 1, this doesn't reliably lock. If ch1 has a buffer size of 1, you have a race condition deadlock if any other goroutines read without writing or vice versa. Also, using a labeled statement is a serious code smell. Admittedly, this example was somewhat contrived; the only reason I included it in my original paper was to give my class some direct comparisons to the techniques we had been learning. I also did mention that Go has no equivalent `TryLock()` method under the "Try and back off" section. However, I'm not sure I follow how this would result in a deadlock, or race condition, and I don't think "race condition deadlock" is a thing. Perhaps you can elaborate? As for the code label, I mentioned in a footnote that the label was necessary here because `break` would only break out of the `select` statement. &gt; Why not use [`time.After()`] instead? I suppose I could have, but I was directly quoting the article. In any case, thanks for the feedback! :)
It depends on which db you use and the driver implementation. I like to pass a context object to the HTTP handler functions that has pointers to the data stores to use (for mgo I pass mgo.Database, gotten from a session which is copied for each HTTP request) or to a connection pool for Redis. Usually all database drivers have some sort of connections pool management so you don't really have to choose between keeping a single open connection or opening a new connection for each http request. 
Thanks for replying. &gt; It depends on which db you use and the driver implementation. I like to pass a context object to the HTTP handler functions that has pointers to the data stores to use (for mgo I pass mgo.Database, gotten from a session which is copied for each HTTP request) or to a connection pool for Redis. Post updated. The database is Postgres 9.3 and the driver is https://github.com/lib/pq &gt; Usually all database drivers have some sort of connections pool management so you don't really have to choose between keeping a single open connection or opening a new connection for each http request. So I'm guessing they handle goroutines as well so I don't have to on my end, right? 
&gt; [I] have to violate DRY in projects that reuse common patterns. Yep. I agree that this is a bit of a bummer. But lets stop and think about how we're repeating ourselves--are we repeating complicated logic or boiler plate like the type-safe wrappers I described in my post? My experience has been the latter, but I'm definitely open to the suggestion that there are problem domains for which there are no suitable patterns that don't depend on the generics feature (I've never encountered one, but I'm still learning). Another important question is how important is the type-safe wrapper to you? In most cases, the unit in which you want to use a generic Stack&lt;T&gt; is sufficiently simple that the `interface{}` Stack from my example wouldn't pose a problem in practice. Would it be nice to write DRYer code without compromising type-safety? I definitely think so? Is it as big a deal as most people make of it? Not in my experience.
Pretty great!
fuzxxl, layoff the coolaid
All things are possible with `interface{}`, I suppose. I guess my issue is that I find type casting- especially in cases where all involved parties (the developer, the compiler) know at compile time what the type will be- utterly awfully. It's a huge code smell to me.
Anybody know what the Y-axis on those images are? I'm guessing bytes and milliseconds based off the raw data of the JSON.
I saw those earlier, but they didn't help me in this particular case
I finally took some tome to check this memory charts implementation. The good thing, I really like chart library you use - it looks super clean an nice. Though, it took me a while to realize, that it's not suitable for long-running monitoring. First of all, the data amount after like 8 hours reaches 1Mb and JS code becomes kind of luggish and slow (not too much, but noticeable). Second, the data of debugcharts itself is included into the program memory, so it's always grows up, as data.BytesAllocated and data.GcPauses grow. Of course, that's not a huge amount, but I actually spent at least 20 minutes trying to realize why the memory grows a little each hour, until I guessed to look up debugcharts itself. I see you limited it to be to 1 day range, but still 4MB per day grow can trigger someone's alert and suspicion of memory leak. So, I'd suggest to put it in README to make it obvious - that this tool is designed to short-term monitoring, like quick debug sessions or so. Next, perhaps it would be wise to make (optionally?) the possibility to just send metrics to JS frontend, without storing it in memory. If we're targeting short-lived debug sessions, it would be reasonable trade off. Of course, the client will loose the history on page reloading, but that's short-lived debug session, after all. Anyway thanks for the nice tool. It makes memory monitoring easier.
I thought it would be cringe-y but wasn't really bad tbh.
Thanks for the tip of looking at stringer. That's a great way to get a look at some code doing very similar stuff.
Yeah, I got a few chuckles out of it. Could have been way worse.
GoClipse work well for me on Windows/Ubuntu
Interface never bothered me anyway.
[Go database/sql tutorial](http://go-database-sql.org/) looks very good documentation.
I'm so glad it is that way. Thanks for sharing! Nice article btw
I'm not sure I understand what purpose this library fulfils. Can someone explain it like I'm 5?
I am also unable to understand how these semantic versioning libraries are being used in real life. AFAICT, semantic versioning seems theoretical (how to assign a version number to a library).
It offends my sense of elegance, for sure; however, it's never poses real problems in practice. And that's one of the things you have to get used to in Go--it's more interested in being practical than beautiful (for better or worse).
Isn't the go way to vendor the dependency currently? Since this isn't part of any convention in go, I don't see how much adaptation you'd get. I wrote something to pull in env vars into a project, then I did some research and found people don't us go like that. (Flags are mor idiomatic)
At first I thought this was some sort of dependency versioning support for Go. It's not. It's just a library for parsing version strings.
Few days ago, I posted this comment on a recent post: [What is the state of Oracle DB bindings ?](http://www.reddit.com/r/golang/comments/2p3gok/what_is_the_state_of_oracle_db_bindings/cmxgej5) It slipped away from frontpage of /r/golang and did not receive any comment. So I took a bit of time to try it and managed to get simple SQL queries working (Linux / 64bits / Oracle 11.1). It provides a standard "database/sql" driver, but due to my limited Go skills, I did not push tests further (i.e playing with DDL, inserts, transactions, CLOBs and so on). Surprisingly, this repo is the only reference I found on Internet. It provides bindings to a C/C++ lib that (from Wikipedia) is popular and that states it has bindings to Go. Repo is not very active nor contributed, has no issues, but otherwise looks healthy (stable?) to me. So here come the questions: Has anyone had any experience with it? Is it stable (web apps in mind)? Missing features?
I've been enlightened by a coworker to the wonderful ecosystem Go provides out the box. This is my first Go program and had help from [Codegangsta](https://github.com/codegangsta). I'd love suggestions, improvements or constructive criticism. Bring it on!
Nice work /u/LongElm !!! I really like the idea of writing commands that wrap arbitrary commands that modify your environment! Also tmux is the bomb
Hmmm, I got it working. But first impressions are that documentation is rather lacking. There isn't even examples for making a simple query that returns a result set, so you end up having to read the sourcecode, which may or may not be a bad thing :-) But as pointed out the underlying ocilib should be rock solid, so I will give this a shot.
Great job. Thank you. 
Why does Go do this? What is the benefit?
Now that I've been downvoted, let me show you an example of where os.stat(path) fails whereas opening the file and using os.IsExist() works. 1) Start your program 2) Program checks /foo/bar/baz exists with os.Stat(), it does. 3) File is deleted by another process 4) Program attempts to open /foo/bar/baz, receives error 5) User still has to check returned err to be safe So, why use Stat()? Perhaps your application checks for a lock file and exits if the file exists. Or perhaps you like debugging annoying race conditions. It's even possible that you love checking the same file over and over again, but that's going to be bad for application performance. Check once after opening the file and be done with it. Even in the case where your app is checking for a lock file, opening the file is a better way. It's more idiomatic, it has little chance of confusing future developers, and it's the same code you'd use to open a file anyway!
&gt; Go does low level allocations in 8 KB pages taken from a (theoretically) contiguous arena; what pages are free versus allocated is stored in a giant bitmap. On 64-bit machines, Go simply pre-reserves the entire memory address space for both the bitmaps and the arena itself. As I understand it, and I want to emphasize I am not competent on the technical details, Go says "OK, to get some of the performance properties we want with Go routines, we're going to use contiguous stacks. Contiguous stacks increases performance because previously as a Go program expands past it's 8KB page it has to create a 16KB page and then copy the old page into that. Now the stack just expands and starts using the already mapped space. But this means we also need to reserve the space for that stack. So we'll just reserve a map of all the possible 8KB pages - but because that map is 64 bits long after the math it ends up taking 128GB." I do not know why this only affects 64 bit systems.
Use the source Luke, https://github.com/golang/go/blob/master/src/runtime/malloc1.go#L106 Importantly, this is *virtual* memory allocation, not physical. 
"2. Any changes to the system call interface necessary to support future versions of Go will be done through the internal package mechanism proposed for Go 1.4."
&gt;First: os.IsExist() doesn't actually test whether or not a file exists, it tells you whether or not an error returned from some other call indicates that the file exists. Yep. That's why I said err has to be checked anyway. It's also why IsExist and IsNotExist take an Error as input, not a file path. I understand what IsExist() and IsNotExist() do. Let's move on, shall we? &gt;In other words, some call has to fail because a file exists – meaning it applies to neither os.Stat() nor os.Open(), since neither return an error when the target file exists. Yup. When you attempt to access a file (for read) and it exists, no error has occurred. When you try to Create() or OpenFile() with a O_CREATE flag an existing file, though, these calls will return an error. The documentation is clear. Why do you feel like you need to explain this? Everyone here knows, let's move on. &gt; os.IsNotExist() is relevant, but doesn't actually answer the question of which call(s) to use. Yes, same as above but in the opposite sense. If you try to Open() and file that doesn't exist, IsNotExist will return True. The docs are again clear on this, and you don't need to explain it. &gt;Second: on every platform except Windows, os.Open() doesn't prevent that file from being removed. In fact, POSIX requires that unlink(2) succeed even when one or more process has a file descriptor open for the file in question. This is one of the reasons that there are two Stat() methods is the os package: fstat(2)ing an open file can be different than stat(2)ing the file with that name, since another process might have renamed another file over the one you already opened, or the file you opened might have been deleted, or it might have been moved away, or a hundred other things. You're missing my point completely. If you check that a file exists by calling IsNotExist() on the err value returned by os.Stat(), and you then attempt to Create() a file, that file may have been created already. In other words, don't try to be cute and check for conditions before attempting to open, create, delete, etc. Let the actual call to those functions fail and check the returned err value. This is the idiomatic way to write Go, and it is the way to write code that does not produce hard to track down race conditions. Also, along your example's lines...yes, you can unlink() a file that is open. But the file is _not_ destroyed, and any application with a file handle to the now unlink()'d file can still read and write to that file handle! This is why amateur system administrators often delete log files but find a filesystem has not reclaimed space. The fd is still open, the inode still exists, the space is still in use. Once there are no more file descriptors open, the refcount drops to 0, and the inode(s) are freed from disk. This is clearly spelled out in POSIX, it is the intended behavior. The fact that windows allows files to be locked for read access, preventing processes from removing active files or that it may not allow removal of files with a refcount higher than 0 isn't of importance to my example at all. &gt;As for file locking, that topic is complex, platform-specific, and generally full of gotchas, especially in contexts involving multiple processes and/or networked filesystems… which are exactly the situations when filesystem-based locking is relevant. It's also not something OP asked about, so I focused on the question of existence or non-existence instead. You've again missed my point. Read it again more carefully. Not a locked file. A lockfile. In other words, I have a program that creates a file as a semaphore to indicate some state. This is common with things like cron jobs that can not run multiple times. A simple process checks for the existence of a file, if it exists the process will not run. If it does not exist, the process executes. This is a super common thing, and it is the corner stone of my example. It is also often messed up by developers trying to check for a file before attempting to open the file. Don't do that. Just open the file, and if the call fails check the returned err value. Trust me, this _will_ bite you if you don't heed my warning. &gt;As for os.Open(), I agree that it's preferable to os.Stat() – if and only if you need the contents of the file, as I stated above. You're correct that stat-then-open causes additional work and has additional failure modes than going straight to open. If the question was "does this file exist and what does it contain?", that should be implemented as to "try to open the file and fail if it's not there", but all OP wanted was to know if a file exists. os.Stat()/stat(2) is the correct way to answer that question for a single file, and readdir(2) is the correct way to answer that question for multiple files in the same directory. I'm betting OP isn't simply checking the existence of a file. I bet OP is checking for a file before doing something to it. There are cases where I could easily be wrong, and I'd love to hear what OP is actually trying to accomplish rather than what function they want to call. This is what causes StackOverflow programmers- People trying to do the wrong thing, getting sage advice about doing the wrong thing, then wondering why it failed. I'm suggesting OP avoid an entire domain of errors. But, if all OP really wants to accomplish is to write an app that checks for a file, great. Stat() is probably what they could use. But I highly suspect they _don't_ just want to know a boolean answer. I bet they want to do something to the file if it does or does not exist, meaning they've got a perfectly valid answer about how to do the wrong thing.
Anyone know off the top of their head the difference between etcd implementation of raft and goraft implementation? Etcd Raft - https://github.com/coreos/etcd/tree/master/raft Go Raft - https://github.com/goraft/raft Thanks!
Good lyrics. Akward performance. 
&gt; I understand what IsExist() and IsNotExist() do. Let's move on, shall we? Two posts up, you wrote about: &gt; an example of where os.stat(path) fails whereas opening the file and using os.IsExist() works I went into detail again about `os.IsExist()` because I don't see a situation where `os.Open()` can ever return an `error` for which `os.IsExist()` returns `true`. `os.IsNotExist()`, yes, but not `os.IsExist()` – unless you're using `os.OpenFile(…, os.O_CREATE|os.O_EXCL, …)`, but surely that combination of flags would be worth spelling out for someone asking about how to use `os.Stat()`, right? &gt; Why do you feel like you need to explain this? Because your original post, in its entirety, is: &gt; If all you need to do is check for existence, don't use stat. It causes the filesystem to do a lookup, then gather all of the metadata about the file. At worst you're doing the stat operation twice per file, at best you're doing it needlessly. Stat can be very slow on a busy filesystem and this is an easy way to reduce the impact your app has. &gt; &gt; Use os.IsExist or IsNotExist as already suggested. "If all you need to do is check for existence" then `os.Stat()` is the correct solution. "Doing the stat operation twice per file" is [plainly not how `os.Stat()` works](http://golang.org/src/os/file_unix.go#L130). Denouncing `os.Stat()` and suggesting `os.IsExist` and `IsNotExist` as a replacement instead is unhelpful – unless you're implicitly suggesting that OP should use `os.Open()` first, which is much worse for the case where OP is just trying to check for existence of a file, which is what your post was addressing. &gt; But, if all OP really wants to accomplish is to write an app that checks for a file, great. Stat() is probably what they could use. We agree, but this position is quite a change from: &gt; If all you need to do is check for existence, don't use stat.
Yeah, I'm actually not conceding the point to you. I'm just not interested anymore. Using stat() is probably wrong in every situation besides the very rare case. That's my position. Spelled out plainly. It is extremely uncommon to care if a file exists and not want to perform some action.
Dang! It looks like our two projects started around the same time: https://github.com/coreos/go-semver
&gt; except for how nobody will be paying you *except that nobody will be paying you a wage. Sorry could not resist providing an option (chuckles away.. I'm out ;D )
Thanks. Since it looks like both of those are using raft in private packages, I'll take a look at how CockroachDB integrates it.
Pity I'm not set up with bitcoins or I'd toss you some embarassingly-small fraction of a penny, just for the sheer irony.
This is great! Perhaps it would be even better to use a CI service, to run the benchmarks on different versions of Go so that they're available as estimates, then the users don't always need to run the benchmarks themselves.
Maybe it could be used for a package manager.
See also https://github.com/feyeleanor/gospeed which is very comprehensive
This could be cool! :) I might check this out sometime.
No units, but incredibly concise ways of expressing very complicated operations. The J programming language was its ASCII-based successor. 
Using *var m float64* makes the result more scary 0.1 0.2 0.30000000000000004 0.4 0.5 0.6 0.7 0.7999999999999999 0.8999999999999999 0.9999999999999999 1.0999999999999999 1.2 1.3 1.4000000000000001 1.5000000000000002 1.6000000000000003 1.7000000000000004 1.8000000000000005 1.9000000000000006 2.0000000000000004 Play: http://play.golang.org/p/DJYOyWXtvQ 
That is just standard floating point precision. If you want to truly avoid floating point errors, use ints and scale them accordingly. 
While that may be true, the way it displays is not consistent with the documentation. %v is supposed to use %g, and %g should be using %f for this type of number ([source](http://golang.org/pkg/fmt/#hdr-Printing)). This is not the case. Edit: looks like this distinction is made elsewhere, and the verb you use actually makes quite a bit of difference: // fmt_f32 formats a float32 in the form -1.23. func (f *fmt) fmt_f32(v float32) { f.formatFloat(float64(v), 'f', doPrec(f, 6), 32) } // fmt_g32 formats a float32 in the 'f' or 'e' form according to size. func (f *fmt) fmt_g32(v float32) { f.formatFloat(float64(v), 'g', doPrec(f, -1), 32) }
Jalaska13 - what graph libraries have you looked at already (that you didn't think are good yet)?
I also developed an event bus as a subpackage for another project ([link](https://github.com/dradtke/allegory/tree/master/bus)), but took a different approach for the event identifiers. Events are defined kind of like this: package bus type EventId uint32 var _eventIdCounter EventId func NewEventId() EventId { return EventId(atomic.AddUint32((*uint32)(&amp;_eventIdCounter), 1)) } so that other packages can define events like: var ( MyEvent bus.EventId = bus.NewEventId() ) func main() { bus.AddListener(MyEvent, func() { // handle MyEvent }) bus.Signal(MyEvent) // same as Publish() } It's more verbose in that every event you use has to be explicitly defined somewhere, but comes with the benefit of having the compiler catch any typos in event names. I don't know if the trade-off is worth the extra bookkeeping, and I like your consistent naming scheme for event names, but I liked exploring this approach. Anyway, cool project!
https://code.google.com/p/go-wiki/wiki/Projects (ctrl+f for "graph" or see this [subsection](https://code.google.com/p/go-wiki/wiki/Projects#Data_Structures)).
Serving an html file is about the simplest thing to do. Hugo is not a framework, it's an application and it's a comparatively big one, so I wouldn't use it as something to learn from. You don't need any framework, html/template is an easy (and powerful) html templating library. Start by studying simple examples: * http://thenewstack.io/building-a-web-server-in-go/ * https://hecticjeff.net/2013/07/17/golang-static-http-file-server/ * https://github.com/itang/gohttp * https://golang.org/doc/articles/wiki/ * https://gist.github.com/tristanwietsma/8444cf3cb5a1ac496203 BTW: those are from 1st page of google results for "simple http server golang"
I'm looking for something more robust than that. The algorithms are certainly nice, but I'm looking for something that supports: - arbitrary data associated with a node - arbitrary data associated with an edge - directed and undirected edges - weighted and unweighted edges - extensible and pluggable (for example, Boost lets you swap out different implementations (edge list, sparse matrix, neighbor pointers, etc) that implement the same basic interfaces, and you can do all of the generic operations on that)
Usually its effective to just route new connections to a new server instance with with the new code and decomision the old server instance after there are no remaining connections to the old server instance. It doesn't cost that much and is a general solution.
I use a very similar tactic in my irc bot framework: http://github.com/whyrusleeping/hellabot 
Thanks! That's a good service idea.
This is nice!
https://github.com/google/cayley ?
Hugo is fantastic for most use cases. It is statically generated yes, but for most interaction, you're probably going to use a Javascript solution regardless. With Disqus for comments and WuFoo for your forms, you have a fully functioning site, even including basic ecommerce transactions, without having any server side overhead. I do agree with kjk that you you're just trying to learn how Go works as a server, Hugo isn't the right choice.
Just to give you an alternative and maybe something more familiar, there are [other template engines](https://github.com/avelino/awesome-go#template-engines) out there for Go as well, for example my [pongo2](https://github.com/flosch/pongo2) library. As a web developer you might find it useful. A nice list of web frameworks is collected [here](https://github.com/avelino/awesome-go#web-frameworks).
Yes, this is the sane way to handle updates. 
If you want to synchronize access to a resource, you should probably look at using a sync.Mutex. Also, you are leaking channels (they need to be closed).
Well, I opened a PR. I'm sure I'll find a use for this - a few small things (that I'm fixing), but looks good!
I did it with rails and haproxy. I can do a blog entry in it off you like. It went nginx to haproxy to rails 
Caley is a graph store not a graph lib... or not an easy lib to use for pure graph work.
Generally, you would write: 1. A "server" goroutine that performs all transactions and "owns" all the state. This server has a channel coming in for all requests. These requests may also contain channels to send the answers back on. (It's OK to create a channel like that for just one use.) This reply channel would probably include an "error" as at least one possible answer. This goroutine sits in a `for { ... }` loop until told to terminate (one possible kind of request) or the program ends. 2. Each of the clients then uses the channel to send their request, and if they expect an answer, create one channel each to receive their reply. The channel then naturally serializes the requests. The server goroutine is the only thing allowed to touch the state, and the fact that it will never stop in the middle of a transaction to suddenly go try to get another request off the channel is what prevents a transaction from half-occurring.
Sure. My mistake was I was looking at raft.go and most everything in there isn't exported (newRaft, raft, etc.). Looks like node.go is where everything is.
If you want to practice with channels, you want to use channels. And you do not need to close channels. The standard says you "may" close them, not that you "must". They're just data structures that the Go runtime happens to have a special love for, they're not really "resources" in the sense that file handles or sockets are, and they'll just get GC'ed. This just sits and spins, it doesn't fill up memory: package main func nothing(chan int) {} func main() { for { c := make(chan int) nothing(c) } }
Yep. That's what we do. Two instances on two machines behind HAProxy. Remove one from the pool, drain the connections, then bring it back up and add to the pool. Great way to upgrade so long as it's okay for the two versions to briefly run at the same time. This approach has the benefit of being language and framework independent, as well. 
Hey, handy to know about chan closing. Thanks!
Thanks for the info, you are right. I should learn the proper way of serving my html files through fileServer method. Found this tutorial seems to give me a simple and proper framework: http://www.reinbach.com. 
Indeed; 'twould be a mighty pain to have to close them! May your days with Go now be that much more pleasant!
Now that you mention haproxy and nginx I understand how this is done, thanks.
Give names to the spinners and use constructors for each i.e. http://play.golang.org/p/T5epunF83V it makes the usage much nicer. Although I don't know whether "Fn" is the best name or whether it should be public at all.
Yep, i made a list of other libs with the same goal, but none was fully complete so i had to write my own. Not sure if your lib existed that day. Yours is definitely more complete/correct than most of the others :) 
This is cool. Wouldn't it be better to put the charsets in a map though? Then in the ```New``` method could just take in a charset name and you pull it out from the map. Custom charsets can be via a separate ```NewCustom``` method. e.g. var charsets map[string][]string = map[string][]string{ "arrows": []string{"←", "↖", "↑", "↗", "→", "↘", "↓", "↙"}, "bars": []string{"▁", "▃", "▄", "▅", "▆", "▇", "█", "▇", "▆", "▅", "▄", "▃"}, } ... func New(charsetName string, t time.Duration) *Spinner { func NewCustom(charset []string, t time.Duration) *Spinner {
Because they are different - look closer. "edcba" is not equal to "ebcda".
Well, I'm torn. I initially had it in a map[int]string. It was easy to just pick the number and run. A PR was submitted with some compelling reasons to just put it in a []string. If there's a quorum, I can make it a map again. I'm a bit more hesitant to make it a map[string]string because I have no idea what to name each one that will be descriptive. 
Made me laugh! Reverse d == b :D
That is not the first open source project dealing with encryption. If anyone is ridiculous, it's the people who succumb to such nuisances. 
it's true, many nations restrict cryptography export and some restrict its use within their borders by their citizens or others. many consider the US at least partly to blame for the policies of other nations in this area. for that matter, many open source projects in the past have been explicitly developed their products outside of the US to avoid export regulations, e.g. FreeBSD when they started working on Heimdal Kerberos implementation or OpenBSD when they started developed OpenSSH by bringing Niels Provos (now at Google) from Michigan to Ontario, as Canada permits export of cryptography. so yes, that is ridiculous, but we should obey the law, shouldn't we?
oooh another one, just what we always wanted :3
made me laugh too.. I am so dumb! 
Lol.. thank you.. I never realised that i could write a wrong test case.. So stupid today
The underlying cryptography used by Square is vanilla Go packages. Based on your argument, that makes entire Go language dealing with cryptography, subjected to the ridiculousness, people call it law, which is only there to protect everyone but the exchequer. Either way Go should ship with such disclaimers for the sake of laws. This way it makes my job easier to stay away from Google Go.
I would agree with you if most of them did not look almost the same.
Sigh... I don't even know how to respond to this. Is this an attempt at shaming or stirring up drama or something? (don't bother answering). I mean - if you had any argument at all, IMO the delivery alone would be enough of a reason to ignore it.
What a nice concise example. I love that it demonstrates exactly the problem it wants to address, the problems with the existing common solution, and finally a nice clean readable solution. 
Which is consistent with the doc: &gt; For floating-point values, width sets the minimum width of the field and precision sets the number of places after the decimal, if appropriate, except that for %g/%G it sets the total number of digits. For example, given 123.45 the format %6.2f prints 123.45 while %.4g prints 123.5. The default precision for %e and %f is 6; for %g it is the smallest number of digits necessary to identify the value uniquely. In other words, %g doesn't use the literal `%f`, but rather the same format with unlimited width and precision.
do you mean interface like this: http://play.golang.org/p/e0fpfvnfUF and then override the behavior in the tests? 
Sure - just make a mock type that has those methods, then implement the ones you need for testing. There's various ways to do this depending on how you set up your tests and what you're testing; it usually involves adding to a counter when a method is called or setting a flag or something like that. Then your tests assert that the flag/counter is the right value... that's the over-simplified, basic idea, anyway.
Maybe the reason why Square put that disclaimer is because their lawyer told them to do so. While Go, backed with Google lawyers, know it's no longer necessary[1]. 1. http://en.m.wikipedia.org/wiki/Export_of_cryptography_from_the_United_States#PC_era
An image generator from code. For example, remember those image forum signatures where you could add your name on them? Something like that. Application for those is limitless, starting at Internet memes and ending in custom graphics generation based on a data (i.e. Visitors cards with the name printed on it). To get you a fast start, if you know PHP, the "Imagick" class covers all this options (do not think that's "ImageMagick", it do uses iamgemagick for generation but Imagick is a simple class).
I recently implemented one that also did comparisons against the package.json version ranges (as used in satisfies() here: https://docs.npmjs.com/misc/semver ). I have not completely finished it yet, but it is 99% there.
There's really no need for that attitude. If I posted something in this subreddit and just got a snarky comment like that it wouldn't exactly encourage me to post something else in the future. If you have something to say, at least be constructive.
alternative explanation: net/http is such a good base library that building a framework is an almost trivial project.
It would be nice if people creating these frameworks wrote a few sentences about how this framework is different from the 15 other ones. A few points about their intentions, the advantages and differences over others. 
Exactly right. I'm also a little hesitant to call something "minimalist" when you can replicate it almost trivially with the standard library. Minimalist should mean taking things out -- smaller executable, lower memory use, simplifying algorithms, etc. Adding another layer is not minimalist. Replacing net/http with something more lightweight is.
That's probably overly specific for your tests. My guess is you'd be better off with the following: type Publisher interface { Publish([]byte) error } type Consumer interface { Consume() ([]byte, error) } Functions should then generally be written to expect a Publisher or a Consumer. I'm not familiar with RabbitMQ specifically, but I suspect you have a point where you're configuring your queue which is where you call all the other methods, and the things that are actually publishing or consuming don't care about any of that (at least, the method signatures strongly suggest that). I'm also guessing that wanting to both publish and consume in one function is unusual, but if I'm wrong, type PublisherConsumer interface { Publisher Consumer } is easy enough to add. Even that is still easier to mock out than the full connection sequence. You may want to read my blog post about ["parametricity" in Go](http://www.jerf.org/iri/post/2923); it covers this idea in greater detail. In the blog post, I show how to take a `net.Conn` and sort of cut it down to a `Reader`/`Writer` etc... in this case, you'd try to isolate your RabbitMQ-specific stuff out if possible (which I suspect it is) and leave yourself with the entire rest of the program using just those very simple, and very easy-to-switch, interfaces, rather than trying to carry around the totality of a full RabbitMQ interface. As a bonus, this will isolate your dependencies on RabbitMQ just by its very nature. This isn't necessarily a great reason to do it, but it comes for free and could certainly be useful later.
If Go had GD or ImageMagick bindings, then this would be pretty trivial to write. Or you can just pipe the required parameters to the GD/imagemagick binaries.
It does... lots of them... also lots of stand alone image libraries with no debs. 
A really good cross platform move that worked on files / directories and did what is expected on each platform would be gold. Doubly so if you don't try to extend it into silliness, just build it and let it be used. 
&gt; No rm -rf either, there is os.Remove but doesn't work if stuff is in the directory. [os.RemoveAll](http://golang.org/pkg/os/#RemoveAll) is what you're looking for is it not? I wasn't aware that `os.Rename` doesn't work across different file systems though. Do you have any more details about that?
Hi, we already developed a little framework for jsonapi in go. It's called api2go. In your article you mentioned that you are going to write your own. Have you looked at api2go already? Maybe you are interested in using/improving it instead of creating another one. https://github.com/univedo/api2go
A number abbreviation library. I basically want to be able to give it "1234567891" in string or numeric form and get "1.2b" or "1.23b" back with the number of digits rounded to configurable. Also doesn't round numbers under 1000. I've been trying to do it in Go for just two sets of numbers and it's a little more tricky than I first imagined.
That's exactly what I was thinking when I saw it. net/http is great, but missing basic stuff people need. BTW I've written my own little micro framework when I needed one, and didn't even bother to open it.
[What every programmer should know about floating point](http://floating-point-gui.de).
Your framework is similar to the one I am building. Since I already have pretty much everything done, I will release mine anyway but I will look at yours and see if I can improve it based on the ideas I have.
totally agree
For MIDI, I started something a little while back. [You can check it out here.](https://bitbucket.org/JamesOwenHall/musical/src/0ec2b219f903a5272859480728b5c960102c8989/midi/?at=master) It only supports writing files, and only Note On and Note Off events. Still, could be useful.
It falls un the "OS-specific restrictions" mentioned in the doc. E.g., see EXDEV in [rename(2)](http://linux.die.net/man/2/rename). Something like the `mv` command has to instead do a copy and remove of the file, along with whatever is correct for permissions, etc.
A port of the Processing graphics API. Originally, Processing was centered around Java. Now their are reasonably popular ports in JS and Python. I'd love to see one for Go. If anyone reading this happens to be aware of a related project that I haven't yet discovered, please share. I'm interested in helping out, though my knowledge in the area of graphics isn't much. 
Yes, emphasis on the *pronounceable* passwords... it really isn't possible to speak the passwords with most of those "pronounceable" password generators, which really takes away the advantage.
True for now. In 1.5 there will be internal packages, though. We enjoyed using them in the 1.4 stdlib
Doesn't godoc.org already do this and more?
The main difference is that godoc.org displays documentation - not source code. It links to other sites when you try to see the source code (and it could potentially be changed to link to gotools.org instead). There are a few other key differences: - godoc.org is designed to show the public API of a library. no branches. no commands. no unexported symbols. - gotools.org is used to display the complete internal source code of any Go package. It supports both libraries and commands, and you can pick a development branch or older commit to see its code. Of course, godoc.org is incredibly useful and it was the main inspiration for gotools.org. I use godoc.org more than 10x more frequently than I use gotools, but they do serve different purposes at this time. They do have the exact same URL structure of site.org/import/path, and that's on purpose. :)
I know, but not documentation for any of its funcs (because you're not supposed to import and use them, but you might still want to look at the source code).
&gt;os.RemoveAll is what you're looking for is it not? Didn't spot os.RemoveAll, thanks. &gt; I wasn't aware that os.Rename doesn't work across different file systems though. Do you have any more details about that? Basically rename just moves inodes around. When going across device you will get a os.LinkError with a "invalid cross-device link" message. In order to actually move files it works more like this. * os.Rename if possible, then your fine. * If that fails you have to actually do a complete copy of all the data manually. * You also have to copy all the metadata, which is a fairly complex operation as different operating systems, file systems and configurations have differential types with different apis (Consider unix permissions vs ACLs vs Windows). Even the official Python shutils has a big red warning saying some metadata will be lost (although it's bizaro Windows stuff). * Afterwards you have to wipe the original. * If it's a directory then copy+remove all has to be done recursively. Other languages often have the same issue, but Python for example have the [shutils library](https://docs.python.org/3/library/shutil.html). It would probably be worth while checking the source code for that to look for all the odd corner cases if some is implementing it. [go-shutils](https://github.com/termie/go-shutil) implements the recursive copy (but without metadata). 
I wanted to try out bleve and I just happened to read about the database dump provided by Isohunt, the indexing speed was a bit slower than I had hoped but it was fairly easy to get started with the library.
Seems just like this 'disclaimer' is just something thier lawyer told them to put in somewhere, so that in case it does get 'exported' they cannot be held responsible for it. 
Why oh why is the Postgres container not created with a Dockerfile as well? Static building + `FROM scratch` is preferable. Not sure if the pq driver uses cgo or not.
Check out go-humanise
I'd love a library that I provide a url and a target filename and I get a nice progress bar with speed for a http download.
Hi Yetan, thats a good point, I'll mention that all the postgres steps can be added to a Dockerfile and run that way. Can you elaborate on what you mean by Static Building + From scratch? Thanks for the feedback!
Sure! You can statically compile and link your go binary, and then your docker container can be the 'scratch' base image (extremely minimal) and just include the single static binary. Its really the best way to go. Static binaries are a pleasure to work with in rocket too. I guess it doesn't really matter, but it seems that scratch+static is common for golang.
Only now do I realize that the title is kind of clickbait-y. Sorry! :)
I've always used net/http without any other dependency and I agree it's great. However, at the end of the day you find yourself programming once and again the very same piece of code for routing or for executing multiple handlers when a route matches a requested URL. That's why I put everything together into Orujo. Its objective it is not to replace other frameworks, it is simply a helpful package for me that may fit the necessities of other people, so I documented it and published it. That's all :)
I thought you still needed standard libc etc even when compiling static go binaries? (could be wrong though) Some other remarks regarding the postgres container: * You can define the Postgres socket as a volume, and mount it in other containers. This allows you to skip the network reconfiguration. I think it's located in `/run/postgresql/` folder in the default postgres images, so just make that a volume, and use `--volumes-from` in containers that need to connect to it. * When using the socket method, you could kill all network connectivity by commenting the `host all "postgres" 0.0.0.0/0 trust` line in `pg_hba.conf` * For initializing the DB, I would also create a temporary container linking/connecting to the database container, or ideally, your application would do this. If it has a private postgres container with the socket linked in it, there's no need for extra users. And regarding the Go container: I don't like having a compiler inside my 'runtime' environment. This makes things a LOT easier in case you get hacked. Basic image with only the resulting binary would be ideal (which is what I usually do)
In the case of Orujo, I think that the main different is the way it handles the execution of multiple handlers per route. It is explained in the README: https://github.com/jroimartin/orujo#routes-and-pipes Basically it allows you to define a sequence of handlers (pipe) that will be executed until one of them explicitly call w.WriteHeader(). Once this event happens, only the handlers defined as mandatory in the pipe will get executed. EDIT: It also accepts only http.Handler's so everything that already works with the std lib works with orujo and viceversa.
Thank you! :)
Unfortunately, it does. Unless you roll out your own version for 1.3 using internal testing APIs.
Orujo is my micro framework. I just took the time to document it, so I released it just in case it can be useful for other people.
Probably most of them are different if you take the time to see how they are implemented or solve certain problems.
not meaningfully from an API standpoint
Orujo is minimalist in the sense that its API is really small. Also, it solves a common problem: executing several handlers/middlewares per route and manage the relations and errors between them.
It is if that gives you different features or makes things easier.
Chromecast client.
Couldn't you have used sync.Once to call models.TestDBManager.Enter() and some reference count to know when you must call models.TestDBManager.Exit()?
You could use gopkg.in/check to get test suites with sure and test setup and teardown. That's still compatible with older versions of go.
Wouldn't the reference count go to 0 after every test? Like: &gt; Test begins (+1) -&gt; 1 &gt; Test ends (-1) -&gt; 0 &gt; Database is destroyed, when I only want tables to be flushed. 
http://golang.org/pkg/net/textproto/ ?
Cool thanks!
Thanks. Orujo looks nice in that it doesn't try to get in your way and is very minimal. May I ask why you didn't use gorilla's routing library instead?
"How Go 1.4 added this one AMAZING feature you didn't know. MIND=BLOWN"
Whats the definition of reader. It supposed to fill the buffer handed to it with the data read and return the length read or an error.
Why would I use this instead of [github.com/codegangsta/cli](https://github.com/codegangsta/cli)?
Actually, at the beginning I did. However I was using only a small subset of features, so I dropped that dependency and implemented those features on my own. Also, I wanted to use pure regexp for route matching. In fact, Orujo doest not have any dependency other than the std lib (packages net/http and regexp). https://godoc.org/github.com/jroimartin/orujo?imports Also, take into account that orujo allows you to register pipes of handlers, so you can define a sequence a handlers to be executed when a route matches the request.
We're given a slice of bytes and we need to return the number of bytes we put into the slice along with an error if one exists. So how many bytes should we put into the slice? We know our goal is to emit an infinite number of them, and we don't have an infinite length slice, so we can't do everything at once. That means our function must be called over and over, and we should just keep emitting the 'A' byte every time. So the easiest way is just to emit one. import "fmt" func (r MyReader) Read(b []byte) (int, error) { if len(b) == 0 { return 0, fmt.Errorf("Buffer is not long enough") } b[0] = 'A' return 1, nil } Maybe this error checking isn't necessary, but I feel better with it there.
Gocli has a strong emphasis in flexibility and minimalism. In fact, I was about to use codegangsta cli for a project, but I found it a little bit over-engineered (you just need to take a look at both APIs). I just wrote it for my personal use, but I like to open my projects just in case someone may find it useful :)
Oh god please no.
Thanks a lot, I clearly understood your explanation :) 
A library for reading and writing Apple plist formats. Format is somewhat similar to JSON
You could do `models.TestDBManager.Enter()` in an init function to get the same effect, but there was no reliable way to know when all of the tests are done. My best suggestion is to delete and create at the beginning of each test, and leave the garbage behind for the next test run to cleanup. Not ideal, but its what you can do.
You do introduce the possibility that tests bleed into each other though. Before you had each test in perfect isolation. Now you have them sharing a database init step. If one test corrupts the database, another test could fail because of the side-effects of the previous test.
Nevermind, I am an idiot who didn't read the article well enough.
Only assuming you forget to `Reset()` after a test. After you train your mind to `defer` it just after writing the function signature, it should not happen.
[Djinn](https://github.com/thrisp/djinn) is my solution for Go html templates.
Why don't you try [go-qml](https://github.com/go-qml/qml)? 
I'll be excited once they remove $GOPATH. it's stupid, annoying, and useless. It's the major blocker besides dependency management that keeps me away.
I... I don't know, I have to learn Qml, right? will it work on Windows?
That sounds bad...
Any information about writing your own tools like stringer? I like the idea of go generate, but it would be much more useful if it were possible to create your own custom generation tools.
You can use any executable with go generate. Here's the stringer source code: https://github.com/golang/tools/blob/master/cmd/stringer/stringer.go
Sorry, $GOPATH isn't going anywhere. Perhaps you'd be happier with a different development environment.
I don't know why it isn't. My development environment is fine, I just don't like the idea of having to nest my projects in a specific way for things to work. I think Go could take a few pointers from [Cargo](https://crates.io/) when it comes to that. It's so much nicer to have your project contained in itself rather than part of a "workspace". Also, fun downvotes.
Given that we are already talking source code, and a package could thus simply have a nefarious `init` func, I don't think this materially changes the threat profile. Running bad Go code can own you either way.
I agree with the point you bring up. Two thoughts: 1. Users of a go package typically won't run go generate, it's something the package developers will do (and commit generated code). 2. It's possible to write a little tool that acts like the -n flag is given (The -n flag prints commands that would be executed, without executing them.)
Well if you are already familiar with QT, it shouldn't be a problem. especially if you already used some javascript before. However, i have to admit that i never used it on windows. But the project page says that it is supported. 
&gt;It's so much nicer to have your project contained in itself rather than part of a "workspace". Gopath *is* containing a project. Set it to the top-level of your project, then all the src/ folder structures contain dependencies. It makes the whole thing painless, and isn't any particularly different than npm, rvm, or maven (except in that it's more flexible than any of them). You can have just one project per gopath (as i tend to do), or multiple sharing the same dependencies. &gt;Also, fun downvotes. Being casually inflammatory, then self-pitying, is one of the easiest way to get downvotes. You're all too good at attracting them.
&gt; `func (cl *Cli) Handle() error` &gt; Handle is the engine of CLI. It handles the arguments given to the program and calls the corresponding command Run or Usage methods. Damn me if I understand what this does mean.
this might be a way to implement data structure without interface{}
Well, at least there is support for Windows! and... JavaScript is my weakness :-/
This was a nice read until the last paragraph. I realize you're trying to sell a product, but language that divisive is not appropriate. 
As someone on mobile, thank you. I am bewildered that the author did not provide a proper link in the README.
That's one of the use cases that drove the design, as I understand it. I suspect there's still going to be some competition about the best tool for pseudogenerics generation, but the "go generate" framework gets us a lot of standardization right off the bat.
How it compares with https://github.com/BurntSushi/toml? Is it able to write to existing ini file, overwriting values only (keeping the comments etc.?) 
I wrote a python class that can do that. I may release it to the world, because I haven't found another python script that could seem to get it right.
http://blog.golang.org/profiling-go-programs http://golang.org/pkg/runtime/pprof/#WriteHeapProfile http://golang.org/pkg/net/http/pprof/
I used pprof but the problem is that some ram is "missing".
Give http://golang.org/pkg/runtime/#ReadMemStats a whirl.
it is same as pprof's lookup("heap") 
Which `top` value are you looking at?
Well, ReadMemStats gives you info about non-heap allocations as well. Can you provide a printout of the entire struct while your server is using 1.7GB RSS? 
I wrote [this tool](https://github.com/jteeuwen/templates) a few days ago as an experiment, to demonstrate just that. It's technically doable. How this all works in practice, I don't know yet though. I haven't had an opportunity to actually put it to use. I am also not entirely convinced of the usefulness of this particular application. From what I understand of the `go:generate` mechanic, it is intended to get rid of Makefiles and such. But in this case, you are still dependent on an external tool being present (namely the template tool in my repo). So functionally this is not very different from manually invoking the command and leaving out the `go:generate` statements. In addition, we are supposed to only use this as package authors and then commit the generated code into the code base. If that's the case, then why leave a `go:generate` statement in your source to begin with? Once your code is generated, it's done. There's no use for the generate statement anymore.
You can't mix up `int` and `uint` in code, and `int` is a much more popular type. When you do `x := 0`, x is `int`, not `uint`. So if built-in functions returned `uint`, then everyone else's code would be a mess of `int(len(s))` and `int(cap(s))`. I'd assume it's the same reasoning with the rest of std. The more std functions would return `uint`s, the more conversions we'd have to make.
I suggest you read up a bit more on uint versus int, it is quite popular to not even have uints in your language. If you are using uints because something can't be negative you are almost always looking for a problem where there is none. Use uints for bitfields and the like where a sign bit would be annoying, not because you can only have positive values. I'd also assume(although this is speculation) that if you can only have positive integers it is still good to have it in a signed integer and thus make overflow detection easier. Nim as a recent language and Java as a slightly older language come to mind for languages that don't even have unsigned by default. A very similar question was asked on the golang-nuts list a few days ago.
In a way the OP's concern is justified, though. This is one of the cases where semantics have been sacrificed for straightforwardness of the language by rejecting implicit numeric conversions.
The basic problem with uint is that people use it when "it can't be negative". However, most of the time, you don't use it just to store things, but also to calculate things (and in languages with type inference it's viral). And this is when the problem appears, underflowing uint is super easy. It's recommended to use just plain int unless you really need an uint. You can even see GoingNative 2013 conference, where all the C++ gurus say that size_t usage in STL was a mistake (https://channel9.msdn.com/Events/GoingNative/2013/Interactive-Panel-Ask-Us-Anything). But people still disagree, and they have a right to do so. In Go however the use of int is recommended also due to the lack of implicit type conversions. If you start to use uint in the code, then you'll have to type a zillion of type conversions. In my opinion there is simply no reasons to use an unsigned type ever. It can't be negative, but it doesn't prevent you from underflows. There is performance difference, but it's practically unnoticable. The additional bit you get is tricky to use correctly (e.g. [(min + max) / 2] vs. [min + (max - min) * 2]) and if you need it, you'd better be using larger type (like int64). So, why use uint? Another good link: http://www.soundsoftware.ac.uk/c-pitfall-unsigned
Rob Pike gave a good explanation, it was about erroring due to under-/overflow: uints become nasty around 0 which is very common value.
the pipe thing is nice. In my micro-framework I defined a pre and post processor interface for each request, to achieve more or less the same needs I'm guessing. So the preprocessor can for example reject the request if the user is not logged in.
It's because of how I interpret 10.1.1. It gets first expanded to 10.1.1.0-255, then for each of expanded IPs I apply /28. 10.1.1.0/28 expands to 10.1.1.0-15, then 10.1.1.1 gets expanded to the same block, then 10.1.1.16 expands to 10.1.1.16-10.1.1.31, etc etc. So eventually it covers the whole /24. I am still debating myself whether I should keep this behavior or I make a special case for anything with CIDR at the end. Regardless 10.1.1.0/28 gets you the correct results.
I've been working on a tool called [goast](https://github.com/jamesgarfield/goast) off and on since they announced this proposal, that aims to to take advantage of the `go generate` tool It's certainly not "generics", but it aims at being being a generalized "generic programming" utility for Go that I think solves the same problems that "generics" solve. The focus is on * No text templates (generic code is valid, compile-capable go code) * Compile time type safety * No Reflection It's still early in its development (working on the feature that makes version 0.2.0), so not quite ready for a real release, but it is fully functional for the completed features (and is even bootstrapping itself) and comments are welcome.
Pretty good explanation here: https://www.youtube.com/watch?feature=player_detailpage&amp;v=vA0Rl6Ne5C8#t=328
Not sure I understand your question. There are possibly multiple type parameters. `T` is not very descriptive. `TypeNames` makes the intent clearer.
&gt; I have found gotk3 but in any place it says such bindings works on Windows platform, I need that such desktop application can work both on GNU and Windows. What I'm saying is that this sentence is wrong. gotk3 will work with both Windows and non-Windows platforms.
The error from a malformed body is different from the validation error. The first will be 400 (Bad Request), the other 422 (Unprocessable Entity). So yes, you have to return an error when decoding and another one when validating if you want to give the developer using the API more details about the error. If you don't like contexts, you can create a function similar to the body decoding middleware and pass the user as the argument. You won't have to use a context. There's no best solutions, the one you find the most simple, elegant and reusable is the right one for you. Maybe it's not for some other people.
we apologize - it was not written well, that was totally not our intention - we screwed up and we added an annotation to explain what we meant to convey instead - we'll try and do a better job next time
&gt; So, why use uint? For the same reason we use types. It seems that is an unpopular opinion but the two main reasons for use of int instead of uint is: * type conversions - but this shows more that the APIs are using int instead of uint. If it was the other way, the type conversions would be a downside of using int. * underflow - the fact that a underflow happens is a bug and should not be an excuse to use int. On underflow it should just panic. For me it doesn't make sense otherwise, it's like dividing by zero, you are trying to give a value that the type doesn't support. Of course, we should have a way to work in case we are expecting under/overflow, but the default should be panic.
thanks for the feedback, agreed - we'll try and spend some more time next time
You're right on every count -- but I want to point out that, for array indices, uint types are great. Uint is a great way to double your index range without using more space, which is important in compact/tight data structures.
This is really interesting! I wonder what the go team think about this given they didn't want to add templates/generics.
Sorry, but you live in a perfect world. The link I gave shows some of the pitfalls with unsigned types, such as: `if (i &lt; v.size()-1) {`. As I said, sometimes intermediate **calculation** results require negative values. Thinking that programmers are always smart and know what they're doing is overoptimistic approach to programming in general. I understand the desire to strive for correctness, but at the given moment it's simply unrealistic to pursue.
&gt; In my opinion there is simply no reasons to use an unsigned type ever.... &gt;if you need it, you'd better be using larger type (like int64). So, why use uint? In applications where you need to be frugal in using memory, you do need uint.
&gt; On underflow it should just panic. That would require instrumentation every time there is arithmetic with a uint, since the CPU won't handle this for you.
That 'if' is a bug, so it should be treated as such. That code, for me, makes the same sense as division by zero. The main issue with using uint and the underflow is that most languages just eat under/overflow as if nothing happened, when in reality when it happens is the case of a bug and whatever operation is going should be aborted. &gt; Thinking that programmers are always smart and know what they're doing is overoptimistic approach to programming in general. Actually I think otherwise. That is why I prefer to use uint, it removes a bunch of invalid values. The more restrict the type of possible values, the better. The main problem is that languages treat under/overflow as valid operations.
Thanks for the response. &gt;The error from a malformed body is different from the validation error. The first will be 400 (Bad Request), the other 422 (Unprocessable Entity). I don't freaking care. I can live with 400 for all malformed requests, if the only alternative is cluttering the code. &gt;If you don't like contexts, you can create a function similar to the body decoding middleware and pass the user as the argument. That means I would have to process the decoding errors in the handler, and I've had enough of that shit. I prefer as little code (especially repetitive) in my handlers as possible.
Just want to link a tool I've been using for generics-like functionality recently. It's still an early version, but I think it's promising. https://github.com/ncw/gotemplate
Thanks, I appreciate that! My take on the situation is that the Go Team has spent a lot of time expressing that they believe there's more than one way to solve the problem that 'Generics' solve, and are really going the distance to extol the virtues of code generation. I've tried to combine what they seem to be aiming at with the kinds of abilities I'd personally like to use while coding, so hopefully what they think is "That's what we were talking about!"....
&gt; Actually I think otherwise. That is why I prefer to use uint, it removes a bunch of invalid values. That's fantastic, and as long as you're the only person working on a project then the bugs you will inadvertently introduce will be no ones problem but your own. For those of us that work on teams with other programmers and understand that humans do in fact make mistakes, it's much easier to avoid bugs by using int.
Yes. It has impact in the performance. But it should be the default behaviour. All those bugs associated with overflow would be removed. Of course, when you have logic that will cause overflows, mostly bit fiddling, or when performance matters you should be able to cut that validation off.
I think this point was missed by a lot of the readers. go generate is a feature for package maintainers, not clients.
It looks good. The fact you have GetSection and Section is a little confusing, though (same with GetKey and Key). For a future version, you may want to consider renaming Section and Key to SectionOrNew and KeyOrNew to make their behavior clearer and then rename GetSection and GetKey to just Section and Key. MustSection and MustKey methods might be handy, as well.
uint is useful when you need bit fields.
cool stuff. fyi, https://github.com/conformal/btcec might be faster than go-secp256k1 and it's all native go.
&gt; All those bugs associated with overflow would be removed. Or you could just use an int, as we do.
You can also do bitfield manipulation with signed ints, it just a matter of using the right masks.
It's as simple as type Queue interface { Put(Event) error Consume() (chan *Event, error) Close() error } Each implementation needs to run some feeder goroutine, which will send arrived events to the chan *Event, wrapping it if needed (like wrapping *amqp to *Event). Keep in mind, that it was designed for my particular case (I use rabbit just for persistancy for long-running tasks queue).
Would love to see a data processing tool in Go. For scheduled metrics, I use pandas, which is fast, but would like to see a port in Go.
Have to ask, are you from Galicia?
I like the general ideas here, although I think that the idea of checking for the implementation of canonical methods (like Timeout() bool for timeout-related errors) is somewhat brittle since it requires the package author and, more critically, authors of packages that the package in question uses, to obey this convention. The first problem is easy to solve, but the latter is much more difficult. There's no good way to guarantee that a package's imports don't violate this assumption, and you could end up with a successful assertion that you take to semantically mean that the error means something other than it really does. For example, if you import package "a", which imports package "b", and package "b" uses the Timeout() bool method for things other than timeout-related errors, asserting against interface{Timeout() bool} will not be sufficient to tell whether the function in "a" that you called intended to indicate a timeout-related error. I think that a cleaner approach would be to have packages define interfaces that include unexported methods that they can use for internal checking, and then export error-checking functions. For example, inside package "a": type timeoutError interface { error isTimeout() } func IsTimeout(err error) bool { _, ok := err.(timeoutError) return ok } Using this method, you'd be guaranteed that the semantics of the check were not reliant on the proper use of conventions, but would be rather enforced by the language. Notably, this is backwards-compatible with the current practice of defining specific error types such as: type networkTimeout struct { err error net string } func (n networkTimeout) isTimeout() {} Note that the one case this does not handle is that of checking against, for example, timeout-related errors from *any* package. For example, you might want to know if package "a" **or any of its imported packages** intended to indicate a timeout-related error. In that case, this method wouldn't work. I can't think of a good way to incorporate the good features of this suggestion and yours into one method, but it'd certainly be useful to come up with such a method.
I keep forgetting you can declare types inside functions. That's a huge win for types you only use once like in these cases.
Thanks, I might benchmark the two and write up the results
Basically what's going on here is that the overflow check is being deferred until you try to index the array. It seems like... your actual goal is being achieved, while avoiding the unreasonable overhead of instrumenting arithmetic. Hooray go!
You also use an anonymous interface declaration, but I decided not to use that in my post because it isn't as clear, and gofmt doesn't preserve the format I'd like func IsTemporary(err error) bool { te, ok := err.(interface { Temporary() bool }) return ok &amp;&amp; te.Timeout() } _protip_: this is exactly what happens every time you write `interface{}`, it's not a type, but an anonymous declaration of an interface with no methods.
@dgryski, neither you nor I have any obligation to perpetuate this incorrectness.
Very informative!
I don't really like this. If you control the types of possible errors that can be returned, then it might make sense. But if you return errors that were generated by a third-party library, you'd need to ensure that the third-party library didn't start using an error which implements a method with the same name that you were using yet has different semantic meaning (different retry logic, etc.)
Don't over think this, the use case for the last 5 years has been Timeout() and Temporary(), for everything else, the error should be considered opaque. If you are communicating complex state back to the caller via specific error values with complicated methods sets, you're doing it wrong.
/u/marineo02cro, jjasonclark wants to send you a Bitcoin tip for 400 bits ($0.13). Follow me to **[collect it](https://www.changetip.com/collect/289274).** [ChangeTip info](https://www.changetip.com/tip-online/reddit) | [ChangeTip video](https://www.youtube.com/watch?v=_AnfKpypMNw) | /r/Bitcoin
I probably wasn't clear in my message. I think we should use uint, I think it's the better option, the type is more restricted. But in the current situation we should use int, because of those 2 reasons I said before. If that 2 reasons would no longer be valid, then uint is the better option. Ada is a good example of this, even better because we can be more restrict than uint.
Very interesting. I have been wanting to set up something that runs periodically to check my isp and keep them honest, but I have never had a clear way to do it programatically. This may help.
&gt; Your project manages the memory has gotk3 claims to do? in go-gtk, widget struct has a pointer of native widget. And the pointer shoud be released when the widget is destroyed. Setting finalizer is good to handle the memory-releasing when the pointer is not handled with container widget. For example, when the label widget is created and not contained as child widget in container widget, it should be memory leak. gotk3 just do it. If you add the created widget to container, the container do memory-release when the widget is destroyed.
If I understand you correctly, you mean that go-gtk memory management is not like gotk3, but in some cases it will do the Right Thing™ and it others I have to do the Right Thing™ for go-gtk, manually. Right?
Tried a few different servers but both failed, using go version go1.4 darwin/amd64. Browser ui works for both tested locations giving 220/20~ mbit Gathering server list and testing... 5 Closest responding servers: ------- ------------- --------------- ------------------ ----------------- ID Name Sponsor Distance (km) Latency (ms) ------- ------------- --------------- ------------------ ----------------- 0 Helsinki DNA Oy 0.56 2.667996ms 1 Helsinki Elisa Oyj 0.56 2.66329ms 2 Tallinn Starman AS 82.78 3.93155ms 3 Tallinn Telset AS 82.78 22.150432ms 4 Tallinn AS EMT 83.08 5.255855ms ------- ------------- --------------- ------------------ ----------------- Enter server ID for bandwidth test, or "quit" to exit ID&gt; 0 Latency: ▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ 2ms avg 2ms median 4ms max 2ms min bandwidth test failed: EOF
Ah, I see! Thanks for all the information indeed!
Cool. I've literally just finished writing the unit tests for my speedtest.net library. Got to do the CLI next.
To take a concrete example from this CL https://go-review.googlesource.com/#/c/2032/2/ which is what I suspect triggered this blog post (I am the author of the CL). The function `net.http.RoundTrip` can return a number of errors: * When the request URL is empty * When the request header is empty * If an unsupported protocol scheme was chosen * If there is no host in the URL * or if either `connectMethodForRequest` or `getConn` return an error Previously, in order for a consumer of the API to determine what the error was they would need to do string comparison - brittle and not a great experience from a users point of view. I agree with /u/davecheney's assertion about adding new types for errors, but not so much in the public declaration of `error` instances, as with the CL linked above. So for the `RoundTrip` example, is the suggestion here to create a new private type for each error case, then have public functions to test each one? i.e. `IsRequestUrlEmpty(err error) bool`, `IsRequestHeaderEmpty(err error) bool`, `IsUnsupportedProtocolScheme(err error) bool` ... and so on? I don't see how this is easier or less brittle than: _, err := t.RoundTrip(...) if err == http.ErrNilRequestUrl { // do something } As opposed to, what I think the suggestion here is: _, err := t.RoundTrip(...) if IsRequestUrlEmpty(err) { // do something } I don't see what the advantage here is over the first solution, with the first solution a consumer can quickly and easily determine what the error was in a manner that will not be broken the first time an error string is changed. Am I completely missing the point here? &gt; This suggestion fits the has a nature of Go’s implicit interfaces, rather than the is a [subtype of] nature of inheritance based languages. For the errors above, what would the actual error implementation look like, something like this? type transportError struct { error requestUrlEmpty bool ... } func (e transportError) RequestUrlEmpty(err error) bool { return e.requestUrlEmpty } func IsRequestUrlEmpty(err error) bool { type requestUrlEmpty interface { RequestUrlEmtpy bool } if e, ok := err.(requestUrlEmpty); ok { return e.RequestUrlEmpty() } return false }
I do this with a cronjob using this client: https://github.com/sivel/speedtest-cli Of course it's on my desktop at home, so I can't share it while away for Christmas, but basically it just appends a line with speedtest/date to a text-file every hour. If you are on an inferior system without something like cron, then it would probably make sense to make it all in go using the library posted by OP and then just have a loop that sleeps for however long you want the intervals to be and then run the test and go back to sleep and so on.
Hahaha. You got it!
In this case I don't think the caller should be inspecting the error, I believe all the cases you mentioned are caused by programming errors creating a request from invalid data. The caller should be checking the parameters before issuing the request. Let's continue this discussion on https://github.com/golang/go/issues/9383
Nice! It works great here: &gt; speedtest Gathering server list and testing... 3 Closest responding servers: ------- --------------------- ------------------------ ------------------ ----------------- ID Name Sponsor Distance (km) Latency (ms) ------- --------------------- ------------------------ ------------------ ----------------- 0 Indianapolis, IN BridgeMAXX 35.70 33.878569ms 1 Danville, IL Cellular One of ECI 96.27 34.713334ms 2 Champaign, IL Pavlov Media 147.67 29.995571ms ------- --------------------- ------------------------ ------------------ ----------------- Enter server ID for bandwidth test, or "quit" to exit ID&gt; 0 Latency: ▇▆▂▅▁▃▇▅▇▆▆▆▆▆█▆▆▇▅▂ 34ms avg 35ms median 37ms max 30ms min Download: 89.71 Mb/s Upload: 21.63 Mb/s I get the same/similar results with the python `speedtest-cli`: &gt; speedtest-cli Retrieving speedtest.net configuration... Retrieving speedtest.net server list... Testing from Comcast Cable (68.58.84.189)... Selecting best server based on latency... Hosted by Innov. Network Solutions (Indianapolis, IN) [35.70 km]: 39.976 ms Testing download speed........................................ Download: 87.01 Mbits/s Testing upload speed.................................................. Upload: 21.09 Mbits/s I've never had the same results from the `speedtest-cli` because of the server that gets picked via the web interface seems to be different/optimal for my connection: http://www.speedtest.net/result/4008431394.png
But then you can have problems when shifting bits. It's a minor point, though.
Joining myself to the question. I've also seen that ChromeOS supports NaCl (Native client). I read somewhere that Go is able to compile to that, too, but there was no support for ChromeOS. Don't know why, given that's native client too. 
I am seeing a few servers do the same thing to me on my VPS that has an insane connection. Do you by chance have a really fat pipe? I am guessing that there is a hidden limit on how large of a chunk you can request for a download and I need to perform multiple requests. I will tinker a little more and push updates.
The web interface appears to select based on available bandwidth of the test server as well as latency. I'll pull that metric in the initial configuration and display it too. My guess is that your 100Mbit+ connection is overwhelming the server picked by lowest latency.
Just checking in to mention I have the same problem here. On 500/500 and I tried a couple of times, let me know if you need me to test anything! :-)
Sure thing! speedtest-cli does work FWIW :) You might be able to get some ideas from there. Yeah it's nice, I felt I owed it to myself to get it because I used to have the shittiest internet for a really long while, but it's true you get used to everything! 
Also taught spring of 2014: http://www.cs.cmu.edu/~dga/15-440/S14/ The instructor, Dave Andersen, also has a great blog at http://da-data.blogspot.com/ and in particular a post about teaching this class in Go the first time at CMU: http://da-data.blogspot.com/2013/02/teaching-distributed-systems-in-go.html
I heard they're not teaching it in Go this coming semester, which made me sad :( Go was a good fit for the course.
Seems to depend on who's teaching it. Gregory Kedsen's class is here: http://www.andrew.cmu.edu/course/15-440-f14/ (fall 2014) and seems to be in Java and C.
I read tha it is more used on clients than servers. went with scanner and probably will switch back to bytes.Reader as the docs stats...
Isn't `Fprintf` really inefficient because of all the reflection? Do the generated functions always return `nil`?
GHP: Hypertext Preprocessor
Mind doing a pull and retrying? It appears the servers kick us off if we try to do a pull greater than about 10MB. I set the maximum pull to 8MB for safety. I am not seeing any more EOF errors on my VPS now.
I think I'm going to run through this course myself. I'll PM you if I struggle. Thanks!
It's a good summary , but not so deep, I hope you can dig it deeper which will be a good helper for go's developers.
I think the nacl that chromeos uses is the portable variant like chrome browser which go cannot compile to yet
He's right, but could have said it better. I don't understand the down votes though.
Any chance you can squash it to a single commit so I'll be able to comment on the diff?
The article is not about generics, it's about HTML templates.
I've added a couple of notes on the first commit. It's mainly fine, just some improvement ideas.
If it's designed for global use, you may need want to add a sync.Mutex, or look at atomic.Value for the store. Have you tried testing with -race ?
Working fine on my connection. Latency: █▁█▁██████▁█▁▁▁▁▁█▁█ 0ms avg 0ms median 1ms max 1ms min Download: 839.90 Mb/s Upload: 799.71 Mb/s
I thought go statically compiled everything, why would the underlying system OS matter? Does OP mean "shared library callable from a ChromeOS app"?
In `GetInt`, if the value is a `float64`, you round the float, format it as a string, then parse the string as an integer. You have managed to turn a single cpu instruction into multiple function calls and a dynamic allocation. Also the comment for `GetInt` says `bool`. It looks like you copy pasted from `GetBool` and didn't change it. Overall, this looks just like a global `map[string]interface{}` with some convenience casting methods. I'd much rather just have a globals package that had the correct types. package globals var DatacenterName string var CurrentBitcoinPrice int var StringThatLooksLikeANumberSometimesButShouldntBeCastedAsOne string You could also declare these variables in packages where they are more likely to belong, as long as this doesn't cause a circular import. The only thing your package does that ordinary variables don't, is arbitrary naming. So for instance, you could store users redis-style with `Set("users:12345", User{name: "foo"})`, without knowing the user id ahead of time (e.g. read out of an http request or database). However, it would be better to just have a datastructure to just store that. var Users map[string]User // or map[int]User if user ids are just integers This is better in every regard since there is no casting (i.e. shorter, faster, more correct code (that the compiler checks for you)). It will also be easier to document since it can get it's own document comment. Also, it will be easier for editors to offer support for in terms of type inference, autocompletion, documentation presentation, etc.
Excelente
In `Registry` you don't have to wrap the last part in an else statement since you return in the if statement. Effective go suggest not to use else statements when not needed: https://golang.org/doc/effective_go.html#if
Even though they are not exported, package variable i and registry struct member m could have more descriptive names. The single letter variables idiom in go is mostly limited to function parameters, IIRC.
Excellent! Thanks for sharing. looking for any and all viable packages.
Ah, Bitcoins. Nice.
Sorry for being harsh, but you're doing something simple in a complicated way. In your own code, you could simplify: var i *registry func Registry() *registry { if i != nil { return i } else { i = new(registry) i.m = make(map[string]interface{}) return i } } to: var Registry *registry def init() { registry = make(map[string]interface{}) } But why would anyone use this functionality is beyond me. I would much rather have var Foo int Foo = 5 foo := Foo instead of: goregistry.Registry().Set("foo", 5) foo := goregistry.Registry().GetInt("foo") Your code just adds unnecessary layer of redirection with worse API, is many times slower and more memory hungry. 
A license nitpick: don't put "All rights reserved" next to "it's apache license". It's one or the other. The proper way is described at the bottom of http://www.apache.org/licenses/LICENSE-2.0.html
This needs to be addressed. I have read the github and have no clue what the added benefit of all this indirection is. From the README: &gt; Implements the singleton pattern so the same instance can be used anywhere. What does that even mean? It looks to me like a map[string]interface{} that has some methods to do type switching. When would I use this?
Yep, I agree. I appreciate the feedback!
Great stuff, thanks! I'll add the Example functions, it's cool that Golang supports that feature. I just learned about init, I like that idea. The line, fmt.Sprintf("%s", s), does seem like a better way of doing it instead. How do you suggest enforcing integers? Thanks so much for your input, exactly what I was looking for!
Ah, that makes sense. Good find, thanks!
Cool, yeah I see my mistake now. Thanks for the clarification.
I have not worked with them yet, but I will thanks to your comment. I appreciate the info!
Good point with the init(). And I forgot about method chaining so that's a good suggestion too. And you're also correct, I could create Set() and Get() functions that use i so it could be written as goregistry.Set() instead. I got so caught up in using methods, I didn't see I could use functions that directly modified the package level variable. I appreciate your comments! You were not too harsh - this type of feedback is really helpful. 
Wow, great information! I think your approach does sound more idiomatic. Instead of building a container of everything, build smaller containers of explicit types since Golang already has rules in place for the types. Yeah, my type conversions are unnecessary overheard. Thanks for the good stuff!
I went from PHP's Symfony madness to Java's Spring madness. I might be a bit bitter from working in the enterprise. Now I'm building a roguelike in Go to learn it. I can't find golang jobs yet but I hope they're coming. I feel like the best way to get to know a language is to write programs (not libraries) in them.
Haha, yep, fun stuff. I was a Phalcon guy - loved it, but Go has great program design in mind. I love that it's designed to be productive, it just doesn't have the community support yet like PHP or Python. Writing is the best way to learn - it's just easier to get people to critique your work in small doses. Good luck with the game! You have github repository?
It obviously is different to buffer overflows. For one, the result is well defined. The cost of dealing with overflow panics would be huge both computationally and in code complexity. Fwiw, I've never had an issue with overflowing int in five years of using. Go. 
Hey, I'm Lionel Barrow. I wrote the Go library for Braintree. Using floats instead for currency amounts was definitely a mistake and I'll be correcting it in the next major version (although I don't have a time for when that might be). I'd be very happy to incorporate any changes you have to suggest into upstream. To the OP: You can definitely use Go and Braintree! If you have questions or run into any issues please, please email me at lionel.barrow@getbraintree.com.
Hey, I'm going to bore you again - why 386 binaries? At first I was like what-a-waste-of-space, now I'm just genuinely curious.
People use 386. I don't understand your question.
What people on what OS under what circumstances? Be realistic, no-one uses i386 binaries for *development* under neither Windows, Linux nor OS X.
You can get a stronger sum type using the visitor pattern (which is the typical way to get sum types in Java). The main advantage of this approach is that, like with "real" sum types, you get compile-time checking that you've handled every case. It also seems to mesh better with Go's interfaces, since there's no need to introduce a dummy method so the interface can work as a tag. On the other hand, bypassing Go's type switch construct is a little disappointing, since the automatic casting in type switches makes the syntax pretty clean. It's also interesting to see that having "r" as an assignable return value comes in handy here (since you can't return from inside a lambda). In Java, I'd solve the same problem by making Visit usable as an expression (like case expressions in functional languages) by giving it a parameterized return type, but the lack of generics makes that annoying in Go.
It's also not too difficult to write a static exhaustiveness checker for `switch` statement, although it has to use heuristic to infer the set of alternatives. The heuristic is needed because you can add further subtypes to `Expr` because of the way anonymous embedding works: the private `isExpr` marker method is not filtered out.
`O(max(input)+n)` Oh my. :P In case anyone misses it in the readme, this is a "ridiculous" sorting algorithm (like [Bogosort](http://en.wikipedia.org/wiki/Bogosort)). Don't use it.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Bogosort**](https://en.wikipedia.org/wiki/Bogosort): [](#sfw) --- &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), __bogosort__ (also __stupid sort__, __slowsort__, __random sort__, __shotgun sort__ or __monkey sort__ ) is a particularly ineffective [sorting algorithm](https://en.wikipedia.org/wiki/Sorting_algorithm) based on the [generate and test](https://en.wikipedia.org/wiki/Trial_and_error) paradigm. It is not useful for sorting, but may be used for educational purposes, to contrast it with other more realistic algorithms; it has also been used as an example in [logic programming](https://en.wikipedia.org/wiki/Logic_programming). If bogosort were used to sort a [deck of cards](https://en.wikipedia.org/wiki/Deck_of_cards), it would consist of checking if the deck were in order, and if it were not, throwing the deck into the air, picking the cards up at random, and repeating the process until the deck is sorted. Its name comes from the word *bogus*. &gt; --- ^Interesting: [^Gnome ^sort](https://en.wikipedia.org/wiki/Gnome_sort) ^| [^Trial ^and ^error](https://en.wikipedia.org/wiki/Trial_and_error) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cn5rmak) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cn5rmak)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
One note. Your documentation is not clear that when using the Get function you may have to type assert as it is technically an interface type. 
I'm traveling and can't reconfirm exactly what happens, but I did verify for the post that it is indeed impossible for an external module to implement that interface. Static valuation should be possible. Perhaps someone else will be kind enough to post the error that comes up. Note you can't do it on the playground because you need multiple modules. 
Ill just throw this out there. Writing compilers is a current major use of Go. In particular, the go compiler comes to mind. Great read though, some good insight in there.
Good point, thanks!
The original bash version from 4chan seems much more succinct.
I suggest watching ["Implementing a bignum calculator"](https://www.youtube.com/watch?v=PXoG0WX0r_E), which shows how to solve the AST problem differently than the usual ways (visitor and sum types).
Maybe this is the "least bad" solution, but it still feels clunky. I think it would be easier to do something like this (EDIT: perhaps 'easier' is the wrong word--it feels slightly more intuitive to me; I recognize that it's still far from pleasant): package os type ErrorCode int const( ErrExists ErrorCode = 0 ErrNotExists ErrorCode = 1 ) type Error struct { Message string Code ErrorCode } func (e *Error) Error() string { return e.Message } func (e *Error) Code() ErrorCode { return e.Code } Then in use, it could just look like: func main() { info, err := os.Stat("SomeFile.txt") if err != nil { // I'm not sure what all errors os.Stat() can return--maybe it's sufficient // to ignore the `ok` flag altogether? osErr, ok := err.(*os.Error) if ok { //handle os.Error } else { //handle other errors } } } It might be a little more verbose (I don't know--I've never had to type switch) but I like it better than the idea of type switching or the whole os.IsExist()/IsNotExist() thing. Perhaps I'm naive?
I knew there had to be a library out there that made this easier, but my Googling wasn't turning up anything. Thanks! I'll try it out!
There's also [go-simplejson](https://github.com/bitly/go-simplejson), which I've used quite a bit. Its API is a bit quirky; Jason looks like a promising alternative. Edit: However, I would recommend avoiding these types of packages as much as possible—type safety is nice. If it's writing the structs that's bothering you, use [gojson](https://github.com/ChimeraCoder/gojson), a nifty tool that takes some JSON as input and writes an equivalent Go struct for you.
True - type safety is good, but when I'm trying to bang around ideas, it's labour intensive to have to type so much boilerplate. I'll probably use Jason to get rolling, and refactor it out later when things stabilize and I know what my final data structure will look like.
https://github.com/ChimeraCoder/gojson/ is a huge timesaver. Curl some JSON and pipe it to this utility and it generates the struct definition for you. With this method you don't sacrifice type safety. With a basic IDE like GoSublime you'll get auto completion while coding 
From the introduction it sounds like environment variables are used by some 2FA app to ensure people _don't_ store environment variables in config files and accidentally distribute e.g. passwords to others. But looking a bit at the source code and the examples shows that this parses environment variables from a config file and sets them? Isn't that contradictory to the introduction? Sorry if I am misunderstanding -- but perhaps the package could explain a bit more about what it's trying to solve? EDIT: I found [the link to a Ruby project at the bottom of the page](https://github.com/bkeepers/dotenv#dotenv-) which describes briefly.
I hear you coming from a python background, but implore you to try gojson first. Seeing the structures typed out leads to a better understanding of the APIs in my experience and how to best integrate them with Go. The relatively small extra time to reorganize the generated structs and name them might suprise you with some unexpected dividends. You will then also have types to attach methods to. 
Great tip! Please have 400 bits from /u/changetip
/u/KyleBrandt, jjasonclark wants to send you a Bitcoin tip for 400 bits ($0.13). Follow me to **[collect it](https://www.changetip.com/collect/301165).** [ChangeTip info](https://www.changetip.com/tip-online/reddit) | [ChangeTip video](https://www.youtube.com/watch?v=_AnfKpypMNw) | /r/Bitcoin
Type safety is nice as well as unnecessary and inefficient when you're building prototypes. +1 https://github.com/antonholmquist/jason
"`interface{}` is a code smell" +1.
The first is equivalent to the second; both work and both are fine, though the second is a little more focused. The third is incorrect. The compiler would be free to run the N new goroutines after i reaches len(input)-1, which would result in incorrect output.
I actually find it very useful (and with `gojson` it's easy) to unmarshal into a struct because then my editor can autocomplete stuff within the struct. Otherwise I usually end up having the JSON in another window as reference.
Why would you call log.Println() from an HTTP handler? EDIT: I meant log.Fatalln(), sorry. Muscle memory :). I don't see why you should kill the program if something goes wrong in a handler.
looking at his code, i see nothing wrong with `log.Println("Listening on 8080")` unless i'm missing something.
Yes. It is expected to work. 
If you're concerned about individual bits of memory, you probably won't want to be using a language with a runtime. Maybe there's some memory-sensitive allocation for which a runtime is permissible?
How do you panic on underflow without a check every time the value changes? Perhaps I'm misunderstanding something?
How is uint more restrictive? It occupies a broader range of values.
What's the architecture of your go app and the program you're running? I've seen issues with 64-bit commands not always returning the full stdout buffer on exit from C++ client code (CreateProcess - which is probably what Go is using under the hood on Win32).
There is something about the algorithm that makes me want to think it has the potential to be fast if, like, the list were, like, somewhere between 20 and 50 items long, and each item was guaranteed to be between 0 and 1, and you used a time.Duration of 0.1 seconds, and the machine you're on has like 16 cores, and there are no other processes running. 
and it does, now I'm very confused...
&gt; there are no other processes None? What about the kernel? :) But really, any algorithm that causes the processor to sleep (essentially wasting time) will not be fast, even if the result is correct. There are other linear-time ways to sort a list without snoozing the CPU.
Man, I am loving Go thanks for your efforts man!
Your homework today is to use Go's benchmarking tools to find out how long it takes to sort 20 items, and compare it to your proposal. Seriously. It'll be fun. Try it. And, totally seriously, it'll make you a better programmer.
In that case, yeah I agree. I really really hate finding fatal in libraries also. 
It just gets better and better. THANK YOU!
I'm getting a strange error: &gt; speedtestdotnet/servers.go:91: unknown http.Client field 'Timeout' in struct literal What is the go version requirement for this library?
make sense, I will change this, thanks for pointing it out.
I can't say much about these bindings, but I have had a lot of experience with CEF. It's pretty good stuff, and has been around for ages. Basically what you expect: embeddable chromium. Hopefully they are using CEF3 (there was a huge direction shift after CEF1 that made updating very hard for us, since the API changed a ton).
Thanks so much for your work. I use your plugin every day. $3 /u/changetip
The Bitcoin tip for 9,557 bits ($3.02) has been collected by *farslan*. [ChangeTip info](https://www.changetip.com/tip-online/reddit) | [ChangeTip video](https://www.youtube.com/watch?v=_AnfKpypMNw) | /r/Bitcoin
Thank you, first time I receive something for vim-go :) It's feels good and I'm really happy to be able to help others! 
Thank you too for using it! As stated somewhere else, I thank to the awesome contributors of vim-go, without them this project wouldn't be as successful as now :)
Having not used Qt, I cannot compare the two. I'd pick the one that makes me more comfortable.
Depending on what exactly you need, Tk might be the answer (https://github.com/nsf/gothic). Worked pretty well for a basic application for me, and the Tcl/Tk runtime isn't that big (about 19MB on all platforms iirc). Qt is a fair bit bigger. That was actually my main reason to choose Tcl/Tk, node-webkit/Qt/CEF produced way too huge binaries for an application this simple. The only thing about Tk is that you will want version &gt;=8.6 (I think) and OS X and some Linux distros ship with an inferior version (and Windows does not ship with it at all). Also it's a bit of a learning curve, as its nothing like Go or HTML/JS :).
One final note. I can copy the executable built on the CentOS 6.5 system to the src/sixty directory on the Ubuntu system and it runs fine after modifying app.conf to provide the correct MySQL credentials (I had already created the needed database and tables).
Output of `go version`? Full text of the errors you are getting?
https://golang.org/doc/go1.1#return
Sorry about that, ubuntu 12.04 ships with the original Go 1.0 release. I'd recommend using the tarball from the official site. 
Heh, maybe try using the package manager next time ;)
Thanks for sharing your project. Quick comment on your [main.go](https://github.com/vgarvardt/rklotz/blob/master/main.go#L8) which uses relative imports. It seems this approach is generally not recommended as mentioned [in this post](https://groups.google.com/forum/#!msg/golang-nuts/n9d8RzVnadk/07f9RDlwLsYJ) so unless you have a legitimate reason, it might be prudent to revise it. 
hehehe. cheers
This looks cool, is there a way for the executable to not open a terminal window? I downloaded the example and it seems kind of annoying for it to have two windows open. Is this a limitation of Go specifically or do all CEF applications function this way? (I am not familiar with CEF at all) Edit: also to further the conversation, I have previously looked at https://github.com/andlabs/ui as a GUI toolkit. It seems promising. Edit2: Just did a little more research and it seems if you build using ```go build -ldflags="-H windowsgui"``` it might hide the command window. I haven't tested it yet but I think it would work.
There is no need for reflection since it has no arguments other than the string. I also run a small test and FPrintf run slightly faster: https://play.golang.org/p/N6GideE5GE 
I may be on the wrong tack, but if you're already doing client-side auth, you can skip any middleware-based oauth authentication, and just forward the token from the javascript client to the back-end (using a similar "Authorization: Bearer" header). The back-end can validate the token directly with Google as needed, with a simple HTTP call. https://developers.google.com/accounts/docs/OAuth2UserAgent#validatetoken Then use the 'people.get' API (with the special 'me' username) to get more info about the user, and subsequently validate their ID (and/or domain) against your own ACL. https://developers.google.com/+/api/latest/people/get
Are you strongly opposed to adding subcommands, or did you just not need them?
No luck here yet I'm afraid: Gathering server list and testing... 5 Closest responding servers: ------- ----------------- -------------------------------- ------------------ ----------------- ID Name Sponsor Distance (km) Latency (ms) ------- ----------------- -------------------------------- ------------------ ----------------- 0 Alblasserdam Qweb | Full-Service Hosting 72.94 4.008644ms 1 Utrecht Vodafone NL 75.12 4.637271ms 2 Antwerp Nucleus BVBA 77.42 4.826063ms 3 Doetinchem Avira B.V. 80.52 9.735666ms 4 Voorthuizen SIT Internetdiensten B.V. 82.19 5.556724ms ------- ----------------- -------------------------------- ------------------ ----------------- Enter server ID for bandwidth test, or "quit" to exit ID&gt; 0 Latency: ██▁██▁▁█▁██▁█▁▁▁▁▁▁▁ 6ms avg 7ms median 7ms max 6ms min Error, the remote server kicked us. Maximum request size may have changed 
Getters/setters in Go? WTF?
Structs don't need getters and setters. They're open data structures. Go isn't OO in a way that would/could benefit from encapsulation or data-hiding. 
Never store password as plain text!!!
http://golang.org/pkg/encoding/json/ Each exported struct field becomes a member of the object unless (...) the field's tag is "-" (...).
Thanks for the info, I haven't read json tag section that clears a lot of things. Question then, I never found any article that tells the benefits of using unexported fields except for my polluted OOP mind "Encapsulation", any ideas? Edit Found this to be really helpful http://www.laktek.com/2012/02/13/learning-go-interfaces-reflections/
You probably shouldn't go around saying this. It's definitely not true. Encapsulation and data-hiding are useful patterns not matter what language you are in. Why else would Go offer private struct fields? What if you need to provide thread-safe access to properties? Or want a consumer to be able to read but not write a value? The Go authors even use getters/setters in the [stdlib](https://github.com/golang/go/blob/master/src/go/token/position.go#L108).
The way you linked the source may suggest it's normal in Go to use getter functions instead of exported struct members. If that was your intention, it's wrong. The File struct needs to ensure thread-safe access to its member fields, that's why getters. The ones that are not protected by mutex just happen to not be accessed concurrently in current implementation. However if your intention was to make a funny comment, you could post that instead: http://golang.org/pkg/flag/#Getter
I don't quite follow why the code I linked doesn't demonstrate the usefulness of getters in Go. I understand that in certain segments of the File struct they exist to provide thread-safe access to the fields (I mentioned this in another comment), but the getters that aren't using mutexes are still providing read-only access to to what would otherwise be private, inaccessible data. What am I missing? 
If there wasn't a need for thread-safe access, the struct fields would have just been made public. There would have been no need for getters.
I disagree. You should not be changing the values of File.name or File.size, yet it is still useful to be able to read their values. Given that they are read-only, there is no need to provide mutexes for them, and you still have thread-safe access. Getters provide a pattern to enforce this behavior.
Sure, that's your opinion and a lot of people agree with you. You asked what you were missing about getters in the stdlib, and it's that they are used sparingly. In the particular case of File, it was because of mutexed access. The standard library has tons of structs but rarely has accessors.
https://medium.com/@rakyll/interface-pollution-in-go-7d58bccec275
Please watch this ENTIRELY https://www.youtube.com/watch?v=yi5A3cK1LNA
Hi and welcome to Go :) This is just a little feedback, not a critic. Having getter and setter methods can be quite useful but I would be a little wary of generating them as you are doing. You don't always need them and their implementation might have to differ from time to time. Typically, when you need to synchronize access to your struct fields, they are welcome. (leaving the field unexported allows you to control access to it). But it requires that you use a mutex or any other synchronization primitive within your getter/setter. Or when setting one field needs to have side-effects on other fields, using a setter is appropriate because it allows you to modify several fields at the same time safely, if you handle it properly, still with regards to your struct being accessed concurrently) Making the choice of implementing Getter/Setter methods is something that I would handle case by case. Not every struct field needs a getter and/or a setter. Especially if you export these methods, it means that the client code can rely on it for some reason. If you were to have to change your internal implementation, it "could", at least in theory, make backward compatibility a bit tough. Finally, I encourage you to read effective Go : https://golang.org/doc/effective_go.html#Getters 
Hi, I don't have the required time to do an in depth analysis of you package. Therefore, i would like to apologize if my feedback seems a little bit light. I don't have the feeling that the code is idiomatic at all. First, on a cosmetic level the names can be improved, check this out [talk about names in go] (http://talks.golang.org/2014/names.slide#5). Then, it seems to me that the implementation is way too complicated for it does. it smells too much like Java, there is too much indirection and one line functions. The code seems over engineered. Generally with GO, the simpler the better. Some time you are using interfaces for the sake of using them. if there is not more than one type that implements you interface and you don't expect your users to provide new ones. Than there is no need for an interface.
Using BoltDB is unnecessary if this is a "simple" and "single user" blog. A JSON file would have worked perfectly and doesn't require an external dependency. 
Except for the first 5 minutes, I really like this talk. It changed my mind on how to develop in Go.
For the example he mentioned, it was actually for protection against writes. The field in question had to be immutable once set since there is no mutex locked here. But I think the example provided can be a bit misleading. There is a difference between having getter *and* setter methods versus having just a getter. You don't always do it for the exact same reasons. (A getter method without a setter method is useful for read-only access and/or synchronized read-only access (avoiding torn reads).) I guess garfj was mainly responding to pierrre though. edit: That's what effective Go has to say about them : https://golang.org/doc/effective_go.html#Getters
Apologies for my lack of clarity. I wasn't trying to imply that someone should be using accessors all over the place without good reason. I was merely trying to say there is nothing implicitly "WTF" worthy about them in general. Yes, people overuse the getter/setter pattern, but it's certainly not an anti-pattern when it's appropriate.
There's a trick to this that isn't entirely obvious. You can protect fields which will still be marshalled using the following pattern: type internals struct { Foo string `json:"foo"` } type Published struct { internals Bar string `json:"bar"` } func NewPublished(foo, bar string) Published { return Published{internals{foo}, Bar} } Calling `NewPublished("a", "b")` will return a struct which will marshal as `{"foo": "a", "bar": "b"}`.
I agree with you and the parent poster most likely does too. If we step back, the reaction was to a tool that automatically generates simple getters and setters. Getters/setters should be specialized use cases that are difficult to generalize.
*looks at name* Mm hmm
Won't load, reports too many redirects.
If you think using BoltDB for this project is creative, then I pity the users of your over-engineered code. The goal of Go is to prevent over-engineering. KISS
If you think writing your own blog engine in go is productive, you're missing something as well It's for fun
That was good! Reminds me of https://www.youtube.com/watch?v=o9pEzgHorH0 (Stop writing classes!)
See this: https://golang.org/ref/spec#Passing_arguments_to_..._parameters s := []string{"James", "Jasmine"} Greeting("goodbye:", s...)
Have you really found switching GOPATHs to be easier? [I'm a fan of the single GOPATH](http://mwholt.blogspot.com/2014/02/why-i-use-just-one-gopath.html) because its structure works not only for all my Go projects, but also *all* my other dev projects (JavaScript, etc.).
Very important point, Ill make sure to point that out in the Readme. The project in its current incarnation is really just supposed to be a kick-off point thats easy to debug/test.
How does the go-plus plugin for Atom compare to the GoSublime or vim-go plugins?
Author of the post here, the main reason I use multiple GOPATH's is largely because the author of GPM recommended the use of GVP to set per project GOPATH's. I'll be honest that I'm not convinced, especially since "best practice" does seem to be the single GOPATH. However, I do think direnv is better than GVP though, as changing projects is entirely seamless for me now. Using multiple GOPATHs seems mostly to be an ultra-conservative risk reduction decision. There may be better ways to handle it. The basic problem I want to avoid is if I work on Project_A for a while, and update a library it uses, and then need to make one simple edit to Project_B, I know that any bugs in Project_B are ones that I introduced by my new code change, and not because it also uses that same library which has now been updated. This is probably overkill. I'll re-evaluate as things progress. I've edited the post to mention this practice may not be needed.
Why not use the one that's provided in the extended standard library? Served me very well in several projects now.
Link for posterity sake: https://godoc.org/golang.org/x/tools/playground/socket
I enjoy the domain name.
That library seems old/abandoned. I've had success using this project's Engine.IO implementation in production: https://github.com/googollee/go-socket.io I haven't used the Socket.IO bits but I imagine they work fine, as Engine.IO is working swimmingly. 
As other commentors have ably noted, I don't think useful getters and setters can be auto generated. That being said, if your package did the right thing with an embedded `sync.RWMutex` when generating getters and setters it would have been quite useful to me while scaffolding a current project which has a fairly large number of synchronized structures, especially if it generated the truly tedious func (s *someStruct) GetFoo() (foo string) { s.RLock() foo = s.foo s.RUnlock() return } func (s *someStruct) SetFoo(foo string) { s.Lock() s.foo = foo s.Unlock() } That being said, my other major qualm with this package is that it doesn't seem to work very well with the `go generate` model. The default mode of operation should not be modifying the file in place, rather for a file `example.go` a better default would be to create a new file `example_gomusha.go` containing the generated code. Further, I don't think that it's appropriate to blindly generate public getters and setters for every private field. It would be better to allow the use of semantic comments or struct tags to determine which methods should be generated. It would also be useful to be able to output getters and setters for a specific offset in a file to stdout so that the tool could be invoked from an editor to create desired functions.
The accepted example didn't explain the portion about the json definitions within the struct. His go playground example included it, but the explanation was confusing to the original poster. Sometimes I like to help by example, rather than giving an explanation that confuses the person asking the question. Additionally (and this is a minor issue), the accepted answer ignores the error response of the json.Marshal. It's good practice to check for these errors just to make sure nothing bad happened along the way. 
I recommend this lib: https://github.com/gorilla/websocket
I've used the gorilla websocket package in production now for about 8 months without an issue.
Valid concern. That is the traditional dependency management problem. Gopkg.in is one possible workaround. But I have yet to be bitten by it so hard that I couldn't just checkout a particular tag or commit that works. And tests can help me to know if it's my code that breaks or a dependency (granted, this depends on the situation).
I'm based in Europe where most applications have to be multi-lingual. My country has two official languages and English is also often supported. That means eg three different ways of formatting, and parsing, dates. This might be beyond the scope of your library, but if you decide to take it there let me know; I'd be glad to help. I'm currently using Go strictly for back-end services where this issue doesn't pop up; but if I'd be tasked to write a front-end service I'd be hesitant to pull in 250+ ways of doing those things. This is talking merely about i18n. I hope that answers your question.
&gt; Luckily the struct only has exported methods and private fields. [...] Is there a better, approved way of doing this? I would say export all the fields and simply test using the struct, because the code that will be running will use that struct. Of course depending on the context of things then testing via interface is also valid approach. If you have only one struct that implements that interface - then remove the interface and make the struct fields public and use that struct directly. If there are over 3 types implementing the interface, then test with the actual structs or with the interface. If the type does external requests (i.e. db/file/web access) then use an interface to hide that. Of course it would be helpful if you described what is the exact thing you are building because there might be other ways of testing that thing as well.
I found [this](https://github.com/golang/text/tree/master/language) the other day, looks similar. Not sure if it does the exact same thing though.
New socket.io is *meh* if you don't want to have dropped connections. I use [SockJS-Go](https://github.com/igm/sockjs-go) at work.
I should clarify. The library I'm using, not writing, has the one struct with private data members and exported methods. I am testing my code written on top of this library. To make this concrete, I am writing a small library for the [blink(1) USB RGB LED](http://blink1.thingm.com/). (A library exists already, but this is a good exercise for me.) I am using the [go.hid](https://github.com/GeertJohan/go.hid) library to access the device over USB. go.hid exports a struct (among others) that wraps the C struct from [signal11's hidapi](https://github.com/signal11/hidapi). To test my code, I believe I need to mock go.hid. That is the context of my original post: how to mock go.hid for testing. I would rather write tests than not, even if my code is small.
I would rather skip the tests, too. I'm not doing anything super complicated. However, in an effort to understand testing better, it'd be useful to at least think about how to do so in this case. There are some other cases I'll have to deal with such as storing patterns and playback, but that's after v0.001 of setting the color, etc. My library basically takes your first example and makes it into the second set of examples. That is, I'm wrapping the HID API for the Blink's "api" that uses feature reports. Thus, to test the interface I want, I'm having to "mock" the HID API as in your first playground example. Thank you for all your input, it's highly helpful.
It just won't work. You cannot change local variables like that. You need pointers, and then you need to take addresses, and dereference, and your code becomes a mess.
You're right. That's why functions are allowed to return values.
The compiler's inlining ability has come a long way, and is only likely to improve. You may be surprised how little inlining by hand buys you.
If you take a look at my examples, you'll notice that the macros change many (if not all) of their parameters. And anyway, I don't feel like rewriting a few thousands statements by hand.
&gt; On another note, why even port from C? C is just closer to Go.
&gt; But in this case I would much prefer functions that take int pointers for readability reasons. It was the first thing I did. But it was ugly, man.
Try using the -a flag : &gt;-a &gt; force rebuilding of packages that are already up-to-date. &gt; In Go releases, does not apply to the standard library.
This is awesome! Just did a quick test on the reddit homepage and you get great results: $ curl -s http://www.reddit.com/r/all.json | gojson -name=Reddit package main type Reddit struct { Data struct { After string `json:"after"` Before interface{} `json:"before"` Children []struct { Data struct { ApprovedBy interface{} `json:"approved_by"` Author string `json:"author"` AuthorFlairCssClass interface{} `json:"author_flair_css_class"` AuthorFlairText interface{} `json:"author_flair_text"` BannedBy interface{} `json:"banned_by"` Clicked bool `json:"clicked"` Created int `json:"created"` CreatedUtc int `json:"created_utc"` Distinguished interface{} `json:"distinguished"` Domain string `json:"domain"` Downs int `json:"downs"` Edited bool `json:"edited"` Gilded int `json:"gilded"` Hidden bool `json:"hidden"` ID string `json:"id"` IsSelf bool `json:"is_self"` Likes interface{} `json:"likes"` LinkFlairCssClass interface{} `json:"link_flair_css_class"` LinkFlairText interface{} `json:"link_flair_text"` Media interface{} `json:"media"` MediaEmbed struct{} `json:"media_embed"` ModReports []interface{} `json:"mod_reports"` Name string `json:"name"` NumComments int `json:"num_comments"` NumReports interface{} `json:"num_reports"` Over18 bool `json:"over_18"` Permalink string `json:"permalink"` ReportReasons interface{} `json:"report_reasons"` Saved bool `json:"saved"` Score int `json:"score"` SecureMedia interface{} `json:"secure_media"` SecureMediaEmbed struct{} `json:"secure_media_embed"` Selftext string `json:"selftext"` SelftextHtml interface{} `json:"selftext_html"` Stickied bool `json:"stickied"` Subreddit string `json:"subreddit"` SubredditID string `json:"subreddit_id"` Thumbnail string `json:"thumbnail"` Title string `json:"title"` Ups int `json:"ups"` URL string `json:"url"` UserReports []interface{} `json:"user_reports"` Visited bool `json:"visited"` } `json:"data"` Kind string `json:"kind"` } `json:"children"` Modhash string `json:"modhash"` } `json:"data"` Kind string `json:"kind"` } 
I could do that, but I was hoping to have the system act more efficiently, by just rebuilding things that actually needed to be rebuilt.
Pointer dereferencing in inner loops can be slow. I removed them from a hash function I implemented for a ~20% speedup https://github.com/dgryski/go-spooky/commit/59f9b55535c05437a2b4d8f38217aeee970727e3 
I don't think inflating numbers in this way helps to present an accurate picture.
Well, I agree. An "accurate picture" is hard to get, though. For example, my code2014 included Assembly -- but only a little bit. Most of my time was actually in JavaScript. I mentioned all three in a tweet, but they each get an equal count. So I don't think this will throw off the graph too much. Especially since most Go programmers probably used at least one other language this year. A single #code2014 tweet can mention multiple languages and they'll all be counted equally.
You're only calling `install` on one particular package, and that is the only package that will be checked for updates to the source files. The `go` tool handles building the dependencies in an all (`-a`) or nothing way. So yes, it's expected behavior. You should also install via the full import path (`go install import/path/package`) rather than just relying on using the current directory to make sure you're package and directory layout are correct. If you want to conditionally rebuild dependencies, you'll need to have a build script or Makefile to call `go install` for each. Also, multiple paths in GOPATH can cause confusion, and unexpected behavior. The current general recommendation is to only use a single GOPATH entry at a time. 
&gt; If you want to conditionally rebuild dependencies, you'll need to have a build script or Makefile to call go install for each. That's the solution we've settled on for now. I just found the behavior odd that it can build dependencies once, but won't rebuild them. This caught us by surprise, and I had not found any documentation talking about it. &gt; Also, multiple paths in GOPATH can cause confusion, and unexpected behavior. The current general recommendation is to only use a single GOPATH entry at a time. Agreed. For the current project, there are issues with switching to a single path in GOPATH. I'll have to think about what can be done there.
Thank you. It is a great answer. It would be nice to have a less restrictive license. go-discreterand implementation and the detailed description of the solution at http://www.keithschwarz.com/darts-dice-coins/ has been very educational to me. Thank you. 
Well, the main page does say that this is a work in progress (the sockjs-go one), and I cannot really feel comfortable using something like that in production, even if it has proved to be stable. 
Seems like you'd be better off just copying and slightly modifying the code for printing %#v : http://play.golang.org/p/P0ue2_Yfel (If you really need the line returns)
Thanks for the comment. I thought [Paho](http://git.eclipse.org/c/paho/org.eclipse.paho.mqtt.golang.git) was a great project but I decided to create yet another MQTT client in Go for the following reasons. * Paho didn't follow the Go standard coding style written in the following articles and about 90 warnings were given by [golint](https://github.com/golang/lint): * [Effective Go](http://golang.org/doc/effective_go.html) * [Go Code Review Comments](https://github.com/golang/go/wiki/CodeReviewComments) * the master branch of Paho didn't support the latest version ([3.1.1](http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html)) of MQTT and it did only [3.1](http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html) * the develop branch of Paho supported 3.1.1 but it looked work-in-progress and I didn't know when it would be merged into the master branch * the develop branch of Paho imported [another third party package](https://github.com/alsm/hrotti/tree/master/packets) and was susceptible to the modification of the package
Perhaps use something like https://github.com/agoragames/nginx-google-oauth in combination with the standard NginX proxying functions, and then just run the backends on different ports. This way NginX handles the Google auth stuff and the backends can be very simple.
Thank you for the the hard work. I will definitely give it a try. BTW, do you plan to add a ( sort of ) complete example in order to show various APIs in action? That would be great. Thanks.
That may solve the specific example but not the actual problem, which is using generics.
Thanks for your interest and advice. It is an absolutely good idea. I will add a complete example to the documentation later. Thanks a lot!
Are we looking at the same page? Latest version, v2, is stable. 
I don't think this site could ever achieve an accurate picture. The subset of all programmers is just too small.
That's the problem with generics, there almost always a better solution for any specific problem.
"The problem was that I'm far too reliant on writing Python code like this:"
You said this solves the specific problem, I'm saying, every problem is specific. I get there from my experience in languages with generics and in Go.
I'm up voting you. For the record, I'm not a huge fan of the large and complicated tests that such frameworks enable. But it fits what he was asking for.
Hi, Your Procfile says "mainserver" is the name of the binary but it's cleaner-facebook-friends, you should update it.
Oh, really? I didn't, ha!, thanks!!
This is a terrible motivating example for generics. Actually, I have a sneaking suspicion that generics were excluded from Go to prevent exactly this kind of over-engineering, and the party line about generics being difficult to get right (though true) just serves to mask that fact.
great ! would like to see api auth as well, probably with Osin
I’ve found it informative even though this presents some very skewed metrics (since all languages get the same weight… I coded a _lot_ more Go than Bash this year) Next year it could use the heuristic of weight by order.
&gt; I have no idea of knowing if your repository will exist in the next year at that same address. To be fair, that's true of all repos. You can always delete a github repo. 
Do you think Go would be better with or without blessed parametric types such as `map[T]T` or `[]T` or `chan T` or `*T`? Is there something fundamental about *those* generics that the Go authors picked and other degrees of generics? My suspicion is that the level of blessed generics in Go was chosen by years of experience. I personally like it. But that doesn't jive with statements like this: &gt; That's the problem with generics, there almost always a better solution for any specific problem. If you listened to this line of reasoning, you might reject types like `map[T]T` because there is a much better and more specific implementation of `map[int]T` as opposed to, say, `map[string]T`. At some point, we must strike a balance. *But there is no one right balance*. This is at odds with "generics are bad because specific solutions are better."
Yet another programmer insisting on using functional idioms in Go, happy new year. 
&gt; I am not interested in wether an idiom is functional, imperative or anything else. Except you are. That is exactly what you did with comparing languages. Comparing apples to oranges. 
Are you saying that because he used Haskell as example? Would it make less functional if in the examples he used C++, C#, Rust or Java? I would guess, but author can validate it, that he choose Haskell as the example language since it's one of the languages with the most powerful type-system, and can be used in all the examples. Otherwise in some examples he can used Java in other Python in another Rust and so on... no consistency.
Good read. I just think that it has more than it needs to be, specially in the Generic section, it doesn't need to be so long.
Good point! I agree structure is not brilliant - it has kinda a mini 'what are generics' tutorial in it which breaks the structure and makes the article overly long (?). I felt compelled to include it due to the number I meet on a daily basis who do not really understand them.
&gt; I am interested however in comparing different language features to write robust software in a reasonable timeframe. But is writing the occasional for-loop really that much of an impact? No doubt, one of the reasons you chose go originally was because of the battery included nature of the library ecosystem. The reason why there were so many included libraries, was exactly *because* the language was simple enough to not impose high learning curves on new developers. Every language feature added has a cost, what concerns me is not the cost of compiler time, but the social cost imposed. To say it another way, what aspects of C made it the most widely used language in the world? Certainly language simplicity has to be near top of the list? 
What remains unanswered is why those problems were not solved in Haskell / whatever works better if they were so obvious or at least now when problems are very clear.
I love being able to use multiple return values, and I truly do not understand why your argument against them is that it is possible to fat-finger an error-check conditional
One recurring typo in your article. You keep using *Quiet* when I'm sure you mean *Quite*
Because in most cases, you don't want to provide the caller with a value _AND_ an error, but a value _OR_ an error. In those cases the current approach enables programming errors which are completely unnecessary.
I actually agree with Go devs that generics aren't *essential* if interfaces are implemented correctly (though I'd still *like* generics).. but the problem is, interfaces in Go are woefully incomplete. Built-in types cannot be interfaced; there is no interface for `string` and `type Foo string`, even though as data these two are identical and should be valid arguments to functions handling built-in `string`s. Why is that? If there were a way to interface default/builtin types it would seriously ease the demand for Generics while also resolving the absence of type aliases. It wouldn't resolve the lack of useful union types, but it would at least enrich the options available to work around this absence. Unions might be doable with a compiler-checked switch as in Rust, making them a compile-time convenience only: everything would be compiled to static dispatch under the hood at compile time.
Multiple return values are only sometimes for error handling. Would you suggest adding error handling as some new design instead?
Yeah, Bitcoin here we go!
I don't really see why you'd complain about that 'superfluous syntax'. map[string]interface{} is a lot more verbose IMO than "Map String Any". The first is clearly describing one thing, the second is ambiguous -- the perl background in me thinks Map might be a keyword running 'Any' against 'String'(or the other way around). Or maybe you're defining multiple variables. Either way, spaces in the middle of a type definition just seems like unneeded ambiguity.
The problem is that the Go syntax is a specific, builtin construct, while expressing a map type should not require that! In the Haskell example Map is just a regular type parametrized over two other types. There is no need for special syntax. Similarly a tree could be expressed as "Tree String Int" or "Tree Int Int" etc. In Go that is not possible, you have special syntax for slices and maps and that's all.
1. It was in Unix. Just like JS, Objective-C, etc., C took the easy road to success by riding in on a new platform. Don't get me wrong, I like a lot about C. But it didn't win a fair fight on pure language merit. Like most languages, political and social factors had a much larger impact.
&gt; To say it another way, what aspects of C made it the most widely used language in the world? Certainly language simplicity has to be near top of the list? LOL WUT?
My dodgy non-native english skills show :).
Glad it didn't just annoy me.
What would your better example have been?
&gt; Ctr+f Haskell &gt; n results found Somehow I am not amazed. I have no idea what pulls these people to Go.
&gt; What if your women didn't cook and didn't suck your dick? Sure she may have other redeeming qualities but god damnit suzy you'd be so much better if you played with my golangs every now and then So, you seemed to be making a good point until this. Was this necessary?
That wasn't meant as a criticism of Python or Go. Just noting why this example was motivating to me.
I guess people are just discovering alternative languages like ones in the ML family, where there are a lot of good ideas are floating around. Haskell happens to be the most popular one.
&gt; What if your women didn't cook and didn't suck your dick? Sure she may have other redeeming qualities but god damnit suzy you'd be so much better if you played with my golangs every now and then Uh... what?
Not complaining! Just thought OP would want to know.
Indeed. i don't mean that error handling is recommended to be done in other ways, I mean that error handling is just one use case. You can also return x,y,z from a coordinates function, you can return arrayA,arrayB from a classification function, etc. This system is a lot better than systems with a single return value, where the error value differs by function. For example, PHP brought us tidbits like this: &gt; Warning This function may return Boolean FALSE, but may also return a non-Boolean value which evaluates to FALSE. Please read the section on Booleans for more information. Use the === operator for testing the return value of this function. Alternatively, you could do it the Java/C++ way where everything is an exception and you place nested try/catch/throw blocks around every third line.
I think that comparisons to Rust and Haskell only serve to reinforce the notion in the Go programmer's mind that the tradeoff in features was worth it. Haskell comes across as a really complex experience not in small part due to the many GHC extensions to the type system. Likewise, Rust's lifetimes feature is likely to be explained in a ton of "yet-another" style of tutorials. The comparisons to these languages only convince a Go programmer that with more abstraction capabilities come great hurdles in comprehension and complexity, and that the Go team chose the tradeoff they did with good reason. Meanwhile, Apple's Swift quietly landed with generics, closures, collections, pattern matching and a decent standard library, and has been adopted widely by the Average Programmer. They didn't need to make an argument that these features required a tradeoff in comprehensibility or compiler performance. Which is why, I think Go's design choices must be examined in the light of what Swift has done, and the tradeoffs involved. 
It isn't a functional vs imperative debate. It is a complexity vs. simplicity debate. You've structured your argument as: 1. Generics and lots of type inference is useful. 2. Go doesn't have them. 3. Therefore, Go should add them. [Go takes a different route](https://golang.org/doc/faq#Why_doesnt_Go_have_feature_X). Adding more to a language makes it easier to do some things, but it also makes the language more complicated. There is a tragedy of the commons problem that shows up at the end of that road, where you have every language feature that anyone can stuff in. The devs have drawn a line, an opinionated, arbitrary line, and said they don't want to add every feature, and they have decided on a case by case basis. I have to respect them for it, and I suspect that over time more people will appreciate it. Saying that they have a duty to programmers everywhere to add generics is narcissism masquerading as altruism. They don't have to do things your way. I use go because I am *completely fed up* with languages with feature-itis. I *don't want* generics, and macros, and annotations, and derived types, and tons of stuff going on behind the scenes that I don't entirely know about. I want to know exactly what's going to happen when I program. I don't want magic, I want logic. Also, rsc has a short article about the issues with generics [here](http://research.swtch.com/generic). I don't see anything that you wrote that addresses it.
Yes and this is exactly why we have multiple languages.
&gt; What if your women didn't cook and didn't suck your dick? Sure she may have other redeeming qualities but god damnit suzy you'd be so much better if you played with my golangs every now and then You are the reason women seem to be mysteriously missing from our field. Congratulations.
Honest question: The reason I really like using Go is that it works really well for making web backends without the bloat of something like Rails (yeah, I came from Ruby). I've been looking at Rust and have been really interested, and I definitely see the issues with not having generics, but my problem is I don't see anything even comparable to Go in the realm of making web backends. Is there a language/technology I'm missing that is compiled and type safe and implements all the cool things this article wants from Go?
My apologies; the way I've described it does indeed assume that you already understand why adminsock would be helpful. Say you've written a piece of server software which allows people to store and retrieve information about their yo-yo collections. Yo-yo data insertion and fetching is its *public* interface, exposed to the internet. As the administrator of yoyod, you may wish to instrument it for monitoring, you may wish for a way to alter its configuration on the fly, or other similar things. You *could* add these capabilities to the public interface, either hoping that other people don't stumble upon them, or fencing them off with an authentication scheme of some sort. But you could also add a second interface, which is only exposed to the machine the server is running on (typically via [Unix domain sockets](http://en.wikipedia.org/wiki/Unix_domain_socket)), and is expressly for administrative purposes. This way the public interface has no access to administrative functions, the administrative interface has no access to public functions, and the internet has no access to the administrative interface. Adminsock makes it easy to provide an administrative interface. It's tested and developed on Linux and Mac OS, and I would expect it to work on any of the BSDs as well.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Unix domain socket**](https://en.wikipedia.org/wiki/Unix%20domain%20socket): [](#sfw) --- &gt;A __Unix domain socket__ or __IPC socket__ ([inter-process communication](https://en.wikipedia.org/wiki/Inter-process_communication) socket) is a data communications endpoint for exchanging data between processes executing within the same host operating system. While similar in functionality to [named pipes](https://en.wikipedia.org/wiki/Named_pipe), Unix domain sockets may be created as connection‑mode (SOCK_STREAM or SOCK_SEQPACKET) or as connectionless (SOCK_DGRAM), while pipes are streams only. Processes using Unix domain sockets do not need to share a common ancestry. The [API](https://en.wikipedia.org/wiki/API) for Unix domain sockets is similar to that of an [Internet socket](https://en.wikipedia.org/wiki/Internet_socket), but it does not use an underlying network protocol for communication. The Unix domain socket facility is a standard component of [POSIX](https://en.wikipedia.org/wiki/POSIX) [operating systems](https://en.wikipedia.org/wiki/Operating_system). &gt; --- ^Interesting: [^I3 ^\(window ^manager)](https://en.wikipedia.org/wiki/I3_\(window_manager\)) ^| [^Z ^shell](https://en.wikipedia.org/wiki/Z_shell) ^| [^File ^descriptor](https://en.wikipedia.org/wiki/File_descriptor) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cn9hgwd) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cn9hgwd)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Repos moving and disappearing is a real problem, but I tend to agree with /u/mostlywaiting that using GitHub is not a solution. It's just something we're going to have to deal with, as a community, until an analogue to the CPAN or PyPI arises. For now, I've added a TODO for myself to add [canonical import paths](https://golang.org/doc/go1.4#canonicalimports) to my projects and custom import path support on the server-side. Forgive me, but I don't feel that a conversation about my reasons for self-hosting projects will be a productive one. That said, your concern about navigation difficulties is a valid one. If you feel like explaining further, I'd be happy to see what I could do to make improvements in that direction. Thanks!
Those features you mentioned are also coming, or are available Java, C#, and C++. I don't think the average programmer is going to have to much trouble understanding them.
Rust has the features but is not production ready, you can check [here](http://arewewebyet.com/) for any easy way to see if its ready. Scala has a lot of complexity but has these features. F# and C# also have lightweight frameworks like go and are compiled and type safe. Haskell obviously does as well but Haskell is a very complex beast. Honestly just about every language these days has a "sinatra inspired web framework" that are about as easy to write an http server as go. Though its not compiled or type safe you may want to consider erlang/elixir there is a static analysis tool called the dialyzer which with some extra type annotations will make your code at least as safe as go. Erlang/elixir are also blazingly fast and offer a very similar concurrency model to go.
&gt; what concerns me is not the cost of compiler time Not to disparage your good points, but it is really helpful to remember that compiler time is one of the prime concerns for go. I work on a large project with a fairly respectable compile time. In the past, I've worked on larger projects with absurd compile times and relink times long enough for coffee and a donut. I am quite willing to jettison generics and other higher language concepts for build times measured in seconds, rather than hours.
Well-typed containers aren't a functional idiom. C++ has them, lisps don't. That said, parametric types are the only sane way to type functions, containers, or anything else generic, and it boggles the mind that Go's designers are putting lipstick and making excuses for C's type system.
&gt; Hey, author here. I am not interested in wether an idiom is functional, imperative or anything else. If all you think of have to do with list manipulation, folding, filtering, summing, accumulating, ..., then you are drowning yourself in the world of list-based functional programming languages. There is a reason why such list-based functional programming languages have not been able to make it big. Think of about it. And don't disillusion yourself thinking that Go is big because it has Google behind it. Go is not perfect. But it was designed by those who know what they are doing. It was designed to solve real problems effectively. The reality is if it takes an average programmer to read the nth iteration of "What is a monad?" and still can't wrap his head around it, then what you have is simply a toy language. 
&gt; Built-in types cannot be interfaced; there is no interface for string and &gt; type Foo string, even though as data these two are identical and should &gt; be valid arguments to functions handling built-in strings Overally I agree but your argument is ham-fisted. If you design API that requires indirection over builtin types and you can't get away with fmt.Stringer then you have more serious problems than lack of generic.
Sweet I needed this. I'm going to try this out tomorrow. Thanks.
It uses it's own stacktraces syntax for panics (no plugin support for e.g. vim), it gives away static type due to Check(interface{}) functions (refactoring hussles), it does not support parallel tests, it requires developers to learn its own command line flags (and basically typing them altogether with testing ones). This is what I can list right off top of my head, possibly there's more... I can't imagine using this for serious projects for which you'd like to have contributors.
My golang app is in GAE so building is yes.
I take offense at the assertion that Go is hindered by developers coming from weakly typed languages. Before Go, I spent most of my time in C++ and Java. I tried learning Haskell, but never found any projects that were purely functional. Real work tends to need a fair amount of statefulness and handling state in Haskell isn't exactly early on the learning curve. Disclaimer: I've been stuck at the airport for several hours and have been drinking a fair amount.
I actually think that was one of the better parts of the article. Lots of people demand generics without making a solid (or really, articulated at all) case for why they might belong in Go. So you did a great job showing what we're missing. If you're in the mood to update or follow-up, it might be good to look into 'go generate'-based approaches to generics, since that's the direction the language is moving. There's still not too many competing tools yet, but there probably never will be - source-level monomorphism isn't rocket science, and there's only so many ways to do it.
Some kind of generic container type. A linked list would have been bite-sized enough for a short blog post. I can understand why you might want to print your types the way python does it. It really is easier than the Go way. But writing hundreds of lines of support code and introducing an external dependency to avoid writing a 3 line `for` loop still seems a bit crazy to me. EDIT: s/byte/bite/
I can't understand why OP's post has been upvoted.
The start of the article holds up GCCGO as the bastion of correctness, so why not just use that? golang.org even advertises it as an alternative 
The compiler forces you to use the values, though. Plus I like that you prevent additional nesting depth this way.
Which is ... bullshit.
D has Generics and (last time I checked) faster compiles than Go.
&gt; perfect type systems Tell me more.
Guy can't even get a joke about ALL CAPS in the assembler guide. Seems like a fun guy.
Oh, trying to move the goalposts? Let me try too: Now compare all the complexity which gets multiplied and pushed from the language/libraries into application code because Go can't handle it properly.
Interfacing built-in types will require either boxing/unboxing values, which is expensive, or beefing up compiler to smartly insert extra code where built-in type is involved in interface checking. It seems like there is an obsession to avoid any (extra) table lookups in the compiler at all costs. Hence no overloading, generics, etc. Compiler is very fast indeed but one has to consider that "perfect is the enemy of good." Eventually features and compiler speed will balance up.
You can't filter Go slices the way you can filter lists in Haskell because Haskell lists are linked lists while Go slices are just nifty arrays. I'd remove that comparison....
I think you need to recalibrate your sarcasm detector.
I thought the hyperbole would make it obvious that I was being sarcastic. Apparently not...
Sorry, I don't actually know anything about Haskell.
Oh okay, I just assumed you didn't get me either since no one else seems to. Sorry!
&gt; A linked list would have been bite-sized enough for a short blog post. I think that'd be a lot more code. Append, Remove, InsertBefore, the linked list struct declaration. The only thing simpler I could think of is Stringer which the Go team [already wrote](https://github.com/golang/tools/blob/master/cmd/stringer/stringer.go) (in 600+ lines) &gt; introducing an external dependency to avoid writing a 3 line for loop still seems a bit crazy to me For join() you could be right, but the repetition adds up over the lifetime of a codebase. This sums it up pretty well: http://c2.com/cgi/wiki?OnceAndOnlyOnce
I'm not sure I agree about usability, I find the features make it easier to write safe code. And the terseness afforded by them often makes code easier to read (up to a point). But that's subjective. I agree those languages are much more heavy weight than go but those languages are usually hard to learn because they have so many features often doing the same or similar things. Judicially adding features that help the programmer, particularly ones that are becoming standard idioms in the programming world (option types, ADTs) are worth the costs and decrease code complexity in many cases. The article gives several examples of where you have to fight to subvert the type system in very non-intuitive ways to perform some relatively basic tasks. Frankly, the meme of "x feature is cool, but the languages that have it are complex therefore go shouldn't have it" is a tired canard.
I think author doesn't understand the concept of interfaces and how to use them. 
I had just been wondering to myself why there wasn't a Go version of the Rails Rumble... Awesome to see this happening! 
@maruwan: There is a possibility of me writing a separate package for i18n, as I'm going to need that fairly soon anyway. What data is included though, and what the source of that data is, is another question. It would be useful if you have any suggestions for good sources.
Thanks for the link. From what I can tell, there is some overlap, but it seems to be quite different. Looks interesting though.
Looks good! A few suggestions: 1. Instead of fmt.Print[fln] for debug messages, use log.Print[fln]. At the very least this will print to STDERR. 2. Although [named result parameters](http://golang.org/doc/effective_go.html#named-results) can make code more readable, I feel the way you're using it isn't helping code readability. The best examples of where it doesn't really buy you any readability is in methods like `Type`, `receive`, `Dele`, etc. Small function bodies where you assign to `err` and then return it. 3. You can move your regexps to the top of the file and switch to a [`regexp.MustCompile`](http://golang.org/pkg/regexp/#MustCompile) -- this saves you having to check `err` (which you aren't doing anyways) and moves a few lines out of your function bodies. 4. Your `switch` statements don't need a `default` if you aren't using it. 5. Wrap all your `if ftp.debug {}` in a method call or something. 6. You explicitly call `Close()` but if your code returns early, `Close()` is never called. You want to `defer pconn.Close()` right after you assign `pconn`.
Have you **used** Haskell? That's what I thought. I learned Haskell after I learned Go. In some respects Haskell is my new standard. It certainly has warts and oddities but some of the things in Haskell that the post mentions just turn out to be ingenious features that I miss every day while I'm in Java (at work). It's perfectly fair to compare Go to any other reasonably well known programming language. If you try Haskell you'll find their features that you just can't believe other languages haven't picked up.
What does functional programming have to do with being able to return a value in being able to type check that a call either succeeded or returned an error? Where did the article advocate getting rid of for loops? What do lists have to do with any of this? Nothing. Your argument is a red herring. You don't seem to be debating the point of the article, only deciding because the examples were given it a specific language they must be irrelevant.
So any comparison to any feature in a functional language is automatically an argument for functional programming over imperative, de facto? Haskell considers whitespace to be significant. Has anyone told the Python people that they are apparently using a purely functional language?
That kind of work is a perfectly common task. Even if it has to be implemented by making a new array and returning that instead of operating on one in place it still seems like a useful thing to have in the standard library.
Agreed. It's nice to see someone talking about generics and go without assuming that everyone knows exactly what you're talking about in exactly the kinds of problems that the lack causes. So many discussion seem to just say "generics are missing" and leave it at that. It was great to see examples of exactly how that causes go programmers to go out of their way or have extra problems.
Right. The fact that Swift was given such a warm welcome is a testament to the fact that the average programmer now wants these capabilities. My additional point is that Swift doesn't seem to have gained that much in complexity or compilation speeds, so that's a good case to compare Go to. Java, C#, C++ and Scala have such large-scale complications in their implementation that relatively few people have the comfortable sense of what's going on underneath.
Interesting, I'll give it a look, thanks
I'm not sure why you think that ADT's perform poorly in a concurrent environment. Rust proves that it is certainly possible to have an efficient implementation. The fact that rust isn't battle tested doesn't really matter in this case because they have tagged unions now that are efficient. They also don't have any particular reliance on other rust structures so using the same or similar techniques you can do this in go as well. Haskell and others have proven that the ergonomics are sufficiently worthwhile to adopt in Rust, C++, Java, .Net family languages and others. Vetters and linters are good solution unfortunately they are incomplete. You cannot be guaranteed that the library you just pulled in used the linters. If it is possible to implement it in the compiler without adding a ton of complexity that should be the preferred solution because it guarantees a minimum standard for the code you use. I don't pretend that every feature that people ask for is worthwhile or even that Haskell should be the sole influence of language features (why not just write in Haskell then?). I also don't think that features should be added hastily. But go is a five year old language. Its not being used in the use cases the designers envisioned it being used. And its fairly clear that there are some pretty downright ugly parts of the language. The number of "generics" codegen tools proves that user want some more complexity and their are good use cases for these things. But to be dogmatically conservative about language features is a mistake. C# is starting to eat Java's lunch for this very reason.
You are thinking in binary terms: success or error. The world is more complex than that. There are multitude of possible errors and you will need to know which one it is and what additional info can be obtained. One magic return value is not enough to properly handle errors. The solution is multiple return values, output/reference parameters, or exceptions. And with multiple return values you can get both error and partial data, which is impossible with a single return value.
&gt; Meanwhile, Apple's Swift quietly landed with generics, closures, collections, pattern matching and a decent standard library, and has been adopted widely by the Average Programmer. They didn't need to make an argument that these features required a tradeoff in comprehensibility or compiler performance. I might be the Average Programmer, but I really saw it as more of the same - the same features that are in the newest-ish languages, only with a slightly different syntax and library. At one point I was knee deep in dependent type inference hell in Scala, and I decided I didn't want the compiler to do so much work, and started learning Go. Put the unofficial Go motto here, I guess.
It is funny how people comming from script languages like Python suddenly start complicating things because they don't want to do things the slow way. The case against reflection in this case should not be that it is slow, as I can see how this would be performance sensitive code, and likely it will run faster than any similar python or ruby code anyway. I think if you use Go more like a script language, then a lot of this cravings for Generics will Go away. I'd say the problem here isn't trying to use Go like Python. The problem is trying to use Go like C++. Btw not to sound too negative. I did enjoy the article and I am happy the author made the code available as I am sure there are usefull things for this kind of approach.
I just registered, Florida
That's probably the point: ObjC isn't going anywhere.
Because for now, you need extra measure and precautions to play around with multiword values at the hardware level. That's a cost that is not worth it especially wrt error handling that has to be done pretty much everywhere. And honestly when you have interfaces which can be parented to tagged unions and when you add to that struct embedding, you don't particularly need ADTs. (ask the Java folks who are actually wishing for something similar) About importing external libraries, you have the interoperability problem in Haskell too. And it's even more striking to me that it is due to the fact that you have too many different ways to handle errors. That shows that we can compare languages all day, but in the end, it is really about tradeoffs. I think we "need" a language that is conservative in terms of features. Otherwise, people are free to look elsewhere if they need a feature rich language. They even have the choice of which one to use. :) (conservatism because it is the right thing to do, not as a dogma)
Haskell uses the keyword 'let'. I refuse to negotiate with terrorists. 
There are many non-idiomatic things in this package. Looking at http://godoc.org/github.com/SpiritOfStallman/herots, * drop the string from your consts. they're implicit. * HerotsSrv should be renamed Server, per https://golang.org/doc/effective_go.html#names * HerotsSrvOptions should be named Options * SetMessagesDst(src io.Writer) -- it's called Dst but takes a parameter named src? * Options.MessageLvl should be named MessageLevel, and the zero value should be the default, not 2. understand and embrace the zero value. * TlsAuthType should be spelled TLSAuthType per https://github.com/golang/go/wiki/CodeReviewComments#initialisms etc. There are more, but I stopped there. This may be a good package, but it doesn't feel right yet, so I would be uncomfortable using it. 
&gt; To be fair, most of Swift's acceptance is because it is essentially being forced on Apple platform developers. Did I misinterpret this then...? To me, what /u/brokedown says makes it sound like Apple is forcing devs to start using Swift which isn't true.
Ah, I did not want to explain that little pun, but OK ;-). ObjC is a 80's lang with little work done to it afterwards. With Apple going Swift, they're probably cease further development of ObjC like they're usually doing with "obsolete" software. So it "isn't going anywhere" as in "not improving". And that would at some point - indirectly - force people to move.
Spot on. I am in the middle of building a fairly huge app in Go, and I have to say that I really don't think that Generics would speed development all that much. I would never trade the type-assuredness of the code I am writing now with the swiss army knife convenience of Generic containers. There is a verbosity issue, if you equate verbosity with the number of keystrokes you have to put out to declare or create variables and such, but thankfully ObjC has prepared me for such issues. Besides, you can make macros in your IDE of choice (IntelliJ with GoLang plugin here) that will spit out the verbose incantations of `map[string]interface{}`. 
Atom is not quite as mature as sublime but has huge potential. I use it for day to day coding in golang, but recently started using https://github.com/visualfc/liteide when debugging.
I'm in Seattle and just signed up for the Gala. (Incidentally, after years of reading reddit I made a profile, just to comment on this. haha)
What was your rationale for posting this article in r/golang?
In your article you are clearly trying to rationalize your interest in functional languages. 
I reckon the number of programmers that can read through and make sense of the c++ stl library is about .01% of the programmers that can read through the go std library and understand it. This blew my mind when I got started writing Go. The std is so approachable. It's because of how simple the spec is.
On a first look, I can see some simple preferential things which will help others read and understand your code better. * Files should be named in small letters with underscores * Package doc should start with the package name &gt; the doc for package yelp should start with "Package yelp ..." and not the project name(in this case "go-yelp provides ...") * Constants need not be in all caps as in C. Name them as regular variables. &gt; SEARCH_AREA can be named as SearchArea * Errors can be defined as variables of error types &gt; const ERROR_UNSPECIFIED_LOCATION can be &gt; var ErrUnspecifiedLocation = errors.New("location must be specified") I would advise you to run `golint ./...` in your project folder to find out more such conventions. You can install it by `go get github.com/golang/lint/golint`
Wrong Name (**firebase**) ... one might confuse it as a library for [Firebase](https://www.firebase.com/) which is also a database ... 
And D also has a compiler that breaks with every release. Could some of that be due to the complexity of the D language, an issue that the designers of Go are making sure they don't have?
Thanks for writing this up - I really appreciate the feedback!
&gt; There are also some sliglty more featureful options, such as the Zeus IDE but it is Windows only. FWIW while Zeus is Windows based, it can be run on Linux using Wine. *Jussi Jumppanen* *Author: Zeus IDE* 
I understand what do you mean. Many thanks for your opinion. Add this to my "experience box". PS: things from list was fixed
Has swift been widely adopted? Did they fix the performance issues? Can I run it on a server?
Apparently. Swift is surprisingly high on the TIOBE rankings of programming language adoption. http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html I don't have experience with it on a large project, and performance wasn't an issue. One could probably run it on a server if you are willing to run cocoa code (e.g. [CocoaHTTPServer](https://github.com/robbiehanson/CocoaHTTPServer/tree/master/Samples/iPhoneHTTPServer)), but it isn't really a server-side language or much of a concurrent one. 
I think OS X servers are pretty rare in the wild. I take it there is no option to cross compile? You'd think it'd be easy with LLVM in play. What about this stuff? http://stackoverflow.com/questions/24101718/swift-performance-sorting-arrays http://blog.sudeium.com/2014/12/10/swift-performance-too-slow-for-production/ 
7 . Don't hard-code port number
According to the downvotes you cumulated, it looks like sense of humour and sacarsm are like generics and exceptions : not a feature of Go.
I don't know how others feel about this, but I would prefer that the library didn't look for a JSON file. Rather, I will store the data however I see fit (as an environment variable, a JSON file, or hardcoded) and I will then pass that data to the library.
Try [Nim](http://nim-lang.org/) - there are no such holes in design and performance is even better. ;)
I noticed that some comments don't start with the struct or function name. This looks like a solid first golang project. Welcome to the communty. 
Like others, this is more a matter of style, but I am not crazy about the Foo/FooOptions pattern for client libraries. I prefer the approach taken in the standard library with `net/http` and creating request and response types, and setting options fields on the request type, often via helper functions. Ie, instead of: c := yelp.New(yelp.AuthOptions{ConsumerKey: "abc123"}) c.DoSearch(yelp.SearchOptions{ GeneralOptions: &amp;yelp.GeneralOptions{ Term: "burritos", }, }) something like: c := yelp.New() c.ConsumerKey = "abc123" // This could be either a NewSearchRequest() function or a // struct literal. req := yelp.NewSearchRequest() req.Term("burritos") // res is a yelp.SearchResult res, err := c.Do(req) and in the library: // If these options make sense in other structs, make them private and // embed them. Otherwise, just put them directly into SearchRequest, which // makes them easier to set directly than via methods. type SearchRequest struct { generalOptions localeOptions locationOptions coordinateOptions boundOptions } func (o *generalOptions) Term(term string) { o.Term = term } It ends up being a little more code, but IMO the API is nicer to deal with. Like `net/http`, the API is simpler for beginners but has the flexibility to become much more customizable. (I keep meaning to write up a blog post about this...)
Does it? Are there any reasonably sized programs in the two languages to compare? The only numbers I've seen are that D's standard library compiles faster than Go's, and I have no idea how apples-to-apples that is.
You can apply that argument to ignore feedback from anyone proficient in another language. I see a strongly isolationist attitude in the Golang community that arguments like this support: "Go is different, so issue X is moot", or "If you want Y, go use another language", or "You only think Go's not perfect because you aren't thinking the Go way". Sure. Brainfuck is an awesome language, it's turing complete, so any feature requests to make programming in brainfuck easier or more productive are just failures on the part of the asker to "Think in brainfuck". Go ain't perfect. And one of its very sore points is the rough surface where they have *incompletely* replaced generics with interfaces. It should be obvious that using `interface{}` in cases where invalid input is possible, and having no recourse besides trial-and-error typecasting and error catching, is a sign of bad design. But this is how JSON encoding/decoding works in Go, for example. The libs are littered with empty interfaces in cases where you could accurately describe what you expect if the interface system weren't so incomplete. Such as "I expect a datatype consisting of sequential runes", which would accept strings, or []rune, or `type foo string`. The answers I keep getting to this are lame patches like "just always cast to string when passing", which naively ignores memory wastage and failure to catch coding errors at compile time. Lame patches or verbose code duplication are symptoms of a bad design. Go can do better, with advice from other languages.
&gt; It is funny how people comming from script languages like Python suddenly start complicating things because they don't want to do things the slow way. That's totally true and I'm guilty of that. For me I hope that Go replaces C++ and Java in my toolbox (but I still use Python a lot). I'd like the convenience of Python with the speed of C++. Writing Go is easy enough that I expect more from it. So this situation is like the [uncanny valley](http://en.wikipedia.org/wiki/Uncanny_valley) of programming languages.
Why not? It's topical, about Go, and resonates with many users of the language. Really: why not? Is Go so perfect that it's above constructive criticism?
It's clear that he's rationalising his preference for functional languages. He's neg'ing Go. &gt; The support and hype it receives might be better spent on more novel languages with bigger potential to better our industry. Articles that have such bias do not belong in this sub.
I just registered as well. I'm in South Florida, if you are close maybe we could collaborate drinknderive.
Disagree: not separating errors and values is a big wart when done in other languages. I'm glad Go allows multiple returns. I do wish it offered more conveniences to standardise error handling considering the huge bulk of error handling code in most Go code. A lot of codebases will include functions for quitting on fatal errors, or panicking on errors. These are so commonplace they should be builtins. But even then there's a common case that can't be functionalised: conditional early return. For example, sometimes I want to return an upstream error if I get one from a call, but I can't functionalise that: I have to do: foo, err = bar.New() if err != nil { return err } ..but if Go had macros, I could fix this.. or if it had some other way to short circuit this case, considering its frequency, I could avoid disruptive boilerplate. This s what the author meant by 'flow disruption': code that is brainless yet requires thought and lines of handling logic, interfering with the flow of thought and productive coding.
Re-read his conclusion. His motives and reasoning are clear: &gt; The support and hype it receives might be better spent on more novel languages with bigger potential to better our industry. * That is not constructive. Try and guess why, as young as the language is, that it's already in use in many high-end production systems.
You're taking it the wrong way. Go is *far* from perfect, as any language, and I pretty much dislike core team's arrogance regarding generics (not that I can't live without them but, come on Rob Pike et al, get down to earth). Any feature from any programming language has advantages and drawbacks. So, when conceiving a programming language, you have to pick some advantages *and* some drawbacks. You generally do so by targeting some programming niche (that is Go's choice, but it also applies to Erlang, C, Prolog, COBOL, etc.) or by having a generalist and/or powerful language targeting clever programmers (that is C++, Lisp, Haskell and Rust's choice, among others). This is not a strict dichotomy, of course, but you get the idea. Implementing powerful Haskell features has impacts on the language, both positive and negative. The thing is, the more you make a language look like Haskell (or anything else), the less you need another language (because, well, why not use Haskell then). I believe in survival of the fittest : rather than similar languages that share more or less the same features (remember that recent period when each and every language *had* to implement OO principles because, well, OO is the solution to every problem, so every language, from COBOL to scripting languages, had to implement the canonical OO model) I prefer having many languages that share very different views of the world and make radical choices (as Haskell did in its own way ; for example, it pretty much ignored the OO dogma). Survival of the fittest. Go is the platypus of programming languages : it sucks, is ugly, many people think it should not even exist, but it fits very well to its niche. Yeah, that's it : go does not use duck typing, it uses platypus typing ;)
Could you explain the need for all the "getParameters() (params map[string]string, err error) {" ? I'm not sure what's going on here but tbh it smells like you're being "clever".
As some I'm in central Fl I don't mind collab remotely
Cool, not sure how the team thing is going to work, but I guess I will pm you when they update the site with more info. I am hoping a local company will host a get together, but I am totally game for meeting up at a coffee shop, or maybe the [hackerspace](http://www.metrixcreatespace.com/#makesomethingawesome).
Anyone aus?
&gt; Disagree: not separating errors and values is a big wart when done in other languages. How do you get the idea that I had something like this in mind? Yes, there are a few ways to have even worse error handling than Go. That doesn't make Go's error handling good.
Can you explain the reasoning behind: b[0] = 'A' return 1, nil I'm don't totally understand that part.
&gt; I would never trade the type-assuredness of the code I am writing now with the swiss army knife convenience of Generic containers. I'm not sure if this makes sense at all. Types will be more precise and helpful with Generics, not the other way around. &gt; Besides, you can make macros in your IDE of choice (IntelliJ with GoLang plugin here) that will spit out the verbose incantations of map[string]interface{} Code is written once, but usually read many times by many different developers. Pray that those other developers 2 years down the road can tell which types you were thinking of when you wrote down `map[string]interface{}`.
&gt; "Go can't handle it properly" --&gt; Says you. Really? REALLY? You are trying to argue against established technical facts? What's next? Vaccines are full of "toxic chemicals" and cause autism?
&gt;I think that's survivor bias. Most people just leave after a while when they see that they can't use the language in the way that is appropriate for their use-case. I seriously doubt it given the increasing adoption of Go. Who would honestly judge the suitability of a language on the presence/absence of a single feature ? That does not make sense. Not saying that there aren't any use cases where you might want to use something different. But that's why we have many languages.
&gt; Mechanically checking errors is inherently unsafe. What if you miss a case? What if you ignored the error while developing and forgot to put the check back in? go vet What, if you check all the errors, but do the wrong thing when handling the error?
It's not a single feature. It's mostly the arrogant behavior of Go creators and the dismissive community around it.
Thanks for sending. It looks like Brad Fitzpatrick created winstrap/winstrap.go to automatically install TDM-GCC, WiX Toolset, and Git. It then clones the Go git repository and compiles both the 386 and amd64 versions of Go for Windows. My tools are not for building the Go language itself, but are for compiling, testing, and formatting .go files using the batch scripts. The release contains the go1.4 binaries already. I also include a portable version of Git so 'go get' can be used without any setup.
I pointed out the problems with go vet below. Due to the halting problem we can never know if your algorithm is correct. But having the compiler guarantee my program can't crash unless I explicitly make it do so is a huge win regardless.
fixed
thanks for your suggestions. I've updated all except for 6, this connection needs to be closed before it can expect data on the control connection. Alternative will be placing the Close also in the return on error.
I'm still trying to figure out what a interface is, so +1 on your question. 
Interfaces are not here to simulate inheritance, which it seems you're trying to think of. Interfaces are that how they named — interface. Consider this stupid and useless interface which however will be good illustration: type filesystem interface { List(dir string) []files Reader(file string) io.Reader Writer(file string) io.Writer } and its implementations: type localfs struct {} func (l *localfs) List(dir string) []files {} func (l *localfs) Reader(file string) io.Reader {} func (l *localfs) Writer(file string) io.Writer {} type ram struct {} func (l *ram) List(dir string) []files {} func (l *ram) Reader(file string) io.Reader {} func (l *ram) Writer(file string) io.Writer {} And so on. So interfaces is a way to define an abstraction on behaviour plus way to formalize/enforce it on compile time.
I understand that for a struct to implement the Animal interface, it must be associated, at a minimum, with the same method set as the interface. I know there is not inheritance in Go, but what I don't understand is the benefit to: type LandAnimal Animal What can I do now with LandAnimal that I can't do with Animal?
It's how the language is specified. When you write `type X Y` where X is a name you give it and Y is the description of the type, you're defining a type X which is shorthand for Y. There is no difference between: type Animal interface { Speak() string } and type LandAnimal Animal except the name. It's the same thing as writing: type LandAnimal interface { Speak() string } And in the case of interfaces, I don't know what this gains you except the ability to rename an interface from another package so that it makes more semantic sense in yours (but that is not always a good idea).
One way this could be useful is to increase api compatibility. Say you make a package that uses an interface from a different package as part of it's public API. Say func SpeakAll(animals []thirdparty.Animal) { ... } If the `thirdparty` package changes the interface for Animal to be something less useful for your api, then you will want to change the interface into your own interface (`MyAnimal`). However, `[]thirdparty.Animal` and `[]MyAnimal` are not api compatible, so all users of your package will have to update their code to use new types. If instead you just used `type MyAnimal thirdparty.Animal` initially, you could borrow the thirdparty interface at first and change it later without breaking your own api.
Cool, thanks!
Ah, that makes sense! This would be similar to aliasing imports. Thanks for shedding light on this for me.
Hahaha, this is part of my discovery process as well.
(This is unrelated to the OP's question, so, just to help you out in understanding what an interface is) Basically, an interface lets you (and the program) know what kind of "stuff" an object can do. That's why the convention in Go is to give them names that finish with -er Like Speaker, Listener, Walker, Eater, Pooer, Sleeper, Notifier, Drawer. You get the idea! type Speaker interface { Speak() string } type Human struct { name string } // Human can speak func (h *Human) Speak() string { return "Hi, my name is " + h.name } type Duck struct{} //Duck can speak func (d *Duck) Speak() string { return "Quack" } //Any object that can Speak can be used as argument here. func makeItSpeak(speaker Speaker) { fmt.Println(speaker.Speak()) } func main() { duck := &amp;Duck{} human := &amp;Human{name: "Joe"} makeItSpeak(duck) // Prints "Hi, my name is Joe" makeItSpeak(human) // Prints "Quack" } For just one last example, the print methods in the fmt package use a Stringer interface, which defines how a certain object will be printed. To implement stringer, a type just needs to have a `String() string` method. func (h *Human) String() string { return fmt.Sprintf("This is %s.", h.name) } func main() { human := &amp;Human{name: "Joe"} fmt.Println(human) // Prints "This is Joe." If the String() method hadn't been defined, Go would just use the default format, and would've printed "&amp;{Joe}" } Hope that helped.
Nope, one GOPATH to rule them all. If you have collisions of different versions of packages using the same directory, someone is doing something wrong.
If you update a library and it breaks one of your projects, then you've made a mistake. Use a new path for the new package that isn't backwards compatible.
Thanks, I'm actually writing different variations of how to use interfaces and structs right now to help understand them, this is the latest: [https://play.golang.org/p/cddj6p-Cd8](https://play.golang.org/p/cddj6p-Cd8)
Cool! I would definitely just explicitly call `Close()` in the error blocks before then. Good work!
Oh please. I did say "you're defining a type" which means you're making a new type.
No unit tests ?
The io.Reader interface is a good example because of how ubiquitous it is. type Reader interface { Read(p []byte) (n int, err error) } This now provides a single interface for anything you might want to read from. Anything that can be read from simply provides that interface, and then anything that knows how to use a reader can use any of them interchangeably. Want to unmarshal some xml read from a file? Opening the file gets you a reader and you pass the reader to the xml package. Want to instead read from an http request? You switch the file open for the http request body and nothing else needs to change. Decide XML isn't webscale enough? You can swap the xml reader for json. It all uses the same interface so it all hooks together the same.
In the same web that you posted, Go is slightly faster than Java if it used with quad-core (x64). And more a lot efficient in the use of memory ram.
Just to attempt at being maybe clearer : my issue is that as you mention, after introducing ADTs, you realize that IO is difficult to do and that you need monads. Besides, you also realize that you need to eliminate side-effects and then you have to be strictly immutable. And so on. Next thing you know, you have Haskell. Given that Go is probably going to deal with a lot of server-side IO, with a lot of error handling, I don't think ADTs are suitable.
So god damn fast
probably not. What are you expecting to get on the golang subreddit...
some advise? 
the net/http package handles every request in a new gorouting. To utilize all core you should run runtime.GOMAXPROCS(runtime.NumCPU()) fromt the runtime package.
Driving people to search Google to find myriad articles discussing precisely that question?
I've set my GOMAXPROCS to four, the problem is that I'm am confused as to whether or not this would actually increase my servers performance because of all the context switching that may be occurring. I am also confused as to what the go scheduler is actually doing with my go routines in the back ground. Because they are relatively small routines I wonder if they are implicitly being optimized to only run on a single thread.
&gt; ... program can't crash unless I explicitly make it do so is a huge win regardless. I really doubt it's a huge win. If a program ends up in an infinite loop it's as bad as a crash for the end-user. No matter what you do, you always need to account for your program crashing or doing the wrong thing; because of some driver problem, external libraries, other programs causing the whole computer to freeze, power outage... There's no magic solution for ensuring that the program does the right thing. I really do not consider that as a huge win, because I always have to verify whether the program does the right thing in the first place. (obviously, I'm not saying that it is always the case - e.g. ensuring that browsers crash as little as possible is quite important)
&gt; Additionally my current setup involves a persistence layer which stores a database connection as a global variable. If the routines ran on different cores, wouldn't they have to block to access the database connection? If you're using an sql.DB from database/sql, that's a "handle" with its own connection pool and not a representation of a single connection. As to the rest of your question, I think it is best answered by yourself by testing your application with ab under different GOMAXPROCS settings (you can do this by setting an environment variable).
No, you *must* not.
&gt; what is Go good for? Real projects, the ones typically rewritten in Java after their Ruby/Python prototype needs a room. From pure experience unsound benefit of Go's simplicity is that big codebases tend to just grow as opposite to Java's all-the-time-refactor-mode.
/u/uriel please could we remove /u/myzt 's trolling comment.
&gt; Define the interfaces you consume, not the interfaces you expose. In other words, export types but depend on interfaces. 100% agree
I recommend reading, https://talks.golang.org/2012/splash.article, or watching, http://www.infoq.com/presentations/Go-Google, this presentation about the rational behind the design of Go. If you agree with the problem statement that Rob Pike presents, and are interested in the proposed solution, Go, then the language could be for you.
&gt; how are they unrelated ? In pretty much any sense.
If you like learning new languages, you should. If you have time and want to learn a new language, you should. If you think learning Go will make you the Kung-fu Panda of the programming world, you shouldn't. If you asked something like: &gt;'Here's my use case/problem/task... Is it worth learning Go to solve it?' you'll get more helpful answers.
Anecdotal evidence, take with a grain of salt, but it may be useful for getting a very general idea: I did some benchmarks on my own laptop a couple years back. Doing some simple integer addition in a loop resulted in Go taking about twice as long as Java and between 1 / 100 and 1 / 200 the time of Python.
a) `Maybe` is a type (constructor) which can either hold a value, `Just 42` or not hold a value, `Nothing`. Functions on Maybe let you program in a way where you don't have to worry whether the result is `Just` or `Nothing`. That's it. b) There is no way in which ADTs are related to concurrency. There just isn't any connection. c) There is no connection between `Maybe` and side-effects. Languages with unchecked side-effects as well as languages without are using constructs like `Maybe` with great success. d) There is no particular connection between `Maybe`, side-effects and Monads. Maybe is a Monad. `IO` is a different Monad. Neither of them rely on being a Monad to get their work done. For instance, both Monad and `IO` are type constructors, and probably many other random things. It doesn't matter. e) Abstractions like Monads allow you to write code which works with any Monad like Maybe/Option, Future, List, etc. instead of having to implement it for every type (constructor) manually. That's it.
Ok please tell me if you have a struct with two fields each of a machine word size. And you write to one field (for instance which is an error type) while reading the other from another thread. What happens ? What are the potential issues ? (hint: a lot of things to take into consideration) If you can't see what I am saying, I guess we are done. &gt; Which "implementation details" are you missing? We are discussing concepts. No, I asked for implementation details explicitly. You want to discuss about concepts because you want to avoid talking about their implementation maybe.
Jesus. And people wonder why everyone with the slightest clue nopes the fuck out of this community. Have a nice day, do everyone a favor and stop touching a keyboard for the rest of your life.
Reason why I ask you for explanations. Seems like you know more. &gt; do everyone a favor and stop touching a keyboard for the rest of your life Did I hit a nerve ? :)
This may be useful for background. http://dave.cheney.net/2014/06/04/what-does-go-build-build
&gt; Did I hit a nerve ? :) No, I just fear for the lives of people if you ever touch any critical piece of software.
That's gratuitous. And you still haven't explained anything and resorted to being slightly insulting. That's quite telling. On the other hand, I see someone who says that we should use tagged unions to implement Maybe monads deep into the language and I'm saying that it's not so obvious. You guys should provide more insight about the way you would like to have this happen in Go. Without changing the language excessively.
Run siege or ab against your server app, then increase the number of goroutines and GOMAXPROCS. At a certain point, a server process I wrote can no longer keep up with requests when using low goroutine counts, and it doesn't even make filesystem or database calls.
Thanks, the rule-based request/response modification and replay it's something a security tool can surely benefit from, it would be nice if you could add an issue requesting each separated feature and adding details on the approach of other tools (such as CharlesProxy) so it can be clearly understood, if it looks useful we can surely add it. The live web view it's in its infancy but offers a lot of possibilities.
Yes ! edit: (where is the question ? :o) Ok I'm just being cheeky. I would say yes, but this is probably not an absolute rule as in everything. But I like the saying.
Checkout cloud instances for Windows, either Azure/AWS/Google(?). Way easier than trying to keep it up-to-date yourself and all that. Although, might not be the test case you're looking for.
Makes me realize I make this error too. The only type "aliases" we have in the spec are byte for uint8 and rune for int32 but I keep telling people that they can create an alias and add methods to it. I guess we should be more careful. :) (even though I understand you) 
Since Read is [allowed to used the whole buffer](http://golang.org/pkg/io/#Reader), we could read into the buffer as follows to be more conventional: for i, _ := range b { b[i] = 'A' }
&gt; But there are tasks that require much more typing like generating an HTML coverage map and then displaying in your web browser. &gt; go test -coverprofile="%GOPATH%\test.tmp" -race -cover {package} go tool cover -html="%GOPATH%\test.tmp" This kind of stuff is typically solved with so-called "task runners" - works like a CI, tasks are defined in some configuration file, typically JSON ones, but for use on dev box. Unfortunately I'm not aware of any go-centric task runners (there're some, but I've never sticked to any due to reasons I don't remember). You might be interested in investigating it when you start creating different scripts per each of your projects.
The fact that **default** memory allocation may be significantly less, [actually may not be significant](http://benchmarksgame.alioth.debian.org/play.html#whymemory) -- it depends what you're doing.
What do you think that *anecdote* adds to the [specific measurements](http://www.reddit.com/r/golang/comments/2r1ybd/speed_of_go_compared_to_java_and_python/cnboxzw) that `RSoreil` already mentioned? edit: Why down-mod a simple question?
It works on Linux and OSX too, I'm using it on my laptop when I go off the grid :)
Great link, thanks!
It's only 40 GB? I kinda want to get a usb drive with Wikipedia on it now. 
Download the official and legal ISO (32 or 64bit as suits) via this URL: http://getintopc.com/softwares/operating-systems/windows-8-1-download/ edit: I know that url looks dodgy buy I could not find official linkage easily, ISOs come from MS servers so should be kosher. And use that with your VM of choice, sometimes full install can be completed before key is needed within trial period. Key can typically be bought cheap via ebay (better than online via MS, which is just too expensive)
Any chance of a way to simply use it as a proxy, rather than having to mess with IP routing?
The highlighted code seems to set options for the connection. Have a look at https://github.com/huin/goserial and the serial_windows.go file, there you can see how they are communicating via the syscall package to the Win32 API.
Agreed which is what ADTs are explicitly designed to solve. Your solution is still problematic because you can make errors by using Item without checking for errors. With those questions you pose I can give you the answers from my perspective. 1. From experience at work on our multimillion line C++ app (I have numbers handy for that, a go version of it would likely have fewer bugs). ~20% of our weekly crashes are from null pointers. Almost all of our crashes are from catchable exceptions but that number is harder to quantify. But, assuming you don't use exceptions as control flow the vast majority of crashes are likely from catchable but uncaught exceptions. Most of the time the OS doesn't do exceptional behavior. 2. Agreed that its smaller than bad program behavior. But having making sure that you don't have nulls and your errors are checked aren't zero sum with bad program behavior. Having an application crash can result in bad data or at least the loss of compute time, admin time, and developer time. It can also cause service interruptions. The cost of a little bit of complexity in the language (which the compiler can give you really good error messages about) is completely worth it. 3. Not entirely sure I don't know the internals of the go compiler well enough to give a complete analysis. As for the syntax you can make option and either ADTs special and use basically the syntax you use today for errors and nulls. Getting full ADT support would add a bit more complexity to the language. But there are enough languages adopting these features that most programmers can figure out how these features work without too much trouble. Obviously, these features shouldn't be thrown in willy-nilly. I very well might be underestimating their cost. 4. The impact is fairly large. As mentioned a 20% reduction in crashes is major. You can also special case option and either style ADTs to give programmers familiar but compiler checked patterns. You can also compose over those types much better than you can if you have nil. The easiest example of where composibility shines is when chaining a bunch of methods that can return nil. a := something() if a != nil { b := a.somethingElse() if b != nil { return c.thirdThing() } else { panic("got nil") } } else { panic("got nil") } Depending on how the syntax is supported (I'll use C#'s) you can clean it up to the following: a := something().?somethingElse().?thirdThing() Or with no special syntax support (like Rust): a := something().unwrap() b := a.somethingElse().unwrap() c := b.thirdThing().unwrap() 
Someone aiir drop a few thousand of those over North Korea.
Regarding 1. that's indeed significant. Regarding 3, I really don't mean the compiler complexity, simply whether it encourages better code or not (of course this is out of context and needs to be compared to some other possible solutions). 4. I'm usually trying to get to the downsides of larger library economy and application structure, because the benefits are usually obvious. And certainly, in your case - getting rid of those kinds of problems would be a major improvement. Regarding the example, it's not really real-world, but I can comment nevertheless, the code is lacking in proper error messages: a := something() if a == nil { return fmt.Errorf("something failed") } b := a.somethingElse() if b == nil { return fmt.Errorf("something else failed: %v", a) } c := b.thirdThing() if c == nil { return fmt.Errorf("third thing failed: %v %v", a, b) } So, the code-size pretty much stays the same for both cases; and it can be composed better. *Obviously, whether the error messages matters depends very highly on the context - which is why I was hoping for the "real-world example".* Regarding C# chaining, it's possible to implement something similar, e.g. http://play.golang.org/p/RYOT1RgMWP, (although sorry that it's not a good real-world example.) Obviously here we are signaling with nil, which means danger ahead. It's also possible to do something like http://play.golang.org/p/T5WkVIw-d1, although I doubt that it is the first idea that people would come up with; but it's still a possibility.
On 1 I don't want to give out more specific numbers but its fairly high. Due to our architecture many of our processes are batch jobs and we can detect timeouts. The number of crashes was far higher than the number of timeouts. I don't have numbers factoring in bad data which is much harder to detect. Regardless of the other bad states it doesn't really matter because solving crash bugs by using ADTs is not zero-sum with today's error handling. At worst ADTs are no better in terms of syntax and just make it a compiler error to have unchecked nils and errors. In the worst case you are doing the same amount of engineering that you should have done in the first place which means that the number of unchecked error crash bugs should be equal. 
C code isn't "script", scripts are interpreted at runtime from their plaintext source (like Lua, JS, bash, or Ruby). C is compiled to whatever platform/architecture needs to run it, then distributed in binary form (such as ELF or EXE). Also, that code you linked is C++, you can tell because it's got classes and a lot of syntax that isn't clear. Anyway, what you linked is just a helper class to set up the serial connection. What you really want is the wire protocol - which is how they communicate. The readme actually gives you the basic format of this: [ Data Format ] Start bit : 1 bit Data bit : 8 bit Parity bit: Even Stop bit : 1 bit So you're going to be sending a packet where one bit indicates a "start", there's one byte for the "data", a parity bit, then a stop bit. It looks like most of the actual packets are created from the "Unit" forms, with lines like this: rs232.TransferComm(hCom1,62) Where "rs232" is an instance of the class you linked in the original post, "hCom" is a handle to the COM port that communicates with the device, and "62" is the data they're actually sending as the "data bit" in the readme. So to get what you're really after, you need to find the calls that actually turn the machine on/off - which you ought to be able to find through the form code. It doesn't look like they actually bothered making constants for what pieces of data do what, so "62" just magically works. EDIT: I see in other posts that you've got a protocol spec PDF - you'll probably want to link that here, since it'll give explanations on what combination of data bits performs which actions. EDIT 2: I noticed you added the protocol spec to the post. It's a bit of a strange spec, but it seems as if this is the gist: Powerup---------( Power Supply On , One Times Olny )------------------------ 80h (128) - - - - - &gt; 8fh (143) - - - - - &gt; ( Handle Request ) : : ( Within 2 Second) &lt; - - - - - 02h (02) ( Handle Response ) ( Receive 02h ,Communication Sucessful) The "80h" and "8fh" are what you want to put in the "data" byte of your packet. "8F" is the value, "h" means hexadecimal. So "8F" in hex is "143", the number in parens. It appears that in order to start the machine, you send two packets - one with the "data" being a single byte, value "128". The second with the data being value "143". Within 2 seconds your device ought to send you the single number "2", as a single byte. If it doesn't, you should resend the request. Looking through the win32 code some more, I'm not seeing anywhere where they send the start/stop/parity bits down the wire - and if they did, that'd result in a 11-bit packet, which is weird. They seem to just be sending single bytes, so it's possible that win32/COM takes care of start/stop/parity. I haven't worked with win32 in a long time, so i can't say. I would suggest just sending a single byte at a time to the device, and seeing if it works. Just find a good serial library and try to send it single bytes and see if it responds and/or starts up. If it doesn't, look into adding those start/stop/parity bytes to the request.
You must have not gotten the memo: https://news.ycombinator.com/item?id=4654125
Well, it is a "file" based "database", thus "FileBase", it is not "firebase". :)
It's subjective. But [here's a little backstory for you.](https://blog.golang.org/gopher)
The people who picked it didn't think it was so ugly? edit: There's a [blog post](https://blog.golang.org/gopher) about it, fyi.
Typical programmer art. But in all seriousness I don't know. I think it looks cute.
Are there incremental updates you can set up to patch in, or would you need to redownload all 40GB to keep it in sync?
what? Gopher is adorable!
I meant on the homepage, not hosted on the domain. Relevant IMO because its odd to call something a practical logo if it isn't on the homepage. I guess it may be more accurate to say there isn't an (actively used) logo, though.
Something like https://play.golang.org/p/3IELBFXacN Here the main data type is exported CoolData. The function that classifies the data specifies an interface it wants, the data happens to meet that interface so we just cast it into it and pass it through. The function doesn't have to care about the real data, it just specifies a requirement. The data class is just holding things and exposing data through methods, so even know they could be from different packages, if you happen to be using both, you can pass one through to the other with a bit of glue. Would be nice to have compatible array types []*CoolData == []AnimialLiker .. to get rid of the glue but that's a bigger fish to fry.
I would be very surprised if it was the Golang side that was actually giving you trouble. You can test this by hosting the static files with another server (Python comes with a nice HTTP server for static files), and by using your browser developer tools to check for 404 responses and other errors. FWIW, this is the kind of thing where you really need to learn how to do your own debugging and problem solving, rather than relying on the internet to solve your specific problems for you. Which is why I'm trying to leave you a lot of room to do your own problem solving, while still pointing you in the general direction to solve your problem on your own time. The other people of the net don't want to "do your homework," and they shouldn't have to for you to succeed ;)