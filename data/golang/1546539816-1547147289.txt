Those are very good ideas thanks. Beyond Merovius' blog post, it's surprisingly difficult to find other good usages of the default router.
In the past, I would e suggested https://gopherci.io/, but it seems to be down at this time unfortunately. :(
My employer pays for my licensing. To them, it's a tiny investment that yields many many times more gains in productivity. If you're not working on commercial products, yeah, it's a bit much. I'd probably look to VSCode in that case.
I'm not a programmer. Just an admin, using Python to automate stuff. My employer won't buy an IDE for me and I have to pay to make my job easier. That is why I'm looking for applications, that can be used at home and at work for a mixed commercial and private use :(
Nice! I've done something similar so it's interesting to see varying approaches to this. Any thoughts around running the container with your user ID so any created files (maybe logs in this case) are owned by you?
I'm sorry but I find that go is the one of the least problematic platforms when it comes to running things on different platforms. And personally I would not trust a developer that prefers being lazy to being knowledgeable. I find that it's more difficult to modify things you don't really understand.
Please let me know what you think about this blog post. Really appreciate some votes, or written feedback, either here or on my blog in the comments. What topic should I zoom in on any next blog posts?
And Go has [Gorgonia]([gorgonia/gorgonia: Gorgonia is a library that helps facilitate machine learning in Go.](https://github.com/gorgonia/gorgonia)).
I'm not suggesting writing a general-purpose router. I'm suggesting that a valid approach is to use stdlib and write a router which is optimized to your specific project.
I have a very similar setup, but I use [modd](https://github.com/cortesi/modd/) where they use reflex
Just a heads up, if your services are all calling the same database and not each other, you are not building Microservices, you are building a distributed monolith and you will not realize most of the benefits of Microservice architecture. In terms of your question, you need to change your db methods to be interfaces. You can then either use a mock library like go-mock to mock the interface or implement mocks that return the db state you want for the specific test. There are pros and cons to both approaches, but mostly comes down to preference. 
Totally agreed here. I'm looking at putting together a simple webapp and this, in addition to the other comments in this thread, give me a lot more confidence about how the project should look.
if your command takes 20 secs to generate the output and a http request is in placed, what will show? I think shared state and locking is necessary. &amp;#x200B;
Make each command's output a formal HTTP entity. Update each entity's state in a goroutine of its own. Serve the entity the same as you'd serve any other.
The only time I had to deal with this was when using glide or dep for old-style dependency management with `vendor` directory (it was created by the container on startup). We didn't really come up with an elegant solution then, just run after each dependencies update something like: chmod -R o+rwX vendor It's not pretty but worked good enough. A thought on logs: you could consider just printing them on stdout instead of writing to files.
If you are not using nginx as a reverse proxy for multiple services you could simple use go's http server and spare you the effort, setting it up. * For the assets you can have a static file route * Port 80 is &lt;1024 so you need root to start this service, having a docker image would be the most elegant way, also quite easy. 
&gt; perform automatic code review and security review of pull requests Employ a programmer. Tools and linters can point out some common mistakes, but they can't do reviews; especially not security ones.
Well, first in your Golang code you have to fetch the most recent entries. Assuming you've done that, and are passing the entries as a slice to the template, then you'd simply iterate over them in the HTML template: {{ range recentEntries }} &lt;li&gt;{{ .Name }} - {{ .Decs }}&lt;/li&gt; {{ end }} Above, we loop over the entries, and `{{ .Name }}` refers to the Name field of the entry corresponding to the current loop iteration.
That makes a lot of sense. Thank you!
The name is Go, not Golang.
The name is Go, not Golang.
Please format your code correctly by indenting it with four spaces or a tab. It's very hard to read like this.
I recommend the https://blog.golang.org/go-slices-usage-and-internals article, it will help you better understand how slices are represented, and in turn understand why those two snippets produce different behavior. The “A possible "gotcha"” section in the linked blog post is especially relevant.
In the latter, the changes to the SRC and DST will not be reflected outside of the function. See 'Slice internals' for a better understanding of how passing a slice by value only passes the ptr/len/cap triplet, and how the triplet changed as a local variable inside the function does not change the original one that was passed. https://blog.golang.org/go-slices-usage-and-internals
This was also failing for me (go 1.11.4). By adding the first go get command, the second succeeds (allowing the third to succeed and generate my assets file). &amp;#x200B; *//***go:generate** *go get github.com/go-bindata/go-bindata* *//***go:generate** *go get -u github.com/go-bindata/go-bindata/...* *//***go:generate** *go-bindata -pkg $GOPACKAGE -o assets.go -prefix assets/ assets/...* &amp;#x200B;
Bad bot
 type struct Envelope {... Should really be type Envelope struct{... Near the top of the article (typing this on a phone)
any reason not to use `alpine` and just add some `RUN apk install foo bar baz` to your `Dockerfile`? It’s what I do with my docker prospects that run builds for golang so I’d be interested in any counterpoints for doing this...
From the Readme - Dragonboat is the **fastest** open source multi-group Raft implementation on Github. Very interesting...
 &gt; func (it *Item) AdjustItem(price int) { &gt; it.Price = price &gt; } Quick thought: At least in this case, if you need to wrap modifications of `Price`, then *maybe* it's a good idea to make it private: `it.price`? 
It certainly is. But if I followed this article a couple weeks ago, my go version would not have supported modules. 
excellent, thanks for the reference materials
thanks, I'll give it a read!
Forgive me, I’m trying to read your code on a phone which is probably the worst IDE next to a whiteboard. But, if I’m reading this correctly, the head is the end of the file and the tail is the beginning. You keep a pointer to the head (presumably initialized to the first non-zero length value) on startup. That means the file is never truncated or copied forward to purge old entries, right? I might have missed the GC if it exists so please let me know where that is if it’s there. What is the layout of the file? Is it possible to misinterpret the value sizes if alignment relative to your layout gets messed up? Basically, is there a magic value you can verify the layout against to be sure you’re reading the size and value correctly? I may use this in the near future so thanks in advance!
thanks for this! im glad there is a safe mode, too many times you see projects with bad defaults (mongodb comes to mind in early days of letting the OS fsync). Honestly after spending so much time on storage systems, letting the OS fsync is probably the worst decision you can make since they try to be so general and the defaults vary. From my own experience i think you should consider offering a batching and periodic modes too. The best systems let you reasonably quantify expectations of data loss. Having it so you can fsync after N items or after period of time (10s - configurable of course) helps set expectations so you can balance speed vs durability. Just my two cents after doing this stuff for so long.
I now use VSCode, but i do miss how Atom (Go-Code) showed full function signatures with return types in the code completion drop down. in VSCode you have to go down the list one by one.
Your employer sounds exceedingly short-sighted. €200/year is about 0.25% to 0.5% of an employee's cost (if you factor in salary, equipment costs, taxes, office maintenance, and of course coffee). It's very little. So if you do your job 0.25% faster with better tooling then your employer made a return on their investment. Not to mention that having employees pay for their own tooling is not exactly good for morale.
It’s totally valid approach and I used it at first. However the example I showed is a bit unusual, as two compose services are built from a single Dockerfile. In that case Docker Compose builds two separate images anyway, so in the end I decided it will be simpler to download bigger base image once. For most use cases though, alpine is a good choice. 
It was always the same for the end user, if you're paying for the license you can use it ANYWHERE, that includes your company. The significant difference between business license and user license is that business has to have the right to pass the IDE to other employees, like someone quit new person came.
GoLand. I'm spoiled by PHPStorm already. Downgrading to editors with plugins (vscode + go plugin) felt like a huge drag. It just.felt.awful. And while language itself isn't all that complicated, I grew tired to see how VScode fails to highlight argument types in different color or keeps on suggesting random stuff from lexical scope. It's not intellisense, it just damn guessing. These are not the same. Not to mention all the non-language specific tooling I'm already used to from PHPStorm.
Bad "Bad bot" bot
Oooh really. Will fix that. Thanks
What are you taking about? The whiteboard was the only ide to ever put the whole tabs va spaces debate to rest. (Spaces won. And you use 4 of them).
That looks really sweet. Looking forward to the opportunity to put it to work.
The bit you missed in terms of "GC" is that the queue is split into segments, which are eventually deleted. It doesn't seem to be one ever growing file, more like a log rotation.
What does multi-group mean? Looks very interesting indeed!
Off topic, recently I read about CRDT, https://en.m.wikipedia.org/wiki/Conflict-free_replicated_data_type , would this be able to forego the need of consensus altogether?
Desktop link: https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^229599
Using Go as backend instead of NodeJS saves you from nodeJS's one CPU Core restriction. The bridge is only used to control the browser window. I've personally written C++/QT Computer Vision applications and would nearly always prefer a to develop a Typescript/React UI for productivity and simplicity reasons. Sure there a rare cases where you want the power of GTK+ or QT but in most cases a web based UI is just enough. Please keep in mind that Visual Studio Code is based on Electron. It is doing an awesome job for most of us software developers.
I'm looking for a "double-free" and "dangling pointers" type of security issues
Hey, thanks for pointing this out! We just committed [a change to the GH project](https://github.com/facebookincubator/dhcplb/commit/371a5e9965f95f163934e0b02e9f7342ad11a13e) to re-license this under MIT (and removed the `PATENTS` file :)) &amp;#x200B;
In general a lot of backend services in FB are written in C++ (especially the user facing ones, or the ones that have very high throughput, i/o) Python sees a lot of usage in infrastructure automation and processing pipelines of various types (AI, Ads, etc). A lot of things are started in Python first, Python3 + asyncio gets you far away, some teams never have problems with that, some teams might hit bottlenecks and might end up rewriting things in C++ (or golang as it's the case of my team :))
Go is a garbage collected language. Double-free and dangling pointers don't really happen.
If the DB is a global variable and exported, you can set it yourself during an init of the tests. However, all tests will still be using the same global DB object, and thus might interfere with each other. You can try to run the tests sequentially by passing \`-p 1\` to go test, but this will all bite you in the ass later on. Make sure that in any new projects, your program constructor accepts a \`\*db.Sql\`, that way you can pass a mock during tests. 
That's why I used quotes. 
How about opening multiple connections to the service and round robin across them? This way you lessen the probability running into a closed connections. PS: Any edits are appreciated 
Thanks. Resolved that. Once in a while an eagle eye is required :)
I haven't looked at the code, but I assume it corresponds to what CockroachDB calls "multi-Raft". Imagine you have an RDBMS that you want to replicate with Raft. A naive implementation might have just a single Raft log: Every database operation will be sequenced through it. Since the log is strictly sequential, every single update is queued behind other updates. If you have just a single database, that's fine. But if you have multiple *independent* databases, it's completely unnecessary, and bad for performance. One database could hold up performance of another database this way; the log is a performance bottleneck by definition. You could create one log per database, but that would mean many more network connections, as each leader and follower would communicate with another connection. (In Raft, all peers connect to each other.) Instead, you could invent a level of indirection; everyone talks to each other as if there's a single log, but each log message is tagged with a group ID. When log messages are processed, messages within the same group are handled sequentially, but messages overall can be processed in any order. So the cluster has multiple "logical logs", layered on top of the same protocol. In CockroachDB, the unit of Raft data is the shard. Each shard has a leader and multiple followers. Since a table can have many shards, and the cluster as a whole could have thousands of shards, a naive one-log-per-shard would cause a crazy amount of network traffic.
Fantastic explanation, thank you very much!
Great. :)
Thanks, I'll use that phrase "like log rotation" in the documentation. That may describe it for most people better than a lot of words will.
I've built something similar and written a blog post about it [https://redbyte.eu/en/blog/using-the-nginx-auth-request-module/](https://redbyte.eu/en/blog/using-the-nginx-auth-request-module/)
Not at work (am a software engineer leading a team in a medical company where the codebase is mainly php), but for a pet project I'm writing a self learning auto pilot for an rc-plane in Golang. It uses reenforced learning to fly the plane under different conditions. I started out in Python, but simply need the performance and the concurrency. This is my second project in Go and I love it. It's as easy to read as Python, but prevents a lot of runtime errors because of the strong typing. I'll be posting a video blog about the build of the self learning auto-pilot soon. Looking forward to feedback and ideas on it.
Very cool project. I wrote [undock](https://github.com/titpetric/undock) some time ago to install VMs based on Dockerfiles (at least compatible ones). I like your way better as it allows running pretty much any OS from any docker image, if i'm not mistaken. At least up until a point (ENTRYPOINT being the operative Dockerfile directive, and compatible architecture). My questions are more along the lines - do you use any custom networking? I see that nspawn does create a container, but doesn't seem to do much else that docker does (network isolation being the big one). How do you handle volume mounts? mount --bind?
When you use this merge function, the idea is that merge should immediately run a new channel from the channels that you give it, and you can start reading from that new channel. On the other hand, the goroutine that closes the new channel only executes after all of the other channels have closed. You can try it with a simple example like this: ch := make(chan int) go func() { for i := 0; i &lt; 100; i++ { ch &lt;- i time.Sleep(time.Second) } }() mergech := merge(ch) for i := range mergech { fmt.Println(i) } With the code above, you'll start seeing numbers printed out immediately, but if you run the wg.Wait synchronously, the numbers will only print out after 100 seconds.
I'm not aware of any professional websites that were creating by Wix. Also, most dynamic content is going to require programming a backend. So web development is certainly not dying, it's still quite the opposite really. Also it's 2019 now :)
No.
Thank you. Currently we use host-shared networking. We're basically moving old runtime-heavy applications into containers, but still run them like normal processes that bind to the same host interface. We just want our applications to bring their own runtime at this point. The networking part will come eventually. Systemd-nspawn can give us our own networking namespace which we'll have to set up for our needs. A project that does something similar is the following, though I haven't tried it: [https://github.com/seletskiy/hastur](https://github.com/seletskiy/hastur)
It sounds like the server is doing some caching. 
I assume you mean plain HTML frontend instead of Javascript Progressive Web Apps (PWA)? Sure, see the https://gohugo.io/ project for a great website builder. Go is built to create powerful dynamic website/API backends (often called "web apps"). What you do one the frontend is up to you. Though most users expect the improved experience Javascript provides over plain HTML.
Thanks, more investigation needed then
They're solving different but complementary problems. Raft consensus is about having many trusted participants agree on what the latest state is. CRDTs are about writing state transitions in such a way that they can be merged in a deterministic way. For example, say node A makes CRDT operations X and node B makes operation Y. Without consensus, node B could argue to node C that Y is the latest state, and A could argue that X is the latest state. With consensus, they would all coordinate and ultimately get X and Y merged, so all nodes agree on what the latest state is.
Lol, asking a question that could easily be solved by reading the docs or even reading the Go code yourself if you're not sure, and then getting an answer from the dude who wrote the majority of HTTP package himself. ❤ Reddit.
How do you think Wix works? It was made by professional web developers. Web dev ain't going anywhere. It's just the low end that gets taken away by the ability of non-developers to self-service, but that's been true for like 10 years now. High end web dev will always be bespoke, just like you could easily print your own wedding invitations on your printer, but if you want them to look really good, you get a professional service to design and print them for you.
HTML is nowhere near dead. Pros do not use cookie cutter solutions like Wix. HTML, CSS and JavaScript let you do anything you can imagine really, whereas with What-you-see-is-what-you-get editors, you're limited to the functionality programmed by the developers.
Wix is good for very small businesses looking to get a quick website off the ground with limited functionality. A lot of companies prefer owning their tech, and frontend web development is only part of the story anyway. Web development is going nowhere at the moment. Once all software development can be automated by some AI it'll disappear.
You could just use [Caddy](https://caddyserver.com).
All the features are great, but disappointed to see it requires cgo. [https://dave.cheney.net/2016/01/18/cgo-is-not-go](https://dave.cheney.net/2016/01/18/cgo-is-not-go)
Reading various forums gives me good information for what users want &amp; are confused by when using net/http and thus influences its eventual redesign in https://github.com/bradfitz/exp-httpclient
I didn't see any persistent storage for which [feed items had already been published](https://github.com/umputun/rss2twitter/blob/master/app/rss/notify.go#L72). It would be really simple to throw bbolt in there for a [quick storage solution](https://github.com/etcd-io/bbolt#getting-started).
Glad to have package maintainers looking out for ways to help end users.
[removed]
I'll be writing 2018 for like the next 2 months...haha but thanks
This app doesn't publish all rss item, but [updates only](https://github.com/umputun/rss2twitter/blob/master/app/rss/notify.go#L70) from the moment it started. The restart won't republish anything and I see no practical need to store the state in any form. Btw, if for some reason, such state needed (I stil don't see why, but anyway) there is already stored state - twitter api. It is possible to get and parse fitered list of tweets to retrive such info.
Understood
it makes sure it cleans up after all input channels are done (closed).
[removed]
[removed]
Since you deleted your reply to ashlovesys's reply I'm assuming you grokked it after re-reading?
only if you have atomic clocks on each node (Spanner) or are willing to take a fair bit of latentency on transactions (Cockroach DB).
[removed]
If you make a tutorial, always try to *do* the tutorial exactly as it is written once you finished writing it, I've caught many errors that way. Or if possible, have someone else do it.
This has never been an issue as gofmt standardized it long ago. And tabs won, 1 of them.
IMO you should also commit your go.sum and also mark dep as optional requirement
`RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .` Christ, does anyone write an original article???
I've recently adopted Go modules, and I don't know how to do this, which command can be ran to generate it?
Symantec detects a "JSCoinminer Download 10" when I go to your site. If that's not on purpose, your site is being tampered with. If that is on purpose, fuck off. 
Hmmm I do have a widget which allows you to donate some CPU cycles, but it doesn't do this without you consciously clicking that. So if you like my content it is up to you if you want to support me by using that. If not that is also perfectly fine. Your rude last sentence might have wanted to check a bit more context. Of course I don't want to user anyone's hardware without the consent to do so.
[removed]
I think the information in the README of that project is very straightforward. Can you please show us the code that you wrote so we can tell you why it’s not working? I think that will be easier than to explain you what’s already in that page.
You're so right it's painful. For a contribution, my docker golang stage: FROM golang:alpine ADD . /golang/ RUN apk add --no-cache git gcc musl-dev &amp;&amp; cd /golang &amp;&amp; go get -u &amp;&amp; cd HTTP &amp;&amp; go build 
Oh, I didn't realize that I was posting in r/golang here. I should have whored tabs for that sweet sweet karma. Oh well!
This is function `func GetAllFromCat(w http.ResponseWriter, r *http.Request) {` `if r.Method != "GET" {` `helpers.ShowError(w, "405")` `return` `}` &amp;#x200B; `p := helpers.NewPagination(453, 33, 5, 5)` &amp;#x200B; `fmt.Printf("%+v\n", p)` &amp;#x200B; `config.TPL.ExecuteTemplate(w, "getallfromcat.html", p)` `}` &amp;#x200B; &amp;#x200B; &amp;#x200B; this is template &amp;#x200B; &amp;#x200B; `{{ template "header.html" .}}` &amp;#x200B; `{{if not .Page.IsFirst}}[First](1){{end}}` `{{if .Page.HasPrevious}}[Previous]({{.Page.Previous}}){{end}}` &amp;#x200B; `{{range .Page.Pages}}` `{{if eq .Num -1}}` `...` `{{else}}` `{{.Num}}{{if .IsCurrent}}(current){{end}}` `{{end}}` `{{end}}` &amp;#x200B; `{{if .Page.HasNext}}[Next]({{.Page.Next}}){{end}}` `{{if not .Page.IsLast}}[Last]({{.Page.TotalPages}}){{end}}` &amp;#x200B; &amp;#x200B; &amp;#x200B; `{{ template "footer.html" .}}` &amp;#x200B; &amp;#x200B; &amp;#x200B; at finally can't see nothing
Very useful. I often found myself needing to do \`docker exec -ti myContainer /bin/bash\` to explore an image.
Hey, looks like your link isn't working at the moment!
Lol. Thought you were in the /r/python? 4 space indent is the one true way over there.
Works immediately for me. Right now. Tried on my mobile. 
I think this is better: FROM golang:alpine RUN apk add --no-cache git gcc musl-dev WORKDIR /golang/ COPY . . RUN go get -u &amp;&amp; cd HTTP &amp;&amp; go build 1. Split the `apk add` commands out as a step, so that you get layer caching and don't have to re-run the install every time you change the image. 2. `ADD` also allows adding from a URL, where `COPY` only does local copying. I think it's more clear to always use `COPY` unless you want to do fetching from a URL. 3. `WORKDIR` both creates a directory if it doesn't exist and changes to it, which simplifies things a little. If you have Go modules or dep files, you can also separate the module fetching from the building, again for better caching. COPY go.mod go.sum ./ RUN go mod download COPY . . RUN go build 
Cheers for the corrections, this was unfortunately a quick hack done a while ago, but seems to work correctly. Docker's build caching still quite opaque to me, but your explanation is clear.
Seriously. This is terrible advice now.
oops, my bad. my company blocks your ip cause of malware scares apparently :P i'll look when i get home!
i'm just getting into go and really excited so i'll let you know of any feedback i have!
I Will check that donation widget I use. This is blocking valuable readers from my webpage. Would you mind retesting for me?
I also add `ca-certificates` when using just `alpine:latest` ```RUN apk update &amp;&amp; apk add ca-certificates &amp;&amp; rm -rf /var/cache/apk/*```
I thought I was in neutral territory xD
Why is it that every version of this blog post puts `go build` in the Dockerfile? Using a dockerized build is a nice way to ensure consistency, but you can avoid bloating your docker cache and preserve Go's build cache by mounting files into a container and building there. When I've built stuff like this, I keep the go build separate, so the Dockerfile just looks like FROM scratch EXPOSE 80 COPY myapp /myapp ENTRYPOINT ["/myapp"]
If you want to use google/go-cmp why don't you just import it and use it? Why do you need an alternative to testify? Why do you need testify in the first place? 
We do this as well lol
I've done this, as well as `FROM alpine`. Sometimes it's nice to have a shell on your docker container for debugging and things.
go run, build, clean etc
&gt; p := helpers.NewPagination(453, 33, 5, 5) I thought you were using [paginater](https://github.com/Unknwon/paginater). What is helpers? Please share the code that we can reproduce the error with. I don’t think _“helpers”_ is an alias for _“paginater”_ because there is no such thing as `NewPagination()`
lenn0x, I like your idea of allowing the library user to specify a time after which an fsync would occur (if writes have been done)
I found another method which works quite well. 1. Google Cloud Build [`gcr.io/cloud-builders/go`](https://gcr.io/cloud-builders/go) 2. Add packages `steps:` `- name: 'gcr.io/cloud-builders/go'` `args: ['get', 'github.com/gorilla/mux']` `env: ['GOPATH=.']` 3. Build `- name: 'gcr.io/cloud-builders/go'` `args: ['build','-o', 'api', 'src/main/main.go']` `env: ['GOPATH=.']` 4. Copy the built binary to Google Bucket 5. Final part simply adds any external dependencies to an new Alpine container like SSL certs and adds the binary in which is run on entry. &amp;#x200B; This process can be done without a CI/CD system, but I used Bitbucket Pipelines to orchestrate this process. Final images were 17MB\~ compressed on [gcr.io](https://gcr.io). Process allows for other steps and some testing to be done prior to committing a full build too to add some sanity. 
Todd Mcloud is a very passionate teacher.
Python is a dynamic typed language which allowed mixed types in a tuple. Go does not allow mixed concrete types in a collection because it needs to know memory layouts. You can however add different types that implement the same interface. In your case, what you want is a struct which defines the fields for which you want to store in a collection. Also go doesn't have "tuple unpacking", with the closest equivalent being the multiple return values from a function. You would just pop to the single item which contains your fields. 
You can also make a type alias for a slice of interface{} add add the Push/Pop/Peek methods. Illustrated here: [https://play.golang.org/p/KPU3MTKRjst](https://play.golang.org/p/KPU3MTKRjst) Some helpful slice tricks here: [https://github.com/golang/go/wiki/SliceTricks#push](https://github.com/golang/go/wiki/SliceTricks#push)
You need generics for this to be what you want. I suggest either waiting or selecting a different initial project.
Yeah you'll need a struct for this, as Go's 'tuples' aren't real types that you can store into data structures, they only work as return values, or as the left and right of an assignment. Go also doesn't have destructive assignment, the closest you could get is `a, b, c := s.a, s.b, s.c`
There's no dynamic typing going on there, it's a list of tuples of (int, string, bool) 
You probably want to create a struct to hold your tuple fields, as they're consistent: type Tuple struct { First int Second string Third bool } You could then use a slice of `Tuple` to closely mirror your example, but depending on your use-case, you might use a channel instead.
I wonder if its because a lot of people come from NodeJS perhaps? First time I deployed CFSSL I did the whole build thing, then we got a DevOps on the team who's docker just took the latest binary from where ever CircleCi had put it, and dumped it in / directory. It just worked.
I meant dynamic types in a container type in python. A tuple in python can obviously hold anything because under the hood everything is a PyObject 
[removed]
\&gt; When you ask your question, display the fact that you have (looked for your own answer) first; this will help establish that you're not being a lazy sponge and wasting people's time. Better yet, display what you have *learned* from doing these things. We like answering questions for people who have demonstrated they can learn from the answers. [http://www.catb.org/esr/faqs/smart-questions.html](http://www.catb.org/esr/faqs/smart-questions.html)
I use my approach mainly in deploying in production environment, using CI/CD where everything needs to be done within the dockerfile. But for local deployment, i think your method is best and is even faster.
This sounds interesting, I will give it a try. Does it work with only Google Cloud Platform, or can i also use a competitor?
[removed]
&gt; Does anyone ever write an original article anymore??? In my professional experience, this is the only way I've seen it done in the past, but I never knew why it was preferred over having `go build` in the Dockerfile. 
Read the link. It'll tell you why you're getting so many downvotes. Trust me, it's worth your time.
Ah sorry I missed the second part of your answer
I always build in the container with a multistage build because then Docker Hub can do everything for me, instead of writing a custom script to push the image (or make some CI service do it). Local development is a different story.
[removed]
Threads and goroutines are different. goroutines are very lightweight, spawning hundreds or thousands will not be an issue. Threads, on the other hand, are USUALLY best matched to the number of cores available on the target machine. [See here](https://www.youtube.com/watch?v=f6kdp27TYZs) for more.
Go is designed for this. They are significantly lighter than real threads. This is because they don't come with a full thread stack. I think a goroutine initially uses about 4k, where a real thread is at least 1MB of RAM per thread. Think of a goroutine as a struct that gets scheduled onto a much smaller number of threads than there are goroutines. Ironically, this is because it doesn't use the C runtime stack, which means that every thread must be associated with a rather large stack. You don't want to have a lot more (actual) threads than you have actual physical concurrency on your machine (ie: number of cores). One thing to watch out for though.... Just because you can have 100k goroutines, it doesn't necessarily mean that each goroutine can have an open file handle. Sometimes in Go, you can easily admit so much work into the system that you can run out of other resources that are not as robust. For instance, say that you need to upload many thousands of files into Amazon, but know that 128 concurrent files will saturate the pipe well. You have your many thousands of files scheduled to go up in a goroutine, and 128 threads service the thousands of goroutines. That limits the number of open filehandles and tcp connections in use. Go uses very little memory when written correctly, even under high concurrency.
Yeah a bit, but I'm reasonable, if it's not actually doing it that's fine. I exaggerate online more than I would in casual conversation, but come on it would be really egregious to post here and have it actually do that. I'll check once I'm back on that computer, probably tomorrow sometime.
[removed]
Wonderful, option a) would be a lot easier, and if it isn't going to kill things, then I'd rather go with it. It's on a pi zero but I will test it out.
Yes, I meant go routines. I see that I think of them wrongly as a "thread". Thanks for clearing that up!
I like this game! Here's my `.gitlab-ci.yml` stages: [build, release] variables: DOCKER_DRIVER: overlay2 go:build: stage: build image: golang:1-alpine cache: paths: [$GOPATH/pkg/mod] variables: CGO_ENABLED: 0 GOOS: linux before_script: - apk update &amp;&amp; apk upgrade &amp;&amp; apk add git script: - go fmt - go mod tidy - | git --no-pager diff [ 0 -eq $(git status --porcelain | wc -l) ] - go vet - go build -o chaos -ldflags '-s -w' - | git --no-pager diff [ 0 -eq $(git status --porcelain | wc -l) ] artifacts: name: $CI_COMMIT_REF_SLUG paths: [./chaos] docker:import: stage: release image: docker:stable tags: [docker] dependencies: ['go:build'] variables: IMG: $CI_REGISTRY_IMAGE:$CI_COMMIT_REF_SLUG before_script: - echo $CI_JOB_TOKEN | docker login -u gitlab-ci-token --password-stdin $DOCKER_REGISTRY_HOST script: - if [ $CI_COMMIT_REF_NAME = master ]; then IMG=$CI_REGISTRY_IMAGE:latest; fi - tar c ./chaos | docker import --change 'ENTRYPOINT ["/chaos"]' --change 'EXPOSE 6784' - $IMG - docker push $IMG - docker rmi -f $IMG Do I win? ;)
[removed]
[removed]
You may be interested in time.Timer https://godoc.org/time#Timer rather than trying to roll your own with sleeps.
In addition to what the GP said, you can also look at time.Timers and time.Tickers. They may provide functionality closer to what you need.
VSCode + \[vscode-go\]([https://github.com/Microsoft/vscode-go](https://github.com/Microsoft/vscode-go)) + \[bingo\]([https://github.com/saibing/bingo](https://github.com/saibing/bingo)) as a language server. ``` "go.alternateTools": { "go-langserver": "bingo" }, "go.useLanguageServer": true, "go.languageServerFlags": ["-format-style=goimports"], "go.languageServerExperimentalFeatures": { "format": true, "autoComplete": true, "rename": true, "goToDefinition": true, "hover": true, "signatureHelp": true, "goToTypeDefinition": true, "goToImplementation": true, "documentSymbols": true, "workspaceSymbols": true, "findReferences": true }, ```
You can use a ticker and an infinite loop with select statement in it. You can also use the ticker and spawn a goroutine that blocks on it. If you use the clockwork library, you can use a functionality it has which is very similar to tickers but only triggers once after a given amount of time. Also the goroutine to OS thread mapping is many to one. A new OS thread won't be spawned unless the goroutine blocks on IO. So if you don't have IO operations in the goroutines you can spawn thousands of them with no worries. I am slightly worried though. Your deadline for executing tasks might outlive the actual goroutine (service deploy, crashes) in that case you are better off persisting the tasks somewhere and looping over it periodically. 
That's what I do as well. If you want to build in a container that's fine but do it in a different container unless you need dependencies or something like that. This is essentially how Source 2 Image (S2I) builds work but on a smaller scale.
I'm not aware of any other services in this area. Maybe Azure might have something, but Google Build services are very powerful, yet simple. I can share an example bitbucket pipeline and cloudbuild.yml if you like?
But it isn't a constructive answer to tell someone they need to wait for a language feature or do their project in another language, just so they can more closely map syntax from one language to another. There are perfectly reasonable Go-based solutions to this problem that can be used right now, even if they don't look exactly like Python. 
I've made a bit more progress and am now refactoring it all out to a simple package that gives you access to the pixel buffer for the scene/window. No tests yet, still getting the hang of Go idioms, the refactoring process is pushing me here, I'd also like to look into go routines down the track as I'm sure they will help with frame rates down the track, cheers.
yeah, just consider how you're going to handle the pending jobs when the Pi reboots or your program is otherwise terminated.
I've made a web crawler for a company with Goroutines onve. A simple 5 USD (1 vCPU, 512 MB RAM) DigitalOcean VPS can handle atleast 100 Goroutines running at the same time without any issue.
Generally speaking, I go with a root folder that looks like: ``` cmd/ # executables. main functions are as small as possible lib/ # everything else ``` If you prefer keeping the `lib/*` subpackages in the root folder, no one would blame you. I personally just prefer keeping them out of there, as the root folder usually already has enough READMEs, .github, CI, Makefiles, go.mod, etc to clutter it up, it doesn't need more actual code as well. Within `lib/`, more packages: ``` lib/config # loading and validating environment variables lib/handler # "route handlers". most of the body for each API method lib/&lt;model&gt; # logic for specific models, domain logic, etc. lib/server # http server creation, mounting routes, etc lib/util # random utility functions ``` Specifically with the `lib/handler` package, I prefer a pattern of writing handlers that take in basic `MyHandlerInput` structs and return `MyHandlerOutput` structs, then writing a second layer on top of that which knows how to take in an `http.Request`. That way, you can more easily test the core logic separately from the request handling, and you can re-apply the same handler code for usage in other binary deployments which don't mount on an HTTP server. ``` type Handler struct {} type HandlerInput struct {} type HandlerOutput struct {} func (h Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) { input := HandlerInput{} // ignore all the error suppression and compilation errors json.Unmarshal(ioutil.ReadAll(r.Body), &amp;input) output := h.Handle(&amp;input) w.Write(json.Marshal(output)) } func (h Handler) Handle(input *HandlerInput) *HandlerOutput { // the actual logic } ``` The Models and Domain Logic are what is most specific to your app, and its harder to give advice on that. Think about database tables, or the nouns that you talk about when talking about your application. Think layers around external services. Those are the things that should get their own packages. 
&gt; That's what I was originally doing Okay so this is a solution no? &gt; It makes your tests code much shorter and IMO easier to read. It also makes tests fail at runtime. Meanwhile, you can write a few helpers yourself to keep compile time safety and get rid of testify.
[https://github.com/n0byk/linkmonster](https://github.com/n0byk/linkmonster) this is all web app `you need controllers/getallfromcat.go , helpers/pagination.go`
Are you retarded?
[removed]
In fact, AfterFunc is very intelligent about sleeping quietly in a single goroutine until the next func is scheduled, and so on. It basically combines the best of both worlds
I hope it is resolved as this potentially will cost me valuable readers which I was not aware about. Looking forward to your reply.
How do I do it in caddy?
I just want to say thank you, not only for the content you’ve shared, but the absolutely beautiful post format you’ve put it in. It’s so nice to be able to read a quick description of what’s in all the links without having to skim through each one
Dragonboat author here, I am trying a list of pure-go options but so far the challenge is to find one that is proven to be reliable. etcd's boltDB fork is currently on the top of my list. 
lobster\_johnson provided a detailed explanation from an application's point of view. For the raft library itself, it means the library has built-in support to share cpu/network/storage resources across many raft clusters. Each raft cluster is basically a leader with multiple followers working together to reach consensus. When application developers decide to shard its data in certain ways by employing multiple raft clusters, the library needs to be able to efficiently drive all of them. A few example issues the library has to face are 1. how to allocate available cpu cores to different raft clusters? 2. each proposals (write requests) have multiple stages in its lifecycle, they need to be pipelined to maximum efficiency, with the above requirement 1 in mind, how to implement such concurrency? 3. each raft cluster maintains its Raft entry log, they need to be replicated across the network and persisted onto disks. how to do that efficiently? e.g. whether each raft cluster should independently writes its own entry log data onto disk or maybe batching the entry log from multiple Raft clusters together and write it in one go? &amp;#x200B;
Its hard to read on mobile thought, [screenshot](https://vgy.me/HUfCPg.png).
[Looks fine on my end. Of course, we have different devices, though.](https://i.imgur.com/5fhYkR5.jpg)
I use Joey for Reddit. What did you use?
Looks fine for me as well with Relay.
This is a simple backend API written in go: https://github.com/gbolo/aws-power-toggle Frontend is vue.js
Thanks I'll look into it now
The blog engine [hugo](https://gohugo.io/)
You don’t need the fork. The last official release is great. 
&gt;I don't get this guy either, seems you linked/authored a helpful library? I've noticed an alarming trend in this subreddit where people go rabid when someone links a library instead of just using the stdlib. (stdlib rocks, but no need to hail it as the word of god.) &amp;#x200B;
I'm confused by your response. This post was not a question, but I can see how it could be interpreted as such. There is a link.
&gt;Are there additional c/c++ dependencies besides rocksdb?
If you are a beginner here is a basic skeleton and some resources. https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk https://gitlab.com/zendrulat123/goes https://github.com/josephspurrier/gowebapp
Telling people that Go in its current state is just fine with interface {} or other such things is a terrible out-of-box experience. It's better to say so clearly than try to obfuscate it. It's not like it fools anyone.
Tests always fail at runtime, they do not perform static analysis. I think what you meant to say was that in some cases an error in the test suite may not be noticed by the compiler because some assertions use `interface{}` and so they could be called with incomparable types. I have heard this argument a few times, but I must adjust it seems a bit strange to me. Perhaps it is because we have different development workflows. When I write any code I have tests automatically run when a file is saved. Generally my tests will take under a second to run, even with compile time. The different in time between having the compiler catch the type error and the test failing with a similar error is effectively inconsequential. Since assertions are used in test (not "production") code, and I think it is generally safe to assume that tests are run before any code is merged or deployed, any loss of type safety seems like it should not be a concern. Any errors would be caught by running the tests. &gt; you can write a few helpers yourself That is always an option. If your test suite is small, and your tests are only comparing primitive scalar types than this may be a reasonable option. If you need to compare slices, maps, multi-line strings, or other complex types, writing an assertion that prints a helpful failure messages becomes a lot more work to get right.
The GUI tutorial is outdated, go to the source instead: https://github.com/Equanox/gotron
Apollo for iOS
But the answer to the problem didn't even involve interface{}. The answer is to use structs with the required fields to put them into a slice (type safe and functionally equivalent). So instead of offering a Go way of doing it, your solution was "wait for generics or don't use Go". Less than helpful here. 
1. If it is not ready to use at all, don't tag it yet. 2. v0.0.1 is my preference, everything below v1.0.0 is considered unstable by vgo 3. I'd refrain from using alfa vs beta, instead use semver which should describe the stage enough. 4. Depends on what you are releasing. I like goreleaser for CLIs and stuff. 5. tag your commits when semver requires it. There is a huge difference in managing an open source project depending on it's size. What works for kubernetes is an incredible overkill for a 100 star library. Your project will grow with its users, and if you need major automation, you can add that later. Just make sure you get semver and tagging correct, as go modules depend on it. (recently encountered a project with incorrect tags, forcing me to pin to a commit instead of a tag) As for your PS, I always add my docker pushes in CI, but actual distributions I handle manually. If you have multiple daily releases, automate it. &amp;#x200B; &amp;#x200B;
Rip droid. Official iOS reddit app makes this perfectly readable
Thanks for the informative answer. In regards to things like concurrency, I feel like the best knowledge comes from first hand experience at solving a use case. However, finding that use case in the first place doesn't seem straightforward, and 'just solve a problem you have' with concurrency doesn't seem like the best way to go about it. What I'm trying to say is that I appreciate the knowledge that you've shared thus far, and I'd like to try and dive into content, hands on, that can give similar insight. I've just messed around with so many blog posts that are moreso, 'this is how you can do one thing' without really getting much deeper. I probably just have difficulty thinking about use cases. 
Looks fine in Reddit is fun
Have you considered bagder? &amp;#x200B; [https://blog.dgraph.io/post/badger-lmdb-boltdb/](https://blog.dgraph.io/post/badger-lmdb-boltdb/) &amp;#x200B;
So you have a ten year old Windows mobile phone? [Windows Mobile 6.1 was announced on April 1, 2008](https://en.wikipedia.org/wiki/Windows_Mobile_6.1) and is Unsupported as of January 8, 2013. [Go was publicly announced in November 2009, and version 1.0 was released in March 2012](https://en.wikipedia.org/wiki/Go_(programming_language). You don't have source for the OS and will struggle to get a suitable build chain running on a modern system. Getting the combination working would be on a level with the guys who wrote a web browser for the commodore 64. Translation: if you're asking this question, then no, you won't be able to do it.
Not a phone no, a barcode scanner. Windows was really popular on these devices and there are lots of them still in operation inside of logistics
interesting - when you say it's more efficient are we talking of 0.00000000001s faster or 1K less memory magnitude or? 
[removed]
[removed]
&gt; If you need to compare slices, maps, large multi-line strings, or other complex types, writing an assertion that prints a helpful failure messages becomes a lot more work to get right. Writing a helper with a good error message is generally worth the extra work up to medium complexity cases. For the most complex cases there is always `reflect.DeepEqual` as well as useful libraries that pretty print diffs. Writing helpful error messages in tests is a good culture promoted by Go. Unfortunately this culture doesn't reach codebases that use testify.
Compare libraries I think are fine. Assertion libraries not so much.
Lol drop Windows
Got any arguments to explain that opinion?
What makes you think that using an assertion library prevents writing good error messages?
[removed]
Maybe use a proper os
&gt; Writing a helper with a good error message is generally worth the extra work Why do you feel it is worth the extra work? What do you gain by writing repetitive messages that are prone to errors? &gt; For the most complex cases there is always `reflect.DeepEqual` If `reflect.DeepEqual` works for the most complex cases you have encountered, that is great. It is rather arrogant to assume that the problems you have encountered are as complex as those being solved by others, and that no one else could possibly have needs that do not match your own. &gt; Writing helpful error messages in tests is a good culture promoted by Go What would you include in an error message that is not already available from the values being compared, the test name, and the subtest name? Considering that many assertion libraries also allow you provide additional contextual text to an assertion, do you really lose anything by using an assertion?
I create the session once in the main function and pass it into each AWS service I need to use. Its the AWS service object I pass around to functions to do stuff. eg func main() { session = create a new session dynamo = create dynamo with session then pass around dynamo value } 
meh
Something that wasn't mentioned when describing table tests is that you can avoid the issue of test cases not being identified by using sub-tests. Before this feature was introduced to Go testing, I agreed that it was hard to know which test case failed. Now, I get named subtests which are even individually runnable by pattern matching. I still don't use any external testing dependencies. 
Author here. Seems like I didn't communicate clearly on this. You're right, that sub tests identify each table case. However, depending on the test code structure the error stack trace will lead to the loop and not to the test case itself. You'll have to find the case manually. The proposed solution solves the issue. How do you trace back to your test cases when using table driven tests?
Someone needs to implement, test, and maintain the code. Currently, there's no one doing that (although there has been some effort in recent times on the issue tracker). If you're not willing to be the person to maintain this stuff, why do you feel like you're entitled to demand that someone else does? Alternatively, rethink your problem and determine whether just creating plugins that communicate via RPC would solve your use-case, rather than in-process plugins.
[removed]
Hashicorp worked around this in terraform by making each plugin into a standalone program and using grpc to talk to it.
My project is a virtual machine for a programming language and it requires some sort of way way to extend the functionality, do you think that rpc can solve that?
Thought about that...lol
Aren't you then limited to just exchanging strings and json data/encoded?
Depends, if you are writing the client and the server you can use any protocol you want. 
It certainly *can*, just depends what your performance requirements are.
haven't seen devices like that in a while, but are you sure it is Windows Mobile and not Windows CE?
mobile 6.1
Maybe I don't fully understand your proposed problem. Isn't the body of the loop technically the test code you want? The only problem before subtests was knowing which test case was failing. Now when it fails with subtests, you see exactly the test case name and the trace back is for each individual subtest. I don't see how it matters if line 50 in the trace back is a loop body or an unrolled 3rd party testing framework test line. 
Personally, I try to minimize the amount of "testing logic" and focus on simple assertions. Introducing logic into the test results in another possible point of failure. I prefer a dead-simple declarative approach: assert := assert.New(t) obj := Object{} assert.NoError(obj.LoadFile("testdata7.csv")) assert.Equal(372, obj.NumRows) assert.Len(obj.Headers, 7) assert.Equal("name", obj.Headers[0]) It's boring and repetitive, but that's ok because tests don't change as much as implementation does.
Ah okay. Is there any way you can globally define dynamodb without having to pass it around? 
very cool I would make the sub-package called "basex" and allow for alphabets of any size, then have your root folder called base58 and add the restrictions. the const for 58 could become an attribute on the Alphabet struct.
Who's going to look at a library and guess what OP wants us to do with it? This is a terrible post...
If you can't be bothered to write anything to demonstrate value here, then I won't be bothered to do your homework for you.
I would gently suggest a paradigm shift. Use LuaJIT. Here is an example. It works on windows. It links LuaJIT into the Go main executable. It provides a Golang REPL. https://github.com/gijit/gi LuaJIT allows you to load any C library you like at runtime. By compiling any Go library into a .so/.dll, you can load it as well. It doesn't use the Go package system.
I have never understood what problem libraries such as goblin are solving. How is this: Expect(err).To(test.expectErr) Expect(val).To(test.expectValues) An improvement over this? if err != nil { t.Fatal(err) } if output != tt.expectedOutput { t.Fatal("unexpected output") } What's wrong with `if and `==`? Why do we need to abstract it? The Ginkgo example is even worse. It turns a very simple, straightforward, and understandable piece of code and chops up the execution in several different functions (`BeforeEach()` and `DescribeTable()`), and adds the same abstractions over `if` and `==`. I don't see how "Ginkgo makes your tests much more expressive"; what extra expressive powers does it give you over the regular control statements and operators? I think there are real problems with these test tools, as they all obfuscate what you're actually doing. You're adding heaps of code just to save a few lines and make `==` look more "beautiful" (personally I would say it's not even that, but that's a subjective matter). When determining if something is "easy" then my prime concern is not how easy something is to write, but how easy something is to *debug* when things fail. I will gladly spent a bit more effort writing things if that makes things a lot easier to debug. All code – including testing code – will fail in confusing, surprising, and unexpected ways (this is called a "bug"), and then you are expected to debug that code. As a rule, you should expect all code that you're writing to go through at least one debugging cycle after you've finished writing it. Often, there is more than one cycle. In general, I already find testing code harder to debug than regular code, as your "code surface" tends to be larger. You have the testing code and the actual implementation code to think of. That's a lot more than just thinking of the implementation code. Adding these abstractions means you will now also have to think about that, too! This might be okay if the abstractions would reduce the scope of what you have to think about, which is a common reason to add abstractions in regular code, but it doesn't. It just adds more things to think about. So these are exactly the *wrong* kind of abstractions: they wrap and obfuscate, rather than separate concerns and reduce the scope. tl;dr: testing is already hard, and adding more abstractions only makes it harder.
I like how [semantic-release](https://github.com/semantic-release/semantic-release) works ([intro](https://blog.greenkeeper.io/introduction-to-semantic-release-33f73b117c8)) and have used it for a bunch of projects. I have also successfully used it with [goreleaser](https://goreleaser.com/) together ([example](https://github.com/hipages/php-fpm_exporter/blob/master/.circleci/config.yml)). semantic-release is basically the gateway and does the tagging while goreleaser creates the actual release. &amp;#x200B; &amp;#x200B;
I believe base58 is a Bitcoin Thing™ so that’s the target market. 
then why make an Alphabet type and pass it as an arguement if you're just going to panic when it's not what you want?
SOMEONE BUY THIS MAN A DRINK! I used Ginkgo in my last gig and I felt the same. Your tests should be the most reliable code you write, so there is no need to inherit a liability in the form of a complex community supported framework that prevents you from writing idiomatic tests. A simple assertion library like testify is okay for productivity, but I worry about that as well. There's some nice new features coming to the stdlib in Go v1.12 and v1.13: deterministic printing of maps and test logging during test execution. Those things will make testing without 3rd party dependencies even nicer.
I guess there would be, just create it as a global variable but I feel this is questionable coding style. Instead I created a struct called `context`, it stores all the AWS services I need to use throughout the script and I feed this into all the functions that need to use it rather than rely on global variables. I don't really know any go, just used it a couple of times to hack some AWS scripts together but felt it worked ok and its easier to test if you ever wanted to do that.
Yeah, it's just a global variable. However, when it comes to stuff like unit testing (or really anything more involved than a sample app), it's better to have dependencies injected (can be as simple as passing around a context) so that you can mock things instead of having your unit tests connect to AWS.
You could use encoding/gob and just exchange the binary data which would be extremely faster, depending if that fits your use case. 
Notice how this is not Javascript based. Looks like a custom web server designed to shit out endless piles of poo.
Yup, it basically has the same use case as Base64; representing large numbers in a compact way for human read/input. It has the more confusing and non alphanum characters removed: O0 il +/ This is a cool implementation but I wonder if the naive approach, with a worst case of 1us, was really the limiting factor when interacting with humans :)
Reddit hug of death? 🤔
Nice post
Ugh seriously. I've seen so many tests in go that just shoehorn some third-party test library that just obfuscates everything. And then I get push back when I suggest deleting it all in favor of the standard lib. Everyone's taking crazy pills!
relevant: https://twitter.com/rob_pike/status/1075163975875055616 
I wonder how many crawlers and things will be broken upon finding a page that is responsive, but just very slow, and gives an unending amount of data.
Another former variadic functional argument guy. I, too, wound up going the config struct route. Glad to hear others come to the same conclusion
I have created a testing framework for API testing. Test cases have predefined struct that name, title, desc, url, body, teardown, setup func, expected result that can have regex. It reduced my time to just writing test cases for coverage. No testlogic required in most of the cases. I will try to open source it. Earlier I didn't think it was worth to others 😁
goroutines are scheduled onto threads, and if you do anything to block a thread, e.g. file I/O, then you’re going to pay the full price of that resource. However, blocking a goroutine and blocking a thread aren’t the same thing. The runtime frees threads whenever it can when goroutines block, and guarantees threads won’t block in the following instances: * channel operations * network operations (thanks to netpoll) * sleeping * primitives in sync package In your case, using `time.Sleep` would mean your goroutine would block, but the thread would be freed to do other work. When the sleep time is up, the goroutine would be scheduled onto a free thread. You only pay for the cost of the goroutine, which may be a few KB of stack memory compared to thousands of times that for the equivalent thread stack. So the answer to your question is: Threads used in Go are as heavy as in any other language, but goroutines are an abstraction on top of them that allow lightweight concurrency in many useful situations — just make sure you know which situations they are.
Thanks for the idea! Now I am definitely planning to leverage Envoy as soon as initial architecture of the project established. Did you have a chance to measure a latency added by Envoy proxy across microservices communication?
I believe that this idea might not work when an underlying tcp-connection with the service disappears: all opened connections would become invalid. Seems RR here should be handled by service mesh or similar tool.
Link is broken, what has he done?
As far as I know, mutex in Linux is all about context switching (kernel &lt;-&gt; user space), so there should be an overhead. But for now, that seems is the only working way to achieve my goal.
It writes the poop emoji to screen roughly every 300 ms by my estimates. But it's a buffered write on the server side so the page stops loading (or writing poop to the screen. 
The irony
Self [slow loris](https://en.wikipedia.org/wiki/Slowloris_\(computer_security\)) someone stop this man
[removed]
does that means if you launch multiple tabs, his backend will have to spawn multiple threads and kill itself?
It's like toying with the output buffer in php, but the output isn't sequential.
Most probably just time out because slow loading pages aren't unusual.
Very valid point
&gt;so the page stops loading 🤔 my tab is spinning indefinitely, so it seems to me like the page never stops loading?
It's a shitstream. Was a joke andrew gerrand committed to an example pull request or something a while ago. I can't find it now. 
How does someone accomplish something like this? I don't see any JS or network requests, it's mind-boggling to me
Well considering you're on /r/golang you should probably know that the server is likely written in Go and Go does not spin up new threads to handle requests, but rather goroutines. Goroutines are (relatively) efficient, you can have hundreds and thousands of them at once and they're cheap to spawn. See https://golang.org/doc/effective_go.html#goroutines for more information.
Whoops. Yep I meant never. 
Like so: https://play.golang.org/p/0i67F3iZ8fY
The page never finishes loading so it's all the first request.
Yes. See [Gobot](https://gobot.io/) for a generic firmware that can be remotely controlled, or [TinyGo](https://github.com/aykevl/tinygo) for compiling directly to low-resource systems. Of course, the definition of 'embedded' is sometimes fuzzy.. If I buy a [Linux box](http://linuxgizmos.com/catalog-of-122-open-spec-linux-hacker-boards/) for $5/$10/$20 that runs Debian, is it embedded?
The link isn’t broken. Your browser probably doesn’t display the contents until the first request completes, which it never does. Try clicking the link, waiting a few seconds, then hit the stop button.
+1. I also don't understand why the examples in OP's article keep using `t.Fatal`. One nice thing about Go's testing library (there are lots of nice things) is that it have both `t.Fatal` and `t.Error`. Yes when you do `output, err := SomeFunc(); err != nil` that warrants a `Fatal` because you don't have an output, but a value mismatch, in most cases, should not stop you from running the rest of the test (it's the last one in the example (sub-)test so it doesn't make a difference. but it's a really really bad habit to do).
It’s ironic that they are discussing on Twitter how the web is broken with intrusive pop ups. As I’m reading this on the iOS Reddit app web view, a Twitter login window appears with the inability to bypass.
I'd steer clear of C++ as well, so much chaff in the language. When you're operating at an embedded level your margins are much slimmer. The language you choose will dictate the hardware you buy. I'd personally look to C or Rust.
With any server that supposed [chunked transfer encoding](https://en.wikipedia.org/wiki/Chunked_transfer_encoding)
Can you please explain why you choose C / rust over Golang? I heard Golang is compiled language like C ..!
&gt; What would you include in an error message that is not already available from the values being compared, the test name, and the subtest name? How about why the test expects the value it expects? Also context about the test. Why is this test necessary? But most importantly, explanation of the business (if it's a business test). In general, communication with the future reader which could also be yourself. In many cases, the test/subtest name is sufficient. But you just can't beat a well written human message. &gt; Considering that many assertion libraries also allow you provide additional contextual text to an assertion, do you really lose anything by using an assertion? It's a [matter](https://golang.org/doc/faq#assertions) [of culture](https://golang.org/doc/faq#testing_framework). Writing is thinking. When a developer has to write a good error message for the future reader, not only their understanding of the codebase increases, but they also save time in the future when the test fails. Meanwhile, testify messages are optional. Therefore the average developer won't bother with them.
I’ve heard about those firmware but my project cares about ns execution. In general it’s the GPS concept, tirlateration over the wifi network. 
[Yes, I explained below](https://www.reddit.com/r/golang/comments/acmmph/testify_alternative_which_uses_googlegocmp/edd9rl8).
Is there a way to "view source" of this on Chrome or Firefox?
No, you can exchange anything that can be serialized.
Golang is compiled, so is C. It's not right to say they're compiled to C. They are both compiled. Also Go binaries ship with a copy of the go machine which adds a lot of size overhead. Additionally this go machine step also slows down execution. Where memory and execution time are expensive in embedded systems, using C to cross compile for a specific target is the cheapest and quickest method. Companies are willing to pay the cost of a C developer and the complexities entailed, if there product is better. Go could be a solution for homebrew projects to allow more people access to the market. However that's more of a Rust thing.
Thanks a lot. But u mentioned C. Does c is different than C++ in term of speed compile etc. ?
It can be as simple as including some form of name/id in the table tests data. Also, table tests are better for calculations (unit), and subtests are better for behavior (functional).
After all, The project that I’m planning to work on need to be networking (multiple servers and multiple clients) which also need to use the concurrency feature. That’s why I picked Golang since it’s much easier than other languages to implement this feature. But another part is the hardware. The program must deal with the hardware which makes me doubt about using Golang. I have no experience in C/C++ programming but I’ve done many Golang network programs already. Any idea or guid ?
Slightly faster and easier to debug. C++ can do almost the same if you don't use most of the STL, which I hate anyway.
I am not sure how reliable is badger. 
Is there any proof that this was done by Rob Pike or a friend of his?
No - and there is no plan to add any more non-go dependencies in the future. RocksDB support will stay forever, but it will eventually become an option that need to be explicitly enabled by users. A pure-go based approach will be the default storage engine in the future. The only challenge here is to find a super reliable kv-store in pure-go. Cheers! 
I agree, communication was not very clear and the article couldn't convince me. For example you claim that different ways of testing yield better/worse to read output. Why are you omitting such a crucial detail? It is unclear why you need stacktraces - hence your initial problem statement lacks information. Once you get to your solution you state that it is inspired by Stomka's *testing go with custom check functions* - and we can find similar patterns in go's stdlib. Just give us an example of these techniques such that we can see your contribution. 
&gt;It's like toying with the output buffer in ~~php~~ Go, but the output isn't sequential.
I think that you are hired.
Apart from Twitter
For what it's worth, I've been using it heavily for months without issue. I realise this isn't exactly a rigorous evaluation, but thought I would mention it anyway.
Is it me or are there no tests?
Are you sure it's not just about the difference between `"("` - string and `'('` - char ?
You don't have to assign the string to a []rune. You can simply ``` for _, r range s { // r is a rune } ```
Or you define a aws.DynamoDB in a struct and use function receivers. Here is an rough idea of the concept: https://github.com/unee-t/env/blob/master/main.go#L19
Fairly simple example of a unauthenticated API https://github.com/kaihendry/goserverless.sg deployed with Apex Up.
No comments here on how awful it is to build this? Reddit is full of resentful people.
10000 vs 100000?
Doh! Good catch.
SO follow up https://stackoverflow.com/questions/54058007/how-to-prove-this-code-has-a-race-condition
An interesting method for stopping trivial scrapers (if used after meaningful content has been output for users).
That's poop streaming aka chunked response
I get the same result from both languages, which doesn't match either of your results, so I'm not sure what's going on. [Online Go version](https://play.golang.org/p/6y90tf8iPUN) (I had to copy the source for pbkdf2 as you can't import external packages in the Go playground) Output: 0x240fac6eba979da47d3a8931e3dad725f9f2d7632505fa6534f65727371fe4c3ff9a05cb80c8bc62f30576494e436a4a608a [Online Python version](https://onlinegdb.com/BkIl9IJGE) Output: b'240fac6eba979da47d3a8931e3dad725f9f2d7632505fa6534f65727371fe4c3ff9a05cb80c8bc62f30576494e436a4a608a'
I started a simple parser combinator framework for Go in 2017 and recently took the time to finish it (well, as finished as a v1.0.0 library ever can be). To be honest, I'm still figuring out for myself how to use my own library the best way, but it already helps me solving real problems at work. If you can use it: Great. If not: Also okay. Feedback is welcome anyway.
Honestly, I'm still thinking about how to test it where the tests would actually do something useful. Most of the logic I'd want to test is in the XML parsing. I would have to build a repository of different fixtures for each request and test that it doesn't fail and maps them correctly against the internal structs.
Seriously, if you can’t dual boot your machine, then install Virtualbox or VMWare Player and put a Linux distro into a VM. It’s perfectly usable like that for development.
[removed]
At least test that some recorded responses decode into the target struct with all the values are in the right fields.
Yeah, I think that's a good place to start.
Really interested in knowing about the shared memory...how would one go about that, somehow share pointers or what? Or like manually tell each other when some variable changed?
See also: https://www.reddit.com/r/programming/comments/acrb49/you_could_have_invented_parser_combinators/edbm43o/
The only character written to the client is the poop emoji. There's nothing else on the page.
That's good actionable feedback. Thank you! I'm considering to address the issue in another article. At first I didn't anticipate any feedback at all because many people around me don't care for testing at all. Just wanted to test waters. I learned that I left out too many details to prove my statement. That being said, some of the comments look like people didn't had to deal with rewriting complex software (that was well covered) so the issue might not be known to everyone. Other than that simply voting down my statement in case I didn't understand the issue doesn't help at all. It's just for the downvoters ego. So thanks again that you actually cared for my improvement.
thanks for the info. 
Mobile twitter is ass. That is, when it loads instead of telling me I'm being 'rate limited'
It's all ok you just need to use '(' when comparing with a rune, "(" is a string and cannot be directly compared with a rune.
This site has been like this for many years. Why "again"?
The new Economist site is a total shitshow. Looks just as bad if you are a paying subscriber. They just show a massive "Gift a subscription!" popup instead of the "Subscribe!" one.
At Line 13, we have a contribution by the Poop Nazi. Where's George?
C++ has too much crap in it, but you can just ignore the crap. Look at John Carmack's code for example.
Similar project: https://github.com/carlmjohnson/heffalump
True, but then why not just use C. I said In another post that it's much easier for businesses to write C compilers than for C++.
Because you want OOP for example?
Well then that's a trade off betweens abstract data types and implementation complexity. Plus go doesn't use OOP, which is one of the many reasons I like it. And the same arguments that go has 'objects' are the same that 'C' has objects. 
This looks pretty cool. Will eventually try it out. One minor thing: to make the code look a bit nicer is to remove `New` from each of the constructor. ``` dollarParser := pars.NewSeq(pars.NewChar('$'), pars.NewInt()) dollarParser := pars.Seq(pars.Char('$'), pars.Int()) ``` With exception of the logging which could be `WithLogging(...)` and `WithStdLogging()`. Also maybe, in https://godoc.org/bitbucket.org/Ragnara/pars#NewLogger take an interface with the minimal methods, this means people can stuff in their own logger, whichever they use.
C++ has a more complex runtime than the C runtime. Support for calling destructors automatically, handling exceptions are some of the language specifics that gets into your compiled code. In embedded world, I would stay away from anything garbage collected and language runtime provided scheduler. Go does both (GC &amp; scheduling)
Because he first worked at bell labs, and then created Go, and then made an endless poop stream.
The proof is in the pudding. By pudding I mean brown shit.
What’s so difficult about building a web server that spits out a single Unicode character?
Why though? What has Rob Pike done to deserve this pudding?
enum and a switch statement then :D &amp;#x200B;
I thought about this but 58 is most popular base after 64 (and more popular then 32). All over encoding is very rare, so I don\`t want waste my time, but I can merge your pull request with this function.
Imagining web servers silently concatenating piles of shit to the end of every page on the internet is funnier than it should be
Reddit - perfect source of stars. :) &amp;#x200B;
Add Gmail redesign to that, too. Things just don't work anymore there, either, and it became ridiculously slow to load, so slow it immediately came with a progress bar.
I heard can be disable these from Golang. Isn’t it?
Interesting. That brings up another question I had. Let’s say I passed something around to each function which seems like a better practice, how would I unit test without having to actually reach out to the AWS API?
OK, so : because you want strings and maps?
I'd echo this... can you be specific about the hardware in question? I have no qualms running Go on a Raspberry Pi, and you're several factors of magnitude from running standard Go on an Arduino, even ignoring architecture issues. There's a lot of in between there.
The loop value is a copy of the original structure. You either need to save it back into the slice (for which you'll want the index), or have a slice of pointers. You probably want the first, though I do find the need to remember to do so can be a bit problematic.
Instead of reassigning you could write your loop like this: ``` for i := range foos { foos[i].count++ } ```
You forgot `:=` :)
The actual thing I'm doing is a bit more complicated than this, I just dumbed it down for an easy to read example.
Then do as @jerf suggested and use a slice of pointer types. This way, the loop variable is a copy of the pointer which obviously points to the same object.
I haven't seen that syntax on line 11 before. Is it some sort of casting?
From Go source: src/runtime/extern.go &gt; The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package's GOMAXPROCS function queries and changes the limit. I am fairly certain you cannot disable GC
It just keeps the connection open (or doesn't end the response stream) and flushes the current buffer continually, ending up with a infinite amount of poops outputted to screen.
Yeah. It's safe casting w into an http.Flusher and saving the casted value in f. If the cast fails (that is, w isn't an http.Flusher), ok will be false and f will be nil. If it succeeds, ok will be true. The value of w doesn't change either way.
Yes, agreed, use a slice of pointers. Here's your example redone with pointers for number 1. https://play.golang.org/p/h7CO4b74ros
I haven't needed to manipulate the buffer for any of my Go projects, but yes, it looks like ResponseWriter has that capability. Neat to know. PS I just upvoted you since I have no idea why you're getting downvoted.
You don’t need chunked encoding for that. Justs set content length to a reasonably high number and write stuff from time to time. 
[removed]
If Go has the support for your architecture, then you can begin regarding your embedded system just like a normal consumer PC, provided you have the *ware ready.
&gt; That being said, some of the comments look like people didn't had to deal with rewriting complex software (that was well covered) so the issue might not be known to everyone. I'm pretty sure you're now at the point of using ad hominem statements about the people who have downvoted or disagreed with you. It's not helping your argument as much as your feelings.
Why would that require nanosecond execution? You really should not be using a microprocessor, those things clocks are pretty slow and their clock speeds are super variable depending on the temperature. Also I doubt your router has atomic clocks in them, you don't need nanosecond execution to just read the signal strength of nearby access points.
Well you have strings in C and can have maps, like I said you can abstract all things enough to solve your problem.
You don't have strings, you have pointers to bytes, which is close enough as long as you don't want to have functions that build new strings or strings that contain non-english text. Sure, you can implement your own, non-typesafe maps, but that's a pain in the ass. Now, it's all about tradoffs, it really depends on the actual project. Sometimes I'll choose C, sometimes C++.
So if I understand correctly you need to use both in tandem ?
Thanks that really helps. From the semver docs (which for some reason I didn't read all the way through, before asking these questions 🙈) https://semver.org/#how-should-i-deal-with-revisions-in-the-0yz-initial-development-phase, it suggests starting at v0.1.0 which sounds reasonable but I agree with @kaiserkarel's, that if it's not ready then don't tag it approach. 
On win 10 , they have given options like Linux subsystem 
Sure. Is that the situation here, and is this a private machine, or a company owned asset?
oh thats cool. I was reading the golang strings [blog](https://blog.golang.org/strings) and it just says : &gt;Let's start with some basics. &gt; &gt;In Go, a string is in effect a read-only slice of bytes I guess I misinterpreted that.
The official documentation for “Custom Extensions” is here [1]. You can find examples of how to create new one from here [2]. [1] https://github.com/russross/blackfriday#custom-options-v2 [2] https://github.com/russross/blackfriday-tool
yea that fixes is, not sure how I was expecting the compiler to understand my "(" token as a rune
I don't see any problem with company machines , just ask the admin 
The same way you stream a YouTube video.
This is not true. A string is a slice of bytes, so r in this case will be a single bytes, but runes are not necessarily single bytes. Many UTF-8 characters are multiple bytes long and this will lead to bugs further down the line of invalid UTF-8 characters. Conversion to []rune is essential to ensure you are actually getting individual characters and not just bytes
Yes, this is because they're using a chunked transfer-encoding. You use chunked transfers to indicate to the client/server that the message's body length is indeterminate, only ending when a final special chunk is received. But note, if you don't manually keep track of how long your transfer is taking, you could be vulnerable to attacks. Keeping system resources occupied like this forever can enable malicious clients to consume all your system resources.
There is no direct support for changing the parser--you'd need to fork it. The built-in support is for changing the way the output is rendered after it has been parsed. To add rules for block-level elements (paragraphs, lists, headers, etc.) see the "block" method in block.go, which detects blocks and dispatches calls to functions that handle them. Inline tags (emphasis, underline, links, etc.) are handled a little differently. The parser (in the "inline" method of inline.go) scans within a block-level element looking for a character (actually a byte) that might mark the beginning of an inline element. Say it finds a "\*" character. It would then call a handler for "\*", which would validate the tag, find where it ends, and parse it out. These handlers are registered in the MarkdownOptions function in markdown.go, so if you wanted the parser to watch for, say, ";" characters to treat them specially, you could write a handler and add it to the list of registered inlineCallbacks in MarkdownOptions. Development on Blackfriday has been pretty quiet for a while. If you are interested in working on it and becoming a maintainer, please be in touch. We are especially interested in improving CommonMark compatibility and supporting popular extensions.
I only seem to get the rate limited thing within the reddit is fun app on mobile. Even when reloads seem to persist w/ that error open in browser works fine every time for me. 
What do you mean? I don't understand who it is being awful to.
[removed]
[removed]
It's a [type assertion](https://tour.golang.org/methods/15). See the [spec](https://golang.org/ref/spec#Type_assertions) for more detailed info; it is somewhat different from a cast in other languages.
That makes so much sense. Thanks for the heads up!
Such a low effort of a website... 😴
You did not. However, ranging over strings yields the runes and not the bytes. `range` treats strings as a sequence of runes rather than bytes.
I made it webscale: [https://pastebin.com/gx47iaYV](https://pastebin.com/gx47iaYV)
I have done it, it works great! The biggest concern I had was Go’s binaries can be pretty big, but that ended up not being an issue for me.
&gt;Seeing PRs with "here's the code, it works, but I couldn't figure out the tests, plz halp me!" is not uncommon; and I'm fairly sure that at least a few people never even bothered to submit PRs just because they got stuck on the tests. Writing testable code is the essence of software development. How do you know the code works? By writing tests. Untested code is usually written in a manner that is not testable because people didn't properly handle dependency injection or simply wrote functions that do too many different things. A rewrite would usually take more time than writing everything with proper testing in the first place. By the way, I don't think testing is hard at all. Writing code that's testable and easy to refactor is. If you write the tests first its way easier because you are forced to write code in tiny units. You might want to read clean code by Robert C. Martin if you don't trust me.
\&gt; Suppose we have a struct that contains a map, and we want to modify the map in a method. &amp;#x200B; \`go vet\` does of course warn about copying mutexes and works nicely on the linked example. Another good reason to use static analysis where possible.
It's very common to use pointers in slices and maps. Modification during iteration is one reason. In maps, there is another related reason: https://groups.google.com/forum/?fromgroups=#!topic/golang-nuts/4_pabWnsMp0
When is this sort of thing useful in a real application? All I can think of is file transfers. Can you think of other examples (where it makes more sense to persist the connection and use chunked transfer). I am used to thinking about the server having to complete all processing before anything gets printed in the browser. 
[Of course they don't](https://golang.org/doc/faq#assertions). &gt; We understand that this is a point of contention. There are many things in the Go language and libraries that differ from modern practices, simply because we feel it's sometimes worth trying a different approach. But that different approach has won me already.
[I explained above](https://www.reddit.com/r/golang/comments/acmmph/testify_alternative_which_uses_googlegocmp/edd9rl8).
[https://play.golang.org/p/dOOgGS6Shib](https://play.golang.org/p/dOOgGS6Shib)
[removed]
[removed]
I think you're being downvoted because the question is somewhat large and involves smaller discrete subsystems. This sub is not really a 1:1 help forum but you might have some luck on the golang slack server: [https://invite.slack.golangbridge.org/](https://invite.slack.golangbridge.org/) Can you explain what parts you have figured out and working? i.e: Are you able to CI a different project in a different language? Have you Googled for similar questions? Do you have specific questions that you're stuck on? Digital ocean has many tutorial on CI and droplets so you can probably get 90% done and come back and ask the specific questions. Once you got it working, write a blog article explaining how you did it so others can find your solutions. &amp;#x200B;
Yes. It was the "long poll" technique. Also used by Server Sent Events. It has been generally obsoleted by websockets. HTTP2 doesn't even support chunked encoding.
I'm not an expert but I will say a few things. For the sake of streamlining things, you may first start with turning your bare droplet into a PaaS using an open-source solution like Dokku so that you can abstract things away by only taking over the responsibility of maintaining your code and pushing it when needed. The rest is taken care of by Dokku. Heroku basically implements the same fundamentals, if you have ever happened to use it. For Continuous Deployment, you can release new artifacts and let your listener trigger a new deployment when there is a new release. I may be confusing some stuff and I would appreciate any answers it I'm wrong.
Why'd you say the last thing twice?
This is My first time setting up ci 
&gt; Untested code is usually written in a manner that is not testable because people didn't properly handle dependency injection or simply wrote functions that do too many different things. That wasn't really what I intended. I've seen plenty of projects with a lot of testable code and tests, but people just couldn't figure out how to deal with them. Some of the most difficult code I've worked with is code that is "easily testable": code that abstracts everything to the point where you have no idea what's going on any more, just so that it can add a "unit test" to what would otherwise be a very straightforward function. I think DHH called this "test induced design damage". Testing is just *one* tool to make sure that code works, out of several. Another very important tool is writing code in such a way that it is easy to understand and reason about ("simplicity"). I think that books like *Clean Code* were written, in part, as a response to ever more complex Java programs, where you read 1,000 lines of code but still had no idea what's going on. I recently had to port a simple Java "emoji replacer" (:joy: -&gt; 😂) to Go, and to ensure compatibility I looked up the implementation. It was a whole bunch of classes, factories, and whatnot which all just resulted in calling a regexp on a string. The Go code is a function and a few lines of code 🤷. I'm not saying all Java code is like this, but far too much of it is. In dynamic languages like Ruby and Python tests are important for a different reason, as something like this will "work" just fine: if True: print('w00t') else: nonexistent_function() Except of course if that `else` branch is entered. It's easy to typo stuff, or mix stuff up. In Go, both of these problems are less of a concern. Sometimes you can do a straightforward implementation that doesn't sacrifice anything for testability, but sometimes you have to strike a balance. For some code, not adding a test is fine. In particular, intensive focus on "unit tests" can be incredibly damaging to a code base. Some codebases have a gazillion unit tests, which makes *any* change exceedingly time-consuming. Furthermore, a lot of these tests are just duplicates. Adding tests to every layer of a simple CRUD HTTP endpoint is a common example; in most apps it's fine to just rely on a single integration test. Stuff like SQL mocks is another great example. It makes code more complex, harder to change, all so we can say we added a "unit test" to `select * from foo where x=?`. The worst part is, *it doesn't even test anything* other than verifying you didn't typo an SQL query. As soon as the test starts doing anything useful, such as verifying that it actually returns the correct rows from the database, the Unit Test purists will start complaining that it's not a *True Unit Test*™ and that *You're Doing It Wrong*™. For most queries, the integration tests and/or manual tests are fine, and extensive SQL mocks are entirely superfluous (or even harmful). There are exceptions, of course; if you've got a lot of `if condition { q += "more sql" }` then adding SQL mocks to verify the correctness of that logic might be a good idea, and even in those cases a "non-unit unit test" (e.g. one that just accesses the database) may be a better option. Integration tests are also still an option. A lot of applications don't have those kind of complex queries anyway. One important reason for the focus on unit tests is to ensure test code runs *fast*. This, again, was a response to Java test harnesses that take a day to run. This, again, is not really a problem in Go. All integration tests I've written run in a reasonable amount of time (several seconds at most, usually faster). Go 1.10 testing cache makes it even less of a concern. The big problem with unit tests is that all units working correctly says exactly nothing about a program working correctly. A lot of logic errors won't be caught because the logic consists of several units working together. So you *need* integration tests anyway, and if the integration test duplicates half of your unit tests, then why bother with those unit tests? TDD, also, is just *one* tool. It works well for some problems; not so much for others. In particular, I think that "forced to write code in tiny units" can be terribly harmful for some code. Some code is just a serial script which says "do this, and then that, and then this". Splitting that up in 3 or 4 functions just so that your code is in "tiny units" can greatly reduce how easy the code is to understand, and thus harder to verify that it is correct (this goes back to the first point I made). I've had to fix some Ruby code where everything was in tiny units – TDD is strong in the Ruby community – and even though the entire logic should have been simple, I found it incredibly hard to understand anything. If everything is split in "tiny units" then understanding how everything fits together to create an actually runnable program that does something useful will be much harder. tl;dr: not everything is about testing.
unironically using the simple html view on gmail and i've never felt better
[removed]
It definitely does, I would have a problem if it didn't exist from the start...
Yes, correct. goreleaser doesn't have that functionality yet.
[removed]
Why the check for context.Done()? The write call to the response writer will throw an error when the other client closes their connection, right? Under “normal” circumstances, this looks right though. If the client goes belly up, the context will time out and you should bale here. I think...
How can `[2]` help me? 
It doesn't use any of `blackfriday.WithExtensions, blackfriday.WithRenderer, blackfriday.WithRefOverride`
I just looked at `main.go`, a couple comments, mostly convention. - Don't use `TIMEOUT = 30` and comment that it's in seconds, use `TIMEOUT = 30 * time.Second`. `time.Duration` is great. - Also, constants in Go are usually not all-caps. You can just call it `timeout`. - Rather than `createSSE`, the Go convention is `newSSE`. Or for things which are just data and "which" one they are doesn't matter - like `RequestModel` - the convention would be to call it `makeRequestModel` (if you needed a constructor.) - Don't name your return from `createSSE` and even if you're naming your return variable, *never* use bare returns like that. Just `return sse`. I know it exists as a feature, but it just makes problems easier to miss, especially with error returns. - You probably don't need `doesChannelExist`. `if _, ok := m[key]; !ok {` is common enough in Go that it's an idiom you'll expect readers to understand completely. Therefore, `doesChannelExist` obfuscates what's happening more than it explains it. - In the current form it's OK since it's a tiny program, but there's no way to stop SSE's goroutine. Leaking goroutines is pretty expensive. SSE should probably have a Close method. 
The usual DoS about reading the entire request body into memory without limit in the http handler. Also in the same vicinity you are indexing into the URL.Path string without checking whether the path is long enough. You are using http.CloseNotifier but you should be using Request.Context instead as CloseNotifier is deprecated. Didn't bother to check the actual logic, or deadlocks.
What's the purpose of the library? The readme isn't informative, but I'd love to contribute.
👋 would love contributions! It's for use in GitHub Actions, which you can read more about here --&gt; [https://github.com/features/actions](https://github.com/features/actions) &amp;#x200B; tl;dr workflow automation, this library is so you can run various Go cli commands as part of it.
What is worse is the error messages: if output != tt.expectedOutput { t.Fatal("unexpected output") } If the test fails, you have no information at all. What failed? What was the output? It's better to use: if out != tt.want { t.Errorf("wrong thingamabob\ngot: %v\nwant: %v", out, tt.want) } Which should give you enough information to debug the problem. I wrote a small [Go testing style guide](https://arp242.net/weblog/go-testing-style.html) a while ago which covers this, and some other issues. This post wasn't really about using the `testing` package, so I didn't really comment on that. But yeah, the usage of the `testing` library is sub-optimal in this post.
Oh this is very neat. Do you have beta access? I can't find any API docs, but I'm still waiting for access.
Docs --&gt; [https://developer.github.com/actions/](https://developer.github.com/actions/)
I'm on mobile and only looked a bit at the main program so far. But the first thing that jumps out at me are your pointer semantics around the SSE struct. Basically you are passing around a pointer to a struct of pointers. If a struct uses pointers and reference types internally, than having access to a copy of the struct gives access to the underlying data the struct's members point to. However working with a copy of the struct means that modifying its members, like changing where a member points to, will only affect that one copy. If on the other hand I'm passing around a pointer to the struct, then modifying the pointer or reference type, which could happen when appending to a slice for example, will modify that member for everyone with a pointer to the struct. I prefer to use pointer semantics as a way of communicating what gets shared and what doesn't. So I generally will pass around a concrete struct that has pointers and reference types as members. I'll initialize this in one place, and then pass it to any goroutines that need it. Ardents labs has some great blog posts about this. https://www.ardanlabs.com/blog/2017/06/design-philosophy-on-data-and-semantics.html
This is actually a bit of a tricky style of CI to pull off. You have to deal with a lot to automate in GitLab CI, dealing with SSHing into the droplet. So you have to ensure you have permission to SSH in non-interactively, but also prevent other people from SSHing in. I got it to work, but I found it much easier to do CD with Heroku first. Why not start with that to familiarize yourself? All you need to do is add steps in your GitLab CI config to push to the `master` branch on Heroku like usual. There's a few credentials you need to add to GitLab CI to give it permission to connect to Heroku to do the deploy. For Go, you can use their Go runtime, I believe they have support now.
Also stuck in waiting list ... so annoying!!
Digitalocean supports docker containers as well, which is a cleaner approach IMHO, and easier to incorporate in your CI. I usually work with CircleCI and GKE, but if you need someone to look over your stuff, let me know.
I do implement this project on RPI. and I’m not doing RSSI I’m doing Trilateration so the nanosecond time is matter to it
How about the execution speed. I’m talking about nanoseconds. I’m doing trilateration over wifi network. 
Looks nice. I'd recommend swapping from Dep to Go Modules, however.
My favorite type of DoS https://en.wikipedia.org/wiki/Slowloris_(computer_security)
I really wish typescript wasn't trending as much as it is. But I am happy go is doing well! 
While this is an interesting (clever?) way to do an iteration count: https://github.com/Agnius/go-sse/blob/master/message_test.go#L36, I would use a standard `i := 0; i &lt; ITERATIONS; i++` because that anonymous array's memory needs to be allocated (likely on the stack so it'll be pretty quick, but still). You can use an atomic value here: https://github.com/Agnius/go-sse/blob/master/message.go#L6, would be simpler than a mutex and is typically what you see for concurrent counters. See [`AddUint64`](https://golang.org/pkg/sync/atomic/#AddUint64), [`LoadUint64`](https://golang.org/pkg/sync/atomic/#LoadUint64), and [`StoreUint64`](https://golang.org/pkg/sync/atomic/#StoreUint64). Alternatively, [`go.uber.org/atomic.Uint64`](https://godoc.org/go.uber.org/atomic#Uint64) is pretty nice to work with.
[removed]
I think there must be something more to it, because this seems to work 'as intended' in firefox for me, but not in chrome whereas robpike.io does work in chrome.
Will this function kill scraping in the future? I make a request to this website, I can't get responses in scrapy 
Yes, with GOOS=linux GOARCH=mips, you can target lots of micro routers! We use go in production and it renders our offerings so far ahead of competition in terms of simplicity, it's not even funny. ARM support should give you beefier options too.
My project will implement on a RPI. Could you explain what kind of project are you using Golang? Does your project care about nanosecond delay?
ah I see, yeah I was confused with receiver and arguments. Thanks for letting me know.
Thank you so much for your answer. I will keep in mind of that rule of thumb!. 
First of all, if it works, it works, so be proud of yourself. :) &amp;#x200B; I usually reserve main for setups, reading configurations from environment variables, files or RPC, and put logic for graceful shutdown and SIGINTs in there. The actual server and business logic I either put in package internal (if it contains non-reusable code, globals etc.) or a specific library. onto your code: 1. Organize by domain. I see \`func main\` twice; put these in two separate directories. This will also make it easier if you start using containers. 2. Use a dedicated logger over print functions. I always go for zap ([https://github.com/uber-go/zap](https://github.com/uber-go/zap)). I don't mind the verbosity, it has served me very well. 3. No comments? I have no idea what is going on. :) 4. \`if m == true {\`? tisk tisk... You may simply use \`if m\`. m is also a terrible variable name, I thought it was your mux as specified on line 15? \` m := http.NewServeMux()\`. The lesson here is, don't shadow variable names. The compiler will allow it, but the reviewer won't.
Is redis used as a primary data store?
Try using reddit mobile web app
You could use a yaml tag and then convert the raw yaml to json
Can you make a User2 (hopefully with a better name) with the JSON mapping you want and just cover to that before marshalling? Or convert the User to a map[string]interface{} and marshall that?
https://attilaolah.eu/2014/09/10/json-and-struct-composition-in-go/
The tag is hardcoded, you can see it here: https://github.com/golang/go/blob/master/src/encoding/json/encode.go#L1116 However, if you make a type identical to the original type but with different tags, you can freely typecast between the two: https://play.golang.org/p/e77ve65IfbW If you are prepared to use non-standard libraries, https://github.com/json-iterator/go allows for customisable tag keys (see https://godoc.org/github.com/json-iterator/go#Config field "TagKey")
BTW, I've tried this with [`curl`](http://ports.su/net/curl), and it does buffering by default, so, you gotta use one of the following options to try to catch it in the act. * `curl -N robpike.io` * `curl --trace-ascii - --trace-time robpike.io`
That's how proper chats were implemented back in the day. You keep the HTTP connection of the HTML file open, sending the `&lt;!-- --&gt;` every few minutes if there's no activity (to preserve the connection), or the actual chat messages as HTML otherwise. Funny thing is that it actually worked faster than most of the JavaScript-style events and rending we have nowadays…
About two main func i build 2 seperate code, one is use gin for routing but then i realize that i need to know more about net/http std package therefore i built the second one using std library. Anyway is using switch/case a good way for routing ? The next point is package internal ? I don't understand it here, is that I have to put my handle into seperate folder and call it from import ?
Go itself will run on an rpi fine, as I said earlier. However, you may be in some trouble because Linux itself may not guarantee the performance you are asking for, regardless of implementation language. You can probably get very close, but if you can't tolerate any jitter it could be a problem. I'd try to test that issue ASAP in a prototype.
I think if I find the rough wasted time on the kernel, I minus off that from send and received time so I get it almost what I need. But I don’t know how to find or estimate the wasted time by kernel itself
FYI, that is referring to the `assert` statement that is available in many languages (python, c++, java, etc), and using them in production code instead of checking for valid states and returning an error. It is not referring to assertion libraries used in tests.
It seems that we agree that most of the time the test/subtest name is sufficient. It has been my experience that avoiding assertion library does not actually produce better error messages. The opportunity to write a good message is there either way. It seems that having people do more work to reproduce the same code of printing out the values of arguments does not actually encourage them to spend more time thinking about the error message. 
Try to read [this first for context](https://golang.org/doc/faq#testing_framework).
I guess you can, but you would be better of with language which is designed for such tasks. Like Rust. Go, unlike some people believe, I suppose based on it's syntax or similarity to C, is not systems level language. And doesn't carry it's performance nor it's level of control, common requirement for working close to metal.
It has been to my experience that using assertion libraries lowers the overall quality of the tests. Developers avoid thinking about what they are testing, they avoid thinking of what matters, they don't care about writing good messages (since they are optional) and they blindly assert everything as long as it increases the code coverage, which produces tests that are harder to work with. That's just me but there might be additional reasons why the Go team chooses [not to use](https://github.com/perkeep/perkeep) [assertion libraries](https://github.com/upspin/upspin).
Haven't had time to dig in yet but my immediate feedback is give a description in the readme. Maybe include sample calls or justification for why this library should be used over something else. 
How it is used is currently in `./example/main.go` (as stated in the README^^) - I didn't want to write an extensive README when I'm not sure about my API
That explains the HOW but more importantly WHY. Why did you develop this or what need does it fill, for you as an individual or a larger group?
This is cool man, but I'd take a look at logrus or the gokit logger or zap and see what kinds of things they provide. It's awesome that you made a library and you should keep working on it. Just think about what it provides besides being a wrapper for fmt.fprint If that's all it does there's no real incentive to use it. Libraries for the sake of dsl are generally bad imo. All in all keep making awesome things!
The filelogger does a bit more than just being a wrapper. I'm planning to add more features like adding timestamps or maybe log levels or something but I'm not sure what to add at all at this point. I need to think about it a bit more. Suggestions are of course always welcome.
But if you're gonna need to import external code, might as well use something better suited for this situation
How does one achieve webscale without MongoDB???
I don't think it would take that much to switch, would it?
If you depend on the interface instead of concrete dynamodb type then you can mock it out in your tests. 
So, just because the tool usage can be bad, it means that the tool itself is bad. I'm pretty sure that this is logical fallacy. I saw a lot of code that didn't use testify, but their error messaging was horrible (like %v not equal %v). I'm unconvinced that the fact that you can't enforce coding practices that you like is somehow an ecosystem problem. YMMV so I will stop here. 
This entire thread is bad. This is when I start to think that CoC is not a bad thing. To Author. Linking documentation is not enough. Good projects consists from motivation, examples, drawbacks and comparisons with other tools. Writing this is hard, I agree but then I don't have to trust you word that your library is doing something better, but I can see it with my own eyes. Add more info to the Readme - it will certainly help. 
It's about the culture and expectations that the tool brings. Oh really? Then let's throw away gofmt and depend on enforcing coding practices since it's so trivial.
The fact that you use "reductio ad absurdum" is enough for me to stop arguing. Have a nice day. 
Likewise. I didn't like how you ignored all my arguments. This is not a productive discussion. Goodbye.
I don’t know man. Some of these methods are one-liners to the standard library. It’s easier to just make the call myself. Colorable consoles, in my experience, are not all created equal. There are libraries to make color font work on many different consoles. I have my own wrappers set up for coloring, log-level, structured formatting, dates, etc set up around a combination of logrus and grpclog, with all the command line flags I might need at runtime. 
probably most crawlers will explode on non ascii string :D 
So tldr; no a good idea to write such a library in your opinion?
I wouldn’t use it in its current state. But you should keep writing it if want to. 
Is this how video streaming works?
I didn't know test logging during execution was planned, that's really good to hear!
Dep, at this time, is no longer maintained for it's original purpose
many, one of them i remember is https://github.com/apex/apex 
While this question is a bit broad, advice that I can give in the most basic 'get it done' sense would be to: - setup the VPS manually so that you are aware of the steps required to do a complete setup of dependencies and apps + startup - extract those steps into a script, and then validate the install based on the script execution. - have the CI tool execute the script via ssh (you can setup the droplet such that a public ssh key can be added upon setup) Again, this just advice that outlines a barebones process of deployment, without any configuration tools or other technologies like Docker, etc, but if I was in your situation, this is exactly what I'd do. Would appreciate any caveats or other advice if anyone else has any, just for my edification. Good luck!
I would like some benchmarks there
Interesting! Grain of salt advice: - place your infrastructure stuff like the Dockerfile or Docker compose + configs in an infrastructure folder or something like that; you already divide files in directories. - Go Modules will be standard in Go 1.12 so it'd be nice to upgrade to that from dep.
I demonstrate TLS and SSH based auth here. [https://github.com/glycerine/grpc-demo](https://github.com/glycerine/grpc-demo)
You can not use any other tag with the standard "encoding/json" library. From there you have 2 solutions: - find a non standard (including coding it) lib - modify your code's behavior You could for example do type User struct { FirstName string `json:"first_name"` FName string `json:"f_name"` }
I didn't know about Github Actions at all until this post, very interesting! I'm stuck in the waitlist, unfortunately.
instruction :) ``` git clone git@github.com:hbakhtiyor/strsim.git &amp;&amp; cd strsim go test -v --bench . --benchmem ```
just did it yesterday for something i’m working on: - move project out of `GOPATH` - cd to project - `go mod init`github.com/username/project - `go mod tidy` - `rm -rf vendor Gopkg,toml Gopkg.lock` - `go mod vendor` 
Heads up, VS Code with its extensions is amazing for Python.
I prefer PyCharm :)
Nice read. Should really look into pprof. 
I’m viewing this from a mobile device and can’t run them til today in the afternoon Why don’t you include them in the readme?
I'm really missing the "why" of this library. You state it's made for simplicity, but I'm not seeing what's simpler about it when comparing to other loggers like logrus. Logrus also has a "hook" that allows you to log to a file, so there's currently no reason to choose your library over logrus. That put aside, are you sure your file logger is OK? For every print statement you're opening the file again and closing it. I'm not sure if that's great performance-wise if you want to log a lot of line per second. Regarding your API spec itself, it might be best to follow the Go logger just like logrus did. This makes it far easier for people to use your logger as a replacement of the Go logger or logrus. That is to say though, if your logger offers substantial benefits over their counterparts. You can break from this std API of course, like zap or zerolog did. Those offer significant benefits that make it worthwhile though. So that would be something you need to think about when creating this library.
I'm also on mobile and wish some benchmarks had been added to the readme.
if you mean benchmark with another algorithms, i don't have if the implementations itself, i think no sense to include in readme
Google.com
Yes, this is one example why Go is not completely magic-free.
If you think software development is about rote memorization of languages, rather than understanding the concepts behind them, you won't have much job security anyway. Anyway: Golang is a young language that's still finding its niche(s), so it's natural that you won't find golang-*only* jobs outside big companies just yet; smaller businesses aren't churning out enough code to warrant having dedicated positions just for that, even if they are using golang. That doesn't mean it's not worth investing time in it, or in half a dozen other languages that are also useful. 
I think if you enjoy composition over inheritance, Rust is definitely worth looking at. 
go test -v --bench . --benchmem Execute this and add the result to your readme 
Rust and D spring to mind instantly.
I saw the two separate approaches. :) A switch case will work for a couple of routes, but you definitely want a dedicated router. &amp;#x200B; If you name a directory "internal", only sibling or parent packages may import from there. You use this if you do not want your code to be imported. If you can reuse the code, put it in a differently named package, and import it in your main. 
No
&gt; Is Go just for businesses that are big? No. Go is a general programming language and well suited to to small projects, tools or services. In any organization. &gt; Came across this today. https://www.quora.com/Why-are-fewer-developers-using-Golang/answer/Sandra-Parker-34?ch=2&amp;share=f73e86ad&amp;srid=5vxF9 Some random Mrs. Parker recycles second hand arguments she heard of. &gt; I understand Go was made by the frustration of scaling but is it wise to spend my free time on it for job security? Go takes 3 weeks to learn and 12 to master. Take a look around: In which language will you productive after that little amount of time spent? Take the Go numbers in months just to get your build tooling straight and expect a year to learn some web framework (and then hope this one will be used in your next company). Note that "frustration of scaling" as you use it does not adequately describe the ideas behind Go's design. Go does a lot of things to speed up build times and make incremental builds easy but I see its main benefit more in a clear focus of understandability and non-cleverness. All this allows to scale e.g. teams. Go is about writing working, failsafe software fast. 
I know Rust is getting popular, I gotta look into D spring.
If you need a popular language, D might not be the best choice. But it's definately worth checking out because what it is.
&gt; I went to a staffing agency in Chicago and they never even heard of it. Well, there is your problem. I bet there are at least a few Go positions available in the Chicago area.
No it is not just for big businesses. It is not the most popular language in the world, but also there are not as many Go developers fighting for those Go jobs. But mostly I would advise you to get really good at programming, via focused practice, and exploration. Learn a few languages. Don't focus on just one. Many companies, especially for junior positions, are just looking for good programmers and don't care what languages you know at the moment. 
We mean that it would be helpful for you to add benchmark results to the readme, so that those of us who don't have immediate access to the `go` tool (and are therefore unable to run the benchmarks directly) are still able to get more information about the package.
&gt; Some random Mrs. Parker recycles second hand arguments she heard of. Oh, no, she's not someone random. She's working for an *outsourcing agency*. I assume she's competent at that, she seems to perfectly understands how moronic middle management thinks. (Read: Her main customers.)
Small startup in the midwest here. We use go for all of our micro services. 
What are your thoughts on C++ as a good second language from Go? 
"is it wise to spend my free time on it for job security? I see almost no Jr level positions in it in the Midwest." Gonna cover this question separately from the question of Go. First, I'm writing this from the Midwest myself, so this isn't just some SV guy bloviating about a situation they don't really understand. In your position, you want to balance two things: What the current careers are calling for right now, and the things you want to work on in the future. You don't want to get too stuck on exactly what the job listings are calling for right now, because that's how you become A Java Guy (TM), which is to say, someone who knows one language, exactly one language, and no other language. It works great in the short term, but in the long term becomes a problem. You will also want to be picking up some skills in areas you want to work in. If you prefer to work in Go, be sure to pick it up, and keep your eyes out even if you can't find a position today. That said, I would generally recommend against going to certain positions because of the language they use. The culture of the position is much more important. There's a couple of languages I just can't bring myself to use (Java and C++, which of course have to be languages \#1 and \#2... sigh), but for the most part it's the culture I'm looking at. Specific to Go, you'll also find if you ask around at interviews, and put Go on your resume, that while there are not necessarily a lot of listings specifically for it right now, there's a lot of places that are either using it internally, or seriously considering using it internally, even if they aren't hiring for it specifically, and it can still be a head-turner that can get you out of the slush pile. Plus, right now, learning Go still _generally_ means you are self-educating, which is always something I'm looking for on junior resumes. Personally, when hiring from the local universities, I basically discard all claimed experience in languages that I know the university uses, unless there is specific evidence they've gone far beyond what the university mandates, because the simple truth is that if your only experience in, say, Python is your classwork, you don't know Python much better than someone who spent 4-8 hours working through a good tutorial. I like to see evidence that you've done more than that, and Go can show that. So even if you don't get "A Go Job (TM)", having Go experience absolutely can be the thing that gets you into a _good_ C# job rather than a crappy one. Finally, one nice thing about Go is that it is low commitment on your free time. You can learn it fairly quickly. So it's a good bang-for-the-buck on this front. (I sympathize with the "I shouldn't have to do stuff outside of work to get a job", but if you want the _best_ jobs as a junior, yeah, you pretty much do. The good news is that eventually you can stop that, I've found.)
If you're looking to expand your horizons, you should be picking something _not_ related to Go. C is a decent thing even so due to its ubiquity. However at this juncture my advice would be to get to the point you can read it and maybe apply spot-fixes to a C program, but unless you've got a hot job you need it for or you're going into embedded systems, I would _not_ focus on learning how to create real systems in it. There's a _looooot_ more to writing real C systems than just knowing C, and most of it is dealing with C's crap, not useful information about how to create real systems. You can get to the useful "creating real systems" far more quickly in... well... almost literally any other language. (Again, excepting embedded systems.) If you have not yet learned any of these, I'd recommend learning them first: * "Real" SQL, i.e., not just "a select statement", but joining tables, normalizing, working with a data set large enough to need properly indexed and optimized queries, etc. * Quality shell scripting in your local shell language (Bash, powershell, etc.) * How to write a basic compiler, or at least a basic interpreter. (If you're feeling saucy this can be combined with picking up a new language at the same time.) If you do want a general purpose language, Rust is a decent choice. Haskell is the choice if you really want to expand your brain, but it's a bit of a commitment to get to that point for most people. Anything that says "Lisp" on it is another, though I think that's a lot less mind-blowing than it used to be since so many languages have absorbed so many features from it. Still, it's got some interesting perspectives. For yet another direction, assembly language.
The name glog is already used by a google logging implementation
I think it depends a lot of your goals. With one word I'd describe C++ as your second language would be "ambitious". It'll take time and you will learn a lot. It's easy to do half-assed too, but if you wanna go with half-assed, you could pick an easier target (Say Java or C# that are very "employable" languages). Then again if the main purpose is learning, maybe dabble with something that is on purpose more away from Go, say functional languages or scripting stuff. You definately should do this dabbling to some extent, learn to learn languages. Maybe do it before starting C++, which is no small feat by any measure.
Wow, thank you. After what the staffing agency told me I felt kinda crushed. Yesterday I picked up nodejs just for this reason. All I was doing was trying to see similarities cause I've studying go for two years. But I have a feeling you are right cause the staffing agency tried to pull me in with a big name but then when I went in... It turned into a bunch of 4 letter acronym jobs. I kinda knew then they were just trying to lurer. But it just is hard when I'm just a support guy for 4 years and I spent 2 years on side projects and I figured when the rubber meets the road businesses only care about on the job experience but I think your explanation makes more sense. Sorry but navigating opinions has been a life changer and a curse. Thank you!!
If you'd asked big business in the 90's what they wanted, they'd have told you they needed COBOL programmers
Thank you. But the whole senior level thing is kinda holding me back cause I'm no senior level. Not even intermediate. 
What paradigms were they looking for when hiring? 
I know you're looking for something similar to Go but to expand horizons it's best to try different things. Some suggestions: Haskell, Elixir, Rust, Clojure.
Why exactly is Dice's coefficient better than Levenstein for string similarity? It seems like an odd comparison, especially since its just the F1 score and is more akin to the Jaccard Distance. Dice's coefficient isn't a true metric, so it immediately loses to Levenstein and Jaccard which are, and thus preserve various nice properties when working with embeddings. Also I believe you should make it apparent in the readme that you are doing bigrams for your comparison. 
Yup! Check out the issue: https://github.com/golang/go/issues/24929
Staffing agencies in the DC area typically do not know the difference between Java and JavaScript so I wouldn't give their knowledge any weight when it comes to your career decisions.
[removed]
added
No particular paradigms. Full disclosure, I am the hiring manager. &amp;#x200B; What I look for is the ability to learn and understand things quickly. If I throw a new technology in front of you, how quickly can you use the resources provided (sometimes not provided) to get up to speed with what's going on. (Documentation, Google, Documentation, YouTube, Documentation) See what I'm getting at? I look for soft skills. How well can you interact with stakeholders/team members. Can you accept criticism without blowing your top? What does your tooling look like? Do you have a desire to automate to make your life easier? I don't particularly care about what tools you use, or how you choose to automate. Just that you do it, and have a drive to make your life easier. You should want to learn. At the end of the day, Go is not a complex language. I want you to be able to speak confidently about what the pros/cons of the language are, but more importantly I want you to understand it's part in the entire ecosystem of software. Understand version control and why you use it. Understand what a CI pipeline should be used for. Understand what different environments are. A significant portion of questions that pop up on this sub are "How do I become a go developer?" Instead, focus on how you become a software engineer. What makes a great woodworker? Someone who understands how to use different tools, and how to decide which tool to accomplish what task. (I love woodworking.) The biggest drawback of woodworking is the amount of time you have to dedicate to accomplish certain things. Your tools can only do so much without significant capital investment. However, software development tools are almost infinitely extensible. Utilizing your tools properly can be the difference between a 3 minute iteration loop, versus a 3 second iteration loop. &amp;#x200B; Also. Tests. Test everything that make sense to test. Please. 
I work in a government service with 50 employees. Some of us use go because it solves our problems, so, no, it's not a big business only language.
&gt; After what the staffing agency told me I felt kinda crushed. Yeah, they, uh, aren't exactly motivated to give you the info you need to navigate the job world on your own. In your position, you may also need to take a less-than-optimal job right now to build bona fides. But it can be a stepping stone, not the end result. The big thing you're looking for is making sure you come away from this job with the ability to tell your next interviewers "While I was in this position, I accomplished this goal which improved the business in this specific way", with a clear explanation as to either how you did it more-or-less yourself, or in a team with a clear role. (I've done a lot of interviews lately where the interviewee talks about what "we" did but was rather vague on what _they specifically_ did.) Fortunately, this is one of those too-rare times where your goals and your employer's goals align; if they've got half-a-brain, they too ought to want your work to have a clear explanation as to how it helped the business. 
Thank you for your extensive feedback. I will have a look at logrus soonish an see what I can take away from it.
updated &gt; Also I believe you should make it apparent in the readme that you are doing bigrams for your comparison. but the algorithm already explained in wiki
I work at a company with 5 backend developers, and our primary backend language is Go, powering the vast majority of our services. We're not as startup as such, just a small ish company.
Excellent post, I will take your advice.
Good point, makes complete sense,
LOL COBOL!! I remember the insanity about the Y2K virus and Cobol as some large companies were still using it. Oh Y2K how you employed sooo many!
Definitely agree with Haskell. It will make you think about programming in any language totally differently way
Yes it is used for storage of clients and channels
&gt; Y2K virus 
Why the heck are so many people down-voting this? Just curious. Building apps in HTML and CSS is very cross-platform and standardized.
Thanks bud - y2K bug :)
Go is a bit of an odd duck in the pond - as most other languages in current use are very traditional Object Oriented, where Go take a more novel approach. So I'd get some solid experience using say Python or C#. Both quite popular, and both quite easy to get started with. Syntax is the easy part, getting to grips with the underlying principles is the hard part.
Thank you for the advice and i will switch indeed since it is the initial release, Lots of feature will come &amp;#x200B;
Go is a tool. Master your Algorithms, Data structures and CS fundamentals. No one cares what languages you are expert in. Companies which hires based on tools are generally poor companies IMO with no intention to invest in their employees.
Regarding the job market, many companies that would tend to fit in the Go mindshare space are doing Node (I would argue there are many more Node jobs). Learning Typescript is something on my radar since so many fun and interesting projects are written on the backend (and front end) with it. Plain JavaScript is also worth learning, but after being indoctrinated as a type safety developer you will probably feel more at home with Typescript. Also, now Go can compile to WebASM which means there are more reasons to learn JavaScript to integrate with these new capabilities in the browser.
The similarity measure is based on sets. The creation of your set is done via bigrams, but could easily be done with trigrams. The wiki just uses bigrams as illustrative example. 
The analogy I like to use here is thus: You don't find jobs for "screwdriver expert" or "hammer specialist" so much as you do "electrician" or "carpenter". Using a tool is essential to your job, but first you need to know why you're using it, and what your finished product should look like.
That's quite impressive. The most surprising part is the contention on a read-lock: I thought locking for reads should be (almost) free.
Here is a go playground example of casting between types: [https://play.golang.org/p/mMVh\_v74tck](https://play.golang.org/p/mMVh_v74tck)
If you're calling it a billion times, it can matter. And it seems it has some performance issues: https://github.com/golang/go/issues/17973
I work in Chicago, my last job the team I was on used Go for everything backend (5000 person company) my current job also uses Go on a subset of teams (75 person company) I know of a good chunk of Chicago based companies that are very Go focused, it sounds like your staffing team just doesn't know what they are talking about.
Yep, I've seen it all now.
`multipart/form-data` is exactly for that. It won't get lost. Just give it a try 😉
To make this question make more sense... The "Go" in Google Maps Go and YouTube Go does not reference golang at all. The Go moniker is appended to certain versions of some Google built Android apps, indicating these apps are lighter versions of the originals, which you can take "on the go".
&gt; All this allows to scale e.g. teams. It also eases code reviews a lot. 
I'd recommend to embark on Erlang instead of Haskell if this would be the OP's first encounter with the functional programming paradigm. Erlang is ridiculously easy to pick up (just get the Armstrong's book and follow it) and experiment with. There's no question about Haskell being "more real" FP language (sure, many take it to be _the_ FP language) but its learning curve has a steep wall not too far beyond the starting point of the journey. 
This is excellent work and a great demonstration of how to debug Go programs. Thanks for writing this up!
Plz read this https://golang.org/doc/faq#closures_and_goroutines
Jonathan Blow´s JAI language might be released to the public this year. It has a nice mix of features which I think will make it relevant for more than making games. I think a lot of people who like Go will also like JAI. You can for instance declare an array with structs and indicate if you want the memory layout to be a struct of arrays or array of structs. It does not have garbage collection. :-) [https://inductive.no/jai/](https://inductive.no/jai/) &amp;#x200B; &amp;#x200B;
Golang is very much its own thing with regards to its paradigms. Every other language I know is different in some fundamental property of its paradigm in one way or another, most either because they don't have explicit pointers (almost all managed languages) or because they aren't managed languages (almost all languages with pointers). Perhaps Go's predecessor, Limbo, might be of interest.
I work for a 20 year old company outside of Denver, about 400 ppl, and we're using quite a bit of it
I think a better way of saying it is Go solves some of the problems big businesses have, but that doesn't take away from it being useful for small businesses.
Thanks for the feedback! I will surely consider it. Especially the almost-stuttering "New..." is something that annoyed me myself.
that Logger in your project looks like it’s begging to be refactored DRY but I just glanced - also the steps above may be out of order - report back if I was wrong because I’ll need to do this again for other projects of course
Thanks! I couldn't put two and two together and figure out that interfaces were involved.
why aren’t you using Mongo (just curious) and possibly RabbitMQ
&gt;"hammer specialist" BRB, just updating my current role on LinkedIn.
This probably isn't the best sub to ask about this on. As I understand it, you can do machine learning tasks in Go, but it's usually done almost exclusively in Python and R. I'd try reading through posts in r/datascience too. If you're asking specifically about doing machine learning in Go, you should edit your post.
Though they're not similar in terms of syntax, the Pascal series of languages are similar to Go. Though learning pascal itself is useless these days learning one its descendents like Modula or Ada might be worthwhile. 
Why use Mongo and RabbitMQ? Redis is very fast, it's a single operational dependency (one daemon to manage vs two, one config file vs many), and the configuration a fair bit simpler.
I can't argue with that. My path to Haskell passed through Erlang and it definitely made Haskell an easier task. Instead of being hit with 15 unfamiliar things at once, I was hit with only 6 or 7, which is more important than it sounds since "the things I don't understand" tend to compound on each other.
In the end, what matters is that the code does what you need it to do. If the only effect of a given error is that it is going to be logged, and nothing else needs to deal with it, then it's OK to just log it and return no error. It is certainly true that it is easier to deal with functions that don't have a separate error return. (At least until the error handling proposal goes in to "Go 2", as I hope it will, which would actually smooth over some of the issues there.) My advice, though, is to be on "high alert" for cases where it ceases to be adequate, and to switch to "return an error" at the drop of a hat. If you have any question at all, switch the error return and ensure that all callers handle it appropriately. If that means errors get threaded through multiple call stack levels, take the pain; you put your chips down and you lost. It happens. Hopefully you win enough elsewhere to make up for it. I do operate like this sometimes, so I do think it can be made to work. But I will say I had to be bitten many times by this sort of issue before I finally took the advice I'm giving now. :)
Assuming you are talking about the concepts in general and not specific to Go I would recommend [https://www.tensorflow.org/tutorials/](https://www.tensorflow.org/tutorials/) &amp;#x200B; It has a library for C, Python, Java, JS, Swift, and Go although the go one is for some reason or another not covered by the stability guarantee of the others
Thanks, and yep that's what I'm doing in part. In some areas, the errors bubbles up and it's a pita to deal with, but here, it's a 50-50 type of thing. As it stands I'm happy with where it is though (software can never be 'perfect') so I'll leave it for now and get some real-world usage experience with it.
\`import ( "fmt" "encoding/hex" "image/color" ) &amp;#x200B; func main() { fmt.Println("Hello, playground") c := color.NRGBA{255, 24, 35, 255} colr := \[\]byte{c.R, c.G, c.B, c.A} fmt.Println("#" + hex.EncodeToString(colr)) } \`
it gives you the rgb... converting from that to a hex string value is just a call to fmt.Sprintf? fmt.Sprintf("#%02x%02x%02x", r, g, b) https://play.golang.org/p/WNPOImsYw1A
If you're looking to not spend money, I recommend the fast.ai series: https://course.fast.ai/ I also took Andrew Ng's coursera class, which I enjoyed, but had to pay money for. I thought it was worth it. These are a good foundation for learning but will get you nowhere in terms of getting a job.
I'm afraid this not how RGB to hex works, but thank you for your answer. I do have to say I can't understand why one wouldn't want a \`toHex\` function for color though.
Note that "hex value of a color" isn't well-defined as far as the color-definition of the color-package you're referring to. Traditionally, hex-color-strings (specifically as used in CSS) only represent 24bit RGB colors. So a e.g. a [color.CMYK](https://golang.org/pkg/image/color/#CMYK) isn't really meaningfully represented by a hex-string in CSS. You *can* convert any [Color into RGBA](https://golang.org/pkg/image/color/#Color), but that process is, in general, lossy and will result in 16 bit per channel (so you lose even more precision) and still leaves you with an extra alpha-channel not represented in the hex-string. The problem is that "hex-value" really is an application defined concept - so it makes sense for an application to define that itself. That being said, the closest you'll probably get is // hexColor returns an HTML hex-representation of c. The alpha channel is dropped // and precision is truncated to 8 bits per channel func hexColor(c color.Color) string { rgba := color.RGBAModel.Convert(c).(color.RGBA) return fmt.Sprintf("#%.2x%.2x%.2x", rgba.R, rgba.G, rgba.B) } IMO, given the specificity of this function, it's fine having to write it yourself.
I'm considering releasing a new, refreshed version of the project, so feel free to post here ideas or feature requests. Thanks!
I was hoping for something like [AutoHotkey](https://www.autohotkey.com/), but it's just a library.
I'd encourage you to read the position description for "all these machine learning jobs" to see exactly what is expected of incoming candidates. When I was in university for my master's degree, I found that machine learning courses were only being taught at the PhD level... though open to grad students with sufficient mathematical backgrounds, including linear algebra, Bayesian statistics, and neural networks. If you're interested, the text used in the machine learning course I took is "Pattern Classification" by Duda, Hart and Stork. 
Please no password in plaintext in a config file Never 
No README.md No unit tests Fix those before asking for a review, pls.
The project is not finished yet. I asked at the beginning of the development for help because of the project structure. Thanks anyway
Read your post after I found the solution and edited mine, thanks anyway !
Makes sens, thanks for the clarifications !
Look into R and rstudio as well. 
Actually i use golang routines and channels as message broker (Same as rabbitMQ) so using rabbitmq not an option here since golang can do the same and it is very fast. Second thing mongo as storage and not redis i think this also not an option since redis is very fast and that is also required. I was thinking about adding hooks to allow second storage for history messages. &amp;#x200B;
This is cross-platform, and it is constantly improving. Welcome to contribute code.
Not sure why logger not that good, but i would like know exactly what you mean? 
"A Real Time Messaging Server" Could you expand on this a bit? Why would I choose this over NATS, googollee/go-socket.io, or plain gorilla/websocket + redis?
[removed]
Also a nice tool on OSX only is Hammerspoon.org, a lua bridge for the Accessibility Frameworks and other frameworks. Worth checking out
You will have to reinvent the wheel and build another beaver with all the stuff you said :D! How can you use only websocket or even plain gorilla/websocket + redis to build a service where you can define private channels and presence channels and has the other features like message delivery to clients subscribed to specific channel or broadcasting? So we built that using gorilla and redis and some other stuff and now it can be used on your project easily &amp;#x200B;
Looks useful 👍
It’s D, not D spring
\&gt; The project is not finished yet Adding unit tests at the end of the project is more likely to make your life much harder. Some people even prefer to write the tests before writing the code. \&gt; because of the project structure Title says "code review". That's what I did. You get what you pay for...
Why are you only looking at individual languages? Methodologies help you become a better programmer in all languages: how to design a system, how to test it, how to deploy it, etc. Will get you a lot further in terms of professional development, than just learning another tool.
You should check out Siraj Raval on youtube and github
Just reading the examples in the readme it seems like it would be pretty straight forward to implement AHK type things (press &lt;key combination&gt; do &lt;thing&gt;), while writing normal golang. You would have to implement something with this library that implemented a dsl of some kind to I suppose replace AHK though.
I highly encourage you to consider renaming it to "MrRobotgo"
どういたしまして in advance.
So this is like socket.io + persistent storage? 
Interesting advice, lol.
Welcome to try and feedback.
I've really liked the courses at datacamp.com. They're in Python, R and SQL, not Go, however
[removed]
I've spent a little bit of time with Elm, and it might be a nicer way to get a lot of the benefit of learning a pure FP language like Haskell without as much of the pain. Its type system is richer than Go's, without having the extremes of Haskell. Its syntax is Haskell-like but with more modern conventions. It's somewhat restricted to writing web frontends, which is a shame, but as a learning exercise it seems worthwhile. It just doesn't have as much learning material available, but at least it doesn't have as much _outdated_ material.
&gt;Also Go binaries ship with a copy of the go machine which adds a lot of size overhead. Additionally this go machine step also slows down execution. You mean the Go runtime. It is not a virtual machine, there is no interpreter. It doesn't universally slow down execution, just some things. For example, here is a 4-year-old post where a novice got within [50% of nginx performance](https://www.reddit.com/r/golang/comments/28so0e/go_networking_performance_vs_nginx/) with trivially simple code. (Go has gotten much faster since then, and nginx uses a lot of hard-to-understand tricks to get it's performance.) 
&gt; I don’t know how to find or estimate the wasted time by kernel itself Nope. It's not constant. In addition to many other things, Linux will actually [switch from interrupt mode to polling mode](https://en.wikipedia.org/wiki/New_API) depending on network traffic. That will introduce latencies. You might need a full RTOS. The Go rountime isn't real-time either. On the other hand, the simplest way to solve your problem is to break off the realtime parts into dedicated hardware such as an ESP8266.
New API (also referred to as NAPI) is an interface to use interrupt mitigation techniques for networking devices in the Linux kernel. Such an approach is intended to reduce the overhead of packet receiving. The idea is to defer incoming message handling until there is a sufficient amount of them so that it is worth handling them all at once.
all the methods do the same exact thing
Thanks for this. I am wondering if there's a way to implement a shared state machine system, across these "multi-group" raft clusters. &amp;#x200B; Is is possible to process client requests targeted to a particular group identified by its "Group ID" and have that log entry synchronized with other raft clusters in a controlled latency?
That’s awesome. Thanks for sharing the wifi microchip with me. 
That’s awesome. Thanks for sharing the wifi microchip with me. 
[removed]
Bad bot. Stop stealing from Wikipedia without attribution.
Although Badger is a promising candidate ([https://github.com/dgraph-io/badger#comparisons](https://github.com/dgraph-io/badger#comparisons)) , I would like to understand if support for Hashicorp's Consul KV store makes sense..?
[removed]
[removed]
I'm curious, is there a library in another language that privides this functionality that you've used in the past? 
[removed]
Sounds like you want to use the new go modules. Here are some good resources I know of. https://www.youtube.com/watch?v=aeF3l-zmPsY https://roberto.selbach.ca/intro-to-go-modules/
personally I prefer Da Spring
Your terminology is a bit foreign to me... but it sounds like you have multiple interconnected or tightly coupled applications. If this is the case (one project of related apps), then a single repo with shared packages (libraries), and multiple apps/commands (target executables) would probably be the best. In Go, this is usually organized using `/pkg`/`/internal` for packages (libraries), `/cmd` for apps (targets), and `/vendor` for your dependencies (if you want to commit them to your repo). You’ll probably want to use modules or `dep` to manage your dependencies. `pkg` is for packages that are possibly usable in other projects, `internal` is for packages that should not be used by other projects. [This repo](https://github.com/golang-standards/project-layout) is a great example / documentation for good project layout. The README has good explanations and references. Check it out. If these are standalone or loosely coupled projects, they would normally each have their own repo, with their own dependency management and project layout.
Is this just copied from x/crypto/nacl? Wtf
Also! Read [How to Write Go Code](https://golang.org/doc/code.html). It will go over some key things like this.
No point because Microsoft bought it. I’ve extract all my repos to GitLab 
You're right, the other millions of users and projects on github don't matter as long as you left... /s
What are the differences with https://godoc.org/golang.org/x/crypto/nacl ? I've used that one with success and it seemed relatively ergonomic.
LOL. They should be ocncoder. Some people just care about comfort zone nothing else
You cannot have a toHex function because any single such function would not do what you want in 80% of the cases. A function like toHex that "works" on 8bit, 16bit, paletted, RGBA, HSV, CMYK , YUV, YCbCr, with alpha, without, etc, pp. is simply not doable. Color is _much_ more complicated than you think.
By the way, you can still stay there 👍🏼
Great news. I just moved all my Bitbucket repos to GitHub. I'm very happy!
I also get nostalgic about all the Microsoft hate but let’s be real here. GitHub is great and if you don’t like the product, then you switch. But unless Microsoft does something bad with Github, I’m staying there. The platform is good and the ecosystem works well with most OSS hosted there. Microsoft also released VSCode and I use it because it works great for me. I use Linux as my Desktop because, again, it works for me.
Well congrats to Microsoft to release one thing opensource after years still people’s money to provide them backdoor/malicious software(windows). Also who knows what the hell Microsoft planning to do. Experience and history shows what ever Microsoft owns just ruined it. LinkedIn, Skype etc. GitHub will be the next 
Why do they offer free private repos? Is it to get more users, that can be monetized and vendor-locked-in later? Will they ever charge for private repos when people have so many that it's too hard to switch? What is their long term plan here?
uuuuuuuuh... that's not how git works
If you are looking for a Go specific resource, the book Machine Learning With Go from [Daniel Whitenack](https://datadan.io/) might be for you.
nobody knows..
That is the goal, to kill off opponents before becoming monopoly.
Back doors? Are we still whinging about the NSA_KEY misunderstanding of the 1990s? Come the hell on. 
Money is to be made in the enterprise. Get Deva using your stuff and that's what will be used at work. Suddenly your business is forking over 100k in licensing. It's a solid business plan.
Oh is windows 8 and 10 for 1990s? I didn’t know. My bad 
Closely related in the same class (compiled, no runtime, typed) would be Rust and Swift. &amp;#x200B; But as others have said, make sure you try out different paradigms. My favorite functional language is ELM. (It has the best compiler errors.)
Do you know Microsoft has more contributions to the linux kernel than Canonical, the company which owns Ubuntu?
Your attitude is 1990s. There are enough actual problems with Windows without making up any conspiracy theories. 
Ubuntu is not counted into the real linux distros. Let’s talk about debian, red hat. Generally Talk about originals not children :) 
I don’t remember we know each other, how you can judge my attitude? Well the truth is : Technology growth == people’s ignorance growth Out of anyone’s control. Good job guys to support most crappy company even on the planet. Use it. Don’t get out of your comfort zone. 
If you start defining what's real and what's not, then I don't have anything to say.
🙄
Good news, but Go related?
Too little, too late, moved to gitlab and never looked back. They have the whole devops thing going on and a code first e2e platform for maintaining and tracking all your changes. Plus it’s free for private repos
This is something I have been looking for, great work!
Only upto 3 collaborators though
I agree, especially as Erlang has an even better concurrency model than Go. Elm is a pretty good functional language for beginners, too.
C++ is a very hard language, probably the hardest popular language, by far. It is very popular, too. It might be a good choice, if you are ready to try to teach yourself a big language.
That is still not bad though for people who want to start working on personal projects and keep it private until they decide to open source it or move it to a commercial setting.
I frequently use Vegeta [1] for stress testing _(written in Go)_. And LightHouse, by Google, for web performance _(written in Node.js)_. You could also make use of any Go client to communicate with Pingdom API [3]. [1] https://github.com/tsenart/vegeta [2] https://github.com/GoogleChrome/lighthouse [3] https://www.pingdom.com/resources/api/
Yeah, who wants to type all that? I just call them b, u and c!
Redis has pubsub which you can easily use for broadcasting. For worker queues you can use redis list with BLPOP.
I don't visit /r/programming every day (but agree that this news is hard to miss from \*some\* source)
Yes, I think that I explained myself on the wrong way. Thanks for advice about testing!
[removed]
but still you need to use all of the (Redis + websocket + Native PubSub like go routines and channels) in order to build a realtime server used for chat apps for example
logging with different level is not the same thing, creating the log file can be on a separate method i agree
&gt; Will "import path MUST be (publicly) resolvable URL" restriction go away? No. And you know why? Because that restriction literally never existed in the first place. All your wishes are already doable with a replace directive in a you go.mod.
The article suggests that having completely unrelated packages depend on common code is indicative of a design flaw, which from my experience really isn't necessarily the case. Then it goes on to say that duplicating the same piece of code in multiple places is preferable to just writing it once, with proper tests, in a separate package, but never explains why.
Package names like these are bad because the names don't describe what their members are, the names describe what they *aren't*. The members aren't related to `User` or `Network` or whatever actual packages you have, so they get chucked in `util` along with a bunch of other unrelated code. 
Start slow. Try to understand and implement easy algorithms first. Like, naive bayesian classification, decision trees, linear regression, k-means clustering, then random forests, logistic regression. Those are relatively easy to understand and implement, but don't get into thinking they are inefficient or deprecated. They can help you solve tons of real-life problems. Random forests are really cool : easy to implement, easy to understand, pretty efficient, no tuning required, and very decent classification results in lots of real-world problems. Naive bayes is shockingly efficient and easy to implement, and produces decent classification results, but fails miserably in some cases. Linear / logistic regression are so old and tried and tested that it would be a sin not to try to understand them, and of all these easy techniques, they are the closest ones to neural networks (numeric data only, gradient descent techniques, etc.) Then, and only then, get into more complicated stuff : neural networks, SVMs, gradient boosting, etc. Those are the cool, new kids on the block, these are the techniques that work really well if you have tons and tons of data and processing power : alphago, self-driving cars, image recognition, etc. It might be tempting to start here, but it might drive you crazy.
Sure, but that's not anything super complicated to do. Not to say that if you want to scale up, redis does that out of the box (cluster). 
i second that! i would have to use like 4 different loggers if i wanted stdout, error, file and debug logging, bloating my code quite a bit. Just remember, packages are there to make stuff easier (write less) and be modular at the same time. logrus has a pretty good aproach with logrus.Warning(), [logrus.Info](https://logrus.Info)() etc. its basicly just taking the default logger and extending it quite a bit. . just one instance, has hooks and you can replace the default logger with it with just one line of code (kinda like a interface). &amp;#x200B;
[https://www.amazon.com/Make-Your-Own-Neural-Network-ebook/dp/B01EER4Z4G](https://www.amazon.com/Make-Your-Own-Neural-Network-ebook/dp/B01EER4Z4G) This is a great book. Starts with some theory behind neural networks, and later hands-on with TensorFlow &amp; Python. It's Python, not Go, but you should be able to apply the same concepts in Go (as TensorFlow has G Bindings as well).
They’re just trying to match what their competitors are offering, and it’s about damn time.
I just can't seem to get this running then. There's no `go get` command to do that and `go mod edit -require=MYLIB@latest -replace=``MYLIB=github.com/ACME/MYLIB@latest` does not do the trick, either. For import paths that start with something looking like a hostname I get either this error: &gt;unrecognized import path "ACME.COM/MYLIB" (parse https://ACME.COM/MYLIB?go-get=1: no go-import meta tags ()) or that: &gt;unrecognized import path "ACME.COM/MYLIB" (https fetch: Get https://ACME.COM/MYLIB?go-get=1: dial tcp: lookup ACME.COM: no such host) For import paths not starting with a hostname (that is what I traditionally used in some projects; Google internally does the same according to [https://golang.org/cmd/go/#hdr-Package\_lists\_and\_patterns](https://golang.org/cmd/go/#hdr-Package_lists_and_patterns)), I get: &gt;unrecognized import path "MYLIB" (import path does not begin with hostname) What am I missing?
Now where’s github actions... I’m slowly moving to gitlab because not having any sort of CI/CD straight from github is really annoying.
AIUI, you can have a webserver serving `ACME.com` host any packages you like. You also can resolve `ACME.com` to a different webserver on a private network (if you control it), if you want to serve different packages to a private network and the public internet. Lastly, you can have a module proxy running locally, which can do all kinds of shenanigans. So I think anything you want in terms of development-workflow will be possible to do, the way `go get` is designed. That being said, one thing that *does* change is that the git-repository and the released module-code are fully decoupled. So, something like &gt; Does anyone know if a feature to "go get ACME.com/MYLIB from github.com/ACMEINC/MYLIB" is planned for Go Modules? doesn't fully make sense - `github.com` is hosting the git-repo and `ACME.com` is hosting the module (it just so happens that the go command has a feature to transparently download a dynamically built tar-ball for github module paths). You *can* upload your releases to `ACME.com` and make them go-gettable from there - regardless of where the git-repository is hosted. But AIUI you do still need a webserver on `ACME.com` to actually serve the modules, if you want the modules to use that import path (just like you currently need a webserver serving a `&lt;meta&gt;` tag on `ACME.com`, if you want that import path for your packages). But because of the work the athens project is currently doing, that webserver probably doesn't have to be terribly available and can be quite simple (in the simplest case, you can serve the current content of `$GOPATH/pkg/mod` statically).
You can already achive this with meta tags https://golang.org/cmd/go/#hdr-Remote_import_paths
Why?
Thanks, shall take a look at it.
Yes, but that means I need to modify a public website just for some internal development tools.
Katamari Dama-C++ is a complete mess of a language now and every release is making it worse as they keep adding to it. If you need it for a job, well, there you go. But if you want to learn it to expand your mind, Rust is a far, _far_ better choice. Ironically, if you do want to learn _real_ C++, Haskell can still be a better place to learn some of the hardest aspects of it! It has been observed that the best way to make non-trivial C++ template code is to first write it in Haskell, get it right, and then transliterate it into C++ template code. Which kinda points to C++'s problem. It keeps chasing fads, only it gets there late, with very kooky support, and with massive interactions with all the previous stuff that came before it. I find myself wondering how many polyglots there are nowadays that can use C++ but also are deeply familiar with some other language; I often feel when I'm debating matters that the pro-C++ camp exhibit the signs of knowing C++ and nothing else. When that's what you know, everything C++ does makes sense, and all the other things people are saying to criticize C++ don't make any sense, it just sounds like gibberish. But if you know multiple languages, despite its massive popularity, I find it hard to see very many cases where C++ is _truly_ the best choice in 2019, and Rust is nibbling in on the remainder fast. There's just so many places where I can pay a 2x-3x speed penalty to use Go or any of several other quality languages, and on the flip side, even if you do need that speed, like I said, Rust is really nibbling in there, and D (as recommended elsewhere) has some non-trivial advantages. (D is basically C++++, by design, by someone who knew what he was doing.)
Yes, I want to have package path and Git repository fully decoupled. No, "ACME.com" in my example is not "hosting" the module in any way. It's just a unique name. And I want to specify in my go.mod where to get that package from. The import path prefix is an arbitrary prefix, that, until the advent of Go Modules, could be freely specified, with the added, optional feature that `go get` would try to figure out where to download it from, if it looks like a hostname. From `go help packages`: &gt;An import path *can* also name a package to be downloaded from a remote repository. Run 'go help importpath' for details. and &gt;Every package in a program must have a unique import path. By convention, this is arranged by starting each path with a unique prefix that belongs to you. For example, paths used internally at Google all begin with 'google', and paths denoting remote repositories begin with the path to the code, such as 'github.com/user/repo'. My internal packages can be imported without issues if: * using the traditional GOPATH approach, * using Glide, and * using dep. I just want to understand, if we need to rename packages now to support Go Modules or if that is a temporary restriction in Go Modules.
A lot of people only store their random personal code on BitBucket or GitLab because of the private repos. Most will never convert to paying customers, but if GitHub has a vision of being standard plumbing in everyone's workflow, then this is an easy barrier to remove. Their status as standard plumbing will bring *other* customers to pay for other services. That's my theory.
We just store pure configuration stuff in a table and cache it, then use something like \`x.configuration.Get().Thing.Value\` where necessary, most configuration changes really shouldn't require a restart.
summary of the article: *don't put your dick in a hotdog slicer.* thanks for that invaluable information.
Looks like you are importing "ACME.COM/MYLIB" then that's exactly what should be in your `go.mod`. `go mod edit -require=ACME.COM/MYLIB -replace=ACME.COM/MYLIB@latest=github.com/ACME/MYLIB@latest` You may also try import "ACME.COM/MYLIB.git" to skip checking for meta-tags and assuming `git`.
Among other things, "util" packages tend to be places that collect a million transitive dependencies, and also places that people modify and break large numbers of things that depended on them without having checked them. It tends to become a dumping ground of code that nobody really takes any responsibility for but everyone relies on.
He does explain why it's sometimes preferable to copy-paste rather than import: &gt; Even if this results in some code duplication this is preferable to introducing an import dependency between two packages. My understating is that it increases decoupling.
He does explain why it's sometimes preferable to copy-paste rather than import. My understating is that it increases decoupling as the author writes: &gt; Even if this results in some code duplication this is preferable to introducing an import dependency between two packages. I also don't think that "the article suggests that having completely unrelated packages depend on common code **is** indicative of a design flaw". ` The very title says `avoid`. So the correct interpretation would be: Unrelated packages depend on common code **may be** indicative of a design flaw.
Give me gitlab or give me death!!
Just started a new job where they host GitHub internally. Going to see it I can convince them to switch to gitlab, especially for its excellent gke integration
The key is that they're only free with up to three collaborators. That's good for small groups who don't want to pay just to get a private repo, thus encouraging them to exclusively use GitHub, thus, hopefully, getting some of them to pay when they need more. I'm just glad I don't have to use GitLab for this anymore. I can't stand their interface.
Even building a cross platform AHK with this would be possible. By building a parser for the AHK syntax and converting that(AST) into the relevant robotgo calls. That actually sounds like a very awesome side project! :D
[removed]
I switch my company to Gitlab years ago. Endless issues. Every time you go to use it, SOMETHING is broken. Pipelines were also clunky.
This is quite good. Most would dismiss it as irrelevant when circuit-breakers, automatic-retries, and automatic-failover will keep you afloat in such times of crisis, but it is good to see transparent port migration being laid out for Go-based daemons.
This is already suggested [here](https://github.com/golang/go/wiki/CodeReviewComments#package-names), [here](https://golang.org/doc/effective_go.html#package-names) and [here](https://blog.golang.org/package-names).
Hello, after few months of iterations over the API I have tagged 0.0.1 and I think the API are very similar to what they will be for 1.0.0 [https://gianarb.it/blog/testcontainers-go](https://gianarb.it/blog/testcontainers-go) examples and more context in the article
&gt; No, "ACME.com" in my example is not "hosting" the module in any way. You misunderstood. I was saying, `ACME.com` *has* to host the module. &gt; It's just a unique name. And I want to specify in my go.mod where to get that package from. Where would `go get` know where to get the module-file? &gt; The import path prefix is an arbitrary prefix, that, until the advent of Go Modules, could be freely specified, with the added, optional feature that go get would try to figure out where to download it from, if it looks like a hostname. I don't believe Go modules change anything significant here. &gt; I just want to understand, if we need to rename packages now to support Go Modules or if that is a temporary restriction in Go Modules. Still don't understand what you mean. You will continue to be able to use Glide or dep or whatever else you want. Go modules are, to the best of my knowledge, a pure `go`-tool concept and don't touch the language. If you don't intend to use the `go`-tool and are not interested in being compatible with it - then I don't see a problem. If you are, I think I outlined above what you can do - the easiest possibility is probably having your own proxy to do any shenanigans you want internally and host the module on your domain for public consumption.
Here I am trying to support dynamic languages, such as JavaScript. Which is choosing a solution.
I'm a curmudgeon, but to me it's indicative that the dev team has stopped trying to organize code for intuitive discovery. If I have to write something and I'm not sure if it exists yet, I *always* have to check if there's something useful in "util" or "common". Ultimately I find it tends to be a short term fix for a developer, at a long term cost for making the codebase less scalable to many developers.
Coupling is bad. Repetition is bad. You can't always avoid both, so whichever you decide, you are making a trade-off. &amp;#x200B; As a rule of thumb, finding yourself with ill defined poorly names packages like "common" is a sign that you've leaned too far towards avoiding repetition. (there are always exceptions to this, but it's a good alarm bell to be careful) &amp;#x200B; If it's really "common" then think about what it's common to, and think about how you can give it a more clearly defined role. If you can do that, then fine, give it a proper name that describes the role and go for it. Maybe even make it a different well documented and tested library project for others to use. 
[removed]
[removed]
[removed]
As I mentioned, that approach has significant additional complexity: I would recommend instead working on implementing plugin support for Windows. But yes, the idea is that you map theb same off-go-heap memory area in both processes, and the you transfer offsets into the area between them (in general you can't pass pointers because the address of the mapped memory will differ in the two processes) and synchronize accesses to the memory somehow (platform dependent). Being off-go-heap obviously means you can't rely on gc. There may be some libraries that can help with this (mangos/nanomsg maybe?). 
GoLand. I took a decision last year to buy a Jetbrains personal All Products license. I did it for several reasons and was happy enough to renew again this year. I plan to keep doing so. 1) There is a perpetual fallback license so I can stop subscribing to the new version at any time and still have a license for the older version. 2) I use several different languages (Java, Python, PHP, Javascript and also Datagrip for database connections) and am learning Go and possibly a few others soon (Kotlin) So by getting an All Products license then the IDE is near identical for each language and I can just concentrate on the language rather than a new IDE or getting various plugins working. 3) I was very impressed with the Jetbrains IDE when I first tried it. 4) The license cost reduces each year for the first three years, to the point where it's actually an amazing price for the All Products pack. 5) I've used their support a couple of times and it has been excellent. So rather than spend hours trying to understand why an IDE isn't behaving how I expect then I can just ask them because I've paid for support.
Personally I'd just use cron + bash + scp. Personally I wouldn't complicate matters unless you have other requirements.
Either one would be good. Cron would probably be easier because you don't really have to do anything with the web server.
What?! Definitely going to try this out. 
I've been using peachpy for all my assembly work recently . This is a Go version of the same idea. Check out the examples: https://github.com/mmcloughlin/avo/tree/master/examples
I just watched Mitchell Hashimoto's talk on Advanced Go Testing and he covers cases like yours. You might find it informative: https://www.youtube.com/watch?v=8hQG7QlcLBk Hashicorp has a couple open source projects with built-in e2e testing: Terraform and Vault. You'll find examples there that include even more complicated setup and teardown. HTH 
How will you know if your gocode broke? Will you have it constantly restart? Will you e-mail/log on failure? cron has a bunch of niceities built in to help service your ondemand~ish job that'd probably be worth it vs having a long-running go process. That being said, if you're doing this every 1m it sounds like you are wanting it "immediately~ish" moved. If you do go with the long-running go process you can look at `inotify` and essentially receive a callback whenever a file is added to that directory, without you writing any directory polling code with sleeps and etc.
Private repos on free tier is limited to 3 team members 
If you haven't read [Rob Pike's papers on windowing systems](http://doc.cat-v.org/bell_labs/concurrent_window_system/), I suggest you start there. The TL;DR is, a client of the windowing system receives input events over channels, and sends an image of its window to the system for rendering. The window system simply multiplexes the keyboard, mouse and screen to all the clients.
Muchas gracias! Will check then out :)
Why string only selector ?
- https://github.com/as/ui is something along these lines, /me think.
This is what activated sockets in systemd are for doing. I have some code somewhere on how to do it but don’t have access to it at the moment. 
This sounds awesome!!! I will def give it a try If this works out as I imagine right now... holy fck
In every language, not just Go, it's a bad practice to have generic "grab bag" packages. The whole idea of a "utility" function is something people made up so they can be lazy about documentation, naming, and testing. It is always better to either not put the function in a separate package (as this author suggests), or to name the package more intelligently. IMO the only valid use of a "utility" package can be seen in the httputil package in the standard library. It is literally just things that could have been in "http", but aren't used by everyone. However, most of the time when people make a utility package, it's just so they don't have to come up with better names and a better organization scheme.
Not closely related and somewhat already spoken of, but python and JavaScript/node would be good if you’re considering this for resume/work. Even not considering that python is pleasant to work with too. Not the biggest fan of the JS ecosystem but as a language it’s also nice to work with. The frameworks (and there are many) are often like learning another language entirely. Both of these languages also offer a lot of possibilities, from ML to front end web development. All of which can be done with go (or most languages) but these two have large communities around many of the different subsets. I can’t really speak to academic, or generally personal enrichment though.
This is harder to write and more convoluted than plain assembly.
I originally planned to pass a variadic list of structs, but expressing certain patterns like wildcard matching and boolean operations quickly became annoying to type. The implementation can still use other data structures underneath. Plus, it’s not like new channels are constantly being allocated in a loop. So the parsing is only done once.
Yes, but easier than complicated `#define` macros. Consider all the openssl assembly files that are generated with perl.
What' s the difference between this and dockertest? [https://github.com/ory/dockertest](https://github.com/ory/dockertest) &amp;#x200B;
For small functions, yes this is likely not worth it. However I personally think this makes large kernels with loop unrolling (for example) substantially easier to reason about. The [sha1 example](https://github.com/mmcloughlin/avo/tree/master/examples/sha1) is a good demonstration of this. I also think the success of PeachPy has already shown the value of this kind of technique.
You'd probably want to conceive of the string as a serialization of some specified format then, basically giving you both. The API should probably take both, because sometimes the user may just want to slam a string in, but sometimes the structure needs to be programmatically generated, and having to serialize that into a string just for the receiver to turn around and deserialize it again is both just generally annoying, and a common source of security bugs when the two serializations disagree with each other. (Yes, there are security concerns related to client-side widgets.)
&gt;Looks like you are importing "ACME.COM/MYLIB" then that's exactly what should be in your go.mod &gt; &gt;`go mod edit -require=ACME.COM/MYLIB -replace=ACME.COM/MYLIB@latest=github.com/ACME/MYLIB@latest` You're right, but this command is not working. As manually creating the `go.mod` entries seems to be fine, I opened [an issue](https://github.com/golang/go/issues/29620) for that.
Yes the idea was inspired from that work, but it’s currently not interface-heavy like as’s. The event selection is a lot more granular here though.
&gt;Still don't understand what you mean. You will continue to be able to use Glide or dep or whatever else you want. Go modules are, to the best of my knowledge, a pure go\-tool concept and don't touch the language. If you don't intend to use the go\-tool and are not interested in being compatible with it - then I don't see a problem. From my understanding, what I was trying to achieve should be working with Go Modules (as in "go tool"), too. After some more digging, it turns out that it actually is a bug in the "go mod init" and "go mod edit" commands—handcrafting the correct `go.mod` content works fine. I opened a ticket here: [https://github.com/golang/go/issues/29620](https://github.com/golang/go/issues/29620) To answer my own question: Yes, this restriction is only temporary and it will go away. Thanks for trying to understand my "shenanigans." :-D
Link (presumably): [dudk/phono: DSP pipeline](https://github.com/dudk/phono)
Is there any story behind of it
One thing you must keep in mind is tests must run based on consistent conditions, so, not on what the result of a t.Run() is. t.Run() is very good for running tests that have common initial setup. Hence your test should be like "setup(); snapshot(); t.Run() { defer restoreAtSnapshot(); test(); }; repeat... ". If a Run() depends on the result of a previous one, you're indeed abusing it.
Prime him and paint to fenris gray.
I'm waiting for it
3D-printed gopher-duck☝🏽
If your SQL translate 1-to-1 to a REST API, your REST API sucks and you should just give out database access instead.
The slices share the same backing array. 
`three` is a slice. [Slices are like references to arrays](https://tour.golang.org/moretypes/8), so `three` is going to be changed by anything that changes `arr`. [`append`](https://tour.golang.org/moretypes/15) will allocate a new backing array for the slice it's called with only if the current array isn't big enough. `arr` is the backing array for `arr[:3]`, and it's big enough to hold the 5 too, so append just uses `arr`.
Go is not really comparable to C. It's more comparable with other high level languages like Javascript (node.js), Python or Java. I mean perhaps it has some syntax similarities with C. And does not use classes, but absent of classes doesn't really eliminate OO patterns (reusable code bundles with behavior and/or state). And it's garbage collected with quite a heavy runtime. You may want to try Rust. Some developers dub it "practical haskell". It's has quite a steep learning curve. However, application from web-developer side is quite limited to web assembly and perhaps FFI's. Sure you can build microservices with it, but you'll probably be way more productive with Go for that.
Throw a `fmt.Println(arr)` at the end and you can see the underlying array was modified with the append. The `three` array is just a pointer to that section of the underlying array in this case. starting array: [0 1 2 3 4 5] three - before append: [3 4 5] three - after append: [5 4 5] underlying array: [0 1 2 5 4 5]
This is really cool. Seems to break on this query (I know it's arbitrary) - doesn't look like it can interpret the `count(*)` field properly. ``` select user_name, count(*) from users where user_name like '{{ .Input.user_name | .SQLEscape }}%' group by user_name; ``` "[PANIC RECOVER] interface conversion: interface { } is int64, not []uint8 goroutine 34 
I need the stl.. for science.
This is actually a very good point. I’m not assuming any dependence amongst Run(), however I’m also not restoring back to a snapshot after each one. As things are right now, Run()s are not starting from a blank slate. Thank you for pointing this out.
security - its important 
I was just bored, drunk, and own a 3d printer
I used [this](https://www.thingiverse.com/thing:439511) as the go gopher, then just mashed it into a rubber duck stl. Literally as lazy as possible to make this wonderful creature. 
[removed]
I'm gonna print this in tpu. It will be glorious.
I hardly find that to be the case. I mean it supports OO patterns, there is no inheritance, but who cares, I mean OO does not require inheritance, you pretty much always use composition anyway. Explicit references maybe isn't what people are used to, but dealing with references to memory is common experience (javascript). What it introduces is thinking about concurrency, and even that is introduced very easy to grasp way (although not very robust, have fun debugging data races). But other than that I find it very similar to already commonly used high level languages. Wanna dwell to true wonderland try Erlang or Rust.
The primary paradigm of Go is not OO. Go is a data-structure oriented language. it's primary paradigms is the same as C where you build structures of data that is passed by value or by reference as needed. Explicit references are all the difference here.
I've been following gRPC in the browser developments for a while. Improbable has an in-process proxy for Go, so I thought others might be interested to see where the project stands given the official release of Google's gRPC-Web proxy/client.
Could you try it again? \- I removed the \`.SQLEscape\` \- Tried to fix scanner issue, hope it is fixed
Nice post. Why aren't websockets used? At first glance they would seem ideal. 
There is experimental websocket support in the Improbable implementation. I'm assuming it will eventually be added to the Google repo as well. I think the reason it hasn't been added yet is that websockets are really only needed for BiDi streaming support and streaming from the client to the server is probably the least common of the supported gRPC features. Perhaps someone else can weight in as well.
holes for pupils give me weird feelings of horrors arising from deep within (even though real pupils are holes)
Would latency also be lower with websockets? I guess I could get off my butt and measure it myself...:) 
Start() returning an error seems like it's way out of place. It's complaining about illegal configuration well after the configuration has already been accepted.
Aha! Got it. I think. What Microsoft calls a "solution", Go calls a "repository". What Microsoft calls a "project", Go calls a "Library". What Microsoft calls a "package", Go calls a "Module". "go mod" is Go's "package manager". Treat it like nuget (or npm for node folks). Structure like: c:\Solution\Bin -- where foo.exe will got and c:\Solution\src\Library\classX.go cd c:\Solution go mod init solution got get ./... -- write code -- go build I'll try it out and see how this structure/pattern works for me. Thanks!
Yes, correct. Although it shouldn't be hard to get this into goreleaser.
[removed]
me too, can you send it to me?
We can call him [Ducky-Go-Go](https://www.youtube.com/watch?v=3MHzNfoulwI). He is your very best friend.
When has r/golang become into r/programming?
It would not given the websocket handshake needs to occur before any data can be exchanged. Using plain HTTP has lower latency.
This is potentially a really bad idea. Check into whether bats cluster is propagating messages to all nodes. This would kill you on network saturation under load. 
I use amazing [https://godoc.org/github.com/stretchr/testify/suite](https://godoc.org/github.com/stretchr/testify/suite) package which allows to implement SetUp and TearDown facilities for tests run. I would not have invented a wheel without any `real` necessity over raw and poor default `testing` package. Hence in `SetupTest()` I do usually prepare an environment for the tests (including DB), in `TearDownTest()` some clean up is made.
Load in this scenario is on the order of less than 10 messages/second. Currently I have Raspberry Pis connected up to control my HVAC, reading temperature, and controlling the garage doors. So the HVAC controller and temperature sensor would talk to each other on a regular basis but that would be on the order of once per minute max. If I can get something up and running, I'll probably add some type of persistence to track temperature changes over time and control events coming through just for the heck of it. But that's just leveraging the pub-sub in NATS.
&gt; https://play.golang.org/p/e77ve65IfbW Seriously thank you so much for this. This will help me a lot. 
You could try checking out the source code for rio and wm, the window managers for Plan 9 and Inferno respectively. Both are written by Rob Pike, and wm is written in Limbo, which has similar concurrency ideas as Go, so the source code could be interesting reads. You should be able to find them relatively easily through Google.
Done this to impl a quick and dirty nodemon for Golang/Docker build-and-compose-up-on-changes behavior. It’s a simple bash script that loops infinitely, using inotifywait for blocking on dir changes, and running the build/compose-up when inotifywait returns. Op, this would just be a matter of getting the specific file altered and scp. Inotify would be the best of both worlds.
Do you manage the servers or are you using their hosted service? Managed gitlab is kinda hard to use if you’re not using docker. There’s so many moving parts. I found that the hosted solution is more than sufficient for most of my needs. 
Looks like he’s sobbing 
I think the conclusion that Go is on the rise because it is "easy" is wrong. I think other factors, like fast compilation times, a great deployment story and the emphasis on concurrency, are more important.
Eh, don't buy Packt books.
"We're contributing our parents to the old people's home"
\&gt; I know that intSeq() is executed the first time when it is set to nextInt &amp;#x200B; That "it" is perhaps the problem. It is not intSeq which is set to nextInt, but nextInt which is set to the result of calling intSeq(). That result is itself a function (the closure you were wanting to understand), and each time you \`nextInt()\` you call that function. &amp;#x200B; \&gt; why...receivers &amp;#x200B; That's just the syntax for defining a method. \`func area(r \*rect) int { ..... }\` would be a regular function. You can write it if you like. However the regular function couldn't match an interface type, nor could you have other functions called \`area\` which took other types as arguments. &amp;#x200B;
&gt; but I am confused how each successive call increments the counter when it seems like it gets set to 0 each time. Is the outer function only executed the one time and then only the inner function gets executed over and over? That's exactly it. The returned function is in the scope of the outer function and has access to its local variables. `i := 0` until `nextInt()` actually runs. 
Closures Closures allow a function to reference or "close" over values in an outer scope. So, for example, the following will print the value of `x` even though `x` is declared outside of the scope of our function literal. ``` func printx() { x := 1 func() { fmt.Printf("x = %d\n", x) }() } ```
One of the differences can be that I didn't know about dockertest at all!! Looks great, thanks! I will look at it
This is really great! &amp;#x200B; Just quick q as I couldn't see just from skimming - does it work correctly with SSE4/AVX type vector instructions? I'll be playing with it later!
I've not seen it mentioned yet but I'd suggest C# if you want something close to Go (they seem to be converging in some ways too!). Rust is also likely to be a big player. &amp;#x200B; However agree with the others that if you want to expand your horizons go for something very different, Haskell, O'Caml (or F#), Erlang, Scheme, Lisp, (I've even been looking at Algol and Ada recently :) ) etc. all give different perspectives. 
&gt;func intSeq() func() int { i := 0 rc := func() int { v := i i++ return v } return rc } func main() { seq := intSeq() fmt.Printf("%d\\n", seq()) fmt.Printf("%d\\n", seq()) fmt.Printf("%d\\n", seq()) fmt.Printf("%d\\n", seq()) fmt.Printf("%d\\n", seq()) } not op, but i have same issues in understanding this. could this be rewritten as func main() { seq := func() { v := i i++ return v } } or func main() { seq := { i := 0 func() { v := i i++ return v } } } i understand that with closure you keep the environment, but where exactly is this "i" hidden?
&gt;That "it" is perhaps the problem. It is not intSeq which is set to nextInt, but nextInt which is set to the result of calling intSeq(). This part right here makes so much sense. Thank you for helping clarify how exactly it operates. I never bothered learning the more in-depth intricacies of Java but learning Go I am having so much fun really trying to understand everything which is made all the easier since the community is so helpful. 
&gt; ReplyshareSaveedit &gt; level 2mispp11 point · 13 minutes ago · edited 10 minutes ago When the compiler detects that `i` is covered by a closure, `i` is moved to the heap so that when the containing function returns, `i` persists. So, for the following code: ``` package main import "fmt" func newSeq() func() int { i := 0 return func() int { v := i i++ return v } } func main() { seq := newSeq() fmt.Printf("%d\n", seq()) } ``` when i compile with `go build -gcflags="-m -m -m"`, the `-gcflags` portion tells go to print optimization decisions. the code above shows this: ``` ./c.go:6:2: moved to heap: i ``` so that's where the compiler stashes that value so that it can be reused. 
i think i finally understand this. thank you!
/isitgotimeyet ?
This has been bugging me, hoping for an official update as well
awesome! hire me!
&gt;I was just bored, drunk, and own a 3d printer it must be green :) &amp;#x200B; [https://imgur.com/a/0leLzyN](https://imgur.com/a/0leLzyN)
Rob Pike, presumably. Note that there is absolutely no reason to believe that this domain is owned by him.
I thought this was going to be a weird reference to DuckDuckGo. Well played. :)
There are probably a lot of places like my work that use some Go but don't include it in job postings because it isn't the company's #1 language. So even though I personally spend more than 50% of my time writing Go, you might not know we use it at all based on our job postings. This is partly because when we add a new developer to the team it doesn't really matter which languages they've used before. &amp;#x200B; But having a niche or new language on your resume is definitely a good sign that you enjoy programming and can learn independently. If I were reviewing resumes I'd love to see Go on there, or would be equally happy to see Rust, Elixir, Haskell, Scala, Nim etc.. anything that the candidate clearly learned on their own and not because somebody told them they had to.
Wouldn't it make sense to have NATs nodes register themselves with, say, etcd and use that for discovery?
I've had this issue as well. I'll give this a try when I get home, thanks!
I switched back to GoLand for reasons such as this. It just does too good a job at these sorts of tasks, and it turns out it isn’t perceptibly slower either. It also lets me drill into dependencies in the GOPATH without having to add them to my workspace. It really does make a big difference as a developer if you can just pick up a file and drop it somewhere and have everything magically renamed like you‘d expect. JetBrains seems to be the only IDE vendor who has properly nailed this, and I’ve tried so very many over the last 20+ years …
Well yes, that is the standard service discovery route. I was hoping for a more decentralized solution so I could go from zero devices to one or more without any of them having to know about each other beforehand (including not having to know about a service registrar). I do think this may need to be the solution though.
I doubt there is such a thing as data-structure oriented, can't even find any references to such term to begin with. There is data-oriented however that's not even close to what Go does, because emphasis is on the structures, not particular data within the structures. There is no significant difference between a data struct and a class. Other than one can't inherit data struct. Inheritance doesn't make or break OO. It's one of OO approach, class-based approach, feature. The aspect is that you still manipulate reusable pieces of code which encapsulate behavior and state as your main building blocks. Sure it's not "main" paradigm whatever that means, same can be said about Python. So we can discuss the bits and how exactly this pattern is implemented, however that doesn't change the overaching principle of OO. 
hosted service
&gt; Or on a mac: which gorename.exe Yeah that's how executables on mac look like.
I realized it is not the best design, I moved it to the constructors.
I think you always basically hit the same thing in the end that there's a minimum amount you need to agree on to bootstrap. If you want to ping every machine, every machine needs to agree on a list of potential machines (for example) which is just a different set of assumptions and coupling that might even be less flexible for running multiple stacks.
It appears to be very fast when renaming structs. It doesn't appear to change the reference in any packages that utilize the struct. I'd be fine with it not crawling the GOPATH if it still renamed inside my repo.
Apart from AVX-512 it should work! I have an [issue filed to add AVX-512 support](https://github.com/mmcloughlin/avo/issues/20) but I wanted to limit the scope for the first release. If you run up against any problems, please let me know.
There is a lot more gRPC adoption in the Go community and Improbable's implementation mentioned in the article is written is Go. So, still not worth posting it here? 
[removed]
I like your API though. Hope I didn' t kill the excitement for your package unveil. ;)
[removed]
Regular expressions are good for quick hacks but often overused. Maybe you should try some other solutions.
Just add a middleware: ```go func mdlwr(h http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { if r.URL.Path == "/unwanted" { return } w.Header().Set("Foo", "Bar") h.ServeHTTP(w, r) }) } ``` ```go fs := http.FileServer(http.Dir("static")) mux.Handle("/", mdlwr(fs)) ```
&gt; Or on a mac: which gorename.exe Pet peeve: Go binaries on Unix do not have an extension, it is simply `gorename`.
Yep that fixed it! 
im using something that only accepts regex so theres no other option. i ended up doing a massive (|) with all the different order variation possibilities, luckily i only have three capture groups, so only nine versions
In my opinion, it depends somewhat on the requirements of your project. One of our largest application (currently about 90'000 lines of code) is composed of a service simply tasked with serving all assets for the single page application frontend (developed in vue.js), a GraphQL api endpoint that serves as edge proxy for all data request and multiple internal services that communicate over grpc. Authentication is handled by the api endpoint in conjunction with a single sign on service. The respective user context is then passed via grpc metadata using grpc interceptors on the client and server side to inject the respective data automatically into the context of requests. For inter-service communication we employ envoyproxy that is deployed together with each service inside a docker container. This gives us lots of benefits regarding the service hookup without having to write extra code in the services itself (an example is a service mesh that we have for testing, so that developers only need to run the service they are currently working on locally and the rest is automatically proxied via ssh-tunnel to the testing environment that runs all services). Every service is split into four packages at least: \- "domain" to define the data models (generated from proto definitions) \- "usecase" that implement all the rpc-methods of the service \- "usecase-tests" were the tests for all use cases are stored \- "repository" for all database interactions Every service has it's own database and other services are never allowed to directly access the database. However, for production all data is actually managed in one postgres instance with separate schemas. We are currently in the process of validating the application using jira to manage the specifications. Every service is represented as jira-component and all service use cases are specified in jira as well. The user requirements are specified as user-stories which are then further defined as functional and non-functional-specifications and linked with the respective service-use-cases and tests.
We did not yet measure this. But the guys that develop envoyproxy really put quite a lot of effort into making it fast. However, if you do stuff over the network, I would think that the additional latency from envoy pales in comparison to the time the network request is taking and the additional benefits you get are probably well worth it. Check this FAQ for the answer of the envoyproxy developers on the speed of it [https://www.envoyproxy.io/docs/envoy/latest/faq/how\_fast\_is\_envoy](https://www.envoyproxy.io/docs/envoy/latest/faq/how_fast_is_envoy)
I hate the JetBrains is so damn much better than everything else and requires a subscription, but I guess you get what you pay for. Those subscriptions pay for full time devs who are churning out features and fixes to just the cost.
I'm gonna say Rust and Swift.
I understood half of this. I'm still not even sure how to architect the service itself. It looks like you guys use not so micro architecture, but instead split a monolith based on what goal each part is trying to achieve. For production db, services talk to separate database, but separate databases all talk to one giant one? This is for debugging purposes mostly?
This blog post may be helpful: https://blog.golang.org/go-slices-usage-and-internals
Wrapping my head around Interfaces and how to architect go code when I came from decades of Object Oriented programming. It also doesn't help that I am not writing go code all day, but I manage to fit it in where I can.
Did you struggle most with Go using implicit interfaces over explicit? I struggled with interfaces as well for awhile, especially when to use them and when they can be overkill. Another OOP thing that threw me off was the lack of inheritance in structs. 
RSI
Newbie here: \- still no viable native cross-platform GUI option. The Qt wrapper is needlessly license encumbered, everything else not in shape for prime time. I've spent too much time figuring out whether I should make a GUI in Go or not and still haven't found an answer. Almost every library on earth is unfinished. (But that's the same in other languages except Python, C++, and Lazarus.) \- haven't yet figured out how to design a good API for my library \- I probably don't use interfaces as much as I should but haven't found a need for them yet
use `yasnippets` to crank out those `if err != nil {`s and save ur wrists
thanks...i will use `masnippets`
A good talk about refactoring and interfaces is here : https://www.reddit.com/r/golang/comments/5a5rnz/dotgo_2016_katrina_owen_the_scandalous_story_of/?st=JQPSKQJ4&amp;sh=90f2d4b0
Could you send article with example? Or where I can read about this architecture?
You missed implementation inheritance I suppose? If so I can relate.
The lack of inheritance in structs was frustrating for a while, but once I embraced composition I much preferred the "Go way of doing things".
The implicit thing didn't bother me much, that I understood fine, had some trouble with pointer vs value receivers at first. I have the most trouble in trying to design code to be used by other people (i.e. a library, etc). Most of this stems from all the OO work I still do and have done for many a year...
When learning Go, the rigid directory hierarchy is definitely a learning curve. It is definitely an unusual approach, but one does get used to it. Package management is hard to get right, and i don't think any language has it perfect, so I don't give Go too many demerits due to that. The number of packages I run into that generate Go code to do generic stuff is nuts. I haven't decided whether it is crazy smart or crazy dumb. But error handling. I'm an old school C hacker, so I'm used to checks at every call. However, after going back and forth from Python to C a bunch, I've decided that exceptions really is the way to go. It is easier to centralize error handling at whatever level is appropriate. I'd really like a C++-style throws declaration, so a static checker could verify exception handling, but Python does it close enough. It is hard to get used to that much line noise.
&gt; native cross-platform GUI option Sure there is: your web browser. &gt; design a good API API design is orthogonal to choice of language. Rest assured, golang handles many types of APIs with amazing efficiency. &gt; haven't found a need for (interfaces) Interfaces make code testable. Are you testing your own code? You should be...
This was the biggest thing for me. Most of the time I need pointer interfaces I don't know how/when I would use a value interface instead.
This is an updated version, as I wasn't happy with the initial version I wrote. Feedback hugely welcome. 
goroutines and channels. I'm still shaky at best with them. Interfaces were a bit weird at first since nothing I'd done before really had this paradigm. Now in some cases I'm wishing I just had go interfaces in other languages.
Testing honestly. Do I use only the built in testing framework(library lol)? Do I use ginkgo and go full TDD? Testify? Wait.. what's r.Run and subtests ohhhhhh
a good thing to know about interfaces are that their utility is on average decreased with the more signatures added. with the exception of an empty interface. That takes it so extreme that it becomes less useful in most cases. Example: I have a function that takes a slice of bytes and writes it to a file. If I make the arg an *os.File that works, but how can I test this function? Make a tmp folder, run the func, read the file and test that it's the same? What if my boss comes along and says: we need that function to also output to an *http.ResponseWriter... copy paste time? Nope, just replace *os.File with *io.Writer and you can use the same function with anything that has a Write([]byte) int method on it. Testing is now easy, write to a buffer, read the buffer. Done.
This. Trying to make stuff dry and trying to treat types as classes was what was difficult for me.
Been using Go for... ~7 years now. Coming from Python, difficulties I had, roughly in order of when I encountered them while learning it: * lack of inheritance * overusing channels * understanding slices (mem &amp; implementation) * forgetting maps are not synchronized * details around the semantics with `interface{}` * goroutines being truly anonymous is subtle but profound * balancing simplicity with future-proofing in exported APIs Over time, I've come to appreciate the design decisions that tripped me up, but they were still stumbling blocks while learning. Also, I'm among those convinced lack of generics is a net plus, and I'll be sad to see them arrive.
My advice would be to try and not use them. See how far you can get with just well-defined data structures. Wait until you have a good use-case for an interface, then understand why. I think this is a way to get more comfortable with interfaces and why they can be so powerful.
&gt;goroutines being truly anonymous is subtle but profound &amp;#x200B; Can you talk a bit more about this please?
I really hope that GUI comment is some poor attempt at a joke.
Using channels with the select syntax. I usually just end up using a Mutex or WaitGroup.
There's a gtk library that's entirely ported on github
Sure. I was used to thread-based concurrency where threads have ids. A lot of the time, you can use these the same as you would use goroutines. However, in most systems with threads, you can use the ids to: * implement thread-local storage * implement centralized cancelation/`thread.kill()` * include `tid` in logs/tracing info Not having this ends up changing quite a bit about how you manage the lifetime of your threads/goroutines. These features are pretty useful in very small programs; relying on them in larger ones is problematic, which is why I eventually got over it and came to prefer Go's approach.
This was my approach. I just ignored them mostly until now. My latest project has a very obvious use for interfaces and now I fully appreciate their power. Previously I got along fine without them.
If it's a joke, why are so many applications being delivered via the web today?
Filtering collections in Go, which can easily be done in basically any other modern language (i.e. using LINQ 1-liners in C#). It's not that for loops are a struggle but writing them can be tedious and time consuming.
Lack of generics. Reflection seems more complex than needed. 
Interesting, what do you find challenging with the select statement? IMO it’s been relatively straight forward when working with multiple channels. 
[removed]
The easiest way to remember it for me has been if you need to mutate the data in the underlying struct, use a pointer receiver, otherwise use a value receiver. Though, I haven't found any significant impact in defaulting to using pointer receivers for most things. 
At first I definitely missed inheritance. As I started writing more Go and getting used to more composition based approached I actually started to prefer using composition. It even ended up changing how I wrote in other languages. 
We started using github.com/DATA-DOG/godog for testing our services. It has made testing in Go SOO much easier.
I really struggle with some of the loss of syntactic sugar. Python is so expressive, it's easy to do some really cool things in only a few lines of code. In go, it takes 7 lines of code to sort the keys in a map: https://gist.github.com/mattmc3/696d3c18d260697271734012695103a8 Actually, thinking about it further, I love Go for just about everything except when dealing with collections. That's where having generics would be really beneficial, but even without them there are some common operations that should just be easier. The coding bliss of the simplicity of Go is both why I love it and hate it (but mostly love it).
&gt; haven't yet figured out how to design a good API for my library This seems like a struggle in most languages, everyone seems to have a preferred method on how a library API should look/function. IMO one of the big things in Go should be avoiding package global variables/state. 
&gt; the rigid directory hierarchy is definitely a learning curve Have you tried Go 1.11 yet? The new Go modules feature helps get rid of this learning curve entirely. So far it's seemed decent on package management too. &gt; exceptions really is the way to go There can be pros and cons to both. I love exceptions, especially when you can have multiple types of exceptions so you can react to different errors appropriately. Doing the same in Go is definitely challenging/ugly. There is beauty in the noise though. Having error types as return arguments makes it more difficult to miss handling an error. Not so easy with exceptions unless you have an IDE that warns you about an uncaught exception.
For most things the standard library testing framework works well enough. I've noticed the easier my code is to test, the better it is overall. Recently started to use table driven tests with `r.Run` and can report it works quite well, and provides "namespacing" for tests in a way. 
&gt; goroutines and channels What your biggest challenge with them?
Can you elaborate more on this specific use case? I'm having trouble deciding where to use interfaces.
Nitpick: Not sure if typo or not, but it should be `io.Writer`, not `*io.Writer`. (I'm trying to find the resources why that is the case for it but it's late. Perhaps if someone knows off the top of their head. But I know I have never encountered pointer to an interface in idiomatic go)
Mostly understanding threading/multiprocessing as a concept. Channels make sense with inputs and outputs of types, buffered, closing etc. I think mostly it's understanding what is safe goroutine code and what isn't and what the patterns are for async operations with them. I suppose I understand all this stuff in theory. In practice it's certainly a thing I have to go and read documentation and or old example code I've written before.
Try using Go Modules. Pretty much removes the need for a rigid structure and allows your code to live outside of `GOPATH`. If some tool still requires the code to live in Gopath, I just symlink it (not sure what the solution is for Windows... Use Linux I guess?) Take a look at github.com/pkg/errors . Ideally the errors can be propagated back with causes all the way to the caller where they can be handled. I find exceptions to work on magic, with errors as values being much easier to understand (but perhaps less clean to handle). With `errors.Wrap(err, "chained message`), it's even easier to read for humans too.
This seems really useful, but I'd have a hard time exposing it on a public website with no tests
https://stackoverflow.com/a/44372954/3074620 You are right. I'll fix it.
Yes, interfaces. Implicit is a problem for me.
It depends on the language. Swift, for example, encodes whether a function throws or not into the type system. If you don't catch the exception or annotate your function as throwing, that's a compilation error. That's my favorite approach, but it is occasionally nice to treat errors like ordinary data.
There's no standard of when you need to use a function or not. You can get by without using them if you so desired. A quick rule of thumb is if you find yourself duplicating code, you can probably migrate it to a function.
I strongly empathize. Stupid simple data transformations have to be written out over and over again. It's not *that* bad... but it eats away. Makes batch APIs a real pain to write and use. You can't put stuff into a utility function because no generics. No getting away from it. It's not just slower to write but also to read. It can be difficult to immediately see the outline of a function when half of the variables are intermediate values just used for collection shuffling. I end up using lots of bare scopes { } just to sideline transformation code for the reader. It does, however, encourage making functions that don't do very much. Not short functions, of course, but just that don't do too much. 
The adoption in the Go community is no more than other languages. It is ok to post an article about Improbable, but not ok to mention it in one sentence in a Go unrelated article posted in this subreddit. If it ok, then there are many other things can be posted here, a JSON article mentioned Go in one line, a network theory article mentioned Go in one line, or any programming related mention Go in one line. My standard for what should be posted in this subreddit is very low. You can even post softwares which are written in Go without touching any Go code, but this article is far lower than the standard.
I use them for my controllers and models, makes easier to inject them, also mock them with something like gomock
Do you use any library like go-kit or GIN for APIs? I am learning to REST in Go, so was wondering is it better to use a framework to create micro services
I meant API more generally, eg. a package's exported API. I write mostly libraries and servers that are exposed over gRPC. I don't have a ton of recent experience building HTTP interfaces, but I'd probably reach for `gorilla/mux` and otherwise use standard libraries. If it was going to have a large surface area, and I needed it to chat to browsers, I'd probablycheck out `twitch/twirp`.
I’m that case, anything will fly! Have fun :)
The ability to serve an application over the web is not an argument when someone is complaining about a lack of cross-platform GUI libraries. You're being an ignorant twit.
For the love of me I can't understand when to use * vs &amp;. Usually I find out when I get a panic, or the linter. I also don't know what is the difference between var foo myStruct vs foo := &amp;myStruct{} and I don't know how to Google that stuff. Not being English native doesn't help either.
Generics, it would make a lot of code simpler if we had them. Using the reflection library is a pain and is horribly inefficient. End up writing a lot of boilerplate code to get around this fact.
Its not very complicated, is it your first time using pointers ? How I look at it is that we use &amp; to represent the address of the object and * to dereferece the pointer. I think you just need to write more code and after a while it becomes intuitive.
While I can agree about the "line noise" aspect of all the error checking, I've been writing network services for perhaps 25 years now (everything from smtp/pop3 servers through to HTTP transproxies), and nowadays I'll take error values over exceptions every time. I've done work in Python where I've needed very careful error checking and ended up with 2/3rds of the code being try/except lines. Ugh. There's some interesting proposals for Go2 to reduce the error checking boilerplate while retaining the control we have currently.
In my case I have a group of structs that are similar but not identical. They some functions with the same name, but different execution, and those functions are called by the main thread. Defining an interface with those shared functions allows me to call the functions allows me to call those functions from the main thread for any of these structs, regardless of which specific type they are. It's in this repo https://github.com/revmen/electionsim The interface is defined in method.go, and the structs that are represented by the method interface are on approval.go, irv.go, and plurality.go. The interface is used in the runWorker function on main.go, in the loop that's commented //run methods.
&gt; Also, I'm among those convinced lack of generics is a net plus, and I'll be sad to see them arrive. Their lack certainly stops a lot of up-front over-engineering, but if done well I'd still like to see them. Might even occasionally use them haha.
Dealing with JSON, specifically dynamic JSON where the structure isn't known ahead of time, is a freaking nightmare with Go. Sucks with Java and other strongly typed languages too though. Easy peasy with JavaScript (of course) but also with any of the other popular scripting/interpreted languages like Python, Ruby, PHP, etc. 
I’m with you on generics. Every language I’ve dealt with that has them have been more powerful, way harder to reason about, and ultimately not worth it. I think the lack of features is one of the strengths of go. It’s just a lot easier to reason about. Though I do miss better enums. I feel that is an oversight. I think keeping it simple is better, or you’ll just end with a mess. 
I mostly struggle with co-workers who try to be clever with Go.. It's such a simple language, and that's the beauty of it. Sure, it can be a little verbose, but just stick to the basics and everything will be OK.
Your example really ties in with my main qualm with Go. It seems so allergic to functional programming and this fact makes many operations that would be trivial in other languages become quite cumbersome.
I tried using it. It was average. I thought I saw a way to punch in the XML generated from glade which would make it was easier but when I looked again I couldn't find it.
Yea for smaller things like the Raspberry Pi and whatnot go is great, but if you spin up any kind of modern browser you're sucking a decent amount of resource before you even navigate to something like an angular app making it unusable.
Goconvey will change your life.
In my understanding * is like passing by value (read, copy) where &amp; is passing by reference.
Check out gabs, it's awesome!
Ha i shall research it tomorrow. :D
Again I think don’t try and use them just because they’re there. You’re not doing Go “wrong” just because you’re not using them. That’s like saying I’m using Go wrong if I don’t use Go routines.
Fair point. 
I love goconvey. If I didn't already have three monitors, I'd buy another one to dedicate a screen to it.
Try test-driven development. Is a great design methodology. Seriously. When you don't know how to design something, start by writing a test/the client part.
As someone who doesn't browse /r/programming, I highly appreciate this post.
Pointers can be a bit tricky at first. I'm (un)fortunate that C was one of my first languages so I had to get good at pointer real fast. Try googling "understanding pointers golang" for an overview. Your example about initialising myStruct is a little trickier. The first declaration creates a zero value myStruct whereas the second creates the zero value struct and gives you a pointer to it. Other things to Google may be "golang address operator", "pointer indirection" and "golang pointers as parameters". Good luck!
The biggest struggle for me was Go as a first language. Everything is explained, and discussed in the context of already understanding programming. I know a whole lot more now, but I still don't feel any level of confidence that I'm designing something properly. I just throw things at the problem that sound reasonable until I hit some block that shows the error of my ways, and repeat.
to piggyback off of others, mutation is just one thing to consider when using a pointer. It tends to be more efficient as well, so pointers to structs are *faster* esp. if the values are large. 
That is actually what I use. I come from world of node, so my instinct is to shape it like an express app, but I think I should go more struct oriented. Like, have a struct that has server field, etc, but I'm not sure how to go about it.
I am a Gopher who works as a system programmer in one of top 5 Chinese tech companies. I am insterested in some kind of remote GO job
As /u/knotdjb said, there is no standard for when to separate a block of code into functions. However, it is common for modern projects to follow a set of coding standards, and one of them that I personally find useful is the [Cyclomatic Complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity) because it suggests me to keep pieces of code grouped in small tasks that are easier to maintain or review in the future. The complexity is generally measured by the amount of conditions and function calls inside the function or method, once the limit exceeded, a warning is triggered. I personally keep my functions with a cyclomatic complexity lower than twelve. There’s a popular linter for Go called [gometalinter](https://github.com/alecthomas/gometalinter) which includes another tool called [gocyclo](https://github.com/alecthomas/gocyclo). If you want to follow a coding standard and keep your functions small, you may want to use this tool. But remember that the number is set by your, which makes this a mere personal preference.
This looks really good! I’m still learning Go, but this is perfect for the front end work I want to try out next! Nice to see that you chose Vie :)
An interface with a nil value is not always nil: https://golang.org/doc/faq#nil_error
You can use XMLs with the builder in the gotk3 library. I have done it before
What do you mean about maps not being synchronized ?
When you say GUI.. you mean GUI for a desktop application? I would argue that Java Swing AND JavaFX are very capable GUIs. 
I dont find it difficult at all with Java. You can generate Java POJOs and then load/save JSON with the java objects, dynamically using JAXB. 
Oh really? With unknown JSON schemas, please give me some sample code.
You could register your gnatsd Services with https://github.com/grandcat/zeroconf If everything ist in the local Network. No need for etcd/consul etc in this Case.
It is not safe to write (and read) from a map from multiple go routines. Reading only is safe. You have to use a mutex to only allow access for one at a time while writing. See https://golang.org/doc/faq#atomic_maps
Would it be to simple gzip the data put it in string and read it with https://golang.org/pkg/compress/gzip/ ?
That you have to setup you go path for projects. It is really annoying, why not just assume current folder is the active project 😔
Good old bindata? [https://github.com/jteeuwen/go-bindata](https://github.com/jteeuwen/go-bindata)
Remote an option?
Whats the company about in general terms, and also do you offer remote?
Have you tried Go 1.11? The Go modules support gets rid of the need for $GOOATH
Thank you. For me as somebody not doing front-end programming was Vue.js/Vuetify an easy choice ... as it speeds it all up.
Well even in Python you have to know your keys and the types for the values when you want to make use of your json/dict. In Python and other dynamically typed languages, you're just deferring that knowledge of the data types and ignoring it for the keys you don't care about. If you do obj['abc'][1] + 5, then you knew that you key 'abc' was an array of integers that you could just as well have created a Struct for
That looks like exactly the solution I was looking for. Thanks, I'll have to try it out.
No, I haven't update. But thanks for the information :) 
For me, in a semi-resource sensitive environment, it was understanding heap profiles and reconciling them with the GC behavior and the number of goroutines. The marketing around Go makes you feel that you can literally spawn an infinite number of goroutines but they do incur cost and understanding how that cost affects your application helped me a lot. 
Unfortunately, it is not. There are two options: gotk3 and a gtk2 port libary. Both do not support embedding OpenGL contexts and framebuffers for live hardware accellerated rendering... And the original libraries both have that option. For me, this is a blocker unfortunately...
very well summed up !
There are many contents you would highly appreciate but which shouldn't be posted here.
Right. And how do I embed an OpenGL 4.3 context again? And no, switching to WebGL is not an option here and is missing several features from the OpenGL 4.3 standard that I need... A web browser is NOT a viable alternative to native applications every time.
Who says that it shouldn't? I see that the majority appreciated.
Channels honestly. A feature that was suppose to be the flagship of Go but I am either too stupid or just lack the experience to correctly use channels. * I find it easy to just use mutexes * I struggle with deadlocks when using channels / select combo * I am not really sure how exactly I should be closing channels ( I know the theory in practice it's a bit more difficult depending on the code / what I want to do) * I am not sure whether I prefer abstracting concurrency primitives (after reading Concurrency in GO) or use directly. * i find it hard to deal with dynamic json/xml/soap
passing errors up the stack (no exception handling per se) and the different concept of of inheritance (structs and interfaces are not new concepts but the limited way to use them I still struggle with at times)
I said it. It is just my opinion. What do you so care about this?
gzip compacts for repeating sequences of bytes only. If your data is pseudo random you won't gain much. Note that zstd is the same algorithm but much faster. For pseudo random data you should consider bzip. But these algorithms make no assumptions on the data, because they are general purpose compression algoritm. In your case, you know the data and could manually derive a more efficient algorithm in compression ratio and speed. 
Can you elaborate on your issues with enums? I find that most of my grievances went away when I started doing type myEnum int const { ENUM_VALUE_ONE myEnum = iota ENUM_VALUE_TWO ... }
there was a little used json library I found called jsonpath when I decided “to heck with this” on one project wrestling a deeply nested buck of spaghetti JSON - the structure doesn’t even change I just didn’t want to have to deal with getting a value buried so deeply in with all the error checked I’d have to do: https://github.com/peter-jozsa/jsonpath/blob/master/readme.md
I have no prior experience in Go but I am learning it. As far as back end is concerned, I have \~5 years of experience on Node.js .
Slices. They are so powerful, but i find them kinda tricky and not intuitive. The fact itself that a page called [SliceTricks](https://github.com/golang/go/wiki/SliceTricks) exists (to me) proves that they are kinda weird.
Error handling really grinds my gears. It's one thing to be very tedious to write, which it definitely is, but it's another to make code much harder to read. The verbosity required to deal with errors, hides the happy path of the code, which is usually what I'm looking at more. Its a constant strain to try to ignore the heaps of error handling code just to see what a block actually does. In that respect, the proposed design draft for error handling really fixes these issues quite nicely. I can't wait for it to propagate to a full blown proposal and get implemented. Then there's the lack of generics. Its not an issue most of the time due to the currently allowed generic structures. But dammit, it would be nice to have an easy to use set, or an indexOf function that works with any slice.
30mb is 40mb in base64 string form. You can write a simple shell script to convert the file into a base64 string and store the string in string constant in a generated .go file in your project.
[removed]
Maybe [Zig](https://ziglang.org)
``` for i := 0; i &lt; 3; i++ { tmpCode[i] = letterCode[codon[i]] } ``` I haven't read your code fully. I just feel that the tmpCode slices can be per-caculated in an init function. 
It seems that none of the go-bindata forks are maintained nowadays. :(
I follow the VerbNoun standard... I try and code all my functions with a name that has a Verb and a Noun (GetThings, AddStuff, FrobulateTheWangleberry, etc). The function then has a clear scope. If it's called "CreateUser" then it must create a user. Nothing more than that. If I find myself doing things that aren't creating a user (e.g. sending an email to the new user), then I start another function that does that thing ("NotifyUser") It's not an absolute rule - often things are more complicated than this rule allows for. But it's a good rough guide for when to break a function - if I can't describe what it does completely with a single Verb and a single Noun, then I should probably break it up.
this can be a alternative https://github.com/gobuffalo/packr
have you tried something like https://github.com/gobuffalo/packr?
github.com/rakyll/statik
Pretty much the only thing that I had to really get used to with Go was how to structure files and packages so that I didn't end up with circular dependencies. I came from using languages like PHP, Java, Scala, and JS. All of those are more specific in that you "import" basically a file or even a type at a time, whereas in Go of course you're importing a whole directory when you import something. Concurrency was another interesting one, mainly because I'd not touched on it much before, even in Java / Scala. I'd only really used promise / future style concurrency which is a bit more abstract. I do however much prefer using Go's concurrency because you can choose a concurrency solution that fits the situation. Channels are a nice abstraction, but if you need to use a mutex then you can, and Go makes a lot of these things really straightforward. Error handling, GOPATH, interfaces, testing, dependency management, and a lot of these other things people have mentioned weren't really things I had any issues with. I don't think Go differs that much from other languages in many regards. Tooling is simple and built-in, and coming from something like PHP there's actually a _lot_ less setup and extra knowledge required to get something running. GOPATH is one thing that seems to crop up a lot with beginners, but I just accepted it and continued developing things. It really didn't matter where the files were to me.
Yes, and use `go generate` to read and put the compressed data in a `.go` file.
ahah no no, it is good to find that other projects are in my same mindset. behind testcontainers there is a huge cross languages experience, so I hope the API will stay clean as they are or they will even improve!
Fantastic, thanks for the reply and I'll let you know if I get any problems (or if it works too probably :) ).
Versioning/vendoring and the workspace layout. I think this is much better solved in languages where the tooling tries to mimic NPM. But I haven't tried go dep yet.
[removed]
I'm curious what you're doing, and how you can work with ~~json~~ data without knowing what's in it
This guy Goes
The \`html/template\` package gave me an awful lot of hell, especially when reading through the docs. I got stuck on global/local context (difference between `.` and `$.`), template context passing and such.
I hear ya. This took me ages to get a good grip on, and it's really just because channels are a half-baked feature. `context.Context`, which should be part of the language, is a symptom of that. Well, the timeout/cancellation aspect is, at least. The "WithValue" part of it is just a symptom of someone having a really bad idea! Channels are the beginning of something really awesome, but that's all they are, a beginning. Everything else is up to you to get right, which can be tricky, error-prone and hard to prove is correct.
I'm using this one: [github.com/shuLhan/go-bindata](https://github.com/shuLhan/go-bindata) I prefer bindata over all the others because it does not include the net/http package.
if only there was a defer(panic()) for life
It still does not inspire confidence. Is it your repo?
for me it was the lack of support for enterprise modules. Ie, no SSO support for database drivers. &amp;#x200B;
Have you also updated the microservice series? I was a big fan of it, but there are multiple parts that don't work anymore, if I recall correctly.
The code you provided demonstrates a form of the [Single Responsibility Principle](https://en.wikipedia.org/wiki/Single_responsibility_principle). In short, it's the idea that you should separate code into structs or functions that have only one job. &amp;#x200B; While go and other languages aren't necessarily object-oriented, they can still benefit from the lessons of [SOLID](https://en.wikipedia.org/wiki/SOLID) principles. &amp;#x200B; As an aside, I highly recommend you go out and get a copy of [Pragmatic Programmer](https://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1547134181&amp;sr=1-1&amp;keywords=the+pragmatic+programmer). The lessons inside are not aimed at go specifically, but rather generalized for any programming language. &amp;#x200B; Hope this helps!
I know that's a given for professional organizations but the discussion so far is incredibly pragmatical and constructive for something that's quite the deal like transferring ownership of `dep` project. The proposal itself seems like a win-win in my book.
Absolutely, I'm talking to the owner of Micro in the next week or two, and I'm going to get it updated :) 
Hi Ewan, nice blogpost. I've been working on a serverless app lately aswell and our code looks very similar. I even 
Nope. not mine. I should probably clone it and maintain it myself ...
Using panic doesn't make for interesting explanations of why defer is useful. It's useful because it can be added optionally (e.g. sometimes you're writing to a file that should be closed, sometimes stdout) or because the return flow is confusing and you need to ensure a lock is released. It's both a simplification for the programmer and a hedge against accidental bugs from a maintainer, and also couples cleanup with the need for it together in code. I didn't get the sense of this from the post, only that defer helps guard against rare panics.
My biggest confusion in all of this, is what is "gofrs"?
What's your use case?
&gt; making it unusable If that truly were the case, there wouldn't be so many applications delivered via web browser today. But it isn't. Yes, some frameworks are heavyweight, but we're living in the era of fast internet and mobile devices with GB of RAM... it all still works.
It looks like self-promoting “independent” community. Reminds me of that XKCD comics with standards. 
Correct me if I'm wrong, but those don't allow for library clients to create enums effectively, i.e. the library cannot rely on the enum type to guarantee that client-generated values are one of the ones defined in the `const` block.
&gt; couples cleanup with the need for it together in code This is, by far, the biggest benefit of defer. After having done years of kernel coding, where one uses a `goto` to jump into some cleanup block of code from an error condition, golang has been a breath of fresh air. Error handling is much cleaner and the code is much more readable.
[removed]
[removed]
Please read the sidebar about the Code of Conduct. Your attitude is not appreciated, nor do you need to take (or make) this personal. We're talking about programming here. I'll state it again: the web browser is a cross platform GUI. We're both using an application right now -- Reddit -- that's usable through the browser on any number of platforms. [There are plenty of libraries](https://github.com/avelino/awesome-go#web-frameworks) that can be used to handle the interaction between your app and the browser. Sure you can identify some use cases that might not work, but it's more likely that you can rework your use case to fit a Web UI, than the other way around. Also more cost-effective: companies that release applications to multiple platforms often need a team dedicated to each platform as anything "cross-platform" will have its own quirks that need addressing. The web is no different, has its own platform-specific quirks, but given the way the app is delivered the surface area for bugs is much smaller. One doesn't have to chase down platform-specific networking bugs, for example, because HTTP/TCP is thoroughly exercised on every platform. Again, I implore you to check your tone and check your ego. Absolutely no need to make the web any more toxic than it is today.
Use one of the many libs to embed static files. Then try running UPX on the compiled executable: https://upx.github.io/
Honestly, I think it's fine to work that way. I just wish they wouldn't make any claims to be or represent "The Go Community". Why not just be "a community of Go programmers"? Optimally with some shared goals? e.g. Suckless isn't "the C community", but they still managed (for better or for worse) to gain a reputation and a certain amount of trust in their software. Even then, with the vast majority of people, I'd probably *still* be fine with their self-identification - but I know that some of the people in that group *do* genuinely see themselves as representing "the Go community" and given how often I disagree with them, I find that messaging frustrating.
Maybe use https://ipstack.com/product (10000 req/month free) and no need to bundle a 30mb database. (*I didn't try the product and it's only the first search result that I found). There isn't/shouldn't always be a technical fix where using a service will do.
I haven’t tried the community edition, but I believe it’s free as long as you keep up with updates?
Also, reducing the database to only the countries you need might be a good option. If you need to limit access (and not just detect it), then it's likely you can throw away 90% of that geoip file and just leave in the country(-ies) you need to allow.
[removed]
While that is true, I don't see why that would be a problem unless you're iterating over your enum instead of using a switch with a default.
Buffalo (https://gobuffalo.io/en) speeds up web development in go with combination of "runtime" framework + code generation. I haven't gone deep into it myself, but and as far as I can see it delivers on the speedy development experience promise.
An idea I like is to keep all code within a function at the same level of abstraction. So a function that contains some low level loops on arrays of ints as well as higher level function calls could be said to contain code of varying levels of abstraction, and could be refactored. I find this rule of thumb helpful
Replying to your comment here since you deleted it in the middle of me typing up a response: &gt; Please read the sidebar about the Code of Conduct. Your attitude is not appreciated, nor do you need to take (or make) this personal. We're talking about programming here. &gt; &gt; I'll state it again: the web browser is a cross platform GUI. We're both using an application right now -- Reddit -- that's usable through the browser on any number of platforms. &gt; &gt; There are plenty of libraries that can be used to handle the interaction between your app and the browser. &gt; &gt; Sure you can identify some use cases that might not work, but it's more likely that you can rework your use case to fit a Web UI, than the other way around. Also more cost-effective: companies that release applications to multiple platforms often need a team dedicated to each platform as anything "cross-platform" will have its own quirks that need addressing. &gt; &gt; The web is no different, has its own platform-specific quirks, but given the way the app is delivered the surface area for bugs is much smaller. One doesn't have to chase down platform-specific networking bugs, for example, because HTTP/TCP is thoroughly exercised on every platform. &gt; &gt; Again, I implore you to check your tone and check your ego. Absolutely no need to make the web any more toxic than it is today. You knew exactly what the person you were replying to was talking about when you made that comment and you made it anyway. Your disingenuous quips are no less toxic because you're trying to mask them behind a thin veil of constructive discussion. If someone is complaining about the lack of a car, me suggesting that nobody needs cars because trains exists is a stupid argument. Maybe learn some social skills and understand the context of a statement before being dismissive. While you're at the social skills development, try to learn that just because you're not being overtly rude doesn't mean you're not being rude.
1. This is a Google unrelated matter. 2. Google and Go community are not two opposite parties.
I've heard of it as well. This would be more of a hobby project for fun and learning, so really the only blocker for me would be if another framework has already taken this exact identical approach (basically copying Django REST's viewset/ serializer approach).
Which is kinda why I was confused learning it. Why would you ever pass by value at all?
The only language I use other than HTML that's supported in the Community Edition is Python, and it lacks the Django-specific support that the full version has which is what I use for web apps.
You can use the XML, I've done it for all my projects
This gotk3 library? https://github.com/gotk3/gotk3
this is awesome, thanks!
Poor tools in combination with the nazi lint strategy with errors on unused imports, variables etc. Mixed casings. Mixed abbreviations. Is it ln, line, Line? And the built in functions should be removed and added where they belong cause it’s just confusing.
Finding use cases to use channels and goroutines. Professionally I haven't really needed to use channels at all, and I've used goroutines to the extent of just using sync.Wait to have multiple goroutines 'do' things but that's it. On my own time, when I try to work on this 'weakness' I end up learning it pretty well for the day, doing something super simple with it as an effort to apply the knowledge, then forgetting how things work soonafter. While I understand a lack of consistency is a fault on my part, I still don't have any use case or exercise that will make me confident enough to say, 'yes, I understand channels and goroutines and I'm confident about how and when I should use them.
Most of what I do is web services so I suppose this comes naturally, but personally I just gave up on native GUIs with Go. Everything is a web service, even things that only run on my desktop. If something absolutely positively must have a native GUI (rarer than most people think), I put Go aside for a moment and do that particular project in C# or Swift. (Haven't been tasked to make a native GUI for linux, but I guess I'd hop over to something like GTK+ there.)
I'm sure I've had problems that were less memorable, but in an apparently unusual note, the biggest thing that tripped me up as a newbie was GOPATH. It took me literally days to wrap my head around the concept of a go workspace where *ALL* my code, regardless of project, would be located. There were other pain points, but nothing else stands out to me the way that one did.
Ahh, I see it’s free for JVM stuff but not Go. I was just now looking at the “Discounted and Complimentary Licenses” they offer: https://www.jetbrains.com/idea/buy/#edition=commercial It’s quite a generous list. I ended up just paying for it myself so I could use the tools for whatever I felt like. Aside: my other language is Clojure, and the Cursive plugin for IntelliJ is similarly leaps and bounds ahead of anything in the OSS community. Being able to jump from a definition inside my Clojure app to a Java dependency and have it download the relevant source or simply decompile the class files dynamically is totally magical. For most open source editors, jump to definition barely works properly in the same language, let alone working reliably across language boundaries in the absence of source code!
Context package. I've tried so hard to kinda get it but it's weird because it only really works with channels but the godocs mostly don't use channels. So understanding exactly what's happening in different situations is hard to wrap your head around.
I can read this 100 times and still not have a mental model of what's going on or how to use this in different situations. https://blog.golang.org/context
I've looked into an open source license before but the requirements are super strict. And yeah. Every time I fire up Atom, Sublime, or VSCode I run into annoying quirks that just don't exist in JetBrains products. With a lot of customization I can get VSCode to 95%, but the older I get the more I just want shit to be the way I like it out of the box.
Honestly just haven't spent enough time attempting to use it, as I haven't connected the dots of "this is a situation that could benefit from using \`select\`".
[removed]
Nevertheless, it still works well.
Yes. What I would need is the correspondent of the widget "GtkGLArea". I couldn't find it anywhere...
dep is used across the board by big and small projects. It is a big matter who has direct commit access to it.
[removed]
&gt; It tends to be more efficient as well due to the constant size of a pointer vs the dynamic size of something like a slice (perhaps a bad example since a slice is a pointer itself i believe?) , so pointers to structs are faster esp. if the values are large. This is almost never true, and you should almost never make a reference-or-value decision based on your intuition that the struct is "large". The only situation I've ever seen it matter is if the struct contains a 100+ element _array_ (not slice) of nontrivial values.
I don't think it's a big matter unless you assume whoever has commit access will act maliciously (which includes leaving the project to rot).
The only reason I made the example with panic is indeed to showcase of something really goes wrong the deferred code is executed. Indeed for things like db connections, file handles or stuff like that. Thanks for your feedback.
Agree. Maybe it is not bad to discuss how to transfer the project in a proposal. However, I think it would be better to discuss this matter in go-dev group.
 "tests" You know when you are writing good code when you can test it. If you put all code in one big function most probably you can not test everything and it will be harder to modify the code at a later step of the project. Consider testing the functions, than dive in into architectural principles and last algorithms. Pragmatic programer it is about the mindset of the programmer but since you are questioning code and are trying to improve yourself, you are probably already there. 
I guess that you're referring to https://github.com/gotk3/gotk3. There's also https://github.com/pekim/gobbi/ that I've been working on.
[https://github.com/mkouhei/gosh](https://github.com/mkouhei/gosh) not the first Go shell called gosh :P
[removed]