Curious. Why do these projects use Tinygo when Go supports WASM as a target.
been a while for me working with rabbitMQ, but i think there was an option uppon creating channels defining if they are permanent or not. if they are not, they will be deleted by rabbitmq anyway once all listeners/clients are gone
https://github.com/Shopify/sarama
I completely agree it's filesystem job in theory. And from very little that I know, btrfs is one of those that actually care about data blocks checksum; ext3/4 that we use, only checksums its journal and files metadata. Will research above statements.
As far as i know, there’s nothing magical about background processes. They are just processes that don’t stop. You could do this in one line: time.Sleep(5 * time.Minute) Windows only makes processes look magical because they can hide their system icons etc.
I'll generally have a combination of your #1 and #2 in any sizable and long running application. For your #1 situation I'll use that where lots of adds and/or updates to the database are going to be occurring or where ensuring the users only "see" one instance of the data is important. Go is a bit different from other languages in that I find I don't use getters as much as public fields for this case. I also tend to map these closer to 1:1 with underlying tables. That works great for locking granularity and push notifications for clients if needed. Then I send updates through theses objects and think of them as cached chunks of the data. This works especially nicely where you're only a couple levels up from your leaves in your object/ER hierarchy. It means you're typically working with a well defined subset of business logic too. Your #2 technique is basically my go to technique for reports and view only data. It's super easy to write and performs really well in Go. Your "top 5 people with the most disliked foods" to me falls immediately as a #2 case. I'd go that route until you find a reason not to. I wouldn't sweat the one or two query stuff unless your getting into an n-squared query loop. Databases figure out how to cache stuff pretty well these days and you can just leave it to them until you hit a performance bottleneck. Code what's easiest to understand and maintain first. Finally, don't get too paralyzed by all this. If you're stuck in Go it's often better to just start coding stuff and see what falls out. The wrong path will usually become overly complex pretty quickly. Go's not as much like other languages where you're loath to make changes because you've gotten so wrapped up in a complex framework.
I am the only who thought this a linux package manager clone, and even wondered, how can be run on windows, or is just me?
\[NATS Streaming\]([https://github.com/nats-io/nats-streaming-server](https://github.com/nats-io/nats-streaming-server))
I would avoid using NATS streaming. It’s immature and has massive problems at scale. Source: used it and got screwed over badly, and to migrate off of it
It's not quite credible as reading sources or at least documentation, but here's undisputed stackoverflow answer: [https://stackoverflow.com/questions/31345097/can-ext4-detect-corrupted-file-contents](https://stackoverflow.com/questions/31345097/can-ext4-detect-corrupted-file-contents) it's "no" \[protection against media degradation on ext4\].
Maybe I'm talking about wrong point. If you expect the hardware device making checksum guards, then I can't imagine how to test if that's true or not. Do you?
Not to say anything about which library is good or bad, but "more recent" isn't really a good argument pro/con a library? On the contrary perhaps, gorilla has been stable and production used much longer which might make it a safer bet.
You’re absolutely right. What I really should’ve said is something along the lines of both x/websocket and gorilla/websocket have fairly problematic APIs that they’re unable/unwilling to change, and nhooyr/websocket was able to learn from their prior art. In this case, “more recent” means “able to learn from the mistakes of previous libraries in the space” imo
I don't doubt it, but this is basically a wrapper for cmd which will be flagged once you do anything suspicious.
We use nsq.io to process millions of messages daily; it's super stable; we didn't have any stability and performance issues for the last three years. But you have check whether it fits into your stack https://nsq.io/overview/features_and_guarantees.html
I'm going to an investment bank next year, which is probably worse, but at least I'll get paid.
Howdy, Matt, thanks for the Caddy info! The endpoint needs to know about the prefix because it's dynamically generating links to assets. The blog post talks about `/static/application.css`; the browser needs to request `/faktory/static/application.css`.
[`x/net/websocket`](https://godoc.org/golang.org/x/net/websocket) - The documentation recommends to use `gorilla/websocket` instead. [`gorilla/websocket`](https://github.com/gorilla/websocket) - RFC 6455 compatible and passes the Autobahn Test Suite. Currently looking for new maintainers but bugs are still fixed. [`nhooyr/websocket`](https://github.com/nhooyr/websocket) - Does not implement RFC 6455 completely (this is not necessarily a bad thing) but passes the Autobahn Test Suite. Influenced a lot by `gobwas/ws` [`gobwas/ws`](https://github.com/gobwas/ws) - RFC 6455 compatible and passes the Autobahn Test Suite. Has a low level API and high level wrapper. Highly optimised memory and IO usage. (Personally I prefer this library.)
This couldn't have come at a better time.
Makes sense, thanks for clarifying.
For a second I did wonder whether they meant the package manager or the game...
&gt;Does not implement RFC 6455 completely (this is not necessarily a bad thing) Are you referring to the [close handshake issue](https://github.com/nhooyr/websocket/issues/103)? To be fair, none of the other libraries implement the close handshake either, they rely on application code to handle it and I don't think anyone actually does because it's not very useful.
I was looking forward to the tutorial and thought they meant the package manager. Only when I clicked step 2 I realized that the game is meant.
I'd say Go is perfect for this use case. A lot better concurrency story than C and C++. As long as you don't allocate in the hot path you will be fine. Make also sure to use asynchronous system calls. This way you get outstanding performance for comparatively small effort.
Yes, I think the CRC is checked directly by the HW or not later than in the device driver. At the level of the file system it would a bit too late. File corruption OTOH at the FS level may substantially slow down operations for programs that for any reason do not need that. (Imagine temporary files, for example.) so I'd not expect that to be the norm.
on average nothing could be further from the truth. enjoy your unicorn scenario and I hope they have enough runway to keep the checks coming. good luck.
Thanks for the correction and sorry that I mentioned this without looking into it. Last time I checked there was an on going discussion about Ping/Pong messages but now I see that it was implemented in may way before the v1.0.0 release.
Maybe I just skipped past the uninteresting comments a lot where people just were complaining without really making an argument and don't remember it correctly either. I think that new proposals should be coming. One thing that I don't see many other people saying is that I would like parametric polymorphism to be prioritised ahead of stuff that might make use of it depending on how it turns out.
wise choice young man. work your way towards a manhattan hedge fund. you'll become an entitled prick but you'll be drowning in money and pussy.
I'm a girl LOL
Not necessarily, as such. In some cases, incorporating it into the stdlib would mean merging it with existing stuff, resulting in semantic changes that could break existing code (e.g. the new `xerrors` package) -- so one wouldn't expect to see that get promoted to stdlib until at least Go 2. In some cases, the functionality is _widely useful_ and/or there's a sort of "public interest" in getting it "right" -- but not _so_ widely useful that it's likely to be viewed as worth adding bloat to stdlib (e.g. `oauth2`), but it'll probably be actively maintained for a long time. And, of course, any particular package might not wind up getting the love/attention it needs -- especially if a third-party package comes along that outpaces it, and may just wither on the vine (see scarhill's quoting above of the docs for `x/net/websocket`). Basically: You can depend on the `x` stuff to not be malicious, and to have a certain degree of care/effort put into it in terms of API design, code quality, backwards compatibility/SDLC. You can depend on it to follow the golang team's design sensibilities and idioms. Don't expect it to be full-featured/batteries-included, and don't expect stuff in `x` to see as much love/attention/maintenance as the stdlib proper.
https://godoc.org/github.com/golang/glog See V(n int).
Every time I used UPX, dozens of (lazy) antivirus softwares on Windows falsely flag my binaries as viruses so if you happen to deploy to windows, I would advise not to do that.
It's not really a unicorn scenario if you simply ask, "Are you cashflow-positive?" during the phone interview... which any sane adult should do.
good for you but reality is nyc startups notoriously have shitty hours, pay offset by options, and lack of structure and maturity. im unfortunately all to familiar with the scene here and its not a pretty picture.
Rust-style enums (sum types) specifically :)
This is really nice! I love how you get into each step and explain the process
Btw I use Arch
That is interesting, but I still need some mechanism to decide on the value of V at the place where the error occurs, but actually log it at the handler/main level.
as an aside, I utilise arch
I tried to use x/net/websocket for some project, but at the time it didn't support "largish" packets. I then switched to gorilla/websocket that worked for my use case. Note that relatively recently (April) the mantainer for gorilla/websocket posted this: https://github.com/gorilla/websocket/issues/370
&gt;The trouble is that it is justified (nay, necessary) in most cases Not remotely true, unless you're trying to simulate a stack trace, in which case, we should have try AND stack traces.
A short article about the init functions - That's not a complicated topic, but I hope it could still be useful - any feedback welcome
Finally!
This article misses the most important thing to say about init functions, which is that their only purpose is to mutate package global state, and therefore they are always red flags, harbingers of bad package design, and should always be removed.
Speaking as a moderator of this subreddit: don't do this. Thanks.
because Go WASM binaries are huge (~1-5 Mb) but TinyGo produces ~300-700 Kb. So better use TinyGo in case of WASM
No, no, no. Never use glog. - https://github.com/danderson/metallb/issues/189 - https://github.com/coredns/coredns/issues/1597
So I should have left it up?
Recommending https://github.com/msales/streams. Good lib and easy to use with multiple different sources
Don't do what I did, which is place an order and *then* notice the 20% off coupon code.
What were some of the issues you faced?
I really need to take a look at it
coupon code = Gopher20
Is it somehow possible to open a sub-folder as an Intellij Project while keeping the go.mod in the root folder of the Git Repository? This way I could concentrate on a certain aspect without having the whole structure always around.
already did it. :/
I did as well and sent an email to the contact given at the purchase screen, warehouse \[at\] pinnaclebranding \[dot\] com. They refunded me the price of the coupon within minutes. Best of luck!
Where is the picture in your readme? WHERE!!??
No, as that would mean the IDE doesn't have access to the information needed to correctly resolve all the code in the selected folder.
When in doubt, close it. &amp;#x200B; The articles u/JaegerBurn suggested below are really good. Specifically these two sections may be relevant to your problem: [http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#close\_http\_resp\_body](http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#close_http_resp_body) [http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#close\_http\_conn](http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html#close_http_conn)
&gt;always red flags Sure. &gt; harbingers of bad package design A bit strong; sometimes the "bad design" is in the thing the package is manipulating. &gt; should always be removed No, definitely too strong. I just grepped over my source code; one I found is "init" functions whose purpose in life is to identify _which execution_ of a given program did a thing, by creating a unique random identifier for its lifetime, which is then used by some logging and tracing. There's nothing wrong with this; the "execute exactly once per execution" behavior exactly matches the fact that I want something exactly once per execution. Red flag? Sure. But upon inspection, fine. I find here another one that takes a hard-coded string representing a certificate and converts it into a `*x509.CertPool` for use by other code. It's too complex a transform to be replaced by a top-level `var` (which is just another way of writing init functions anyhow). "What if...?" Won't happen, not a problem, I release new binaries faster than any of the "what ifs" can come up. It's fine.
Dropped messages when queues hit 1m messages, NATS not recovering from failure conditions such as the previous one without manually editing data files or deleting the entire stream, a bunch of stuff. You can see my issues here: https://github.com/nats-io/nats-streaming-server/issues?utf8=%E2%9C%93&amp;q=is%3Aissue+author%3Assoroka
What dogma. Are there ways to abuse init functions? sure. Are there appropriate uses for them? yes. Educating less experienced engineers is in order, not throwing out the baby with the bathwater.
A shame :-) okay thank you for the fast response!
Son of a! I checked the comments, somehow completely ignored all comments about 20% off and then immediately placed two separate orders. Oh well, at least the proceeds are going to a good cause!
Sold out
One approach would be to use the [golang.org/dl/](https://golang.org/dl/)... wrappers: &amp;#x200B; go get -u [golang.org/dl/](https://golang.org/dl/)... go1.12.7 download Downloaded 0.0% ( 15174 / 127614387 bytes) ... Downloaded 3.8% ( 4881210 / 127614387 bytes) ... Downloaded 24.7% ( 31521594 / 127614387 bytes) ... Downloaded 45.0% ( 57408314 / 127614387 bytes) ... Downloaded 58.7% ( 74971962 / 127614387 bytes) ... Downloaded 72.7% ( 92732218 / 127614387 bytes) ... Downloaded 87.8% (112001024 / 127614387 bytes) ... Downloaded 100.0% (127614387 / 127614387 bytes) Unpacking /Users/calamari/sdk/go1.12.7/go1.12.7.darwin-amd64.tar.gz ... Success. You may now run 'go1.12.7' go1.12.7 version go version go1.12.7 darwin/amd64 &amp;#x200B; If you check, it installs a shim for every supported Go version, and you simply run it via that executable (after downloading it through the wrapper). &amp;#x200B; Another approach would be to use something like [https://github.com/syndbg/goenv](https://github.com/syndbg/goenv) &amp;#x200B; imo those are your two simplest options.
I use asdf package manager, use it for go, ruby, node, terraform and it seems to mostly handle everything flawlessly
I'll give it a go! Was looking for something like this recently.
Follow-up. *I'm posting this as curiosity. I'm not making a statement on best practices.* * First, I took the original article's link to the GitHub teivah/pointer\_test.go page and made a few changes. I removed the JSON parse and I only use one struct called foobar just to shorten the code. I also added a "Count" field just to have some "work" done at various places. Here's a playground link (that can't be run AFAICT): [https://play.golang.org/p/C5to8E0S97J](https://play.golang.org/p/C5to8E0S97J) * Second, I added a "byAutoCopy" function and benchmark. This shows the cost of copying the foobar struct by value into the function but not creating another instance of it. * Third, I added a "byRef" (\*1) function and benchmark. This shows the cost of passing in a \*foobar that's already allocated on the heap. This would be a typical scenario where you've pulled your structs up onto memory from, for example, a database and are now going to do something with them. This is what I would consider "typical" pointer use for my code. *(\*1: "Golang pros use pointer and reference interchangeably (TM). Golang too!"* * Finally, I added a "byNothing" function to try to factor out the overhead of setting up the call stack. The results on my machine: BenchmarkByPointer-8 20000000 82.9 ns/op BenchmarkByValue-8 50000000 33.6 ns/op BenchmarkByAutoCopy-8 200000000 7.99 ns/op BenchmarkByRef-8 2000000000 1.66 ns/op BenchmarkByNothing-8 2000000000 1.65 ns/op The ByPointer and ByValue calls were as the article stated. Escaping pointers do take their toll. The ByAutoCopy is quick. Automatically creating/copying a foobar on the stack on the way into the function takes some time but not as much as I would have guessed. ByRef is super quick. Once an instance is on the heap passing it by pointeris not a performance hit. How little? ByNothing shows the overhead of the function call itself. Take that away from the ByRef call and passing a struct pointer to a function is about as "free" as a parameter is going to get. What's my general takeaway? Don't fret about passing around lots of pointers in and of themselves. They're fine in Go for the appropriate tasks. Just be aware of where your structs might escape to the heap and then how often those pointers will be reused. As all the linked articles in this thread point out, there are situations where you'd be better off passing and returning by value.
I wish they'd let us order sold-out items with the understanding that it will take longer to arrive.
Sweet! If you have any questions feel free to open a GH issue.
Docker is the most system agnostic solution.
I am disappointed that they only accept CCs.
Sold out so fast...
To be clear, this is a Kafka client for Go. But Kafka Streams specifically are only available for Java.
&gt;When you've decided to pass around a struct instance as a pointer you've probably already decided you want the data to be mutable and that you're going to pass around the same reference repeatedly Not necessarily. Actually, from my experience, a lot of Go developers use pointers in and out because they believe that it will be faster regardless of the situation, that's all. They do not necessarily thing about using pointers because it can be shared as you mentioned. Thanks for the constructive feedback though. I'm gonna rework a bit this part because indeed, the benchmark is not here to discuss a typical reference use. I'll try to be clearer.
One nifty thing, I thought, was how we [check for extra keys when validating](https://github.com/elastic/go-lookslike/blob/master/core.go#L51) using binary search. The code's somewhat similar to the materialized path pattern in a database. There's probably a more optimal way, but practically this is pretty fast, and pretty easy to code with the go stdlib.
1. Make sure the util package does not rely on other packages in your project. 2. Unit test it
This might help you think about what you are trying to accomplish: [https://dave.cheney.net/2019/01/08/avoid-package-names-like-base-util-or-common](https://dave.cheney.net/2019/01/08/avoid-package-names-like-base-util-or-common)
Agreed. utils is not a great package name. Think about what you're trying to do and name it after that. Eg: I needed a couple functions to encrypt or decrypt email addresses before storing them to the database. Rather than making a util package for this, I ended up putting it in \`lib/crypto/email\`. Another couple functions for manipulating string slices ended up getting pulled out to an external library specifically for this (see [https://github.com/ssoroka/stringslice](https://github.com/ssoroka/stringslice) if you are curious).
Use configurable log levels such as debug, info, error, etc. and library that supports them such as https://github.com/sirupsen/logrus or https://github.com/uber-go/zap and than you can provide cli flags or config options to decide what to log.
I really wish they had the blue vinyl gopher, been hoping to get one for a very long time now. But at least its nice to have an official store!
If you like adventures starups are great, but you have to reconsider this decision every 12 months :)
So if I have a few methods which validate and do some other stuff related to Files should I make a class called FileUtils or FileHelper instead? Like being more specific with the purpose?
Try keeping the package names simple. How about `files` and `validation`?
Sounds cool but I'm not too hot on the $16 shipping on a $15 plushie
SO glad they don't label everything as .99
there is genuinely never a good case for an init function. *ever*. if you can name a case for them, i bet i can always offer a better alternative.
completely agree. i've been called "a purist" (in a derisive way) for saying this but it has played out that they're always problematic every time i've encountered them.
Hey guys, I created this package. Tell me what you think :)
there are no classes in go.
I'm already using logrus, but I need to somehow distinguish between the errors that should only be logged during development (auth/bad requests) and the ones that must also be logged in production (database connectivity issues). &amp;#x200B; I guess I could use the Debug level to log the non-critical errors, but that feels a bit weird. &amp;#x200B; And since the logging happens far away from the place where the error occurs, I need some way to store the logging level of the error in the error itself. Would you consider this a good approach?
If it helps, it's going to a good cause :)
Interesting project. Will take a look.
Thank you for including a comma in the title. I thought you were just missing a space at first
Depends on your needs, but in general everything above info level should be logged into external tool such as logstash/elastic/stackdriver/any other tool just to aggregate them and set alerts on huge spikes of such messages. But of course you can log all levels to the external tool and than investigate.
I've had the same multi-version requirement when maintaining a Go OSS package, and I ended up using the same tool that my CI uses: [`gimme`](https://github.com/travis-ci/gimme). Works well enough.
16$ shippment :&lt;
What should we call them then?
Alright. I like your suggestions. I understand your point now.
Goka is probably your best bet here
We use kubernetes and fluentd ships all logs from stdout/stderr to elsatic so that's not the issue. &amp;#x200B; However many of the errors are not actionable while producing a large volume of logs (e.g. when a user provides incorrect password or provides incorrect input to an api endpoint). It seems logical to not log those at all in production, but only log the critical errors (e.g. infrastructure problems). During development however, it is useful to log the non-critical errors as well. &amp;#x200B; As far as I'm aware, there is no way to configure logrus to only log Info and Critical errors in production, but log Debug, Info, Non-Critical errors and Critical Errors during development. This is why I was considering to use the Debug log level for the Non-Critical errors but that doesn't feel too great.
***SOLD OUT** INTENSIFIES*
i think you're talking about a package.
I'd easily take a judgement call from Russ Cox over one from a community vote.
I’m doing this in unix/macOS
These packages tend to become junk drawers. But if you absolutely must i second this ^^
Coming from Java I would think package as a directory with class files. Thats why I'm bit confused with the terminology
that's fine -- i get it. here's some advice that you should really take: forget all of the terminology and concepts you've learned in Java (and C++ if you've used it). try to learn go with an "empty cup" so to speak. learn go's terminology and idioms. if you have any question about what something is called, read and use the go spec's terminology.
Well, since everything good already sold out. _What else can we discuss while we wait for stock..._ Is it just me, or did they add a bunch of fake tattoos to the male model? - https://cdn.shopify.com/s/files/1/2606/6960/products/mRun_tee_fnt_360x.jpg?v=1558714817 - https://cdn.shopify.com/s/files/1/2606/6960/products/mGrad_tee_bck_faf7d5a0-97ef-4d87-b250-42d2e62d8a5e_360x.jpg?v=1558714825
The gopher is so damn cute
&gt; The entire server is a structure that should not have delays in the router and sender. What does it mean? What is acceptable delay for you? There is no such thing as no delay, there is always some kind of delay, created by your OS networking stack, kernel NIC drivers, OS scheduler etc. But I don't think you need to worry about any delay if you are passing it to python. &gt; Which language is better in terms of performance? If you are asking those things then you don't know any of the languages? If you don't then just use Go, it's simpler than C/C++ and it will meet your requirements. In case of sender if you don't need to read the packets then just use io.Copy, it uses splice under the hood so the packets stay in kernel space without copying to userspace. You can also send multiple packets with one syscall.
That does help; I'm leaving my order as-is.
If you're not into microcontrollers, the most interesting thing about TinyGo is that it can produce small WASM binaries: kilobytes rather than megabytes.
No Mugs?!
ooh: Also, realistically, since we don't have unlimited resources, I see thinking about language support for error handling go on the back-burner for a bit in favor of more progress on other fronts, most notably work on generics, at least for the next few months. source: https://github.com/golang/go/issues/32437#issuecomment-513002788
Hopefully this works for me too. Was too eager!
It's not too bad if you order a hoodie too...
No need for a class. Just make functions.
&gt; this person Hi, did you get your issues resolved? I am facing similar issue.
Nah he got that one on his right arm specifically to match the hemline of his T sleeve. He just loves Go that much.
I get those complaints, these are not issues I've personally had or wasn't able to work around. I forked glog locally and made stderr only logging the default (among other changes), and use that for my projects...other than "it uses files", I don't really see anything actually terrible, unless I missed something.
Thanks I'll give it a try.
I guess writing the site in Go would have been a lot more work than using Shopify, but at least it looks nice. :)
&gt;other than "it uses files", I don't really see anything actually terrible It registers flags in the global flag set, and will panic your program if certain common conditions are met.
WHY ARE YOU SCREAMING??
I plan on using this framework in conjunction with the developer to make some app tutorials. Any suggestions on simple apps you would want to see?
Have a search for “type assertion”. This will allow you to get a concrete type out of a returned interface value.
Thanks for the reply. In that case, my resulting code would look like this: v2 := v.Normalize().(Vec3) This seems pretty heavy and error-prone. Am I understanding your type-assertion suggestion correctly?
Interfaces are a way to abstract away the implementation differences of types that do the *same things*. For this definition "same thing" is very explicit, and refers to having the exact same method signatures defined in the interface. While all of your types support a method called **Normalize()** that returns the same type as themselves, the (ideally) different return types don't satisfy this definition. In short, interfaces don't really work this way, and you need type switching :( If your usecase supports it, what you COULD do is make it a mutating method with no return, but this would break the functional nature. &amp;#x200B; Having said that, one of the primary reasons to use interfaces is in passing many different types that satisfy it to a function, or having a property or variable that you can swap different things out of for dependency injection or customization. I can't tell from your example if this is something you need, but if it's not, you can always just give them all the same method name and rely on the user to read the godoc to know that they all support it.
Thank you, this was very helpful! I've been reading a bunch about this, and I can tell it will take some getting used to thinking about interfaces a bit differently than languages like C#/Java/TypeScript.
That is how you would do it, yes. But, like I mentioned below, I still don't see why you need interfaces yet. I don't see any functions in your example that explicitly take a **Vector** type. If you do, the amount of effort you need to spend is basically t\*f where t is the number of distinct implementors you have and f is the number of functions that take it, and in each one you would need a type switch like `switch vec := v.(type) {` `case Vec3:` `// do something with vec as a Vec3` `case Vec4:` `// do something with vec as a Vec4` `default:` `// maybe return an error about an unsupported vector type` `}`
Another thing you could consider is just going all in on the interface as a generic matrix representation like [gonum](https://github.com/gonum/gonum/blob/master/mat/matrix.go) does.
Yes, please.
Duly noted.
Is the reason why there's so much go swag compared to other languages mostly just cuz the mascot is particularly cute?
Brief observation on this code: good commenting. Always be verbose about your weirdness, comments are zero bytes when compiled.
Criticism of dogma is fair, though I would argue that one of the primary responsibilities in educating less experienced engineers is teaching them early how to avoid some of the most pernicious runtime bugs, which **init()** functions are especially adept at causing. When considering the issue from the point of view of novice programmers, I think it is unfair to say that **init()** functions are "lazy" as some other commenters have, because that's a value judgment, and it's always best to assume best intentions. I stop short of calling **init()** completely useless, but I think that 99% of the time Peter is absolutely correct, and that best standards around using **init()** should be so tightly circumscribed that linters could be written to alert on it.
I wonder if it is actually built it in Go or are they using something like Shopify or Magento
Thanks for the input, I had not used it in anger.
This is a little bit sophisticated, so bear with me: Interfaces are best thought of as _behavioral contracts_. When you write some code that needs an X in order to do its job, the best way to specify X is as an interface, with the methods that your code needs. If you use interfaces in this way, they can also be thought of as _consumer contracts_, because they're being specified by the code that consumes (uses) them, not the code that produces (defines) the things that implement them. Your example of a vector math library, using concrete types like Vec2, Vec3, etc. isn't a great one to exploit the power of interfaces, because, as you've discovered, Go's relatively poor type system doesn't allow you to encode your intent. Due to that limitation, if I were you, writing that package, I wouldn't use interfaces at all. I would just write e.g. func (v Vec3) Normalize() Vec3 { m := v.Magnitude() return Vec3{X: v.X / m, Y: v.Y / m, Z: v.Z / m} } If you really wanted to play with interfaces, you might say that methods like Normalize would mutate the method receiver, rather than returning a copy, e.g. func (v *Vec3) Normalize() { // note: pointer receiver and no return value m := v.Magnitude() v.X = v.X / m v.Y = v.Y / m v.Z = v.Z / m } Then, you could define a Vector interface as type Vector interface { Magnitude() int Normalize() } But, I probably wouldn't do this. It's generally better to let your callers define _consumer contracts_ for your types on their own, based on the methods they need from them. Vector might be a bad example, because maybe your callers would always need both Magnitude and Normalize. But consider e.g. the concrete net/http.Client, which has this method set: type Client func (c *Client) CloseIdleConnections() func (c *Client) Do(req *Request) (*Response, error) func (c *Client) Get(url string) (resp *Response, err error) func (c *Client) Head(url string) (resp *Response, err error) func (c *Client) Post(url, contentType string, body io.Reader) (resp *Response, err error) func (c *Client) PostForm(url string, data url.Values) (resp *Response, err error) If you have some code which uses only the Do method of an *http.Client, you could define a consumer contract interface as type HTTPClient interface { Do(*http.Request) (*http.Response, error) } Go's implicit interface satisfaction means the real *http.Client automatically satisfies this interface, and now you've got a nice place to insert a mock client in your tests.
The goal of this article was not to say if it is good/bad design but rather explaining how it is implemented in Go :)
I'm not convinced. Usecase 1: something like `NewUniqueLogger()` in `main()` that you pass around. Usecase 2: Maybe I'm misreading, but you talk about security, but put certificates in your source? That's just as bad for opsec, probably worse. Why not pull from a secret store? If this is absolutely intolerable somehow, what about `-ldflags "-X..."` or customizing your build to generate a special .go file containing the constant you want?
&gt; I just grepped over my source code; one I found is "init" functions whose purpose in life is to identify _which execution_ of a given program did a thing, by creating a unique random identifier for its lifetime, which is then used by some logging and tracing. There's nothing wrong with this; the "execute exactly once per execution" behavior exactly matches the fact that I want something exactly once per execution. Do you test this behavior? Assuming yes, how do you ensure multiple program executions produce different IDs? (Kind of a rhetorical question: you can't, at least not easily.) Is that ID actually a property of the process? Or is it a property of the root of the component graph of the program? It's almost certainly the latter. Package globals are necessarily singletons in a process space, and very few things meet that description. A PID would be one, and os.Std{in,out,err} is another. I'm not sure there are many more. If instead of using init to generate that ID, you had a function to do it, you could call that function in `func main` and achieve _exactly the same behavior_. In fact, your program would be even easier to grok, if the components which used that ID had to take it (or a proxy for it, like a base context.Context that contained it as a value) as a dependency. I stand by my claim. For essentially all industrial (i.e. line-of-business) programming, init should never be used.
[https://medium.com/@cep21/preemptive-interface-anti-pattern-in-go-54c18ac0668a](https://medium.com/@cep21/preemptive-interface-anti-pattern-in-go-54c18ac0668a)
I've been messing around with this for a while and I'm still stumped regarding how to create the next key:value pair. My thought is that I need to split it off after the *252* so that will be the value for the key _Enclosure Device ID_, then the next key would be _Slot Number_ with the value of *2*. The problem that I'm facing is I can't figure out how to grab the *next* colon since Index only grabs the first and the initial one isn't deleted from *val* so it still grabs that.
A fair criticism, especially when a link you found interesting immediately finds itself with a soapbox set up in its comments section. However, this doesn't read like a simple article on the implementation of `init` so much as a language tour, and you could make the case that any tour of the language should admit that `init()` is contentious and go to greater lengths to describe why this is so or best practices around it, especially when there is a dearth of material on the topic already. And, much as I've seen people tell me how useful `init()` is over the years, I have yet to find a use-case that truly convinces me. ¯\\\_(ツ)\_/¯
Thank you :) I think these are the most simple and important things
I totally agree with you - however, taking aside in favor or not to init function will lead to endless debate... that's why I wanted to focus on the implementation only \^\^ &amp;#x200B; `especially when there is a surfeit of material on init() already` Again, I totally approve that point, and with this article, I tried to bring more details compared to what exists already on this topic
We want mugs !!! With if err != nil boilerplate :D
You should use \`knownathlete\[0\]\` instead of \`knownathlete\[:0\]\`. &amp;#x200B; The first one takes the first element from \`\[\]\*workout.Athlete\`) as explained here: [https://golang.org/ref/spec#Index\_expressions](https://golang.org/ref/spec#Index_expressions) &amp;#x200B; The second one creates an (empty) \_subslice\_, which also has type \`\[\]\*workout.Athlete\` : [https://golang.org/ref/spec#Slice\_expressions](https://golang.org/ref/spec#Slice_expressions)
[removed]
[removed]
!remindme 14 days
I will be messaging you on [**2019-08-02 05:59:09 UTC**](http://www.wolframalpha.com/input/?i=2019-08-02%2005:59:09%20UTC%20To%20Local%20Time) to remind you of [**this link**](https://np.reddit.com/r/golang/comments/ceuxvk/announcing_the_new_go_store/eu72l1j/) [**CLICK THIS LINK**](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=%5Bhttps%3A%2F%2Fwww.reddit.com%2Fr%2Fgolang%2Fcomments%2Fceuxvk%2Fannouncing_the_new_go_store%2Feu72l1j%2F%5D%0A%0ARemindMe%21%202019-08-02%2005%3A59%3A09) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete%20Comment&amp;message=Delete%21%20ceuxvk) ***** |[^(Info)](https://np.reddit.com/r/RemindMeBot/comments/c5l9ie/remindmebot_info_v20/)|[^(Custom)](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=%5BLink%20or%20message%20inside%20square%20brackets%5D%0A%0ARemindMe%21%20Time%20period%20here)|[^(Your Reminders)](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List%20Of%20Reminders&amp;message=MyReminders%21)|[^(Feedback)](https://np.reddit.com/message/compose/?to=Watchful1&amp;subject=Feedback)| |-|-|-|-|
Damn, thought this was an App Store for Go...
Thanks for adding some nuance to the discussion! Genuinely appreciated! I agree with you -- I'm certainly not trying to advocate the use of init functions. They're definitely something that's worthy of scrutiny, because to /u/peterbourgon 's point, their only purpose is to mutate package global state. I agree on that point. I even agree with the implication that mutable package global state is generally a bad thing. I disagree that it means that they should always be removed. I actually did a search through a couple of code bases I maintain at work, and the only uses I could find were from generated protobuf definitions registering their descriptors with the github.com/golang/protobuf/proto package. There's a very fair argument to be had that having a global registry of type name -&gt; descriptor is bad package design. Under most circumstances, I think that's where I'd fall. Looking at the design space of the protobuf package, I can see why it's a reasonable tradeoff: It's not clear that there's really any better way for the library authors to be able to provide such a registry with acceptable ergonomics.
Couple of gophers and some stickers split between friends and it's not so bad.
The Gopher Plushie is a thing of nightmares
Ever marveled at how you can plug a USB device from one company and hook it up to another company's device and they work? Probably not, because we take it for granted that USB just works. But, how do they do it? Well a bunch of people got together and designed a document that specifies exactly how the USB port should look physically, how much power it should be able to deliver to a device, and exactly how data should be sent over it. In principle, if you have this USB standard you can create your own *implementation* of it in your product and be confident that it will work other products that adhere to the same standard. The USB standard is an example of an interface. An interface is a specification for a software "port" so that different people can implement the interface with little to no collaboration and then plug in to each other's "ports". If they implement the interface correctly, they can be assured they software components will work together. Where do you put interfaces? Well we can look back to the USB example for hints. The USB is essentially the dividing line between two devices. In the software world we call this an "architectural boundary". An architectural boundary is a line you draw between software components. When you draw this line you say "I don't want stuff to know about stuff on the other side of this line". Why might you do this? A big reason is so that you can break up software and assign subsystems to teams. The higher the coupling of software components, the more the teams working on the components will need to communication. Generally we like to think of communication as good. But, in software, excessive cross coupling can drive communication overhead to the point where no work gets done and the engineers are just in meetings all the time. Decoupled software can make it easier to add people to the team and actually make progress. If you try to add people to a tightly coupled ball of code, there is a good chance that extra employee is totally wasted in the best case. In the worst case they may actually slow things down. Why? Communication overhead. Communication between engineers tends to follow the lines of coupling in software. It can be nice to make software highly decoupled with interfaces, even if you own both sides of the interface. It is also good to decouple early so you can scale the team. But, you need to have a nose for where to put those boundaries. Just scattering interfaces anywhere you can isn't automatically a good thing. You need to know why you are doing it. Adding architectural boundaries is a decision that comes with overhead itself. That's why software architects are a thing.
&gt; The only uses [of func init] I could find were from generated protobuf definitions registering their descriptors with the github.com/golang/protobuf/proto package. &gt; &gt; There's a very fair argument to be had that having a global registry of type name -&gt; descriptor is bad package design. Under most circumstances, I think that's where I'd fall. &gt; &gt; Looking at the design space of the protobuf package, I can see why it's a reasonable tradeoff: It's not clear that there's really any better way for the library authors to be able to provide such a registry with acceptable ergonomics. I don't know all the details of how package proto works, but I doubt very much that proto definitions need to be process singletons (which is what package global state dictates). I imagine that the definitions could instead be state in a type used to manage protobuf de/serialization and network communication. Consumers of the package could instantiate that type, register their definitions in it, and use it as a dependency for the components that needed to speak protobuf. Imagine how much nicer those programs would be! You would know immediately by reading the func main which components spoke proto over the network, or needed access to proto definitions, by reading the component construction graph and seeing which bits took that proto.State as a parameter. But as it stands, anything could reach out to the proto package, likely even transitively, and interact with those dependencies without you knowing about it.
GitHub profile pic, man. 😂
&gt;ar as I'm aware, there is no way to configure logrus to only log Info and Critical errors in production, but log Debug, Info, Non-Critical errors and Critical Errors during development. There is method `log.SetLevel(log.WarnLevel)` you just need to either: a) use some kind of cli flags or env variable or config file and dynamically set level while starting b) use build tags (prod / dev ) [https://dave.cheney.net/2013/10/12/how-to-use-conditional-compilation-with-the-go-build-tool](https://dave.cheney.net/2013/10/12/how-to-use-conditional-compilation-with-the-go-build-tool)
For anyone that finds this later, this is how I accomplished the above task package foo import ( "bufio" "fmt" "io" "strings" ) func ParseOutput(r io.Reader) (map[string]string, error) { outputMap := make(map[string]string) scn := bufio.NewScanner(r) for scn.Scan() { firstKey := scn.Text() // find first instance of ':' firstColon := strings.Index(firstKey, ":") //19 // split line on first ':' and trim space from each side //use the first 19 characters (Enclosure Device ID) as the name for the key, then use characters 20 to the end as the value outputMap[strings.TrimSpace(firstKey[:firstColon])] = strings.TrimSpace(firstKey[firstColon+1:]) //Taking the first key and using it's values as the values for the second key secondKey := outputMap["Enclosure Device ID"] secondColon := strings.Index(secondKey, ":") //15 //taking everything in the value after the first colon as the new value for this key and naming the key using characters 4 to 15 from the previous key's values outputMap[strings.TrimSpace(secondKey[4:secondColon])] = strings.TrimSpace(secondKey[secondColon+1:]) thirdKey := outputMap["Slot Number"] thirdColon := strings.Index(thirdKey, ":") outputMap[strings.TrimSpace(thirdKey[2:thirdColon])] = strings.TrimSpace(thirdKey[thirdColon+1:]) fourthKey := outputMap["Enclosure position"] fourthColon := strings.Index(fourthKey, ":") outputMap[strings.TrimSpace(fourthKey[3:fourthColon])] = strings.TrimSpace(fourthKey[fourthColon+1:]) fifthKey := outputMap["Device Id"] fifthColon := strings.Index(fifthKey, ":") outputMap[strings.TrimSpace(fifthKey[2:fifthColon])] = strings.TrimSpace(fifthKey[fifthColon+1:]) sixthKey := outputMap["WWN"] sixthColon := strings.Index(sixthKey, ":") outputMap[strings.TrimSpace(sixthKey[16:sixthColon])] = strings.TrimSpace(sixthKey[sixthColon+1:]) seventhKey := outputMap["Sequence Number"] seventhColon := strings.Index(seventhKey, ":") outputMap[strings.TrimSpace(seventhKey[2:seventhColon])] = strings.TrimSpace(seventhKey[seventhColon+1:]) eighthKey := outputMap["Media Error Count"] eighthColon := strings.Index(eighthKey, ":") outputMap[strings.TrimSpace(eighthKey[2:eighthColon])] = strings.TrimSpace(eighthKey[eighthColon+1:]) ninthKey := outputMap["Other Error Count"] ninthColon := strings.Index(ninthKey, ":") outputMap[strings.TrimSpace(ninthKey[2:ninthColon])] = strings.TrimSpace(ninthKey[ninthColon+1:]) tenthKey := outputMap["Raw Size"] tenthColon := strings.Index(tenthKey, ":") outputMap[strings.TrimSpace(tenthKey[2:fifthColon])] = strings.TrimSpace(tenthKey[tenthColon+1:]) //Prints out keys and values /*for key, value := range outputMap { fmt.Println("\nKey:", key, "\nValue:", value) }*/ slotNumber := strings.Fields(outputMap["Slot Number"]) fmt.Println("Slot Number: ", slotNumber[0]) deviceID := strings.Fields(outputMap["Device Id"]) fmt.Println("Enclosure ID: ", deviceID[0]) mediaErrorCount := strings.Fields(outputMap["Media Error Count"]) fmt.Println("Media Error Count: ", mediaErrorCount[0]) otherErrorCount := strings.Fields(outputMap["Other Error Count"]) fmt.Println("Other Error Count: ", otherErrorCount[0]) rawSize := strings.Fields(outputMap["Raw Size"]) fmt.Printf("Raw Size: %v GB\n", rawSize[0]) } return outputMap, nil } Which gives the following output Slot Number: 2 Enclosure ID: 8 Media Error Count: 0 Other Error Count: 0 Raw Size: 223.570 GB
Try this instead: ` DisplayMany([]Stringer{Person{"Foo", "Bar"}})` DisplayMany takes a slice of Stringer, you can't give it a slice of Person instead. My example above gives it a slice of Stringer, but the first (and only) item in the slice is Person.
What? Why? I see nothing wrong. You can't use enum(2) from outside of this exact package, but you still can use constants Foo and Bar. [https://play.golang.org/p/14ls9Schdfz](https://play.golang.org/p/14ls9Schdfz)
Person is a struct and is represented in memory very differently to an interface. You need to send a \[\]Stringer. Of course, Go could compile multiple versions for different types. Once generics/contracts/whatever they decide on gets implemented there *may* be a way to pass a \[\]Person. But right now, you'd have to either copy the \[\]Person to a \[\]Stringer or implement DisplayManyPerson(\[\]Person) separately or just use a \[\]Stringer.
Dang! That sold out fast.
[removed]
Which database?
Sorry, Postgres
We use a test suite via https://github.com/stretchr/testify for e2e We then use https://github.com/dghubble/sling to make HTTP requests really easily (we also use gRPC generated clients). For service unit testing we keep it supple with table driven tests (https://github.com/golang/go/wiki/TableDrivenTests) and mocking via testify. Another good project for testing diffs is github.com/google/go-cmp
Great thanks. And is there a way to take a slice of `Person` and convert it to a slice of `Stringer` without a for loop to iterate over the slice ?
For each field you can just add to a `SET` SQL query (for example) using `strings.Builder`; you’ll still want to have the values set to `?` so you can also creat a slice of values to your query to avoid any SQL injection issues.
FYI the `Stringer` interface is already defined in the `fmt` package
The basic SQL for something like that is: ``` UPDATE &lt;table&gt; SET field1 = ?, field2 = ? WHERE id = ? ``` Always use placeholders and prepare your statements to ensure you're not risking SQL injection attacks. Can't say I've used postgres with Go so the SQL conventions may differ.
https://godoc.org/github.com/jmoiron/sqlx#DB.QueryRowx supports placeholders, does that make it a prepared statement?
How does it do this? Is the runtime not embedded? What about GC?
Not as far as I can see. QueryRowx simply executes the underlying sql.DB.Query function with whatever SQL you pass in. It does not prepare the statement or sanitise inputs. It looks unsafe.
FYI, the code is unreadable. Backticks for code blocks only work on bloaty new reddit.
I wonder if the shop is implemented I'm Go.
Acknowledged. I’ll try to paste it in a gist or something. What do you think of the concept in general?
I don't think so since \[\]Person is a slice of structs and \[\]Stringer is a slice of interface values. Both are represented differently in memory.
You don't need to put it in a gist, just indent the whole code block by four spaces. I'm reserving judgement because it currently looks like a complete mess, though my first instinct is to say that your dependencies should probably be types, not inline function definitions, e.g. type FeedFunc() *persistence.FeedEntity type ParseFunc(URL string) *parser.Feed
https://stackoverflow.com/questions/26345318/how-can-i-prevent-sql-injection-attacks-in-go-while-using-database-sql says otherwise. Please leave a comment there if it is so, since then a lot of people get it wrong.
`panic()` should be avoided in the first place. i wouldn't want to panic in any of the above situations.
If you want this functionality it would take 3 lines of code to implement yourself; no need to make it part of the language.
It depends. If there is arbitrary input, I agree panic is no good. But for my example I had fixed input in mind (a situation I often have), and then panic would be just fine. I suspect this is quite common. Disagree?
If your Action declares a set of functions it needs, you're pretty much asking for an interface type to be passed to Action, no? Action(fn1, fn2, fn3) Vs. Action(svc1) type Service interface{ fn1() fn2() fn3() } Albeit that you might pass more than 1 service, depending on scope and responsibilities. If your number of functions required is small, than passing functions works. If you're up to 3 or more I'd say that's getting harder to read and passing in a service is cleaner. Both work of course. Object oriented programming vs. functional programming.
How so? You can't return the same types.
I'm no expert. Personally I always explicitly prepare statements as a matter of habit. If Query is running an implicit prepare then great.
log.SetLevel doesn't allow you to skip a level in the middle, does it? Critical and Non-Critical errors are both log.ErrorLevel. If I set log.SetLevel(log.WarnLevel) I will get both kinds of errors.
Not as a generic method (unless Go 2 brings us generics) but you don’t need `must` for everything. Some libraries provide a `must` function eg: https://github.com/aws/aws-sdk-go/blob/master/aws/session/session.go#L316
Yes, this is where the idea came from. The template package in the standard library [also has it](https://golang.org/pkg/text/template/#Must). To me this shows there is a desire for this, but no general solution. Probably in part because it promotes bad error handling, but my idea is to restrict it to main packages, which is where the final responsibility for error handling lies.
This wouldn't remotely meet my needs.
ya -- i disagree greatly. you don't handle recoverable errors with `panic()`. i haven't come up with a justifiable use for it yet.
Can you check again? I think I fixed it
That's exactly the dilemma I am trying to resolve. I think that resorting to functions instead of an interface would make the construct easier to tear apart, because you won't have to create that extra struct, only to have to modify it again some time later. The second argument is exactly the number of funcs you pass to an Action. I want to make it tedious to pass many, in order to restrict myself as a programmer of the possibility to over-bloat things. A decade of Java experience in the enterprise taught me that a service class can always hold one extra method, just because it can. Of course, you can create local interfaces with two three methods instead, right where the functions are ...
Interesting, I would have preferred panic due to the stack trace, but I do see your point. With a panic it would be possible to use a defer to convert the panics to log.Fatal (or any other way to handle it). Any thoughts on this? Example: func main() { defer onErrFatal() must(strconv.ParseInt("abc", 10, 32)) } func onErrFatal() { if err := recover(); err != nil { log.Fatalln(err) } }
Zeebe just posted that their latest release is "production ready" : https://zeebe.io/blog/2019/07/announcing-zeebe-0-20-production-ready/
I'm honestly not sure, but I saw it first in [this article](https://dev.to/sendilkumarn/tiny-go-to-webassembly-5168). Exact same Go code went from 1.3MB to 3.8KB under TinyGo.
I do like the "on" keyword idea. The only issue is that (just like the current `if err != nil` construct, there is no way to handle it with a utility function either due to the need to return. So in most cases it wouldn't actually make things much simpler, would it?
what good is a stack trace for a technique you think should only be used in `main()`? why would you think it is acceptable to have to `recover()` in order to print a reasonable error message? i would argue that it is, in fact, bad. i'm not trying to be mean -- i'm sure you're brilliant. i just don't think this is thoroughly thought through and i'm not sure if it brings anything new to the table. lisp programmers love parenthesis and s-expressions. people who don't understand lisp wonder why it has so many parenthesis because they don't understand lisp. i think `if err != nil` is our parenthesis -- it is the thing people don't love until they understand the language.
If it's all REST endpoints, then using the built-in testing framework with your own API client would be a good solution. Check for errors at each step, maybe leverage sub-tests for the different steps. Given it's E2E though, you don't even necessarily have to write them in Go, though I think given it's an API it would make sense to use Go in this case. If it were a web application I'd considering using something like Nightwatch or whichever E2E UI testing solution is most popular these days.
read all of the complaints about `try()` and apply them to this code PLUS the fact that this `panic()`s. this is like `try()` but much much worse.
No worries, I really am just looking for thoughts on this and an honest conversation about it, and I appreciate the honesty. And I agree that `if err != nil` is fine actually (in fact in most cases I think it is really good). For me panic would be ideal since it is the default Go behavior for certain errors anyway (array out of bounds errors for example). If that happens, I want to know where my program crashed. And if I want good errors for the user, I already have to recover and handle all the panics. Anyway, I think we probably won't agree, so never mind.
r/dadjokes
OP (Endtest) is spamming up tech subs, every day with multiple accounts [1,](https://www.reddit.com/user/boss_scarbos) [2,](https://www.reddit.com/user/dragnea_presedinte) [3,](https://www.reddit.com/user/llupei) [4](https://www.reddit.com/user/wernerklaus), [5](https://www.reddit.com/user/jos_cu_klaus), [6](https://www.reddit.com/user/sa_vina_werner), [7](https://www.reddit.com/user/ihavelepower), [8](https://www.reddit.com/user/viorica_presedinte), [9](https://www.reddit.com/user/werner_sclavul), [10](https://www.reddit.com/user/basist_infect), [11](https://www.reddit.com/user/felix_presedinte), [12](https://www.reddit.com/user/werner_la_puscarie), [13](https://www.reddit.com/user/carnati_si_varza) ultimately in an attempt to make you pay money for the service he runs (endtest). [This is the kind of person you're dealing with here](https://imgur.com/xyfZ59P) Still want to give endtest money? **Vote and report accordingly.**
To answer just the question, I'd go with: 1. \*User if it's available and there's no reason not to, 2. User if there are more than a few fields to update or there's a 1:1 mapping between struct and table, 3. ...Field style if there are only a few (maybe 6 or less) to update. Also, it might not be worth skipping the non changed fields if passing in a User. If there are only a few unchanged fields and you're locking the row or table anyway it's unlikely to hurt performance if these fields are "plain" fields. It will likely make code maintenance easier. Refactor later if needed.
Because, like SLAYER, you're not meant to say it, you're meant to scream it.
Something that might also help you in your choice: * https://blog.cleancoder.com/uncle-bob/2018/04/13/FPvsOO.html There's no "this is right and that is wrong" answer. It depends on a number of factors and often you don't really have a clear reason why one way would be better than the other. In some cases you do however. Uncle Bob has quite a few useful guidelines in this aspect in my opinion, that he explains in this post or also in other articles and books (e.g. Clean Architecture).
just curious: so what class of errors do you think are appropriate to use panic() for and which should you not use panic()?
Also regarding &gt; A decade of Java experience in the enterprise taught me that a service class can always hold one extra method, just because it can. A service class should limit the responsibilities it has and not grow ever larger. Keep it slim and simple. See for example the SOLID principle for guidelines: * https://en.wikipedia.org/wiki/SOLID
You’re on the right track. It’s `[]string{“a”}` to create an array on the fly with one element.
GoBridge will never see a penny from me. I promise.
The on idea: Is it supposed to take the last return value of the function (as it's usually the error value)? I think that's the trade-off you get here: a little less verbose for implicitly binding the "error" value.
This was very insightful, and I think I understand exactly what "Accept interfaces, return concrete structs" is getting at now. Thanks!
Why do you have a map[string]interface{}? Usually it’s a sign that you don’t know about https://mholt.github.io/json-to-go/.
It is a really great design. I don't usually care for mascots, but with golang it's a real bonus that it's constantly popping up as I'm searching the web for answers to my questions
we currently run https://github.com/aerokube/selenoid
I'd say panic should be used for any errors that should never happen if the program is programmed correctly. For example array index out of bounds, nil dereference, that kind of thing. Errors are for things that can be expected to happen even if the program is programmed correctly. For example file not found, network errors, etc. These should never panic. Sometimes things could be both. Like parsing a string to an integer, which is in the latter category if the string is unknown, but in the former if the string is known. I think this is why a bunch of Must functions already exist. For example regexp.MustCompile, template.Must. Often you already know the input to those functions.
Hi, have you contacted the Google groups? I think that is a much better place for this kind of questions. I am wondering however how you managed complex matrices? But the truth is that a C like PL like Go probably just is a lot of trouble.
+💯
Is there a good go offering that's similar to Gatling?
I need to call the function from 3rd party library for sending a data to Zabbix monitoring system. Link: https://github.com/AlekSi/zabbix-sender/issues
I never understand why the mascot in 3d always looks like it's eye balls are gonna pop out. Isn't it ugly?
Looks fine now. You can always check by swapping "www" for "old": https://old.reddit.com/r/golang/comments/cf3qyt/using_functional_actions_as_dependencies_instead/
Feeling very inconvenient without `map`, `filter`, `reduce`
so panic is for un-recoverable errors that place your program in an indeterminate state. if a function can return an error value signalling that the error has occurred, then it is incorrect to use panic to handle that error. so think about the types of errors you pointed out: * nil pointer deference mean that the program has gone off the rails -- there is no reason to do it which means that something extremely bad and unexpected has occurred and to proceed means continuing without knowing what to expect. * ditto for indexing an array or slice out of bounds. * `regexp.MustCompile()` and `template.Must()` are examples of potential mistakes made in the standard library.
Any e2e example scripts? I want to see how it's written...
I think latest version included GC for wasm: https://twitter.com/JohanBrandhorst/status/1151621548043845633
Unrecoverable is an incorrect categorization at that point. The same error can be recoverable or unrecoverable depending on the context. Opening a file that doesn't exist in a text editor is fine, since you can just report the error to the user. But a missing asset file is often unrecoverable. The function to load a file doesn't know this, so it can't make a decision on this, that is up to the caller. It is certainly arguable that `regexp.MustCompile` shouldn't have been in the standard library, but it is very useful mainly to initialize global regexp values with fixed input. For example: var whitespace = regexp.MustCompile(`[ ]+`) Here if the regexp compilation failed, it means that the input string is incorrect. That is a perfectly valid panic. Same goes for `template.Must`.
Well, I am not really looking for simpler error handling. I have a strong impression people prefer to avoid error handling because even most negative of us are infinitely positive, something built in into our kind, all races. Meanwhile, the rational approach tells error handling is just another branch. So, this proposal is about a shortcut for such kind of branching, that's all.
Oh niiiiice!
That's the cost of Go's error reporting I am afraid.
OK, I understand the use case and why you definitely need to produce a value of type `map[string]interface{}`, but I still can't quite follow everything enough to give an answer. In particular, I don't understand the return value from [PrefixMap.Get()](https://godoc.org/github.com/alediaferia/prefixmap#PrefixMap.Get) at all and how it relates to your code; it doesn't seem like that's necessarily going to have an order that will be able to be a key/value in your map, or that it's necessarily going to have two values at all. I can tell you for sure you're going to need to type [assert something](https://golang.org/ref/spec#Type_assertions) into a string, which will give you a string for the key.
I believe that's only a limitation in dev machines (x86) and GC is supported on ARM.
I always enjoy reading about crypto, but the mathematical proofs are beyond me. I would've gotten a lot more from the artic
There is such a large golang community. How do they only have enough stock for an hour?
All the dude shirts are sold out :( half of the plushies as well :(. I still got some socks and a pink plushie, so happy with what I got.
Point taken. The "proofs" in the article are essentially defining a recursive method of mutating both partitions of the key without changing the underlying value that we are storing. This is done by XORing the values with fresh cryptographic data in a specific way that makes the extra data "cancel out" when it comes to retrieving the key.
No. Go has no contravariance or covariance, which are the formal words for these ideas if you want to do an internet search for the ideas, along with some information about why Go does not do this seemingly-simple and sensible thing. Generally in Go, you have the following options, in rough order of preference: 1. Use the type you need in the first place 2. Use something like encoding/json that uses reflection anyhow, so the type difference doesn't matter. (For instance, if you were encoding this as JSON, passing that a `[]Person` or a `[]Stringer` with the same contents wouldn't matter to it, it'll do the same thing because it uses reflection to dig down anyhow.) 3. Use a for loop to do the conversion. Between #1 and #2, a surprising amount of cases can be covered. I don't know that I've done #3 more than two times in the last 5 years. But it is something that can happen.
Is that xor-preserving operation related to any of the "usual" crypto primitives? Is it just using XOR's magic properties to keep a pair of values that XOR together into the same final value, but changing them often? Like, (1+9), (5+5), (2+8), (7+3) are "changing values" that all add up to 10 so you don't have to remember the sequence of operations in order to undo them?
Can you go more into the “when the key is needed it is unlocked and destroyed?” What does destroyed mean here? It sounded to me like the key is stored using the boojum stuff as a cycling xor with the hash function, and I’d assume when you need the key it’s run xor twice to retrieve the key, then after it’s done it’s stored in memory again as the boojum?
To be honest, what we need at this point isn't new ideas, but progress towards an agreed-upon metric or rubric for analyzing them. There's like half-a-dozen github issues with hundreds of comments on them on this matter, dozens of blog posts, etc. We've got ideas. What we don't have is any method of analyzing them that isn't talking past each other as we fail to bring out our hidden assumptions and value preferences.
Interesting. Since you also seem to work on memguard, may I ask how cross-platform it is and on which platforms it is tested?
[removed]
well -- and if you should be using globals is another part of the story. i placed a pretty good definition of unrecoverable: if it places your program in an indeterminate state. if you can ascertain the state of your program (ie, i've just tried to open the file but it doesn't exist or i tried to compile this regex but compilation failed) -- those you can easily signal an error using error values. again, pointing to invalid memory is an indication of a fundamental logical or algorithmic flaw you can't be sure about anything that happens after that point. same goes for attempting to access an array of slice out of bounds.
Consider the key being a single bit, 1 or 0. Then we store (k xor r) and r. Then when we need k, we xor them together and get k xor r xor r = k xor 0 = k, so we don't need to remember r. The real protocol is similar to this except it works on 32 byte keys and stores r and (h(r) xor k), where h is a cryptographic hash function.
[removed]
A guarded memory region is allocated and the key is written directly into it. Afterwards the memory region is wiped and freed.
It should be relatively well supported across platforms. It's actively tested on Linux, FreeBSD, OSX, and Windows.
I wonder if it is okay to use a map of maps of custom interfaces?
They are called differently: myFunc(\[\]int{1, 2, 3}) vs myFunc(1, 2, 3)
How do you update (r) and (h(r) xor k) in a way that you can still recover k? Is it a general property that h(r)^v == h(r^v) or something? Or do you come up with a new r and store (r2) and (h(r2) xor h(r) xor (h(r) xor k) == (h(r2) xor k)?
A new R is generated and the partitions are updated to R ⊕ R2 and h(R ⊕ R2) ⊕ k, etc. That's a trick that's possible due to the properties of XOR: k ⊕ y = k ⊕ 0 ⊕ y = k ⊕ x ⊕ x ⊕ y
Inside the function the usage of parameters from both of those examples is the same - you will utilize the slice functionality. On the other hand, calling the functions will require you to pass arguments differently - in the first example you would have to pass a valid slice type e.g. `myFunc([]int{1, 2, 3})` where as in the second example you can pass any number of arguments (even zero), though the format would have to be like any other non-slice argument e.g. `myFunc(1, 2, 3, 4, 5)`. I recommend reading more about variadic parameters [here](https://golang.org/ref/spec#Function_types).
Thank you guys. How to call myFunc when I'd like to pass a variable containing the slice instead of calling it directly with values?
&gt;Pzda &gt; &gt;No, I meant UML Class Diagram. plantuml did not allowed me to create the type of diagrams you mention.
If you want to go full hardcore then docker-compose that simulates the entire cluster should give you most reliable end to end. I’ll provide a link once I land.
It looks that way in 2d too, and I think the word you are looking for is endearing.
Ok, that would make sense with a language like C, but not with Go, because it explicitly avoids the indeterminate state and gives you a perfectly defined state, which is the panic. So the panic is actually the opposite of unrecoverable by your definition, at least as far as I can see.
That's a good point!
how does it compare to testing/quick?
okay -- i yield. :)
Thank you for your attention to my question! &amp;#x200B; Look at my function, please: `func send_to_zabbix(cnf *Settings, a []string)(ret interface{}, err error){ // add errs` `var ka []string` `pMap :=` [`prefixmap.New`](https://prefixmap.New)`()` `for _, m := range a {` `e := strings.Fields(m)` `ka = append(ka, e[0])` `pMap.Insert(e[0], e[1], e[2])` `}` &amp;#x200B; `/* Saved for debug purposes` `for _, m := range ka {` `e := pMap.Get(m)` `fmt.Println(m, e)` `}` `*/` &amp;#x200B; `/* do something with 'data'...` `data := map[string]interface{}{"cpu_pc": 42}` `*/` `di := zbxs.MakeDataItems(data, "hostname")` `addr, _ := net.ResolveTCPAddr("tcp", cnf.Zabbix_app_hostname + ":" + cnf.Zabbix_recvport)` `r_zbx, _ := zbxs.Send(addr, di)` `return r_zbx, nil` `}` &amp;#x200B; **\*Settings** \- is filled struct with parameters for connect to Zabbix server (host, user, pass, etc) **a** \- is strings array. It looks like: ^(key now peak timestamp) ^(cpu\_usage 42 15 20190719000118) ^(mem\_usage 1024 1600 20190719000118) The range of strings ('a') got from a raw output from the device and delimited via spaces and newlines. I want to put in Zabbix 'key' (like a 'key' in Zabbix's therminology) and 'now' (like a integer 'value') **from** an each string. In the future I'll plan extend this function and will store of all 'columns' to another backend. I find difficult the situation when at an output the program get a type 'string' instead 'int' ('NaN' instead 42, e.g.) Maybe that can be avoid?
I'm realizing now aria2 might be too complicated for what I need. I am just looking for the multiple HTTP connection of aria2c using said command `aria2c -x2` [`http://releases.ubuntu.com/disco/ubuntu-19.04-desktop-amd64.iso`](http://releases.ubuntu.com/disco/ubuntu-19.04-desktop-amd64.iso) &amp;#x200B; I know there a few others such as axel ([https://github.com/axel-download-accelerator/axel](https://github.com/axel-download-accelerator/axel)), hget, ... that would fit my need.
You might find a technique like the following useful: [https://coderwall.com/p/uz2noa/fast-parallel-downloads-in-golang-with-accept-ranges-and-goroutines](https://coderwall.com/p/uz2noa/fast-parallel-downloads-in-golang-with-accept-ranges-and-goroutines)
Thank you! Will look into this.
Go Store Announcement: when being a female coder works in your favor..... 99% Reddit: everything is sold out or is pink! Me: gimme ALL the pink things and any shirt I want!
Quick test is one of preferable test case generators for huffy, and I’m thinking about better integration of my package with “testing/quick”.
https://dave.cheney.net/2017/04/26/understand-go-pointers-in-less-than-800-words-or-your-money-back
Nice link, thanks!
I'm also in the devops world and go is great to know since I can develop on my Mac. Compile a Linux binary and it works
OK, so if I'm following, the answer is something like m := map[string]interface{} for _, array := range arrays { e := pMap.Get(array) if len(e) &lt; 2 { // handle error } key, isStr := e[0].(string) if !isStr { // handle error } valStr, isStr := e[1].(string) if !isStr { // handle error } val, err := strconv.Atoi(valStr) if err != nil { // handle error } m[key] = val } I don't know what you need to do to handle errors, and this sort of assumes that the second value is always a number. And I'm still a bit fuzzy about what is going into that prefix map. But I bet this tells you what you need. Incidentally, what you're seeing there is the mismatch between all the data types acting like this is a dynamic language, and the fact Go is a static language. If you had all the values more strongly typed this would be easier. If you control this program fully, I'd seriously consider creating a type Record struct { Name string Now int64 Peak int64 Timestamp time.Time } and writing code to convert an io.Reader (look into bufio and the ability to read lines from an io.Reader) into []Record as a deserialization step. From there you'll find Go is much easier to work with. Unless this is a _huge_ file or you _really_ need that prefix thing, I'd dump it too, since it can't be typed and it's holding you back. (Someday, we will hopefully get generic data structures.) Go works best when you serialize incoming data into strongly typed structures like this as quickly as possible. While it can work like a dynamic language, it isn't very much fun anymore.
You just put the dots on the other side at the calling site. input := []int{1, 2, 3} myFunc(input...)
There are a couple of frameworks like [Revel](https://revel.github.io/), [Echo](https://echo.labstack.com/) and [Beego](https://beego.me/) to name some of the frameworks I've heard of. I don't think they are as good as Laravel for begginers. But the thing is, in Go you don't need big frameworks. The standard library that comes with Go provides with all that you need. My recommendation when you switch to a new language, is to learn the idiomatic way of things. For starters, in Go you won't see the MVC model, instead you'll see the onion model or clean architecture, microservices and the sort.
Error occured, can’t watch :(
Requires a Google or Facebook account to participate, which is disappointing
[JustForFunc](https://www.youtube.com/channel/UC_BzFbxG2za3bp5NRRRXJSw) I think was the best. But I don't think it was exactly for begginers. And it's already months since the last video.
There is also an email login option (https://barbra.io/auth/register)
[removed]
Ah, didn’t see that, my bad and thank you!
That is true. Me too, I also got into reading it up but it's rather complex especially when you go into the server thing. But the thing is, even today we in the internet are still using old crap. Here, I don't know whether they got "hold up", like what happened with [pond](https://github.com/agl/pond), that also got terminated. What I am saying is that when things are started to roll that then Google is getting involved to not let things get out of hand if you know what I mean.
[GoTime](https://changelog.com/gotime) is an awesome podcast.
I think "on" with this syntax is much more clear than "try". But, I have similar objections to both. This only improves the case where, if you see an error, you give up and return. It does nothing for the case where you do something different when you see an error. So code will be mixed with "on" and "if" and it might be hard to figure out the exact control flow.
I think most of the team moved on to a new project.
Welcome to learning Go! I don't have any resources, but just wanted to say that pointers vs values is one of the things that seems to overwhelm people at first; however, the concepts are really simple and powerful. They're one of the things that allow Go to be so much faster than Python (I work in a Python shop).
**Thank you so much for your detailed description of the algorithm and the mention about 'io'!** I should dive deep inside a Golang for insight of features of 'io'. To my regret, I can't change something in an output from the device (e.g., adding an errors exclamations). Anytime a data looks for me like a blackbox's burp (O\_o). In this situation I should checking an input data "twice". I think that in this case "a functional" have a low priority in front of "the safety" :) My background in the software development based at knowledges of Assembler for x86. I'm not an old lizard, who know only 'mov' and 'push' (and 'LOOP'! ))) ), but I'm feeling an impact my early experience at my current scores in Golang. E.g., I've read about an amazing OOP's tricks at Golang, but I can't to kick yourself for use that in my practice....
Great explanation, Peter. I just want to pick one nit: &gt; Your example of a vector math library, using concrete types like Vec2, Vec3, etc. isn't a great one to exploit the power of interfaces, because, as you've discovered, Go's relatively poor type system doesn't allow you to encode your intent. What's the intent? While Go's type system is definitely not the most powerful, I don't see how this example is limited by it. Either his code depends on an abstraction over vectors of different sizes, or it depends on concrete details of a given vector type.
Yes, I think this is one of those cases, though I tend to avoid this pattern myself, so I haven't dedicated much thought to what a "better" alternative would look like.
No
You mention that it will work with Result from Rust, which I think is a really important requirement for any error-handling proposals. At least, I'd really like to see Go get real, Rust-like enums (and exhaustive pattern matching) such that we can use Result types instead of multiple returns for the return type on a fallible function. Any error handling proposal that precludes Result-type error handling is a nonstarter in my opinion. That said, I'm not sure how this would work with result type error handling, and in general I wish we would focus on sorting out enums and generics and how those might improve error handling before we focus on syntax sugar for error handling.
Not if fn1, fn2, and fn3 have nothing to do with each other, as in the original example.
Yes, it is not meant for a complete beginner because the language itself is not very beginner friendly. But as Dom correctly pointed out during the talk at London Gophers, this could be solved with an additional layer of abstraction on top of the most technical parts. When I ran this in the workshop format we had "mini-lectures" about the terminal and UNIX basics. Still, the target audience was students from the first year of computer science or related courses.
I understand your confusion, and this probably only gets worse as the audience gets younger as less people will actually know what Pac Man is... And on a side note: unfortunately this version of the tutorial doesn't work in Windows cmd, but maybe it will in a terminal emulator (untested).
I was originally a python developer and I hadn't started looking at pointers in a compiled language until 6+ years of python experience. So I can confirm that it can be a confusing concept at first for someone with only high level dynamic typed scripting language experience. But that being said, it is far more complicated to understand when approaching C++ as opposed to Go. You could start by just comparing Go pointers to python objects (it's not 100% correct but has similar behaviors). If you assign a list to variable x and then assign x to y, you end up with two variables that point to the same list value. The list items are no duplicated, only the pointer it copied. Same with how you would create an instance of a class in python and assign it to x, and then x to y. The instance is the same and changes to a field through either variable modify the same underlying instance. Passing a value instead of a pointer in Go has a similar effect of using pythons `copy.Copy(obj)`, where y is now a new copy of what x pointed to. So in Go, you can just start out by thinking about pointers vs values as whether you expect a copy or the original to be passed into functions or retrieved from slices or maps.
I have a free list I just adapted from a Slack conversation awhile back, if it's of use to you. I keep meaning to turn this into a proper article or... something. [https://gist.github.com/flowchartsman/be141593ce1087e38c6787b4127d060d](https://gist.github.com/flowchartsman/be141593ce1087e38c6787b4127d060d)
I just made this list today at the urging of a friend. It's hastily adapted from a chat conversation, so be kind ;) I'll be polishing it off soon: [https://gist.github.com/flowchartsman/be141593ce1087e38c6787b4127d060d](https://gist.github.com/flowchartsman/be141593ce1087e38c6787b4127d060d)
Learn C. Sounds like a pretty stupid thing to say right? But C pointers covers so much ground and you can get a decent grasp of them there and then move that knowledge to pretty much any other language. It’s always lurking beneath the surface :) One thing to look out for is that * has two meanings. Which is something I wished that go had done something about. * connected to a type tells you it’s a pointer. *int for instance. With a variable &amp; and * gives you a pointer or gives you want it points to. So * either defines a pointer type or dereferences. Depending on where it’s used:( Good luck! And remember, you don’t need to know all about C, just the pointers part:)
Looks neat.
This is a good one, I will be adding it to my own list of zero-to-go resources.
&gt; What's the intent? I meant the specific case of having a method on a type that returned a copy of that type, and then wanting to define an interface that would be satisfied by all types with that _form_ of method. There are ways around it, like returning a Vector interface, but (as explained in the OP) that's annoying to use. The Go Zen Master answer to this would I guess be to _redefine your intent_, which usually means zooming out one level and asking questions like "What do you want to do with these Vectors?" and then seeing if you can write that code in a way that doesn't need concrete types.
Have a look at golangprojects.com.
Thanks.
Maybe try /r/GolangJobOfferings
One issue with this approach is that your actions are forced to be constructed with funcs. If you instead had single method interface arguments like Stringer, Reader or Closer you could use both structs and funcs (with a helper). Another issue is readability. func A(a func() bool, b func(bool) error) func(int, int) error { // ... } A lot of funcs and you quickly miss sight of what is arguments and what is return types.
I was just taking a look at that yesterday. I'm quite find of the project in part because I got a free T-shirt from them for finding a major security issue in it. It's disappointing to see that it seems to be abandoned. It was very promising.
Yes, sorry. I do love golang the language.
Yes, i agree, no
With something like Fyne - sure thing. That makes for very nice Desktop app GUI using Go under the hood. Cross platform and standalone. However throwing in HTML, CSS, JS and god knows what else isn't how I'd go about making a frontend for a Go app. Much less involve a browser or browser runtime like Electron. If one must make a web-app (or web-site for that matter) better and more efficient (in developer time) options exist.
I should add that the mongo/cursor.go file in my vendor folder is missing the method, but I used dep ensure -update to get the latest version.
How about Awesome Go ... https://github.com/avelino/awesome-go
You can easily make adapters for Casbin.
nice article, I happen to need it right now
Casbin adapters define how it gets serialized but not when, and there was no easy way to just serialize the new changes. And that doesn't change the fact that the lookup data is still in memory and multiple nodes will drift without etcd or similar.
Yes
&gt;friends `len(me.friends)!=0` is a bold assumption.
Yes. It's almost as good as Glenda, the Plan 9 Bunny.
I feel like that probably inspired them to have a cute mascot
I had the same warning but doing this, go allowed me to create the module. Why outside of the GOPATH works?
Spam
well, afaik it was the same designer.
It creates the go.mod file, but doesn't respect it when resolving dependencies of you're in GOPATH
If you feel confident have a go at the [Exercism Linked List](https://exercism.io/tracks/go/exercises/linked-list) exercise. If you feel masochistic write some C code to learn pointer arithmetic.
why "No"? It's WASM thing, you can write frontend in any language, not only in Go, or you don't like the whole WebSssembly idea?
you don't have to throw CSS and HTML. You still need it. WebAssembly mostly extends / replaces JS. And why do u need Electron app in WASM, just why? You can write regular web apps in Go, not desktop.
Really cool, thanks for putting this out there. Ignore the low effort negativity.
these guys don't get that it was an experiment + WASM allows to write frontend in Go so they should **hate _WebAssembly_ instead**.
I don't hate WASM. It absolutely has value. Let me share a story. Last weekend, I was building a small doghouse. I used screws to attach most of the panels to the frame. My battery operated screwdriver was working great for that. When I came to the roof, I had some roofing nails to secure the shingles. Now I really like my screwdriver. I mean; I think it's my favorite tool in my whole tool chest. It's so great, I would love to use it for pretty much every job. So I figured since it's such a great tool, why couldn't I secure the shingles with it? So I took the roofing nails, and I hammered them in with the screwdriver. Man was that satisfying. There were some tricky bits, like the rounded nature of the screwdriver meant many of my strikes kind a slipped off, and it took 15 to 20 strikes for each nail. BUT those nails certainly went in. I am so happy I got to use my screwdriver.
What are the advantages of this other than the change of language? Performance?
bruh this article doesn't say you should drop JS and write only Go+WASM. This was a little experiment. WebAssembly has some disadvantages, as well as pure JS. I didn't say you must use it instead of JS. I write both JS (React mostly) and Go (frontend and backend) and this is fine to me. I know that WASM is not good at DOM interactions (slower than js) but it was experiment.
Definitely a bruh moment
I would use go mod, and have a look at which versions is actually installed. Then go to github and make sure that version/tag is selected when browsing the files to see if cursor.All should actually be in the version you have. I had problems when this package was in beta as the API changed quite a bit. When I revisited an old project and updated dependencies, a load of stuff was broken.
This is **a little experiment** so it doesn't have so many advantages. In case of performance, WebAssembly takes time to load so it is (in theory) slower than JavaScript, but for load. But you can reduce load size using TinyGo and it loads very quickly (still not the same speed as JS though) In addition, WebAssembly is slower than JS in small operations but faster than JS in huge calculations. I think WASM is slower in DOM operations than JS (but I'm not sure) but it is still fun to write Go web apps just to play around, not for production cases. WASM is better for canvas / complex math etc.
I agree. I considered becoming a contributor, but seeing the low activity, I don’t think that will be very rewarding.
Interesting read, thank you. I'm wondering though whether net/http works io go/wasm, since I know grpc sadly doesn't.
Everyone already covered the libraries that can help with this, but if you want to go with a more bare bones approach just spin up the api in a goroutine and fire requests at it in your tests.
A change of language is a very big advantage IMO. Not all developers know javascript. But now wasm allows them to write webapps too. It just opens up the ecosystem. And that's a good thing.
Hey /u/MeschDog18 good job and thank you for sharing. - Make sure to use [gofmt](https://golang.org/cmd/gofmt/) or [goimports](https://godoc.org/golang.org/x/tools/cmd/goimports) everywhere - Instead of parsing commands with `strings.Contains()` you should consider [flag](https://golang.org/pkg/flag/) - There’s a logic bug in your `input()` function that allows the execution of all available commands at once. You should add a `continue` statement at the end of each condition to prevent a fall-through. You may also want to take advantage of `switch` automatic breaks. - You are using `http.DefaultClient.Do()` which means you don’t have good timeouts - In some places you are using `log.Println(err)` to print errors, but forgot to add a `return` statement, so the code is falling through even when data is not available. An example of this bug is available in your `GetTweets` function, immediately after an attempt to decode a JSON response. You are trying to access `USER[0]` even though an error was triggered. - Minor nitpick, but filenames are usually written in lower case I’m looking forward to test the future versions.
Do you mean running a server in WASM? I think it won't work cos' you mix up frontend and backend. But interesting to try.
yep, I hope WebAssembly perfomance will improve in the future and we'll be able to write DOM apps as fast as JS.
Of course. If you read my other replies, services should stick to 1 responsibility. So no mixing in a lot of random methods into 1 service.
Ah I wasn't clear enough! I meant to ask whether net/http's client can do Get and Post requests.
There's just [IPFS](https://ipfs.io/) and [Perkeep](https://perkeep.org/) left. Both under active development. Both written in Go.
Development of perkeep scaled down in February :'( [https://twitter.com/PerkeepOrg/status/1095371716644155392](https://twitter.com/PerkeepOrg/status/1095371716644155392?ref_src=twsrc%5Etfw%7Ctwcamp%5Eembeddedtimeline%7Ctwterm%5Eprofile%3APerkeepOrg%7Ctwcon%5Etimelinechrome&amp;ref_url=https%3A%2F%2Fperkeep.org%2F)
That's sad to hear. I had my eye on Perkeep in particular. IPFS does seem to have taken on a life of it's own though.
Thanks man for the advice I’ll make sure to fix my code as soon as possible!
of course net/http can. Look here: http://www.golangprograms.com/example-to-handle-get-and-post-request-in-golang.html
I mean whether wasm-compiled go can call out of wasm to my REST endpoints. Was the transport net/http uses adapted to wasm? I hope not it is clear enough :)
What are the differences between it and telepresence?
0.1.3 and just mirrored on github.
Is there a slack centered around go?
Wait, what? There are developers who write web applications but don't know javascript? Sorry, but that's just ludicrous. Especially given how easy js is to learn. I like this experiment, too, but it is kinda like "hey I made this fish ride a bicycle, isn't it cool!". It is cool, and I love Go, but I'm not going to use this in actual production.
yeah that's interesting. Do you have to create a XMLHttpRequest in the browser to make a request, or can you make a net/http client in the WASM and call the server using that. Be interesting to find out.
oops, sorry for misunderstood. yes, you can make requests using `http.Get`: https://github.com/siongui/userpages/blob/master/content/articles/2018/07/30/golang-wasm-xmlhttprequest-xhr%25en.rst but I'm not sure. I didn't test it
&gt;i think if err != nil is our parenthesis -- it is the thing people don't love until they understand the language. I understand the language quite well and I love the language design, the runtime design, the library design and the tooling design, and how everything fits together, but I really dislike the repetitiveness of error handling, because it takes too much "visual" space compared to the rest of the code.
FYI: Laracasts is not a podcast. Laracasts is really good - well made bunch (1k+) of videos on Laravel &amp; friends topic. I own a lifetime "license"; although I don't use it anymore that much - overall, money well spent. --- I am not aware of any good Gocasts wannabe videos.
Hi Jan, looks good overall, few minor improvements: calculator_server.go: * port is hardcoded (use e.g. flags package). * L17: *calculator* rename is not needed. * L31: you could add *err* to the log to give the user additional information why listening to port 8888 failed. * L51: is inconsistent w.r.t. L69. * additionally, I'd move the check division by zero check before L67. * Because *response.Result* is only assigned once you could construct and return it in each of the switch cases. calculator_server_test.go: Have a look at table driven testing. calculator_client.go: * Again, port is hardcoded. * L24,L28,L37 are inconsistent w.r.t. L44. * In one case you log the ouput, in the other you print it to stdout/stderr. I'd stick to a consistent way of logging. * *isSupportedOperation* could be removed (depending on the requirements). Adding an operation requires to change client and server currently. The server does the check anyway, so you could remove it in the client. Of course, in your case the function helps in parsing the input. There are probably better ways to parse inputs depending on the requirements. What I dislike about *parseInput* is the fact that it does not pass the error upwards. This makes testing difficult and can result in inconsistent handling of errors. Consider a new requirement: The user should be able to enter as many calculations as they want. All calculations that are valid must be computed, for the remaining you can log an error. Right now, this feature is not supported and requires changes in *parseInput* because it has the side effect of exiting the application *log.Fatal*. calculator_client_test.go: Why did you skip the tests?
Hey, thank you very mich, great feedback. I will start implementing it right away.
You can run microservices or some other process locally or forward using TCP, I don’t think you can do this with Telepresence. Also, you don’t need a Docker image
C,
Cgxzg
Good to know, thank you
It says [here](https://github.com/janPhil/calculator/blob/master/calculator/calculator.pb.go#L1) this file is generated, then it should not be in git.
Yes :) [https://invite.slack.golangbridge.org/](https://invite.slack.golangbridge.org/) It is really good :)
&gt;That's why I suggest to run Monday using the following alias: &gt;alias monday='sudo -E monday' Uhhh...no thanks.
Gophercises
In case you are interested, [this is covered in the FAQ](https://golang.org/doc/faq#convert_slice_of_interface) and I wrote up a [detailed explanation](https://blog.merovius.de/2018/06/03/why-doesnt-go-have-variance-in.html) why this can't work on a conceptual level :)
Your title was explicitly “let’s write front end in go”. I was merely answering that. I didn’t read your article, so my statement is not on its quality or content, just in regards to a more common trend in general. The number of jr and new-to-go engineers I need to course correct because of articles out there they read by people who don’t write ideomatoc go is astronomical. The more time goes on and the more popular go gets the more we see things like: “Let’s use these 15 frameworks to build a service in go” Or “How to write go just like node.js because we &lt;3 dependencies” Clearly that’s all title gore, but you get the point. This subreddit has a massive amount of shit articles being promoted all the time. Again, I’m not judging your content; but I sure as hell made assumptions about it, and I answered the question it posed. Use the right tool for the job, and front end is not what go was designed for.
I tried to find more information on the "Boojum scheme" but in vain. What I am curious about is, if the key can be retrieved with a few known operations on some data that is entirely in RAM, what would prevent a cold boot attacker from getting that data and applying the same operations? Sorry if the question is silly but encryption is not my area of expertise.
so you want me to change the title to "Let's (carefully) try to write frontend in Go (not good for production)"? I didn't say __YOU MUST WRITE FRONTEND IN GO JS IS SH*T__. The point of the article was experiment, not _best practises_, _patterns collection_ or something else. I don't tell ppl to use Go as frontend on a regular basis, so I don't promote "bad" ideas. And why did you write "No" as a feedback even if you didn't read the article? What's the point of writing "no"? What does it change? "How to write go like node.js" is actually not a bad idea for an article cos' lots of ppl switch from Node to Go and using libraries / frameworks (Beego, Echo etc.) is not a problem at all.
Great article thank you :)
defer isn't slow, it's the equivalent of one (allbeit not inline-able by the compiler) function call
I meant "developers", not "developers who write web applications". This is about backend developers who do not write frontend applications. Sure, JS is easy to learn. But the point is that it is _possible_ to write webapps in other languages. There is no harm in that. And yes, it is not recommended to use it in production right now. But that might change within a few years. The wasm spec itself is evolving.
 func unhappyFunc() (int, string, error) { if err := neverHappyFunc(); err != nil { return 0, "", err } if err := neverHappyFunc(); err != nil { return 0, "", err } if err := neverHappyFunc(); err != nil { return 0, "", err } if err := neverHappyFunc(); err != nil { return 0, "", err } if err := neverHappyFunc(); err != nil { return 0, "", err } if err := neverHappyFunc(); err != nil { return 0, "", err } return 1, "Happy!", nil } is even shorter.. &amp;#x200B; I'm not a fan of the single line formatting. I would rather the editor do something smart like fade the error check to the background by shading it in light grey
Exactly. I asked the question which is answered in the comment you linked :-) That said, I'm not sure generics would change anything to the issue of verbose error handling, which mostly concerns control flow.
I uploaded the relevant pages from the book that was cited: https://spacetime.dev/memory-retention-attacks
I'm on your side here 😂 well done, you made a cool toy 👍
Not sure if you manage to find answer for what you are looking for, stumbled across your query while i was facing similar issue. Here are the steps i followed to resolve mine. * Install delve in your machine * set up and ensure Delve is working via command prompt/terminal * then try follow /u/mattinielsen steps with a simple go file just a variable and print statement. * use :GoDebugBreakPoint to set break points * once after setting enough break points use :GoDebugStart command to start the debugging in vim * This will default to delve debugger you will have multiple split windows one for stack trace , variable debugging and debug output window along with your go file window. * Focus you commands in your Go file window only and use :GoDebug continue /:GoDebugNext to work on the program.
I really don't think it helps with readability and breaks standard formatting rule by having this one as exception. If you wa t to hide it or take less space it should be a job of editor. For code I think consistency is much more important than personal preference which is where editors shine. So personally I don't see the value this change would bring.
One thing For GetAppName: It would be better to create a structure and return that or an error. Makes it more readable than 3 strings
Thank you for your feedback. I will do it :)
I’ll try to expand my comment once I’m at a computer.
The example code blocks aren't loading for me on mobile :/
I recently wrote about another use for finalizers: https://link.medium.com/cYisSB2YtY
No, I disagree. Committing the generated code ensures reproducible builds. The generator may change and create different code. Of course, its possible to pin the exact version of the generator and save a hash of the generated file, but then you can commit the file and have all the benefits of version control.
https://github.com/ricardomaraschini/crebain Hello, it appears you tried to put a link in a title, since most users cant click these I have placed it here for you ^I ^am ^a ^bot ^if ^you ^have ^any ^suggestions ^dm ^me
I'll take “Things That Should Be Removed From Go 2.0” for 500, Alex!
A radix tree seems like a better solution. Much more efficient storage. In general I'd avoid large maps with strings as keys as they massively contribute to gc overhead.
Alternatively you can just use Systemd as it's part of the OS. Write a Unit file, enable it and you're done. It'll restart the service, can handle logging and start your service on reboot automatically. Here's an example Unit file: ``` [Unit] Description=web service, runs on port 8000 [Install] WantedBy=multi-user.target [Service] Type=simple User=www Restart=always WorkingDirectory=/www ExecStart=/www/site.app ```
I've been having this problem for every medium article for the past couple of weeks, it's really frustrating.
I like DoomFrog666's radix tree suggestion. I would also suggest a simple combined key + merged keys. "en:ball", "de:kugel", "fn:pallo" are your search keys, but what you actually throw in the radix tree would be the merged key of "combined key" + "target lang": e.g. "en:ball:de" = "kugel", "en:ball:fn" = "pallo". Because radix trees allow prefix search, searching for the prefix "en:ball:" gets you all the translations of en:ball (the trailing ':' avoids getting en:balloon results). You just have to encode your delimiter if it happens to show up in your text, and handle that when you search. &amp;#x200B; So you first search for "fn:pallo:en", if you get a result, you have your answer. If it fails, you repeat the search, this time for "fn:pallo:" and loop over your keys: "fn:pallo:de", "fn:pallo:fr", fetch the values "kugel", and "balloon", and search for "de:kugel:en", and "fr:balloon:en", get a match on "de:kugel:en" and return "ball". &amp;#x200B; I know, doing string manipulation of keys may seem like a code smell, but you aren't doing any parsing beyond simple substrings to get the target language.
Yeah but there are closely related issues like error wrapping/unwrapping which could affect how the API looks overall. We also don't know the scope of the parametric polymorphism yet, even if it's not likely we could get union types or something else that would shake up a bit. The point is that we don't really know until we have it and thats reason enough for me to wait with other changes.
It's honestly amazing how people fail to transfer and display formatted hypertext using infrastructure that was _explicitly created_ to do little more than to transfer and display formatted hypertext.
&gt;, but what you actually throw in the radix tree would be the merged key of "combined key" + "ta Yeah, tries were the first thing that came to mind, but the last time i've used one was prolly at the university, quite a while ago. Does go have a good implementation of it? Also what would be the go to database for storing these nodes? Used redis for the hashes. Thanks
&gt;Yeah, tries were the first thing that came to mind, but the last time i've used one was prolly at the university, quite a while ago. Does go have a good implementation of it? Also what would be the go to database for storing these nodes? Used redis for the hashes. Thanks Yeah, it does smell, but this'd be a proof of concept so i guess it'll do.
This seems pretty stupid to me. It's like a C++ destructor but without any control or guarantees. If anything this feature is an argument against using a gc.
Garbage collectors are fine. Finalizers are abominations
Or monit https://en.wikipedia.org/wiki/Monit
Yeah, after a while I realized you are talking about Pac Man.
alternative: inotifywait inside a (shell) while loop https://stackoverflow.com/questions/4062806/what-is-the-proper-way-to-use-inotify
Well I'll go against the bashing and say that Finalizers do carry their weight, as a line of defence against file descriptor leaks. I mean it fits that problem like a glove.
Yes. This or run it in a container with --restart unless-stopped.
That would be an unmitigated disaster. They are there for a reason. Huge swathes of currently-correct code would become incorrect, that _should_ be correct as written. I am also yet to even see a single usage of these things in the wild, so it's not like there's some sort of epidemic of usage out there.
&gt; Huge swathes of currently-correct code (…) &gt; I am also yet to even see a single usage of these things in the wild (…) 🤔 And don't worry. The Go Team has already expressed the intention to not break backwards-compatibility. Even if it means leaving warts like this.
&gt; Alternatively you can just use Systemd as it's part of the OS. Assumes a platform that has systemd. Nice thing about supervisor is that it's an easy package install on different platforms. It also has a lot of other cool features like an RPC api, web UI monitoring, and organising multiple programs into groups that can be managed as a whole.
We use supervisor as our process manager as well. It's flexible, easy to install on different platforms, and has good docs about all of the configuration options. Couple comments about the examples in this articles: 1) Why is it important to set the GOPATH in the supervisor config which should just be launching a binary? 2) not knowing about the godotenv thing, I found it to be a confusing aspect of this tutorial as it wasn't really explained and linked to the supervisor setup. I had to read what that was to then understand why there was a strange env var in the supervisor conf. Maybe a section explaining why it's an important aspect of deploying the app would be good 3) is it wise to suggest from a high level that a supervisor program should point at the source location default build? Seems really easy for that source location to get modified without thinking about it being part of a deployment. It may just have been part of a simple "clone and deploy" process on a clean VM but it looked odd in practice. Binary should be installed somewhere detached from Go dev influence?
This is definitely one of those things, like init() functions that should basically start with "don't ever use these"
They are useful for CGO projects where an underlying C object is tied to the lifetime of the Go object. And this is specifically the only place I have ever used Finalizers. I have at least 3 projects which are bindings into C/C++ libraries. We can offer a Destroy() or Close() function, but we also set the Finalizer to guard against leaks of the C memory in a long running program if they don't call the method. The memory would get cleaned up at some point when GC runs. I wouldn't use them to manage Go memory. Only resources allocated outside of Go.
Has anyone else had any issues since ordering? I ordered using a credit card I seldom use (it kept saying my postal code was invalid when I tried to use my main card). Fast forward two days to this morning, and I get a call from my bank saying that my card was 'compromised' and they are issuing me a new one. Yes this is a throwaway, but I'm not trying to say the go-store is responsible, or discredit it in any way, I just found the timing to be very odd.
beware that what you're describing, is a keyboard logger. These are notable security threats, and the operating system itself goes out of its way to prevent programs from being able to globally capture keyboard input.
&gt; 23 lines of code vs 35 lines of code with current gofmt rules. FWIW, LOC is a simple metric, but not a particularly useful one :) [Conway's Game of Life is one line in APL](https://www.youtube.com/watch?v=a9xAKttWgP4).
mod and dep are using a tagged version from the release/1.0 branch &amp;#x200B; It's not the same code as the master branch.
Isn't the entire purpose of a major version bump to break backwards compatibility in order to clean out cruft?
Why? I haven't use them, just curious why this is so horrible?
On a different note, now that I've responded properly to the OP, I'd just like to point out that unless the problem domain is tremendously narrowly focused (i.e. the only words you'll be translating are domain-specific with only the one meaning), this is actually a very bad method of translation. &amp;#x200B; It fails utterly on homographs, especially where a pair of words are homographs in one of the languages and not the others. &amp;#x200B; For example: tear (rip) and tear (as in what you cry). en:tear=de:träne goes in, and en:tear=de:zerreiße goes in. en:tear=es:lágrima and en:tear=es:rompe go in. en:tear=fn:déchirez and en:tear=fn:larme go in. At some point down the line, an attempted translation of "Tear the document on the dotted line." becomes the equivalent of 'Cry about the document's dotted line', and you end up on an entirely different subreddit.
Yeah the more I research about this project, the more I’m becoming aware of that fact. I’m going to go out of my way to make sure I’m only documenting the frequency of key usage and not persisting the sequence of keys. Since it’s a side project, I’ll also be open sourcing the program. I’ve found a couple of keylogger repos that are able to accomplish the keyboard input such as robotgo but it does seem limited in its usage for this use case.
The crypto community would have a word with you
If you're cleaning up the cruft then you usually replace it with equivalent code that can do the same job. It might have been a bad idea in the first place but now that it's here, I don't think the language designers will take it out especially when there are real problems that this solves.
&gt; to make sure I’m only documenting the frequency of key usage and not persisting the sequence of keys antivirus can't tell the difference, just that you've hooked into the keyboard driver and are recieving all keystrokes entered into the computer.
There won't be a new major version. "Go 2.0" is just an unbrella term used to cover all manner of new features one might want to add to Go at some point. If any of these ever are approved, they will be added to the language one at a time in separate 1.x updates. As such, they can not break backwards compatibility.
Consider posting on r/ProgrammingBuddies
Thank you. Sorry if I put this in the wrong place
It's like calling a function whenever you want to, except it isn't clear when the function gets called at all and it's coupled to the behavior of the garbage collector.
The current gofmt treatment of `if err != nil` is no biggie for me. I can easily mask it out visually as boilerplate do-nothing-but-return-zeroes-and-err and page through the extra lines of code it constitutes. However, `if err != nil` over 3 lines of code has been a big issue for people in the Go community. A rule change to gofmt to reduce it to 1 line solves more problems than it creates. It would make some people less happy (for a while) but would improve readability for many others, perhaps including those who shy away from Go because they see lots of boilerplate lines of code in an otherwise compact language.
Agreed. Readability wins. Hence the proposal.
Why are init() functions bad? (sorry, if its a stupid question, still pretty new to go)
No questions from new programmers are stupid. Basically the only purpose of init functions is to create global state and to have side effects, and these are usually a bad thing, and could be done in a better way that also offers the user of a package more control and predictability. See: https://peter.bourgon.org/blog/2017/06/09/theory-of-modern-go.html
Enable LSP, and avoid working inside your GOPATH for module enabled projects. Then make sure to update all the Go tools.
Why should I avoid working in the GOPATH?
Hmm, that's interesting. Just two questions: 1. How could you tell? When I did mod init I got v1.0.4 in my go.mod file. 2. Is there a way to fix that? Thanks for the information btw!
When using modules outside of the GOPATH the ENV `GO111MODULE` is always “on” by default, which means tools (including IDEs) know to use modules; but inside the GOPATH it will be “off” so you have to explicitly set `GO111MODULE=on`; which likely means that you’ve not set this ENV in certain environments (for example your IDE). It’s just easier to avoid the GOPATH for projects if you are using modules. This will be the default in Go 1.14
Is there no use case for a function to operate based on the actions of the garbage collector?
You should really handle errors everywhere but I want to point out two of the more interesting places: &amp;#x200B; fd, err := os.Open(path) defer fd.Close() if err != nil { return } Here you are calling \`defer fd.Close()\` before checking for errors. This is not safe, since \`fd\` will be \`nil\` if an error has occured. And if an error occurs, you should send back an error to the client. &amp;#x200B; fd.Read(fileHeader) Here you don't check the error, and you don't check how many bytes were read. In practice it will fill the entire buffer, but this is actually not guaranteed. The simplest solution is to use \`io.ReadFull\` instead.
Note that "on" will be the default in GOPATH with 1.13 if a go.mod file exists as well.
Let's say I don't think so unless you're implementing a garbage collector. Can you give some some examples?
It sounds like go modules is going through some hardship for the time being
Is working outside the GOPATH the recommended method of go development then
With Go Modules... yes. It will also make `go get` work as you would expect.
If you're not above paying a lot of money for a keyboard, you do that "in hardware" on [https://shop.keyboard.io/](A Keyboardio). It has open source firmware and LED key backlights. Just write our own accumulator for keystrokes and light the LEDs accordingly.
Oh I'm not trying to be a dick. It's all I can come up with given what little I know. The only thing I can come up with is maybe relating it to another problem I had where I grabbed a reference for an object and garbage collection destroyed it. We're basically accessing a thing not available &gt;Android 5 and replaced with a new object in 9. Garbage collection kept removing the reference. IDK how the guy solved it but he figured it out and we had a nice single malt. I'm not a mobile guy, never tried, but I think of there was a way to detect when the garbage collection was doing thing to fuck us up we could trap and get ahead of it. But I'm totally taking out my ass.
Golang itself isnt really relevant here, I think you're over thinking. A simple (http) API server in golang can take a request from a GUI and execute shell commands. I've done this a lot over the years, if I'm not understanding you right or you need more help definitely hit me up.
Or, you know, that they're being introduced slowly so they don't break everyone's stuff?
I'll do that with a HTTP REST API(go), and some js on the frontend to handle the requests and showing the results
How would it being the default in go1.11 not the default in go 1.12 the default in go 1.13 and not the default in go 1.14 achieve that??
If it is recommended to work outside the GOPATH then why did another comment say go mod will be enabled by default inside the go path in go 1.13/1.14
What about I18n? https://github.com/nicksnyder/go-i18n
I like how you made your errors constants, but your return nil, ErrParse is repetitive and provides little to no context on what exactly went wrong... you might wanna do something like this: https://play.golang.com/p/3ZprNplpMDZ
"Readability" is a subjective criterion. LOC are one metric, trying to make it objectively measurable. It's just not a very good one. I'm saying that, because you are far from the first person to suggest this particular change to gofmt and yet it hasn't happened - for one, because many people feel that the 3-line version is more readable than the 1-line version. So ISTM that if you want to argue that your perception of readability is more correct, you should be looking at some good metrics to that effect :)
Thank you for your valuable feedback, I'm going to change it / improve it right now.
For making the transition for GOPATH users as smooth as possible
Depends. When writing Go applications for AWS Lambda, one will find init very useful to preserve global state. This allows to reuse database connections for example.
No, but there is no need. Sounds like you're interested in building a mock version of `Template` and inject that into your code. Or you could use a special template text that outputs `Data` in a simple and stable format to compare against.
I don't profess to be an expert, but I think its accepted practice to use init to setup global's like db connections etc in lambda type environments. Its recommended in the cloud functions documentation for the go runtime, so at least someone with some experience of it thinks its neccessary
well, take a look at https://github.com/yudai/gotty first and also https://github.com/zserge/webview
I did this a while ago trying to figure out a configuration in vscode that works out of the box. The idea being that when you checkout out the repo for the first time the `.vscode/settings.json` comes with it (while any further changes you make to it are gitignored) https://github.com/pseudo-su/golang-service-template/blob/master/.vscode/settings.json. Settings: • `go.useLanguageServer: true` to use the official language server implementation from google because it’s required in order to support go modules. • `go.toolsEnvVars.GO111MODULES: "on"` to make sure that all the go tools know to enable go module support for this project (regardless of if it's inside your gopath or not) • `go.toolsEnvVars.GOFLAGS: "-mod=vendor"` if you want to make all go commands use the `vendor/` folder in the project (just like dep did/does) • `go.formatTool: "goimports"`: enables automatically managing/formatting package import statements, I think the golang extension uses `gofmt` by default once you enable the `useLanguageServer` flag • `go.alternateTools.golangci-lint : "${workspaceFolder}/bin/golangci-lint"` This isn't important but I did this because I wanted to lock down the version of `golangci-lint` and use a project-local version of it (to avoid issues where people have different versions of golangci-lint globally installed and there’s no way for a project to specify the exact version to use)
I personally find them useful with sync.Pool, to ease the need to drop values back to the Pool. Since the finalizer is called whenever the garbage collector detects an unreachable value with associated finalizer it will call the finalizer and clear the finalizer set, so that next time it encounters the same value, just to remove it. But finalizer puts the value to the Pool and thus garbage collector may not be encountering the value anytime soon.
I work inside the go path with modules=on, and it helps working with outdated packages
We use https://github.com/looplab/fsm but I will check this for sure.
I wouldn't, that ugly import path is enough for downvote
Fix import path. Create package to be beauty for user not for yourself.
My project works with a function based approach. You define a struct with functions and rules within a state machine. Then you let the state machine decide wether the struct is allowed to proceed with a function or not. This is *in my opinion* a better approach of a state machine.
Done :)
It's fixed now
eBay have a good post about how WASM improved their QR code scanner on their website dramatically. https://www.ebayinc.com/stories/blogs/tech/webassembly-at-ebay-a-real-world-use-case/
I reduced your function to 14 lines without any change into the language: https://play.golang.org/p/hsqG-OCzLZ7
\&gt; WebAssembly mostly extends / replaces JS I know. \&gt; And why do u need Electron app in WASM You don't if making an online webapp - I was talking if making a desktop app. \&gt; You can write regular web apps in Go, not desktop. Again, I know. But if doing a webapp, why use Go? Better options exist - fully fleshed out frameworks even. You can get a rudimentary good looking webapp up and running in no time using Angular or React. Where do Go fit into that picture? That said, making static sites with Hugo - which is Go based - is all well and good. But it isn't quite programming as such. And if making a desktop app with a GUI \*\*and\*\* using Go under the hood - you'd use something sensible and HTML/CSS free, like Fyne.
I see, so how do applications like WhatPulse get away with logging keystrokes and heatmaps? I’ve definitely seen a couple programs that do this so I’m curious if you know of any techniques.
Why are you getting function signatures as strings and what are you doing with them? In general, the best way to parse Go is to use the Go parser, since Go is written in Go, so you can get the official interpretation if you use it, but it may be overkill for your purposes.
Replace the calls to template.Execute with a call to a function or method that you can swap out at test time. This will also help if you want to eg render the page as JSON instead of HTML.
I completely forgot about the Go parser since my use case is pretty simple - however, I'm going to give that a try!
What exactly are you trying to achieve with this parsing?
I was able to get it to work simply with \`go.useLanguageServer: true\`
This is just an example (again) of Google that is trying to tie down environment, just like I said before in this thread.
I simply want to find out the return types of all functions in a project. :)
Always start with a monolith. Don't break it up a ton until you hit a problem. Just bake in interfaces where you need to so that you're prepared to break it up. Go isn't overkill, it's great for small things like this.
I don't find this a convincing response (and didn't find it a convincing response when Rob Pike first brought it up), unfortunately. Your `antidepressant` doesn't address control flow. The original function returned on the first error - yours continues to execute and just looks out if it has to replace actions with NOPs. While this isn't an issue in the correct case, I think it's kind of error prone. Future modifications of `unhappyFunc` must be very careful to not have any side-effects and because the error handling is implicit, that's an easy danger to overlook (arguably not in this *extremely* oversimplified case). Even in the correct case, you are still burning a little bit of extra CPU, BTW. That's probably not a huge issue in practice, but little inefficiencies tend to add up. FWIW, that's the true power of Monads for error handling - that Monads don't just wrap values, but that they abstract over control flow. The closest you can get to that is [using panic/recover with some extra wrappers](https://www.youtube.com/watch?v=QUC_uqP1WVI). But of course that comes with its own set of issues and still is kind of error prone and easy to break in the future due to its implicit nature. In my opinion, that's the true value `try` was attempting to bring to the problem - interfering with control flow in a way that is still explicit and type-safe. I'm not sure whether I think that's really *needed* (I'm fine with Go as it is, pretty much), but I don't agree that it's not a real value-add. (Also, I planned to write all of this up as a cleaner blog post a while back, but oh well, never got around to it =D )
I would say it differently. Don't even use these unless you're in a problem state where they are necessary. If you are in one of those problem states, please use these instead of trying to do the same thing but worse. The catch is that properly defining what those problem states are is fairly complicated. But managing non-Go state like file descriptors or the life cycle of objects in other languages you are bound to are perfect examples of where finalizers are significantly better than any of the alternatives.
I'm not sure you can do that with a regular expression. You would have to write a regular expression to match [TypeLit](https://golang.org/ref/spec#Types) and that doesn't seem like a regular language to me. It's at least *incredibly* complicated, even if you use a regular expression engine that… isn't regular :) Your parser has to be recursive, because type literals can themselves be function types. So, you have to add e.g. `func() func() int` and `func() func(func() (int, int)) func() int` to your list. Seems pretty hopeless to me - just use the `go/parser` package :)
1. It's not super important but a matter of choice and it's convenient for reading configuration from a file like .env and config.json etc. Otherwise you have to move the config files along with the binary file. 2. Using dot env (.env) file for storing all the configuration for the app is very common practice and a best practice. And .env file is usually added to .gitignore file and it becomes easier for other developer maintaining and reading the configuration. I skipped that part, considering most people are familiar with it, specially someone wants to deploy their applications. (That could be a separate article on it's own I guess) godotenv is a just a tool which reads the .env file, you can manage/read the file by yourself. Usually a .env file look like this ``` HOST=hostname DB_USERNAME=username DB_PASSWORD=password DB_NAME = database ``` And then the application reads the file at the starting of the application it depends on how you use it though. Some people also store those in OS ENV variable but I feel using .env very comfortable. Because I don't have to mess with other developers OS ENV. All they need is just to create a .env file and change the variables value which they have on their machine. Also you won't need to worry about changing any piece of code in the remote server. Usually the host, username, password etc are different than your local machine, right? Honestly, you never really want to push any secret variable to the git repo. It should be stored in a different file which will be skipped for commit. 3. I kind of agree with this. But this was for simple demonstration purpose. So if someone understand how it works they can definitely change the location wherever they want. Otherwise for the beginners they have to build the file and then they will need move the binary file and configuration files they have for the application. I tried avoid that for sake of the simplicity.
Sounds like a good use case for a lambda function
My thoughts too. Event driven over crons. And with these sorts of things you need to think about catching errors and retry, which I believe a lambda and bucket change trigger will handle for you. At least it will in google cloud. For more complex ETLs you can use something like airflow, google cloud composer, or aws equivalent.
What platform are you *actually using*, on which you would be running containers, that *doesn't have `systemd` installed and used by default?
This. Especially since you're already using AWS. For the http server, you shouldn't need to restart anything. When you read the file from S3, keep track of it's "last updated" timestamp. Every X minutes/hours (depends on how much you care about having a stale cache), read the "last updated" timestamp of the file and if it differs from the current one then invalidate the in memory cache. You could get a little more fancy with things if you need to avoid a stale cache, but this should be good enough.
regular expression will not work. try this: package main import ( "fmt" "go/ast" "go/types" "golang.org/x/tools/go/packages" ) func main() { pkgs, err := packages.Load( &amp;packages.Config{ Mode: 0 | packages.NeedImports | packages.NeedDeps | packages.NeedTypes | packages.NeedSyntax | packages.NeedTypesInfo, }, "fmt", ) if err != nil { panic(err) } if packages.PrintErrors(pkgs) &gt; 0 { return } for _, pkg := range pkgs { global := pkg.Types.Scope() for _, name := range global.Names() { if !ast.NewIdent(name).IsExported() { continue } obj := global.Lookup(name) fn, ok := obj.(*types.Func) if !ok { continue } signature := fn.Type().(*types.Signature) fmt.Printf("%s\n", name) returns := signature.Results() for i := 0; i &lt; returns.Len(); i++ { fmt.Printf("\t%v\n", returns.At(i).Type()) } } } }
Thank you!
Your editor (at least VSCode and vim) can also do this
Thanks to your feedback I've been able to improve it with this: [...] type AppInfo struct { name string version string path string } func Check(w http.ResponseWriter, r *http.Request) { if !HasHeader(r, "X-App-Name") || !HasHeader(r, "X-App-Version") { PLog(r, "Header Missing") return } var app AppInfo appName := r.Header.Get("X-App-Name") err := GetApp(&amp;app, appName) if err != nil { PLog(r, fmt.Sprintf("%s is an unknown App.", appName)) return } [...]
Just make sure to validate the user requests... Otherwise you may end up with them able to do remote command execution on your server... For instance `ping + ip -n 1; rm - rf /` .... Nasty way to go....
I don't know if this community considers this thread off topic or not. My reply was in service of directing you to a community geared specifically for this topic, rather than chastisement.
The correct usage is what is in the standard library, to deal with OS resources. Most other usage would be incorrect. I don't see an epidemic of incorrect use. Removing them would break a lot of code, and "solve" a non-problem.
RTFM: &gt; Go code may pass a Go pointer to C provided the Go memory to which it points does not contain any Go pointers. The C code must preserve this property: it must not store any Go pointers in Go memory, even temporarily. When passing a pointer to a field in a struct, the Go memory in question is the memory occupied by the field, not the entire struct. When passing a pointer to an element in an array or slice, the Go memory in question is the entire array or the entire backing array of the slice. https://golang.org/cmd/cgo/
RTFM: &gt; Go code may pass a Go pointer to C provided the Go memory to which it points does not contain any Go pointers. The C code must preserve this property: it must not store any Go pointers in Go memory, even temporarily. When passing a pointer to a field in a struct, the Go memory in question is the memory occupied by the field, not the entire struct. When passing a pointer to an element in an array or slice, the Go memory in question is the entire array or the entire backing array of the slice. https://golang.org/cmd/cgo/
This is a really good idea, I just tried it out by switching between JSON and HTML based on whether /api is in the url.
FTL or faster.
Yup I went with JSON as my simple and stable format in the end
You're trying to make a C shared library that exposes Go types. Think about that for a while...
Thanks I’ll try that out!
Believe it or not, individual contributors also have their own reasons to cut back on their projects. They're people after all, people who have families, newborns, limited amount of time in their lives to do the things they want to do. I doubt Google told anyone to stop working on anything. If you're keeping up with the personal lives of the lead developers (e.g. their Twitter), you'd know that they're busy people.
Just FYI lambdas max execution time was raised to 15 minutes
you an set the header yourself and wrap the writer with `gzip.NewWriter()`.
The HTTP spec does not support compressed payloads, as far as I know. That is, you can't send gzip'd JSON bytes at any random server and expect it to work. That doesn't mean this won't work, you just need to control both the client and the server and define your own "protocol" of how you're encoding and sending the binary, gzipped data within the bounds of HTTP.
The transfer from one place to s3 is really one line in shell, so don't overdo it with go. Put it in a cron. Only reason I'd go any other way would be if I'd need it updated within seconds of it changing.
I believe the answer the the 2nd test is that your struct contains a string, which itself is a little struct of { pointer-to-1st-char, length }. Therefore when you return a pointer to a MyStruct you would be returning a go pointer to a go pointer, which is not allowed by cgo\[1\]. I do not know why returning the struct by value is not allowed. Maybe cgo doesn't support returning a struct to C. &amp;#x200B; \[1\] because gc might someday move the inner pointer around, and would not be able to coordinate with the C code to update the pointer. The compiler puts magic to pin your outer pointer in place, but not any inner ones.
Ah.. make sense. Thank you!
Thank you! Issue was the server not accepting correctly.
from what I can tell from a brief look at that app, it's not tapping into the content channel directly, only receiving events from the input driver. E.g. it's being told "a keyboard input event was received" , and not which key was pressed specifically. (the OS usually tries to ensure that keyboard data is directed only to the application in focus, but general OS-level events can usually be subscribed to by multiple applications)
Use Go AST parser. It's not that complicated actually. Someone posted an example above.
Could bufio.Reader speed up the go read code?
Haven't had any success with Go111 modules and vscode. I went with GoLand and haven't looked back.
You could also do something with s3 write event tracking and lambda. For example: fire a lambda on file change, and have that lambda call an endpoint on your rest service to recheck. This could likely get your cache clearing itself in less than a few seconds with nothing more than a file modification in s3.
My little research result is: commands/data in transfer to/from SD card is protected by CRC. Stored data is not. It kinda makes sense: if filesystem is not smart enough to tell temporary data, the SD card doesn't have slightest clue then. It could assume all-secure mode, spend storage capacity and cycles for integrity, loose benchmarks and rot in warehouse. &amp;#x200B; Can't recommend enough this great reading, if you're into hardware stuff: [http://users.ece.utexas.edu/\~valvano/EE345M/SD\_Physical\_Layer\_Spec.pdf](http://users.ece.utexas.edu/~valvano/EE345M/SD_Physical_Layer_Spec.pdf) I'm going to copy few design decisions from their SPI protocol, wish had read it earlier. &amp;#x200B; And this small library was born: [https://github.com/temoto/extremofile](https://github.com/temoto/extremofile) works well as it should.
With apologies, but that's not correct. There's a header the client sends for whether it can accept gzip (or other methods), and then the server can send content compressed in one of those ways, with a label for which way it chose. See: https://en.m.wikipedia.org/wiki/HTTP_compression net/http takes care of some of this automatically, but I don't remember the details.
This doesn't work if there are multiple servers serving the data is in the S3 file. You'd have to hit each server's update endpoint rather. I'm sure AWS has something that handles this but it seems like more work than just having the servers check to see if they need to invalidate their own cache every few minutes.
Yes, you’re correct for the server response to the client. The reverse of that doesn’t work though (the client sending a compressed request to the server)
The GOPATH setting for the purpose of the configuration file doesn't make sense to me and seems like it only relates to how you decided to build and deploy from your GOPATH source location. And yes I know what configuration files are. That part doesn't need to be explained to me. My issue was that in a tutorial about supervisor, you chose to use a 3rd party dependency and extra concept with the approach of the dot env file in the root, but you didn't explain it or tie it into your tutorial. All my apps use config files, but I have not used this particular one. I'm just saying that I think a tutorial should avoid using too many dependencies or concepts that do not get tied into the main concept. Now what I think might be cool is if you quickly explained your use of the dot env approach and then showed and explained how you are overriding a few settings from your supervisor conf environment settings.
Sure, depends on your architecture and requirements, of course.
Go automatically decompresses gzip it receives but you must manually compress what you send. Fortunately there is middleware for this: https://godoc.org/github.com/go-chi/chi/middleware#Compress
Second this
look at the -o build option
It is marked deprecated in the docs. Any clue what is the replacement? As there is not mentioned what substitutes this thingy.
It's not the package name. The package name should have been 'main', right? It's the last element of the directory path.
When you go build it you can set the -o flag and specify a different name. Default is IMHO git repo name
Who said anything about containers? Containers implies that there is a daemon that can run your container already, right? OSX would be an example of a case where you want to run a binary as a service and it doesn't have systemd. Supervisor works the same way regardless of the platform-specific process management solution.
Sorry, yeah, I meant GitHub package name which coincidentally is the last element of the directory path. Any way to change that?
Thanks. Can you share more details on it as to how that will change \`go get [github.com/](https://github.com/)&lt;user&gt;/foo\` for other users?
It won't affect `go get`, which simply uses the name of the directory that `main` is in. If you want something else, you'll need to provide build instructions like `go build foo -o bar` which will generate a binary named `bar`.
Great work, but why not put a PR against go-pg?
You can move where the binary lives in the package, maybe `github.com/&lt;user&gt;/foo/bar` or `github.com/&lt;user&gt;/foo/cmd/bar`
I thought about that. But as there are still missing features, i decided to put it out as a module for now. I have not decided yet what way I like choose in the feature. Either create an PR for go-pg or create support for lib/pg in addition to go-pg
Decorators are usually just sugar over a higher order function, so Go is already 90% of the way there. That being said, most of this community likely has PTSD from annotation driven development, so I expect it to never, ever happen.
Just make a function that takes a function and returns another function. You won't be able to write a generic decorator (at least not a typesafe one) and the application site won't rebind the result to the name of the original function (but that's a feature; Python decorators make testing impossible in the general case because you lose any reference to the original function).
I don't think Go has any capabilities for such a thing. Java and C# sometimes use this pattern as well. One thing I will say is: how convenient is it compared to the overhead of figuring out how it works? In Python, decorators can take a function and then just replace that function, but in a static language (like Go, C#, or Java) they're meta-data that can be reflected on (similar to Go's struct tags). So, what does this syntax get you by going outside the normal program flow? In a language like Go, you could do something like (this is pseudocode in both cases): router.GET("/mypage", pkg.MyFunc) func MyFunc(r Request) { r.Response().Json(myThing) } How does this feel compared to the Python/Java/C#: @GET @Path("/mypage") @ContentType("application/json") def my_page(r): return my_thing Now, you might say, what if there's a response filter that I want applied to some functions and not others? Well, that could be set up when you do the routing or you could do it directly in the function: func MyFunc(r Request) { r.Response().Json(MyResponseFilter(my_thing)) } It's just as easy to forget a decorator as it is to forget calling a function. And most of Go's routers support grouping a bunch of pages together so that they all use the same middleware and you don't forget one. So, the amount of code is basically the same. But now you have to wonder, what code is responsible for mapping the path to this function? When I return "my_thing", what code is determining how to actually put that into a string to be written to the network? There's a lot more questions and it doesn't go through the traditional function-call flow. I think Go tries to tell you that you should really be using the traditional call flow rather than trying to make something that might be a cute way of expressing it, but then obfuscates what's happening. When we say r.Response().Json(myThing), we can click into that and see exactly what's going on. It's a normal function call just like anything else. The @ContentType is certainly something you can figure out, but it somewhat inverts how the function works. In fact, if I call my_page outside of the web request, am I going to get a String back that's the Json representation of my_thing or am I going to get my_thing? Under what circumstances does @ContentType kick in? Heck, when something goes wrong and you can't figure out why @ContentType isn't being processed, how hard is it going to be to debug it? I work with things like this and they can certainly be cute and feel nice, but when they go wrong, you end up eating a lot of time trying to figure out what isn't hooked up correctly. I think Go pushes for simplicity. Ultimately, you don't need an @ContentType("application/json") to write out Json. You can just as easily call a function. Likewise, you can call a function to set up your route mapping. Why force users to learn more ways that something could be done that don't offer a substantial advantage? Why make the control go in a weird direction? Again, these things can be neat, but they can be harder to understand and debug ("it just magically does stuff!") and Go seems to be of the opinion that it's better to just use a small number of well-understood abstractions.
Golang is slow to adopt any new syntax. A basic try built in was rejected recently. There aren't generics either. I think something like decorators will be on the very last long list of features. I doubt we'll see it ever due to golang historically being very apprehensive about adding new syntax.
This is just my personal opinion, but annotations add unnecessary complexity. An otherwise simple function is made complex by needing to look for the existence of supported annotation meta-data, and provide a case for when the annotation does not exist. Using higher order functions, I can decorate a function without needing to look for meta-data. All of such functions remain unit testable in isolation and are explicitly applied within the normal program flow.
Yep, coming in Go 3, right after Generics, monads, halting?(func), and the floss operator
Struct tags were enough to trigger my PTSD and they aren’t even that bad.
`go help get` claims it accepts build flags, and there is a build flag `-o output`, so you can try `go get -o bar github.com/&lt;user&gt;/foo`. I haven't tried that myself, though.
I think the Compressor type in the same package does the same through its Handler method
I like gofmt and use it to format even auto-generated code. I personally don't need a change to gofmt. But many people, it seems, from the recent debates over err != nil ARE concerned. I'm not worried about my perceptions of readability, and neither should you worry about my perceptions of readability. I don't have a problem reading error handling code. The emphasis on error handling is a huge strength for Go, and particularly the reluctance to obscure it with Java-like try blocks and such. But if many people have been so concerned as was recently evidenced by the debate that culminated in the try() proposal, then those concerns may need to be addressed. I think that's valid subjective comment. As for objectivity: a set of 0 or more zero return values with an err != nil is unambiguous.
[removed]
Did you read the [mailing list thread](https://groups.google.com/forum/#!topic/perkeep/Kqvh2dJVmoo) linked in the Twitter announcement? Why do you think Google was involved at all?
Is this what are you looking for https://github.com/tensor-programming/pattern-tutorial/blob/master/decorator/main.go ?
Yikes. Someone running the binary can suddenly have their static assets swapped out, likely breaking the binary or the app. The point of bindata is to make a permanent copy that is ready to be deployed, independent of anything else. People often use docker for the same reason and use it instead of bindata. It’s what makes Macs .app files so potent compared to splattering files around the system like you would on windows. This approach breaks that, and adds external runtime dependencies. This doesn’t sound even remotely interesting to me.
Isn't there already [`pg.ParseURL`](https://godoc.org/github.com/go-pg/pg#ParseURL)?
It sounds like this could be a server application that didn't need constant redeployment; but could still use git-based version control.
I could potentially see some use cases for this, but they’re very limited. For 99% of apps, I agree with you. The main reason I have for using Go for a project is to get a self-contained binary that runs with no dependencies. Also, I wonder the choice of using Git, it’s not really the most efficient of all protocols for fetching data.
There are things that people might realistically want to do that are rendered impossible by this architecture. For example, having two components in one process (say, two servers on different ports) that could parse different sets of proto definitions. Where you see potential for misuse, I see a component graph that's explicit about its dependency relationships. (shrug)
Yea I was thinking about that after I posted. Depending on the API, it may be fetching huge swaths of extra metadata.
This still sounds anti-pattern. When doing proper DevOps you normally want to control how the code is rolled out, so you can do things such as rolling and blue-green deployments, you want the ability to roll-back... I’d argue we have Continuous Deployment tools that are good at replacing binaries (or containers) with zero downtime.
Come on. We are talking about Pond, Camlistore (Perkeep) and Upspin. All of them were projects that came out of Google employees. All of them also were rather public and were supported by people other than Google. And all of them are in the process of dying (except Perkeep maybe).
I've heard that some people do use the internet to provide content successfully, and that versioning _can_ happen there to lock binary versions to consistent assets. While it's not appropriate for every use, I think you are being a bit too dismissive.
It’s the very problem many of us have with languages like node, where libraries can be swapped out from under you. Because it works does not mean it’s successful.
Let me correct you, "the choice of Github", not Git. Git is efficient, Github API is not, that is correct. It all depends on the use case. The lazy loading, and the fact that each file is loaded only once makes the use of Github reasonable. A possible improvement I can see is to use Git instead of Github API for the "pre-fetch" mode.
A common way to use static content is through Amazone's s3, which is not content that is packed to the binary. This library makes Github something like a free s3, with an easy to use API on top of it. Actually, now that I think about it, maybe adding s3 as another backend to this library will make sense :-)
No, Git isn’t efficient in this use case. Any time you clone a repo, you’re cloning the entire history (and I’ve worked with repos with GBs of history). You could clone without the entire history, but then the server would have to calcolate this for you, which takes time.
People use s3 and cloudfront as a way to distribute load to them. If they’re handling static content then good. But those also are almost never distributable. It’s a very different hosting metric.
Of course cloning the entire history is not what you'll choose to do in this case.
BTW, maybe you missed that, but this library also supports binary packing.
Thanks for letting us know. Do you want a pat on the back or something? Goodbye.
\&gt; Someone running the binary can suddenly have their static assets swapped out &amp;#x200B; Looks like the lib takes care of that problem by supporting Git tags. If the repo changes, existing binaries would still fetch "their" version of the data. The remaining risk is that the repo goes away completely, so I would use this solution only for Go code and data repos that are under my (or my team's/my company's) control.
I want one [Sit-Gopher](https://go-store.io/collections/all/products/gopher-decals?variant=27975550632038) for one dollar.
[removed]
You could achieve this in WebAssembly too :)
&gt; _If golang cared about us, or about the world, and the environment, they would have seen the outrage in themselves and charged $0.50 for a stamp to mail one sticker. If anyone wants to send me one Sit-Gopher I will pay you for your stamp and your sticker._ &gt; **submitted by** /u/KPop_Poster Give me your full name, home address, phone number, and I’ll send it to you for free.
I will give you my address, the name "Sit Gopher", but not my phone number.
I searched _“golang copy file to another directory”_ on Google [1] and found the solution [2][3]. [1] https://www.google.com/search?q=golang+copy+file+to+another+directory [2] https://opensource.com/article/18/6/copying-files-go [3] https://shapeshed.com/copy-a-file-in-go/
Sure, but `ParseURL` does not support URL Encoded socket paths. Most of the parameters supported by `libpq` are just not handled, it can't parse the key-value based connection strings and it does know nothing about environment variables.
&gt; Which way is better to follow ? Better is relative, depending on the case. However, if you just want to copy the file, you should be fine using `io.Copy` like method 1 in your linked article.
I've used [github.com/NYTimes/gziphandler](https://github.com/NYTimes/gziphandler). Worked well in my case.
Since author mentioned git, I'm assuming the assets are tied to specific revision so that might help a bit, although that's kind of meaningless if malicious person owns the repo. I was thinking that maybe you could use it in corporate environment, but then you still wouldn't want to have your availability tied to internal git availability
&gt; My little research result is: commands/data in transfer to/from SD card is protected by CRC. **Stored data is not.** (Emphasis mine) I'm not sure I understand correctly. The research shows there's no CRC stored together with a data block on the SD card, meaning that when the block is read back, there's no CRC to check against?
This is what I see frequently, people often try to use git for fetching latest configuration files and are trying to squeeze it to do what they want, when if they would choose for example svn it would be ideal for the use case. In svn you can fetch just the subset of the repo (i.e. a directory or a single file) the latest version is also effortless. Since SVN uses WebDAV freezing latest version of a file can be done through a standard http request. Having assets downloaded at runtime has its own issues, but git is not the most efficient tool for this kind of use case.
What's the sense in licensing the binding under MIT, if the QT itself is under GPL, partially LGPL and even under AGPL, which are only compatible with MIT if based upon MIT licensed source code, not vice versa? And there's no way QT will be republished under any other license anywhen soon. Unless the recode all depended code from the scratch. Well, there's no way they are going to lower the prices for closed sourcing either. So, they list a dozen of bindings for their project on their own website, this one is going yet another one, which with all the due to respect won't make any big difference in the overall situation.
Well yes, but more strongly I couldn't find evidence of **any** effort to read same bits. I mean there are lots of error detection mechanisms.
We do support complex matrix creation, see `mat.NewCDense`, but the CDense type is very barebones. We also already have BLAS Level 1,2,3 implementation for complex64/128 in pure Go but it is not used by CDense due to lack of manpower. If you have your complex matrix type, you could use the functions in `blas/gonum` internally, they are well tested. If you need more advanced functionality like factorizations, we don't have that and probably won't have anytime soon - porting the corresponding functions from LAPACK is a huge amount of work.
Okay, I got your point, I'll update the article. I should consider and explain it better if anyone have difficulties understanding or following the tutorial.
I once thought about that and tried out the go parser. It can parse function comments, so one possibility would be to use code generation and templates and render them based on the parsed comments containing whatever decorators you wish but that's more like "it's possible but not feasible approach"
First of all, it's possible and allowed to build proprietary app using Qt open source edition, as long as we follow the obligations of LGPL v3 license (which has been explained nicely in Qt's [FAQ](https://www.qt.io/faq/) : - We must not use Qt's module that licensed under GPL, e.g. Qt Charts, Qt Data Visualization and Qt Virtual Keyboard. - We must provide the source code of Qt that we used while building our app. So, for example, if we build our app using Qt 5.12.4, should the user ask for it, we must be able to give him the copy of Qt 5.12.4 that we use. - The user must know that we uses Qt with LGPL license. - The user must be able to re-link our application against a different version of the Qt library, which means dynamic linking is mandatory. However, it doesn't mean we obliged to make sure our app will work if the user re-link our app. And, well, that's it. As long as we fulfill those requirements, we should be legally able to build an app with whatever license that we want, including MIT license or proprietary. This bring us to your question : &gt; What's the sense in licensing the binding under MIT ? One of the reason this binding exist is because [therecipe/qt](https://github.com/therecipe/qt) is published under LGPLv3 license. As the [FAQ](https://github.com/therecipe/qt/wiki/FAQ#can-i-make-a-proprietary-app-with-this-binding-) in therecipe/qt explained, it's impossible to create proprietary app using therecipe/qt. Quoting the FAQ : &gt; As we know, Go compile its code into one single executable file. Now, what happen if end user want to change the version of therecipe/qt. For example, you deploy your app on 21 June 2017 using commit 5b0427c, but when your user use your app on 20 July 2017, the latest version of therecipe/qt is 4e40d6b, so your user want to change his app, on his own, to use the latest version of therecipe/qt. &gt; ... &gt; Go by default static linking all imported package then converted all code into a single executable that can be distributed easily. Therefore, if end user asking for your app's source code, you don't have any choice except giving it to him. So, since AFAIK Go doesn't provide ability to easily dynamic linking a package, this makes therecipe/qt is not exactly suitable for my need. Hence why Qamel exists. In other hand, since Qamel uses MIT license, I can create proprietary app in Go, then dynamic linking it to open source version of Qt. &gt; And I suggest that you better stop misleading people about how they can use the QT, before anyone will get caught up in the real legal battle with QT. No, Of course not. I'm not sharing this binding to "mislead people" to use Qt. First, AFAIK there are no QML binding which has good documentation and still active except therecipe/qt. I've used it extensively in the past, and it's really nice. However, its license make it not suitable for my job. Second, other GUI alternative for Go mostly uses web interface like Electron, which is too heavy for the requirement in my job, so I can't use it as well. From those problem, I decide to create Qamel. And since its quite stable for me, and I figure other people might have the same problem with me, I decide to share it here. Besides, this binding is still usable for building open source app, so IMHO it still worth to share it.
Why is there a lack of manpower? Can we contribute to work on it?
You could use webview or fyne
Electron is bloated and not the most native feeling, but it definitely has the easiest learning curve and provides good looking results (as opposed to Qt on most platforms). Also you’d be surprised how many apps are using Electron nowadays
Thanks for your reply. By native front-end app do you mean an app that runs on browser? Because thats not what I want.
We are a small group of volunteers with a limited amount of time. Sure we welcome any contributions, we'll be happy to review your PRs and give feedback and advice. Adding a support for complex matrix arithmetic to CDense would follow what exists for Dense but it would be best to take the discussion to [https://groups.google.com/forum/#!forum/gonum-dev](https://groups.google.com/forum/#!forum/gonum-dev)
I mean a OS-native app. So something like Cocoa on macOS or UWP on Windows. That would offer the best experience, but you’d have to make a separate app for each platform.
Calling it gitfs is confusing. Makes it sound like a different take on SparkleShare
Sure, I will do just that. Hope we get to work together :). Happy Coding!
I don't think the problem some people have is that it spreads over three lines, I think the main issue people have is that they have to type it at all. If you come from python, java or any language with Exceptions the if err != nil paradigm seems odd, at first. This is compounded by the narrow error interface. &amp;#x200B; I do think your example is a little contrived, because you would never actually write code like this. There are many ways as people here have already alluded to that could make your example better, here is another example of using a loop: [https://play.golang.org/p/cCv8na\_DDV6](https://play.golang.org/p/cCv8na_DDV6) It's why people often say the LOC is not a metric to judge code by or for that matter readability. &amp;#x200B; I am not saying this is a bad proposal but maybe it shouldn't be a gofmt proposal but more a language proposal to support ternary operators. That way we could get many things that currently span over 3 lines to just one and maybe more useful. This is a little above my paygrade but maybe something like this? `(err := NeverHappy(); err != nil ? return err)` &amp;#x200B; Obviously, that's just me spitballing but the question then becomes is that more readable and does it improve the flow of the code, it's readability. I am not sure that it does. &amp;#x200B; I would also guess ternary operators have been proposed before.
Thanks I'll look into that. Although I've no idea how can I make UWP communicate with go backend?
Thank you for your reasonable explanation. I hereby withdraw my complaint, yet, leave the comment for the sake of history.
...I am so confused by this. Was this written by a bot?
https://tools.ietf.org/html/rfc2616#section-4.2
HTTP spec RFC 2616: Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)]. It MUST be possible to combine the multiple header fields into one "field-name: field-value" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma. The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded.
So you can store multiple header values with the same name..
You can set multiple values in the header. Here's an example: ``` // Return results w.Header().Set("Status", "200") if useCSV { if isDL { w.Header().Set("Content-disposition", "attachment; filename=\"data.csv\";") } w.Header().Set("Content-Type", "text/csv; charset=utf-8") csv.NewWriter(w).WriteAll(geneCSV(result)) return } if isDL { w.Header().Set("Content-disposition", "attachment; filename=\"data.json\";") } w.Header().Set("Content-Type", "application/json; charset=utf-8") ```
Doesn't explain it. Yes, you can have multiple values for the same name, but only if they can be combined into one comma separated value. Why does Go not do that?
Just to be clear: You where using LOC as the primary metric to justify why you think this is a positive change. I'm trying to tell you why I don't think that's a good basis to argue for this change, to help you come up with a better one to push for this change. Your hostile reaction is thus uncalled for - I put effort into engaging with your suggestion positively and if you don't want feedback for your idea, you shouldn't post it. So again: 1) Everyone has a different perception of what is or is not "readable", so just saying "Readability" isn't an argument that can be worked with and 2) LOC is not a good metric to use to defend your notion of readability. And, FWIW, 3) neither is "something needs to be done, because people are obviously concerned" - you should argue that *your* something should be done, not just that *any* something should be done. Do with that as you will. But don't expect people to listen to you, if you snap at them and ignore their feedback when they try to engage with you open-mindedly.
The documentation for Add() explains how this can happen: https://golang.org/pkg/sync/#WaitGroup.Add It implies that you might be allowing more calls to Add after your Wait has started and not returned.
It's one of my huge pet peeves when people design APIs with comma separated values. It adds more work and shows an ignorance of how headers in http work. Just do ?a=123&amp;a=456 and you make both the client and the server simpler to write
a language, where you need to read an article about "this" to understand it is not easy. especially if you use third party libraries that are composed of hacks and dirty JS to accomplish something. &amp;#x200B; But i agree, it is easier to "start typing" something in JS and get results than in any other statically typed language. But often the results are unexpected, especially for people that just started with JS.
I wonder what gophers think of this pattern considering their "clearer is better than clever" and "line of sight coding" mantras. To be clear, I like the idea of implementing the decorator pattern using higher order functions, but the typical Gopher is confused by them in my experience. They seem to be more familiar with "OOP"-style decoration with interfaces rather than with a functional style.
Why would Go do that? The comma separated string is just a serialisation of a list. Don't leave your data in encoded form - you have data structures in your programming language - use them. It is really annoying how people treat so much structured data as strings, encoded in some form. Don't do that. It leads to so many bugs. If the structure is naturally a list, just use a list.
You’re describing the query string, not the headers. Or am I missing something here?
This is for http response but I need one for request. One commented out http spec doesnt support this
Don't buy anything from here: it says the profits go to a discriminatory organization.
No, it's successful. Plenty of companies deliver content over the internet that is version pinned. There are a good number of ways to achieve this, from providing the full content for every version to using manifests for every version that tell you what versions of individual assets to get. If you play a mobile game, there is a good chance that some of the assets may be delivered like this to avoid initial download sizes for the app itself. The companies that do this have large revenue streams riding on that. If you play a PC game, it is almost certainly content patched through a CDN, and potentially delivered through one too. If you started up WoW in a free trial, it would stream down assets as you played. If you played Eve Online, it would use Download on Demand.
Sorry yes, meant query string
Author seems to be Russian.
This is a terrible article. Terrible English. Even gets Robert Griesemer’s name wrong.
It reads like every word was run through a thesaurus.
Your conversation on Discord was via a client written on Electron. Slack, VS Code, Evernote, Skype, Etcher, and Mailspring are also Electron. Certainly those are more sluggish than a native solution, but if you are okay with what you experienced in any of those applications and do think it would be the easiest way to write a UI in the way you like, then I recommend you go for it. As someone else said, you can still use web technologies without having to deliver a huge package via something like https://github.com/zserge/webview so that might give you the trade off you're looking for. If you are comfortable with Kotlin, that's probably a good choice
You would probably use HTTP to talk back and forth which means the languages on the front and back don't matter. Any language can speak to any other language over a protocol they both understand without needing to know what the other language is.
Loads of http servers have middleware patterns already, see for example: [https://github.com/go-chi/chi#middleware-handlers](https://github.com/go-chi/chi#middleware-handlers)
That’s really not at all how those systems work.
That site is so weird, it seems like every article is written by the same person, but they slapped on a different image on each profile. Many of the profiles have email addresses like "marketingreddit044@gmail.com" The account that posted this here (/u/Rabidmono) stopped posting **9 years ago** and then suddenly about 20 hours ago started posting at semirandom regular intervals every few hours across a whole range of different subreddits ... Smells like a spammer to me
The repo you found is not official in any way. There are lots of patterns it discusses that are widely accepted and a few that are much more controversial. It does a great job showing many patterns regardless of if you use them, but I would guess that nobody agrees with all of the things shown. Personally, I only use a dist folder if I am working on the type of project that will have more than one output file. Since there is static linking, it isn't necessary to worry about a dist folder if you are only creating a single file binary with no media files or anything. You do not need an src folder. It adds unnecessary nesting since there aren't as many auxiliary files in your root folder as there would be in a JavaScript or Typescript project. Furthermore, packages are named after the folder they are in, so this would link in the import URLs. You do want to prefer use of go mod over GOPATH for new projects. In theory the GOPATH will eventually be deprecated, I'm so I expect that to be a slow process. It is also very nice to be able to clone a project anywhere. Since you weren't very used to the language yet, I tell people it's better to start writing code. You might have some uncomfortable refactoring a few times in your future, but if you try to determine the perfect organization before writing any code, you will never write any code. One major difference between Node and Go is that the standard library is very solid with lots of consistent mature functionality. Often in Node you will go grab a third party dependency to solve something. Go developers tend to try to keep the number of dependencies to a very tiny handful instead of the thousands you can sometimes see in Node.
If you want a native UI, the Qt bindings are really solid, I quite enjoyed using them for some small stuff: https://github.com/therecipe/qt I've seen others recommend them in the past too. I'd personally avoid GTK bindings with Go as all of the bindings I've tried have been quite incomplete, and the documentation for GTK isn't great either, whereas the Qt documentation is good, and the Go bindings are easy to work with using that documentation.
On Go Modules - do use them, don't use any other approach to dependency management that you may have also heard about (e.g. Glide, Dep) as they're legacy approaches and the community is shifting to Go Modules as the standard. It's good that you've heard about the history of this already though :) Standard project layout provides you with some base ideas of where you might put certain things. I think the for the most part it hits the nail on the head (i.e. `cmd/`, `docs/`, `examples/`, `internal/`, `scripts/`, etc. all good). My recommendation for you when thinking about how to structure you packages with Go would be structure things by _domain_. By that I mean, don't make a package called `controllers` or `models`, have something like `auth`, `blog`, `cart`, etc. so that you can name your types in a way that will make them read well later (e.g. `auth.User`, `blog.Post`, `cart.Item`, etc.) If you'd like a good example of idiomatic Go package structuring, take a look at the standard library (also great for looking at how they've solved certain problems, how they name things, what the code style is like, so on), and another good example is [upspin](https://github.com/upspin/upspin) (in particular I like their approach of having a package named after the project that contains app-level types). You asked about `src/` and `dist/`. Don't bother with a `src/` level, it's unnecessary nesting and separation when you don't need it. With Go you're building a binary, as a single file. Having a `dist/` folder with Node.js may be necessary if you've got a compilation phase that produces many files, but in Go you're more likely to do something like build the binary and shove it straight in a Docker image on it's own without any source code. Not sure what you mean by that last part about workspaces. With Go Modules you can put the repositories for your code anywhere on your machine, so if you have a workflow already around where you place your repos, then you should be able to continue using the same workflow.
Bear in mind, Goroutines can't be nested, they're all top-level siblings. If you create a Goroutine inside another Goroutine it's not a child of that first one. If you're reusing a waitgroup for the outer Goroutine and the inner Goroutines then it sounds like you could be calling methods on the Goroutine at the same time as each Goroutine is processing things at different speeds. You've got a race condition. You should just be able to create a WaitGroup for each of your "inner" Goroutines, and call `.Done()` on your "outer" Goroutine straight after waiting for each "inner" one.
github.com/amlwwalker/got-qt I put that together to help making UIs with Qt and go...
Don't put the binary in the root of your repository, put it in a `cmd/bar/` folder. When you `go get` it, it should be called `bar`.
I'm on the "Bad idea" side of this. I don't like things that seem more magical. I like the code to be super explicit. I also think that annotations introduce tight coupling, routing is a good example of this, as it prevents code re-use. Handlers as they are now can be dropped into any router, at any path, as the handler doesn't control it's route - that's definitely a good thing.
But it also doesn't split a single comma-separated header value into a sequence. It's represented as a list so that you can access the header value exactly as it was received without interpretation, and because it's faster not to process it in any way.
As he said in the video, I think it's fairly common for doing HTTP handler middleware. Get a whole bunch of func SomeKindOfMiddleware(h http.Handler, anArg string) http.Handler { return http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) { // ... h.ServeHTTP(rw, req) })) } This is with interfaces, but it's basically the exact same thing, just slightly more generalized. You could easily just use `http.HandlerFunc`s, too. `io.Reader` and `io.Writer` chaining is fairly similar as well.
There's a category for this on [awesome-go](https://awesome-go.com/#gui). Also, just today the author of [qamel](https://github.com/RadhiFadlillah/qamel) posted that here (bindings for QML-based apps).
In addition, it means you can `go get` the code and have it compile it for you, skipping many steps of cloning, generating code, and then compiling.
Great this helps clear things up a lot. Appreciate you taking the time to explain everything.
When we've started with e2e tests, we chose [tavern](https://taverntesting.github.io/). It is a great tool written in Python (our team was switching from Python to Go) with simple yaml-based syntax. The main disadvantage is not great support of jsons: as Go returning maps in random order, it requires to configure weird expressions with [JMESPath](http://jmespath.org/). But anyway, this tool is fine for basic HTTP testing. But now we are in progress of switching to [venom](https://github.com/ovh/venom) tests executor. It is written in Go, relatively easily customizable and has built-in support of the multiple protocols. Not only HTTP, but gRPC, IMAP, could apply fixtures to the databases and use any executable by capturing stdout from it. How our e2e tests are organized: * We have separate folder `tests/e2e` where we have docker-compose with database, mocked external APIs (nginx with static responses), StatsD logger and tavern/venom tests definitions. * We are using our production image during e2e tests to make sure that the image is working correctly. * Our e2e tests definitions could be also used as documentation for our service. * We are testing only basic flows in e2e stage without all edge-cases. * Also, we have the second image with delve binary which starts `dlv` in headless mode and allows remote debugging. But on the other hand, I believe the approach with writing e2e tests directly in Go could be better for the majority of use-cases.
Actually Spotify's desktop experience is now a progressive web app and not in Electron, at least on Mac and Windows, as far as I know.
Afaik It uses CEF (Chromium Embedded Framework) . But I've no idea how to develop such app or if I can use the CEF with Golang.
Syntactically, there's a difference between a function signature and an interface, and you can't just trivially swap back and forth between them. However, I'd observe that at the *program design* level, there's actually not a lot of difference between type SomeInterface interface { SomeFunc(int) string } and type SomeFunc func(int) string You can even implement the latter with a struct: type SomeStruct struct { Offset int } func (ss SomeStruct) Stringify(i int) string { return strconv.Itoa(i + ss.Offset) } Now if you have `something := SomeStruct{5}`, you can pass `something.Stringify` in to something as a conforming `SomeFunc` value; Go takes care of making the obvious closure for you under the hood. Interfaces don't become something that a func type can't be until they have more than one method in them. (There's nothing wrong with one-method interfaces, as they are good documentation of intent, allow easy growth in the future if necessary, etc. But if hypothetically, interfaces were limited to one method only, there wouldn't be a lot of daylight between them and a func type.) And I mention all this because I think if you take this perspective on interfaces, there isn't a lot of difference between "OO-style decorators" and these function-style decorators; it's just decoration, either way.
A web app.
I've written off using multiple query values like that, because so many environments/frameworks/libraries just explode and die with them. Dynamic languages like to make it "easy" to use query values, so they like to return a string if there's just one value with a particular name, but then someone notices a couple of years later that there can be multiple values, so for backwards compatibility they'll return a list if there are multiple, and now the universe explodes because suddenly a ton of things programs used to safely assume were strings may also now be lists. There have been security exploits because of this type confusion. There's plenty of other environments that will put them in the local equivalent of map\[string\]string and take only the last while parsing, so you put this into an API and the programmers come back with "Our framework won't let us do that and now we have to parse it manually, say, is this regular expression a good way to parse query parameters?" (Usually, no. This *is* a case regexps can handle, but while there's a decent chance they'll at least separate the parameters correctly, usually the decoding step is subtly wrong.) Generally you just want to have a consistent policy of "take first value with a given name" (which turns out to be slightly better than "take last", although if you consistently apply that it's not really the end of the world; anyone who exploits something by appending to a querystring you generated already broke something to get that far anyhow). It's just too much pain to try to get the rest of the world to understand this. Mind you, I'm agreeing about it being a pet peeve; I just find that trying to boil the ocean to get frameworks and libraries and programmers to handle this properly isn't worth the hassle and security vulnerabilities. If I were King of HTTP and I was re-writing the spec, I'd just specify it as take-first-value in the spec.
[CEF BitBucket page](https://bitbucket.org/chromiumembedded/cef/src/master/) &amp;#x200B; Go CEF bindings: [CEF2go](https://github.com/cztomczak/cef2go) [CEF](https://github.com/richardwilkes/cef)
Which language that has a url parsing library does not support? Seems like it would be more of an edge case to me but maybe not, some people probably write their own parser even if the standard library have one built in but people like that will always introduce easily prohibited bugs anyways. Both NodeJS and Python which probably are the two largest dynamic languages in use supports parsing urls properly.
Don’t do that, please. [Don’t add a webserver to your desktop app](https://arstechnica.com/information-technology/2019/07/zoom-makes-it-too-easy-for-hackers-to-access-webcams-heres-what-to-do/) Use some bindings instead: https://medium.com/learning-the-go-programming-language/calling-go-functions-from-other-languages-4c7d8bcc69bf
Qt is ok but it doesn’t feel native on platforms other than Linux. On Windows, it looks like an old Win32 app; on Mac, it feels like a ported app. :(
That's not what I'm suggesting. Usually when someone talks about a "backend" they mean a server-client application. The OP described a project like Evernote, which is almost for sure sending data to a remote server so that the data is synced between devices.
&gt;Which language that has a url parsing library does not support? It's generally not the "language", but some web framework written by someone who doesn't understand HTTP/HTML. Unfortunately, "some web framework" sometimes gets quite large and popular for various reasons. If you go hunting, a lot of web frameworks still have warts that show they were written by someone who didn't *initially* understand HTTP/HTML, but learned the hard way over time. Dynamic languages are really bad too... despite what may seem obvious, in a lot of ways they handle things like changing from a guaranteed string to "maybe a string, maybe an array of strings" *way* worse than static languages. Static code breaks obviously at compile time; dynamic code breaks subtly, at runtime. Again, if you look, a lot of those frameworks have leftover warts from the framework maintaining backwards compatibility for their 50 users in the 0.2.1 era, and now all 250,000 users in 5.3 have to deal with some wart as a consequence.
But if the framework does it wrong the user usually don't have to write the functionality themselves, they just need to use the standard library to parse the url instead of what the framework provides. "maybe a string, maybe an array of strings" isn't really a problem as long as it documented which the standard libraries usually do well enough.
Yeah, I can definitely see where you're coming from there. Your options are quite limited really when using Go without putting in a ton of work. Maybe a lightweight Electron-type solution will work best if you want a really consistent experience across different operating systems. Otherwise you'd be looking at making separate native UIs for each major OS with the right look and feel for each one.
Oh ok. I interpreted the question as in OP wanted to build the business logic (“backend”) in Go and have the UI (“frontend”) cross-platform. I’ve heard people using those terms before. If the backend is on a remote server, then agree HTTPS is almost exclusively the best option.
PHP
Ok, I have probably written more Perl than PHP in the last 15 years and I have almost not written any perl since the 90s.
You can use [gofpdi](https://github.com/phpdave11/gofpdi) to merge PDF files. It works with gopdf and gofpdf.
Sciter [https://sciter.com/](https://sciter.com/) [https://github.com/sciter-sdk/go-sciter](https://github.com/sciter-sdk/go-sciter) &amp;#x200B; Probably the funnest UI I've programmed in my life. Right now I'm using it to tie up a sciter UI to a golang app calling CLI utilities.
[removed]
[removed]
Go Modules is still not officially out. Hopefully it will be in 1.13. Something to keep in mind :)
This is a really good answer thank you :)
Normally people will recommend Qt or Gtk, but these are really large beasts to learn and dev on. I'll recommend Fyne or Nuclear go binding. They are tiny libs that draws UI using gl. Downside is it doesn't look very native.
Thanks! First time hearing this technology. May I ask why should I prefer Sciter over Electron ? What advantages Sciter offer ?
As has been stated, you can have multiple headers with the same name. **A common example of that is `Cookie` and `Set-Cookie` headers.**
!remind me 5 years
But the same applies to headers, you can have multiple headers with the same name
Just FYI: You can also implement a method on a function type, so that the function implements the interface itself without the unnecessary struct: type SomeInterface interface { SomeFunc(int) string } type SomeFunc func(int) string func (fn SomeFunc) SomeFunc(i int) string { return fn(i) }
When an error is returned the other values are typically ignored.
Yes. But I don't understand why Go creates an empty slice in the background while returning. It can just return nil.
you can still range over a `nil` slice. the slice returned by `f()` is indeed `nil`. try printing the values and you'll see the difference between the two. https://play.golang.org/p/efpDFjJdW9L and it is nice to have a distinction between `nil` and empty that you can use. you should probably always try to return a `nil` slice on error.
That’s how standard function call works. You push return values on stack, then you push arguments. Before function returns, it pops parameters leaving return values on stack.
I'm not sure that your code actually asserts what you conclude. A nil slice would have a length and capacity of zero, and a nil pointer. The range keyword likely looks at the length value first.
Why do you assume it makes a slice transparently? AFAIK this is not the case. Instead, it makes the nil values useful.
returning a slice instead of a nil is probably not a great practice. Go goes to great efforts to make the internal library deal with nils as proper values. eg: \`arr := append(nil, "string")\` will set arr to \`\[\]string{"string"}\`. reasons why not to do this: 1. extra memory allocation for a garbage result 2. it's not actually useful over nil 3. returning a value when you return an error seems wrong. it's typically one or the other, with few exceptions.
Gophercises held me tremendously
https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices
Yeah that makes sense. Thanks!
This made things clear. Thanks!
The point of Rob Pike's response is that you can program with errors. In this specific case, it reduced the LoC and made the code look nicer on paper. &gt;Your antidepressant doesn't address control flow. ... Future modifications of unhappyFunc must be very careful to not have any side-effects and because the error handling is implicit, that's an easy danger to overlook (arguably not in this extremely oversimplified case). I obviously named the struct `antidepressant` as a joke. You can easily pick up a more appropriate name which will signal to the user its intended usage. &gt;Even in the correct case, you are still burning a little bit of extra CPU, BTW. That's probably not a huge issue in practice, but little inefficiencies tend to add up. Since when do we care about that stuff? In Go we optimize for correctness and clarity. Performance comes second. In conclusion, I really do not see your argument. Side effects and performance? I say Rob Pike makes a good point. What we need is more examples where coding with errors is triumphant. P.S. &gt;FWIW You wrote almost 300 words in your comment and this you decide to abbreviate? Why make poor people Google stuff? :'( :P
Size. Sciter runtyime lib is pretty small. For macOS, sciter-osx-64.dylib is 12.4 MB. For Win, sciter.dll is 7.5 MB. For Linux GTK, libsciter-gtk.so is 11.3 MB. My Go binary is 4.3 MB so far. &amp;#x200B; Easy. Sciter CSS has some really cool layout capabilities, easy to put together, flexible. Scripting is done with tiscript, behaviors are a cool way to make random UI parts act like pretty much anything you want. The samples folder in the SDK is pretty self explanatory.
Check out flutter 😋 Flutter also allows for native platform communication to Kotlin/Swift for Android and iOS. That's only for advanced logic and most of your code with be the same for all devices. If you would really like to use golang there is “Using Go Library in Flutter” by Archan Paul https://link.medium.com/xoK1lJxkxY Flutter for Web https://flutter.dev/web
Electron as other people pointed out is very popular. Slack, VSCode etc. It works on desktop but on mobile you probably could use something like Phone Gap and keep most of the code. You only mentioned mobile and PC but if you might want web too this is probably best for that. Other alternatives: React native is developed by Facebook, it's a Javascript framework that uses native widgets instead of a web view. It's focused on mobile, desktop versions exist but not sure how mature they are. Xamarin is developed by Microsoft and uses C#. Xamarin Forms is the cross platform UI library for mobile/desktop. It directly exposes pretty much the whole platform-specific SDKs in addition to having their UI library which is a bit different from some of the other alternatives. Used to cost money, now open source/MIT license. Flutter is developed by Google and uses Dart. Not very popular but some people say good things about it. Kotlin can run on multiple platforms but I'm not aware of any mature cross-platform UI libraries. QT has bindings for multiple languages including Go. LGPLv3/Commercial license.
Returning nil does not create an empty slice; they are different if only subtly. One important difference is that if you json.Encode \`var x \[\]int = nil\` you will get \`null\` and if you json.Encode var x \[\]int = \[\]int{}, you will get \`\[\]\`.
Did you mean `go get github.com/&lt;user&gt;/foo/cmd/bar`?
&gt; lightweight Electron-type solution That's an oxymoron :) As for Qt, Telegram uses it and they have solid consistent UI across (desktop) platforms. Not sure how though...
That was fast! Ordered Thursday evening; shipped from North Carolina Friday. Arrived on my doorstep in Chicago today!
[removed]
You are operating under the assumption that the non-specified "generic web framework" you are examining in your head is competently built. This is, unfortunately, frequently false. Anyone can write some code and call it a "web framework".
I’d say go with Electron. Or justmake a PWA so you can access it via browser on your phone and computer (and I think google play store accepts PWAs but I’m not sure). Sure it won’t be as fast as native but realistically does it need to be? It’s a note taking app afterall
&gt; I obviously named the struct antidepressant as a joke. You can easily pick up a more appropriate name which will signal to the user its intended usage. I don't think naming alone really solves this. I wasn't really talking about the name at all (I mean, I considered commenting on it, because as a depressed person I think it reflects a poor understanding of depression and antidepressants, but I decided against it - until now ;) ). I don't think names can fully convey how errors are handled in this code. A `if err != nil { return err }` is super clear about that. Even a `try` is explicit, once you accept it as a language-level construct. Unless you want to call your methods "doingThingUnlessAnErrorOccured" or something, I don't think you will reach the same level of clarity as either. &gt; Since when do we care about that stuff? In Go we optimize for correctness and clarity. Performance comes second. Okay. But as I said, the performance argument *is* secondary and the clarity and correctness argument is primary :) It just so happens that IMO both make the approach not great in general. But, to address that: One of the main reason very often cited to write Go in the first place, was performance. Namely, the poor performance of the C++ compiler. You are right that performance isn't the primary concern when writing Go, usually. But I don't think that goes as far as outright dismissing performance considerations. &gt; In conclusion, I really do not see your argument. Wording nit: It seems to me you *do* see my arguments, you just don't agree with it or don't weigh them as heavily as I do. Which is fine - that is what disagreements fundamentally are :) But saying you don't *see* it invites me to spend more time expanding on it, to show it more clearly. But I don't think that's really the issue. &gt; Side effects One more thing here: In my personal experience, code that benefits most of error handling improvements is parsing code. In fact, error handling is most of what parsers do. And screwing up the error handling and accidentally continuing despite an error is pretty catastrophic in that case, as a) you will continue parsing based on broken assumptions (e.g. with an incorrect field length in a binary protocol) leading to potential exploits and b) parsers are the first line of defense for malicious input. So I don't feel like this should be dismissed so easily.
Hmm I heard about Sciter and Flutter first time on this thread. Can you give me a little more information about it ? Why should I choose it over Electron or Sciter etc.
Probably just a lot of custom styles I suppose. If you can normalise everything across all platforms, and then build on top of that then I guess that should work?
Nope, I mean exactly what I put - give it a try!
For some value of "out". :) For many "you can use them and they work" is out-enough.
You're probably calling Add() and Done() within your Goroutine, then Wait() in the Goroutine that creates the other Goroutine. Since Goroutines may not run immediately when created, the Add() from one of the Goroutines might run after the Wait() was called. Do the Add(1) before each go func(), or the right amount before all of them with Add(len(chunks)) or something like that.
What’s the issue with Qt?
I'd just have a lambda function run on a schedule (Cloudwatch Events) to replace the file on S3. Doesn't really matter what programming language you write it in. At the end of the function you could then call your RPC endpoint to reload the file. Depending on READ requiremetns you could even get away with just using a service like AWS Athena to handle the query side of things, although that won't be as fast as having something in memory (e.g. using sqlite) but that won't scale if the file ever gets bigger
It’s typically better to use discrete test blocks so that you don’t inadvertently change state in such a way to get a test passing (or failing) when it shouldn’t be. Said differently, if you isolate your test setup, you can be confident that you are only testing one thing at a time. The caveat to that is that if your test setup is complicated or requires a lot of pre-processing, then sometimes it makes sense to use the same instance of the runner (and same setup), to save time when running your tests. As far as your assumptions, you are correct, it will bail early. I know that ginkgo has a By func that allows you to see where it failed, but I’m unsure how it is implemented. My opinion, split them up into separate test funcs so it is obvious where your test failed. A little extra setup doesn’t save you much time, but can create some real headaches when you do something wrong.
Pass testing.T to the helper and make sure to call the Helper() method.
Client side JS has had shockingly crappy query parsing until quite recently. URLSearchParams requires IE17+.
Yeah, almost everyone who writes non trivial programs in JS are at least familiar with transpilers and polyfills these days so it's not a big problem.
That's because it would be incorrect to split a comma separated value into a list. According to my reading of the spec, if a header appears multiple times then it must be equivalent to a single header with the values separated by a comma in the order that the headers appear, but it does not say that a single header with a value containing commas can be interpreted as separate values.
When you use Run, you can selectively run that test.
I would recommend the author to read up on REST. What is written here doesn't adhere to that. While not strictly a requirement, it is easier for most developers to use as it is a convention, closely resembles database ideas (CRUD) and is therefore also predicatable. Furthermore, it has less path clutter, since you don't need /showuser and /deleteuser, you just have /user, where GET and DELETE are handled separately. [This article](https://hackernoon.com/restful-api-designing-guidelines-the-best-practices-60e1d954e7c9) shows it quite properly, while [this](https://medium.com/@johnteckert/building-a-restful-api-with-go-part-1-9e234774b14d) is one specific for Go
typically i use `t.Run()` to execute tests that i can express in very little code and that i can often take advantage of the fact that the function literal can close over other variables in the function. so personally i wouldn't use the last pattern you suggested -- i'd just create another test function.
Yeah, consistent with their UI on other platforms, not consistent with the platform's native UI...
Go isn't creating an empty slice in the background. A nil slice behaves, for the most part, like an empty slice intrinsically: It has length 0, and appending to a nil slice works as one would expect appending to an empty slice would. See also https://tour.golang.org/moretypes/12
This explains the motivations for t.Run pretty well: https://blog.golang.org/subtests
`t.Run()` aka subtests are great for Table Driven Tests; you can run tests in parallel, they are named so you know which one is failing and you can target just one subtest to run, which is very cool. Good article about it: https://dave.cheney.net/2019/05/07/prefer-table-driven-tests
It’s weird that such a spec exists but we can’t use comma separated values on `Access-Control-Allow-Origin`
Huh. I built some of them.
&gt; There's no sense in an "allocated" zero size slice. Where would it point to?? There are multiple ways to get a zero-length/capacity slice: * `a := []int{}`, which is [specified to have length/capacity zero](https://golang.org/ref/spec#Composite_literals). * `b := make([]int, 0)`, which is [likewise specified](https://golang.org/ref/spec#Making_slices_maps_and_channels). * `c := make([]int, x)`, where `x` is a variable with value zero (subtly different from above) * `d := y[0:0:0]`, where `y` is any existing slice. * `var e []int`, a `nil` slice (or equivalently, assigning `nil` to a slice. [The spec allows, but does not force](https://golang.org/ref/spec#Size_and_alignment_guarantees) all zero-sized values to have the same address. `gc` [currently implements these as](https://play.golang.org/p/ZWEhhaZefPm) * `[]int{}` and `make([]int, 0)` are equivalent and apparently get a fresh address in their pointer value. * `make([]int, x)` points to the canonical zero-size-value address. * `y[0:0:0]` points to the same array as `y`, but has zero length and capacity. * `var e []int` has a zero-pointer. Anyway, the distinction is actually somewhat meaningful, in that the spec distinguishes between zero-length slices and `nil`-slices. In fact, comparison to `nil` is the *only* way in which a nil-slice differs from a zero-length slice, as far as the language is concerned. `gc` takes this so far, that it [implements nil-checks as checking whether the element-pointer is nil](https://play.golang.org/p/hLAsbED8698). In that way, the spec forces non-nil slices to have a distinct element-pointer *even if their capacity is zero*. Personally, I'd be in favor of removing `nil`-comparisons for slices altogether for these reasons. I think there isn't a meaningful difference between the two and removing any way to distinguish them would make that clear. But it's a weakly held opinion.
Writing something to pop a value off a query string should not require a polyfill in *a language created to work on webpages*.
yeah yeah, some situations are worse than others but then again no language is perfect. If you get too stuck up on those things you will never get anything done.
That's very interesting. I suspected they'd have the same address if they did point to an address based on how the standard library implements some system calls. Comparison with nil is indeed annoying but instead of removing nil comparisons I would be in favour of either forcing a nil pointer for zero slices or making comparisons with nil return true regardless. The former is cleaner in my opinion. What is the rationale for giving them a valid non-nil pointer? It seems unnecessary.
&gt; forcing a nil pointer for zero slices This has one somewhat significant downside, in that it means you have to special case every slice-expression to check whether the result has a zero capacity. So you'd have to generate an extra check for every `s = s[:x]`, because you don't know in advance whether or not you'll end up with zero capacity. It's probably not an *enormous* price to pay, but it would be pretty similar in cost to current bounds check and there is still very significant work both on the compiler side and in individual codebases to eliminate those. &gt; making comparisons with nil return true regardless In this case, you end up removing any distinction anyway. `s == nil` would be universally identical to `len(s) == 0` and I don't find the former any clearer than the latter. And arguably, the overhead of putting the comparison in the spec would eat up any benefit that would be there. &gt; What is the rationale for giving them a valid non-nil pointer? It seems unnecessary. I think giving them a valid non-nil pointer makes sense, as I said above - it means the generated code for slicing can be simpler and more efficient. And *if* you have a distinction between `nil` and non-`nil` slices, you are required to put a non-nil pointer in initialized slices even if they're zero-length - because you are required to distinguish them. That's why I said that I would probably remove comparison to `nil` altogether. There is never a practical reason to check for `nil`. And I'd argue that if there is a reason to distinguish an uninitialized slice from a zero-length slice, that reason also applies to distinguishing an uninitialized integer from a zero-value integer. Or struct. Or anything. Of course, we can't really change this now. Even if the spec [doesn't technically prescribe the current behavior](https://twitter.com/TheMerovius/status/1153420745759965184), there probably is too much code out there depending on the current behavior. But if we would do it over again, I'd argue for removal of nil-slices.
Good post!
hi - what did you use in Python - was it [Spotipy](https://spotipy.readthedocs.io/en/latest/)? I did find this Go library: https://github.com/zmb3/spotify linked from Spotify's clients page, but last update was a while ago, so I've no idea if it is still fresh. Good luck!
I won't say much about your points, because I mostly agree with your comments. &amp;#x200B; (It's also possible that my library design style results in a predominance of zero-value err != nil returns, because at the point of error detection and construction the method has access to a receiver with, usually, all the information it needs to construct a complete error message that makes perfect sense way up the stack. That could be why I see it a lot -- I write them a lot.) &amp;#x200B; I personally don't like `if err := neverHappyFunc(); err != nil` much, because it places error handling around the line of code that's being checked, partially obscuring it. I think a minor objection to the try() proposal was that there would be a `try()` around every checked function/method call, visually getting in the way. (Doesn't mean others don't like it.) &amp;#x200B; I think your example is a borderline brilliant solution: &amp;#x200B; `(err := NeverHappy(); err != nil ? return err)` &amp;#x200B; The only thing I don't like about it is that I didn't think of it! &amp;#x200B; * It gets rid of the `if` in front of the call. * Essentially it moves the role of `if` to the the end as `?` out of the way. * It doesn't hide the error handling in any way. It's right there at the end. * It makes it easier to see more lines of code per page in your editor. &amp;#x200B; It would be nice to ditch the parentheses. &amp;#x200B; I think you're onto a winner and this is worth fleshing out and proposing.
hey, i've never been to one of these before. What is the main benefit from going to these conventions? Is it more for networking? Do you feel like your Golang skills actually improve from attending? Is it just to show support for the community? Thanks.
Just noticed this message from you. Apologies if I have come across as snapping. That's not my intention. It's so much easier corresponding with someone you know in person. Nevertheless, in these discussions, text is all we have. I wish you well.
Totally fine to use experimental features when it's an option, but it does mean you sign up to be a guinea pig :-)
What kind of memory utilization did you expect to see and what are you seeing?
JavaScript has a standard date library, where February is month 1 and the current year is 119. I have never seen anyone argue that it is an example of good library design.
2kb default stack size of goroutine. So with 10K goroutines, that would be 20MB. That is still chump change on modern systems. Why are you worried about it so much?
This is really interesting. I want to use it.
The first part of this talk was stellar. The actual demo I think was somewhat rushed and hard to follow but I certainly think he is on to something, just very very early stages.
&gt; try moving your allocations off of the stack and onto the heap by e.g. replacing \`make\` with \`new\`. I didn't think `new` implies a heap allocation in Go, the way it does in C++. Are you sure about that? I had thought that it tried to stack allocate as much as possible and does escape analysis to decide what to promote to the heap. But that we don't have control over those aspects directly.
github.com/zmb3/spotify
That has never stopped me from accepting any JS work though.. It's not like it I have denied a client writing a calendar feature on a web site or something because of some weird edge case behaviour of the date class. Again, this is minor hang ups about minor annoyances which has little or none practical impact.
Another example is \`Link\` header
I *almost* used these in Caddy 2's design, but found defer and context to be much more workable and less magical solutions. Through these we've fixed a memory leak that is often a problem in Caddy 1.
There were several things that were not right - Human brain is the most complex object in the solar system. We cannot possibly know that, it sounds absurd. To quote Reddit. &gt; It's like taking a bucket of water from the ocean in which you happened to catch a crab and saying "Crabs are the largest animals in the ocean!". - 4-7 objects can be kept in our minds. Not what the research says at all... for a lay description https://mrjoe.uk/millers-number-7-2-psychology-myth-busting-2/ I did like the visualization, although I'm not sure free-form exploring vs Rail-camera is the best. It also does not seem to be visual code as much as re-arranged textual code. Some cool things I've seen for visual representation of code (different to visual programming) - diff tools - plantuml (and other graphviz-based tooling) - https://github.com/pomber/git-history - debuggers (particularly interactive debuggers where you can stack walk) Ultimately we simplify from pictorial content to textual because the pieces are larger. We reduce precision in order to simplify It will never be easier to review code as a human because - we might be learning about a novel approach (which may or may not be a good/bad thing) - the range of expression is too large even for a 100 line PR to carry the whole thing in our heads Maybe RISC holds benefits in this regard. Less primitives, but then without higher-order functions, there is a lot more code to read.
It's wonderful how you exactly figured out what I was doing. I'll modify and test how it works. Thank you.😊
Would’ve loved to Go (heh), but with ticket cost plus hotel/travel it’s too pricy for me. (Job hunt is going slowly and snap ran out last month.)
No, it really depends on your app's requirements. Just as an example if you have AWS you can do serverless with golang, you can do more traditional deployments using AMI images etc. What are your requirements? What kind of scale do you expect and both low and and high end
I have huge structs allocated on the stack in each goroutine. Thus, there lies my issue. If you look at the sample code in my edit. It will demonstrate what I mean.
I actually need to process millions of a function execution in parallel. If there was a way to force golang to release memory back to the OS after a goroutine terminates, then my memory requirements would be much lower.
I am expecting as high as Facebook or LinkedIn
My hybrid app is made of kotlin with golang backend and the webpage is made with javascript and golang plus I am using somewhat graphql with node in the server side too.
No, you might benefit from a orchestration service if you deploy and manage many hosts but you can use whatever you want. Depends a lot on your application architecture as well.
AWS, GCP, Azure can autoscale just fine, and each has their own way of managing deployment. Some use Docker without Kubernetes, some use their own deployments, and they also offer managed Kubernetes. If you have nobody in your team with the experience on any of them, you just have to pick your poison.
I have no idea about docker and Kubernetes so for managing server do I need to learn it ?
I don't have anyone else in my team so will it be fine to use azure for cloud servers for my app.
Yeah. Just like with anything else, you have to know your tools. I heard Azure has excellent enterprise-level support. So if you have got some extra cash, you can probably tap into that.
Having an idea of what growth might look like helps. I mean if you expect slow steady growth go with things that make more sense economically. I would always encourage people to learn docker. K8s is great as well but just know you're going to want a sysops background and cloud experience. Eventually an ops team of some sort be it Devops/sysops/sre whatever.
 will get started with azure from today itself
you telling me you expect traffic as high as facebook, yet you dont know anything about cloud architecture.... or you have some DEEEEP pockets , or you dont know what you doing... &amp;#x200B; in case you have DEEEEP pockets, hire a software architect, he will do magics for you otherwise, start simple, I suggest AWS with [SAM](https://aws.amazon.com/pt/serverless/sam/)
ok
lol classic troll move
Did you use the heap profiler to confirm there are not dangling references to objects? Also it takes a few minutes for go to release memory back to the OS. Something between 5-10 min I last recall. Try putting a 10 min sleep in you code to see if it eventually happens.
What?
In the simple sample code in my post edit, I do not see any potential dangling references?
Unless you are leaking goroutines somewhere, there should not be any such issue. Have you tried enabling pprof and checking how many goroutines are active? Also take a heap dump to check what is going into heap. &amp;#x200B; I have have a GO application that handles 20,000 web socket connections and processes 15K msg/sec from Kafka. The app has about 50K go routines running at peak and its memory usage is around 3 GB. When the connections and messaging stops, the memory comes back to &lt;50 MB proportional to only the go routines that are active.
I plan on doing the profiling you describe. Each of my goroutines accumulates a huge structure, which is kept in memory. Maybe there is something I can trim. However, I would like to know how to release memory back to the OS. If you run the example code in my edit to the post, you will see that memory is held until the main process dies.
That's correct, the only difference between make and new is that make also does some extra initialization for the special types like slice, map and channel while new only zeros the memory. There is no way to directly control whether the allocation happens on stack or heap. Escape analysis is done to determine where its allocated. &amp;#x200B; However, in your case, unless you have a goroutine leak, there is no way for any stack allocations to remain behind after a goroutine gets killed.
I developed a backup client in Qt and would say it integrates alright with macOS. [Screenshot](https://files.qmax.us/vorta-golang-1.png) and [website](https://vorta.borgbase.com). For Linux, there are many different desktop environments anyways. Currently I'm trying to dynamically link my Qt app against the distro's Qt. Not sure if this will help. I should note that the first version was written in Python/PyQt, which is very hard to package. Currently I'm redoing it in Go with the bindings mentioned above. I didn't get it to compile everywhere yet, but where it did work, the app size is a lot smaller, faster and it runs on more version of that OS.
Is it possible that the garbage collector just hasn't run yet?
It's in Chinese :/
No, you aren't. You have no app, no deployment and don't understand the scale of what you are talking about, come up with some reality-based figures and we can help you with actionable and direct feedback. If you are expecting traffic as high as Facebook you'll need to hire tens to hundreds of people just to be able to architect, design and engineer a solution to cope with that. That level of traffic is impossible to be handled by a single person and I doubt you'll get to that level in 5-10 years time even if you are extremely successful...
s/such as/like/
You didn’t realize that before you posted it here?
Yes you must learn it and make sure you're using Web Scale technologies like MongoDB and wasm in all your front end for Maximum Performance.
On mobile cant test myself, but reading your code there is not much time for the gc to collect the slice and runtime to release the memory to the os. Can you try to to the sleep in a stackframe that does not contain the structure? Something like go func(){ doWork() //Here the gc and runtime have //time to collect the slice sleep(...) wg.Done() }
Have you used `GODEBUG=madvdontneed=1`? Otherwise madv_free is used (at least on most unix systems). With madv_free the os will reclaim memory lazily so RSS will not shrink unless you run low on memory.
This is my first time attending so I will definitely try and share my experience on this thread ! At least the plan is to network with the community and definitely show my support. Go has done more for me than anyone can imagine. Moving from C to Go and then getting a chance to showcase my abilities without the language syntax becoming an impediment has been a great morale booster for me personally. So I am really thankful to the community for all the great work they have done and continue to do in making it as diverse and welcoming to new comers.
My biggest concern that you're reading whole files into RAM. You should hash them a couple of megabytes at a time. Also, your tests fail under Windows due to it using a backslash to separate directories.
Thanks for feedback, golang isn't really my main language and I overestimated go's crossplatform-ability. Will take a look. Besides, I was mainly fighting directories with a lot of small files on osx
I think you may be confusing the memory allocated to the app with the memory in use and locked by the app. When app requires a high amount of memory at some point which is allocated, the same is not automatically returned back to the OS immediately. If you run some other memory intensive program, the OS will collect the unused memory from the other apps. So, if the process monitor tells you that 4 GB of memory is allocated to the app, it doesn't mean that memory is all in use. &amp;#x200B; To illustrate, here is what the mem stats of your sample app (with some modifications done in the code) looks like after its done running all the go routines \# runtime.MemStats \# Alloc = 265312 \# TotalAlloc = 4001807152 \# Sys = 3748116856 \# Lookups = 0 \# Mallocs = 2603 \# Frees = 1482 \# HeapAlloc = 265312 \# HeapSys = 3627810816 \# HeapIdle = 3626655744 \# HeapInuse = 1155072 \# HeapReleased = 2022449152 \# HeapObjects = 1121 &amp;#x200B; HeapSys is 3459.75MB, but HeapInUse is only 1.1MB while idle is 3458.65MB. That means that even though 3459.75MB is allocated to the app, only 1.1 MB is in use and the rest can be collected back by OS when it requires memory.
In any case, I submitted a pull request.
Looks like it's your first PR on github 😉 Very nice start!
&gt;That said, I'm not sure how this would work with result type error handling Easy, in Rust these will be equivalents file = File::open(name) on err { &lt;failed to open section&gt; } &lt;successful at opening section&gt; vs match File::open(name) { Ok(file) =&gt; { &lt;successful at opening section&gt; } Err(err) =&gt; { &lt;failed to open section&gt; } } The first example is just as type safe, just a LOT friendlier for imperative workflow. And in Rust they don't a need `return!` anyway.
You're changing the subject. The question is not "Can you use JS to make software?" The question with which you started the reply thread is "Which language that has a url parsing library does not support?" The answer was "until quite recently, JavaScript did not have a query library built in." That led to a discussion of standard libraries. You stated, "One of the strong sides of JS is that it's standard library is moderately sized." I disagreed, because the JS standard library is more haphazard than anything else, for example it does have a date library, but the date library was very poorly designed and returns 119 as the current year. No one doubts that you can use any language to do anything. Particularly if you write your own utility libraries, you can work around anything. But some languages have better standard libraries than others, and JS is an example of a language with a _haphazard_ standard library.
&gt;The crypto community would have a word with you Why do you want finalizers for cryptography?
What? RISC? What on Earth are you talking about? Have you ever coded or reviewed *any* kind of Assembly, let alone RISC?
You have also been changing the subject, nowhere did I talk about date functionality until you mentioned it. I just said I wanted the stdlib to be small which it is.
Hey all, I recently finished this vanity imports generator (the lazy man's imports generator™) for people who don't want to have to update a file every time they create a new Go repository. Let me know what you think!
1. Try not to use words like "blazingly fast", it is almost always subjective and thus. wrong for other usecases. 2. The obvious next step is to work out how to create a hash for the directories. 3. [https://github.com/james-antill/mtree/tree/master/go-mtree](https://github.com/james-antill/mtree/tree/master/go-mtree)
This is an attempt to bring nil-safety to Go in a way that is as Go-like as possible. I would love to get feedback to know: - Whether you would like to see nil-safety in Go - If are some aspects of the proposal that doesn't feel like Go - If you think it is too complex or not Any kind of feedback and constructive criticism is highly appreciated, as it will tell me if it is worth it to keep pushing this proposal forward
In my opinion, the section on converting a nillable type to a filled type seems in practice to just be adding another type of zero value. Since that seems to be the most complex part, it seems to me that most of the use cases this covers would also be covered if a filled type declaration just specified a new non-nil zero value for the type.
I use GitHub pages' Jekyll templates, which gives all of the benefits of declarative static sites and also collocates it with my repositories. I basically came to the same conclusions as you with respect to ease of use and reliability.
How many new keywords?
Blazingly fast compared to?