And error code returns are clearly the superiour method of error handling. This design pattern is one of the reasons why I really like both C and Go.
Try using a linter to catch these use cases. Typically you get an “assigned but not used” warning, especially if your code looks like this: foo, err := some.Foo() bar, err := some.Bar()
Strange. I didn’t type r/ and it doesn’t want to edit away. 
&gt; What is the suggested/idiomatic way to avoid this? "declare `err` in an awkward way". It's fine.
you're already defining return, why not err - nothing awkward there... I was surprised when I discovered shadowing in Go, I'm not a fan of compilers even allowing it ! 
Just to fix your example, I'd do this: https://play.golang.org/p/IhSKci3ivKG I prefer to have fewer competing indented branches, which is why I've integrated what was in the if branch. However, personally I'd refactor the code into something more like this, since I'd want to handle the error rather than panic: https://play.golang.org/p/9xOwsg6fBvy
Wrap the handler in an [http.TimeoutHandler](https://golang.org/pkg/net/http/#TimeoutHandler). If you use a router with sub-routers, you could wrap each sub-router with it. It will handle properly buffering the response so you don't accidentally write twice.
V2 and v3 of the API do in fact use different keyspace. Etcdctl uses v2 by default.
It does set RowsAffected. What it doesn't set is LastInsertId
I dunno. Something crashing at 3am in the morning isn't *terrible*, so long as the application automatically starts itself up again. Still causes downtime, but probably not significant downtime (unless the exception occurs at startup, in which case it should be fixed regardless of how "minor" it is). It also gives you a non-ignoreable alert that "something is wrong" - maybe it's just a utility library being huffy and it's not worth bringing the server down for one weird edge case, but it's still good to be brought to your attention. On the flip side, Go's "method" of error handling gives you freedom to handle errors in any way you prefer (Don't particularly care if something has an error, and just want to continue on anyway because it's non-essential? noooo problem). This also comes with a good deal of responsibility and potential for human error, though. 95% of the time, *something* has to be done with an error, no matter how minor, and if you forget to do so and just silently use the zero-value returned by a function, your application might end up in a really weird state. And it isn't as though Go has done away with the concept of exceptions and try/catch - that's basically what panics are. The "return an error last" convention is, well, just that. A convention. Not unlike the "return an error first" callback convention that was a thing back when Node.js was in it's infancy. 
Not sure how to interpret this: Should juju be supported as provider ? Or How does it compare to juju ?
I was using Etcdctl v3 but I was using package `client` instead of `clientv3` in my go application \*facepalm\*
As far as I'm concerned the Go 2 proposals mainly try to introduce some syntactic aids to deal with error values. They don't seem to try to remove returning error values as the core concept of how error handling works. &gt; it's like saying manual memory management is superior because it's explicit in C. Yet you are using Go with a garbage collector. Makes no sense. I'm not particularly strongly attached to either style of memory management. What I am attached to though is APIs that allow the user to reduce allocations in performance-sensitive areas. For example, the Go IO interface (`io.Reader`, `io.Writer`) is designed to receive a buffer to write into instead of allocating a fresh buffer. This kind of API design makes writing fast programs much easier.
I wouldn't worry about it, especially not for simple/straightforward cases like this. We've had a developer insisting on "fixing" all the variable shadowing cases (especially surrounding errors). The result was ugly code and a bunch of bugs that didn't exist before. The developer in question no longer works for us.
&gt; They don't seem to try to remove returning error values as the core concept of how error handling works. If it was so good there would be no need for "patching".
Useful one! Maybe can evolve to rename through a passed template to include different data, e.g. \`{origName}\_{width}x{height}\_{date}.{extension}\` or something like that.
No, I mean juju can also deploy code to all public clouds.
I am happy that more people are adopting Go. But why were Rust, Java and Go the only choices ? Why weren't other languages even investigated ?
&gt; If it was so good there would be no need for "patching". I actually don't see a need for patches and the changes offered are rather lightweight quality-of-life improvements. Have you actually read them? &gt; You know there is an overhead each time you use interfaces somewhere right? error is an interface. Checking if an interface is `nil` (i.e. checking if an error occured) is one or two instructions worth of machine code (a compare and a conditional jump). The overhead is negligible. In case there is an error and we want to inspect it, there is some machine code needed to inspect the interface, but as error handlers are rarely a performance hot spot, this is negligible, too. Returning an extra `nil` is also just one extra instruction to return `nil`, no allocations needed.
SQLite is so heavily optimized, tested, and feature full that it would be hard for anyone to go head-to-head on individual line items, but I have been meaning to try this project for quite a while now. It sounds like ql is good for small projects but probably has a somewhat less sophisticated query planner than SQLite. If I use SQL, I tend to go full blown Postgres or SQL Server, and if I want embedded I usually use Badger as a key value store with Bleve for indexing and retrieval, so I haven't made myself use this or SQLite in Go yet.
while you could be right, no where in Go's language specs talks about the heap and stack; and you cannot guarente that allocation within a function scope &gt;does not&lt; escape to the heap [1]. also, returning slices and map types is always pass by "reference" [1] https://stackoverflow.com/questions/10866195/stack-vs-heap-allocation-of-structs-in-go-and-how-they-relate-to-garbage-collec
&gt; I actually don't see a need for patches and the changes offered are rather lightweight quality-of-life improvements. Have you actually read them? &gt; &gt; euphemism. &gt; The overhead is negligible. it still does exist.
Thanks. That's a good start.
Jetbrains suite is the best out there. However I found myself at home with VS Code w/ Go plugin. 
gorm is extremely awkward for me to us for that exact reason. I've since abandoned it in favor for other solutions. have you looked at upper/db? it's not a full feature orm per say but it's the closest to idiomatic Go as it gets
I'm not a juju expert (in fact the only things I know about it was heard at a conference the wee kof the juju's launch). I see juju more like an orchestrator (ala kubternetes, openstack...) while with rocket you simply put a `.rocket.toml` file alongside your codebase, and when you'll run `rocket` in your CI/CD pipeline `rocket` will automate the deployment of your containers to your repository or create a github release and uplaod artifacts or deploy to heroku or deploy to firebase.... Let me know if I'm wrong. 
&gt; you cannot guarente that allocation within a function scope &gt;does not&lt; escape to the heap [1]. True. But what you can guarantee is that if there is no allocation at all, they do not escape to the stack. &gt; also, returning slices and map types is always pass by "reference" Nope. The slice itself is returned or passed by value, it's only the underlying array that is refererred to. This is how `io.Reader` and `io.Writer` can avoid allocating objects each time they are called. &gt; while you could be right, no where in Go's language specs talks about the heap and stack; and you cannot guarente that allocation within a function scope &gt;does not&lt; escape to the heap [1]. Check out Go's actual implementations. They behave this way. Assuming the compiler is too dumb when it actually isn't is stupid.
&gt; euphemism. More like it is so painful something has to be done to make it is less painful. It is not at all painful. As I said: I do not think that changes are necessary. &gt; it still does exist, and it adds up. Overhead compared to what? That's always the question you need to ask.
I have the same problem. For some reason IntelliJ doesn't index the modules. I need to restart it and clear the cache for it to recognize new modules. What I found that works is to `go mod vendor` your dependencies.
Can you please help me reproduce the issue? Do you have the Go Modules integration enabled? Is your project outside of the GOPATH?
`true` is a constant, which makes the `if` useless. `err` is a variable.
I just tried it on a new project and was able to reproduce it: 1. Created a new project choosing a VGO project. The path is `~/projects/project_name` 2. Created main.go with the main fn 3. Ran `go get github.com/go-mgo/mgo`. At this point IntelliJ refreshed the external dependencies and added `mgo` to them. I confirmed it by importing the library. 4. Ran `go build .` 5. Ran `go get` again: `go get github.com/panjf2000/ants`. IntelliJ didn't refresh the external modules this time. Running `go get` for additional modules has no effect. As I said the only workaround is to `vendor` the dependencies and manually refresh the vendor folder. I think some `fsnotify` events are not being fired, so an option to manually refresh the modules will be a great first step towards *fixing* this behaviour. Some more info: Go version: go1.11 darwin/amd64 Goland version: 2018.2.2 MacOS High Sierra A short video: https://drive.google.com/file/d/1o0S9mzAe8TvB_79iZQabTHhm4hahXG2l/view?usp=sharing
I’ve recently made an error where I accidentally forgot to propagate the error: if err != nil { return Foo{}, nil } Had I returned a pointer, the caller would have dereferenced the nil pointer and crashed. Unfortunately, the rest of the code took the empty value and used it incorrectly, causing much larger issues. 
Indeed.
How does this compare to https://github.com/goreleaser/goreleaser?
Goreleaser only targets GitHub releases (and S3) and mixes building (which we think should be delegated to tools like `make` or `bazel` which are far more advanced. OTH `rocket` is only the D in CI/CD, but aims to do it perfectly so you can deliver/deploy your software to any cloud providers, hosting solutions, PAAS or distributions services like bintray or snapcraft.
Vim: https://github.com/fatih/vim-go VS Code: https://github.com/Microsoft/vscode-go Both are excellent.
I picked up a copy at Gophercon 2018. It does look like it's aimed at a beginner to Go, though it appears aimed at someone learning a second language (it's really hard to write a purely beginner's book because you have to cover so many basic concepts). It's certainly not at the level of Donovan &amp; Kernighan which assumes more sophistication from the reader, but it looks like it hits the kind of topics that are central to Go (coroutines, etc).
So, check if it is nil. Be explicit. 
productID *= 2; // just made our product twice as good, boss customerID *= 2; // guess what i did boss!
Can confirm, there are non-zero `var err error` declarations in pretty much every Go codebase. *Oblig. yes I have seen every single Go codebase ever*
You are welcome!
I've been writing Go for 6 years, 5 of that full time... and I use recover so infrequently, I often have to look it up to make sure I'm using it correctly.
Dismissing net/http out of hand and jumping immediately to FastHTTP (which is more about gaming microbenchmarks than building serious software) is troubling, to say the least. I hope with the some more experience the Passenger team learns to trust the standard library.
i completely agree. i'd like to see benchmarks that justify moving away from `net/http` and taking on a non-standards compliant, buggy, poorly maintained third party package. i think people new to go simply take it on because -- why not use `fasthttp`? it has FAST and HTTP in the name! it must be better than regular old `net/http`.
So something I've noticed, both GoLand and Go itself do not recognize root level packages. If I nest the package everything works fine. mycoolproject/domain.go with a package of mycoolproject won't be found. But mycoolproject/internal/domain.go will get recognized. 
Wow you're pretentious as fuck.
have not, thanks!
I believe this is the second time this has been posted here and I still don’t understand the value add. If I have a bunch of container images that are the artifacts of my build process, why would I deploy them with Rocket instead of CloudFormation or Terraform? The latter seem like more complete solutions anyway, since they’re capable of managing not just build artifacts but all of the resources of the stack. What am I missing?
imho, if Go doesn't want to have a sophisticated type system to make it safe, then Go programmers should avoid doing potentially dangerous things like returning uninitialized records. &amp;#x200B; you don't optimize for constant-factor perf until you feel reasonably assured that your code is correct, but I see programmers (esp. in fast languages like Go or Rust) pick designs that make it harder for users to write correct code, before even determining if a bottleneck exists.
Read [How to write Go code](https://golang.org/doc/code.html). 
Ah, thanks! I didn't know what the appropriate methodology for sharing software was! Will fix and keep in mind for the future! &amp;#x200B;
As long as you are following the standard package structure, go build ./... will do what you want from the root directory.
I'm sorry that my post affected you emotionally. That was not my intention. My point was that in order to avoid what you see as "messiness", developer burden is increased notably. If you accept/prefer that, that is your business. I believe that the incongruity of your claim of "messiness" is worth exposing, but did not mean for you to be offended.
Hi. I remember your first comment and it was in fact really useful: thanks to it we plan to include jobs (aka stages) in `rocket`. in your scenario rocket just aims to help you push (deliver) your containers to your registry and then use terraform to actually deploy your immutable infrastructure. But there is other scenarii where when your containers were pushed, you simply need to execute somme SSH commands (think it as a replacement of ansible). Or another scenario where you need to create a GitHub realese after your tests passed. Or another where you need to deploy to Heroku after your tests passed but you can don't use their CI/CD platform nor want to use their repositories. Or another scenario where you need to push your binaries to bintray. Or another where you want to deploy to firebase hosting but don't want to install their CLI because of the NodeJS dependency 
My point is that developer burden doesn't change, you have to deal with the errors regardless.
Basically go.mod is updated correctly, the correct packages seem to be added. ``` module projects_go_mod_test require ( github.com/gin-contrib/sse v0.0.0-20170109093832-22d885f9ecc7 // indirect github.com/gin-gonic/gin v1.3.0 // indirect github.com/go-mgo/mgo v0.0.0-20180705113738-7446a0344b78 // indirect github.com/golang/protobuf v1.2.0 // indirect github.com/mattn/go-isatty v0.0.4 // indirect github.com/panjf2000/ants v0.0.0-20180918162820-af376f1b7b59 // indirect github.com/ugorji/go/codec v0.0.0-20180918125716-ed9a3b5f078b // indirect golang.org/x/net v0.0.0-20180911220305-26e67e76b6c3 // indirect gopkg.in/go-playground/validator.v8 v8.18.2 // indirect gopkg.in/mgo.v2 v2.0.0-20180705113604-9856a29383ce // indirect gopkg.in/yaml.v2 v2.2.1 // indirect ) ``` Something interesting - I went to test something quick in this project just now and running `go get` for a new dependency this time caused IntelliJ to reload the modules. So maybe something was stuck before? I haven't restarted IntelliJ
VS Code
&gt; developer burden is increased notably A lot of people find pattern matching a "cleaner" construct than `if`, to write, read, manipulate and extend. Sure, sometimes people use `if` for error checking against `Result`s, but rarely. I don't think developers are going out of their way to burden themselves. Even then, most people are using `match` when they need the `Result&lt;T&gt;` to a `T` and need to handle all cases. Or if they want to transform the left-sided `Err` into a different `Err`. Most of the time, for just throwing the error further up the stack, people are reaching for `.map` and doing away with control flow entirely. 
Well that's cool. I was looking for a way to not have to type go build file1 ... file9999 and it's built in! Go just gets better and better.
The go tool, the way we specify dependencies in the `imports` section, and the way we group related source files in a directory solve the problems the Make utility solved for C. No need for make. /u/gopherNoodel said it best.
I managed to replicate the issue, thank you so much for the detailed reproduction instructions. &amp;#x200B; You can see the issue here: [https://youtrack.jetbrains.com/issue/GO-6217](https://youtrack.jetbrains.com/issue/GO-6217) &amp;#x200B; The workaround is to use the sync action on the \` go.mod \` file, \` Sync Go Module (vgo) \` via right-click on the file. 
Hey Todd, I got your Udemy course Learn how to code: Google’s go last week and about 25% of the way through. Do you suggest I start over on Greater Commons?
This structure is an anti pattern in Go. Here's how to do it: * [Standard Package Layout](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1) * [Code like the Go team](https://talks.bjk.fyi/gcru18-best.html#/) * [Practical Persistence in Go](https://www.alexedwards.net/blog/organising-database-access)
I use a Makefile because I inject compile-time variables (like the git commit hash that built this executable, or the datetime that it was built), so my `go build` command looks more like `go build -ldflags "-X main.Build=$(BUILD) -X main.BuildTime=$(TIMESTAMP)" ./...` Your options then are shell scripts or Makefiles because are you going to expect people to copy and paste that big old command from your readme or something?
Thanks for picking up a copy and for the review. If you have a minute, would you mind adding a review on Goodreads? [https://www.goodreads.com/book/show/30025600-get-programming-with-go](https://www.goodreads.com/book/show/30025600-get-programming-with-go)
Awesome! I didn't know go.mod had a sync button on it's right click. Glad I could help!
Never heard of before, I will investigate. Which platform does support `rkt` containers. Is there a kind of repositories like with docker ?
DDD isolates systems based on domains. It is more abstract and focuses on business rules within the domain and interactions with other domains. Hexagonal Architecture protects the Domains business logic from the interacting systems (databases, http, etc). Domain logic should be shared between all interacting systems. So Hexagonal Architecture is just a way to implement domain driven design. 
Hey man! Sorry for the delay. Busy. :) Sort: * Small * Single purpose binary * Dead simple without anything else * Application deployment focused Long: Terraform atm is a 100MB binary with a texasshitton of options and configuration. Furnace gives you a single purpose binary based on your vendor. It gives you a binary for AWS for GCP and for DO. It has a simple configuration entity, and an easy to use multi purpose stack configuration option. You can multiple stacks and deployments in the same directory given a different .furnace file. Also furnace is application focused. It also handles infrastructure but that's a side effect. It deploys an application and it uses AWS / GCP specific things to do that. Namely CloudFormation CodeDeploy and DeploymentManager and GCP's git deployment functionality. It just stays out of way after that. It can get a status of your stuff, or delete it but the rest is up to you. I know terraform also deploys applications. Furnace is, for the lack of a better thing, a small wrapper rather than a complex tool of provisioning. It doesn't provide an inhouse solution. If something isn't on AWS Furnace won't create that for you. :) I hope this helped somewhat. I like using furnace for small to mid sized projects as a quick bootstrap. Then you can move on to a more robust or a more complex solution. 
``` assert(err == nil, "Unexpected error, %+v", err) assert(session.ID == "test-session", "Unexpected Session ID, test-session != '%s'", session.ID) assert(session.Username == "test-user", "Unexpected user, test-user != '%s'", session.Username) assert(len(session.Roles) == 1, "Expected one session role, got %+v", session.Roles) assert(session.Roles\[0\] == "test-role", "Unexpected session role, test-role != '%s'", session.Roles\[0\]) ``` I find this test assert example to more concise but less readable than the conditional example. I can quickly scan on the test conditions when it is just pure `if` statements but it's harder, for me, to quickly scan a bunch of assert lines. It really doesn't cut down on any boiler plate like the `check` proposal, instead it just cuts down on lines and some nesting.
Cool, Btw i use Arch...
you can see the `rocket` repository itself for an example
Yup I understand that, but in your case we are just really saving some t.Fatalf and a wrapper statement. As for reading vs writing. If we are making the trade-off I wouls rather optimize for reading. Writing is done usually once while others must read the code many more times. I don't think Verbosity is a metric in this particular case but it is my personal preference. I can scan the if blocks faster than a bunch of function calls with conditionals and formatting all on the same line. You can also get 90% of this functionality with a helper function today.
Sublime, thank me later
u wut m8
That's not official, the official is `go mod`. https://github.com/golang/go/wiki/Modules
I understand. Thank you for your candid responses. :)
Go is very new, It takes a lot of effort and money for companies to migrate their extensive code based from languages to another. Not to mention having to hire a whole new team and fire the old one. Or at least try to teach the new team Go. Also as people use a language overtime? They develop a good understanding to its mechanics, but the mechanics of each language is different. So you can just translate a java backend to go line by line and except it to work. There will be new bugs, new problems, and new architecture to deal with. All that means lots of down time and subsequent lost revenue etc. Overall, even if those companies may develop future platforms in Go . Converting current ones to Go is a massive undertaking most of the time not worth the effort 
Int is faster then float at any given point in time. Though the gains of it are minimal, especially in today's time. 
I'm seeing go to be rather popular for *new* projects.
Or for migrating resource/mission critical 'components.' I'm seeing this quite a bit.
To add to that, there is the Catch-22: Because it's new, companies would find it difficult to hire Go developers, so they don't start using Go. And without companies starting to use Go, few people are interested in learning it. No one wants to be first, because it's a cost, essentially. Other tools are still good enough.
This is nice, I'm a big fan of the tSNE dimension reduction. Can it be parallelised? I'm less sure how useful Go is as a numerical platform. Do we have proper multidimensional arrays yet?
Core ideas are all good. But executions wise I prefer something like this: https://github.com/katzien/go-structure-examples/tree/master/domain-hex/pkg
Inertia, mostly. While Go has been getting traction, keep in mind it's not always the best technology that wins in the marketplace (ahem, Visual Basic).
The problem with benchmarking int vs float is that it is not language specific but highly CPU specific. How floating-point-arithmetic is done in hardware varies greatly between CPU architectures and even if it looks good on your test machine it may look very different in production. You may find info on this in CPU specifications or hardware reviews.
Good to know. Thanks!
It seems he copy-pasted the code into internal/fuseshim, and then from there all over the code base. So, it seems his code has evolved from a wrapper to a fork.
I guess errcheck can't catch that kind of thing?
If using the [Barnes-Hut approximation](https://arxiv.org/abs/1301.3342) then it would be possible to parallelize the gradient computation. To parallelize the optimization it would probably be necessary to use stochastic gradient descent instead of batch GD. I was thinking about creating a numpy-like Go package for multidimensional arrays but I found [https://github.com/gorgonia/tensor](https://github.com/gorgonia/tensor) which seems pretty complete. I haven't played with it yet though.
Ah my bad i didn't know they moved on from \`dep\`
Rkt can run any docker container.
I stand corrected then. My bad
Lack of key features such as Generics is a dealbreaker.
VB was actually great for what it was *intended* for. Where it fell down is that companies wanted to use it for other things that it was not well-suited for, and Microsoft at the time shrugged and said "the customer is always right."
Many of the latest and greatest server side projects are written in Go. Check out the cncf.io projects, and you will see quite a few are written in Go.
Pure opinion based on my observations. First, Go seems to appeal most to newer developer and to experienced developer. Go doesn't have as much excitement to entice intermediate level developers. (As one of the Go team put it Go asymptotically approaches boring.) In other words those new to coding are interested in Go because of its perceived simplicity. Those having experienced a career of complex and difficult to understand code look at Go as a possible way to simplifying and control projects. Second, the typical lifespan for Go developers who don't stick with Go seems to only be a few years. I see this be related to the "boring" aspect of Go. Go makes it difficult to abstract code and that, to me, tends to limit creativity. Go doesn't lend itself to just trying out code constructs that might prove to be interesting in and of themselves. (See also complex and difficult to understand code.) After a while I think this can push people towards another language. No matter though. The total population of coders is huge when compared to the number who have even looked at Go so I suspect it will continue to grow at a reasonable but measured rate. Something that seems appropriate to the Go ethos.
Are those free to use? I decided to go with writing unix timestamps between my network functions... simple
Because the performance and scaling of Go really isn't a killer combination for the vast majority of websites...
I think these articles provide something to think about but aren't the best examples. Code like the Go team doesn't have any application code example but instead links to the Standard Package Layout which only has a single domain (users). Practical Persistence in Go only has a single domain as well (books). The examples only show a subset of CRUD operations without filtering, cancellation, validation, authorisation, pagination/streaming/iteration of larger result sets, joined (merged) data or anything else that tends to muddy clean separation of layers. I think perhaps we would benefit from a community project in the style of http://todomvc.com that has "just enough" complexity to really show the differences between package layouts, frameworks, routers, error handling, authentication and authorisation and so on for a common example API. It would give us more concrete common domain examples when discussing these things as well as documented skeletons for developers looking to get started or make up their own minds. 
I don't see why it couldn't. The body of the if never refers to `err`, that should be easy to detect.
[removed]
Go is not friendly to beginners, not compared to languages like JavaScript and Python which are both practical languages for lots of common tasks: parsing spreadsheets and text files, building websites, solving math problems, etc etc. Yes, Go can do all of the above but it's more of a "programmer's language". It's a great language for command line applications, microservices and DevOps tools (Docker, K8s, Terraform) but it's not as approachable for building your first website or writing a simple statistics algorithm. This is part of the reason why I don't see Go becoming as popular as Python, Javascript, PHP or Ruby. However, I can picture a day when Go has replaced a lot of Java, C# and C++ code.
Yes we do. Gonum: gonum.org/gonum for matrices. Gorgonia's tensors (gorgonia.org/tensor) for nd arrays. 
you CAN use gorgonia's tensors to build tSNEs. Source: I've done it 
Nice example. 
In 2018, ten years after the demise of Moore's Law, only fast compiled languages like C, Go, Rust or Julia ought to be considered.
[removed]
Can you go into more detail around which standards fasthttp doesn't comply with and how? Also in what way it's buggy or poorly maintained? I've never needed the package (net/http is just never the bottleneck for me) but the README goes into pretty good detail around the tradeoffs chosen and the reason for the design, and the commit history and issues seem healthy. It sounds like you have a different evaluation of it though so I'd love to hear more about it incase I ever have a need for a package like this. I'm sure it'd help others as well who haven't had the time to investigate it as thoroughly!
Because it's easier to look to the past to not have self responsibility. Meaning if you love your c++ and you have problems and you don't want to learn anything new, then you are in essence dropping blame from yourself. The easiest thing in the world is to blame someone else and stay in the past. Some also go through languages weekly and they too are relieving themselves from responsibility by not learning what they should. Basically if you have a thought that you should be learning something, take some self responsibility in your decisions.
As an advocate for Go in a Fortune 100 company that has deployed 60+ Go micro services to production, I am now getting more interest from other areas within the company. The performance, stability, and reliability of Go programs has proven to be more effective than even the most well-written Java or C# programs. It’s slowly getting the attention of the most hardcore enterprise Java developers. For a company such as mine where the tried and true option is preferred, having any interest in something as relatively new as Go speaks volumes to its abilities. I think you’ll find that more companies are interested in it than you think; they just don’t advertise it. 
I’m confused as to why code would be written in a way where such a refactoring would be possible, let alone desireable. Did you just choose to use floats everywhere you needed a “number”? If so, yes, refactor! But not for performance! For readability through communicating intent...
People hire engineers for their fundamentals and problem solving, not for just tools. Maybe you should avoid fixation with Go. 
I like this comment and think you pretty much hit the nail on the head. Lots of developers don't really write simple to read code, and at the intermediate level, complex but "cool" solutions are viewed with great respect. &amp;#x200B; I think this actually goes back to that meta work is more interesting than work. However, if you are trying to think of what you are doing as adding business or customer value, writing super complicated code or adopting complex frameworks that paper over complexity (as is VERY common in Java and to a lesser degree C# and C++) doesn't actually accomplish either of those things and could as well be considered the opposite of adding business or customer value.
Yes yes yes yes. It's so much nicer to get type errors at compile time when mixing up parameters vs random "not found" errors at runtime. It also let's you hang methods off the id type, which can be pretty awesome. So instead of something like: ``` func (db *Db) GetFoo(fooId int) (*Foo, error) { } ``` your code can become ``` func (id FooId) Get(db *Db) (*Foo, error) { } ``` and so on. (Maybe it's arguably if that's nicer, but I have found it to be so.) Being able to very easily defining new types for primitives is one of my favorite Go features.
This post makes a good argument against exception based error handling. https://www.reddit.com/r/golang/comments/9gxycu/go_solves_error_handling
You know how much it costs to hire go developers? How about re-train your developers go? Just so you can build something slightly better? Rewriting or writing a program in go vs, say, Java or c# usually isn't worth re training your developers for. If you want faster, more scalable program, good software design + better infra is a much better approach. 
&gt; Go can do all of the above but it's more of a "programmer's language". It's great for command line applications, microservices and DevOps tools (Docker, K8s, Terraform) Exactly, and you are seeing a lot of top-tier development teams using it. I can't think of a better language overall to build out very specific standalone web service-based software that runs fast and scales. Comcast's streaming on-demand video and many of Google's systems are built in it for good reason. I see it taking a good marketshare in about 10 years, which actually isn't a bad timeline. We are just now at a point where a competent Go developer has a decent chance at landing a Go development job. With Go 2.0 possibly having generics (at least last I heard it was up for serious discussion) there will be little to complain about as that has been a big gripe.
Was reading Uber eng blog. They basically scrapped Python and NodeJS microservices and rebuilt in Go-
&gt; Go is very new It's almost 9 years old.
Have you tried Crystal lang?
Goland (cost) and VS Code (free) are the two I mainly use, Goland as my primary, due to the amount of features that just work out of the box, VS Code is still amazingly fantastic, but does require a little work on the developers part to configure it. 
Thats nothing when talking about network effects of a language.
But only started really catching on a couple of years ago. And remember Python started in 1989 and people are calling Python new. Because it's just emerging in a lot of new areas.
I see a lot of reimplentation of C projects with Golang.
Yes, it's by no means "old", but calling it "very new" is a bit of a stretch in my book. It has a huge ecosystem and major production-grade projects are built with it. But we can quibble over the definition of "new" all day long.
&gt; Not to mention having to hire a whole new team and fire the old one Just imagining some manager coming in Monday morning and surprise firing his entire team of developers because they were hired to work on a language he's suddenly not interested in and the developers just confusingly walking out of the office is hilarious for some reason.
100% agree 
Well, here is my 5 cents worth anyway [https://play.golang.org/p/EkVePxZGmBG](https://play.golang.org/p/EkVePxZGmBG) &amp;#x200B;
Go is probably my favorite language, but this post reeks of immaturity and a lack of perspective. What does "fast and scalable" even mean? I can guarantee that whatever you're building can be made just as fast using a few of the other languages you listed.
Me too.
Just a quick question, does it continue to index file periodically every 5 minutes to the `goindex.db` with this second command?
As no one seems to appreciate it. I will. Thanks for providing it.
We use Go for our headless CMS backend, and I think it's brilliantly conceived and written. I started out on Perl, than PHP, than Python. By far I've enjoyed Go the most.
honestly, the name is trying to be too clever. NOAA is a trademarked term, it isn't a generic English word like "cloud". It's also misspelled a dozen times in the article, which is just intense.
Those other languages have decades head start. It's a lot easier to find Java or C# devs than it is to find Go.
Its gaining ground in Sydney. There is a fair few jobs around. I think it's to do with talent and cost of talent. There aren't too many expereinced programmers in the lang. But its definitley picking up.
They might have free tiers. Take a look at opentracing, there’s some useful libraries there, as well as a list of providers. http://opentracing.io/
That would not happen. I worked in company, where one day managers decided that all of us, C++ programmers, are going to write new project in Javascript. And we had two options, learn it, or change company.
context.Context
The first call sets `err` without using it, so maybe it's that?
I hope you found a much better company :)
Put yourself in the position of a big company. You have bought 5 different enterprise software which you use, enhance and operate. 2 C# and 3 Java. You have a stock of 20 developers which you happily restock with fresh devs produced by school (which teach Java and C# because it is used in industry). You are a manager. 
You have to expand on this point because it's a pretty vacuous generalization as it stands. Not all trade-offs are equal.
It's obtuse
In theory, integer operations are faster than integer operations. This is because floating points need to be normalized after the operation. However, you may not see a difference when pipelining is in use. This then depends on the CPU and the code. If your code has if instructions, pipeline can't be used. The rule of thumb is that if you have the opportunity to use integer in place of floats, than there is a good chance that your code will be faster. How much faster ? It depends. 
The latter. It reads the index into memory. If you have an updated index file, restart godoc again to read the new file.
I don't think the names of US Government agencies are trademarked.
Given its young age, go is *very* popular. There aren't many language whose user base grew so fast, except maybe Java, because of the impressive marketing campain back then. But it's still relatively young, and in a saturated market. The later a language is created, the harder, as it has to compete with tons and tons of existing libraries in other languages. Oh, and yeah, you're overestimating go. It's a language I love, but I wouldn't rewrite any of my existing infrastructure with it just because I like it.
By scalable i mean the code is maintainable and extendable as it grows larger. PHP, NodeJS, C++ is not scalable. By fast i mean yeah faster than most language, Ruby Python is slow af.
Do you think it was easy to find a Python job in 1998? Or in Perl in 1996? Heck, even the uber-popular Javascript in 2004 was still considered a toy, and not something you could find a full-time job with.
Not OP, but anything that involves arithmetic operations, because of the lack of operator overloading. Say, matrix manipulation, big numbers manipulation, formal calculus, geometry, etc. Or, anything hard realtime. Or, anything that must be proven. Or, anything that must be embedded on an architecture with very little memory.
[It is trademarked.](https://trademarks.justia.com/756/58/noaa-75658200.html)
In this case context.Background.
It defines a method on a pointer to a File struct, *File being a pointer type to a File and f being the name assigned to it, like `this` in many other languages
Seems like you'd be a fun person to work with.
You're overestimating Go.
Until recently bug reports were ignored for almost a year. I had a at least one that was recently addressed and merged. So there were long standing bugs -- particularly related to a coarse timer scheme they used to limit the amount of time system calls -- you go strange and erroneous results if you used a sub second timeout etc. In terms of non-standards compliant, please google a bit.
Mee ?? Or the guy who call me immature just because i didn't write correctly, eventhough everyone gets the idea.
Um... Extendable? Without type parameters? I don't think so. It's not even all that fast, given the overhead of the GC. Compared to well-maintained C++, Rust, etc. Go doesn't have all that many things going for it. Just because you think it's easy to use doesn't mean others automatically want to use it.
ah, I see! Thank you, now i know how to find more information about it :)
This is probably going to depend on your processor as much as the language runtime.
I recommend you take the Tour of Go, here is the section relevant to your question: https://tour.golang.org/methods/1
I'll add to this: - Garbage collection (it's the result of shoddy design, not a feature. Doesn't solve the problems of resource management, isn't efficient) - Poor error handling - Lack of type parameters - Attempts to be Python by moving what errors it can to run-time rather than compile-time to avoid offending the inexperienced.
Fucking delusional. Go doesn't handle anything. In fact any language does what go does and more, normally it's less verbose and with better guarantees. This is like when mothers try to convince others there baby isn't ugly.
&gt; They can recognize that a reference is basically a "safe pointer" and that methods are just functions that take pointers to structs as arguments. Those are just two levels of abstraction. One is no more real than the other.
What's the canonical literature on clean (hexagonal) architecture? I've seen the talks on it by Robert Martin (uncle bob), and read some blog posts about it, but they different a bit from your take on it. &amp;#x200B; I've been experimenting with clean for a while now, but I still don't have a good grasp on what is standard and what isn't.
I'm going to play devils advocate here and say that Go isn't popular for things that a better fit exists in other languages. For example: - Schemaless work ("anything goes" in the sense of unstructured data) Go is a typed language, so working with arbitrary structures which may be of any type, especially like in PHP or Javascript, is very cumbersome. You can't really achieve a similar kind of expressiveness, which would cost the language it's type safety. Even basic "holds anything" `interface{}` usage is frowned upon, and I haven't seen a reasonable attempt to achieve something like this. Metaprogramming might be an answer (Node implemented a lot of language features with it), but Go doesn't have a facility which would support it. I kind of wish it did, since it would be fully optional - like `go generate`, and it would give a lot of users the option to experiment with new language features without going towards Go2 (generics, etc.). - Templating work for html front ends While Go has a strong html/template package in the standard library which is OK for many use cases, the torch for building front-ends usually falls into frameworks like Vuejs (I do like this one), React, Angular. It depends on what kind of developer you are, but generally it's easier to find front-end developers, and Go developers then concentrate on systems stuff. If you'd use html/template, you'd probably have issues finding enough developers to do it (not to mention that the problem domain here is completely different... not sure if I'd even try). - Existing projects with commercial interest If you really think about it, there are very popular frameworks and products like Wordpress, Woocommerce, and other webshop stuff which constantly needs tweaking. Agencies usually do work for customers that have web shops and blogs, and provide branding over it all. Go is a systems development language - if somebody would have developed with Go a great system for ads delivery (like OpenX once upon a time!), or a webshop API, or a CRM or something that would compete in these areas... there is a lot of room for a commercially successful product, that would also increase the job volume of the Go community as a whole. Or, given the divide of what's important to clients - likely it would just mean more jobs for the front-end guys from the previous bullet point :) What do you think?
But that is the point. Go proposal provides a value and an error. Is decision of the developer ignore the error and still use the value. I understand the strong culture in golang of doing the correct thing here, but each call to a function is an opportunity to make a mistake and ignore the error and use the wrong value. Other languages solve this issue make it a XOR: or you have a correct value, or you have an error. In this case the developer can still ignore the error, but there is no value to use! IMHO the Go proposal is a lot of boilerplate and is not resolving the real issue.
Yea that's definitely up to debate, but it was meant as a competitor for C++, not Python. If Go didn't exist, nobody would have thought to write Docker and Kubernetes in Python - they would have written them in C++.
Not many companies using Go? Pretty much every large tech company you would've heard of use it, here's a list of a few: [https://github.com/golang/go/wiki/GoUsers](https://github.com/golang/go/wiki/GoUsers) &amp;#x200B; off the top of my head, some other notable mentions would be blizzard, twilio, kubernetes, mailgun, reddit etc &amp;#x200B;
How about a game of... [Go](https://en.wikipedia.org/wiki/Go_(game))? ;) :P
Parallel torrent / file downloader should be fun. With progress bars and shit
Minecraft-like game server (and client? check out https://github.com/g3n/engine and #g3n in Gophers slack)
My hobbies involve the game engine Source Engine. My Go projects are about writing file loaders for its file formats. Perhaps you have other hobbies that, like me, you could write some implementations for.
C - 46 years old
Command-line tools is another commodity… But I really like to create this kind of app interface.
Rewrite an existing CLI program in Golang. It's portable across all systems. I've learned much along the way.
I'm thinking of writing a distributed simulation in Go, but I wouldn't know what could be an interesting simulation for you to create.
Writing a compiler/interpreter of any language is a *lot* of fun and a huge self-education experience. Even when not completely finished and/or just thrown away/abandoned later.
Obviously this code is tongue in cheek, but as a beginner in Go I would appreciate any comments.
Ok wo I'm curious how would I begin go brainstorm something like this? 
I had fun implementing a neutral net with each neutron as an independent goroutine. Didn't solve the teaching it yet tough, since most algos are matrix-based
Damn guys, there're so many good ideas that you made me want to start *more* side projects
You'd have to create your own Un/Marshaler: https://gist.github.com/mdwhatcott/8dd2eef0042f7f1c0cd8
I get the joke, but: This is actually just a more complicated heap-sort ;) So it actually runs in `n•log(n)` ;)
Oh, and also, maybe more interesting: Since this only works for ints anyway, you can also use [bucket sort](https://en.wikipedia.org/wiki/Bucket_sort), giving you actual linear (average) performance :)
 ls /bin should keep you busy for years
Happy you liked it, it was a great fun for me 🙂
Did [that] (https://www.github.com/DeedleFake/ggigl) already. I wonder if it still works... I haven't looked at it in a while.
&gt; I'm sad enough that I develop on Windows Say no more
I found that this type of project helped me a lot with correctness in my vocabulary and despite already having written code for years, after playing with an interpreter there were certain classes of documentation (such as in languages where I'm not experienced) that were far easier to read because I wasn't missing context that I would have previously glossed over--probably assigning a more generic meaning to some of the terms.
And it's little, simpler brother: markov chains. :) The result is lower quality "decisions", but it is quicker to grasp and still very fun, and it gives some good foundation for then moving to nn.
Given a list *a* of *n* elements with an O(1) access time to each element. If I am not very mistaken this runs in O(c_1 + max(*a*) \* c_2) which reduces to O(max(a)) and has nothing to do with heap-sort. The time complexity of this algorithm is not bound to the number of elements but on their values in contrast to almost any other sorting algorithm. Btw. if the scheduler is very busy this might break the algorithm.
Yes, I changed it :)
can't believe file sharing is still a problem in 2018. I'd love to work on a project that finally solves distributed file sharing.. maybe ontop ipfs? https://github.com/ipfs/go-ipfs https://blog.cloudflare.com/distributed-web-gateway/ https://ipfs.io/
Use the Unmarshaller interface https://golang.org/pkg/encoding/json/#Unmarshaler https://blog.gopheracademy.com/advent-2016/advanced-encoding-decoding/
Implementing RAFT as a library
I still find it strange to see interfaces put next to an implementation of the interface, not next to the consumer of an interface.
Here is a possible implementation for decoding the computer addresses: [https://play.golang.org/p/xIWbMyP00sY](https://play.golang.org/p/xIWbMyP00sY) You can of course implement error checks as you see fit. Since your encoding is specialized, you will also need to do a marshal function to make it symmetric.
[Arraymancer](https://mratsim.github.io/Arraymancer/uth.speed.html) shows some int/float comparisons for nim.
Why not [gRPC](https://grpc.io/)? There is Go library, documentation, examples, etc. GitHub should have plenty of projects using it. 
But that's sort of the point. In a section of real code, there would be an `if err != nil` check after the call to `bar`, so _err is getting used_. The bug is that the `if err != nil` check was accidentally omitted after the call to `foo`. What we need the linter to catch is that the assignment to `err` from the `foo` call specifically is never used, even though the value of the `err` variable is indeed checked later in the function.
Perhaps, but I'm still curious about &gt; Typically you get an “assigned but not used” warning What tool do you use to get that warning in situations like this?
what language has language support for XML?
How long of a project are you looking for? As a few people have mentioned, CLI tools are a good alternative to web development, and can provide interesting challenges in terms of user experience. As a massive departure, an emulation project can be a fun challenge in Go. CHIP-8 is a really small "toy" machine that is great to get started on. I built one of these a few month ago, and it really got the ideas flowing! More details (with C examples) at: [http://www.multigesture.net/articles/how-to-write-an-emulator-chip-8-interpreter/](http://www.multigesture.net/articles/how-to-write-an-emulator-chip-8-interpreter/) If you're looking for something more "individual", I like to look for things I do repeatedly and try to find ways to automate or simplify the process. As a (vague) example, I'm currently working on a helper for common use cases of a complex CLI tool.
Can you give an example of what type of language you better understood?
(_sigh_) Like it said, syntax is a small part of it. It's the features Go offers + gofmt + idiomatic Go + the community that = the success we are talking about here.
Atom, Vim, Visual Studio, etc.. all have plugins that can all tie into gofmt, golint, etc...
The scheduler has to know at any moment which goroutine it has to wake up. Which means that the mechanism underlying `time.Sleep` has to put the calling goroutine into some data structure, like a heap. Since we're talking about big-O, let's let `len(arr)` become very large, so that the cost of maintaining that structure becomes greater than 1ms per call. So the length of the longest sleep *isn't* the dominating factor; the cost of scheduler housekeeping will be `O(nlogn)` or greater.
C compilers give this kind of warning habitually and it doesn't seem too hard to implement. I haven't written Go in a while, but I assumed that Go's tooling was on par in this regard.
Totally agree with you. I'm been using PHP, C#, Javascript, Python and Go is by far the best language. It is simple but also fast and efficient. Just think about C# keywords like **static, public, private, protected, abstract, sealed, internal**. Go doesn't have any of them, but works even better and simpler.
Taipei-torrent already exists. https://github.com/jackpal/Taipei-Torrent. But seems to be un-maintained. It will be great to have a solid torrent client written in pure Go, that can compete with BitTorrent or UTorrent.
I'm implementing PragProg's Raytracer Challenge in Go to learn the language and do something I always wanted to: https://pragprog.com/book/jbtracer/the-ray-tracer-challenge
I've never had the use for such functions. I just write a loop like a normal person.
Sorry, but I feel like none of these features are THAT important from a software engineering perspective which is what I think the question was about (with the possible exception embedded software, but who does embedded software in a language besides C anyway?)
&gt; even the uber-popular Javascript in 2004 was still considered a toy some of us still consider it a toy in 2018..
Could hiring difficulty be because the Salary is to low to attract actual Go developers, or because of your location?
I'm well aware of that. None of the compiler, nor gofmt, nor golint complain about this bug. I was hoping there was some specific tool I'd missed that warned about this specific case.
A new "bar" or "panel" application with native UI components, for Linux, with support for a StatusNotifierItem-based system tray and extensions to add support for window managers like i3 (please!)
&gt; Sorry, but I feel like none of these features are THAT important from a software engineering perspective you mean for the cookie cutter web developer monkey you can engineers. 
Well, I'm not especially fond of it either from a technical point of view, but wa have to admit it's a tool that can make you tons of money.
There are a lot of factors at play. Is this piece mission critical? What are the complexities? Is this a monolithic or micro service? What's the cost of training? Developers are not cheap. Every day a developer is learning new thing is a day they can be spent building /fixing. It's go worth that investment? Vs putting the time /money on better infrastructure such as a testing framework or catching up on bug fixing? How will the resulting go service be supported if the developer is out? Do you train devops too? The entire team? Most of the time the answer is "no, it's not worth the time and money". 
I just wrote a little console emulator based on [ebiten](https://github.com/hajimehoshi/ebiten) to create some ascii games. That's far away from all the backend stuff I otherwise work at.
There is a Google Talk on this subject: [Visualizing Data Using t-SNE](https://www.youtube.com/watch?v=RJVL80Gg3lA) (Video)
Nope. The entire backend for this (crawling, indexing, serving, etc.) was built using Go: https://search.laserlike.com/
Is your node package rendering on the server side? 
Nothing in the question explicitly limits it to software engineering, but still : &gt; matrix manipulation, big numbers manipulation, formal calculus, geometry, etc. lots of readability issues with, say, the bignum library, because a slightly complex formula becomes unreadable. How do your write `(a + b/2) * c^2` in go, when a and b are bignums and c is a regular integer ? Oh, btw, when I do `x := y.Mul(z)`, does it modify the value of y ? Why ? Yeah, I know it's a tradeoff and operator overloading comes with lots of problems. But still : in some domains, the inconvenience of not having them is worse than the problems they bring. &gt; anything that must be proven How is proving software correctness not relevant to software engineering? &gt; who does embedded software in a language besides C anyway? Hmm, lots and lots are made in C++, and heck, even Java is used in (way too) many embedded devices. I remember programming lego mindstorms in java, 12 years ago (not my fault, I've been forced).
I wrote [a network-tester](https://github.com/skx/overseer/), which allows you to test remote "things". For example ensure that your website is up, that a remote rsync server is running, etc. Using a work-queue you can make it work in a distributed fashion very easily. After that there are the obvious command-line utilities, such as [a toy scripting language](https://github.com/skx/deployr] to upload files via `scp` and run commands over `ssh`, using a single connection. Useful for deploying software - kinda like fabric-light, or ansible-very-very-light. Others have mentioned emulators / [virtual-machines](https://github.com/skx/go.vm), and [language-interpreters](https://github.com/skx/monkey) and they're also fun to play with. Finally you can look at re-implementing programs that are abandoned; I [rewrote](https://github.com/skx/implant) the existing [go-bindata](https://github.com/jteeuwen/go-bindata) program because I started using it a year or three ago, and now it is abandoned. 
You must not be working with data a lot. Just the pain of writing these loops hundreds of times, and finally - when you have to add something to a condition - urgh
Realized I hadn't actually written a blog post about Mage, so here you go.
Maybe ¯\\\_(ツ)_/¯
I do work with data a lot and that loop is so simple to write that I don't even think about really. And adding something to the condition is super simple. It looks like this basically: result := make([]someType, 0, len(v)) for i := range v { if condition(v[i]) { result = append(result, v[i]) } } Super simple to write and adapt. 
Right, you're just underscoring my point or rather you're bringing up the age old debate of whether you need to learn programming from assembly first or a higher level human-friendly language. I'd argue that the latter is easier and that comes from my experience learning C++ as my first programming language. I agree that it's important to learn the low level details at some point although it's not strictly necessary, there are plenty of self-taught folks who only know higher level tools/languages (some of them quite accomplished and/or well paid too). 
Yes, Go is great for people who actually know what dev/devops tools are which (an no offense intended here at all) is not the starting point for most beginners. Sure, many of them may need to build tools (scientific computing for example) but they're not building dev tools. Not on day one.
How about implementing a Robocopy like implementation with more flags and options 
Was Java _ever_ considered fast? Java is now faster than it ever was, and it's still slower than Go (never mind other languages it was competing against in its honeymoon period - C and C++). But there definitely is some truth to it - 1. Go is an explicitly boring language _by design_. 2. Computer languages are definitely faddy - name one language that's older than 2005 that's still cool (OK, Python is an exception, but it just got its honeymoon fairly late[1], and JS, which is the only language available on the browser). C? C++? Ruby? Tcl/Tk? Perl? Java? All highly used but are considered boring/yuck. I suspect that a lot of this is because new languages means greenfield development, while older languages implies maintenance - if you're getting a C job, you'll probably be maintaining an old huge codebase. If you're getting a Rust job, you're probably building from scratch as there simply isn't as much code to maintain. [1]. It was released in 1990, but I'm almost possible that it only got popular in the mid to late 2000s.
What's a fictional writing system? 
Wow, a serious reply... Also, I concur.
Glyphs, pictographs, and symbols for imaginary languages. 
Why does SleepSortable need its own type? why not attempt to do this with interfaces
Thumb up for not using medium. 
Java is and will remain a 1990's solution to 1980's problem. Generating bytecode that will run on Solaris, HP/UX, Irix and BSD is no longer a selling point. golang is designed to solve software engineering problems for Google. As long as these problems remain the same I don't see golang as facing the same criticisms. Plus its still on its way up vs. out. 
👍
Not sure if we mean the same thing, but what about syncthing, Upspin &amp; camlistore?
what i am doing is client and server running their own https server and use mtls for communication. however, I foresee there's a scaling issue because every time there's a request, there's a tls handshake. Where does if the client is already listening to the port the connection is already established. 
Games
Well said 😊
&gt;pretty much all the Python stuff should be code in GO You mean like Eve Online? Would be a hell of a side project ;)
This is the kind of feedback I was looking for. How would you do it with an interface? 
Also I have an underlying issue with client and server both have their own http server. That is because for every client request to the server only "one" operation is allowed. That operation will depend on the body and the header and there will be a `return` in the `HandleFunc`. However, what if the state of the server changes? Then i will have the client send the request again. If let's say the connection is already established, if the state of the server changes, it can still perform the operation with the client because the client is still connected. 
&gt; name one language that's older than 2005 that's still cool Smalltalk. I bet you feel pretty silly now, huh?
this
lol @ benchmark game. Have you seen the source code of the implementations for Go?
Having a JIT is a selling point. 
In most web frameworks, a "flashed message" typically **is** something that is stored until the next HTML page is rendered by the server for that user. Like, # you're in the endpoint POST /user/login with # username and password params, you want to redirect # the user to their dashboard along with a one-time # flashed message saying "Login successful!" at the # top of the dashboard flash("Login successful!") return redirect("/dashboard") The redirect returns an HTTP 300 Found with `Location: /dashboard`, the browser makes a fresh new HTTP request to `GET /dashboard` and as the server is rendering the HTML response, it gets the flashed message from the cookies and inserts it onto the page. If this is what you're talking about, Gorilla's flash feature is what you want. I think what you're getting confused at is that Go web apps are much lower-level than Express.js or other higher level frameworks, so you have to manage the sessions and cookies more carefully. The way a flash works is basically you create and send an HTTP cookie holding the message, the browser sends the cookie back on the new page request, the server-side reads the cookie and inserts it into the HTML response and tells the browser to delete the cookie so it won't flash again on future page loads.
For specific pointers in gorilla/sessions: * Use `AddFlash()` to add flashed messages. * To **retrieve** said messages, you use `Flashes()` to get the list of them, but now you have to make this available to your HTML templates. If using text/template or html/template something like, // template variables v := map[string]interface{}{ "FlashedMessages": sessions.Flashes(), } err = t.ExecuteTemplate(w, templateName, v) And in the template code, {{ range .FlashedMessages }} &lt;div class="badge badge-warning"&gt;{{ . }}&lt;/div&gt; {{ end }}
Doesn't matter. You are still going to be paying double for every operation in order to keep it memory-safe and garbage collected. There is no way around it. I get that for most software it doesn't matter, but there is a reason all performance critical apps are written in C++. And why Minecraft looks worse than Battlefield 1. Also note that Google isn't even using java on their new smartphone OS, Fusicia. I understand that this is largely driven by the Oracle lawsuit, but the point remains that there are better solutions these days. Especially for mobile where power matters. 
Thats great! Do you have a github or something where I can follow you? I think as it improves on C, its lifespan will be much longer... Well, either way, we &lt;3 Go. 😊😊😊
I do network and security engineering these days, not software engineering. In fact I went into this field because I hated all languages equally and didn't want to be a software developer. I plan on getting Brian's book and learning golang within the next year, so who knows though. 
I’m confused, are we comparing Java to Go or C++? I’m not sure what point you’re trying to make since Go has those same limitations. 
😂😂😂
Java is now faster than it ever was, and it's still slower than Go ^ no. That is not correct. It depends on the task. Jvm is a state of art. 
Not sooner or later, Go is already slower, verbose and old fashioned. Isn’t it?
Go and C++ have pointers. Java does not. In fact, the closest you can get it a pointer to a pointer, which is what I mean by paying double for every operation. Go isn't as fast as C++ in all cases due to being garbage-collected, but that's by design. 
Username checks out
This is a problem that I come across quite often when working with go. Great talk!
Slow?
No it isn't... **cries in a corner** 😭😭😭
&gt; Java is now faster than it ever was, and it's still slower than Go Netflix serves 2BB pieces of content a day using Java. Y'all can yap all day about theoretical differences, but a language is just a tool to solve a problem. ...and before you say "right tool for the job", this isn't a Phillip's head screw we're trying to drive into a board. The problem space is much, much larger, which makes the solution space equally broad. There's an entire array of tools that would be right for this job.
So submit a better implementation. 
Does your server actually need to push back messages to your clients or can it be requesr-response instead? I'm not sure if Go does this, but most HTTP(S) implementations can in fact reuse connections. This means that you can issue many requests using the same HTTP client without performing TLS handshakes over and over again. Do you have actual performance issues, or is it just a 'feeling' that this is inefficient? If the latter, then stop optimizing something that is not yet a problem.
Also, Java is now getting Graal witch is direct competitor to Golang. Java, Kotlin, JS, Ruby, Python, R and any LLVM supported language can be run in a polyglot JVM and/or compiled to native image.
take a look at what is graalvm, native images, polyglot VM and ZGC.
😂
Java has JIT+AOT and GraalVM is JIT+AOT on JIT (java on java).
I did something similar a while ago. [Client](https://github.com/akillmer/riptide-client) and [Server](https://github.com/akillmer/riptide-server). The client was my first attempt with React, got real messy real fast.
None of these address the inherent issue that Java simply does not support true pointers. 
I’m confused... that’s what I’m saying?
Java was always slow.. verbose.. and safe. Thats why it was chosen for enterprise in the 2000s. Golang is fast, verbose, and safe.
Go and C++ have pointers. Java does not. Can't make it more simple than that. 
This looks quite nice! I would suggest removing the reference to Gradle; some of us have bad memories and Mage doesn't look much like Gradle. :)
&gt; Go isn't as fast as C++ in all cases due to being garbage-collected, but that's by design. So Go's trade-off is acceptable to you but Java's isn't? What is your obsession with direct memory access? For the vast majority of software, that level of performance optimization simply does not matter as you are nowhere close to being CPU bound. There are certainly situations where you want to eek every last ounce of cpu-based performance out of your application, and in those situations C/C++ are the better choice. I enjoy using Go for a myriad of reasons, but let's be real: the vast majority of applications we're writing here are http web services. In that context, discussing references vs true pointers is completely absurd.
It would be incredibly depressing if it _weren't_ true! 
Golang is already old fashioned. It is smilar to C. But procedural programming is coming back. It is old yes and it is also cool, clean, easy, verbose, fast. Best language for internet.
About the second one, a game that the gui is swappable, could you recommend me some books or tutorials about how to design and implement an architecture that allows for this?
Interesting "inherent issue" considering it can run [LLVM bitcode](https://github.com/oracle/graal/tree/master/sulong).
No, it makes easy to understand.
Well yeah, I was just pointing out one thing Java has that Go does not that could be considered a selling point. 
Do you understand the difference between a language and a virtual machine? C/C++ and golang support direct access to memory. Java does not. End of story. 
I'm saying it has more than JIT nowadays.
Tell me the difference between an object reference and a pointer. In C++ objects can be both value types and reference types but in Java they are all ref-types. Having pointers can actually slow down you application as this means more allocations and more cache misses.
An object reference is a pointer to a pointer. A pointer is a pointer. That's why you are paying double. Have two pointers instead of one means more cache misses which means slower performance. 
We've just released 2018.2.3 which fixes the use-case you provided. Please see the announcement post for more details: [https://blog.jetbrains.com/go/2018/09/20/goland-2018-2-3-is-out/](https://blog.jetbrains.com/go/2018/09/20/goland-2018-2-3-is-out/) Thank you very much for your feedback and helping us solve the problem!
Any high dimensional continuous variable data. It's best really for visualisation, and seems to work particularly well in biological/natural data.
[removed]
Thanks a bunch, my dude!
Thanks!
Cool good to know. Are people using gonum for data analysis / data exploration, or is it more geared up for repeated analyses?
&gt; Graal witch is direct competitor to Golang Graal is a VM right? How is that a competitor to Golang? I can see it addressing startup time, but I'm doubtful on memory usage. Certainly it doesn't address any language related things.
You are an elitist but you'll probably deny that. &gt;There are plenty of mechanics that never went to trade school, yet still have jobs... doesn't mean I'll let them work on my Ferrari. Those dudes are why bad Yelp reviews exist. Learning how to build a basic webpage or parse a test file aren't Ferrari-level tasks. &gt;I agree that it's important to learn the low level details at some point although it's not strictly necessary s/important/useful/
Maybe. https://tratt.net/laurie/blog/entries/why_arent_more_users_more_happy_with_our_vms_part_1.html
&gt; Java is and will remain a 1990's solution to 1980's problem. I've frequently described Go as a very, very polished 1990s language. Java wasn't. I'm not necessarily saying it wasn't bad, but it was not polished. It was rushed out by a marketing division, and it shows, in multiple dimensions, including the name "Javascript". (Not a typo. The "Java" in Javascript was thrown on there in an effort to keep the half-baked Java from becoming the scripting language of the web. That's far from the whole story, but it's part of it.) C# is another good take on that idea, in a very different direction. I don't use it, but I respect it.
this makes no sense man... Working in big data, the landscape is almost entirely built on top of the JVM in some way and Java is pretty core in a lot of tools (albeit many big data tools are shifting to scala, but still...)
Well, "verbose" and "old fashioned" are definitely in there already. But, taking it seriously, [Java 1.0 was released January 1996](https://en.wikipedia.org/wiki/Java_version_history). Go 1.0 was released [March 2012](https://blog.golang.org/go-version-1-is-released). So, the sixth year of Java would be 2002. Having been around then, I can assure you Java already had a lot of the current elements of its reputation. It is quite clear to me that Go is not on the same trajectory at all. It's being run by engineers and not marketers. In a weird sort of way, it's important that while Google supports it, it isn't something Google is trying to base its entire business on, which is really the sweet spot for getting an effective language. And said engineers are _really_ watching out for the failures Java had; they're not bloating the standard library, they're not chewing on memory like it's free, they're carefully watching compiler performance, etc. The culture is much different, too, both in the way it was initially bootstrapped by the creators, and the way in which the language drives the culture itself too. I still think it is almost impossible to overstate the culture difference between Go's implicit satisfaction of interfaces and Java's need to explicitly satisfy. It sounds so minimal on paper, but the effects on the ecosystem are so profound. I think it is this one characteristic above all that has driven the Java world into these massive, all-encompassing frameworks, and the subsequent wide acceptance of them, because if you have to _declare_ conformance to some interface, that pretty much means you _have_ to have a framework "above" you in the code organization. With this small tweak, Go does not incentivize the tumorlike proliferation of layer upon layer wrapping more layers in a desperate effort to have multiple frameworks getting along. Instead in Go, you can have whatever "frameworks" you like, but you just stick them together more like what you'd do in Python or JS or something, you don't end up with these massive commitments, and all the followon crap that resulted (massive XML files trying to describe how to merge three frameworks together, etc.).
If you think about, everything, no matter how well designed, is ultimately a failure. Every product we make becomes obsolete. Every computer, every language, every technology. At some point, people will identify a shortcoming and replace it with something better. That fact should not stop us from adopting the beat technologies we have right now.
Go isn't always fast. For example, an interpreter loop for the Wren programming language is about 3x slower than C. In Java, you can go faster with the same portability by generating bytecode, since the JIT compiler is part of the run time. This is a corner case, though. Most people don't write interpreters, or if they do they don't need to match Wren or Lua. Generating Go code ahead if time is usually good enough. Go's advantage isn't raw speed but rather, predictable performance that's reasonably good. A JIT compiler has warmup time and can be hard to benchmark. It will *sometimes* be faster under the right conditions, but it's also easier to hit a performance cliff.
&gt; Go allows fields of struct to be stored directly inline instead of always a reference to a separate object on the heap. This means you have many more heap allocations in Java and many more pointer indirections (cache misses). This is what I was referring to when I mentioned 'paying double'. I didn't know the exact details how golang got around this, so I appreciate the explanation. 
Each go-executor (of which you have gomaxprocs) has it's own run-queue, so the overhead is pretty minimal (there is a global run-queue but it is used sparingly). There was a great talk on Gophercon about it: https://www.youtube.com/watch?v=YHRO5WQGh0k
Graal is a set of technologies, it's a VM, polyglot to java-byte compiler and compiler to native images. It addresses many issues Java has now, like creating native, memory-safe binary files from Java/Ruby/Python/R/... code, drops unused code during compilation, compilation process is supported by AOT for every supported language, startup time is basically file-read time, measured in a few microseconds.
Lose the ad hom immediately, or catch a block. Completely against the code of conduct. &gt; Learning how to build a basic webpage or parse a test file aren't Ferrari-level tasks. Even a Ferrari needs mundane things done, like checking the air in the tires or changing the oil. Likewise, mundane tasks like file parsing will contain pitfalls to the unaware.
Are you sure this is how it is implemented in Java? I'm not familiar with the Java-runtime but I actually guess it works more like a go interface. You have the instance fields, the virtual function table and some metadata for the jvm. You have a lot of references and virtual function calls going on in Java but you also have a smart runtime and a compacting GC to counteract this somewhat.
I'm not talking about "Big Data" (which would be much better served via C++ or golang). Think web browsers, AAA gaming titles and other real-time software systems. It's C++ all the way bruv. 
Thanks. But I still don't know how to get started with a good structure with design patterns.. 
If Go is the new Java, then [Nim](https://nim-lang.org) is the new Go. ;-)
It was literally what someone asked in a Go meetup "What's Go's version of gradle?" At the time the answer was... there isn't anything. But definitely didn't want to confuse anyone. Mage is not like gradle. Mage is like Make. Very very similar to Make. Except Go. :)
Do you Close alk youe request/response.Body?
Different tools for different jobs. I like having access to OpenGL from java, and so far I haven't been able to easily access that from go.
For sure, go does a good job, but still, it has to be greater than O(1).
Let's just agree to disagree.
C#, the Sting of programming languages? https://www.youtube.com/watch?v=wWjJVriFL_o
Where I work we have hackdays once a fortnight, this is what I made today. It uses GoLang compiled to WebAssembly to drive a game on a HTML5 canvas. A few improvements I’d make if I had more time: * Add acceleration when the ball falls, at the moment it instantly gets up to max speed * use request animation frames * animate the ball moving on the x axis, at the minute it jumps 15 pixel each button press * do line collision detection on a circle like the ball, rather than a square around the ball.
True. You could say the same thing about PHP-based services. Doesn't change the fact that real-world performance is an actual pain point, and that if you use a more efficient language that is tuned to the problem space, you can do more with less. At the end of the day, it's usually a matter of what your current devs are comfortable writing, more than anything else. If decisions were based on actual merit, we'd probably see a bit more diverse language utilization
Go is a fully AOT language. There's no point to a JIT because the code is already full binary. There's no VM, parser, or interpreter getting in the way. JIT only solves problems that are caused by non-native code. 
Well, what name did you use when you did go mod init? I didn’t check thoroughly, but modules do not work inside the gopath (at least not by default)
Huh, that's pretty cool! Looking forward to seeing how it develops. I really like Clojure, which runs on the JVM, hopefully Graal means good things for Clojure too. 
I've yet to see anyone put forward a JIT for a non-interpreted language. And most of those optimizations are to fix the fact that interpreted languages are less efficient than native code. 
I am OK with not using GOPATH. I don't think I gave a name when I dod go mod init 
Never heard of nim. Sounds hip, I'm gonna try it out.
I'm well aware, I just didn't want to get into the nitty-gritty. There are good reasons to stick with one stack, I deal with it in my job plenty (curse you PHP and Symfony). But if it weren't for comfort and skill translation issues, it would be better to pick a stack that better reflects your goals and does things efficiently. And like you said, eventually a stack becomes so outclassed that you realize how foolish it was to just keep running the old stack all those years. 
Is medium not liked?
[cu](gorgonia.org/cu) is probably the most complete solution for Go. PR welcome
Sorry for the delayed update, I have no idea how to use the new Reddit editor. Yes, I discard the body and close the response body (see update above).
Yep. Gorgonia would definitely fit your bill. If you're wondering what it's capable of, here's a bit of a [spoiler for sept 2018](https://thestrangeloop.com/2018/a-funny-thing-happened-on-the-way-to-reimplementing-alphago.html)
Sorry for the delayed update. In Go 1.8/1.9, our ESTABLISHED connections rarely exceed 50. But nowadays, I see it growing slowly &gt; 4000, which looks like a leak to me.
[removed]
And Go serves how many downloads on Google.com. But it doesn't matter, since (I assume) that it's more network/IO bound than CPU bound. But I did say that Java's getting faster. It definitely wasn't lightweight back in 97.
I am unfortunately writing javascript. NPM is garbage. But that is not in the same category. @skybrian2 I had no idea about gradle but i just checked and it is installed on my computer. The point is comparison makes difficult subject easy to understand. Checking gradle first and than mage made it clear to me.
Yes. That is why Hadoop and state of the art big data processing workflows are based on the JVM. It's primary yucks are the greatly annoying boilerplate, type erasure, and less than ideal garbage collection. Runtime speed isn't one of the major pain points and hasn't been for over 15 years. Working with the garbage collector is, but there are common patterns to overcome its inefficiencies.
&gt; C/C++ and Ruby are still relevant and not considered "yucky" Look at [stackoverflow's survey](https://insights.stackoverflow.com/survey/2018/#technology) (which, I will admit, isn't a scientific study), where Java[1] is more loved than Ruby or C++, and C is more hated than C++ and Ruby. [1]. And _bash_ is more loved than Java. That says something.
lmk if you need help
What makes this better than https://github.com/rs/zerolog
&gt; Golden times of Java are coming. They are over. It was a strange old idea one can download some byte-code file and execute it on toaster and then on server. It turned out this doesn't work that way at all IRL and you even need to have different binaries for different platforms running **same hardware**. In the real world practice the Java is a curse of Android and Java programs at servers are maintenance nightmare. And the bizarre memory consumption of JVM is not really helping too. 
[removed]
You've already achieved it my friend :) I think your structure is fine and you've clearly read some clean architecture and DDD articles and build a structure that works for you. I haven't taken it to that level of abstraction before but I'm glad you have so that you can tell us your thoughts after living with it for a bit. Ignore everyone who says it's not idiomatic unless they qualify it with code was my point I guess. Go is young and practitioners who claim that idiomatic style is established clearly haven't been in enough team debates over C style this year :) For what it's worth I really liked https://www.youtube.com/watch?v=oL6JBUk6tj0 that others have linked. Not for a conclusion or structure but the point early on about flat structures being fine depending on scale. Plus the speaker was someone building some prototypes, researching and picking their own path.
If Go "fails" the way Java has "failed" - i.e. become one of the most used languages in the world - I'd be ecstatic! 
Better question: Why are you writing your code like this? What's the value of writing a function that takes a parameter of *anonymous* struct type? Are you trying to achieve some weird kind of parameter polymorphism, or? 
Because I need to break dependency between packages.
&gt; Garbage collection (it's the result of shoddy design, not a feature. Doesn't solve the problems of resource management, isn't efficient) What other choice is there? Reference counting? There are tradeoffs both ways. For example, Go's reference counter would have to be atomic (Arc in Rust) since Go is heavy in multi-threading, which would require the garbage collector acquiring a Mutex every time a pointer goes out of scope, pausing all other threads while it recursively calls destructors. It's also going to be slower since it can't run on a background thread. The two advantages of Rc is: 1. It allows RAII (so you can close files just by letting File go out of scope). 2. If your `free` is hard realtime, it allows for hard realtime programs. The only thing is that Go isn't really geared as a hard-realtime language, and most desktops and servers run non-realtime Operating Systems (such as Linux, FreeBSD or Windows), making the whole thing moot. 
True
I think that's because people really abused OO programming and dynamic languages. What was meant to be powerful flexibility led to massive piles of shit code nobody could maintain (I'm looking at you Ruby). When you build with clay, it's not surprising all you get is mud huts. The required rigidity and structure of a static procedural language is, imo, the cornerstone of what allows large elegant and maintainable systems.
[removed]
Old fashioned will always be a great elixir.
&gt; It was rushed out by a marketing division, and it shows, in multiple dimensions, Brian K. called it 'strongly hyped' (vs. typed). 
Lots of people like to hate on Java, but the strict "antique" structure and verbosity make it an extremely familiar language regardless of who is reading it. Things like Spring added a level of "magic" that many were never very comfortable with, but Java at it's core is and continues to be a great language when it comes to being able to transfer knowledge. Go is like this as well, which I think is a major reason for it's success. Ruby is failing now because nobody can read or follow Ruby written by anybody else.
&gt; serious embedded and systems programming. Not denying that. But 20-25 years ago it was the go-to language for _everything_. Windows programs were written in C (or C++), servers were written in C, Browsers were written in C++, CGI was frequently written in C, CLI utilities were written in C, X11 programs were written in C.
That isn't how structs work. It doesn't matter if the fields in the struct are the same, the structs have to be the same, meaning they must originate from the same package. Golang also doesn't offer interfaces based on fields in structs, only for functions. &amp;#x200B; If you need to use a struct in two packages and avoid circular imports, you either need to extract the struct into its own package, or you need to rethink your design, preferably the latter. Typically you make packages that have isolated functionality, and then wire them together in a third package, often \``main`\` &amp;#x200B; You might want to take a look at this blog post by JBD (rakyll) about types in Go which helped me understand how things work with them much more effectively: [https://rakyll.org/typesystem/](https://rakyll.org/typesystem/)
&gt; Java is and will remain a 1990's solution to 1980's problem. Generating bytecode that will run on Solaris, HP/UX, Irix and BSD is no longer a selling point. Yes, but there still is an advantage in writing code on a Mac (or Windows) and deploying directly to a Linux server without rebuilding. Or running on an ARM server (like a rpi).
&gt; Doesn't matter. You are still going to be paying double for every operation in order to keep it memory-safe and garbage collected. There is no way around it. Why? How is Foo f = new Foo(); f.Bar(); different than Foo* f = new Foo(); f-&gt;Bar();
From another post: Go allows fields of struct to be stored directly inline instead of always a reference to a separate object on the heap. This means you have many more heap allocations in Java and many more pointer indirections (cache misses).
If you want, I can give you some example why I do exactly so and not in an another way.
&gt; Working in big data, the landscape is almost entirely built on top of the JVM That Java big-data stack is a huge, I mean HUUUUUUGE pile of shit. Pure map-reduce is way to nowhere – it is a poor approach to ML tasks, and too low-level for statistical systems. Also, this crap is slow and a huge maintenance problem by itself. &gt; albeit many big data tools are shifting to scala, Scala is extremely poorly designed language for **JVM**. Only popular because of Spark – which is just as crappy as Scala (just look at their development history). Slow, barely maintainable piece of junk. An admin nightmare. I have an unfortunate to deal with this shit and cannot be delighted more I decided to switch to much more practical Clickhouse + set of utilities and services written in Go, which covered all realistic purposes, easily maintainable and [several times faster](https://www.percona.com/blog/2017/03/17/column-store-database-benchmarks-mariadb-columnstore-vs-clickhouse-vs-apache-spark/) at that.
Yes, LISP is one of the oldest language and is *really* cool. Simple to write interpreter/compiler and meta-programming features that aren't reached by any other language today. It remains revolutionary today.
I'm surprised the first one works! I'm not often surprised by Go anymore! Thanks for that :)
You are welcome :)
If someone said "I want to build a fast program, whatever the cost", I would steer wide and clear of that person. That isn't a meaningful up front requirement. Discussing which languages are "faster" than other languages isn't a useful conversation. The ASM wizard always wins that fight, and always with an obscene amount of pointless effort. Java's reputation with serious developers is exactly where it should be. It's the best tool for the job in several prominent domains, it's the underlying system for better languages in other domains, and it has enough serious flaws that everyone is waiting for a proper successor just about everywhere. Speed is not one of those flaws. Every language has detractors. If you want to call that a reputation, that's fine. It isn't shared across the industry. You'll always be focused on newness, not on what works today. Golang is in that sweet spot of both being new and is seeing serious usage. At some point it will hopefully replace Java in some of Java's prominent domains. Likely by that point, it will be old and have a _reputation_ as you put it.
And now more important is how to leverage that error? :)
Not necessarily incorrect. But I think the "hard to follow" criticism of ruby is actually more due to rails. Vanilla ruby tends to be way easy to follow imo since you're not dealing with all of the conventional magic rails implements. That being said, I've been enjoying Go more lately.
And the answer is: &amp;#x200B; package main type A struct { A string `json:"a"` B int `json:"b"` } func Function(d struct { A string B int }) { // ... } func main() { Function(struct { A string B int }(A{})) } We need to cast type with composite literal with tags to a type with the same composite literal without tags... So, for now, the answer is: yes, these are different types 'cause they have different composite literals inside: &amp;#x200B; type A struct { A string B int } type A struct { A string `json:"a"` B int `json:"b"` } **But now that is another question: it is a normal behavior or it is a bug?**
* For a call to be possible, the arguments must be [assignable](https://golang.org/ref/spec#Assignability) to the respective parameter types * In this case, assignable means that both types have [identical](https://golang.org/ref/spec#Type_identity) underlying types and at least one must not be a defined type - the parameter type is not a defined type, but the argument type is, so this is fine. * From that section: Two struct types are identical if they have the same sequence of fields, and if corresponding fields have the same names, and identical types, **and identical tags** (emphasis mine). This is why the first case works, but the second doesn't. In the first case, the underlying types are identical, in the second they aren't, because they have different tags. However, there is another relevant part of the spec here: * A struct type is [convertible](https://golang.org/ref/spec#Conversions) to another one, if "**ignoring struct tags** x's type and T have identical underlying types". So you *can* convert a `B` to an `A` (or the struct-literal) to still pass it, if you want to. Hope that helps.
Ignoring Go for a second, What interests you; what hobbies do you have? Do you find anything on a day to day basis that annoys you or feels it could be done better? Isolate that and then utilize Go as a tool to solve that problem (not all problems can be solved w/ Go though). I used to think it was about "writing Go" or "coding" when in reality it's about utilizing your language of choice to solve a problem to make your life easier while enjoying it. Just my 2 cents.
Also working on a JavaScript project and can definitely confirm. Recently switched to Yarn but it's only an incremental improvement. Filler packages like `npm-run-all` and `rimraf` help a lot, and for more complicated things we've wound up with a `scripts` directory full of little 50-100 line implementations of whatever it needs to do. But almost anything's better than Gradle.
RAII also doesn't really have anything to do with reference counting or garbage collection either.
The LISP 1.5 manual is a great example of concise tech writing, too. https://www.amazon.com/LISP-Programmers-Manual-Michael-Levin/dp/0262130114
Go isn't the primary language at Google btw.
It's not necessarily Ruby's fault, per say, since I think most Ruby devs come from Rails, the way they learn to develop Ruby is with "magic included". Ruby though allows for almost limitless flexibility, and there for limitless confusion. Java could have many of those same problems, but magical Java systems are considered secondary, to Rails considered primary, if that makes sense. Java by default falls back to GoF patterns at the de-facto practice, which helps a lot. Go, with Go Format, and being a smaller scoped procedural langauge, takes the structure farther and improves on the idea that there is a "right" way to write the code. This method contrasts with Ruby's "you can do anything 100 ways!" Its not that Ruby cant be readable and scalable...it's just that not how the ecosystem evolved, and the language allows for a higher deviation from the norm than most other languages do.
I distinctly remember a time where there were large, drawn out arguments between C and C++ developers. I mean, it still happens today, but it happened well before 2005 also.
Nothing wrong with it. I just find myself wondering why so many webdevelopers use it when they could just write their own web blog.
&gt; RAII also doesn't really have anything to do with reference counting or garbage collection either. You can do RAII in a GC language, it's just not recommended because there's no guarantee that any particular object will ever e cleaned up, unlike in languages like C++ or Rust, which clean up object as soon as it goes out of scope (and requires Rc or raw new/delete to clean up).
Back in the day, C was considered a “higher level language” because “low level” referred to different flavours of assembly. Now that applications become more and more based on networked services exchanging API calls, backend code that compiles to honest-to-good machine code is relatively “low level”, even if it doesn’t expose as much of the memory layout as C does.
https://mobile.twitter.com/davecheney/status/346969421539074049 If you feel like using a sledgehammer (it replaces the finalizer on the fd with a panic iirc)
1) it isnt about me improving the benchmark game; it is about how you used that as a good comparator between language speeds 2) if I were to contribute back, it wouldnt be a simple as just improving. I would need to do the research on the problem space and ensure I implemented them correctly. No test vectors makes me not want to do it.
from day 1 
Well ... duh? The whole point of JIT compilation is understanding the runtime behavior of your app (while being interpreted) to use make optimizations based on info not available at compile time. 
lol... ^ this guy
Netflix has used Java since launch, but has recently announced that they're porting half of their API to Node after using it heavily in new projects. 
What problems have you encountered using OpenGL in go?
Usually, when there is an error, the response will be nil and an error will be returned. But, when you get a redirection error, response will not be nil but there’ll be an error. From the documentation : " *On error, any Response can be ignored. A non-nil Response with a non-nil error only occurs when CheckRedirect fails, and even then the returned Response.Body is already closed.* " Is your case a redirect one?
It was originally called Nimrod. But in these PC times Nimrod sounds awful so Nim it is now.
Exactly! I know I need to somehow design this interface, but then I just couldn't figure out how. Yeah more examples would be helpful!
Just logged the actual response, not a redirect. We get real payload back.
It may be unfortunate, but JavaScript is certainly available outside of the browser. I just spent a week working on a nodejs graphql api.
Is it better is you do this: defer resp.Body.Close() ?
I believe they both do the same thing.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://en.wikipedia.org/wiki/MUD) - Previous text "MUD" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
My hunch is that most people would find the gentler approach with Python or a similar language to be an easier way to get started. My first language was C++ and it drove me crazy. 
Ruby, Python are still pretty cool by most standards. Javascript is the #1 language by most usage metrics. C is still the #1 language for anything low-level. Haskell is still really cool by my book. In fact, save for Go, Swift and Kotlin, I can't think of a single cool, mainstream language released after 2005.
Ok so update. I took this in a ifferent direction a bit. I am going to create a cli tool that uses a menu system to complete tasks. Like option 1 is grab data from this db, option 2 would be like generate report from these files. In my line of work there's a lot of repeatability. And not a lot of time to do it all. Do this will help me immensely. So thanks for the inspiration :) 
And a non-interpreted language just requires you to know the performance penalties for doing things in different ways. You basically are the JIT. Sure, not as easy in some cases, but good JIT usage requires you to know how to write code that can get as much benefit as possible I guess my argument is that native code languages can perform better without having access to a JIT. Requires a bit more effort from the programmer, but a lot of the time you can hand craft code thats more efficient than the JIT code, and it won't have the warm-up performance hit that a JIT does. JIT at best magically makes your otherwise slow code faster, but not as fast as a native language that has been hand optimized. I basically don't see JIT as a point against go, or for Java. It's just a way to keep Java semi-relevant
A simple Fibonacci of a big N number as a benchmark can tell you otherwise. Java is faster than go not in some niche cases. 
Having developed Laravel apps for many years this sure feels more like home. The empty return statements on error always felt strange. Is there any downside to this except that your handlers are no longer standard handleFuncs?
And now all of these have memory leaks!
Except you make it verbose yourself by handling every single error possible and printing a stack trace yourself, haha
&gt; Indentation is Nim's way of grouping statements. Indentation is done with spaces only, tabulators are not allowed. There it goes! My last care flew away!
The performance characteristics of Java are hard to reason about. That’s arguably a bigger hurdle in many fields than the average performance which is quite good. 
they are actually standard handler functions. think of what this guy recommends as a \`Factory\`; It encapsulates and abstracts the creation of the handler.
Sun IMHO the one of the coolest companies ever run by engineers. If anything that was their biggest problem.
quite interesting. &amp;#x200B; What I'm worried about is that you're creating a closure for every request that comes in. That means an additional allocation and function call on every request. Although it's probably not the end of the world.
You defer closing of the body until the function returns. Does your function maybe not return? I can imagine doing the request in main or in some forever loop.
Got it! Although that can be applied for everything 😅 normally people avoid to try to reinvent the wheel
[removed]
I hope to God that go doesn't turn into Java, mostly because I hope nothing turns into another Java. We're so close to universal recognition of the fact that there will never be a good "general purpose" programming language
I understand. Were you self-taught?
From Zerolog: &lt;snip&gt; To keep the code base and the API simple, zerolog focuses on efficient structured logging only. Pretty logging on the console is made possible using the provided (but inefficient) zerolog.ConsoleWriter. &lt;/snip&gt; Zerolog is designed to log to JSON, and has an inefficient console writer for completion. This focuses on console logging instead, in an efficient way.
&gt; How do your write (a + b/2) * c^2 in go, when a and b are bignums and c is a regular integer Wait, hold on, you can't do that in any typed language anyway. It's mostly dynamic languages that let you do that because they do the automatic conversion, which I would argue is not good. &gt; Oh, btw, when I do x := y.Mul(z), does it modify the value of y I think most sane libraries don't modify values with functions like that, except maybe for performance reasons in which case I don't think it's unreasonable to expect the programmer to read the documentation before/while programming. &gt; How is proving software correctness not relevant to software engineering? In the years that I've worked in this industry, I've never seen anyone bother with proving software correctness. &gt; Hmm, lots and lots are made in C++, and heck, even Java is used in (way too) many embedded devices. Are you making the claim there are embedded systems with such little memory that they can't support Go but are able to run Java? 
And no ~~fearless~~ concurrency!
&gt; Wait, hold on, you can't do that in any typed language anyway I'm 99% sure Haskell and Ada can do it, too. &gt; Are you making the claim there are embedded systems with such little memory that they can't support Go but are able to run Java? Yeah, I know it doesn't make sense, but there are several communities that strive to make Java versions that fit in very constrained environments. Including Oracle's (which is not that small, AFAIK). After all, java was initially designed to be a language for embedded platforms, before the applet craze made it a language for the web. Go could certainly do the same (and be even better) if there was a significant effort toward it, but it's not really the case, AFAIK, so, if today I was forced to develop on an embedded platform and forced to choose either java or go, I'd certainly choose java, even if it breaks my heart to say so.
&gt; I'm 99% sure Haskell and Ada can do it, too. Well, this is then 1% of the time that you are wrong because you have to do `(a + b `quot` 2) * (fromIntegral c)^2` in Haskell. &gt; Go could certainly do the same (and be even better) if there was a significant effort toward it, but it's not really the case, AFAIK, so, if today I was forced to develop on an embedded platform and forced to choose either java or go, I'd certainly choose java, even if it breaks my heart to say so. Okay.
Yes it helps. It's very useful information, thank you. And these are two ways (as I see now): * Use a separate package to store structs used across multiple packages (others saying it me too) * Use structs that are convertable to each other across packages using that data structure The deal now is to decide how to do, if I'm right.
Huh? https://www.techempower.com/benchmarks/#section=data-r16&amp;hw=ph&amp;test=json In every test Java &gt; Go. Except in....... plaintext, where Java is within 0.2%. What gave you the idea that Go is fast?
Basically, you can: 1. Define your own type based on an existing one: `type myCustomType string` 2. Define a custom marshalling/unmarshalling function for your type Here is a concrete example with base64: https://play.golang.org/p/B01Uy5wBUps 
First I'd do it in terminal, asynchronously update parts of view etc
Those are nerd cool, not hipster programming in a coffee shop on the latest hip app cool. 
But Graal's ecosystem is very immature at this point. It might work for Java but..only on *nix atm. And it has a lot of issues and untested scenarios. It might be ready in 5 years but...who knows.
I plan on using Mage to build an ecosystem for Kubernetes and cloud VMs CI/CD. Anyone wants to help?
I had a chat with one of the core Graal developers, they are planning a stable release this year.
Still it's not there yet. The native extensions is one of the biggest obstacles. They aim for common performance across the landscape and we might end up with superfast Ruby.
Tcl is highly used?
This is really cool, my favorite feature is I can list the tasks. Such a simple feature but when you're coming to a new project it's nice just to list what you can do.
Unfortunately, whether something is widely used doesn't say anything about whether it's good or not.
What kind of an argument is this in a discussion about speed potential of languages? 
Better put things that are strongly coupled together in the same package (concrete struct representation is a strong coupling). Put things together that change for the same reason. Else consider clarifying domains and decouple with interfaces. Depend on abstractions not concretions. 
Yes, but I majored on mathematics in college. As odd as it sounds, I didn't do any programming in school but I took a few programming classes afterwards, up to Data Structures. Otherwise, I've learned how to code on the job in a variety of technical roles, I'm currently working as an SRE and I'm very much a Jack of All Trades. That being said, it does bother me personally that I haven't taken an operating systems class and other higher level CS classes. I have this dream of really learning x86 assembly and working through classic texts like Knuth's books, SICP, TCP/IP Illustrated etc but I'm super busy. I work full time with occasional side gigs + I have a family. With all that being said, the purists will argue that you're at a disadvantage if you've never learned CS theory and fundamentals and I'd certainly agree yet that doesn't mean you're destined to fail in the tech world. As much as it offends some people, you can be a self-taught Javascript dev and pretty much build an empire these days. Similarly, you can be self-made in any discipline. Successful entrepreneurs don't all go to business school, for example. 
If you want to claim your language is faster, you will need to create optimum implementations to compare against others. You can't just claim it in a vacuum. &amp;#x200B; &amp;#x200B;
You can overload the operators by defining your own typeclass hierarchy in Haskell, which gets rid of the conversions, so no they're not wrong.
I remember the distinctive thought, but I don't recall specifically anymore--but I was reading RFCs about JWT , docs on OIDC, and studying implementations of token validation around that time, so I suspect it was something in there that I felt I probably understood more quickly because I had been playing with tokenizers.
like so https://github.com/mcandre/flcl
&gt; The client was my first attempt with React, got real messy real fast. I made this same ~~mistake~~ choice with [wpdir](https://github.com/wpdirectory/wpdir). There is a lot more to front-end JS based websites than it appears at first glance and it feels like while I got to grips with the basics there is a world of potential for improved UI/UX which lies just out of reach. *To OP: Find a problem and solve it, there are problems all around us if we stop to look.*
A tip I heard is "accept interfaces and return structs"
All you have contributed to the discussion is [innuendo](https://dictionary.cambridge.org/us/dictionary/english/innuendo). You haven't told us anything about the the Go programs shown. (You could have written your comment without ever having looked at that website).
(a) Okay, so how do you handle cases like `a * b` where `a :: Int` and `b :: Integer` like sacado wanted? Do you let it error out with an overflow? That seems like intuitive behavior to you? (b) You still can't do `(/)`, so I assume you also suggest redefining the Floating typeclass. Would it also have a type like `a -&gt; b -&gt; a`, which still runs into the issue above? (c) I don't see a Rust implementation for bignum and a regular integer like sacado wanted. Maybe you can point me to a definition? (d) So, in order to get "readable" Haskell like the kind that sacado was proposing (with potentially counterintuitive behavior), I have to swap out my standard Prelude and find one of many alternative, non-standard Preludes to match my arbitrary tastes in what readable code should look like. Seems a bit ass-backwards to me especially considering that the claim was "Haskell supports this".
If my understanding of the chronology is correct, the time that Sun was "run by engineers" predates Java entirely. When Java came out I was just a college student, but even then it was pretty obvious to me that there was a whiff of desperation in Sun's promoting of Java, because they were getting very visibly squeezed out of the market. Java was a Hail Mary for them, which was caught on the 15 yard line but the guy bobbled it on the 5 and lost the game.
Rust
Sure, NO cert can prove that one is a good programmer. But, the EMPLOYERS don't understand that?! &amp;#x200B;
First of all, let me preface this by saying that I do not think that implicit conversions are a good idea, at least the way sacado suggests them. However, they are _possible_. &gt; (a) [..] In my earlier comment, I said "or a more complex version of this". If you _really_ want `(*)` to be commutative (Rust's is not), then define it like so {-# LANGUAGE TypeFamilies, MultiParamTypeClasses #-} import Data.Kind (Type) type family MultiplyResult (a :: Type) (b :: Type) :: Type type instance MultiplyResult Int Integer = Integer type instance MultiplyResult Integer Int = Integer class Multiply a b where (*) :: a -&gt; b -&gt; MultiplyResult a b &gt; (b) [..] `(/)` can have a similar signature as above. If you want, you can add super-class constraints like `Multiply a b =&gt; Divide a b` or similar but no one is forcing you to. &gt; (c) [..] I did not suggest that such an implementation exists, I was merely borrowing the type signature. As you can see, it doesn't give a commutative function. Rust doesn't have type families so you can't reproduce the above solution in Rust. &gt; So, in order to get "readable" Haskell like the kind that sacado was proposing (with potentially counterintuitive behavior), I have to swap out my standard Prelude and find one of many alternative, non-standard Preludes to match my arbitrary tastes in what readable code should look like. Yes. Or write your own, based off an existing [one](https://guide.aelve.com/haskell/alternative-preludes-zr69k1hc). As crazy as this sounds, it isn't so uncommon because for large projects, there will often be some common things which are used by a lot of modules, but aren't exported by the default Prelude. So you create your own "Prelude add-on" and import that everywhere, instead of repeating a dozen imports everywhere. It is about cost-to-benefit ratio more than anything else. &gt; Seems a bit ass-backwards to me especially considering that the claim was "Haskell supports this". sacado's comment can be interpreted in two ways -- is it possible or is it easy? I have taken the former interpretation and you have taken the latter. This seems to be the primary source of disagreement between us. I think both are reasonable readings (of course, you may disagree).
Java was a complete rethinking of how programming is done and the concept of being able to write something once and run it "in most places" (Java has NEVER been run anywhere), particularly for desktop applications, was something worth committing to in the late 90s. Still, it's important to realize when thinking about Java that it was designed in a world where the most valuable application was on the desktop. It came to replace C++ and Delphi. In large part, the language has been retrofitted into uses that it was never designed to be used for. I think that aspect of it has driven it into some of the most complicated "Default abstractions" that exist in the market today, and is one reason that, despite its flaws, the .NET ecosystem has become an easier to grok form of the same design patterns as Java.
LOL, love that one.
That cost is often high explicitly because those stacks are not well maintained. 
He said cool. :)
Is this something you could use the [fewstera.github.io](https://fewstera.github.io) to host, or does it need to have the server running in the background? (I haven't done any WebAssembly, so forgive the ignorance.)
Awesome! Yeah I wanna this weekend some how make each class selector it's own type and some how make an ajax type that gets all the methods of $ajax.Get(). Because this would be so useful when building services that accept data. I mean you would be able to use the same service struct on your backend to consume the service on the frontend. Plus, you can start like how you reuse class names on the frontend to build reusable selector types as well.
&gt; pretty vacuous generalization lol, no generics
Thanks! I have not try that.
Quite familiar with performance optimization. Also aware that processors are built to perform well with code that is well suited to problem space. :-)
How do you handle security in an app like this? What prevents somebody running Go code that escapes the Docker sandbox via some zero-day exploit, or finding a way to run the server out of memory and impact its performance?
I have been using it for a long time already (since it was published). My only pet peeve at the moment is VSCode highlighting `// +build mage` and complaining that `function main is undeclared in main package`. But it is not annoying enough that I would bother trying to fix that.
I still don't know what makes languages 'cool' to be honest. I'm a student studying applied computer science, and I just can't get to like any of the supposed 'cool' languages. On the other hand, I never considered Go to be boring. On the contrary, I find Go extremely exciting - just as I find C/C++ exciting. I think way too much people are focusing too much on the process of making a piece of software rather than on the quality of the software itself, which might be a reason to why stuff like Electron is so popular right now - but that's just a guess, as I mentioned I don't have a lot of experience. Imo, Go hits that sweet spot of not being too tedious to write while delivering a very performant product in the end, which makes the language exciting - at least for me.
Yes it is fine to learn Go. Many people go their whole lives never learning OOP or design patterns. Go may be a good ecosystem in that you can learn that programming isn't really about those things anyway. &amp;#x200B; Programming is programming. it doesn't matter much what language you start with. Go is a fine one, it may be better than most because the language spec is simple and you don't get distracted by lots of weird language features. &amp;#x200B; &amp;#x200B;
Thank you for advice. Probably not sleeping this weekend now.
I posted it as a meme but the comments... They got serious...
&gt; Wait, hold on, you can't do that in any typed language anyway. You can do it in Scala. I think you can do it in Kotlin.
You can fix that by setting "go.buildOnSave": "off" I usually turn off go build on save because it seems to make my CPU go crazy and doesn't provide that much actual benefit. I want to build much less often than I want to save. Alternatively, you can run mage -keep and keep around the generated file (which has a main function).
Thank you sir
Yes, Go is quite simple and has many tools. Go has batteries included and it's perfect for devops and web development.
Would recomend Todd McLeod also. Great course.
Turning off build on save helped. Thank you.
[removed]
Oh man, I totally forgot make doesn't even have the capability to print out the targets. 
Sure, but you can go take a look for yourself and see. Anyways, the code in question was complement, if I remember correctly, and they were allocating a byte slice every iteration which has a heavy cost. That alone made me suspicious of the code. Also setting max procs is pointless in their code and potentially could hurt performance. They should let the scheduler figure that out. Mind you that only took about 10s of my time to see which I figured a user of Go would be able to find. And as for Java users, explanation would be required, but they may not understand which would then require more explanation which is far more work than I am willing to sign up for. If you really care about the efficiency of languages one should research the benchmarks being looked at and not take them at face value. Also, shifting the burden of proof onto me is ridiculous. We all know the burden of proof resides in the person who thinks they are right, and switches once an argument is made. Meaning do the research yourselves. Become a better engineer because of it. Im not here to hold your guys’ hand.
Argumentum ad populace :/
Yup, good point! This is definitely not meant to be the "end all be all" pattern; more like another tool to add to the toolbelt. 
It's not a great for every use-case. I've been documenting some reasons why you probably don't want to use this pattern in my ([readme](https://github.com/zpatrick/handler/blob/master/README.md#when-to-not-use-the-handler-constructor-pattern)). So far I have: \* Small size/scope of project \* Streaming \* Frequently needing access to \`w http.ResponseWriter\`
Do it! You can’t get to great without learning new things, and learning new languages gives you a wide breadth of experience. Your first programs will be simple, and anything non-trivial will be horrid, but you will improve. It’s a wonderful journey. Read everything you can about it and you will do just fine with Go. Learning is a lifetime thing, don’t be afraid of the first misstep; it’s just how you get better. And f¥ck php. 
I appreciate the work you put into this response! &gt;but it's the wrong default for a low-level library. Hit the nail right on the head there. That's basically the gist of what I was trying to say with "I think it's because it is necessary to make handlers great building blocks" (I like the way you put it better). I hope this post didn't come across as "You should use always use this pattern"; my intention was more "Here's another tool for your tool belt"
Interesting, I hadn't heard of currying until now. Thanks!
how does one go about it? like how does one display a progress bar or interactive stuff on CLI with go?
Thanks for the extensive response. That was very insightful.
I'm not too familiar with intricate details of Scala. Is it accomplished through subtyping or what?
How do you like that book? Worth a buy?
You could use subtyping. Implicit conversion works out of the box with \`Int\` and \`BigInt\`. So you're wrong.
It used to be. In the 90s, practically _all_ X11 programs were written in tcl/tk.
There are another best practices to follow like: * Prototype your design. (Prototyping rises design questions we didn’t even know we should be asking.) * There's no need to lock yourself into early decisions. * Define interfaces where you use them. * First-class functions. (Anonymous functions and closures.) * Accept interfaces, return concrete types. * Use short names for variables those are a concrete type for a context. * Don't code for future use 'cause when it will be necessary things may change crucially and you will need to code much more.
Wow this is is pretty neat. It's a weird coincidence that I built something similar yesterday that runs entirely in the browser with WebAssembly instead of requiring a server. https://gopry.rice.sh/
Wow this is is pretty neat! It's a weird coincidence that I built something similar yesterday that runs entirely in the browser with WebAssembly instead of requiring a server. https://gopry.rice.sh/
add to previous answer: if HTTP gateway for gRPC is ok for you then you can take a loot at my tutorial how to use it. [https://medium.com/@amsokol.com/tutorial-how-to-develop-go-grpc-microservice-with-http-rest-endpoint-middleware-kubernetes-af1fff81aeb2](https://medium.com/@amsokol.com/tutorial-how-to-develop-go-grpc-microservice-with-http-rest-endpoint-middleware-kubernetes-af1fff81aeb2)
That's one giant interface: https://go-review.googlesource.com/c/tools/+/136676/1/internal/lsp/protocol/server.go
you mean websites?
Naw, I mean database front ends. That's mostly what I saw VB used for -- click and drag an interface together, attach some buttons to SQL queries, voila.
Wouldn’t it be better to split it into many different interfaces?
1. Latest version of Go has built in vendoring of dependencies. There are tools to do this, including dep [https://github.com/golang/dep](dep) which is maintained by the Go Team. 2. This one I don't know the answer to, but I imagine one of the tools out there can be. 3. I started with the tour on the Go website and also https://gobyexample.com/. Bonus: I've not use the GoLand IDE, but you might also checkout GitHub's Atom editor. The support for Go is pretty good imho. 
&gt; Go may be a good ecosystem in that you can learn that programming isn't really about those things anyway. Wut? Go is all about "those things." It was explicitly made to force developers (especially new ones) to use what is considered good design patterns. That is the reason why the interfaces are implemented the way it is, and why inheritance is just another way for composition in go.
was jk. i gotcha
Ah, right, because it's been replaced with some Php or asp crap in a lot of cases now :-D
Re 2nd. Latest Goland has `dep` integration out of the box. Although `dep` is recommended tool for managing dependencies for now, starting from go 1.11 has `go modules` support as an experiment. It is going to be the default tool to manage dependencies in future. But `dep` is a good start point.
Never used Atom. I love my VSCode. Dunno why anyone would money on GoLand, when there are so many great free options out there.
Try adding a line like `module "bitbucket.org/saeedgnu/test"` to the top of your go.mod file. From https://github.com/golang/go/issues/25176#issuecomment-385353243
dep is not maintained by the Go team. Go modules is the built-in way for managing dependencies.
i've been used JetBrains IDEs for many years, and i'm very happy with it. For some quick fixes i use sublime text, but Atom and VSCode are still ok.
:D
Gosh darn. I thought 'How big could it be?'. Oh.
Never 'switch' languages. Learn new ones and add them to your toolbox. Python is much better than Go at a lot of things and vice versa. There is no reason to forgo a single tool for another one. What's bigger, learn where go and python both shine and use them appropriately. Aside: never market yourself as a &lt;language&gt; developer. The concepts will translate from language and are more important that syntax. 
Thank you for the feedback, I didn't think of Marshalling as well to support going in and out but it makes sense 
### Is there anything like `virtualenv` and `pip`, to make an environments and manage dependencies per-project, not globally? Go 1.11, the latest version that came out a couple of weeks ago, introduced a module system for dealing with versioning. For a quick overview, a module can contain multiple packages, each in their own directories including the top-level one, and is denoted by the existence of a `go.mod` file containing at a minumum module the/import/path/of/the/module in the top-level directory of the module. You can create a `go.mod` in the current directory by running `go mod init`. If you're in a git repo it will try to take the import path from the remotes automatically, or you can specify one manually by passing it to that command. Once you're in a module, you can add dependencies either by simply importing them in your code, in which case the next run of almost any `go` subcommand, such as `go build` or `go run`, will automatically add the latest version of that dependency, or by running `go get import/path/of/module@version`. You may also want to run the occasional `go mod tidy -v`, which will clean up the `go.sum` file and remove any unused dependencies from `go.mod`. I don't think there's really an equivalent of `virtualenv`, but I'd be surprised if you need it. The Go toolchain caches dependencies transparently and will automatically recompile them if the environment changes enough to warrent it, such as if the version of Go, `GOOS`, or `GOARCH`. changed. You can installing specific Go versions using something like `go get golang.org/dl/go1.10` to install Go 1.10, for example, and then you can use `go1.10` in place of the `go` command to use that specific version, but you shouldn't need to very often since Go is backwards compatible back to Go 1.0 for basically everything except for extreme cases. Code written for Go 1.11 might not work with Go 1.0, but code written for Go 1.0 should work with Go 1.11 99.9% of the time. ### If yes, can they be integrated with GoLand IDE? I'm not sure; I use Vim. I would be surprised if it doesn't get support pretty soon if it doesn't have it already, though. ### Can you recommend some good book/course, except `godoc.org`? I haven't read any Go books, but I've heard that [The Go Programming Language](https://www.gopl.io) is supposed to be a pretty good introduction to the basics. It'll probably missing support for newer features though, such as the above mentioned modules and the `context` package. It may have `golang.org/x/context`, though, which is pretty much the same thing for the most part, except for the lack of support for it elsewhere in the standard library. In terms of tutorials, though, I'd probably recommend [the Go Tour](https://tour.golang.org). It covers the basics pretty well.
Join the Gophers Slack group [1] there's a #jobs channel there with lot of companies from Europe. There's also this Wiki in the Go repository on GitHub with a list of companies per country [2]. [1] https://invite.slack.golangbridge.org [2] https://github.com/golang/go/wiki/GoUsers
https://groups.google.com/forum/#!forum/golang-tools
Thanks a lot! And one more question about dependencies - if will need some dependency i found on github for example, i need to pull / download it to my project folder and just run module /path/to/my/cloned/dependency ?
The problem with this approach has very probable implicit memory allocation. Allocations are generally very bad idea on line-by-line file reading.
Thank you!
You missed the last part of my post... &gt; Got to run the numbers in every case. Can't make a generalization here.
This is slightly off topic, but are you just checking for a 16 digit number? I feel like that could result in a lot of false positives. Maybe incorporate a Luhn check as well somewhere along the lines (in a goroutine or something?).
&gt;Coming from a C# background, I originally surprised how Go's http.Handler methods looked. You are comparing [ASP.Net](https://Asp.Net) controllers with Go handlers, but the equivalent of a Go handler is an [OWIN middleware](http://benfoster.io/blog/how-to-write-owin-middleware-in-5-different-steps). They are ***exactly*** like Go handlers: you have access to both the request and the response. &amp;#x200B;
Okay, Thank you!
It was actually pretty easy to do. I mostly just followed the Go documentation on it. https://github.com/golang/go/wiki/WebAssembly https://godoc.org/syscall/js To actually build the WASM bundle it just takes two lines. ```go go-pry -generate="main.go" -i="fmt,log,math" -e='log.Println("Hello world!")' GOOS=js GOARCH=wasm go build -v -ldflags "-s -w" -o main.wasm main.go ``` There were a bunch of small "polyfill" type things reworked in go-pry to not rely on the filesystem for certain parts. For instance, if we're building for JS, history now is saved into localStorage and we read files via fetch. https://github.com/d4l3k/go-pry/blob/master/pry/io_js.go If you have any other questions, let me know! I'm currently working on setting this up into an automated service so you can specify any packages and it'll build the bundle and serve it.
Building a mutex with channels can also be a fun experiment if you are looking to try another approach. You basically just use a buffered channel with a capacity of 1 and use the blocking properties of channels to create a mutex.
I have some ideas on how to generalize this, but I'm a little tied up right now. I'll try to respond to you before the weekend is over. 
&gt; *[In the Java HotSpot VM](https://www.oracle.com/technetwork/java/whitepaper-135217.html), no handles are used by Java code. Object references are implemented as direct pointers. This provides C-speed access to instance variables* 
Awesome! That would be very helpful.
[removed]
I don't think you picked the right fallacy there. " a fallacious argument that concludes that a proposition must be true because many or most people believe it, " &amp;#x200B; A claim was made without evidence, that Go is faster than Java. I turned to some readily available evidence about language speed, the benchmark game. It isn't perfect, no measure of language speed is ever is. But if you want to make claims about language speed, bring some evidence. So far I'm the only one who has brought anyway. Rather than nitpicking about that evidence, bring your own. Part of what makes a language fast is the community and how much they are about it. This is part of the reason Rust and C and C++ do well, they make fast implementations of the benchmark rather than whine about them. Its good language PR and good for exposing weaknesses in the language or standard libraries. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
It is probably close to a tautology to say that any given languages design was done to force developers to use what is considered by the language designers to be good design patterns. A lot of the classic "gang of four" design patterns are artifacts of Java's limitations and aren't necessary in Go. 
is vgo and go modules the same thing?
It's using WebAssembly which is pretty new which might be causing problems. It runs quite well under Firefox. Chrome takes a little bit to load.
Wow, that is exciting, I wonder what this means for [https://github.com/sourcegraph/go-langserver](https://github.com/sourcegraph/go-langserver)?
It’s pretty sweet! 
That's correct! vgo was what the prototype was called before it was officially merged into the `go` tool. Now it's called go modules.
WebAssembly is disabled in iOS 11. That may be the cause. Its working under iOS 12 though.
Golang: Rules and best practices apply, except for when they don't.
vgo history will be repeated.
I wasn't trying to say you were wrong, I was just emphasizing that it is often the case that legacy stacks aren't well maintained. That makes it more promising to migrate to something that would be considered "more efficient".
Just read 64k at a time and run the regex on the entire block. The only thing to keep in mind is that you'd want to ensure you have overlapping bytes so that if a number happens to be split on a 64k boundary you still find it. This is pretty easy to do though. just need to * make a 64k+32 byte buffer * read the first 64k into it * attempt match * copy the last 32 bytes to the beginning * read the next 64k into the buffer[32:] * attempt match or just mmap the file, but that approach won't help to search compressed files. 
Those poor souls. I tried messing with Tcl/Tk when I was in high school. Hated it lol. But then again, I was kinda dumb back then. 
I was intending to present information about the existing go-langserver project to my local Go user group. I'm excited for this proposal, but I'm curious -- what would the typical timeline be for adding this in?
I ended up writing [my own logger](https://github.com/lpar/blammo) modeled on ZeroLog's API but aimed at plain text console logging.
Do you know if it improves on the source graph version? Or are we just trading one implementation for another?
Why they again discard effort of community?
Whole heartedly agree with your rails dev explanation. I call it rails-itis. Java does seem to have convention to it that I'm unaware of simply because I'm not that versed in it anymore so it kind of feels that way. But your statement about the "magical" pieces being considered secondary tells me that there's a middle ground if I understand correctly? If so, I wish people would understand you don't have to include everything in Rails lol. 
They commented in the link &gt; Chiming in here on behalf of Sourcegraph. We are 10,000% supportive of this, as we've discussed openly in the golang-tools group and with the Go team.
You posted on go sub so I think you know what answer you are going to get. I would suggest instead of choosing what language to learn. Look at what you want to do. If you want to build mobile apps, learn Java or Swift. If you want to build web, learn Go and JS, if you want to do machine learning, perhaps Python is a good starting point. If you want to do IoT or embedded, learn C++ and C. The choice of language is largely depending on what you want to build. As far as learning is concerned, doesn't matter what language you end up learning. What you ultimately will learn is how computer works, how data is stored in various medium, how your code becomes instruction for the CPU to work with said data. Once you are familiar with this, learning another language is a breeze comparatively. Go is a good language, I like it. It has very short language spec, very easy to learn, generally a joy to write.
Thanks, I didn't read that comment until you pointed it out. Great to hear!
You're typing words for the sake of typing words, it seems. There's nothing to take away from your posts here.
How does your use case differ from grep or its cousins?
You might not get downvoted so much if you could specify what, exactly, they "discarded"?
Seems folks have given you the complicated answer to 1) The simple answer is: you can install golang as many places as you like on your server, and each will comprise its own "environment". Just set `GOROOT` accordingly. 2) yes, but this is not your personal JetBrains support channel. 3) [This book is money.](https://www.gopl.io/) Even for existing golang devs.
I did his udemy course. Is greater commons better?
You could probably work with gorilla/mux's variables and reflect. The way I'd do it is defining a single HandlerFunc which then gets the variables from the route and then calls the corresponding Handler via reflect or returns a 404 if no route matches.
It is a bit updated from the udemy course. Todd also founded Greater Commons, so purchasing the course there helps him more than on udemy. His second course there on Go Web development is great too!
We develop telco/messaging software in Going for 4 years with dev team in Serbia. If you are interested, pm
Yeah you'll learn a lot deeper concepts learning go. Also really good practices. It forces you to do things but those things are universal with doing things correctly. I currently work in php and do frontend and it's helped me tremendously in many levels. Please learn both. I always pass my links around. https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk
If you want to go down that path... https://golang.org/pkg/regexp/#Regexp.FindReaderIndex https://golang.org/pkg/regexp/#Regexp.FindReaderSubmatchIndex https://golang.org/pkg/regexp/#Regexp.MatchReader Just write a io.RuneReader wrapper around io.Reader, it's very simple and only requires a bit of interfacing with whatever encoding you're using, if it's USASCII then each rune is a single byte, otherwise just use [unicode/utf8 DecodeRune](https://golang.org/pkg/unicode/utf8/#DecodeRune). This next bit does not apply to you, but be warned that the Go regexp impl will greedily read a few more chars than it needs so if you're doing this on a network socket (which you're not) then the code will block when conceptually it should not.
As Pope of all learning, I grant you absolution to learn Go. You are forgiven. Wait, why are you asking for permission?
Virtualenv is just GOPATH with worse implementation and better PR. It lets you choose which set of packages to use in your builds, which is the same as GOPATH or in 1.11, a mod file cache. 
I am looking... but here is some system code in Moby: https://github.com/moby/moby/tree/master/pkg/system
As xombul said, memory/cpu is capped Kernel exploits are rather difficult, but they are still possible. This may be mitigated by running this on a separate machine from other services. In addition, I may eventually switch to or support alternate containerization systems which are based off of syscall interception (e.g. gVisor).
more of this
it crashes even a XS Max. There is something wrong with that webpage. I've used and written plenty of WASM websites before.
io.LimitedReader can help with read-ahead, if you can call your length in advance. Whenever I control the protocol I try to ensure I always can, for that reason.
@u/jakewins we have this exact same issue. With Go 1.11 and vgo integrated into main tools now with new module/versioning system I'm wondering if answers to this would change? My understanding is vgo allows u to write code anywhere. We have specific requirements to support a monolithic repo with heterogenous tech stacks, node projects, UI projects, and go projects. We do NOT want any vendor/3rd party libs in our repo, so GOPATH is $HOME/go and go-get installs vendor libs there, but our repo is a separate path outside GOPATH. We want to "install" or reference certain modules and projects with other ones. So we may have 2 projects that need to share common code for db/logging/structs/models so we have a 3rd project folder in our repo called go\_common and it has a go.mod that declares its module [companyabc.com/go\_common](https://companyabc.com/go_common) module, but can't see to use that in other projects or reference it. I tried go install and it puts a binary in GOPATH/bin, but the src and pkg have nothing int hem from install command. Can someone explain how to set this up?
I don't think it's Rails that's a problem. Rails source is rather easy to follow from the chunks I've read. It's very consistent and fairly clean and easy to follow. The problem I think lies in the community, developers, and ecosystem as a whole. As a Rails developer full time at the moment, I find it frustrating that every time someone comes across a problem, the first response is to find a Gem, then the typical Stack Overflow/Google search, then the I'll just hack it implementation to get it done and move on to the next problem. And to think this is coming from so called "Senior" level "Rails" developers. 
https://github.com/kubernetes/kubernetes/tree/master/cmd/kube-proxy
Wow! That must have been the project he alluded to in his first go course. Thanks!
Makes sense. A job that requires a specific language is prolly a maintenance job, or a job consisting of a CTO/PM that only has experience in the language. Since most apps are not written in Go and most CTO/PMs learned programming before Go came out, this is the obvious result.
thanks!
I'm glad you're sinking to your perception of me then.
thank you
[removed]
This is a good question. What I'm looking for is essentially a grep with Go which doesn't read whole files into memory. I still don't know exactly how grep is implemented, but after some Googling I found a lot of cases where grep exhausts memory. The explanation is usually that grep operates on single lines, so if you have a large file with no line breaks and an implementation of grep that doesn't enforce its own max line length limit, you can run into memory issues. Breaking files up by lines would be one way to limit memory, but if you don't know what files it the application will run against, you can't ensure you won't run into issues.
Thank you for the details. If I can't get `Regexp.FindReaderIndex` to work with multiple matches, per @GravitasFreeZone answer, or that approach ends up being unnecessarily complicated, this will be my next approach. The nice thing about this approach is that I may have multiple patterns that I'm trying to match and I doubt I will put them all into the same regex pattern. This allows me to just run each in turn on the buffer. The `io.RuneReader` approach will most likely require use of `io.TeeReader` or similar to grep in parallel.
Not a go-specific solutions, but: * [Ragel] (http://www.colm.net/open-source/ragel/) is a DSL for FSMs. Docs says that it compiles to c, but, AFAIR, it has an option for go code generation * [Hyperscan](https://github.com/intel/hyperscan) is a regexp engine Both of these solutions allow streaming match, but care should be taken for storing "previous" buffer(s). 
Ragel seems like a great solution if I don't care to support different patterns at runtime. It also doesn't see to be too difficult to get it to work with streams (https://github.com/db47h/ragel). Another bonus is that it would most likely be faster than using plain regex. Thanks for the input!
The community for which you so blatantly speak for has already filled supported this move.
I would say start with basic stuff and do all the things listen in OP when you are ready for them, otherwise the source code of most projects will be mumbo jumbo for you.
Go is still in a niche, not used by big enterprises, heavily used in open-source world. Great language!
I recently put out openings for Go engineers for my startup (we had 4 open positions), and filled them all in about two months. What I discovered (from about 100 applicants, and maybe 15 tech interviews) was: 1) the candidates that reached out loved Go, and really wanted to work with it full-time 2) there were very few opportunities in the market to actually work predominantly with Go 3) the average calibre of candidates (from the tech interviews) was considerably higher than generic "software engineer" posts.
This is the answer.
Go is the latest incarnation of the Python Paradox. http://paulgraham.com/pypar.html
[removed]
Why do you even defer at that point? You already copied the whole response body and can just close it straight away. Also mind using defer in a for-loop might defer for too long because no return might be reached (fast enough)
For which question?
I am finding #2 at the moment, it's weird too as I have seen many many companies whos terrible javascript or python stacks could do with a good bit of Go.
I don't have any code I'm afraid, it was just an idea I had. But why would you want to create a struct by string name? That seems kinda weird. The way I imagined is you'd register all your Handlers to a struct as methods, then you can go about it like this: r := mux.NewRouter() r.HandleFunc("/{function}", UrlHandler) Log.Fatal(http.ListenAndServe(":3000", r)) type Handlers struct{} func (h Handlers) BlablaHandler (w http.ResponseWriter, r *http.Request) { // Do things } func UrlHandler (w http.ResponseWriter, r *http.Request) { vars := mux.Vars(r) func := vars["function"] method := reflect.ValueOf(Handlers).MethodByName(func) method.Call(w,r) } In this case, if you'd call localhost:3000/BlablaHandler, the code would make a call to the corresponding BlablaHandler. Note that I did not handly any errors here, nor did I actually try to compile the code. It's just an idea. I hope you get the gist.
What?
Could you add an example of running a kernel to the top of the package documentation?
for the guys who like a YT link: https://www.youtube.com/watch?v=VQym87o91f8 Is one of the best talks on this IMO.
Thanks for the idea, I've added the wasm file to the repo so that game is now playable here: https://fewstera.github.io/go-wasm-ball-drop-game/index.html
because of the json tags :) from the language spec Two struct types are identical if they have the same sequence of fields, and if corresponding fields have the same names, and identical types, and **identical tags**. Non-exported field names from different packages are always different. 
it's normal behaviour because the behaviour is defined in the spec. your type A is not type identical to the anon struct on Function.. if you added the json tag in the anon struct they'll be the same.
Good read, thank you!
Any recommendations? Bootcamps, courses or just general material? I did sone java years ago while in school and when working with devs at my job trying to pick up on as much as possible to tie it together with what they need on the host side but not coding on a constant basis obviously makes it difficult. 
Yes, will be a pain but wanted to be sure there will be some noticeable gains, which looks like it wont. Heh.
\&gt; i really got hyped about learning it Good, go ahead and learn it already! I would recommend [https://exercism.io/](https://exercism.io/) I'm pretty sure Go programmers on average make more than PHP programmers. Plus, Go is an up-and-coming language that is just beginning to go mainstream. PHP has been around a long time and is being crowded out by all the other languages. \&gt; but lack experience actually using it in real life apps I think most people learning Go are in a similar situation -- Companies are only just beginning to experiment with it, so most people learn at home instead of via their job. \&gt; do you think it is best to learn one language very well before jumping elsewhere Actually, the opposite. Just like when you learn your first (human) foreign language, it's really hard at first. But if you learn a few different languages, you begin to understand the patterns on how languages are constructed. Each language has idioms that will translate into any language. If you only know one language, you are constrained to only thinking one way. (The [Sapir-Whorf Linguistic\_Relativity Hypothesis](https://en.wikipedia.org/wiki/Sapir-Whorf_Linguistic_Relativity_Hypothesis)) \&gt; or do you think that learning new language does not stop one from becoming better programmer? The opposite: Knowing only one language *prevents* you from being a good, well-rounded programmer. If you have never used a functional language, it's hard to see how it works or why it's useful. If you've never written in Lisp, it looks like a bad programming language. If you haven't seen internal DSLs (in say Ruby), you are lacking a powerful tool. If you haven't written assembly, you don't understand how computers work. And so on.
There are still few jobs but to give you a glance of some companies hiring right now 👉 r/https://golang.cafe 
[removed]
nice application, well done! just a few pieces of feedback: - it helps to follow the project structure laid out in https://github.com/golang-standards/project-layout. standards reduce friction! - speaking of reducing friction, providing a Dockerfile and pushing the image to DockerHub will help your users get started with the application more quickly happy hacking!
this. right now it's Ruby on Rails galore
I will tell you what I tell everybody - go through the go tour and then start building on top of that knowledge with diverse projects
Well, thank you, I know it now :)
Yeah, I read the spec not that good, it's my fault...
Go's version of Python os.command
Thanks for the reply. Feedback is alway great. On 2: I do mention in the readme to rename the parent folder of `main.go` to whatever you wish to name your final binary. `cli` was just an example. I would love to see your template for future reference. Thanks again 
`os/exec`
The python lib is probably just a thin wrapper over syscalls. So, an alternative to exec would be to reverse engineer the python by either transcribing source code or, if that's not available, observe the syscalls the python program is making with strace. You'd probably only need to duplicate a few hundred lines. If you do it please put it on github, I'd love to hack messages.android.com to use an eink display!
I think it's `os.system`? Having said that you are right, `subprocess` is the recommended way these days.
Yeah if you have access you can read the python code interacting with the e-ink display to figure out what it's doing. That'd be my preferred method rather than shelling out to python, though admittedly it's the easier and faster solution.
Excellent, this is basically exactly what I need, thanks! /u/RiderOverElephant thanks!
If it works with Python it for sure is a c lib. You can search for it and then interact with it via cgo.
The official list of starting points for learning go is pretty good: [https://github.com/golang/go/wiki/Learn](https://github.com/golang/go/wiki/Learn) One of the listed websites is exercism which has some nice challenges you can try to implement: [https://exercism.io/tracks/go](https://exercism.io/tracks/go)
Hi! would this work with other mail servers? Asking since you wrote it's a XMPP/Jabber client ;)
That's been true for virtually every static analysis tool in Go already.
It should - the lib used under the hood is generic for xmpp/jabber, and nothing was added/removed/changed to fit gmail (besides docs and examples for easier on-boarding) In my personal tests I only focused in gmail - but it will surely work with other XMPP/Jabber providers. I've left one paragraph about this, in the gitlab page - so feel free to try out: &amp;#x200B; &gt;Although this lib was made and tested with a [xxxx@gmail.com](mailto:xxxx@gmail.com) account, it (theoretically) could work with other xmpp/jabber-provider. You could try one of: [https://list.jabber.at/](https://list.jabber.at/) and report success/failure in [https://gitlab.com/zipizap/gmailchatlib](https://gitlab.com/zipizap/gmailchatlib) as an issue, so other people known about it &amp;#x200B; br
Note it will not work with other \*email servers\* But probably with other \*xmpp/jabber servers\* ;)
[removed]
This is _way_ too vague to possibly answer cleanly. What is you're planning on doing with them? Do you have specific categories of projects in mind, such as game development, microservices, or GUI apps? Is this for work or for fun? Programming languages are good at different things, and different languages are already established, and thus have support, in different fields. Asking 'Which language should I learn?' with no context is darn near impossible to answer. I don't even know what kind of experience you have besides the previous attempt at leaning C++, which is also a bit vague.
Made some research and saw it as a kinda necessity in the field of software engineering, so i just decided to brush up on it as per just getting the hank of it, anyways thanks for the brutal sincerity there ... 
So, general concepts are usually languageless, although some languages, such as Haskell, may be odd enough that they basically require relearning at least some stuff. I usually consider learning programming to be a two part endeavor: Learning the low-level of how a computer actually works and learning the general high-level concepts of how programs should be structured and the general ideas of syntax and code. You are correct that Go is becoming significantly more popular in professional programming, but if you learn either C++ or Go you will likely do fine. I _might_ argue that Go, in general, teaches better habits in terms of code structure, but the garbage collector might help you avoid learning good habits about memory management, something that's still important to keep in mind even if you don't have to deal with it manually. There are tradeoffs to both.
Learn as much as you can about all languages. Check out rust too. It’s a great complement to Go. 
Ok thanks alot, But does Go give all the efficiency and raw power that C++ gives the programmer? &amp;#x200B; &amp;#x200B;
Library and Go? What ? 
Go is not as fast as C++ but close, but in any case if you care about efficiency you should go for C or Rust, not C++. C++ is such a bloated language that it is practically impossible to write a compiler without serious bugs, and many language features have performance costs. It is also very easy to write impenetrable code in C++, and some C++ programmers seem to relish showing off their mastery of the language's arcana, as well as a tendency towards architecture astronautics (if not as bad as the Java crowd). Go's simplicity and straightforwardness is a refreshing change from that.
Most of the feats of software engineering are actually in C, not C++. Linux is written in C, Windows in C++. I rest my case :-) Certainly there is a strong job market for C++ programmers. As a garbage-collected language, Go can't compete in certain niches like operating systems or hard real-time, but in my personal (and highly opiniated view) C or Rust are preferable for those applications.
While I get the joke and your intention of making this work, I would say it is not a correct sorting algorithms. Wierd as it seem, the output might not be in correct order - as concurency does not have a guarenteed order, even with different sleep time. The `ch &lt;- n` for 3 might run before the one for 2 even if `sleep(2)` finishes sooner than `sleep(3)` (given you might have other sleeps before and the compiler may choose to run the sleep and then switch to spawn new goroutines for 2 and 3, it is indeed possible for `sleep(3)` finishes before `sleep(2)` ). &amp;#x200B; You can read more about: [https://golang.org/ref/mem](https://golang.org/ref/mem)
For the people that don’t want to give our their email :) http://www.vividcortex.com/hubfs/eBooks/The_Ultimate_Guide_To_Building_Database-Driven_Apps_with_Go.pdf
Personally, I'm partial to Gorm
I’d say don’t overdo it with creating as generic as possible interfaces (which usually leads to using empty interfaces). The behavior of adding to a db and getting from one is generally quite different, ie. The sql function calls are different, the queries are different etc. I don’t get the point of defining separate interfaces only to pass them into empty interface parameters in these wrapper functions. So define each db functionality interface and it’s wrapper functions as uniquely as possible and use empty interfaces as seldom as possible. This will help avoid type assertions and keep code cleaner and better documented. I will say though, as soon as you start implementing interfaces for interacting with the db for diverse types, parameters that would usually be passed in as arguments end up being passed in as struct fields. This really obfuscates what parameters are required for function calls, but it’s almost a necessity for interface methods such as func (struct) InsertDB() error.
I always loved that source
&gt; The first way requires you to coordinate reads and writes. The second way does the coordination for you while still providing the benefits of a mmap under the hood. The reason that, e.g. the [x/exp](https://godoc.org/golang.org/x/exp/mmap) package provides you with a `ReaderAt` is safety. There is no way to provide the user access to the underlying `[]byte` without risking that they keep it around until after the memory becomes unmapped. And at that point, it might be re-mapped with other data (say, Go heap data) and allow unsafe memory accesses. It's not about synchronization (as the package doesn't do that).
Don't think is that complex, but is answer to every question is... depends how flexible/rigid you want. I prefer fun :) [https://play.golang.org/p/k8fCvt5mLDd](https://play.golang.org/p/k8fCvt5mLDd)
sqlx
&gt; Channel, complex, and function values cannot be encoded in JSON. Attempting to encode such a value causes Marshal to return an UnsupportedTypeError. As far as I am aware that is the only case that can trigger marshal to error and this should really never happen if you control the data structures that you want to marshal, as such most of the time it is a programming error in your application and if you have no way of legitimately triggering it I would argue you should panic instead of returning an error so that it is more obvious to the programmer that something is wrong (and have no need for an explicit test case). Naturally if some outside source can trigger it then you can use that as your test case and deal with the error as you currently are. 
I don't see any way that is would be impossible for the call currently to fail. It will always be possible for it to marshal any value of `[]storage.Hero`. Therefore explicit testing it is kind of hard. If you want you could instead have the `Marshaler` be a `func (interface{}) ([]byte, error)`, so you don't need the interface wrapper. For these common injected stuff, I personally prefer to have fallback, so the zero value works. ``` type CommonHandler struct { ... Marshaller func (interface{}) ([]byte, error) } // Marshal will marshal the provided value with the Marshaller defined on ch. // If un-set, json.Marshal will be used. func (ch CommonHandler) Marshal(v interface{}) ([]byte, error { if ch.Marshaller == nil { return json.Marhsal(v) } return ch.Marshaller(v) } ``` btw, the ` SetLogger`, `SetStorage`, etc serves no real function. You already have the fields available on your struct, so you can just set them directly.
&gt; When I was playing around with mmap in Go a few years ago the behavior I was going for was something like "interpret this offset in the mapped object as an n element array of the type x and return me a slice to that array". This package does just that: https://github.com/alecthomas/unsafeslice
I'd just extract the marshal into a function: ``` var marshal = func(hs whateverTypeHsIs ) ([]byte, error){ return json.Marshal(hs) } ``` Then in your test mock this func out: ``` marshal = func(hs whateverTypeHsIs ) ([]byte, error){ return fmt.Errorf("marshal err") }``` Think that's the simplest way in my opinion.
I would not trust in security by obfuscation, but rather assume that some other kind of measures are taken to protect the files (authentication, short validity of urls, ...) You could also use hashed numbers to access the records, my primary intention was to show an alternative to using file content hashes and to not have to deal with changing or duplicate files by connecting the access straight to the db record
Dependency injection (passing objects on to the next level) is my preferred way to go, though I tend to have global logger objects. Injecting dependencies makes each layer easier to test without having to initialize everything from the outside in - if I have a database repository that's several levels down, I can write tests for only the repository and inject a [mocked DB object](https://github.com/DATA-DOG/go-sqlmock) etc so I can test only the repository's functionality without being affected by issues in previous layers. Our logger package is used as a global package, and when running the app is configured to also send to syslog, etc. The downside of that as a global object is that if I want to silence the logger for tests I need to do it for each test package - that comes with the territory with global objects. But since the logger doesn't do anything but log (and only to stdout by default) I usually don't care.
This does come with a "fragile base class" kind of downside - adding something new to inject might require changing a lot of signatures. I've been having a look at [Uber's Fx package](https://github.com/uber-go/fx) to deal with this.
it depends like always, knowing that you'll need to watch out for obvious issues related to thread safety with global pointers.
Yes, life is short. You could always remove Gorm later, when your design is stable.
Definitely learn C++, the world runs C++. Go is the kind of language that, if it weren't supported by google (not that google uses it that much) nobody would have even noticed. Look around the internet and you'll find how Rob Pike (one of it creators) infantilizes programmers and treat everyone as dumb developers. Also, You'll be bored to death while learning Go. C is awesome, but it is not composable. And that's all I'm going to say about it. Rust is also awesome, but it feels overengineered sometimes (and not in the same ways that C++ is). I definitely think that Rust has a bright future but is not quite there yet. So, learn C++. It is gonna be a mind opener for you. Also, after learning C++ (or some of it, a lifetime is not enough for learning it) you'll have a great time learning whatever other languages you want. Don't be fooled by the "cool kids", C++ is not going away anytime soon! 
Got me reading the whole thing now! Haha great references, useful af.
I can tell you from experience in my field (energy commodities trading), that having just a date is useful - a power / gas deal will have a start and end date and the timezone is linked to the location so can be derived, it will have a shape masking the hours it flows and you only care about the timezone when you're rolling out the energy profile. Excluding the time component makes querying more efficient as most reporting doesn't care about the time component.
There is only one reason to use mmap: performance. Either when you're doing massive amounts of I/O and need to avoid copying (and aren't transforming the data, which pretty much everything does today) or when you have so much data you can't afford to allocate the memory for it twice (once in the buffer cache and then once again in your application). If neither of those two things are true it is almost criminal to use mmap because of how badly defined it is. How does mmap behave on your system when you're writing a hole in a file? How about reading it? How about mapping something past the end of the file? How about reading? Can your mmap overcommit memory? What happens when you touch that overcommitted memory and you've ran out of memory? Which signal, if any, do you get when there's an I/O error? Does your msync give you the error and sync behavior of fsync or write? All of these have at least two different behaviors I've seen in the wild and I know at least one operating system that has different answers to one of these questions depending on CPU architecture.
☝🏼this is the move right here. Let's you mock out the entire data storage layer easily for tests. 
Indeed this seems a very valid use case, thanks for sharing.
[go-tsne](https://github.com/danaugrs/go-tsne) just got added to the [official t-SNE implementations](http://lvdmaaten.github.io/tsne/)!
Thank you for the heads up. This is good to know.
&gt; How to simulate for i in 0..N in some other languages? They tell you to range over an array of zero-size elements... but why not just write a C-style loop?
You're doing God's work. 
I try to avoid global dependencies wherever possible, as they can make it harder to write good unit tests, and reduce the discoverability of the resources used by your code. The "accept interfaces, return structs" mantra can help in managing dependency injection, getting down to just the bare minimum interface required at the point of use. There are always exceptions, and similar to others I've often found myself using globals for non-user-facing concerns like logging and telemetry, to reduce the work of threading it through your code.
I think that as a tip is quite clever. It may not be the most efficient, but it is quite interesting code.
I don't know how I've never seen this.. but this is awesome, I wasn't aware of that memclr optimization!
I thought the same thing and was curious about how they performed compared to just a for loop. Surprisingly the winner was the from the example, the one that ranged over `[N][0]int{}`. It was consistently around 30% faster than the for loop. The other 2 were about 40% slower than the for loop. This was the code from the example w/ `N=50` and instead of print, just `_ = i`inside the loop. 
Except you can't remove it later. Once complexity gets in the codebase it's incredibly difficult to remove. As you said, life is short.
Good question. It's a concern I've received both in private and other public channels. Firstly, I considered `systemd` for monitoring the main application process but my last memory of it was a contentious technology. The industry couldn't agree on it, and the circles I hung out in weren't favorable to it. While preparing the post I jumped on the linux IRC (#linux) to feel the temperature once again, before going out to recommend Monit. The division was still there. Looks like `systemd` argument that it's available everywhere isn't selling too well. Besides, if that's the only argument (use me because I'm available) then there's a need to investigate more. Secondly I use Monit to monitor other things on my system: mainly files. I've learnt to use it well, and asking it to monitor a process for me was a natural ask. To be fair I took it for granted that Monit is pretty well-known and used for the things it excels at. I may have been wrong with that.
I abstract it away with a Data Access Layer - one level of abstraction so it is more or less trivial to switch out the db access code
&gt; 1 : encoding/json doesn't stream, so to put it simply, I emit [, then emit a whole series of objects that are individually small while I manually add the necessary commas. Each individual object is guaranteed to be &lt;16KB, it's the fact that I can't bound how many there will be that makes it many gigabytes in size. This reminds me of a rather crazy json-stream processor at some job in the past. That thing would both attempt to stream-read large json-encoded lists from a socket, apply transformations on the fly, and stream the converted json into another socket. All in some big nasty low-level netty handler. Working with that code was hard and weird. But hell - that thing had amazing throughput, scaled almost linearly with cores and had a really small memory footprint for a java service. Good times. 
Thanks for the feedback! The project structure you linked to seems to be for a Go application, whereas this is just a Go library. In other words, it would be just the "pkg" part of the project structure. A Dockerfile seems overkill as of now, since I can only push images of examples using the library, which anyone can run with "go run &lt;example\_file&gt;"
I see three steps you can take down this road depending on how complex the application is and how it is deployed. The later steps create easier to debug, test, and maintain code, but take longer to build and result in a larger LOC. 1. Global variables. 2. Dependency Injection with concrete implementations. 3. Dependency Injection with minimal abstract interfaces. For example, lets say you've got some type like a `UserRepo` which defines common CRUD operations on Users directly against a `*sql.DB`. ``` // 1 var ( db *sql.DB ) type UserRepo struct {} func (ur UserRepo) GetUser(id string) (*User, error) { r, err := db.Query(...) ... } ``` ``` // 2 type UserRepo struct { db *sql.DB } func (ur UserRepo) GetUser(id string) (*User, error) { r, err := ur.db.Query(...) ... } ``` The advantage of #2 is a little nuanced. First, there's the possibility that the dependency we're needing here would actually be instantiated in another package; by doing this, assuming the type of that dependency is something like a `sql.DB` in the stdlib, this package no longer needs to import that other package. Very nice. There's also a benefit in encapsulation, though its harder to explicitly outline why this leads to cleaner code. All of the things which UserRepo needs to do its job is now defined inside the UserRepo itself. ``` // 3 type Queryer interface { Query(query string, args ...interface{}) (*sql.Rows, error) } type UserRepo struct { queryer Queryer } func (ur UserRepo) GetUser(id string) (*User, error) { r, err := ur.queryer.Query(...) ... } ``` The advantage of #3 is that it is significantly easier to test, because you only need to create mock types that fulfill the interface `GetUser` requires, versus mocking out the entire `sql.DB` struct. We also now get to forget that "qualification" on the first reason why #2 is advantageous; even if the dependency has a concrete type implementation in another package, this package doesn't have to import it, period. 
I was an early adopter of C++ when it first came out waaaaay back in the 1980s and I have been working with it ever since. I also have discovered golang and I love it. A lot of the answer to your question depends on what your career goals are. 1. There is a massive legacy base of C++ code, especially in engineering and other types of applications (and to be fair, C code as well). This code base isn't going away anytime soon so if you are looking to be a professional software engineer, you should be proficient in C++ and/or Java since that is a marketable skill. Many of tho job that are out there are support coding for existing code bases. 1. If you are looking to do new development, then C++ may not be your best option. As Rob Pike points out, C++ is old and doesn't have the sort of ground up capabilities to exploit the features of modern hardware, like multi-core systems, which have to be added in while Go has things like concurrency as language basics. I would suggest you do both if you are looking to be a professional developer in order to keep your career options open. Languages like Go, Rust and Julia may be the future, but realistically, companies still need people who can write C, C++, Java, Fortran and even Cobol code. 
ResponseWriter is an interface, you can create your own object for testing purposes and avoid httptest: https://golang.org/pkg/net/http/#ResponseWriter
&gt; Looks like systemd argument that it's available everywhere isn't selling too well IDK if that is true, all the major distros have moved over to it. It's how I process-manage all of my my Go services, because it's completely portable, dependency-free (like Go itself!) and really easy to write service files for (unlike sysvinit).
How does it compare to https://godoc.org/cloud.google.com/go/civil#Date?
If a call can not fail, mark it as such with something like // this can not fail because {reason here} data, _ := json.Marshal(hs) As long as you are correct in your reasoning, this is a valid move. Go lacks the strength of type system to be able to make any sort of assertion like this at compile time, but you're free to come to that conclusion on your own. Bear in mind that in this case, it's not a choice between "right" and "wrong". The above code may superificially look dangerous, whereas "if err != nil {...}" looks "safe". But, for the precise reasons that you are asking about here, the latter code is actually dangerous too, because it's a case that you are, by definition, not testing! So it's actually a choice of which not-entirely-correct thing you want. I think dangerous code should look dangerous, so I prefer using underscore and a comment (personal policy, _always_ a comment explaining why I believe this is impossible) so that it _looks_ about as dangerous as it is, rather than a very, very innocuous-looking "if" clause that can't actually ever be triggered. Of course you have to be correct in your conclusion as well. I would also accept something to the effect of data, err := json.Marshal(hs) if err != nil { // log something like "this can't happen but did" // maybe panic if you like } But I tend more towards the first example in my own code.
[removed]
Nice, i am using mage and golang to replace docker-compose and many tasks in ansible playbooks, very good results, now I can remove some python dependencies and make pipelines simpler
[removed]
See also [prior discussion](https://www.reddit.com/r/golang/comments/9i7nr3/monitoring_go_applications_with_monit/)
Thanks alot your answer is just the truth, I know that C++ is quite old as regards time and modern hardware but in reality company still want ... u know what i mean . Thaaaaaaaaaaaanks alot, I was just musing around this and knew that i needed some advice, yours is priceless ...
There's actually a much easier way to do this. Instead of parsing the HTML, write a custom blackfriday renderer and change the way code blocks are rendered by passing them to chroma.
https://www.youtube.com/watch?v=OM9jhGiIAFM
&gt; not that google uses it that much False. The whole reason Go exists is to power Google's back-end systems. Most of their back-end stuff was originally written in Python. Python3's backwards incompatibility is what inspired Google to create their own language to begin with. 
I believe the ability to connect multiple wasm instances is a plan for feature. Being able to connect different wasm files will allow the go run time and garbage collector to be cached and only the wasm distinct to your app will need to be downloaded with each update.
Cool! Thanks for pointing that out :)
I do prefer for `i := range [N]struct{}{}` to for `i := 0; i &lt; N; i++`. The reason is I find the former needs less time to be typed, though it is longer, :)
SQL is already an abstraction. Apart from some convenience functions like Insert(table, data), what's the advantage of GORM vs. writing out a select query by hand? If you're going to learn an abstraction, why not learn enough of SQL to write a query instead of writing a language-specific ORM set of commands? Ugh: ~~~ if err := db.Where(“id = ?”, id).First(&amp;person).Error; err != nil { ~~~ vs: ~~~ if err := db.Get(&amp;person, "select * from person where id=?", id); err != nil { ~~~ I'm pretty sure most of your queries will be simple select statements. And if you're dealing with joins, I'd definitely argue that there's wisdom in constructing those joins by hand, and inspecting their query plan on the target database, to ensure the most optimal query. I hate that people advocate ORM with the argument "You can always throw it away later". No man, you really can't and it can be a pain to refactor when you actually hit problems. Sure, it may take a while, but it's going to hurt that much more when you do.
Cool tricks, in particular the one making use of duplicated constant keys checking in composite literals. Would you mind I add these tricks in this article? &amp;#x200B;
There are a few using mage for that already. Am on mobile right now so don't have it here but just Google it
I think it is totally dependant on size and scope of project.. I'd say I have used an ORM (typically Gorm) for roughly two thirds of the services I've stood up. The dev time it saves is great - avoids a lot of boilerplate.. For the projects / services which are more involved or performance tuned I absolutely use raw SQL, because as you pointed out it is not worth the time it takes to shim all the performance tweaks into the ORM. Furthermore, ORMs start to quickly lose value once sharding is introduced.... Which again imo is typically in more "involved" projects. I definitely prefer working with plain SQL. ORMs are a tool in the toolbox, the trick is to pick the proper tool for the job. ( Usually easier said than done, of course! ) With that being said, do you advocate it always being worth writing your own queries / using SQL, and never using an ORM? Thoughts?
Channel has his own mutex so it will be overkill to use unbuffered channel.
I'm with you. But unfortunately this is how most see developing, as operations on data. You example is simple and good, if I was coding a real system I would probably not even return the real User domain object, but a read only copy or a DTO thru mapping. I guess a service layer is missing there, you probably don't want the consumer to have a DB handler, the service as a Storer or Repository, Registry, pick your name. &amp;#x200B;
thanks, this basically do its job :)
&gt;I would love to see your template for future reference. I'll try to get around to it in the next few days. One reason I hesitate to do it is because it's really more of a design pattern than a template. It's not the kind of thing you can just copy/paste and then fill in a few slots. Things like function signatures will change across projects. 
Rather than setting global options to your Gmail package, I think you should have opts for the specific instance. Something like the varargs param of functional options would work great in your constructor. https://halls-of-valhalla.org/beta/articles/functional-options-pattern-in-go,54/
I use go-pg query builder and ORM. It's only for PG though.
Yes, gc is becoming smarter and smarter. The trick used in the BCE example in this article might be not essential for a later gc version. Just like this one: [https://go101.org/article/bounds-check-elimination.html#slice-comparison](https://go101.org/article/bounds-check-elimination.html#slice-comparison)
With pulseaudio (Linux only) you can create a monitor channel, so you can "listen" to everything that is played on your output. It's presented as a regular audio output, any libraries will do. On OSX you could use [https://github.com/mattingalls/Soundflower](https://github.com/mattingalls/Soundflower) For a cross platform solution portaudio would work but I believe your users still have to enable the monitoring which is not an easy task.
And there is a disclaimer in this, I have been to quick to criticise. Thanks for pointing this out!
This is good.
Seriously? I thought they were explicitly targeting the C++ developers inside google, but none of them actually jumped to Go. This is the first time I hear that Google's backend is python! I actually have a friend that works at google, 98% is still C++, and he says "just a little go here and there". &gt; The whole reason Go exists is to power Google's back-end systems. Not at all! Go was initially a 20% project at Google, not a business decision. Google is still very much C++ on the backend. &amp;#x200B;
Not your mistake, the disclaimer was added just one hour ago. :)
That is actually a killer feature IMO. I'm actually reasonably happy for basic building, running and testing with Make. Where things go wrong is when I'm automating project tasks such as building binaries for multiple platforms (I need cgo on darwin for example), promoting artifacts to our repos, and automating deployments or operational tasks. At this point my Makefile typically becomes pretty unwieldy. It also doesn't help that I can't easily reused the code between my own projects, much less with other teams. There are other tools available like Bazel that help with some aspects of reusability, but so far, I think Mage might solve a good number my frustrations with Make. I've giving it a try in earnest now and so far so good! &amp;#x200B; One thing that I did because we use a monorepo and I have two different GOPATHs was to move my build helpers to a small package in my app. As @natefinch said in his blog post, it really does a good job avoiding the boilerplate of using \`go run scripts/main.go\` while keeping the benefits. 
I personally use parts of domain driven design and hexagonal (clean) architecture. You basically separate out your data access layer to separate components called 'repositories'. These return and take data objects (can be anything, usually structs) called 'entities'. What this effectively does is that it let's you decouple code that depends on a data source from the actual data source (db, http call, files). here is an example: ``` // a User entity type User struct { ID int Name string Age int } type UserRepository interface { FindByID(int) (*User, error) FindKids() ([]*User, error) // a custom method for finding users with age &lt; 10 } func SayHelloToKids(repo UserRepository) { kids, err := repo.FindKids() // error handling left out for brevity if err != nil { log.Println("error") return } for _, kid := range kids { fmt.Printf("Hello %s\n", kid.Name) } } type inMemoryUserRepo struct { users []*User } func (r *inMemoryUserRepo) FindByID(int) (*User, error) { // code } func (r *inMemoryUserRepo) FindKids() ([]*User, error) { results := make([]*User, 0) for _, user := range users { if user.Age &gt; 10 { results = append(results, user) } } return results, nil } func main() { repo := mockUserRepo{/*data here*/} SayHelloToKids(repo) } ``` now you can use an ORM, or just "database/sql" to implement repositories or a mix of both. you can even ditch it altogether a use an inmemory data sturcture. Your code will work as long as you implement the repositories properly. I find this is the most flexible and testable approach.
This problem is not about static linking at all. Guard syscall and any other platform specific code with build tags. End of story.
Sure. I don't think it's a terribly useful trick; most constants are integers, so you can use the existing tricks for those. I suppose one case where it might be helpful is asserting `someCondition &amp;&amp; DEBUG`. One thing to watch out for is that the duplicate initializer trick fails silently if you use non-confrontational values; they'll just overwrite each other: https://play.golang.org/p/2gXUymOpI_m
It's because there's less mental parsing, you're doing a single operation instead of 3
My first reaction to this was "wow, that's clever!", but I did wonder if it might be too clever when you expect a lot of other people to read your code. If you've not seen that form before, it does require a little bit of thinking to unpack what's going on.
They do compress well under gzip. There are lots of reasons for large sizes, I opened [an issue](https://github.com/golang/go/issues/26622) about init such as unicode being way too many instructions, but it was dismissed unless I did more research so I just gave up on it. Author will also blame WASM block formats since they don't have gotos causing more block insns and switch insns at the top of functions for resumable coroutine yield points. I think fixing the unicode package (and all those unnecessarily exposed vars) and in general inits and constants can help a lot.
Yes, it only works for constant keys.
Yes?
I’m on iOS 12 and it causes my phone to restart as well.
Don't do this unless you want to have chaotic versioning. Especially if other people are consuming the app.
&gt; For example, it isn't uncommon to see something like this (taken from termbox-go) Termbox is an incredibly platform-specific package. Seems like a bad example. &gt; In illumos &amp; Solaris system call interfaces are "undocumented", and one must use the C library to access system services. This is our "stable API boundary". Yes. On some platforms, for reasons that are beyond me, the vendor has decided that syscalls are not a reasonable stable API/ABI boundary and you're supposed to use C-libraries instead. On those platforms Go is actually doing that. On Solaris for example (the one the author picked) the syscall-package is implemented via the libc. So the author erroneously assumes that just because you use the syscall package, you are doing raw syscalls. I think the problem the author ran into is more, that termios isn't part of the stdlib (as -IMO - it should be, given how platform specific it is and what a mess terminfo is). And that the authors of the termbox package are not familiar with these details. Which is a fair criticism - but it also, again, points to how platform-specific the stuff is. I think a better culprit than "static linking" here is "linking against C code". If the termbox authors would've built it via C-bindings these problems wouldn't have happened. But that, on the other hand, I find a totally fair tradeoff to make, though. Linking against C comes with significant downsides in terms of cross-compilation, speed and most importantly, safety. I think it's a fair goal to strive to not rely on C if not absolutely necessary. Honestly, the author should just open a bug against termbox to make it usable on Solaris.
&gt; The obvious (to me at any rate) reason is to avoid the dependency nightmares and breakage that occurs with other systems where many dynamic libraries are brought together. There is at least one (though not likely the most important one) more reason: Speed. Static linking allows you to replace indirect calls by direct ones, which at least on *some* workloads provides a decent speed boost. Also, not having to dynamically load and map dependencies makes for quicker startup times. Not the most important reasons. But reasons :)
why? OP said he wants to add a function, which implies that it's backward-compatible. Tagging backward compatible API changes in the same major version is the recommended way to go. If it's actually not backward-compatible, then it's already chaotic no matter what they do (unless they tag it as `v2.0.0` instead but there will be other problems.)
[Syscall must always be guarded with build tags.](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=11m10s)
For native pulseaudio, I made a lib to connect to the pulse server through D-Bus. I use it only as a "volume control" (get volume, mute and app icon) so I don't know if you'll get what you need, but here it is: [https://github.com/sqp/pulseaudio](https://github.com/sqp/pulseaudio) and the pulse D-Bus server doc : [https://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/Developer/Clients/DBus/](https://www.freedesktop.org/wiki/Software/PulseAudio/Documentation/Developer/Clients/DBus/) &amp;#x200B;
[removed]
&gt;So the error can be described in multiple ways: &gt; &gt;As a string constant (eg. "ENOENT" or "File not found") &gt; &gt;As a detailed message (eg. "File 'monkeybutt.txt not found") &gt; &gt;As a verbose error stack spanning multiple lines &amp;#x200B; Gee, that sounds familiar. That's exactly a decision the stdlib has made. Let's see: [https://play.golang.org/p/rbeIbb87fRm](https://play.golang.org/p/rbeIbb87fRm) package main import ( "fmt" "os" "syscall" ) func main() { err := &amp;os.PathError{Op: "open", Path: "monkeybutt.txt", Err: syscall.ENOENT} s := err.Error() fmt.Println(s) } &amp;#x200B; open monkeybutt.txt: No such file or directory &amp;#x200B;
[removed]
I believe it's this one: https://www.waveshare.com/product/2.13inch-e-paper-hat.htm
[removed]
That is not what a library is, it is a package. Did I miss the memo?
As in Maven?
[removed]
[removed]
That's just the thing. OP wants to use different sets of libraries and/or toolchains. That's exactly what `virtualenv` and `pip` accomplish.
https://github.com/vedhavyas/cuckoo-filter is concurrent safe.
noticed something with using this shell: how would we handle the IO redirects with reference to programs run from it. Specifically thinking of running ssh from the simple shell, in testing it seems that SSH hangs on exit, as its waiting for the redirect pipes to close. /me is a noob SA trying to create a limited-commands shell in go
&gt; At that point you might as well go with the full safety of normal io because the only thing mmap provides you is avoiding doing a copy at a huge cost Not quite. mmap also gets rid of syscalls and the associated context switches. With read/write, you have one syscall per chunk read/written - which, for large files, is a *lot*, as you usually use relatively small [(say 4K?)]( https://golang.org/src/bufio/bufio.go#L18) buffers. With mmap, after the file is mapped, loading and unloading pages of it just becomes part of the normal operation of the kernel memory management and it mostly can get out of the way. Mmap also provides other benefits. For example, you can have anonymous mapping or set different properties of the mapped pages - it's pretty much the only way to implement a JIT, for example, as memory allocated by the runtime isn't executable. Of course, I'm picking nits here, a little bit :) But I don't think it's totally fair to say that mmap isn't useful without access to the underlying byte-slice.
I don't know about a uniform approach, but one of the future versions of staticcheck will have a config option for build options to check.
&gt;Syscall must always be guarded with build tags. Go-proverb 9: [https://go-proverbs.github.io/](https://go-proverbs.github.io/)
I'd just use a Makefile for basic things like running go build or tests consistently. Once the Makefile gets a bit too involved, I'd suggest taking a look at Mage( 
&gt; Not quite. mmap also gets rid of syscalls and the associated context switches. Yes, you could have read two sentences further and noticed that I mentioned that. But you did what I'm doing right now: read the second sentence and comment on that instead of reading the whole thing. I lied, I read your whole comment, you are right, but that's not what the package provided. I know all those things, I've actually done quite some work in an actual implementation of mmap in a real operating system, which is also why in my other comment here I can say with quite some authority why mmap sucks for I/O unless you're one of the two special cases. You are technically right, but the cost in unreliability and undebuggability is just too high. You want to know the terrible secrets of mmap? Write a program that does this: create a new file. ftruncate it to be one page long, just make sure to ftruncate it, not write because we actually want a hole. mmap the file shared and read only, this gives you a pointer x. Do: `write(fd, x, getpagesize());`. Before you run it, reason about what the behavior should be. Once you think you know what it will do save your important files (because in the worst case you'll completely ruin your filesystem) and run it. If you're lucky you're running an operating system that hasn't reintroduced the bug again (because it pops up every 5-10 years, I haven't tested for a few years so we might be fine). If you're on macos you'll most likely get a hanging process that is unkillable (unless they fixed this, which they probably didn't because I gave up trying to report it to them after debugging their bug reporting system for a few hours), reboot to kill the process, look at the contents of the file, what does it contain?
&gt; Yes, you could have read two sentences further and noticed that I mentioned that. Sorry :) I did in fact read further but I also overlooked that sentence, apparently :)
I just did that yesterday. Was super easy. One file and that was it.
Your code is pretty good, but I would add additional sorting detection to the top level. That or you should check for the slice length. Reason - the last element should be one or you will get index out of bounds error. 
Hmm yeah, without 1p at the end, you could have non-solutions... I was pondering parallelization via go routines or something, but I couldn't think of a clean way to do it. I mean, the problem is so simple it doesn't require it, but as more of an exercise in thinking that way.
I think there are plenty of articles online that explain how to do that. I searched _"golang web server with database"_ on Google [1] and found 1.4M results. [1] https://www.google.com/search?q=golang+web+server+with+database
Use the right tool for the right job. Go isn't going to be a one size fits all, though I too really like Go.
https://github.com/jmoiron/sqlx
&gt;How to simulate for i in 0..N in some other languages? Sorry but I missing something, what is a difference between "for i in 0...N" and for i; i &lt; N; i++ ? I kind of lost TBH.
poorly worded question on my part honestly. I can not find a guide on the best way to take continuous input and store it while being able to add to that input
What kind of database software do you want to use?
Postgres SQL is what I'd like to use 
To use different libraries, change GOPATH or use Go 1.11 modules. To use a different version of Go, compile the binary to a separate location and it will set its own GOROOT automatically. You only need to set it manually if you move the Go binary after you compile it. 
No
FWIW if you dont need to repeat this too often, OpenOffice can generate documents from csv.
Documentation for python is non-existent. 
I am always disappointed when I need a program to do X but Go doesn't do X very well. At least the things it does do it does very well. 
Try generating Mandelbrot sets. The problem lends itself well to being solved with concurrency.
That was my first thought as well. And it appears so.
Same also crashed my phone ios12
I suggest you Google up some stuff about memory profiling. It sounds like you're leaking memory somewhere. There is not much of a way we can help based on the information provided.
Hey there, thanks for the reply! Yeah I thought so; I wasn’t a hundred percent sure about it since Golang has a garbage collector so surely it will free up the memory accordingly? Is there any applications/software I can use to find where it’s happening?
Memory leaks can quite common (and depending on the language) sometimes quite easy to create in garbage collected languages. A garbage collector only means *you* don't have to manually free the memory. However, you still need to make sure your program is in a state that the garbage collector knows that references cannot be reached, and therefore safe to free. This happens normally but there are certain ways you can write programs that render memory unable to be freed. In the case of go, I would check areas where you are running new go routines. Especially if they are capturing values (closures) or something receiving pointers to other objects. Make sure these go routines exit once they've completed their work. You could start with this blog post https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/ If you've never done this type of work before it requires thoughtful diligence and patience. I wish you luck.
A library is a specific type of package. "main" is a package but not a library. A package that has no exported identifiers is not a library. Also, a library can contain more than one package. (Forgot to include that point in my previous comment.) Prominent example: the standard library. Yes, the distinction between "package" and "library" might be subtle, and I see no problem using "library" and "package" synonymously when the context is unambiguous.
I've found Go works really well for the things I need it to, granted I don't write any GUI applications. WASM support right now is interesting though, if there's a good DOM API at some point webapps could just be the future of GUI programming. Not sure how I feel about that though haha
You're making this more complicated than it needs to be.
&gt; help myself use channels, and all the cool concurrency stuff that Go has? I write services that run across thousands of machines. My team avoids channels and "cool concurrency stuff" unless there's no other solution for a problem. The only feature in that set we use is `go`, and only once or twice at the beginning to run supporting threads (health, metrics, etc.) Why? Complexity is the breeding ground for bugs. And channels are complex. Concurrency even moreso. Put the two together and you've a recipe for disaster, especially for the relatively new coder. It's good to learn what those features do, but you might end up scuttling your own project if you make it too complex. Be wary.
If you can't be bothered to fully specify your problem, how can you expect any helpful answers? Here: http://www.catb.org/esr/faqs/smart-questions.html
Learn more about [https://github.com/TarsCloud/TarsGo](https://github.com/TarsCloud/TarsGo)
&gt; I looked at python and couldn't find any libraries I liked to create PDFs so I decided to give GO a try. So, what PDF library did you use?
If you go for Kubernetes then GCP is a better option than AWS because of costs. In AWS a Kube cluster has a cost. In GCP it's free. Also, distributed system with Kubernetes is a breeze really. Here is a guide I wrote up with the accompanying code: https://skarlso.github.io/2018/03/15/kubernetes-distributed-application/ It can be daunting at first, but the article does describe Kubernetes basics as well. That's why it's lengthy. You can skip that part if you already know that. Also, also you could just use docker swarm too. They did improve a lot these days.. This is a good place to start: https://docs.docker.com/engine/swarm/ It might be less of an overhead than Kubernetes. With Kubernetes you have the luxury though to switch to LXC or and OSI compatible container runtime like runc or systemd-nspawn, if you so desire and don't want to lock yourself to Docker. I would also suggest to look into gRPC and NSQ for communication in Go land. Both of which are pretty awesome toolsets. I'm using those in the above guide if you like. But the communication medium is fully up to you. :) I hope this helped to get started. Good luck buddy!
Well, there is the basic pkg provided by Go located here: https://golang.org/pkg/image/draw/ But if I recall correctly pixel is a pretty prominent one https://github.com/faiface/pixel if that is what you are looking for. Also GG https://github.com/fogleman/gg. :) Have fun!
Binding to X11 / GTK and setting dynamically updating pixel buffers for a graph to display. Essentially I was able to bind to GTK using someone else go wrapper, then extend that, but it seemed like even though GTK supported the behaviour it wasn't well documented and there was understandably a lack of Golang support for that.
And as technical complexity is basically zero, you don't need a compiled program and more people can understand and administer it. Personally I use Python atm for most things CSV 2 or 3 I have a library for reading utf8 csv files that passes my test-suite of faux-pas and I'm content with it. go with whatever tool works, then pick a more sane serialisation format to output for other tools to interop. Could be SQL, JSON, some proprietary packed binary format, even office-suite apps.
Maybe [unidoc](https://unidoc.io/) or [gofpdf](https://github.com/jung-kurt/gofpdf) or even [following a tutorial](https://appliedgo.net/pdf/)
Seems an interesting case for a first program. I'm using Go lately and wished I had such a good first usage! But yes, I share your feeling.
Here the great aerticle about picking your niche in video streaming app development. [https://yalantis.com/blog/three-types-of-video-streaming-apps/](https://yalantis.com/blog/three-types-of-video-streaming-apps/) And what about tech side here another source [https://medium.com/canal-tech/how-video-streaming-works-on-the-web-an-introduction-7919739f7e1](https://medium.com/canal-tech/how-video-streaming-works-on-the-web-an-introduction-7919739f7e1)
In my Games With Go videos series, I cover how to do basic software rendering with SDL2 and later basic 3d with opengl: [https://gameswithgo.org/topics.html](https://gameswithgo.org/topics.html) &amp;#x200B;
If you just want to learn go, [this stuff will always be up-to-date](https://golang.org/doc/). If you really want a book, something from 2015 will apply just fine. Go is not in the habit of burning the world down every two years because some hot new awesome came down the pipe and revealed how crappy the previous hot new thing was. Honestly, I'd recommend staying away from languages who can't keep their tutorials stable for two or three years. (Unless you are deliberately seeking out a cutting edge language being freshly developed.)
Factor semiprimes
Thanks, I love Ben Johnson's articles on Golang! :)
is `[N][0]int{}` as efficient as `[N]struct{}{}` though? 
tour.golong.com is just as relevant now as it was 5 yrs. One of Go's strengths is that it doesn't change very quickly. Things from 5yrs ago are still "updated", because there is nothing to update.
Go write some code. Go is so simple, you likely know all there is to know. I'd say this if you said, "I have completed the tour" too.
Good to note then! Right now I'm just trying to familiarize myself with the language.
Have you tried extending the type for example from the wilf bloomfilter. Adding a mutex to make it safe in concurrent use? 
Ha, I also just finished the course by Stephen Girder. It was quite good, yet I was surprised that some things were missing (like switch/case statements for example). I also worked through the Go Tour though and both things together showed me everything I need. At least it feels like it. :-) I didn't mean to hijack this thread, but I have one question for the more experienced Go devs here: What the hell is up with interfaces? They add so much confusion I really do not like them. And what for? Just for less typing? Is that all they're good for? Just so I/developers have to type less? If that's all they do than I think I have understood them. But in case I'm missing something, please let me know. Thanks so much in advance!!
Personally, I think buying the GoPL book is a good idea. I read the docs and did the Tour of Go, and reading that book sure filled in all the blanks for me. There are a lot of subtleties I would’ve never picked up by reading just the online docs here and there. 
I'm not sure how you came to "less typing" conclusion. Interfaces are a way to define behaviour (methods) without implementation. E.g. io.Reader defines how any reader should work, and there are multiple Reader implementation inside standard library (e.g. reading from file, from in-memory buffer, reader combining multiple readers, etc.) Code that accepts io.Reader does in fact accept any of those implementations.
Interfaces for sure are not to reduce typing but a design choice. Especially for medium to large size codebase maintenance of the same code is cumbersome and error prone. 
Hi there, I'm not a pro Go dev by any means, but here's my 2 cents on your question. Interfaces are one of the few tools that you have for achieving polymorphism in Go. Since there's no notion of inheritance in Go interfaces are satisfied implicitly, meaning that there's no need for you to explicitly state that an object satisfies an interface. This by itself in my opinion is the best feature of Go's interfaces. You can read more on the topic here: [http://www.golangbootcamp.com/book/interfaces](http://www.golangbootcamp.com/book/interfaces) Cheers
If you're using recursion you're keeping the whole attack in memory until you finish.
If you are looking for ideas on what to code, gophercises.com has about 20 exercise projects that are good practice. I would recommend you try to code on your own frst then watch videos explaining ways to solve each exercise. oh and it is free. (Disclaimer: I made the course)
As I said, it can be a fun experiment and a chance to understand channels better. It isn't meant to be a practical solution.
Ah yes great example. I experimented with the net/http module. Why do I need to use this complicated io.Reader? It seems so confusing and pointless. Why can't I just use this for example: fmt.Println(resp.Body) That would be so much easier and direct and upfront
Ah yes great example. I experimented with the net/http module. Why do I need to use this complicated io.Reader? It seems so confusing and pointless. Why can't I just use this for example: fmt.Println(resp.Body) That would be so much easier and direct and upfront
Clarification: What I meant by "less typing" = "less code" 
There are some game engine type things out there, which I've played around with a little for the exact same purpose. A google will turn them up. Each has advantages and drawbacks, none are anywhere near as simple as processing, but that's to be expected since it's a general purpose environment, not one designed for drawing to a window.
both yes and no. In a certain sense, you end up _writing_ less code because you minimise duplication and facilitate reuse. but you usually need to lay more ground work to get it going, so you end up writing a lot of extra boilerplate code.
&gt;but you usually need to lay more ground work to get it going, so you end up writing a lot of extra boilerplate code. So interfaces suck even more than I thought??? ;-) (I'm just joking, no offense, I really like GO, I just don't like/understand interfaces)
keep writing code, and one day you'll love them. 
To just print the body, you can copy resp.Body (which is a Reader) to os.Stdout (which is a writer, and default place where fmt.Println writes too) by using `io.Copy(os.Stdout, resp.Body)`
Is that view on cost a post-EKS evaluation?
&gt; Complexity is the breeding ground for bugs. And channels are complex. Concurrency even moreso. Maybe that's exactly why OP **should** get his hands dirty with channels and concurrency now. To learn as much as possible while still in an academic environment. Or as one of my colleagues likes to say: We don't learn to swim by reading.
My suggestions: 1. Join the Golang Weekly mailing list: [https://golangweekly.com/](https://golangweekly.com/) 2. Join the Gopher slack: [https://invite.slack.golangbridge.org/](https://invite.slack.golangbridge.org/). Chat with people, ask questions, answer questions! 3. Start reading other people's code that seems interesting to you. 4. Try and find some fun projects to do (hit me up if you want to collaborate!)
Haha if that day will ever come I'l track you down and tell you you were right!! ;-)
This is the perfect example. Why is it so complicated? Why can't "resp" just be a struct. One of the struct's field would be "Body" of type "string". Then all I'd have to do is fmt.Println(resp.Body). That would be much better. Do you understand what I mean? Why is it solved with so many useless interfaces? Why cant you just store the response body as a string? And then just print it? It would be easier, fast, better, simpler, more upfront, less code, etc... So what am I not seeing here?
Oh I'd very much like to get into that discussion. It's not like I WANT to dislike interfaces. I WANT to like Go and I do, but I do NOT at all like interfaces. Let's take resp.Body as an example. It's a string of variable size. That means it lives on the heap with a pointer to that heap living on the stack. So If for some reason I'd have an enoooooormously large resp.Body I could just pass on the pointer and I wouldn't have to copy anything. Everything would still be easier, faster, simpler, less code, etc. What exactly is it I'm not getting about interfaces here?
This is not actually true... Look at the docs for \`Response.Body\` ([here](https://golang.org/src/net/http/response.go)): &gt;// The response body is streamed on demand as the Body field &gt; &gt;// is read. If the network connection fails or the server &gt; &gt;// terminates the response, Body.Read calls return an error. So when you make an HTTP call, the response body doesn't automatically end up in your memory, you just get a "handle" to it and you can process it as you see fit (you could even ignore it and just close it immediately). If the body automatically entered your memory and it was enormous, it's really not hard to come up with a scenario where you run out of memory pretty quickly. That's why it's important to not just load everything into memory always will nilly.
I do not understand this sentence, sorry brother. :D But here is a detailed view of the costs on either Azure, GCP or AWS: https://codefresh.io/kubernetes-tutorial/kubernetes-cloud-aws-vs-gcp-vs-azure/
I should have been more precise. What I should have said was: "So in my example, where resp is just a struct and hast a field named "Body" of type "string". .... I still don't understand what advantage it has to use this confusing web of interface on another interface, etc. Why not just save it as a f***ing string and be done with it? I just don't understand? Interfaces make everything more complicatedin this example. Yet interfaces are used for it. Not even just one layer, but two layers of interfaces. Which makes everything even more confusing. So again my question: Why not just save it as a string and be done with it? I don't see a single advantage of using interfaces here. So what are the advantages here in this case?
Because a string is an in-memory object. And an interface can let you access something remote. Now, if the response is very large, storing the response body locally is not feasible. So if response.Body was a string, you'd only be able to handle small responses, whereas if its an io.Reader, you can handle any size of response.
I found the implicit-ness to be a nightmare but now I've got the hang of it it's great.
Make something! I found that even reading on syntax and idioms for a new language wasn’t enough. I had to try to write code to see what I did and didn’t know. Go is no exception here.
Your plugin could have a constructor method that accepts the logger from the main program as an argument. That being said, plugins are a bit of a mess right now and are not for the faint of heart.
I've seen that page, but didn't know if it was (always) updated! So thanks! &gt;Go is not in the habit of burning the world down every two years because some hot new awesome came down the pipe and revealed how crappy the previous hot new thing was. Awesome, as student that will begin university the next year, i was trying to pick a few programming languages to work my way, 'cause the syllabus is all about C (very basic) and Java (same as C). After a lot of reading and discussion (like [here](https://www.reddit.com/r/golang/comments/9da5cu/any_pythonist_who_can_share_opinions_on_go/) on Reddit too), i've decided for Go - but honestly i wasn't aware of this aspect. Your words are reassuring, thank you!
&gt; plugins are a bit of a mess right now and are not for the faint of heart. That's the gist I am getting as well.
&gt; a string is an in-memory object. And an interface can let you access something remote What exactly does that mean? access something remote? Well the function/method that stores the Body into MY string in the struct can access remote objects as well. And then just store it as a struct-string. &gt;Now, if the response is very large, storing the response body locally is not feasible. So if response.Body was a string, you'd only be able to handle small responses, whereas if its an io.Reader, you can handle any size of response. But before the resp.Body gets sent out to stdout it needs to be saved somewhere? Where is it saved when using an interface? Probably the heap as well? I mean it needs to come from somewhere!? I'm also learning Rust at the moment and it just takes the resp.body and puts it into a string like this: https://doc.rust-lang.org/std/fs/fn.read_to_string.html It's upfront, works, easy. I just use a pointer if I want to use it in a different function. And according to your logic (not meant as an offense) Rust wouldn't be able to handle similarly huge resp.Body objects as Golang/interfaces. 
I think i'm gonna listen to you then, tomorrow i'll buy it :) But just to be sure, the contents of the docs are the same of the book? I mean, the book covers everything o i have to check the docs too? Thanks
No offense taken, this is a good discussion. &gt;But before the resp.Body gets sent out to stdout it needs to be saved somewhere? Where is it saved when using an interface? Probably the heap as well? I mean it needs to come from somewhere!? This is my point - that the response doesn't need to be stored anywhere before you write it to stdout. When you make an HTTP call, you get the response back, but it doesn't mean you're done with the call - inside the response you have \`Body\` which is just a wrapper around the network connection. This wrapper (an io.Reader) has a \`Read\` method, which you can call to get just a small part of the response body. So in essence what you'd be doing is call \`Read\` many times to get a small amount of data every time and write that small amount of data to \`stdout\`. You can then discard this piece of the data before reading the next piece. So in the end of all of this, you never actually have the entire response body in memory at any point in time. In regards to Rust, when you call \`read\_to\_string\`, you're essentially saying: "Take this io.Reader and just read it into memory", which you can do in Go as well. But if you do this in Rust you will hit the same exact issue. This essentially is the difference between streaming data from one place to the other, vs copying it into memory from place A then copying it again to place B. Streaming is just much more efficient. &amp;#x200B;
Yes, but that is an attribute/ability of the "Read()" function and not of the interface, right? I mean an interface is basically just some sort of container that makes it easier to connect to other methods, no? Check this in the docs: https://golang.org/pkg/io/#Reader The Reader interface just "wraps" a "Read()" function. Where can I see the source code of the "Read() function? Why can I not click it like everything else? I think we agree on this: &gt;This wrapper (an io.Reader) has a `Read` method, which you can call to get just a small part of the response body. I understand and agree. The Read() function/method return an "endless" stream of "int" which is the byte stream? Is that correct? But why the hell is a interface wrapped around it?
Lately I wanted to do some audio signal capture and processing for example. There are some small libraries for it, but Java has a bunch of native interfaces for example. 
&gt;I understand and agree. The Read() function/method return an "endless" stream of "int" which is the byte stream? Is that correct? When you call \`Read\` you get back \`n\` bytes. So you can use this to read many times, essentially creating a \`stream\` of bytes until the \`Reader\` is fully consumed. Then you'll get an \`io.EOF\` signifying you read everything there was to read. &gt;Where can I see the source code of the "Read() function? I'm not sure honestly, you'd have to go digging [here](https://golang.org/src/net/http/response.go) to find which struct is actually used under the hood for \`resp.Body\` and check how it implements \`Read\`. &gt;And one step further. If the stream from Read() isn't saved anywhere that would mean that it would have to be streamed straight into stdout. Is that the case? Exactly, and that's the point - this lets you avoid unnecessarily storing the entire response body in-memory and just stream it to wherever you'd like it to go. &amp;#x200B;
Well I'm not quite ready to show this off but I am working on https://github.com/thegtproject/gravitygl it compiles native or for the web via gopherjs. see the example. 
Hmmmmm I think i sort of understand. But also not really entirely. :-) You Go people surely are pretty heap-phobic, Jesus. (joking!) Thanks so much for your time. This was an interesting discussion. And since I already have you as an expert. One last question: I want to learn Go so I can write a GTK based IMAP client. There are REALLY good IMAP libraries for Go. Much better than for Python and Rust (the only other languages I know) So phrase it as simply as you can. If you made an GTK based IMAP client. What would be a specific example where you'd use interfaces. As of now - and everything is still VERY basic/alpha/crude - I don't use a single interface. I use goroutines all the time so my GUI doesn't freeze when I call methods that take a while to finish. But interfaces? Not a single one. Can you give a few easy, realistic examples please?
&gt; tour.golong.com is just as relevant now as it was 5 yrs […] Hmm, I think you meant this — https://tour.golang.org/
OK that sounds good. I think I'll just give interfaces a pass for now. Maybe in a few years from now I'll be all over them!! :-) Thanks again for your help/input/this discussion!
I would welcome a more generic approach. I’d like to have full controll over what images I’m running (there are about 4 flavors of mysql comptible services/forks i can think about from the top of my head), as well as to run other things (redis, minio, zeromq,...).
You got it. Good luck with your project!
AWS have a new general availability service called EKS, which means that users don't have to manage the control plane of Kubernetes. It also allows integration with IAM and other things, and reduces the amount of EC2 instances you need for smaller projects. The cost is assumedly smaller than running the instances yourself, as you would have had to previously. The article above mentions ECS and Kops, and not EKS, so the pluses and minuses have to understood to be somewhat out of date. You mention a $0.2 per hour, so I'm assuming you're considering it *with* EKS.
Yes. EKS does cost money but GCP provides you a managed cluster without any costs is what I meant. :-)
What are the benefits to using this vs [https://github.com/ory/dockertest/](https://github.com/ory/dockertest/)?
Thanks a lot !! Just started watching your playlist.
Nice! Thanks for sharing :)
Jon's "Web Development with Go" course is also worth every penny if you can afford the video package: https://www.usegolang.com/ No affiliation, just a fan :)
alternatively you could use a custom "net/http".Transport wrapper, that injects the basic auth headers into every throughcomming request.
You can’t AFAIK, http.get is just a simplification Why do u want to avoid it anyway?
Had not seen that before! :) &amp;#x200B; The integrations supported by the go-docker-initiator will have "plug-and-play" support. Meaning that you don't have to implement and use your own probing in the test code. As seen on line 12-22 [here](https://gist.github.com/noseglid/506fa297819934fda7da243c01ca7700#file-users_test-go). Once you are up and running there is probably no difference at all &amp;#x200B;
&gt; I want to avoid using http.newrequest. Why?
You probably want to use websockets (https://github.com/gobwas/ws is solid). You can user timeouts in selects to timeout operations: https://gobyexample.com/timeouts Before you try to implement a complex game, you may want to build something like tic-tac-toe to make sure you have the basics down. 
This is awesome, thank you so much!
OK so point #1 and #2 are understood then. Point #3: Can you please give a simple use case for which you'd want to use a Pointer to a Pointer? How would that make any sense? Point#4: I have no idea what you just said. :-) Must be my missing CS background. &gt;Function/method calls take precedence over operators What does that mean? What is an operator? The "*" symbol? How does it take precedence? Lets make it easier: If I said "this is just how some people at Google made the syntax to be, there's no real reason for it. Someone had to decide on how to do it and that's how it has been decided". Would that be correct in that case? And I also dont understand your answer to the "bonus question". If I have a func like: func one(name string) {} &lt;--- it expects an argument that is of type string, if I pass in a NON-string -&gt; ERROR func two(*name) {} &lt;---- It expects an argument that is of type Pointer, if I pass in a NON-pointer -&gt; ERROR Obviously the Error in the pointer case is not happening. Why not? Shouldn't the compiler complain about this? Seems pretty sloppy, no? 
Go doesn't have pointers. Only references
If you want some pointers, try hitting up r/cplusplus 
They do let you override using [MergeInConfig](https://godoc.org/github.com/spf13/viper#MergeInConfig)
Yes, I took a look at Viper, too. It seems pretty cool for loading config files from various sources. Definitely worth considering when the config is stored in an etcd and for watching config changes That's why I starred the project a while ago. But I could not find anything about merging config files and splitting them again after doing some modifications. 
Oh, I did not see that before. That looks awesome, though.. I will try it out for sure! Thank you for the link.
not the original answerer, but about precedence— take the example `3 * x + 2`. just from how it's written, it's not obvious whether to add 2 to x and then multiply by 2 (`3 * (x + 2)`) or to multiply x by 3 and then add 2 (`(3 * x) + 2`). but PEMDAS teaches us that multiplication comes before addition (or, that it has *higher precedence* than addition). similarly, it's not (by itself) obvious whether to dereference the pointer or call the method first. but in Go, method calls have higher precedence, so that's done first.
Ah ok. That makes sense. So someone had to make the rules and that's what the rules are. No technical aspectg that i just dont know about. Great! Thanks!
OK I will definitely have to look for simple examples. Unfortunately most examples are so pointless that it's hard to grasp what interfaces really do. But I'll just live with that now. I think I have understood enough about interfaces to be able to know when I'd actually need one. Once that time comes I'll look into it! Thanks for your help!!
Well, I have a command that allows to change the config, so I need to modify the config at runtime and write it back to the filesystem afterwards. So, I thought instead of maintaining two config instances at runtime and having to check where the field is specified (in overwrite or regular config) wherever the config is changed throughout the program logic, it would be easier to have just one merged config at runtime, modify that within the program logic and then split it again before saving it to the filesystem. That might not be a common pattern, but it seemed pretty intuitive to use (simply having a GetMergedConfig(), SaveMergedConfig() and hiding the merge/split complexity within a configutil package).
I guess you could just put your username and password in the url like `res, err := http.Get("http://username:password@domain.com")`.
Figure out how you would build it in node, then figure out each replacement in go. It's ok for your first project in go to look like you were writing it in js. When you hit a blocker, that's a good place to ask questions, otherwise your questions are too broad for anyone to help you.
If you're into simplistic integration testing on kubernetes you might want to look into https://github.com/jensneuse/kube-utils
Something that integrates with a docker ready check might work.
Write some code
I did not understand interfaces in the beginning either one day you'll understand them and you will love them
Thanks for the suggestion - will have a good look at it :)
Haha, thanks so much for taking the time and letting me know. I will remain positive/hopeful that this will happen some day with me also! :-)
Plain text auth is a security practice that was bad 20 years ago and is still bad today... 
For me it went, fumble through using an existing interface with existing structs, satisfy an existing interface (for me it was reader/writer because they are super useful), then I started making my own
&gt; the book covers everything o i have to check the docs too? Both. Always. No matter what book you buy, no matter the language. Make it a habit to RTFM even after you RTFB. That being said, the book is a HUGE value for the money to buy &amp; time to read it. Get it already.
Regarding your point about not using interfaces: you could make an interface with all the functions and also make a strict with no fields which implements all the methods. This strict can be composed into other structs to allow them to “inherit” the methods. Another way you could do it would be to define an interface for each method and before calling them, check that it is a member of that interface.
This gets you close to what you need: [https://github.com/zpatrick/go-config](https://github.com/zpatrick/go-config)
Martin Fowler's Patterns of Enterprise Application architecture. I found Robert Martin to communicate patterns very badly with only one concrete example that I found to simplistic to convey good architecture patterns. Martin Fowler's book is much better IMO with good examples and less waffle between useful information.
I'm about to use an approach like this to build a project. I'll have domain types in the top level package then a "mysql" package to implement the "UserRepository" and "BlogRepository" interfaces. What is the best way to make a concrete implementation of multiple repositories? Is it best to make one "Storage" struct that satisfies all of the domain types interfaces like in [this](https://github.com/katzien/go-structure-examples/blob/master/domain-hex/pkg/storage/memory/repository.go) file?
mock code incoming: https://play.golang.org/p/1sgBB6QRf9N ``` package main import ( "fmt" "net/http" ) type BasicAuthRoundTripper struct { Username string Password string RoundTripper http.RoundTripper } // net/http.RoundTripper just requires this one function func (rt *BasicAuthRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) { // Modify incoming request however you need it. req.SetBasicAuth(rt.Username, rt.Password) // Pass on to the real RoundTripper return rt.RoundTripper.RoundTrip(req) } func main() { c := http.Client{ Transport: &amp;BasicAuthRoundTripper{Username: "foo", Password: "bar", RoundTripper: http.DefaultTransport}, } req, err := c.Get("http://example.com") fmt.Printf("%v, %v\n", req, err) } ```
from `net/http` pkg `req, _ := http.NewRequest(method, url, body)` `req.SetBasicAuth(username, password)` `resp, _ = http.DefaultClient.Do(req)`
I was going to suggest this too but as the OP wants to modify the config in their code then I don't think jsonnet will work for them. The jsonnet API is too basic to manipulate config files.
Go passes by value. You are not passing the age, you are acting on it directly. If you'd add a receiver function for person or "func add105ToAge" then you'd need to pass by reference for the addition to work.
What’s wrong with using env vars? 
Why not use a KV service like Consul or etcd? Combine this with something like Hashicorp Vault and you have a powerful config and secret management stack.
&gt; If you pass the variable into a function the function normally receives a copy of the value as opposed to the actual variable Ahhh OK. I did not know that! Thanks!
Variables are always copied by value at function boundaries in Go, so when passing data to a function, you must use a pointer if you want to update the underlying memory. The exceptions to this are: slices, maps and channels.
I will give this a watch after I am off work and home again. I am starting something fresh to learn the plugin system and try it out. I stumbled upon plugins this morning while looking for something else. Honestly I don't know if I will use it moving forward but I think it's worth learning.
You're welcome, I hope I didn't mislead you as I am also very new with Go.
I'm afraid I have some follow-up questions. I don't have a CS background, so I'm having a hard time with the lingo: &gt;at function boundaries in Go What are function boundaries? You mean function arguments? &gt;Variables are always copied by value I hear that a lot, but what does this mean? What does "copying a variable mean"? And what does "copying by value" mean? What else could I copy it by if not value? Sorry if these are ridiculous questions 
Copying happens when you assign one variable to another, or pass a variable as a parameter to a function. Imagine a variable as a piece of paper. Assigning a value to a variable is like writing a number on that piece of paper. What "pass-by-value" means is that when one function calls another, you can't pass pieces of paper from one to the other. Instead, you have to read the number on a piece of paper held by the calling function and write it on a piece of paper held by the called function. This is the copying people are talking about. If variables are pieces of paper with numbers written on them, then a pointer is a number representing a location. Picture a big wall of cubbies. In each cubby, there's a piece of paper. You can't take the paper out of the cubby, but you can read what it says and write something new on it. If you want to share the same piece of paper between a calling function and a called function, that piece of paper needs to be in a cubby. The calling function has the cubby number written on a piece of paper it is holding, and when it calls a function, you can read that cubby number and write it on a piece of paper held by the called function, then it can go to the cubby associated with that cubby number and read and write on the piece of paper there. This allows both the calling function and the called function to have access to the same variable rather than only to separate copies. I don't know if this helps. Attempts to explain pointers often end up more complicated than pointers themselves actually are 😉 
&gt; Go passes by value I have heard this a lot. But what EXACTLY does that mean? In laymans terms? Can you give a simple example? 
I really like env vars for services. I always use a Config to and read it at startup to avoid having env var access scattered everywhere. Config fields let you lean on the compiler, rather than reading an env var that was incorrectly spelled 30 levels deep. ``` func main() { // alternatively, return an error as well if config is not valid config := somepackage.NewConfig() // maybe setup heavy dependencies here, DB's etc. // ... // pass in config, and/or heavy dependencies (cheap DI) service := somepackage.NewService(config) // ... } ``` If I'm running in a Lambda function, the env var story isn't as nice, so I use a JSON config file. I'll either bundle the config file in the package (if not too sensitive), or put the config in S3 (more likely). At startup the function pulls the config file from the S3 bucket and unmarshals it into the Config. I end up with the flexibility to run "local" using env vars, or as a Lambda function via JSON config.
Ahhhh that totally makes sense! Wow, thanks so much for your detailed answer! So it's like borrowing in Rust. I can't believe I didn't get to that myself! So just one more question: Why would I ever use a value Receiver then? A Pointer is always going to be faster than copying. Even if you just want to read a variable and not mutate it. I guess if you're super afraid that a variable gets mutated, value receivers make sense, but if (accidental) mutation isn't your concern, why use value receivers?
You're correct, it's usually recommended to have all methods take pointer receivers, unless you have a good reason not to. There's no downside to it (that I know of).
Ha, making a correct logical conclusion. :-) I'm getting better at Go every day. Thanks so much for your help!
I use it now almost for everything. Think of how great it is to develop on a mac and compile a linux binary on your laptop and have it run on any linux server with no issues. No need to say oh I need to install this python library. I also use go heavily for simple API services since the `http` library is so complete, you don't need to front it with nginx. A lot of the tooling you use is also in go lately. Anything hashicorp an docker to name a few.
I'm also learning Rust at the moment so I'm familiar with Pointers. What confuses me about Golang is the "unexplicitness" with which it handles Pointers. I often don't even have to pass a pointer as an argument, but just the normal variable and the compiler just automatically takes what it thinks is right. Doesn't really help with learning what exactly is going on. So just one more question: Why would the creators of Go choose pass-by-value instead of pass-by-reference? Passing by reference would be faster, no? But then you'd probably have to explicitly mark variables as mutable just like in Rust. Or is there another/better reason for this?
I'm coming from a Python background as well and the cool thing about go is that it compiles so quickly there really isn't much difference compared to a Python script. (I'm sure there is, but it's so minimal that it really doesn't matter) But other than Python, Go is statically typed and because of this Go catches a lot more errors during compilation. Which I cannot commend enough! 
That's what I do in [this project](https://github.com/mickael-kerjean/nuage) and it works great. &gt; Are there any obstacles, tools 1) It takes 5 minutes just to setup your environment (tmux is your friend to make it better) as I find myself with a lot of terminal open: - react test - golang test - server - js compilation - go compilation Unfortunately the default go tools can't watch your change and all the golang program have to be restart manually upon changes which is a pain that will force you to spend time building your own wrapper &gt; Are there any .... libraries A lot but wether you should use them is the big question: - stdlib - github.com/stretchr/testify
There is a downside. Once you take the pointer of a value then it might (if compile-time escape analysis can't prove otherwise) need to be allocated on the heap, and then gc'ed later. If your value is small and you don't need to mutate it, passing by value can end up faster. Profile it.
No problem. If you're going to be programming in any language, it's probably a good idea to learn a bit about how memory works, like the heap vs the stack and how programs use them. Go hides these from you for the most part, and so do most scripting languages, but you can't really reason about the performance of a program without understanding how it uses memory.
@jpco covered precedence as well as I could. Yes the \* is the operator in this case. 3) I have a pointer, and I want it mutated. In order to change the pointer I have to write to it, and to write to it I have to have its address --- a pointer to the pointer. bonus) No error because that is how the language is defined. See the language specification. It's not sloppy, it's how go is defined to work (and that is probably so because it's useful and not ambiguous to call methods of \*T on a T which is addressable).
I fully agree and I even understand the memory/stack/heap background. The problem I have is that Go is not very explicit in that regard. In Rust this is handled way more explicitly = easier for me. 
That seems extremely over-engineered for the task, unless I misunderstood the requirement. So you have a screen that let's you set new config values, then apply them. Ok, so after gathering up the results of the UI when they click apply, you have a simple dictionary of keys (configs that changed) and values (their new value). Pass that map down into your `ConfigWrapper`, whatever it is, as `saveNewEntries()` or something. That class updates its internal cache (if you need these changes to be used right away) and then offloads the work of writing to disk to a background thread via a `ConfigIo` type class. Or am I not understanding the requirement?
You know how to make a http request? then i don't see what obstacle you are talking about. In fact, what the client looks like shouldn't matter.
Develop a concept and start working on that! While you are developing, try to follow Go's best practices, coding standards, guidelines, project structure. See how other gophers are doing try to follow them. Daily visit Golang subreddit that will remain acquainted with the what's going on in the community. If everything goes well, by the time your project is finished, you will be able to see yourself as a gopher who has enough knowledge about the language! &amp;#x200B; Hope that helps!
I taught myself go on the job by writing small projects in it, making sure to write tests as well. * Utility to manage lifecycle of GCP images according to configured rules * Reimplemented kafkacat in go with some features specific to our needs * Super simple autoscaler for GCP managed instance groups to not pay for Stackdriver (WIP) * Daemon that fetches a list of IP addresses and adds them to the default network interface and also sets up iptables rules for the new addresses. Anything that's small and self-contained is a great target to be written in Go for practice.
I should have said "passed by value" rather than "copied by value", slip of the tongue - when passing a variable to a function, the value (the data) of the variable is copied to new memory, which is only valid inside the function. So, when you operate on the value after it's passed to a function, you're operating on a different copy to the one outside the function. By using a pointer, you get access to the original memory location (the _pointer_ value still copied, but it is just the memory address and type of the original variable), and so you can make changes to the data outside the function.
Because it is the only way to get faster binaries?
False dichotomy?
I meant improve
Nice article thanks for sharing also I had no idea about grpc very cool.
Maybe you need some unit tests also.
Last time I check, they want to [init-time CPU and memory usage](https://github.com/golang/go/issues/26775) and working on webassembly.
Hopefully this explains it. https://medium.com/@snippet22/reader-types-2ba61290a5cf Here are more resources. https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk
Most welcome. :-):-)
Agreed. I work with a lot of cloud technologies that all have http APIs and being able to use go is nice, especially being there is usually a nice library already created by someone to interact with that particular API using go.
There are already a lot of answers, and I may have missed one or two answers, but I am missing another reason for pointer receivers besides the pass-by-value vs pass-by-pointer reason. Your code example only works when all code is within the same package. Imagine that you want to write a library that exposes the struct without exposing its fields. (You would do that by writing "Person" with an uppercase P, like so: `type Person struct`. Now any code outside your library package can create a `Person` struct but cannot access the fields inside. This is useful for controlling access to the fields. However, now you need a way to allow your lbrary client to modify the fields in a controlled way (for example, clients should not be able to set a negative age, or an age above, say, 150 (I don't know of any person that ever came near that age)). This is where you need methods with a pointer receiver. They allow modifying your struct across package boundaries.
It's not pure golang but it looks like someone is working on bindings for openFrameworks https://github.com/danomatika/swig-openframeworks
I very much want to use https://github.com/google/filament from go
I love the design of your website, the content is also pretty awesome
The only gripe I have with viper is that keys are case insensitive, this leads to the keys in a hashmap being set to lower case even if that’s not how they are in the config. Really wish there was a way to turn that off.
Awesome, thanks!
Not going to be used public and yes its over https, thanks for concern though. 
Dude, awesome. Thanks! 
I'm not sure, but I hear they are working on loop rolling and common subexpression duplication to help facilitate this goal. If they can incorporate dead code synthesis they may achieve it.
Hey. I've built the basics of a ProgressQuest type of RPG but with no front-end. But that doesn't matter, since the front-end could be anything. The server is an API which performs things in ticks. Hopefully it's some help at least on where and how to start building things with Go. It's pretty simple with no fancy pants things. :) It's located here: https://github.com/Skarlso/goprogressquest
You probably already use it but for someone lurking who is not in the know: A simple shell script can setup a tmux session with all the mentioned processes running in multiple panes and windows with a single command. I use this for every project and it really allows me to start working and switch between projects (AKA tmux sessions) in the blink of an eye.
This is true. Go allocates things on the stack(very fast) if it can prove that a reference to the object does not escape the function. If it cannot prove that(eg. you pass around a pointer to it) it will have to allocate it in the heap and let the garbage collector track and remove it. For small programs it doesn't matter, for large performance-critical programs it might matter.
Others have mostly answered your question, but still my 2c. If you call a function go has to give the arguments to it in some form. It may do so using a value(read: copy) or a reference(read: shortcut). If it passes by value it just copies the argument to another location in memory and gives that new value to the function. If you change the value in the callee the value will not be changed in the caller because it has the original value in the original memory location. This is good since the go compiler has a greater chance of proving that the value in the caller is not referenced from outside it, so it can allocate it on the stack, which is very fast to allocate and remove - no gc required. This might be slower than pass-by-reference when the copied arguments are large structs. If a value is passed by reference then a few things happen: 1) The memory \_location\_ of the original value is given to the callee, which means any change it makes to it will be seen in the value held by the caller since the caller is reading the value from that memory location. 2) The compiler probably cannot prove that it is safe to store the original value on the stack so it will allocate it on the heap, which is slow and the gc has to track it. &amp;#x200B;
[removed]
How do you handle dynamic queries? For example filtering based on user input etc. Concatenating strings isn't exactly fun. query = "select * from person where id=?" values = []interface{id} if foo { query += " WHERE foo=?" values = append(values, foo) } if bar { query += " WHERE bar=?" values = append(values, bar) } db.Get(&amp;person, query, values...)
I'll have a look. Thanks!
For Go v1.11, binaries are statically linked, tested on a go binary named \`hello\` `$ file hello` `hello: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked, not stripped` `$ ldd hello` `not a dynamic executable` &amp;#x200B; &amp;#x200B;
This needs more product documentation. Perhaps a running demo?
A small proxy that doesn’t allow mutating posts is usually fast to write. 
Or you could explicitly enable a demo mode. 
I haven't really been keeping up with the modules thing. That was easy!
Or provide a "default state machine" which people embed into their state machine structs. ``` type StateMachine interface { void Enter(); void Update(); void Exit(); } type DefaultStateMachine struct {} void (dsm *DefaultStateMachine) Enter() {} void (dsm *DefaultStateMachine) Update() {} void (dsm *DefaultStateMachine) Exit() {} ... (meanwhile in another package) ... type UserStateMachine struct { gofsm.DefaultStateMachine } void (usm *UserStateMachine) Update() { // User code here, adheres to the interface without forcing methods, etc. } ```
I do have some utilities to do that, along with sqlx’s named queries the whole thing is slightly better managed. You can check out https://github.com/titpetric/factory (database.go and related test file).
Hi, why do you find this useful ? Most people just use regular HTTP routers.
I really liked this one. I think it neatly solves the problems I was having with my 'gnarly mvc' approach.
You used to have to use "condition: service_healthy" and a service health check in compose.
Why is it a problem how it's stored internally? Doesn't it let you pull out the values case insensitively too? Do you have a ligit case for having keys that are duplicates when case insensitive? (serious questions. Just trying to understand what your issue is.)
Sweet, very interesting even for a beginner!
Hi, thanks for the library. I'm reading the doc and it feels like this is what I need. I'm a beginner in parsing so pardon my stupid questions. I'm trying to parse simple expressions like:- a = function_call(a, "b", "c") or function_call("a", "b") or function_call("a", "b", "c") and support unary operator like:- !function_call("a") So far, I'm stuck on just trying to parse the function call. Here is what I have so far. package main import ( "os" "github.com/alecthomas/participle" "github.com/alecthomas/participle/lexer" "github.com/alecthomas/repr" "github.com/davecgh/go-spew/spew" ) var iniLexer = lexer.Must(lexer.Regexp( `(?m)` + `(\s+)` + `|(^[#;].*$)` + `|(?P&lt;Ident&gt;[a-zA-Z][a-zA-Z_\d]*)` + `|(?P&lt;String&gt;"(?:\\.|[^"])*")` + `|(?P&lt;Lparen&gt;[\(])` + `|(?P&lt;Rparen&gt;[\)])` + `|(?P&lt;Comma&gt;[,])`, )) type Expression struct { Function *string `@Ident` Lparen *string `@Lparen` Args *Args `{ @@ }` Rparen *string `@Rparen` } type Args struct { Arg *string `@Ident | @String` Comma *string `{ @Comma }` More []*Args `{ @@ }` } func main() { parser, err := participle.Build(&amp;Expression{}, participle.Lexer(iniLexer), participle.Unquote(iniLexer, "String")) if err != nil { panic(err) } myAST := &amp;Expression{} err = parser.Parse(os.Stdin, myAST) if err != nil { panic(err) } repr.Println(myAST, repr.Indent(" "), repr.OmitEmpty(true)) spew.Dump(myAST) } I want `Args` to be a list but what I did is something far from what I want. &amp;main.Expression{ Function: &amp;"contains", Lparen: &amp;"(", Args: &amp;main.Args{ Arg: &amp;"a", Comma: &amp;",", More: []*main.Args{ &amp;main.Args{ Arg: &amp;"b", }, }, }, Rparen: &amp;")", } Can you help with finding out what I'm doing fundamentally wrong? 
keep in mind draw doesn't draw to the screen. to use it efficiently for creative pursuits you would need to have some other program open, watching a file that you write to or something that displays the new image when the file changes. &amp;#x200B; it would be cool if the standard library included something like SDL2! &amp;#x200B;
Isn't it just because you are ranging the channel after you closed it?
You defined an unbuffered channel: fooVal := make(chan int) and then you are trying to send values to that channel but that's not possible because no one is reading on that channel to "drain" it. You need to start the channel reading in another go-routine before starting to send values to it. `package main` `import (` `"fmt"` `"sync"` `)` &amp;#x200B; `var wg sync.WaitGroup` `func foo(c chan int, someValue int) {` `defer wg.Done()` `c &lt;- someValue * 5` `}` `func main() {` `fooVal := make(chan int)` `go func() {` `for item := range fooVal {` `fmt.Println(item)` `}` `}()` &amp;#x200B; `for i := 0; i &lt; 10; i++ {` `wg.Add(1)` `go foo(fooVal, i)` `}` `wg.Wait()` `close(fooVal)` `}` &amp;#x200B; &amp;#x200B; 
&gt; That is not "a reason to remove it". The default is always "do nothing". If it amounts to technical debt and we have to chance to remove it since we're not bound to compatibility guarantees and we have a mechanical translation option, then yes, I stand by my point that it is a _very_ good reason to remove it. &gt; You can get one without the other. My prediction is that the stdlib will become a versioned module I'm sure someone will come up with v1-v2 polyfills if mechanical translation is not available and no backwards compatibility is provided. But I was talking about v2 exclusively, so I don't see the point of mentioning this.
Isn't that why `dep` was created?
Yeah, that was my first point
For logging on servers I like to use ElasticSearch and Kibana, the app itself is deployed as a common executable. Telemetry, performance statistics and logs are stored inside ElasticSearch 
&gt; I'm sure someone will come up with v1-v2 polyfills if mechanical translation is not available Even if it is, it will be necessary for both v1 and v2 versions of the same package to exist. There is a bunch of discussion [on Russ Cox' homepage](https://research.swtch.com/vgo-import) as to why. Either way. I'd take almost any bet, that a) the builtin functions won't be removed (or touched at all), b) the stdlib will be released as versioned modules able to coexist in both v1 and v2 and c) that there won't be any actual breaking changes - that is, code build for Go 1 will continue to work just fine, without any migration work (automated or not). I guess only time will tell whether that's a good bet ¯\\\_(ツ)\_/¯ 
I think you may like it a lot. The standard library covers a lot of ground, things you wouldn't expect like CSV parsing are all built in. The language is simple so it is quick to learn, compiles fast, good runtime performance. Just deploy the EXE don't have to deploy the right version of python along with your script. &amp;#x200B;
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/u_wintercat2018] [Goroutines - getting a deadlock even though I think I did everything correctly. Please have a look](https://www.reddit.com/r/u_wintercat2018/comments/9j2nkw/goroutines_getting_a_deadlock_even_though_i_think/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Hmmm OK so let me just try to make sure I really understood this: A (unbuffered) channel can only hold 1 item at a time? So I need to read that value "out of" the channel and then I can put another item into it? Is that correct? (I know it is phrased noobish-ly but just stick with me for now) And when I create a buffered channel with a buffer size of 10 I can put 10 items into it and then iterate over them? 
Have a look at some of the examples, parsing into a list is in there. If you’re still having trouble jump in my Gitter channel. I’ll be online in ~9 hours or so.
I think this is the most recent talk about the GC (and the compiler work to make it happen): https://blog.golang.org/ismmkeynote There's always talk in the issues and go-review about improving escape analysis and BCE; then there's the long-standing improvements to the inliner (mid-stack inlining and the like). Then, speculatively, whatever is required for "go2"
Does the AST produced by the ast import tool and the ast viewed by the SSA passes differ or are they the same?
Yes, I've looked at your examples, especially the toml one which has list example. I think I've made some progress, eventually got the list working but now I get an error while executing the code itself but I think, I've got it closer to what I want. https://gist.github.com/shadyabhi/f14850721f08831ef1844729c08167a7
Docker, specifically kubernetes but it's not a hard requirement. We turn on log rotation for all our containers. For our bigger systems we use logstash and elasticsearch to collect/centralize all the logs
Then how do you avoid having multiple sql.DB objects? Each concrete implementation of your domain type service interfaces has its own connection pool to the database? ` type PostgresUserStorage struct { DB *sql.DB } // CRUD methods for USERS into a POSTGRES database. ` type PostgresBlogStorage struct { DB *sql.DB } // CRUD methods for BLOGS into a POSTGRES database. `
Actually, thanks for the Gitter link. I'll post my query there. You can discard the query on Reddit. Thanks a lot in advance. 
Can you provide your systemd service file example?
This is how I do it too. I like Kelsey Hightowers EnvConfig package, because it does exactly this. Reads in environment variables into a struct. Nothing fancier than that is usually needed for my projects.
You may want to change the name [https://signal.org/](https://signal.org/)
I acknowledge, the problem is that there already a lot of names that are already taken and I do not want to restrict to some weird or intentionaly misstyped names. I think signal is a good name for an analytics project (because we extract signal from noise), so if SEO become important, it will be on the 'signal analytics' terms
Haven't tried running it, but it seems that with the way you use the the library that gives you the connection to the docker daemon I cannot run it on my machine since I don't have the specified environment variables exposed on my dev machine. Also you're simplifying the docker layer so much, that you lock out people that are using private docker registries, as you're setting an empty docker authentication when pulling the image. I like the idea though.
I have always wondered why dockertest didn't implement the probing itself, that's the only reason I never wanted to use it.
Yep. All repositories (may) share the same *sql.DB. I've only used this patterns with a few microsevices, so your approach may have it's benefits when you have a lot of repositories, but I haven't reached that part yet, that's ehy maybe I find this approach better.
Look at the [setup.sh](https://setup.sh) and [service.sh](https://service.sh) scripts in this repo. [https://github.com/averagesecurityguy/scrape](https://github.com/averagesecurityguy/scrape). I log to stdout and redirect stdout to the log file I want.
&gt; With pulseaudio (Linux only) Correction: [PulseAudio](http://pulseaudio.org/) is "for POSIX OSes" and in addition to Linux is "tested on Solaris, FreeBSD, NetBSD, MacOS X, Windows 2000 and Windows XP." (quoted from http://pulseaudio.org/).
IIRC the compiler has an internal/forked version of the AST and parser because they needed to make changes that would have broken the 1.0 compatibility promise.
I came across these the other day, maybe it will help. [https://mlesniak.com/post/2018/09/13/go-guitar-/-visualize-sound/](https://mlesniak.com/post/2018/09/13/go-guitar-/-visualize-sound/) [https://github.com/mlesniak/go-guitar](https://github.com/mlesniak/go-guitar)
To go with what /u/thomasnomas said, reading the title of this, I assumed it was a source analysis of Signal, using something you wrote in Go, mostly because you used "signal" and "privacy" in the same sentence. If you want to avoid the SEO issue, I'd avoid "privacy", at least without the context in comparison to Google Analytics.
You might find these two posts useful (read in the indicated order): 1. https://dave.cheney.net/2017/04/26/understand-go-pointers-in-less-than-800-words-or-your-money-back 2. https://dave.cheney.net/2017/04/29/there-is-no-pass-by-reference-in-go 3, https://dave.cheney.net/2017/04/30/if-a-map-isnt-a-reference-variable-what-is-it 
[client9/misspell](https://github.com/client9/misspell) might be a start.
What environment variables are you talking about? There is a function to expose necessary environment variables, such as the MYSQL\_HOST ect.. &amp;#x200B; As long as your machine have access to the specific image you specify there shouldn't be any issues :)
I use(d) runit [1] in both my previous and current jobs. It's pretty straightforward, here are some example scripts [2]. [1] http://smarden.org/runit/ [2] http://smarden.org/runit/runscripts.html
I'm talking about DOCKER_HOST because your underlying library defines a function dockerFromEnv or similar (on mobile right now) that is connecting to the docker API via these values which you use to initialize docker. Nothing to do with the containers that one wants to use but how your library is using the other docker library.
:D Let me know if there are any questions
You will see the most visible difference between pointers and values when you pass them as parameters to functions and as method receivers. Here is a slight modification to your example that highlights the issue. [https://play.golang.org/p/5C7MOsWAcVd](https://play.golang.org/p/5C7MOsWAcVd)
ack for the privacy part, thank you for the explanation, I think I didn't capture the essence of the [/u/thomasnomas](https://www.reddit.com/u/thomasnomas)'s comment
If I were the Signal team I would probably sue you for trademark infringement. This is close enough that it's confusing. And honestly a bit misleading. "Privacy oriented analytics" is almost a contradiction in terms. I mean it's great that you're getting the data out of Google or Adobe or whoever's hands, but it's spyware.
This looks very interesting. Thanks!
I use a lot of go-kit (It's sort of a pick and choose pack of packages) with a `gorilla/mux` router setup. It's not incompatible, and in fact go-kit's readme links to Gorilla and some of the examples in the repo use mux (iirc).
I use systemd as well. I used [the service file from Caddy](https://github.com/mholt/caddy/tree/master/dist/init/linux-systemd) as my base.
I use systemd as well. I used [the service file from Caddy](https://github.com/mholt/caddy/tree/master/dist/init/linux-systemd) as my base.
Analytics fundamental goal is not to spy on users, it's to help teams to understand how their users use products. I believe that giving away users' data to internet giants who will track and spy users is really bad, but we can have analytics solutions which respect users and enable teams to gain insights from users patterns. It's the Signal goal. I understand that using the word privacy was maybe not the best idea given the existence of signal messenger, But I doubt that there is any reason to sue anybody.
[removed]
Like others have said, a send on an unbuffered channel blocks until something can receive it. Thus each of your sends (`c &lt;- thing`) blocks, and `defer wg.Done()` doesn't get called, so `wg.Wait()` waits forever. You can fix this in at least two ways, all of which are basically the same since you know how many things you're going to send on the channel: (1) Make a buffered channel: `fooval := make(chan int, 10)`. Note that this makes you wait _until you've sent the last message_ before you begin processing any of them (the way you've set things up; this does not generally follow from using buffered channels). (2) Count how many things you've gotten and stop receiving once you've gotten all of them: ``` for i := 0; i &lt; 10; i++ { val := &lt;- fooval // do things with val } This makes you begin processing the messages you're sent as soon as any of them are ready.
[removed]
Thanks so much for your explanation but I think this is still over my head. I will have to look into more examples and learn more first. Thanks though!
You are waiting for goroutines to finish while they are locked writing. &amp;#x200B; If you want to collect data either use a buffered channel with the capacity of spawned goroutines or collect it in an array/slice before wg.Wait.
Thanks for the explanation. So does that mean that bascially no one ever uses unbuffered channel because what's the point of concurrency if you can only hold ONE SINGLE value? Am I correct here?
This is all so complicated. I still need to wrap my head around all this. Just one question for now. What is the difference between: 1. defining a normal func and then calling it like "go do_stuff() 2. go func() {logic_goes_here} Is this just another way of writing it or is there a fundamental difference to it when it comes to goroutines?
Second version is just an anonymous function, nothing else. There's no difference regarding the executed goroutine. However your syntax in 2. is not correct. go needs a function call not a function declaration so it would be `go func() { ... }()`
Actually the unbuffered channel doesn't hold any item until you read from it. So basically what's happening is: https://play.golang.org/p/3XM3_UjSkrm I hope you it's descriptive enough. 
Ahhh thats a very good and easy example. Thank you so much! What is this concept of variables just floating around in Golang without being saved anywhere? I know Python well and I know a little Rust. And in neither languages do items of any kind just float around until they're read. That's what totally confuses me. I thought that a channel is basically just a slice. and whenever I send something to a channel it's basically just another entry added to a slice. It doesnt matter if any other function has been reading from it or not. It just gets added to the slice. However that doesn't seem to be the case AT ALL!?!? Apparently this is some super weird Schrödinger's type. WHAT IS a channel? Why isn't a channel just a slice/list/Vector/Array? What is the concept of this called? Some sort of Streaming type? And why does it need a receiver? Why cant it just store values? Who cares if any receiver is reading those messages? Why cant it just store all messages and once it has saved all of them we can work with it or iterate over them, etc. I'm so confused about this. It's not that I don't understand certain syntax, but I dont understand the logic behind this. Even Rust - which is quite a bit more complicated - just saves stuff like this in a Vector and then you iterate over it. No weird receiver necessary. What's the point of it? (If this is too complicated to explain, it's fine if you just offer me some buzzwords that I can google. But I really need to understand what type of variable it is that can only exist if another function read it. This is literally quantum mechanics!!) 
Perhaps this blog can help you. It visualizes channel interaction.
Don't know Rust so I can't compare them. I think what's important is that slices and channels just fulfill different purposes. Slices hold data whereas channels are thought of application control flow mechanism. The main part of channels isn't that you can "store"/"send" data with it, but to provide communication means for concurrent execution.
I know this is a bit late, but for any else needing a clear answer: &gt; Typically the go.sum file should be checked in along with the go.mod file. From &lt;https://github.com/golang/go/wiki/Modules#releasing-modules-all-versions&gt;
Trademark infringement.
Nice work! Another gotcha of go's JSON package I encountered before was how it handles `[]byte`. It converts `[]byte` to base64 string, which is a very reasonable design choice. But it also means that if you are passing around a huge `[]byte` blob via JSON, the memory footprint would be very bad and you should think twice if JSON is the right choice here. [I wrote about it before](https://wang.yuxuan.org/blog/item/2017/02/some-go-memory-notes).
&gt; Not going to be used public That's what you think. Anyone on your local LAN can do anything they like. Even the folks you don't know are there.
This is working as intended. You can only import modules (aka directories) not individual files, Go is not like other languages that consider a file a module, to Go the whole directory is a module. And as such most Go modules are written with functionality spread across multiple files and you cannot just pull in a single file. If you want to separate functionality and import it separately you require different modules (thus directories). 
I appreciate the help, thanks 
This is simply the go version of the protocol that's been used by several companies.
You can create systemd service files. I have a tutorial on this here: https://www.devdungeon.com/content/creating-systemd-service-files
[removed]
&gt;e You might as well just transpile from other languages to the standard Go AST and then execute the compiler on it.
Now I know what my next fibonacci based project will use!
Hey. Would love an example somewhere to get started. Thanks!
That's the complete opposite from what the repo shows. Go performs worse than virtually all other languages that compile to native code if its using the same algorithm as everything else.
Without seeing the actual error, I'm going to assume this is because `name` is unexported (read: lowercase). Use `Name` in the source and target files instead 
Thanks for the hint, I am literally doing exactly that. 
Well same thing as above a method getOrmObject is unexported. Try naming it GetOrmObject
I haven't seen it mentioned yet but Todd McLeod has a Go web course as well. Is there any merit to taking Girders course after McLeod?
It's pretty radical.
But memorization is easily done just as Crystal can get to the same speed
Other than the fact that it's written in go, how does it compare to something like ownCloud or NextCloud? 
Just a quick note to hopefully ward off confusion. The term is package, for all code in a directory. Modules are a new and different thing, being a collection of packages (what we'd generally think of as a git repo of code).
It seems like *someone* is being trolled here.
Unless I'm sorely mistaken, channels are just thread-safe message queues. Which have existed for a very long.
I made a simple "deployserver" program that I usually run on a server first. it has a web interface and handles creating systemd scripts and uploading/updating the executable and any other files. after the app is running the deployserver is shutdown until something needs updating. Great for updating go apps since it handles compressed files and the executables are usually fairly large.
True, but golang made it simple to use
Golang gob encoder can handle huge blobs
sure but in some json libraries (e.g. Python's built-in json library) they will reject binary blobs so people won't even try. 
Not sure I understand? 
I wouldn’t compare them like that, it has lesser of footprint; and then there are buffered channels. It’s apples and oranges both of them are definitely FIFO and thread safe, but that doesn’t mean we can compare.