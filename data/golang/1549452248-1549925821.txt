`addCommand()` is a false abstraction. There isn't much difference between: ``` addCommand("jump", doJump) ``` and ``` commands["jump"] = doJump() ``` so in this way, it doesn't help the programmer; it actually makes life a little harder because instead of using a simple language construct like an assignment, the programmer has to remember some function call. when it comes to globals, there's never a good reason to use them; there is always a better alternative. 
Thx Francesc.
Not entirely. Elixir vs Go is probably fine (unless Elixir also has some knobs to tweak). Even with Node we can see that at 10k it uses about the same amount of CPU as Go but latency is significantly worse than both Go and Elixir. At 100k Node is severely limited by one core and that's indeed an invalid test for it.
Interestingly, these hiccups are no longer significant at 100k and it's actually Elixir that looks a bit worse.
lmao, when people talk about goto in the future they will be confused as to why Go 2 was and is considered harmful.
JIT is very powerful, certainly the V8 engine Node’s using... Initial ramp up will be a bit slower - but once all hot paths have been optimised - there’s little reason for it being slower than native compiled languages with similar language-level features (array bounds checks, garbage collection, ...). The only thing that could potentially hold it back is reliance on runtime reflection - which in theory is also possible in Go, but a lot less relied on for basic functionality.
In your `mysubpackage.go`, import as you normally would without 'vendor' in the path of the import statement. When you go to `go build` later (or if Heroku does it for you after pushing), it will favor the dependencies in your project's vendor directory over $GOPATH
There is also hydra which is in Go. &amp;#x200B; [https://www.ory.sh/](https://www.ory.sh/) [https://github.com/ory/hydra](https://github.com/ory/hydra)
The plus about exceptions is that they will get passed up the callstack so you can write a function that can throw from functions it calls that just passes the responsibility of handling them to its caller.
You can edit you .gitconfig to rename the https to ssh for your domain
As long as git can access those repos over ssh, it should work. I have not done any specific configuration when working with private repos. 
As I understand it, the Node HTTP server is actually written in C, so these sorts of "ping" tests do not test Node _qua_ Node. I don't know about Elixir, but either it has something similar or its HTTP server is much simpler than Go's and probably missing compliance with something or other or something, because a pure Elixir or pure Erlang implementation isn't going to keep up with a pure Go server either. This sort of test says something real, which is that in all three languages the overhead of a particular HTTP request is roughly the same, but that's _all_ it says. It says very little about the performance of Node because it's hardly running any Node code, and as I said, I don't know about Elixir, but I know enough about it to seriously doubt it's running a pure Elixir web server of the same quality as net/http. I do know Go's server is actually written in Go, but even then, these sorts of benchmarks can't be taken too seriously because you can radically accelerate the HTTP server by cutting out what it does. I can write a blazingly fast server that will outcompete even nginx on a "ping" benchmark with the following: listen, _ := net.Listen({web port info here}) for { c, _ = listen.Accept() // just straight-up ignore the incoming request c.Write(pongRequestResponse) c.Close() } You'd want to do some benchmarks around whether it's worth spawning goroutines, or using a pool, and whether multiple threads calling accept would be useful, but you get the idea; I can "win" such a contest by not being an HTTP server at all. Hyperspecialized microbenchmarks can be actively harmful if taken too seriously, corners start getting cut.
To be specific, we use BitBucket at work and I have a line like the following in my ~/.gitconfig: [url "ssh://git@bitbucket.company.com:7999"] insteadOf = https://bitbucket.company.com/scm You may have to tweak the paths involved, of course, and, yes, the setting feels backwards, but that's what works.
I don’t think you know as much about elixir/erlang as you think you do. The elixir implementation was using Cowboy, which is written in pure erlang. Elixir and Erlang are incredibly performant languages. I don’t think go is the right choice for building a HTTP server, it’s more useful for DevOps stuff imo.
It’s like that it’s schedulers are kept busy waiting
&gt; let's-make-our-data-type-implement-all-the-typeclasses &gt; what is code generation Sorry, that might be a sore spot around here.
It's actually the opposite. Go is extremely good at that. If anything, the test only proves that. It's CPU efficient, has low memory footprint and very low latency. It's specifically optimized for backend.
So, for starters anyone can give a TL;DR of these benchmarks?
Then it would probably eat all CPU even on 10k connections but it's only like 60-65%. At 100k it maxes out CPU. Even if there's headroom and CPU load is just an artifact of some implementation quirks, it's still eats power for no reason. Wouldn't want to run something like that in a container along side other services.
does this mean that the gae is executing the built go binary? or does it just go run 
I worked in Erlang for six years and implemented the core of an entire product in it. Erlang is not an incredibly performant language at the language level. It is roughly on par with scripting languages. Compare [Erlang vs. Java](https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/erlang.html) to [Erlang vs. Node](https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/hipe-node.html), and compare [Go vs. Node](https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go-node.html) to round it out. If you think it's a really fast language, you _really_ haven't gotten out and about much on the language landscape. These are also microbenchmarks, of course, but they get enough range in there that it's a bit more meaningful, and it reflects my own experience with the langauge. As with Python and Perl and such, it's has plenty of performance for plenty of tasks. I was fully aware of its scripting-language-level performance when I choose it for the core of the product I was building. I chose it because it's VM was rock-solid, and, well, actually I blew out the VM a couple of times for various reasons (large binaries, mostly) but as it happens the Erlang team was always ahead of me and I could fix my problems by upgrading, which was cool. Erlang was and is very good at its task switching, though. If you've got a task that needs to do a crapton of little things, such that the scripting-level performance is no big deal but you need to switch between lots of the little tasks, it's a great choice. When I made the choice, it was the only really great choice. Now Go competes in the same space, and on a strict performance basis, it wins. There are considerations other than strict performance basis. I still wish I could spawn a goroutine in a way that I could guarantee it was isolated from all others, for instance. But on the balance, I choose Go now. But I don't think there's a problem with those who choose Erlang or Elixir. However, those who do so should be aware that they are choosing a lower-performance language and should do the due diligence to ensure that won't be a problem for their task. It is simply part of doing good engineering. Go is not the absolute fastest language either, and there are performance tasks for which it is not well-suited either.
so it can be used to xlsx files?
*Hey just noticed..* it's your **2nd Cakeday** Qizot! ^(hug)
The new error-handling mechanisms being proposed are still _error_-handling mechanisms, making existing patterns easier. The distinguishing characteristic of exception handling, in my opinion, is when you have exceptions being thrown up the stack until "something" finally handles it. The new error proposals do not implement that functionality. The new proposals just make a variety of common error-handling mechanisms easier, and makes it easier to use safe error-handling patterns without having to ensure that you type it out each time (personally, I'm more excited about being able to be _sure_ all my code handles errors correctly than the mere convenience of less keyboard typing; most of my error handling bugs come from "that one case" I didn't quite handle correctly). When it's not the right answer, don't use it and use the existing mechanisms. The essential characteristic of Go's error handling is requiring each stack frame to explicitly do something sensible with errors. The accidental characteristic of a continuous stream of "if err != nil { ... }" being literally present in code is not core to that, it was just the first cut.
You can achieve that by stopping the pool, which will wait all running jobs and cancel all queued jobs. It should be easy to add a .Wait() to wait for running + queued jobs (without canceling queued jobs) but how should this behave ? Block new enqueues until all processing and queued jobs BEFORE .wait() are done OR just wait until the pool is empty ? 
xlsx file format is defined on top of the opc file format, where the opc defines how the package is structured and the xlsx defines how an excel file is marshaled into disk. So this library can be used in a xlsx library that only bothers about xlsx and not opc.
&gt; To simulate a generic web application client and server behavior, we have devised the following synthetic workload. The client device opens a connection and sends 100 requests with 900±10% milliseconds in between each one. The server handles a request by sleeping for 100±10% milliseconds, to simulate a backend database request, and then returns 1 kB of payload. Without additional delays, this results in average connection lifetime of 100 seconds, and average load of 1 request per second, per device. I've never seen such a situation in real life. I'm not an expert, and this is still useful, but it seems like a better test would have been: 1. Have the client-server interaction last somewhere in the normal spectrum of 20ms (simple API) to 1500ms (Wordpress) with possible followup requests (HTTP/2, or HTTP + keep-alive) 2. Have the server actually do some real-work (since that would be the only reason you would have an server to begin with). Almost all servers interact with some sort of store. I would be happy with an in-memory store like memcached/redis, Cassandra, statsd, or a regular RDBMS like PostgreSQL/MariaDB.
The author indicated on HN that he was willing to redo the test with threads for node so we'll see.
https://www.reddit.com/r/elixir/comments/ano8dz/benchmarking_go_vs_node_vs_elixir/efv6the/
You might start here: [https://stackify.com/learn-go-tutorials/](https://stackify.com/learn-go-tutorials/) (Links to 30 tutorials)
Very odd decision. Kinda makes it a no go for many cases. Is there some real metrics like time spent doing stuff or latency that demonstrates the benefit? Googling gives me posts explaining high CPU utilization and speculating that it might do something good but no actual metrics.
Don't understand why you're getting downvoted, this is the correct answer.
Why?
The “elixir http server” is actually written in Erlang and is very full featured. It is known for being very performant and hardened enough to serve edge traffic, fwiw.
Interesting! I'll look into this. I like Go a lot, aside from it's clunky syntax - I like the philosophy and the relatively few (minor) tools that I've built have been enjoyable experiences. And that you can compile down to an executable is really nice.
&gt;Have the server actually do some real-work Which typically dwarfs the amount of time used by the basic web server for normal workloads. I find these synthetic benchmarks pretty silly. The question I usually end up asking is not how fast is the web server, but is the web server fast enough for what we're doing. It usually is regardless of what language or framework.
Could you link the latest proposal you're talking about?
Contrary to /u/cre_ker, I would say it does invalid the test results for Node. Using `cluster` allows one to scale pretty well linearly with thread count available. I'd be very interested in seeing the results with *and without* `cluster` utilized.
What a wrong title.
It can probably be tuned. If we saw a breakdown of System/User/IO CPU utilization metrics then we'll probably see System CPU utilization at uncomfortably high levels (eg: 100% overall CPU utilization with all cores saturated but 70% is System CPU.)
the elixir server is cowboy which is written almost entirely in erlang and is _very_ full featured and performant. the erlang vm is very good at what it does
[removed]
Hi! Reddit is full of assholes. I'm sorry if I come off as one of them now. I genuinely want to provide constructive feedback and here it is: It seems like an unnecessary abstraction. If you have a map and you know the item you want from it, why encode it in the format string? What does: ``` Printf("%user", someMap) ``` buy you that the following doesn't? ``` Printf("%s", someMap["user"]) ``` in what way is my life improved by shifting the key of the map to a format string vs simply fetching the value directly from the map using syntax that i already know and understand? What is the syntax if I want to print a map member adjacent to a non-white space charater like: `"%NameFoo"` were entry I want is `Name` and i want to append `Foo` to it? i think the effort you've put into this is admirable and i imagine it was a great learning experience but i think conceptually, it is not something i'd ever use or see as useful or interesting.
Personally I’m most excited for all the Gopher jokes around Go 4.
Thanks for your feedback! &amp;#x200B; So first of all, the usecase: Lets say you want to let your users specify a time format: you could use strftime for that. (It is like Sprintf, but for dates and times). Besides there are implementations out there, you need something that no strftime implementation supports. So your options are: extend one of the strftime implementations, or roll your own strftime. Both leading to more strftime implementations. And I think for this usecase it would be easier to reimplement strftime using mapprint. &amp;#x200B; Other usecase: let a user run a command trough your application. You don't know what the third party tool wants as a parameter: maybe a unix timestamp, maybe a RFC date. So why not let your user choose, giving them multiple options. &amp;#x200B; To your `%NameFoo` question: I have thought about this as well: Look [here](https://github.com/Eun/mapprint/blob/master/mapprint.go#L117) and [here](https://github.com/Eun/mapprint/blob/master/mapprint_test.go#L327). &amp;#x200B; &amp;#x200B; &amp;#x200B;
Package should have an implementation of [driver.Connector](https://golang.org/pkg/database/sql/driver/#Connector) And then [sql.OpenDB](https://golang.org/pkg/database/sql/#OpenDB) to create the sql.DB.
Regarding strftime: I don't understand your point. Can you restate it? Can you answer why I would use this vs. simply accessing a map member directly? Regarding `%NameFoo` -- right, so your implementation takes the longest match. but there is still some ambiguity there. What if I have this map: ``` stuff := map[string]string { "Name" : "Bob", } ``` with a format string of `"%NameX"`. I'd expect the output to be "BobX". Now what if, over the course of the runtime of my program this entry is added: ``` stuff := map[string]string { "Name" : "Bob", "NameX" : "Steve", } ``` What will the behavior of our string be then? It would be nice if there was a way to make the macros completely unambiguous. For example, you might use something like `%{Name}` or maybe simply `{Name}`. But still, I'm wondering why anyone would bother with this vs. simply referencing the map value directly.
You are right about that key, its an issue, however. I decided to not care about it. If you want to use more complex stuff you should go for a more powerful template system. Another usecase: You have the task to write a application that gives out the current time. However the customer wants to specify it by their own: ```golang package main import ( "os" "fmt" "time" "github.com/Eun/mapprint" ) func main() { now := time.Now() args := os.Args if len(args) &lt;= 1 { fmt.Println(now.String()) return } mapprint.Printf(args[1], map[string]interface{}{ "Second": now.Second(), "Minute": now.Minute(), "Hour": now.Hour(), //... }) } ```
I'm not sure what you're reading into my posts. My claims stands as follows. Python was one of early adopted languages in academia because it was better at handling precision. As well as ease of use. Being there first early allowed it to accumulate huge ecosystem predominately supported by academia. And since fields of big data / AI has reliance on higher mathematics, common web developers or business use cases sort of rely on academic capital in this field, which is predominantly in Python. My second claim was that successor to Python is Julia, not Go. And it won't be Go. Even if Go potentially can be used or can handle things with same level of precision, is irrelevant. You can clench your firsts and asscheeks, close your eyes very strong, turn around 7 times and yell "santa" for a few times up to the skies. Doesn't change a thing. Julia is being adopted, not Go. And when time will come for serious AI / Big data stuff they will turn to academia again. That's not to say that there will be no such applications being done in Go. But it won't be leading the industry. Why you decided to pick on ML floating point precision, I have no idea. Perhaps you're right. Who cares, that's irrelevant anyway.
&gt; lobals in Go are idiomatic and don't introduce the kind of problems that usually attributed to them. No they aren't, and yes they do. https://peter.bourgon.org/blog/2017/06/09/theory-of-modern-go.html
As people have said, editing the .gitconfig will fix the problem on a per machine basis. At my previous company, I had the same problem, but wanted to set it up so that so that Go just worked out of the box for everyone. To do that, I made a very simple vanity server that listened for requests from `go get` and served up the go-import meta tags that tell `go get` where to git clone from. Once I had this server set up at go.my-corp.com, then we just had to change all out import paths from "github.my-corp.com/foo/bar" to "go.my-corp.com/foo/bar" and then everything worked out of the box without needing to update a million .gitconfigs. You could use something like https://godoc.org/rsc.io/go-import-redirector but it's only like [100 lines of code](https://github.com/hawx/vanity/blob/master/vanity.go) to write one yourself. Since you have 2 different internal repos, you probably will probably want to roll you owns so that you can route different requests to different repos. Abstracting the specific repos out of your import paths with will also future-proof you a bit. It will be much easier to seamlessly migrate code from one repo to the other if/when you ever need to.
See also this static site redirector: https://npf.io/2016/10/vanity-imports-with-hugo/
&gt; Both spf13/cobra and stdlib flags are poorly designed insofar as they use globals. Both packages would be improved by removing globals and requiring callers to instantiate an e.g. flag.FlagSet independently in the calling code, and operating on that directly. I have faced this exact problem in few of my personal projects. So, I developed my own, yet another, flag parsing library: http://godoc.org/github.com/bvk/go/fls
Yeah. And if you've bothered to read my post I've explicitly made a distinction between common business use and strategic state level endeavors. Currently we have big 3 new languages which qualify as disruptive technologies. One is obviously, Go, second is Rust and last one is Julia. While Rust occupies different niche, being a systems programming language competing on same level as C, Julia seemingly is similar high level language like Go. However on different focus on the tool-set. Which seemingly reflects that Go and Julia are being adopted in different sectors public / private. That being said, your average programmer is not a mathematician. And while it will be possible to do things in Go, much like it's possible to do same things in Java now, for more dedicated applications Julia will be picked, because that's where all the brains and libs are. Much like now it's the story with Python. So we're not disagreeing on your last point.
&gt; We’ve seen that Go and Elixir demonstrated very similar performance characteristics from a client’s perspective, yet Elixir achieved this result with significantly higher CPU utilization. That's what I'd expect to happen. It looks like it used 7-8x more CPU than Go, which is well within the range of how I'd expect a well-optimized pure-Go solution to compare to a well-optimized pure-Erlang/Elixir solution.
As I say in the reply to cr4d, using 7-8 times more CPU for the same result is about what I'd expect from Erlang/Elixir vs. Go.
Okay... I think I get your point. Good job! Personally, I would use something like the text/template package for something like this. I think the language is better thought out and I would recommend that you adopt a similarly unambiguous language for your macro system. I think what you have is great but I think the language needs work. I hope I've been helpful and keep up the good work.
&gt; func dispatchCommand(... Would strongly suggest panic'ing instead of simply returning if the function isn't called. Indeed, the default behavior of running `commands[command]("")` is probably superior. I think some Go programmers read about the restrictions on panic and accidentally simplify them to "never use panic", but that's not accurate. In this case, you are embedding a dynamic function lookup into your static language (perfectly legal and legit), and you tried to call a function that doesn't exist. Yes, that's a "panic" situation; you just tried to move the instruction pointer to an undefined location. Best not to cover that up. (If you need some sort of optionality, I suggest being explicit about it. One common approach is something like specifying a default thing to be done or returned if there is no function, for instance, which works well.)
Elixir doesn't have knobs to tweak, but there is BEAM, which can be tuned for more performance.
HashiCorp and Comcast?
if you need do that in a containerized way, try this out - https://github.com/anuragdhingra/pdocker-go
ES6 classes are just syntactic sugar for ES5 code, so you’ll need to replicate all the prototype calls it’s making. 
I don’t think using append file mode counts as clever. Not using it is confusing if anything. 
I deal with it differently. It doesn’t work for public CI/CD pipelines like travisci, but does for my workflow. I use a two stage build. All of my private packages are stored under a single virtual URL (eventually I plan on setting up vanity aliases). In the build image, I do a COPY $HOME/go/src/mydomain.com/ /root/go/src/ Then I can build as normal. I put all of my APT and Go Get dependencies on one line BEFORE the copy to take advantage of caching. It’s all available on my local system so I do build locally. I’m moving towards a private CI/CD system so I’ll need to rework it for that. I don’t like secrets in images but I may just need to. I intend to have the repo still private within the lan via aws vpns, but that’s no excuse not to secure it correctly with authentication. 
You don’t just have “a” JavaScript runtime, you have V8 - it compiles JS to assembly on-the-fly. So what’s amazing to me is that Go can compete with that, given how many resources have been poured into optimizing V8. 
The http.Dir trads from a subdirectory ”views” from your vittnet directory. The views folder is not compiled into the binary
How can I read the static files when they are bundled in a binary ?
If your code is at `/go/src/` and you execute `go run .` from that directory, you are instructing `http.Dir()` to look for the “views” folder at `/go/src/views/`. However, if you build the binary at `/go/bin/` and execute it from `/root/` then `http.Dir` will look for the “views” folder at `/root/views/` because that’s how you programmed your program. The solution is to add a flag `-basedir` to indicate the full path where the “views” folder is located, or to use `filepath.Dir()` along with `os.Args[0]` to obtain the directory where the binary is located, in my example this would return `/root/` again. I generally use the first option because I always prefer to be explicit about file paths in my web servers, it’s safer.
I love the built in testing/benchmarking. This is a nice little guide. Thank you. For the next one, you can perhaps cover mocking interfaces, which I find being the most frustrating task ever. 
I think there is a library that you can use, don’t remember the name. I wrote my own library that converts any type of file into a go source file and then I have a custom http handler that reads from that bundled data during runtime. The only files included in a binary is the compiled go source files, any other file in the source directory will just be ignored during build.
Third-ed. I really enjoy errors just being another return value that I can branch against (or whatever). I like failure cases being an explicit, top-level part of the design.
Good idea, will add it to my backlog of blog post ideas.
i disagree with this advice. `panic()` should be avoided -- particularly in this case. when you `panic()`, you basically ask to terminate the program altogether. yes, it can be recovered but you don't assume that is the case. in this case, it seems like a simple command REPL (maybe for a game). issuing an unknown command is not a reason to panic. it'd be best to treat it as an error and return an error up the stack. `panic()` SHOULD in fact be avoided at all cost.
https://jsonapi.org/implementations/#server-libraries-go
Do you have any hands-on experience with one of these? If yes, what did you like / dislike about the lib? Thanks for the link by the way 😀 works better then searching github.
&gt; Do you have any hands-on experience with one of these? [JSON API by Google](https://github.com/google/jsonapi) is used at Mailchimp. I don’t have strong feelings about it though, it just works.
I'm attached to `if err != nil { ... }` because it's simple and explicit. There's no new language construct - just a regular branch. There's no jumping around in the code order. There are no implicit values (like `check`'s "a function call where the last result is an error"). And there's no built-up stack of handlers that must be read in reverse order to figure out what a function does. The Go 2 draft is better than anything I could come up with to satisfy the same constraints, but I'm still on the fence about whether or not it's worth adding 2 new keywords to the language.
&gt; there’s little reason for it being slower than native compiled languages But there is. E.g., in Go, you can know the offset of the field members, so accessing "obj.member" can be faster; for numerical operations, JS has to unify ints and floats, something Go can avoid; Go function calls can be directed to a static address. There must be more.
Be sure your clients can support the new syntax. It’s just syntax sugar, so unless you want to be super anal about the generated code, I would just do it the old way. I wrote some raw JS about a year ago that used the new syntax. Tested and worked nicely, even on Edge. Went to deploy only to find out that the place I wanted to embed it into didn’t support the new syntax so I had to rewrite some of the code to use the old syntax. I didn’t have a running instance of the embedded system to test it on so that was an annoying near deploy. 
Erlang Beam which is the Elixir vm is super good in context of concurrency :) i work with erlang for years now and i can only say positives about it. Problem of Erlang is not amazing lib support outside of telecom tech. Elixir is Ruby like Erlang and has much better lib support. I think it is ok, but i also like Go and Rust. I think they should bench also single core algorithms against each other and memory consumption for the "stress testing" if all languages behave almost exactly the same in results for handling connections the real winner is the one using minimum amount of ram / io :D (my personal opinion)
If you’re familiar with programming already, then the tour is perfect. It gives you the basic syntax and changes you would need to know to use Go. It also lets you run the code right there in the browser. 
&gt;Benchmarking Go vs Node vs Elixir I suppose it depends on what one is testing, the test is valid in the sense each platform is being tested as a single process, which is kind of correct. Adding clustering is an additional requirement to improve a platform to perform better, where as the other platforms/languages don't require this extra overhead to improve the performance. Kind of nice that Go has this performance in a single process out of the box.
Did it find any notable differences in the asm/noasm impls?
So far the only discovery is this https://github.com/golang/go/issues/30095. Otherwise no problems found. That said, I was using my personal EC2 account so I wasn't able to hit it with absolutely massive compute. I imagine companies such as Google, Cloudflare, etc. have done something along these lines already.
The basic idea is that everyone with collaborator access to a Git repository hosting this code will be able to vote for things and change their votes. &amp;#x200B; Our small group of developers needed a very minimal way of voting where we want to go for lunch everyday, so I hacked together this very simple tool in Go.
The v8 engine can work out if a javascript field is only being used to store ints, and it will generate machine code to load, store, add, subtract, etc, ints not floats. Of course the JIT has some overhead, but it can potentially generate more optimal code than the go compiler. It will always have more GC work to do though.
Gos advantage in these cases is that it's memory accesses tend to be more efficient, as everything is in structs, not objects. So there is less heap fragmentation, and more locality of access.
simple and nice.
Interesting. I covered pigo in my book so I'm curious about its continued development
IMHO always write js in New style so it is easier to maintain and read. You can use Babel.js to transpile for older browsers and include polyfills. Only thing required for that is a config file.
&gt; Since I haven't found any viable existing solution for accessing webcam in Go, Python is used for capturing the webcam [...] The browser allows capturing a webcam. Could probably send frames over web sockets quite easily. I did a similar thing a while back. I wanted screen capture and was able to inject an extension with puppeteer (node chrome driver, chromedp would be the Go equiv) that captured the screen, auto-approved the user request to do so, and sent it back for storage to disk (see [here](https://github.com/cretz/chrome-screen-rec-poc/tree/master/attempt1)). At the least you can see some of the media recorder code. Sadly it can't be headless because I used an extension and [Chrome doesn't allow headless extensions](https://bugs.chromium.org/p/chromium/issues/detail?id=706008), but I bet you could do the webcam capturing without an extension and keep it headless. Hrmm, this sounds like fun toy project, I may play around with the idea...
How do you feel about remote developers?
[removed]
seems you "cleaned" your code to post it here. im missing packages import. testMain etc making it pretty imposible to debug. if i had to take a guess, id say you didnt init httptest corect thus it cant find the route.
I guess what’s missing is removing the keys again afterwards or you may be leaking credentials 
[removed]
You're specifying a relative directory to read your `views` - this is relative to the working directory when you run the command. You have a few choices: - Use the correct working directory when running your application - Add a flag to specify the directory where the static assets live - Pack the static assets into the binary using a post-/pre-build step (this is typically done by either stuffing the assets into code (go-bindata, et al), or just appending them to the compiled binary (go.rice, et al)).
I was just thinking about looking for something like this, nice
We are definitely open to remote developers for the right candidate. 
https://go.googlesource.com/proposal/+/master/design/go2draft-contracts.md
not exactly sure what you want but from my experienbce its usualy better to pass along structs of some sort then just pure parameters. Best case scenario: you need more parameters? jsut add them to your struct and everything using that is automaticaly happy Worst case: you end up passing along tons of stuff others simply dont need. mind giving a bit more detailed example? PS: you might wanna take a look at [https://github.com/spf13/cobra](https://github.com/spf13/cobra) which handles flags and commands for you (global parameters and function specefics)
Thanks. That looks pretty good. I'd definitely prefer Java/C#/Rust style &lt;&gt; brackets syntax though.
You don't - Go doesn't have classes.
Yeah I know cobra would be a good fit for the parsing. I just am not super fussed about learning cobra right now. I want to get my code to a place i like, and then i will look into having a better cli parser. &amp;#x200B; I just don't like that everyone has to be aware of the same type. And it seems weird as to who defines the type? Is it the main package because its the command line options? or is the kctl package because it actually consumes it. &amp;#x200B; Also without needing to be too specific to my issue, is the use of a types package viewed as a bad practice? &amp;#x200B;
I was looking at this blog post ([https://www.taniarascia.com/you-dont-need-a-framework/](https://www.taniarascia.com/you-dont-need-a-framework/)) and wondered if I could convert the code to Go (GopherJS). &amp;#x200B; I've played around with GopherJS and written some really small toy apps, but nothing large. I am quite familiar with Go servers and reluctantly familiar with JavaScript.
really depends on your code. I generaly try to implement the "package" tought of go. meaning whatever I do, I try to make it as self sufficient as possible. then having something above it which controls it (passing parameters, doing inits etc) and only pass it the data, it needs. thats also why my stuff usualy plays very nicely with cobra ;) I'm a realy example driven guy so to help you any further i need some pseudo code :)
Not seeing any info on Watchtower on Crunchbase. Nor is there much company info on the website. How many employees does Watchtower have? Who's in the C-suite, who's on the board? How much funding has Watchtower received / what round(s) of funding have been closed? Kinda important info for someone looking to invest their time in your company, don'tcha think?
This leaves the SSH key in the final image layers `rm`-ing something does not delete it from the previous layers. You would have to do a two-stage build copying the compiled binary to a fresh container using something like: FROM golang... as builder COPY SSH, etc, RUN build it FROM golang COPY --from=builder path/to/binary . As-is a simple `docker inspect` or `docker history` would give someone access to your SSH key.
Please give credit to the artist of the artwork you are using in your blog. https://twitter.com/quii/status/1089220774945271808?s=21
Awesome idea, I googled it so didn't knew. Will do, thanks for connecting me 😀
Gotcha - this is a pretty common question for people coming from class-oriented languages. You can certainly produce similar functionality, but not syntax - there's no way to extend a struct in the same way as a class, but typically goals may be achieved with interfaces and structs, and possibly embedding, depending on the requirements. type HTMLElement interface{ Render() } type Recipe struct {} func (r *Recipe) Render() {} Take a look at vecty if you want an example of a client-side framework for GopherJS.
Yeah so this is probably the hackiest solution I’ve ever seen for a real problem, but hey, if it works... In `run.sh` it says `./voter` which only works for one os, right? Maybe use `go run` if that’s possible (I’m not a friend of precompiled executables in a git repo) Yeah right now I’ve got so many ideas how to improve the code and add a fuckton of features, but that would be kind of a medium to big project... Maybe if I got time in March, I’ll build such a system with a client/server system. Should I keep u updated if that happens?
Well, I read your blog post. Very contrived example that still doesn't give any arguments as to why package level variables are so bad. Your example would look exactly the same and would have the same "problems" if instead of NewObject it would be a struct method. Do you propose we lift struct fields into arguments as well? And your proposed fix doesn't do anything to make it better. You can't get around reading and understanding others people code. The notion that you should understand everything about a function just by looking at its signature is a questionable one at best. Go is not a functional language to be dreaming about pure functions. &amp;#x200B; Global variables are not that bad in Go because everything lives in packages and you have to explicitly import something before using it. That fixes much of the scary stuff from C/C++ where this global variable phobia is very relevant. When you write tests in Go you have full control over your package. You can replace global variables and initialize stuff any way you want. That also makes globals and init not a problem. Don't test your dependencies, test your code. &amp;#x200B; Personally, I had not a single problem with package level variables. Given that there're basically everywhere in both standard library and 3rd party packages, that should tell you something. There's always a possibility to write something bad but, as is the case with error handling not being enforced by anything, Go programmers tend to be disciplined and use package level variables for stuff that makes sense. Sentinel errors, default implementations etc. go-kit that you mentioned uses them exactly for that, including "init" to initialize them. Be disciplined, not enforce an ideology. 
 if ask("Check resulst? Or ignore and proceed to voting?", false) { outputVotes() return } "Check **resulst**" Literally unusable
This is a very... creative...use of git. 
Erlang/Elixir Beam VM is a byte-code interpreter, while Go and Javascript are compiled languages. (Well, Go is AOT compiled, and V8 is JIT compiler). 
What kind of go xp are you looking for?
Yes. I got into the habit of writing lengthy python scripts because my bash was never as good as it aught to have been, but whenever I put them on a new machine I would spend a minute or two playing “pip tag” to get all the requirements in order each time I ran a script. Now I just go get everything I need and life is good. I also develop in go as my profession so it’s always fresh in my head, which makes it the most the most natural language for me to write a quick script in.
Why aren't you remote by default? 
So why do you doing go get. You can just compile &amp; push the executable in different machine. Or am i missing something? 
Ah, I’m back and forth between macOS and Linux quite a bit and the compiled binaries are different so I just install go and go get, plus I’m not crazy about putting compiled binaries in version control.
Do you have a remote-first culture or just allow remote work in special cases?
here is how i would do something like this with templates. ``` package main import ( "html/template" "log" "os" ) func main() { if len(os.Args) == 1 { log.Fatal("%s expr0 expr1 ... exprN", os.Args[0]) } data := map[string]interface{}{ "name": "Bob", "age": int(31), "siblings": []string{"sue", "hank", "jeff"}, } for _, expr := range os.Args[1:] { tmpl, err := template.New("person").Parse(expr) if err != nil { log.Fatal(err) } tmpl.Execute(os.Stdout, data) os.Stdout.Write([]byte{'\n'}) } } ```
"OCR" is the search term you're looking for.
You're definitely right, happy to divulge on a call. Right now we are still purposefully semi-stealth as we're strategically thinking through when doing media and going public on linkedIn/crunchbase would yield the most value &amp;#x200B;
&gt; a main problem is that running into issues w/o getting a error message is pretty common in the beginning. If you find issues like this please report them so we can get them fixed :)
Thankyou I'll look into those
Being fully transparent, I would say more of the latter. We have an office in SF as well as Palo Alto and really do value face to face interaction. That said, we don't want that to limit us from being able to work with talented folks, regardless of geography and so definitely want to embrace that. At Uber, we had a highly distributed workforce (across many geographies and offices even within SF) and I found that to work out quite well with things like Zoom. 
I would say the level of go experience doesn't necessarily have to be advanced, just a willingness to learn and work in a go environment. We mainly screen for strong software engineers / CS fundamentals rather than anything language specific. 
If the value is equal to the zero value, it is unset. I would remove the pointers.
The good part about exceptions is when errors need to be bubbled up across multiple layers, the intermediate layers don't need to be changed to bubble the error up. They can also potentially be implemented more efficiently compared to manual bubbling up.
What if the zero value is actually the value entered? e.g. the zero value for an `int` is 0, what if that's the actual value in the json?
I can't read your markup in my mobile app, but I just use pointers and live with the unergonomic-ness. Go is just a bit ungainly at times. Every language has its trade-offs.
I don't know of any great way. You have two variables which need to be setup, the value (int) and the presence (bool), and there isn't any pretty way around it. Most people arrange things so that the zero value of the int is good enough. Apparently it isn't for your case. &amp;#x200B; As you have tried, you can use pointers-to-value, where the pointer != nil is the boolean. &amp;#x200B; You can try wrapping everything in a pair `struct Int { value int, present bool }` and set present=true in a custom `Int.UnmarshalJSON()` method. That can even tell the difference between 'null' and entire absent. &amp;#x200B; You can check what names are present in the JSON by unmarshaling the same data a 2nd time into a `map[string]json.RawMessage` and then check if "value" is in your map. &amp;#x200B;
Makes sense would update it with the idea of having a multi-stage build as it'd also help to reduce the final size of the image. Btw how about using docker `--squash` for the same? 
I've made a golang playground to demo it Essentially I have added properties that act as references https://play.golang.org/p/vdaBtTth8to
kctl needs to define what it can consume. You can make it its own type, and have main either use it, or in a more general case, \[tediously\] convert or construct kctl's type from main's own data. You can also have kctl take an interface, and let main implement it.
with most source control (well, gitlab at least) you can compile for different targets directly in CI from commits and have downloadable artifacts.
The pointer approach you mentioned is pretty much the only way I know to do this. The AWS SDK uses this pattern extensively. It's a little awkward, but it works. 
This would be nice to have for pull requests like this one: https://go-review.googlesource.com/c/crypto/+/71950 Reviewing asm is a pain, so fuzzing as a first-pass would help reduce human effort by identifying breakage quickly.
Your first method (using a pointer to the primitive) is the typical way to do this, and it's the way the the protobuf package handles it. It does provide helpers to make the unergonomic bit better: package proto func Int64(i int64) *int64 { return &amp;i } and you can define those kinds of helpers yourself for use with JSON. Proto also defines getters on the type that will do the nil check and return zero if that's what you want, but for JSON this shouldn't be necessary, as you could just use the bare value if lack of presence and zero are the same thing. I can't remember which one, but I feel like I've seen a database library that provided wrapper types similar to the ones in [this response](https://www.nvidia.com/Download/index.aspx?lang=en-us) and those can work quite well too.
Your provided link sends me to NVIDIA's download drivers page. Get yourself a new graphics card?
I watched a YouTube video where the guy talks about how Go is an amazing tool for devops. You can cross compile for everything from any platform. Run it on Linux, Mac, Windows, BSD. Even arm , 64 bit intel or 32 bit intel. Etc. amazing stuff. It’s entirely acceptable to use it to replace other languages. 
This is why I hate zero values. They’re super useful for some things but annoying for others. The pointer method works, so I guess just keep using it. 
Haha, no actually, I got a BSOD when they tried to update my driver so I went for a fresh reinstall. Much less fun. The link is fixed though :)
Ran across this today in case anyone is interested. [https://gascore.github.io/](https://gascore.github.io/)
I didn’t dig too deep, but in the main package on line 33, where you switch on Type, you can do a very neat convention that becomes more Type safe. switch x := s.(type) { case Chameleon: // now x is guaranteed to be Type Chameleon. default: // handle normally. } 
Nope, but looks great
Typically you're not setting fields to static values, so you're just taking the address for an existing value and the ergonomics issue goes away. You're doing the right thing AFAICT.
How about a bash script that compiles your go binary for mac/linux/windows in one go ;) ``` #!/usr/bin/env bash set -eo pipefail IFS=$'\n\t' if [[ -z $TRAVIS_TAG ]]; then TRAVIS_TAG=$(git describe --tags) fi set -u BINARY_NAME=vn GIT_SHA=$(git rev-parse HEAD) VERSION=${TRAVIS_TAG#"v"} DIRTY="" $(git diff-index --quiet HEAD 2&gt;/dev/null) || DIRTY=".DIRTY" if [[ ! -d ./dist ]]; then mkdir ./dist fi echo "Building version ${VERSION}${DIRTY}" BUILD_LDFLAGS="-X github.com/venuenext/venuenext-cli/commands.Version=${VERSION}${DIRTY} -X github.com/venuenext/venuenext-cli/commands.GitRevision=$(git rev-parse HEAD)${DIRTY}" echo "Starting the Build (macOS 64-bit)" GOOS=darwin GOARCH=amd64 go build -o ${BINARY_NAME} -ldflags ${BUILD_LDFLAGS} ./cmd/${BINARY_NAME} case "$OSTYPE" in darwin*) echo "Making sure the build runs (macOS)" &amp;&amp; ./${BINARY_NAME} ;; esac echo "Making tar.bz2 package for distribution (macOS 64-bit)" tar cfvj dist/${BINARY_NAME}_macos64.tar.bz2 ./${BINARY_NAME} echo "SHA256 Sum of the distribution" shasum -a 256 dist/${BINARY_NAME}_macos64.tar.bz2 &gt; dist/${BINARY_NAME}_macos64.tar.bz2.sha256 MACOS_SHA=$(awk '{ print $1 }' dist/${BINARY_NAME}_macos64.tar.bz2.sha256) cat dist/${BINARY_NAME}_macos64.tar.bz2.sha256 echo "Starting the Build (linux amd64)" GOOS=linux GOARCH=amd64 go build -o ${BINARY_NAME} -ldflags ${BUILD_LDFLAGS} ./cmd/${BINARY_NAME} case "$OSTYPE" in linux*) echo "Making sure the build runs (linux)" &amp;&amp; ./${BINARY_NAME} ;; esac echo "Making tar.bz2 package for distribution (linux amd64)" tar cfvj dist/${BINARY_NAME}_linux64.tar.bz2 ./${BINARY_NAME} echo "SHA256 Sum of the distribution" shasum -a 256 dist/${BINARY_NAME}_linux64.tar.bz2 &gt; dist/${BINARY_NAME}_linux64.tar.bz2.sha256 echo "Starting the Build (windows amd64)" GOOS=windows GOARCH=amd64 go build -o ${BINARY_NAME}.exe -ldflags ${BUILD_LDFLAGS} ./cmd/${BINARY_NAME} case "$OSTYPE" in msys*) echo "Making sure the build runs (windows)" &amp;&amp; ./${BINARY_NAME} ;; esac echo "Making tar.bz2 package for distribution (windows amd64)" tar cfvj dist/${BINARY_NAME}_win64.tar.bz2 ./${BINARY_NAME}.exe echo "SHA256 Sum of the distribution" shasum -a 256 dist/${BINARY_NAME}_win64.tar.bz2 &gt; dist/${BINARY_NAME}_win64.tar.bz2.sha256 echo "done building..." ```
Could you share which book?
http://www.catb.org/esr/faqs/smart-questions.html &gt; When you ask your question, display the fact that you have [searched for your own answers] first; this will help establish that you're not being a lazy sponge and wasting people's time. Better yet, display what you have learned from doing these things. We like answering questions for people who have demonstrated they can learn from the answers.
Looking for a programmatic way to gauge the number of functions that my code depends on, just for interest sake.
Thank you, i haven't thought of that
I also have a CL out for a delicate crypto assembly implementation. https://golang.org/cl/136896 I am really interested in tooling to make this kind of thing easier to write and review. The assembly policy gives a number of avenues to pursue https://github.com/golang/go/wiki/AssemblyPolicy My avo project is one approach to make the code easier to write https://github.com/mmcloughlin/avo/ The cryptotest package will help for sure, but I'm not sure of the status https://github.com/golang/go/issues/25309 Project Wycheproof is also extremely useful.
Definitely! I didn't expect to find anything, but I thought it would be interesting to look.
Oh, thank you, I see what you mean. HRW is an algorithm that allows you to re-sort anything based on the weights of the values. This allows for repeatability of sorting regardless of the environment.
Meta
It would be good practice to rewrite this to have a client-server architecture and communicate over HTTP. It is an interesting use of Git, though, I'll give it that
Or at least include executables for a few different OSes if your friends don't want to install all of Go to be able to `go run`
Yes not to sound harsh but please don't use that image, it's literally the cover to the book.
Thanks for your reply, After applying the changes it seems that it is still trying on https. ``go get -v &lt;src&gt;`` ``` Fetching https:// Parsing meta tags from https:// . . . ``` In the end it will return a 401 status code.. Is it wrong with the setup or something else? best regards
humm, I'll check this out! Thanks. The above solutions didn't work unfortunately so hopefully this one does. 
tldr there is a new language called V now. 
This seems like it shouldn't be posted here. This is for Go.
But does it have generics?
I would decode the images into pixel by pixel colors, compute some type of vectorized recognition of each letter by doing a spatial search of the image with some type of NxN pixel filter (you are now basically doing the neural net box scan, but we need to be explicit because we can’t use a training set), cross reference the ordered combination of these letters (aka words or text) with a known database of spam or ad text (Wow this is really starting to sound like we should have used a neural network), then hopefully you can identify with confidence the relevant text. I think a machine learning algorithm would be very well suited for this purpose though. Building the required data sets also doesn’t seem too difficult as I thinking about my gmail inbox.
Looks a lot like Go with immutable var and no Garbage collector
Looks a lot like Go with immutable var and no Garbage collector
Cool idea! But is this just a web wrapper around web services?
Yeah, cool, no one really cares about another language. I'm sorry. It is the best there for you I guess.
I thought by now every single letter of the alphabet was already taken when it comes to prog langs.
So it's going to be open source at some point, but not now. Very interesting, I'd love to see how it unfolds. 
How would you do this? ```go // prints `[14:01:08.005674] Database initialized' mapprint.Printf("[%0H:%02m:%02s.%06ms] Database initialized", map[string]string{ "H": 14, "m": 1, "s": 8, "ms": 5674, }) ```
It's go related
Generally the point the author seems to want to get across (apart from promoting his own V language), is that FFI in Go is pretty unfriendly ("easier integration with existing C graphics and UI libraries"). I can't say that he's wrong here, FFI isn't a language feature like goroutines are, and integrating existing libraries isn't that easy (reflect, unsafe.Pointer, ... just the data structures exchange is already very hard). I'm pretty sure some of this could be solved by tooling, but afaik there is no such tooling that would create the various bridge code that's needed here.
I agree but its nice to have as close an apples to apples comparison since these things end up having so many different variables and easily be misleading.
I had the same thought but after reading this I wasn't too sure: &gt; Node.js is a single threaded language which in background *uses multiple threads to execute asynchronous code*. Node.js is non-blocking which means that *all functions ( callbacks )* are delegated to the event loop and they *are ( or can be ) executed by different threads*. That is handled by Node.js run-time. It sounds and reads like Node.js can and does run async code on multiple threads, but what, has affinity set to only use one CPU core so there's no context switching? I was hardcore sure that it was single-threaded, but that explanation throws that out of the window. It basically sounds like `GOMAXPROCS=1` from once upon a Go history, but no way to tweak that (having cluster as a work-around)?
So .. essentially tinyGo ?
haven't tested it but something like this: ``` tmpl, err := template.New("time").Parse(`[{{.H | printf "%0dH"}}:{{.m | printf "%02d"}}:{{.s | printf "%02s"}}.{{.ms | printf "%06d"}}`) if err != nil { log.Fatal(err) } tmpl.Execute(os.Stdout, data) os.Stdout.Write([]byte{'\n'}) ```
Use Markdown mode and fenced block or paste your code somewhere like Pastebin. Your post is an unreadable mess. 
You can access webcam natively in Go (in Linux/RPi and Windows), no need for a whole browser just for that. See here https://github.com/gen2brain/cam2ip .
But Node cluster is NOT equivalent to Elixir/Go - in case of those two you can use normal inter-thread communication/synchronization primitives, in case of Node you can't and would have to hack around it
I haven't tried this library, but you can make use of Tesseract [https://github.com/otiai10/gosseract](https://github.com/otiai10/gosseract)
Many thanks!
Many thanks!
Go support functional programming, you can have a function return another function. What I do is that I have regular function doing my application logic, in a separate package and import them. Then I define the handler func s making them take that package I defined and use its function as needed Then when you define your routes you would just out the name of you handler function 
You can define methods on functions like on any other type. You can also create closures and pass them around as you like. Method chaining is more OOP though. In any functional language you would write the former. 
&gt; There's no runtime Pet peeve: Yes, there is. There *always* is. C has a runtime. We can talk about how large it is and what its characteristics are (and whether it matters), but you can't actually avoid having one.
It seems easier to do composition of functions. &amp;#x200B; (log, measure)(requestHandler)(http("request")) [https://play.golang.org/p/DdiQ6YePakY](https://play.golang.org/p/DdiQ6YePakY) &amp;#x200B;
FWIW, I'm not sure other languages make it easier. Even rust, touted for its FFI, requires you to use `unsafe` to subvert the type-system and use extra compiler-macros and the like. At the end of the day, you just have different languages with different features and there will be an impedance-mismatch. Granted, the GC makes some things a *little* bit more awkward, but… not *that* much? Like, if you use rust and want to pass a data-structure to C, you construct it using unmanaged pointers. But ISTM that you can do the same thing in Go - construct the data-structure using unmanaged pointers and manually allocated memory. So the crux of the matter seems more that C can't really work with a GC. I don't really like cgo myself, but mainly because of flaws of C - like cross-compilation being a PITA and the lack of standardization. A different argument would be that the Go FFI isn't *performant*. That is definitely more true for Go than for languages like rust, that use the C calling convention :)
I really like that he created his own language for this. It's true that choosing a language/framework forces part of your design decisions and the way you approach things towards certain patterns, but he took the hard way to do the opposite.
&gt; There is no situation in which an init function is the best way to solve a problem. If you use OpenGL it's literally the *only* way to solve a problem.
&gt;you can have a function return another function It doesn't mean Go supports functional programming.
&gt; Globals are not allowed What is the reason behind this? Globals are nice. You just don't use them excessively.
&gt; so I spent two weeks in October 2017 to create a very light and minimalistic language that can seamlessly interop with C Very impressive. V seems like a cool language. Makes sense to transition from Go based on your requirements. It's not meant for everything.
Oooh, "pip tag" is a great game. :D It goes along with "guess-which of your older scripts broke, because you updated a minimally used library, only to find out when you actually need it", and "have a dozen virtual environments for each of your small utilities and all hell break loose when you forget to activate the correct one". 
You can try [RawMessage](https://golang.org/pkg/encoding/json/#RawMessage). 
I will, thanks 
Nice job! This looks great
As I need it for my Go newsletter today, I've uploaded it to YouTube as publicly released FOSDEM videos are all CC licensed: https://www.youtube.com/watch?v=NWRZjyBwcCQ .. I hope Francesc has access to a better quality copy to upload though as I had to do some de-reverbing of the audio :-)
I'd too suggest going with Golang and as we're in a Golang subreddit opinions are likely to be a bit biased. So let me play the devil's advocate and propose some reasons on why one might stick with Bash. It's not that these rule out Go, it's just that Bash may have a small relative advantage. * You're especially strong in Bash and/or part of a team that uses tons of Bash * You plan to run this code in legacy *nix systems/architectures * You have severe file-size constraints * You need to change the code on the fly, (vi, :wq and retest) * Working with standard unix tools, pipes+{grep/sed/awk/cut/sort} would make your life easier * You want to easily call other programs in different languages, toy around with their input arguments and outputs ^If ^anyone ^has ^more ^feel ^free ^to ^add
I'll continue to improve it. Please advertise by all means!!! Thank you very much!!
What runtime does x86 assembly have?
"You won't have to manually free the memory either! V's memory management is similar to Rust, but it's much easier." That sounds pretty interesting, I guess globals are forbidden because of this.
Good one! Don't ignore the errors though ;)
lol no generics
Maybe it has a `const` type? That would cover most use cases.
If it has exceptions I'm in
To be honest, it’s easier to use Go from C (as a shared library) and the compiler produces a .h file. Having tooling that would go the other way and produce a .go api with structs and calls would be awesome. https://github.com/xlab/c-for-go - a quick search comes up with this, but I’m not sure how good it is or if the author evaluated it... i’d start here if I had to interface some library...
No
Instead of writing a whole new language you could have used D which has everything you need and more. https://dlang.org/blog/2017/08/23/d-as-a-better-c/
I can’t argue that as I never had formal education in CS. But the courses I took in both JS and Go referring to functions being first class citizens as a characteristic enabling functional programming. My understanding that Go isn’t designed as a pure functional, procedural or OOP language but rather having features that can emulate all three. But I hope you are not saying that you can’t do functional programming in Go, because if you google “Go functional programming@ you will find a lot of people who thinks Go is suitable for function programming 
Awesome! I'm taking a level 1 programming class and we are learning golang. I'm definitely going to share this with my classmates. 
Yes, you can do stuff like that and it is pretty good. Many Go programmers (and I) do. But it is just passing a function to another function not functional programming. Both Go and JS can't guarantee functions have no side effects and all data are immutable. This is as important as treating functions as first-class citizens for functional programming.
You still need one for interaction with OS (standard input/output handles, system calls), memory allocation, starting and finishing process (how is your executable loaded by OS and finds an entry point). If you build something that runs on a bare hardware, you can get away without run-time in ASM. I remember developing my first programs for computer built on Z80 (Zylog), entering compiled assembler instructions as hexadecimal byte values and loading that directly to a specific address in RAM.
Maybe [gjson](https://github.com/tidwall/gjson) can help you with this structure. For me it worked very well.
The only problem is that it swallows your mouse.
I've been reading about it and thought I'd implement two things. Auto retry, because of the rate limit and use the httpClient to be able to adjust the timeout. What do you think?
I've generally been rewriting Ruby scripts in Go. (I've never used plain old shell for anything more than a dozen lines or so.)
Thanks so much for posting this. It's really helpful to see how you deal with testing with helm and k8s.
Cross post to r/ProgrammingLanguages?
Seems excessive, and there's no rationale why he did it. Its fine if he just wanted a fun project, but then say that's your reason for building it. 
&gt; The v8 engine can work out if a javascript field is only being used to store ints 0. No, it can't. Instead, it removes the compiled code if it finds that some expression now yields another type. 1. The problem isn't assuming some variable is an int, it's the operations: 1 + 1 gives another int, but if you add one to 2^56 , you get a float. Possibly there's another edge case. These things require extra checks, and more code down the path.
This is nice. I fee like it should be part of default Docker install.
Another thing of note for using go for scripting: use go modules (requires go 1.11). It doesn't require you to setup a whole directory structure for dependencies ($GOPATH, etc). ``` export GO111MODULE=on go build . ``` Just keep the go.mod and go.sum files along with the repo.
http://eagain.net/articles/go-dynamic-json/
SOAP is XML so use [etree](https://github.com/beevik/etree) to build your request.
Very well done, you must have surely put a lot of effort into this!
&gt; keep the go.mod and go.sum files al ahann. Thats a good point. Will try with modules. Thanks.
Great red herring :) That depends. Assembly doesn't produce a runnable program. You need to actually link that into an object file. Which then gets executed. By some runtime. Of course there *is* such a thing as bare metal, but at that point we're leaving the realm of programming languages. i.e. if you'd try to make that argument, Go wouldn't have a runtime either. After all, it's also just bytes in memory getting executed by the CPU. It's more bytes than you directly expressed in the source code passed to the compiler, yes. But it's also more bytes than your source when you used C and that is exactly my point. I don't think it's easy to draw a clear line of what does and does not constitute a runtime - but I think ld, libc and libgcc (if using gcc) can be very easily justified as constituting a runtime. They do some things the Go runtime doesn't do (e.g. loading shared objects) and don't do some things the Go runtime does (e.g. Garbage collection). There are a lot of things both do (e.g. managing memory, orchestrating function calls, wrap syscalls…). And there are some in-between-y things (e.g. the specific set I mentioned doesn't do scheduling, but if you add libpthread, it does). What the author means when they say "no runtime" is pretty much * No Garbage-collection * No language-level threading support But then they should just say that, IMO :)
&gt; Even rust, touted for its FFI, requires you to use unsafe to subvert the type-system and use extra compiler-macros and the like I'm not really sure what you mean by subverting the type system, but unsafe rust merely lets you: * dereference a raw pointer * call an unsafe function * implement unsafe trait * access or modify a mutable static variable Even though you need unsafe to do FFI, if properly structured your code will panic before calling out to C, avoiding segmentation fault.
&gt; panic() SHOULD in fact be avoided at all cost. So, Go does the wrong thing when calling a nil function pointer? All function pointer calls should instead do what then? "panic should be avoided at all costs" is not the rule. If that was the rule, __we wouldn't have the panic keyword__. We do, and that's because there are times when panic is correct. "You just tried to call a non-existent function" is correctly a panic when you use Go features to try to do it, and it is correctly a panic when you implement dynamic dispatching to try to call a non-existent function. Otherwise, I am anxious to hear your explanation as to why it is correct when Go does it, but not correct when the user does it for the _exact same reason_.
&gt; Having tooling that would go the other way and produce a .go api with structs and calls would be awesome. That's what cgo does - at least as far as is, in general, possible. C just doesn't map very well to any modern language, as you have to account for lack of safety, context-dependent parsing, no concept of namespacing/modules, lack of standardization… As an example, you might naively say "given a header-file, look at all the top-level identifiers it specifies and transform them accordingly". But you first have to run it through the pre-processor, because otherwise you won't actually know the sizes and alignment of your types (much less what other identifiers refer to - say you have a field that is itself a struct). But running it through the preprocessor *also* provides useless results, because a lot of C-APIs actually use macros, which would get expanded away (so, for example, all constants defined in the library would be lost). And you'd need to decide how to deal with parametric macros in a language without metaprogramming (plus, of course, the macro-definition doesn't actually need to create valid code, depending on the context its used in). And then, do you expand includes or not? If you do, every go-API you generate would define all the syscall-related structs and integer types and everything itself - but if you don't, your source code is unparsable (as C parsing is context-dependent, i.e. the code in a header-file can change how the including file is parsed). cgo actually is (IMHO) an incredibly clever and good solution to all that mess. You simply refer to a C-identifier by name in your code and cgo then runs the actual C-compiler (including all the header-files and everything) to determine its type and layout and generate appropriate go-definitions (you can try this out by building a C-using go program with `-work` and looking at the intermediate files generated). Which has the downside of requiring you to actually list the identifiers you are interested in, but for all the reasons outlined above, that's a *general* limitation caused by all the issues I mention above. That's what I mean when I say cgo does a really good job "as far as possible". I genuinely think that Go is one of the *best* languages in terms of ergonomics, when it comes to interfaces with C. Not in terms of performance, yeah. But the ergonomics are honestly better than usual.
Unsafe Rust "merely" lets you basically bypass the language's entire _raison d'etre_. There's no need to try to defend Rust here. The problem is with C, not Rust. The problem is that when the entire world revolved around C, it was easy to think that "a C function" was some sort of baseline of functionality that imposed no additional constraints on things trying to interop with C. But that's just not true. C comes with just as many semantic requirements and operational details as any other language; it was just an accident of history that it propagated those semantics and operational details so far they could be mistaken as ground rules for computing. The more we experiment with better rules in various languages the more clear it becomes that "C interoperability" is actually non-trivial. See the discussion in another thread about C's runtime, which definitely exists. It has to, because you can not run compliant C code directly on a real CPU. You need that runtime.
&gt; I'm not really sure what you mean by subverting the type system, but unsafe rust merely lets you: I mean that list. You are subverting guarantees the type-system provides you.
&gt; Unsafe Rust "merely" lets you basically bypass the language's entire raison d'etre. Almost, but the borrow checker will still prevent you from doing things https://words.steveklabnik.com/you-can-t-turn-off-the-borrow-checker-in-rust I agree with the rest of what you said though.
Can you give an exact, literal example of the JSON pattern you are trying to deal with? Be sure that if, for example, you have `custom1` and `custom2` at the same level that you include at least 2 of them, for instance; don't include 1 of something that you have multiple of. I will say that if you're doing this a lot, and the type conversions are just becoming too much to deal with, if it's possible, you may just want to switch to something like Python for at least this portion. The other possibility is that you can factor out helper functions for common operations, so that even though there's a ton of type conversions at least the main logic flow is legible.
UTSL: [src/database/sql/sql.go#L202-L208](https://github.com/golang/go/blob/4ae9e7f1667d0a7df157b47d9d2d1f4a3c67849d/src/database/sql/sql.go#L202-L208)
Thanks 
Thanks 
Will try, thanks 
directly trying to call a nil function pointer is different from failing to find a function in a lookup table. yes, panicing is the right thing for Go to do on a nil function pointer call -- but the problem in this case is completely different. panic() shouldn't be called unless the problem is unrecoverable or has been placed in an indeterminate state (ex, when something happens that shouldn't have ever happened). so ya, dereferencing a nil pointer warrants a panic because there are no normal circumstances that this should have occurred. though i agree with this usage of panic, i reject your notion that everything the Go team does is automatically the best merely by them having done it. in this case, we're just executing a simple command dispatcher -- again, which appears to be for a game. so simply typing a command that doesn't exist is an error that you can anticipate and handle gracefully without metaphorically pulling the emergency brake. a more appropriate action would be returning an error. about panic being avoided at all costs: i guess my point is, it shouldn't be used for errors that can be properly handled. panic should be avoided because most errors can be handled. i think if one is considering using panic (like you suggested above) maybe you should think harder about it. i expect that most times you can think of a better solution that involves return errors.
Just curious, is it in a university/college? Interesting to see academia using Go as in my University they go bananas for Java
A community college. Last semester I took an intro to programming course that taught python. I think the instructors have a lot of freedom until transfer level courses.
I really like this, and I love that it tries to copy the Go language. I find this to be very clever and I'm surprised I've never seen something else like this. What I like is you get benefits of C targets (ie. no-GC, video game use+GL libs, and WASM). For concurrency and goroutines, this can absolutely be implemented as well to support in V or something close to it. Essentially, its kinda like gcc-Go without the garbage collector -- which makes sense to me someone might want to fork gcc-Go to another language, or I guess design it like V as a transpiler.
where is the source of volt available? I couldn't find a link to any github or source page on the website..
Neither of those two. Happy to connect with you if you'd like to learn more though. 
Hey /u/joncalhoun (or am I supposed to do @joncalhoun) - thank you for this response. I wasn't looking into any kind of paid courses for Go but seeing what you're willing to do gives me good reason to. I like being able to support folks making quality coursework and standing by it, so when I have the appropriate finances in place, I'll purchase for sure.
Stackoverflow is the next door. Here is reddit. So shut up and deal with it. 
[removed]
V. : But on this most auspicious of nights, permit me then, in lieu of the more commonplace soubriquet, to suggest the character of this dramatis persona. Voila! In view humble vaudevillian veteran, cast vicariously as both victim and villain by the vicissitudes of fate. This visage, no mere veneer of vanity, is a vestige of the “vox populi” now vacant, vanished. However, this valorous visitation of a bygone vexation stands vivified, and has vowed to vanquish these venal and virulent vermin, van guarding vice and vouchsafing the violently vicious and voracious violation of volition. The only verdict is vengeance; a vendetta, held as a votive not in vain, for the value and veracity of such shall one day vindicate the vigilant and the virtuous. Verily this vichyssoise of verbiage veers most verbose, so let me simply add that it’s my very good honour to meet you and you may call me V. Evey: Are you like a crazy person? V. : I’m quite sure they will say so.
[removed]
 log.Info("info from logger", func(e *rz.Event) { e.String("hello", "world") }) Not in love with the extra noise that inline function and its argument add to every log line.
You have to use kernel32.dll lib to print colored text on Win platform. There’re a lot of crossplatform packages which handle the fuss stuff underneath the hood like this https://github.com/daviddengcn/go-colortext 
cool!
[removed]
Yes it can. It might not. But using Speculative Optimisation it may be able to decide that some function is only passed integers and it can assume integer math. This optimisation will be guarded so that if the assumption doesn’t hole then the code is de-optimised. Also, due to the magic tagged pointers, a given word in memory can be a small int, or a pointer to a float, and can be upgraded from small int to float in place. There are various articles on this such as https://ponyfoo.com/articles/an-introduction-to-speculative-optimization-in-v8 It’s pretty interesting stuff. 
#DEFINE myawesomeconstant #DEFINE whodoesnotlovepreprocessors
Looks cool, why did you pick gocui? It does not draw well on windows :-(
Can you describe what you are really trying to achieve here? I see some issues but I don't really understand the goal. For instance, your disabled add/subtract routes are going to try and call the add()/subtract() methods and write to a ResponseWriter that may either be nil or may be the old one that was set in a previous call to the root '/' route. It doesn't make sense to try and save the writer from a previous request because http is stateless and it's a new connection. And really this is running some of your logic at the time when you are defining your routes as opposed to later when the request hits the route. Also the add and init would happen backwards anyways if it were even to work. The add would write immediately and then your out would return a handler that would later write init. I'm assuming what you kind of wanted was for the intermediate methods to return another function which continues to get wrapped by the next function until you have something that is entirely lazy until the http handler hits the last function value. 
Well, I spent 10 minutes reading it and it looks very much like the javascript horrors I explicitly don't want to use. https://github.com/gascore/example has *so much crap* in it.
According to benchmarks it’s not the fastest. It’s on par with zerolog. API imo looks worse. Too much boilerplate.
[removed]
[removed]
[removed]
wow, no. Well maybe, add some channels, a couple goto's, ummmmm, some Cgo calls, i don't see any goroutines, u need at least 10 of them. and then maybe, it will work.. 
Oh, sorry.. I am wondering if something like before will work. `http.HandleFunc("/", handler0)` `http.HandleFunc("/secretPage", handler1.login())` `http.HandleFunc("/secretPage2", handler1.login())`
This is really awesome!! Thank you
&gt;FWIW, I'm not sure other languages make it easier. Even rust, touted for its FFI, requires you to use unsafe to subvert the type-system and use extra compiler-macros and the like. At the end of the day, you just have different languages with different features and there will be an impedance-mismatch. D can use C libraries natively. It's almost there with C++ too. [https://dlang.org/spec/interfaceToC.html](https://dlang.org/spec/interfaceToC.html) [https://dlang.org/spec/cpp\_interface.html](https://dlang.org/spec/cpp_interface.html)
I'm a complete beginner to Golang, but I must say the comments show a rather mature and chilled out community than a lot of other language communities I've seen. Good on you folks! Perhaps I should start playing around with Go a bit more.
Well you’re not checking remote at all. And your checks on path are in the wrong order inside your loop. Check the top level first before checking the member variable. Your casting is super weird. You’re making a lot of assumptions about that logger. 
I can see a bunch of use cases for this. Letting microservices know when peers have started/stopped would be great. 
as you can see, it's the fastest by some ns. The main problem with zerolog is that it's API is unsafe (you forgot to Msg(), or you Msg() x2...) a little bit of more code is largely preferable to unsafe code. 
You're right indeed. I'm not checking remote. But that is not the issue at this point, even though it might be a little shady not to. Thanks for pointing out the order. I didn't realise it would make a difference. I agree on that casting, but since that part works fine I put that on backburner.
Hi, I can't thank you enough (and all contributors) for Learn Go with tests. It gave me such a big head start. Keep it up! If we meet somewhere on a Gopher conference the first beer, coffee, * is on me :)
seems like poor json message design. do you have control of the json struct being passed?
I’ve used github.com/hooklift/gowsdl It basically takes a WSDL file (most SOAP services generate them), and makes a go file with everything you need to connect to the endpoint. The downside is it’s not dynamic so it isn’t flexible when their API changes. But it does work really well. 
&gt; we can use the decorator pattern to add functionality to an object doing runtime without affecting other objects of that type There are many things in code, and life in general, that can be done. The larger question is: should we do something? The mental model is important in such decisions. In my experience it’s far simpler to reason about code that operates as uniformly as possible. In go, this very nicely summarized by interfaces. Try this mental model: different objects are all handled identically, it some don’t do anything at all when asked to do some things. This is sometimes described as the null object pattern. For nearly everything that decorators would be used for, I far prefer dependency injection controlled by interfaces combined with the null object pattern.
&gt;Originally Volt app was written in Go, but after a couple of weeks of development I decided to re-write it in C ... C development is not very productive, so I spent two weeks in October 2017 to create a very light and minimalistic language that can seamlessly interop with C. tl;dr: He decided to re-write it in C, but then he thought about that for a minute, and he didn't.
Exceptions simplify the common case of passing an error up the stack. Using returns forces you to do this boilerplate manually. That doesn't mean exceptions are the answer, I'd say something like Rust's `try!` macro is a good compromise -- the simplicity of return value errors, but the ease of exception bubbling with minimal plumbing code.
First, thanks for taking the time to discuss this. My definition of DI is that the dependencies I depend on are just abstractions. So mostly I have interfaces as an argument. I know there are more DI techniques but this is the one I mostly use. Honestly I don't understand you mental exercise `different objects are all handled identically, it some don’t do anything at all when asked to do some things.` Could you maybe provide some code? Thanks!
I don’t have control. I’ll work on that 
But the cost of adding keywords and learning a new relatively simple concept is a small price to pay for the code cleanup that it enables. I get it, Go is simple and that's one of the selling points. But a one time cost of learning how a new language-level feature works gives continuous payoff in the form of code simplification. The language being lean isn't the strict advantage many people think it is. The core problems don't go away, they just get pushed into userland code. Generics and better error handling constructs allow the language to solve problems that the user would otherwise have to solve.
Imagine you have a function that takes a logger interface, but you don’t want it to log. You pass in a null logger (not nil) that conforms to the interface, but does no logging (hence null). A good example — though perhaps not ideal for go — is a webpage that operates one way with a logged in user, and another way with a logged in user. Rather than have if/switch statements all over the place that check logged in status, you inject a regular user or a null user. The page then operates uniformly. All the if/switch logic can be removed. Hope that makes sense.
&gt; I agree on that casting, but since that part works fine I put that on backburner The path to hell is paved with good intentions :-)
If you ever want to work on a project let me know
Stop using Windows. Problem solved. 
Direct link that doesn't go via twitter: https://github.com/golang/xerrors
This entire project was started because of a joke. I wanted to see how far I can push it. But yes, I'll definitely re-write this in a client-server architecture as soon as I have some free time. Thanks! 
I'm going to publish this on a private home-brew repository so Mac users can install it from there. You're right, the reason I included the binary is that people didn't want to install Go on their machines. I will include a few binaries and tag them and update the shell script or something though.
How about using MQTT, is it an option? You can allocate topics to each process, can you not do it that way?
Sure, you can keep me updated. I'm going to re-write this anyway. This was a very quick-and-dirty solution because the polling app we were using ran out of polls in the free version. 
It's not yet, but will be made open source in 2021 according to the website.
It's hard to tell what you think things like `handler1.login()` actually are, because you're not keeping names stable enough. [I think you're looking for the cases like this](https://play.golang.org/p/1I5eon70CgX). Carefully reading that should show you how to do what you want.
You're too kind, glad it helps :) 
&gt; The distinction about concurrency-as-a-library and first-class concurrency "First-class concurrency" is a rahter pompous and also misleading expression for goroutines. It would be more fitting to call it "first-class asynchronous socket I/O", because that's what it is. Your example above will work asynchronously and pretty well if the io reader reads from a socket, but not so much if it reads from something else. The thing about Promises / Futures / async/await et al. is they are a general mechanism that can be hooked with pretty much anything asynchronous. Perhaps goroutines could also be extended to support arbitrary stuff but the runtime would have to provide some explicit support for that... 
Before what? Are you referring to some other post?
I was gonna write something about insignificant difference, preference for nicer API but scratch that. Did you just copy-pasted zerolog? The project structure is exactly the same. Diffing various files gives zero difference apart from a couple of names. No wonder the performance is the same. That's zerolog under different name. &amp;#x200B; There's no problem in forking someone else's code and improving it somehow but what you did look more like stealing. At least give the credit to zerolog writers and mention that your library is a fork with a few changes.
I just went through the example tests. Quick feedback: - I'm not a fan of using panics to report detected misbehavior, even if it is recovered by `go test`. It's just very noisy in a way that I don't feel is helping me at all. - It would be nice to see the test case minimization/shrinking work. I actually had to go back and see that it was claimed as a feature, to make sure it's doing something. But those are both just visual things. The framework itself looks very promising!
yeah I will add add credit, but couldn't fork because my project already existed before
[removed]
I see swift with those try? Statements as well. I like that syntax. But the whole nasty try/catch blocks are just so gross. :(
Still shady as f. You could mentioned it before defending your library against my comparison with zerolog. &amp;#x200B; What's the reason exactly why you couldn't fork and credit the authors at least before posting here? You already created the project and couldn't fork in the middle of the development (like you side before you edited your comment) or you embedded zerolog's core in existing project? Frankly, I find both statements hard to believe. Your commit history shows that you had some existing library astro-go and then decided to completely replace it with zerolog wtih a few changes. And forking in Go changes import path. It would even allow to use two exactly the same copies of zerolog.
From [https://go.googlesource.com/proposal/+/master/design/29934-error-values.md](https://go.googlesource.com/proposal/+/master/design/29934-error-values.md): &gt; Compatibility &gt; None of the proposed changes violates the [Go 1 compatibility guidelines](https://golang.org/doc/go1compat). Gathering frame information may slow down errors.New slightly, but this is unlikely to affect practical programs. Errors constructed with errors.New and fmt.Errorf will display differently with %+v. &gt; &gt; Implementation &gt; The implementation requires changes to the standard library. &gt; &gt; The [golang.org/x/exp/errors](https://godoc.org/golang.org/x/exp/errors) package contains a proposed implementation by Marcel van Lohuizen. We intend to make the changes to the main tree at the start of the Go 1.13 cycle, around February 1. &gt; &gt; As noted in our blog post [“Go 2, here we come!”](https://blog.golang.org/go2-here-we-come), the development cycle will serve as a way to collect experience about these new features and feedback from (very) early adopters. &gt; &gt; As noted above, the [golang.org/x/xerrors](https://godoc.org/golang.org/x/xerrors) package, also by Marcel, will provide code that can be used with earlier Go versions.
Looks like Rust. But why not just use Rust? :)
[removed]
Vapour ware - do we still use that phrase? Perhaps that is what the V stands for. This sounds more like a wish list for a language than the description of an actual working system. The whole thing looks like a teaser to solicit donations through Patreon and Paypal. I will happily apologize should I be proved wrong by the release of an open source language that meets the claims presented on the web site.
Without more code and/or, this is hard to debug. For example, a stacktrace would be helpful. And the implementation of `roundRobin`. FWIW, without any more info I'd assume that `path.local` (which is an interface type) contains a nil-pointer of some concrete pointer-type and that the debugger you're using isn't showing that correctly. There are lots of other things this *could* be, but if it isn't that, being able to actually see this happening and reading the code and panic output would be key.
Don’t marshal into a map if you can help it. Marshal into a struct directly if you can. 
this is freakin awesome! hope they get the xtensa line working.
I didn't mentioned that it was a zerolog fork because for me, sincerely, it wasn't so relevant. Anyone who'll dig in the code can see it, and I'm totally not trying to add it. The timeline is I created astro-go and used it. It's performance wasn't enough for one of the project it's currently used. So I explored go logging landscape, and started to rewrite astro-go using zerolog as it's core but with a totally new API imported from astro-go (and so code is now very different). then I needed a shorter name than astro because it's too much typing when using the library to write 'astro' (5 letters) everytime. Nothing more, nothing less, I'm not trying to deceive anyone or to steal someone else's work like you seem to think. I posted here because 1) it may be useful for some people 2) to receive feedback regarding the API, the performance, the UX... 
&gt; `func StateMachine` &gt; StateMachine synthesizes a property to be checked with Check or MakeCheck from the type of its argument, which must be a pointer to a state machine definition type. "state machine definition type" is not defined anywhere. The example makes it look like it's any type with a bunch of methods, with `Init*`/`Check`/`Cleanup` being special. (But it looks like `Check` and `Cleanup` still end up in actions? That might be a bug.)
[removed]
Take a look at SocketIO (fallback) ans NATS : https://nats.io
Thanks a lot for the feedback! Docs are really bad right now, and I am not a native speaker, so writing them is really hard for me. "State machine definition type" definitely needs to be defined; it is indeed an arbitrary type with some methods being special. Docs right now are probably the hightest priority.
Thank you! This looks like something that I need. 
One connection per client is the best in terms is scaling your service. 
[removed]
Thanks a lot for the feedback, once again! I am not a fan of panics too, but given that detecting and reporting them in case they happen is a required feature anyway, making them the primary (internal) mechanism seems logical to me. They are recover by rapid, and I tried to make the output concise and easy on the eyes. Shrinking right now is *really* simple; however it should be enough at least for the examples. For the parser one, I get example_function_test.go:45: draw args: (0, 10, 1) example_function_test.go:54: got back wrong date: (0, 0, 1) and for the queue, example_statemachine_test.go:92: draw initializer: "Init" example_statemachine_test.go:92: draw args: (1) example_statemachine_test.go:92: draw action: "Put" example_statemachine_test.go:92: draw args: (0) example_statemachine_test.go:92: draw action: "Get" example_statemachine_test.go:92: draw action: "Put" example_statemachine_test.go:92: draw args: (0) example_statemachine_test.go:68: queue size mismatch: -1 vs expected 1 Do you get the same?
I didn't know Docker well, but I developed it hard. I am glad that you are pleased. Thank you!
[removed]
I'll improve docui further and i'll propose it as an official tool of docker. Thank you!
...which it can't do because maximum queue size is 0, so there are no valid actions. Thanks, previously that was reported correctly, but I broke it, will fix.
Thank you!!
&gt;Looks cool, why did you pick gocui? It does not draw well on windows :-( I'm Sorry.. docui is only support mac and linux.. I chose gocui because it is popular. However development seems to be stopped now, it is very disappointing.. 
But how having multiple connections per client prevents you from scaling your service?
Indeed. I hope rapid will get coverage-driven one day.
Will the rewrite be in the same repo? I would like that
IMO it's a weird choice to put tinygo specific packages in the stdlib TBH. Seems to indicate that packages meant for "normal" go won't work correctly for TinyGo and vice-versa…
Appending using `O_APPEND` can just add to the end of the [file extent](https://en.wikipedia.org/wiki/Extent_(file_systems)) instead of having to rewrite the file. Further, reading from a device "file" like a pipe may not work, whereas `O_APPEND` would. 
Yep, this is the solution I ended up going for :)
Every connection requires memory, CPU and network resources to set up and maintain.
Remember that when people close the app, they won’t have a connection open. It’s often best to use push notifications to get the app to fetch the latest messages. Otherwise you’ve gotta consider routing messages to the server where they are connected to. 
I’m trying to go directly into a struct, but the sub structs are giving me troubles. That’s why i peeled out the base objects from the map, remarshalled, and then unmarshalled again into the structs. It’s working, but it seems really ugly. I can put the json up once I get back to my laptop. Some of the 2nd level json are coming with unknown number identifiers, and there are different amounts for each one, which is also causing me problems. Thanks for the advice!
Ah yea now that I read it more I can see. What a gross situation. :( 
I tried this one, but i don’t have anything like the “type “ field to work with 
Yeah, the json from the api is not formatted well, and I’m kind of new to this, so fun challenge :)
Really awesome community here, I hope to give back when I get better at this! Thanks All!
I took a course on Distributed Systems last semester and all the assignments were done in Go. That's where my love affair with the language started. I feel like my CS Degree Program didn't try to shove one language or the other down your throat, which was nice. It was also refreshing to take classes that even allowed you to choose which language to program in.
Thank you!
Try https://github.com/mattn/go-colorable
Lol.. 2021? vaporware then.. I predict we’ll never see it. The dev should be done in open for best chance of success 
Go compilation is so fast you could use go run as a shebang line. E.g: //usr/bin/go run $0 $@ ; exit
Please review your post.
Creating multiple connections per client adds a constant divider to the scalability of the service. If clients on average open two websocket connections, then you will probably need double the number of frontend machines than the case where multiple conversations are multiplexed over a single websocket connection.
What is outputted after going through the process and ending up at `/auth/google/callback`? It looks like it is dumping out the JWT claims, including the `sub` claim (which is probably what you want to verify.)
Kinda lame to present your library as the fastest when you didn't even write the core functionality, just took it from another logging library.
zerolog is mit licensed and you may be in violation by not including a copy of the license in your project. https://github.com/rs/zerolog/blob/master/LICENSE
`` package oauth2 import ( "encoding/json" "errors" "fmt" "io/ioutil" "net/http" "sync" "razer/csr-sign/auth/client" "razer/csr-sign/config" ) var httpClient *http.Client var once sync.Once func init() { httpClient = client.GetHTTP() } //SetHTTP can be used to set the HTTP client to override the default http.client func SetHTTP(c *http.Client) { setClient := func() { if c != nil { httpClient = c } } once.Do(setClient) } //Valid - validate the oauth2 token func Valid(token string) (Response, error) { requestURL := fmt.Sprintf("%s%s?access_token=%s", config.AppCfg.OAuth2.Host, config.AppCfg.OAuth2.ValidationURI, token) req, _ := http.NewRequest("GET", requestURL, nil) resp, err := httpClient.Do(req) response := Response{} if err != nil { return response, err } defer resp.Body.Close() respByte, _ := ioutil.ReadAll(resp.Body) response.Message = string(respByte) if len(respByte) == 0 { return response, errors.New("no response is received from oauth2 server : ") } err = json.Unmarshal(respByte, &amp;response) if err != nil { return response, err } if resp.StatusCode == 200 &amp;&amp; response.UUID != "" { response.IsAuthorized = true response.Token = token return response, nil } return response, errors.New(string(respByte)) } ``
Cool to see an intro programming course taught in something other than Python or Java!
Hi I uploaded the code to github, please review guys. it would be great help for me to learn go
I am so sorry, i uploaded my code to github. please review if you can , it would be great help for me to learn go
 I am so sorry, i uploaded my code to github. please review if you can , it would be great help for me to learn go 
It is dumping out all the claims. Would I think use the sub claim to make my own cookie or session and then use that in future authentication? that was the bit I was wondering about. 
Once verifier.Verify has returned successfully, the claims portion of the idToken holds the user information and can be trusted. The payload is a JSON; different providers use slightly different field names. [idToken.Claims](https://idToken.Claims)() uses json.Unmarshal() to unmarshal the payload. If you want to use the Id Provider's payload (rather than a raw json message), create a struct that reflects their structure and the corresponding field tags with their json names. As u/ihsw mentioned, you can then use 'sub' or 'email', etc. to identify the user. Here's Google's claims format: [https://developers.google.com/identity/protocols/OpenIDConnect#obtainuserinfo](https://developers.google.com/identity/protocols/OpenIDConnect#obtainuserinfo) and Azure AD's: [https://docs.microsoft.com/en-us/azure/active-directory/develop/id-tokens#payload-claims](https://docs.microsoft.com/en-us/azure/active-directory/develop/id-tokens#payload-claims) &amp;#x200B;
Yeah, you'd be able to make your own cookie linking to the given user. Once it expires they'll have to reauthenticate through the OpenID identity provider (eg: Google OAuth2 authentication) again.
Shouldn’t use an interface here. Use a struct instead. type Vehicles struct { Planes []Plane Trains []Train Automobiles []Automobile } vehicles := []Vehicles{ []Plane, ....} Then: vehicles[n].Planes[i] You can do that inline too if you so desired. 
Are you sure about not running directly on a real CPU, I thought the C runtime gives you hooks/functions to interact with the OS, other than that, the code is compiled machine code running directly on the CPU, even using OS debuggers like ICE show this, unless I am missing something ( •\_•)O\*¯\`·.¸.·´¯\`°Q(•\_• )
My comment was incomplete. Let me elaborate. Most of the cases, It doesn't matter if it's an entered value or a zero value but if it's a valid value. * If an `id` field is 0, return an error. Integer id's are always &gt; 0. * If a `name` field is empty, return an error. Names are usually required. * If a `bio` field is empty, use the empty string as the default value. * If a `number` field is 0, and it is a signed integer, use 0 as the default value. In case this field is optional, you may consider the pointer approach.
Thanks, mate. Will do! :-)
You check for nil in path.local and then check if path is not nil. That should be the other way around. Also why don't you check for remote not being nil, since that is probably most likely the one that falls in the writeto.
What do? 
What field can I use for that? the sub and email field could be easily changed and aren't unique to the authentication. 
&gt; Working with standard unix tools, pipes+{grep/sed/awk/cut/sort} would make your life easier I'd say this is the strongest reason. There are well known tools in *nix land that can solve the vast majority of the simple things you'd want to script anyways.
You can evaluate if this is good enough https://github.com/boazsegev/iodine I was looking for WebSocket comparison and benchmark, this was came up on HackersNews
That is a noise claim but what does it change? More adaptation of go in large scale biz? More confirmation it is good? Imho Kubernetes did enough good to popularize it ;) I like personally but for me biggest features are built in concurrency and solid std lib with support out of box for json, smtp etc. coming from erlang that is a lot. Go is good :) might lack solution pattern like ruby has which is called “ruby on rails” that would make all apps looks similar and finding people easy and also writing testable go code requires a bit of mindset forcing. Overall I think go is amazing :) ps. Sorry for writing from phone.
Rails is a lot more than a "solution pattern", and Go's lack of it is an incredibly good thing :)
I was thinking this, too. Websockets aren't *required* for this. They're a good solution for some of it, but you could build it using polling, or notifications, or a bunch of other solutions, some of which would work better for different parts of it. I'd definitely architect the communications code as a separate package with a solid interface so you can swap protocols out later if you change your mind. 
, err := path.local.WriteTo(p, path.remote) Wrong! You use BOTH local and remote, so check both.
Recently I wanted the same to convert gif to webp, so I made golang binding to libwebp/gif2webp here's package link: https://github.com/sizeofint/gif-to-webp maybe it helps, cheers
Acknowledged for the license, I will fix it. Otho it's faster than zerolog because by some ns because a lot of code has been rewritten, it's not a hazard. If you're not happy with this you can read it as: at least as fast as zerolog, but with a safer API and no global configuration
Your service page is a 404. https://www.scalent.io/services/golang-development-services I personally love your design. I know a lot of people don't like shadow with fixed but I love it. 
Bad marketing, bad.
Your about page has a typo in the second paragraph.
Thumbnail relevant 
I use revel and it's pretty awesome https://revel.github.io/tutorial/gettingstarted.html
Or check https://gobuffalo.io/en
Whatever you do, start with [https://golang.org/doc/articles/wiki/](https://golang.org/doc/articles/wiki/) [https://gowebexamples.com/](https://gowebexamples.com/) and [http://www.gorillatoolkit.org/](http://www.gorillatoolkit.org/) After getting those (spend a day), you may look at Bufffalo and other frameworks. 
Nice to see they fixed my complain: https://www.reddit.com/r/golang/comments/akt4p3/a_look_at_the_reworked_errors_package_feedback/?utm_source=reddit-android
Take a look at Beaver, written in Go. It has got everything that can help you with getting started! [https://github.com/Clivern/Beaver](https://github.com/Clivern/Beaver)
I'm not sure yet. But I can keep you up to date whenever I circle back to this.
Disclaimer: Dangerous half-knowledge afoot :) I only work on Linux myself. One detail I find interesting in this context is that C-interoperability actually *does* set the ground rules - sometimes. In particular, Linux is kind of special in that it provides you with a stable syscall ABI. Many Operating Systems (at least Windows, Darwin and Fuchsia (I think)) don't provide a stable syscall-ABI, but *do* provide a library with a stable C-API. That is why Go is now using cgo on those OSes to dispatch syscalls. As a result, you can't really have an Operating System based on the Darwin kernel completely "clean" of C. You have to ship at least one library whose API/ABI is completely determined by C. Linux doesn't have this restriction - which is why something like [gokrazy](https://gokrazy.org/) is possible :) Personally, I much prefer the Linux way in this matter - I think it makes for a more logical separation of concerns. But it's a matter of opinion and I believe that other vendors have their reasons for their decision :)
Cant wait to get my hands on some Actions goodness!! The waitlist thing sucks :/
To access the first item in Cars: transportation[0].([]Cars)[0] With the empty interface type information gets lost. So you have to remind the compiler manually what it was with the type assertion `.([]Cars)`. If the type assertion fails you program will panic. I would recommend you to look for an alternative that avoids type assertions as much as possible like a struct or use a more specific lets say a `vehicle` interface. 
This is a bit of a relief, that was a very annoying pet peeve of mine 
This is impressive. 
The decorator-pattern is probably my favourite pattern. A couple use cases that come to mind are: - a cache (lru) - timer - validation (of in and output) - early error handling or panic recovery - logging - registering 
Why some repos still have the darker colour?
I’ve heard of the squash flag, but I’m not familiar enough with it to say if that’ll handle it. 
Thanks for your reply. I don't understand, what you are saying about the debugger incorrectly showing the nil-pointer. But I#ll come back to that later. First let me show you the `roundRobin()`: func (s *SchedulerRoundRobin) roundRobin() *Path { s.lastPath = (s.lastPath + 1) % uint32(len(s.pathIds)) return s.paths[s.pathIds[s.lastPath]] } where `s.pathIds` is an array with the PatdIDs used as keys in the `s.paths` map. This is the stack trace: panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x5e8f98] goroutine 10 [running]: net.(*UDPConn).WriteTo(0x0, 0xc000356c00, 0x19, 0x5ac, 0x7ec6a0, 0xc0002e0d50, 0x37, 0xc00034cb00, 0x4) /usr/local/go/src/net/udpsock.go:163 +0x48 github.com/boisjacques/qed.(*SchedulerRoundRobin).Write(0xc0002da000, 0xc000356c00, 0x19, 0x5ac, 0xc000099a38, 0x6d51c6) /home/mk/go/src/github.com/boisjacques/qed/schedulerRoundRobin.go:94 +0x2f0 github.com/boisjacques/qed.(*session).sendPackedPacket(0xc0002cac00, 0xc00034cac0, 0x0, 0x0) /home/mk/go/src/github.com/boisjacques/qed/session.go:972 +0xf1 github.com/boisjacques/qed.(*session).sendPacket(0xc0002cac00, 0x916, 0x406f10, 0x7f956c020c28) /home/mk/go/src/github.com/boisjacques/qed/session.go:963 +0x18f github.com/boisjacques/qed.(*session).sendPackets(0xc0002cac00, 0x110475759, 0x9c4e20) /home/mk/go/src/github.com/boisjacques/qed/session.go:849 +0x1d2 github.com/boisjacques/qed.(*session).run(0xc0002cac00, 0x0, 0x0) /home/mk/go/src/github.com/boisjacques/qed/session.go:413 +0x850 created by github.com/boisjacques/qed.(*server).createNewSession /home/mk/go/src/github.com/boisjacques/qed/server.go:429 +0x691 For the debugger, I attached an image of the path entity in question and an path entity in a valid state. So the debugger understands the kind of pointer at `path.local`. My assumption is, that it is present at the check, but somehow it is nil when the `WriteTo()` happens. [Debugger](https://imgur.com/a/pRxpsCo)
https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk
Eventual consistency? Browser cache?
The latter.
Not sure why you're getting downvoted for asking a genuine question, and nicely too.
Its not silently, i noticed it right away, i dont know why but it bothers me
Ok, clear :-) But I must say, even after this helpful info, it's hard to find this solution somewhere in your files. I was looking for documentation but that link seems to be in a loop. This kind of info would get you more followers if you put those solutions somewhere, where they are easy to find. And I hope you will come to that, since the product seems ok and well though of.
I wholeheartedly agree. This was by far the best way I found to learn Go as it not only gives you hands on learning, but testing as well, which is very important. Thank you for creating this resource. I recommend it to all the folks I meet that are learning Go. I was actually introduced to it by a fellow on the gopher-newbies channel on slack.
Before it was too close to the python color, this is much better.
Me as well. I think I'm relating that tone of colour to Dockerfile colour in GitHub.
There's no Golang.
Play with https://gohugo.io before you make a final decision. You won’t regret it. 
&gt; Thanks for your reply. I don't understand, what you are saying about the debugger incorrectly showing the nil-pointer. The field `local` is of type `net.PacketConn`, which is an interface. One implementation of that interface is `*net.UDPConn`, so let's work with that as an example. Say, we have var a net.PacketConn = nil var b net.PacketConn = (*net.UDPConn)(nil) these two value are different. `a` is an interface value with no dynamic type or value. `b` is an interface value with dynamic type `*net.UDPConn` and dynamic value `nil`. The identifier `nil` is overloaded, to mean the zero value of many different types - in this case both an interface without dynamic value and the zero value of a pointer. In this example, `a == nil`, but `b != nil`, as `b` has a dynamic type and value (that value is a `nil`-pointer). My suspicion was, that your debugger is showing you `{net.PacketConn} nil`, when it *should* show you `{net.PacketConn} (*net.UDPConn)(nil)` or the like. i.e. it doesn't differentiate in its display between "an interface value without dynamic value" and "an interface value whose dynamic value is nil". i.e. you're running into [this problem](https://golang.org/doc/faq#nil_error) and your debugger isn't helping you by providing an ambiguous representation. &gt; This is the stack trace: That panic isn't happening in the code you posted. The panic occurs in the first line of the stack-trace: net.(*UDPConn).WriteTo(0x0, 0xc000356c00, 0x19, 0x5ac, 0x7ec6a0, 0xc0002e0d50, 0x37, 0xc00034cb00, 0x4) /usr/local/go/src/net/udpsock.go:163 +0x48 So, we can definitely see, that the `(*UDPConn).WriteTo` is called - that means, `path.local` has to have dynamic type `*UDPConn` - in particular, `path.local` is not `nil` (as in "an interface value without dynamic value"), but it has some dynamic value of dynamic type `*UDPConn`. You didn't mention what Go version you are using, so I can't really say what's in that particular line of code, but I strongly suspect that it's dereferencing its receiver which is then panicing, as the receiver is `nil` - that is, I strongly suspect, that `path.local == (*net.UDPConn)(nil)`. I assume that's because you're forgetting to check an error returned by `net.DialUDP`. It returns a `*net.UDPConn`, so it would make sense that in case of an error, you'd get a nil-pointer. Alternatively, you are simply using an uninitialized value of type `*net.UDPConn` and assinging it to a `net.PacketConn`. &gt; My assumption is, that it is present at the check, but somehow it is nil when the `WriteTo()` happens. The only way this could possibly be true, is if you have a race-condition in your code. Try running your tests with `-race`. But it seems unlikely, as it would make this issue very hard to reproduce.
Now it looks identical to the Perl color
Not sure but I fucking love GoLand. VSCode+Go extension fell down when I switched to go modules so I decided to take a look at GoLand.
&gt; I think the only valid point here against generics is that it inceases compiler complexity and slows it down. That is certainly a valid point and something to consider. But there's no free lunch. Without generics you're probably generating code before you compile it, which takes time as well. Sure, the compiler is just as fast as it was, but the total build time goes up one way or the other.
Yes! Now if they'd also change Python or Typescript to get them away from each other too... (although that white divider they've added between a project's languages does help)
Are you sure? Dockerfile's a dark gray, shown [here](https://github.com/jessfraz/dockerfiles) (or is this another change?)
It is when you're handling them in every function in the call stack whether you want to or not.
Definitely brighter/more cyan-y
Angle brackets are a terrible idea for generics because it complicates lexing. It's a historical error no other language should make. [Here's more information](https://forum.dlang.org/post/mailman.6753.1548879137.29801.digitalmars-d@puremagic.com)
"Not running directly on a real CPU" doesn't mean "it doesn't run assembler code". It means something more like "if you start up the CPU and try to run this code, it won't work", because the code requires the presence of functions to work correctly that do not exist in the CPU. For instance, malloc. There's also a C standard library that has to be there, there's some setup that even in the modern highly-C-centric CPUs still needs to be done (memory modes, etc.), and so on. Go also runs assembler directly; it is not an interpreted language. But if you try to just pick up a compiled Go function and execute it, it will fail to work as you'd hope. For one thing, as soon as the function has a yield point in it and it tries to yield to the runtime, it'll fail, because the runtime won't be there to yield to. You can run C directly on the CPU, of course, since kernels tend to be implemented in it, but it requires a bunch of magic invocations, and limits the code you can run. The Linux kernel can't just "call malloc", for instance. You can do the same thing for Rust, and it involves [turning off the standard library](https://os.phil-opp.com/freestanding-rust-binary/), because you won't have it.
I don't disagree, but the C++ examples don't make it clear to me (maybe due to my lack of familiarity with C++). I'm mostly coming from syntax that Java, C# and Rust use. I've never had any ambiguity problems with it, and since a language like Rust is using it, it can't be that bad, can it? Could you maybe elaborate on how is using &lt;&gt; different from () lexing-wise? Is it because of the conflict of with comparison operators? I'm not hell-bent on angle brackets, just having a different syntax would be nice. There's already so many pairs of () in a go func and esp. method signatures, that I'm worried it will get hard to read.
There are free licenses for core contributors to open source projects and teachers and students. https://www.jetbrains.com/go/buy/#discounts But.... ¯\\_(ツ)_/¯
wow 700 stars more because of the color
But now it's so close to the perl color
Yeah it looks dark gray to me as well. https://i.imgur.com/xuZuvKy.png
I thought it had changed, good I'm not crazy haha
Yes, before introducing the white divider barely you could differentiate Python from Go, however it will take some time to get used to with the new cyan like color.
I’d like that
This means they have changed this one too. For me this is more like the Perl color.
&gt; since a language like Rust is using it, it can't be that bad, can it? It can. I don't know how Rust deals with it, and the only reason I can think of for them having decided on that syntax is to save on the "weirdness budget", i.e. to make it more familiar to C++/Java/C# programmers. &gt; Is it because of the conflict of with comparison operators? Yes. This is also the reason why C++ required spaces when closing multiple layers of angle brackets before C++11. It's just... awful.
Fair enough. What I'm still not sure about is, how is the conflict between &lt;&gt; and comparison operators different from e.g. the conflict between type params () and normal params () ?
Thanks again for your very thorough answer and explanation. I will have to read that a couple of more times until I fully understand it. But from what I understand checking against `nil` does not work here, because it is not a `nil`-value but a `nil`-pointer. As I found the actual problem (PEBCAK of course) more for future reference: Would I check against the dynamic type to catch a `nil`-pointer?
gin is what i would suggest. Gin has everything including speed :) gin is pure gas.
You could use IntelliJ CE with the Go plugin. IDEA + Go plugin is the same functionality as GoLand, just without some of the UI cleanup.
You don't need to write any JavaScript for a blog. Concentrate on how to make a web server in Go that outputs HTML
Awesome, thank you for your responses! I think I'm getting somewhere now lol
Close(r than before), but not identical. I have a Go repo and a Perl repo sitting next to each other. Go looks a little bit lighter.
goland is perfect for golang edit and debug, i loving this tools and pay for it. goland had work out my 3 business project. also, the datagrip is cool tool for postgres DB management in business project.
Simple straightforward code. I like it!
Thanks
Would you say it audibly bothers you?
Im used to that color already,
Oh no worries bud, I was making an English pun on silent/audible. I forget sometimes that the entirety of Reddit doesn't live in my same region.
haha sorry but i don't understand the joke :D
The open-source Go plugin has not been maintained for 3 years and it's definitely not on par with GoLand. The IntelliJ IDEA Ultimate Go plugin is indeed on par with GoLand.
&gt; because it is not a nil-value but a nil-pointer. Yes and no. It's not a nil-*interface* value, because it's an interface-value that *contains* a nil-pointer. A nil-interface contains no value at all. I tend to recommend to people to read the Go spec at some point, if they want to develop in Go, because it's relatively accessible and can help clarify a bunch of concepts. The relevant section here is [this one](https://golang.org/ref/spec#Variables). In particular, the distinction between a) the static type of an interface and b) the dynamic type and value of an interface. With that nomenclature: `path.local == nil` checks whether the interface value is nil - that is, it checks whether or not `path.local` contains any dynamic value. &gt; Would I check against the dynamic type to catch a nil-pointer? There are essentially two ways you could check whether `path.local` contains a nil-pointer of a specific type (say `*net.UDPConn`): a) Type-assert that the dynamic value of the interface is actually of the correct type. Then compare that asserted value to nil: if ptr, ok := path.local.(*net.UDPConn); ok { if ptr == nil { panic("contains a nil-pointer") } } b) Compare the interface-value to a correctly typed nil. This will use the [comparison rules](https://golang.org/ref/spec#Comparison_operators), in this case &gt; A value x of non-interface type X and a value t of interface type T are comparable when values of type X are comparable and X implements T. They are equal if t's dynamic type is identical to X and t's dynamic value is equal to x. So, writing if path.local == (*net.UDPConn)(nil) { panic("contains a nil-pointer") } will check a) whether the dynamic type of `path.local` is `*net.UDPConn` and b) if so, whether the dynamic value is `nil`. Note, that there is no way to check whether `path.local` contains *any* nil-pointer. You have to know the specific type you want to check. That is by design, because nil-pointers might actually be a valid implementation of an interface (in this case they only aren't because the method dereferences the receiver). So, in my opinion, the *actually* correct way to handle this is… not :) You should trust, as a rule, that a non-nil interface value contains a valid implementation and just use it. Note, that if you've read the stacktrace carefully, you would've noticed what the problem is sooner (as the panic happens in other code). The problem here isn't "I can't I check at the call-site whether there's a nil-pointer in the interface value", it's "I put an invalid implementation into an interface value". There is no real way to defend against that; no matter what checks you add, someone might always simply put a `panic` into their method and thus create an invalid interface implementation. It is a bit frustrating that its harder to debug because the overloaded `nil` keyword, I agree. But TBQH, that's why programmers earn the big bucks :) (also, BTW: I absolutely think you should file a bug against your debugger. It could've solved you a world of pain, if it would represent interface values appropriately)
Just like other services from Jetbrains, webstorm, pycharm, goland etc, are fantastic but very pricey, the only free option is IntelliJ + Go plugin or VSCode + Go extension.
I don't *wholeheartedly* disagree, but our opinions differ: &gt; the cost of adding keywords ... is a small price to pay I think the cost of adding keywords is large. Two keywords is 8% of all the keywords currently in Go, which has 25 keywords vs 31 in Python, 32 in C, 46 in JavaScript, on up to 102 in C#. I write a lot of C#, but I struggle to read some C# programs (even my own old ones!), as it's hard to keep all of that in your head. &gt; ...for the code cleanup that it enables. I don't find the current error mechanisms in need of cleaning up. &gt; But a one time cost of learning how a new language-level feature works Added complexity isn't a one-time cost, but rather an ongoing cost - and an exponential one, since every new feature must interoperate with each existing feature. &gt; The language being lean isn't the strict advantage many people think it is. The core problems don't go away, they just get pushed into userland code. Generics and better error handling constructs allow the language to solve problems that the user would otherwise have to solve. I don't think of verbose-but-simple error handling as a core problem of Go (except perhaps during the first few weeks when I was learning the language). Wrapped errors with better context, yes, but that's explicitly not part of the check/handle new-keyword draft. Generics, yes, but this discussion isn't about generics at all.
Yeah I'm a big fan of JetBrains' IDEs. I use PhpStorm, PyCharm, GoLand, and DataGrip every day. I'm considering checking out WebStorm because I'm already used to all of JetBrains' keyboard shortcuts.
Before the PR of color change, it was like that of current Perl's. [https://github.com/github/linguist/pull/4331/commits](https://github.com/github/linguist/pull/4331/commits)
It's not bad when you're paying month to month. It pays for itself if you're coding for work.
I read somewhere that a good part of github is now written in Go. This may explain that nice attention. 
There's no need to use any JavaScript framework on the front end. Of course, you certainly _can_ use one if you want to and feel it's worthwhile.
A few days late, but your suggestion got it working. I put rand.Seed(time.Now().UnixNano()) before my shuffle and it's working as expected now.
Hello, if you want scalability out of the box then take a look at Centrifugo server (https://github.com/centrifugal/centrifugo) or Centrifuge library it is built with (https://github.com/centrifugal/centrifuge). 
You can submit the colour change as a PR which is a grisly what happened.
GoLand is not free because JetBrains earns money on selling products, not advertising or personal data of its users. GoLand does not have a Community Edition because, unlike IntelliJ IDEA, there is no way to separate its functionality into free and paid tiers.
haha, aw, nice!
This feels kinda like poorly written ML tried to generate a marketing website.
Don't know either. I usually don't participate in the go community and this is the reason ;-)
Besides what /u/yole mentioned already, here is a more detailed answer. In addition to free licenses for students, teachers, open-source projects, JetBrains provide a considerable discount for startups, training courses, universities, educational and non-profit organizations. Please visit this page to learn more: https://www.jetbrains.com/go/buy/#edition=personal?discounts. Besides that, yearly licenses, or 12 months continuous payment comes with a perpetual, fallback license. Also, we offer a continuity discount: for example, 20% discount for an uninterrupted subscription from the 2nd year, and if you have paid for a GoLand subscription for 2 continuous years, this makes you eligible for a 40% discount from the third year. The personal edition can be used at work as long as the company does not pay for the license, and you can use it both on your personal and on the work computer, so it's not bound to a single computer. Another reason is that we don't know what we can remove from the IDE without making it less useful for users. Should we remove the [Go Modules support](https://blog.jetbrains.com/go/2019/01/22/working-with-go-modules/)? Or the [debugger](https://blog.jetbrains.com/go/2019/02/06/debugging-with-goland-getting-started/)? Or perhaps should we remove all the refactorings, such as [Change Signature](https://blog.jetbrains.com/go/2018/10/19/refactorings-change-signature/) or [Extract Interface](https://blog.jetbrains.com/go/2019/02/04/goland-2019-1-eap-2-is-here/)? Or some of the [completion features](https://blog.jetbrains.com/go/2019/01/17/code-completion-in-goland/)? We also have the [Go Templates](https://blog.jetbrains.com/go/2018/12/14/go-templates-made-easy/) which we could remove, but is that good for someone using the free version? We are always happy to hear feedback from you.
No. Really not.
Any suggestions? :)
Who cares about unimportant things like this?
You might be interested in this package: https://github.com/yosemite-open/go-adb adb uses a client server model so you can just implement you own client. Binding to an existing client seems more difficult. Writing a wrapper around the cli tool like go-adb does works too tough less elegant. In any case you need to have the SDK installed just for the server.
Docker
Docker. Multi stage build into an alpine image. Means it can easily be dropped into kubernetes or just run as a plain docker container. Everything is configured via env variables. There have been a couple times where I just cross built to windows and ran it as a service. That’s useful for tiny deployments, and gives me restart on crash safety, although that’s rarely an issue. 
You probably got a signed jwt, so you can validate the signature to make sure nothing changed. If a single character changed, you'd get a hash mismatch when validating it. Or, likely your library does that validating because to be secure, there are a lot of things to check, so that's probably what your library is doing for you. In that case you could set the jwt and make sure your library keeps validating the signature (probably done in the request chain or however it says to use it. This is called implicit flow, if I remember correctly. Or do what I do... I don't like the user holding their own jwt even though it is tamperproof with a signature. I use code flow, which means the user returns from the login page with a code that I exchange serverside for a token and then on the page the oidc provider redirects to I give them my own application token that I code through code flow. You either get a secret that is pre-shared or the library reaches out to a "well known" url to get a public certificate to verify with. One of the confusing things at first is that oidc terms overlap but don't totally match oidc terms, and additionally, there are multiple code flows to pick from and tons of flexibility. The most secure is code flow, and it's basically 1. redirect user to the oidc provider's login page with the required information in the url. 2. have a callback url that you land back on that had a code for the server (which it exchanges with the oidc provider for a jwt that your library probably parses into a neat struct for you) 3. use that jwt to construct a response. It's probably a page that simply sets your own application's auth token and redirects you back to your website.
Now it looks like the Dockerfile color lol. 
With Kubernetes or what?
&gt; P.s. It currently only works on Linux. I just tested on macOS and it works too.
&gt; P.s. It currently only works on Linux. I just tested on macOS and it works too. Your code depends on a library called [reujab/wallpaper](https://github.com/reujab/wallpaper) which is cross-platform so it should work on macOS, Windows, and Linux. You may want to remove that disclaimer from your README because thanks to this library your tool works in other operating systems too.
Shamelessly, rsync ¯\\\_(ツ)_/¯
Thanks for the feedback! I've tested it on Windows with no luck. I think it has a problem with creating a directory. As macOs and Linux have same type of file systems it works, I'll fix the readme and later I'll try to fix the problem so it becomes cross platform thing! Again thanks for your time!
Double color for python? Crossed circle with yellow/blue sectors? Tbh, I think it will be confusing.
almost all, rsync , ha.
build in docker but deploy by rsync / sftp.......
I didn't know there were different plugins and that you couldn't use the maintained one in IDEA CE. Good to know.
rsync FTW! &amp;#x200B; Also, the binary has code to auto restart itself when a new binary is detected. (This isn't appropriate for every use case, obviously. But can be really convenient.)
no no no , goland core value is all refactor related function and debuger . it's core of Efficiency and productivity . it's why i pay for.
[This might help](http://lpar.ath0.com/2016/05/27/openid-connect-introduction/).
The performance of Code with go modules is seriously killing me, hope improvements are coming soon 
Multistage build a docker image, push to a registry, update the Kubernetes deployment files and apply them to a k8s cluster. (All automated by a bot running as a gitlab runner)
I have a very simple setup. I cross-compile a binary for Linux, scp it over to the server, and run it there. I have a .txt file with the exact deploy commands written down as a reference, so I can reuse them.
okay -- well you're in the position of having to write a parser for your already parsed json data. you have to scan the resulting data structures for tokens you're interested in and take action on them. the `map[string]interface{}` you're left with becomes a language of its own if you don't know what keys to expect. this is a major design flaw. if this is for work or something and you don't feel empowered to push back on this, i recommend trying. coming up with a reasonable json structure will make the code simpler, save time, and it is simply the right thing to do. to the point: you should practically refuse to consume json like this.
The IDEs cost $8.9/month or $89/year in first year, with up to 40% discounts from the third year of licensing for the personal license which can be used for commercial projects and both at home and work (if the workplace allows you to do so). We are always happy to hear feedback from you, so if you could suggest what could be a better pricing that would make it easier on the budget, please let us know. Thank you.
All color changes on GitHub are open source: https://github.com/github/linguist/pull/4331
Same, plus the build and deploy commands are all run by a short alias with zsh (oh my zsh), like “ttt appname” and and the script eventually stops in the bash session on the server in the deployment directory so I just do “./appname” and it runs on the server
can you show me how that's done?
Goimports runs only as a file watcher. Actually I have found that goimports seems to fight with the builtin automatic imports and optimise imports setting. I get this behavior where they both run and imports jump in and out. And I will get a pop-up about whether I want to accept the filesystem changes or in memory changes. If I disable goimports file watcher, it doesn't happen 
Thanks, man! This looks awesome!!!
You better do not use goimports with go at all: 1) It doesn’t aware of go modules 2) GoLand can insert import statements itself 3) Unlike goimports, GoLand will give you a choice if several matches are found 3) GoLand has styling options for import statement: grouping, sorting, etc: Settings/Editor/Code style/Go
Finally, an agreement was reached. The Go-bikeshed is now painted gopher blue. 
In my studio I use versioned deployments to a network mount, and supervisord. We are migrating towards a Kubernetes approach soon. 
Thanks. Problem is that it’s a legacy tool without dev support. It’s been on the chopping block for awhile, but still hangs around 
CI/CD pipeline using Concourse-CI. 1) Unit test, linter and integration test (against DB) run in parallel 2) Build &amp; upload artifact to repository (backed by S3) 3) Deploy artifact to staging server (via Chef) 4) Quick functional test (aka smoke test) 5) Run end-to-end suite, including installation, configuration, security, recovery, compatibility, load and volume tests 6) Canary deploy to single prod server 7) Another smoke test (against canary) 8) Deploy to rest of prod To answer your questions, production readiness is determined by several criteria. 1) Quality. Achieved by a thorough suite of unit, integration and e2e tests. 2) Capacity. Bit of a dark art here, but through iterations of installation and load / volume testing, ensuring our service can handle the traffic it will receive. 3) Operability. Ensuring a set of tools exists to operate and maintain the service. 4) Visibility. Extracting metrics and logs from the service and building dashboards to gain quick insight into the health of the service. 5) Alerting. Building systems to react to suboptimal service conditions. When combined with Operability, some conditions may be corrected automatically. 6) Documentation. For the bits we cannot automate, ensure that docs are in place so that anyone charged with maintaining the service knows how to react to any sort of failure. To give you an idea of the scale at which our apps operate, we're in 12 data centers around the globe, servicing 1MM active customers at any one moment. Happy to answer any questions.
If you want to play with http, you could use Mercure: [https://mercure.rocks](https://mercure.rocks/) &amp;#x200B; ### What's the Difference Between Mercure and WebSocket? [WebSocket](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API) is a low level protocol, Mercure is a high level one. Mercure provides convenient built-in features such as authorization, re-connection and state reconciliation ; while with WebSocket, you need to implement them yourself. Also, unlike Mercure (which is built on top of HTTP and Server-Sent Events), WebSocket [is not designed to leverage HTTP/2](https://www.infoq.com/articles/websocket-and-http2-coexist). HTTP/2 connections are multiplexed and bidirectional by default (it was not the case of HTTP/1). When using Mercure over a h2 connection (recommended), your app can receive data through Server-Sent Events, and send data to the server with regular POST (or PUT/PATCH/DELETE) requests, with no overhead. Basically, in most cases Mercure can be used as a modern and easier to use replacement for WebSocket.
O M G
What websocket package are you using? gorilla's websocket, one of the more popular ones, seems to work the way you're asking for already. I'm not sure what package you're using.
I'm not sure what exactly you're asking for. Can you give a concrete example of requests and responses?
I agree that server sent events can have value and what not, but I don't think asking the OP to infect his code w/ AGPL stuff is reasonable.
&gt; So I'm wondering if there is some way to cast / assert / pass the request as a websocket connection to the other handle / signature. Sure, websockets just upgrade the existing http connection. See https://godoc.org/github.com/gorilla/websocket, you can take your request and response and upgrade them (assuming you haven't written anything back yet).
Datagrip is integrated in all of these, except Webstorm, and Webstorm is a subset of PHPStorm, in other words PHPStrom is Webstorm plus Datagrip and PHP (info from the product pages). I started to use Datagrip at the beginning of aquaintance with JetBrarans stuff, turned out there is no point if use any other IDE of theirs
The rust lib is not that complicated, why not implement using CGo directly, rather than producing this weird chimera, and requiring the rust toolchain?
Didn't watch the video, but should be noted Lorca requires users install Chrome and webview doesn't have EdgeHtml support merged yet as the slides may indicate (but, getting close) so it's still IE.
The problem is you don't understand what websocket is to begin with. You should learn about pure socket programming.
You wouldn't believe it... [but there was quite the commotion when they changed the color of Rust](https://github.com/github/linguist/pull/4319)
I appreciate the Rust author's abstraction and cross platform work and find the duplication of it to have little value here. This isn't a "weird chimera", it's just CGO too. Requiring the Rust toolchain isn't that burdensome. Were I to rewrite it, I wouldn't exclusively use Cgo, I'd use syscall for some parts. Still, that requires a lot of testing and cross-platform dev work whereas I cranked this out in a couple hours off and on over a day. It wuld be complicated, the devil is in the appearance of simplicity.
We have our stuff deployed in ECS with Docker containers. Builds happen on Travis for every commit. If the branch name is "testing", "staging", or "production", then the build is automatically pushed to that environment if the tests pass. It's almost too easy.
&gt; Requiring the Rust toolchain isn't that burdensome. Matter of opinion. &gt; I wouldn't exclusively use Cgo Sure, I mention CGo because at least on Linux you'll need XCB SHM to do efficient captures.
https://www.jetbrains.com/community/eap/ Free.
Yeah I'm aware of this, I do like having a single full screen window though.
 &gt;The problem is you don't understand what websocket is to begin with. My working knowledge is that it's some high level bullshit on top of tcp that involves a handshake and then a message stream with keys to decrypt the messages. &gt; You should learn about pure socket programming. I'd love to if I could, done it before with Java, C#, node, etc, but I'm using websockets because that is what browsers have and I'm communicating with chrome. Are people using websockets for regular programs? 
Sounds like I have a bit of reading to do, it would make sense that the websocket implementations are doing that under the hood with the response writer and request structs I'm already used to. I saw the websocket connection type in the method signature and despaired early, it seems. I'll just take a look and do what they do! 
I wish there was a combination of the two approaches. Namely the chrome.dll/.so exposed a minimal C iface. I know it's a bit difficult w/ Chrome's multi-process requirement, but I'd love `--single-process` to make a comeback and be supported too :-) I had high hopes for Servo embeddability back in the day before that was deprioritized.
We are a small shop running Debian servers, so each of my go projects have scripts to build the binary, and then build that into a deb package along with all other stuff (default configs, logrotate and rsyslog configs...) And pushed to our debian repository. When the time is right (usually during a maintenance window), someone updates the packages manually or using ansible.
this looks bad
The golang.org websocket package provides websocket.Handle which takes a connection struct from that package. Net/http request and response structs - that's what I am referring to. For example, the method signature would be something like Http.HandleFunc("/route", func(w http.ResponseWriter, r *http.Request){...}) What I would like to know is if it would be possible to catch an icoming socket request and serve a websocket connection. Like what property of http.Request contains the websocket and how I establish a connection to the client with it. I know the websocket package provides is own handle function that makes this easy, I was just hoping to use that in a sub router, which mine currently operates entirely by passing the writer and request around through plugins. That last bit might sound pointless and terrible, and it is. I built a little application gateway that loads a folder of plugins, puts them in a map[string]func and hands off control of the application to plugin. 
kubectl rollout 
I don't know why everyone is assuming the worst of my understanding of the language and the structs I mentioned &gt;_&gt; I already have a working http.Handle("/ws", websocket.Handle(...)) and the question is merely if I could get to that point with the method signature from http.HandleFunc instead so I don't have to rebuild my router to support multiple protocols. I'm also asking because before I registered the websocket handle, I did see the request come into my existing router. So I'm wondering what I need to do with that http.Request and ResponseWriter to do what the websocket package is doing. Though maybe the negative assumptions are warranted as the 2nd reply suggested the obvious thing I overlooked - just go see how the other packages do it. At a glance I thought websocket.Conn and http.Request we entirely different structs, thus my asking what magic was needed to get one from the other. 
same, but I use a Makefile. My deployment command is just "make deploy" and it works everything else out from there. The only thing I'm unhappy with in the process at the moment is how I'm handling secret keys. I want a better answer than creating environment variables on the server, but haven't found one yet.
Hey! Thanks for sharing. &amp;#x200B; I came across that package before, indeed. It seems it would resolve most of my problems but I'm afraid it means the user has to have ADB installed on his end, otherwise the commands will not reach the server. &amp;#x200B; One of my goals is to actually avoid having users installing the ADB beforehand and somehow already include those binaries to work with the bundle.
&gt; Are people using websockets for regular programs? There's very little reason to. Websockets only exist because 1) people wanted to give webbrowsers more powerful networking capabilities 2) people didn't dare to give webbrowsers the ability to use arbitrary TCP protocols.
[removed]
They have been talking about this for forever. :)
First of all, define your entire deployment methods using code, automatic CI/CD, no ssh/scp/random scripts being run. This is way more robust and in the event you become incapacitated (sick, holiday, death), someone else may figure out in a couple of hours to days how to deploy your app. I am currently quite happy using CircleCI fo my tests, builds and deployment triggers. Depending on the IaaS or PaaS, I will either let k8s, heroku or GAE handle the rest. Go works great in combination with Docker, although the images are slightly heavier, 18mb vs 22mb, not significant in my opinion. Usually, I will provide multiple builds for my apps, Docker, bare-metal and PaaS configs, and let users decide. You can run a server as a CLI, or as a Helm chart. This works great for e2e testing. It really depends on your use cases, I got some personal stuff running on a shared server, some open-source stuff at GAE and thinking of exploring Azure next.
depending on your needs, this is a perfect setup. The weakness is you, and someone else picking up your work. They will need to be familiar with your servers, your preferences, etc... Although it might sound demeaning, every time I find myself being a key component, I attempt to remove myself (after causing personal and professional failure by being a key player.) If this is not relevant to your case, SCP and `./my_app` will work fine.
Why? What do you use to handle errors right now?
Came here to say that since I got tagged in that pr. Definitely not silently
Check ever so often for a new hash and use exec to load the new one
Yeah. They were worried for the longest time about the users making a fuss about it. This is also not this first time its been talked about on this sub.
Don't you need the entire SDK anyways, because of the sdkmanager and the adb-server? For what operating system are you developing?
In the future it should be cross-platform. I guess we'll need to deal with each platform separately. For now, I'm focusing only in Linux. Unless I am perceiving wrong what the lib is, I really think that having the binaries bundled with the rest should be enough.
Saddly i am stuck at IntelliJ, its a very good IDE, i love it and use it every single day. Since I am a student and not earning money, or not doing any professional work, its not worth buying it, and my university is pushing students towards using vscode, which is fine, but intellij is far better with autocomplete, debugger and formating, but i tried for web dev and it doesnt work well because i can imagine, there is webstorm for that purpose. Atm Intellij is enough for me, i would love to have ultimate instead of CE but another time maybe.
My 58$ per year for Goland is totally worth it!
It’s just meh... I wanted to love it. I still might... but it needs some work.
That’s unfortunate as it looked goof from the screenshots :( guess ill stick with gitlab-ci!
I'd highly recommend giving the latest vscode-go a try, they fixed debugging, however you will want to use `bingo` with it instead of `gocode`. https://github.com/saibing/bingo/wiki ``` "go.alternateTools": { "go-langserver": "bingo" }, "go.useLanguageServer": true, "go.languageServerFlags": [], "go.languageServerExperimentalFeatures": { "format": true, "autoComplete": true, "rename": true, "goToDefinition": true, "hover": true, "signatureHelp": true, "goToTypeDefinition": true, "goToImplementation": true, "documentSymbols": true, "workspaceSymbols": true, "findReferences": true }, ```
Github commit on master triggers a Buildkite pipeline. That pipeline runs lints, tests, and a final image build, then pushes that image build to AWS ECR. Linting and Testing are both implemented with Dockerfiles as well; the image build will fail if the lint/test fails, and if it doesn't we throw away the image. Once the image is pushed, the pipeline pulls a centralized repo which contains all of the kubernetes resource definitions in YAML, updates the image tag, then pushes that commit back to that repo. That kubernetes repo has its own Buildkite pipeline which scans for the changed files, then applies the changes to the cluster. In the case of an image change, we kubectl rollout. The centralized kubernetes repo is a major bottleneck in large teams, because its trivially possible for two concurrent builds, potentially for two different services, to pull the same HEAD, one commits and pushes, the second tries to push and fails. Our team isn't big enough for this to happen. The advantage is that we get a linear, central commit log of every deploy that's ever happened right on Github, and the same exact system is used for rolling out configuration changes. Kubernetes is hosted on AWS EKS, using eksctl to provision worker nodes. Its been fine. I wouldn't suggest anyone who wants to invest in Kube opt for AWS, for a few reasons. Ultimately we do have to manage our own worker nodes, which means keeping the OS and packages up to date, and often this simple process will unexpectedly crash the kubelet on the worker node, which means the simplest way to get the latest updates is to just provision brand new workers with the latest updated AMI. Not the end of the world, but you're outsourcing keeping these AMIs up to date to, I guess in our case Weaveworks, which is another layer that slows down being on the latest most secure packages. Additionally, AWS has practically zero integration between EKS and the rest of AWS; CodeDeploy, Fargate, the list goes on. EKS is expensive, and AWS makes you feel like the ugly stepchild forced to live in a closet, scolded for touching anything in the house, made to watch golden child ECS get all the cool toys for Christmas. I genuinely believe EKS was the result of a couple engineers fighting management against all odds, and today they get scraps for funding while management waits for customers to get so fed up that they migrate to ECS. 
You can make it even smaller by using FROM SCRATCH. 
GoLand EAP is free for a month after each release.
People tend to have kind of a strange obsession over making images as tiny as possible. Small is better, but squeezing a 15MB image down to 8MB is rarely worth the time or energy. I go with multi-stage into alpine image like parent post. Interestingly I tried [distroless](https://github.com/GoogleContainerTools/distroless) images but they ended up bigger and were harder to work with.
Woohoo, less outdated stuff, more attention spent on the good stuff.
That's great if you are a student! We offer all our tools for free to students and teachers, see https://www.jetbrains.com/student/ You can also refer your University to have a look at that page or send a mail to our sales at JetBrains dot com department or directly to me, florin at JetBrains dot com for any questions or issues regarding this.
As PHP and Go are my primary languages,I’m very happy about the change because it was nearly identical to PHPs color prior.
Exactly. It most of my images end up using alpine for the base, I’ve saved a whopping 7 MB over 2GB. Big deal. It’s not like that multiplies out; docker is layered so it shares that 15MB. 
You can use gofmt and let the IDE manage the imports, as it will do it better and without the need to save the file. As for the pop-up on file system chances vs in-memory one, please open an issue on the tracker https://youtrack.jetbrains.com/issues/Go as I have not seen such a report before and maybe it's something that we can fix. Sorry for the inconvenience.
Either I'm missing something simple or the approach is wrong / not doable. Either an http.Request with an incoming socket request / handshake can be used to instantiate a socket or it can't. I feel like what I'm asking isn't that difficult to understand. 
I wish there was a vet pass that showed deprecation warnings.
Same really, but staticcheck will warn about them!
I did open a ticket a year ago : https://youtrack.jetbrains.com/issue/GO-4595 The original person helping me couldn't repro it and referred me to another ticket. Someone was able to repro it but said they couldn't think of a way to fix it. 
&gt;You can use gofmt and let the IDE manage the imports, as it will do it better and without the need to save the file. &gt; I could. But Goland doesn't sort them the way goimports does which results in commit noise unless everyone uses the same configuration 
If you go to Settings/Preferences | Editor | Code Styles | Go you will find a setting to configure the imports sorting to match that of goimports. If that option is enabled and you still encounter issues with it, please let me know.
To my knowledge the new File Watcher plugin solved some issues. Also, we added a built-in template for configuring goimports, which should be used as is, without further modifications. If you still have problems with it, then please let me know. At the moment I'm unable to reproduce this, regardless how fast I type after saving the file, so maybe the SSD on my ultra portable laptop too fast?
You can use File Watchers with the gofmt template and let the IDE handle the imports as it will do it better than goimports. Also, you can try having gofmt run as a pre-commit step from the built-in VCS commit dialog, which will remove the need to spam the save action. Finally, you can invoke goimports manually by assigning it a keyboard shortcut under Settings/Preferences | Keymap as we don't have a default shortcut for it.
Oh wow. I will look for that. 
Possibly. The use case is that I work on shared nfs mounts because I can log into different workstations. The race is quite frequent for me. I was working on something using the echo framework and it kept kicking it out and bring it back and my code would toggle from red to resolved. 
Many of VS code issues with go mod is that the built in tools in go don't all support go mod yet.
You can use any database that would store blobs. You could put it in something like Cassandra if you wanted, but Cassandra already has proper key/key/value storage. 
In that case how could I implement something like foreign key constraints. 
NoSQL typically doesn’t do RDBMS things like foreign keys. For that you can use Postgres or MySQL/mariadb. I’m not sure why you would want protobuf stuff in a database tho. Databases do a pretty good job of packing data in for indexing and retrieving. May be useful for unstructured data. 
They changed that couple of years ago if I remember correctly 
Yes, there is no foreign key constraint in NoSQL's but we can mention the object ID of one mongo doc in the other and then resolve/populate that ID while retrieving. This works as a workaround. Can the same be possible if protobufs are used? 
There is already library that doesn't use CGo on Windows and Linux here https://github.com/kbinani/screenshot , and it does use MIT-SHM shared memory if available on Linux.
Personally, I consider openpgp part of the good stuff. It's also the only one where I actually agree with the arguments for deprecation (the others seem stable enough to not require much maintenance), but it still makes me sad if it goes away.
Nice, I'd forgotten about BurntSushi's native X libs.
As Deus said, you can store marshalled protobufs as a column in all DBs that can store blobs. E.g. using a SQL DB you can have a table with a column id (e.g. type int and primary key) and a column called proto of type blob. Then you can query by the id and use it in other tables as a foreign key.
Please don't put oauth information in GET query parameters. They should be POSTed with a urlformencoded body or set in the authorization header.
How does this relate to [ory/hydra](https://github.com/ory/hydra)? Is it good advice to implement a oAuth server on your own? Are there any security concerns or is this a bullet proof implementation?
I logged in with my university account and it wasn't a problem to get the license. And boy this is great, IntelliJ ultimate is everything i need but i installed DataGrip too for databases course. This is great. Thanks a lot.
I just went through this decision. I ended up going with PostgreSQL with sqlx, building a separate models package to describe the schema of the database. I use Protocol buffers solely for transport, with struct methods on the models to convert to and from pb.
Thanks. My sole purpose of trying this was if PBs help in reducing size occupied on disk. It makes me now clear that PBs are solely for transport. 
We use it Kubernetes and our pipeline looks like this * Jenkins builds and tests, uploads container to our docker repo * docker container deployed to dev, testing * same container moved to q, testing * same container moved to production The deployments to the various kubernetes clusters are done with helm or argocd
Staticcheck does.
If you need to query it, go for Postgres and look at the jsonb data type, or just use regular structured tables. If you just need to store it, flat files work perfectly fine, as does any key value database or any relational database that supports blobs.
Tank you, I will give it a try!
I would 100% pick hydra over rolling your own. OAuth2 is only one part of it. You really need OpenID Connect paired with it and getting them both right is full of funny edges. Hydra’s model for user login and consent means you can implement whatever you need / want and not have to muck with the low level protocol at all. This from the Hydra readme sums it up: &gt; OAuth2 and OAuth2 related specifications are over 400 written pages. Implementing OAuth2 is easy, getting it right is hard. 
Well this was more of a rhetorical question ;-). If someone advises to build a key value store on your own, it's one thing. If you're presenting a solution on how to implement protocols for securing resources I'm not sure if this a good idea at all. I would at least add some information for the reader to never run this in production. TLS encryption is missing but even if it were secured via TLS this doesn't seem like a secure way to run OAuth? A beginner might think that rolling your own OAuth Server is easy and it's only a matter of time before we see the next user information data leak. That being said it's a good idea in general to make complicated protocols more approachable.
!remindMe 3 days
I will be messaging you on [**2019-02-12 16:09:23 UTC**](http://www.wolframalpha.com/input/?i=2019-02-12 16:09:23 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/aoow9u/build_your_own_oauth2_server_in_go/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/aoow9u/build_your_own_oauth2_server_in_go/]%0A%0ARemindMe! 3 days) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
As someone who maintains an Oauth provider. Don’t roll your own. The spec is huge and easy to fuck up something. 
How do you create deb packages? Do you use something like fpm/nfpm? 
We used to, but we now do the packaging 'by hand'. I highly recommend this blog post to get started: https://vincent.bernat.ch/en/blog/2016-pragmatic-debian-packaging 
The above comment requires upvoting into the astral plane. If I had 1 dollar for each time I asked a third party to not implement OAuth from scratch and use a library...
If you want to work on OAuth and Go.. please go help one of the big libraries instead of doing your own thing. 
I only have time for a quickly written fairly rough answer. Use channels to pass values through the different stages of a pipeline. The simplest pipeline would be one which passes values through to different functions. You can think of it in the same way as an iterative program except instead of passing parameters to the next function you put them onto a channel and the next stage consumes from the channel. v := function1() v2 := function2(v) v3 := function3(v2) becomes function1() -&gt; chan1 -&gt; function2() -&gt; chan2 -&gt; function3() Logically it's just as simple, the added complexity is mostly in the enclosing function to create the channel variables and set off each function as a separate goroutine. However with this design you can scale the pipeline. You can create multiple instances of either `function1()`, `function2()`, or `function3()` if one of them has become a bottleneck in the overall process. A great example of the use of pipelines is [netcap](https://github.com/dreadl0ck/netcap). There is a [dissertation](https://github.com/dreadl0ck/netcap/raw/master/mied18.pdf) available in the repo which describes the software in great detail, including a concurrent processing pipeline to handle collected data. If you are struggling with Go's concurrency primitives in general I recommend reading the Concurrency chapter in 'The Go Programming Language'. [Go by example](https://gobyexample.com) has four simple examples for how to handle channels starting [here](https://gobyexample.com/channels). If you are confident in your general programming ability and the basic constructs of Go I'd recommend reading [Concurrency in Go](http://shop.oreilly.com/product/0636920046189.do), its a comprehensive reference about how to utilize concurrent designs in Go, and relates them to common concurrency design patterns. There is a specific section on pipelines in Chapter 4.
So awesome, use some flags to cut out debug stuff. My latest multistage from scratch container is a whopping 1.6 mb.
Building your own can be a great learning experience. It's a quick way to become familiar with the nuts &amp; bolts of a spec, practice your API design skills, get up to speed in a new language, etc. Where it becomes a problem is when you see advice like this, where the author suggests that you might want to deploy your hand-rolled OAuth implementation in production: &gt; *This will be very helpful if you want to build a production ready public or private API. So let’s get started.* Bad idea, particularly when you're dealing with authentication or (god help us) crypto.
Oh yes, you’re right of course. But never to deploy into production. 
any recommended ones?
Of course. Just use the same data type as the key, and save it. No real issue there. 
Thanks for the prompt answer ElectronicWater. I understood the pipelining concept but how do I handle pipelining when goroutines are involved. Will this design automatically handle concurrency ?
Hi. Thank you for the feedback. The benefits of such API is to allow *very fast streaming JSON serialization* while being safe, unlike zerolog.
I believe it is. Multiple returns most likely also have multiple different errors. Returning nil makes sure that there is no result when there is an error, otherwise, what do you get? A partial result? Something unknown?
You either link to an endpoint that generates the QR based on querystring and reference it as image source in your template. Or write the QR image to the file system and link to that as IMG src. Or base64 encode the image and include as data URI embedded in the template.
[removed]
[removed]
Not to be pedantic, but it's properly a tool to hack into remote docker daemons, not containers, right?
Well, you access the docker daemon through a vulnerable container (which exposes the docker socket) and that daemon gives you access to the container (through \`docker exec\` for example)
I will concede I'm still not 100% following you, but the gorilla websocket implementation may be able to do what you want, because it works by being in a handler and then you call "upgrade" with the websocket support. I don't know about the golang.org one.
Why would someone mount in the docker socket into a container? Seems really silly to me, except for things that need to manage the docker daemon (not the average container, more like tools like portage). 
Hi. You need to pass channels to each coroutine. Channels are threadsafe. Example (syntax maybe wrong since writing from mobile) ``` ch1 := make(chan int) ch2 := make(chan int) go func1(ch1) go func2(ch1, ch2) go func3(ch2) ``` Here the pipeline will look like func1 -&gt; ch1 -&gt; func2 -&gt; ch2 -&gt; func3
I will just try and come back to you. Thanks, it might just save my day.
A better way to have asked the question maybe would be: is the websocket built on top of http.Request somehow? This is part of a side project at work so I'll be able to answer that myself Monday when I am able to test stuff. Or I'll probably just go to the gorilla project source and look of my curiosity gets the best of me. = For whatever reason when I saw websocket.Handler that accepts a connection type from that package I made the assumption that it was fundamentally different from the http handler because it's also provided by the go team. Thus asking if there was a way to get a websocket.Connection from a http.Request. I'll check later because I can't do anything with the answer until Monday. I do appreciate the common sense direction, thanks. 
I don't know about in prod but I've seen people use an nginx reverse proxy in a container that checks the info of other containers for ENV vars matching a pattern as a way to dynamically add new routing config for those newly started containers. Usually that's in dev but I wouldn't put it past folks to do it on hobbyist/small projects.
JS is single threaded. What happens if you add a call to https://godoc.org/runtime#Gosched ?
Ah ok. I can see wanting to do that then in small scale. 
Is this how you meant for my particular code ? [https://play.golang.org/p/rS8hALsS6h3](https://play.golang.org/p/rS8hALsS6h3) ``` package main import ( "fmt" "time" ) func main() { ch1 := make(chan int) ch2 := make(chan string) go func1(3, ch1) go func2(ch1, ch2) for val := range ch2{ fmt.Println(val) } } func func1(seconds int, ch chan&lt;- int) { time.Sleep(time.Duration(seconds) * time.Second) fmt.Println("In func1") ch &lt;- seconds close(ch) } func func2(ch1 &lt;-chan int, ch2 chan&lt;- string) { fmt.Println("In func2") for val := range ch1{ fmt.Println(val) ch2 &lt;- "hello" } close(ch2) } ``` I think now, I am getting the hang of it ( not sure, will need to practice a bit too ) Can you show me some other examples for the same ( if possible ) ?
Yes, this is what I meant. Tomorrow I can give you more detailed pipeline from project I have done recently. Just think about channels like a message queues, goroutines like a worker threads. Golang will think about threadsafety, so it's really simple to create pipelines.
You can see many examples of such cases in the wild on [https://www.shodan.io/search?query=product%3A%22Docker%22](https://www.shodan.io/search?query=product%3A%22Docker%22)
The Google cloud build service does this, so that you can run docker commands sensibly. The security barrier is that this is on a 1-shot VM used only for this session, and no one can connect to it from outside anyway.
Can you have a look at my updated code, I made some edits. I need to remove those deadlocks. Thanks a lot, it really meant a lot to me, I have literally invested almost the whole day in understanding how to get this working ( almost for the last 13 hours or so, breaks in between ofc) .
And yes please take some time to share those code snippets, it would really strengthen my concepts regarding these. Thanks a lot.
The pipeline pattern is relatively common in Go. You have a data producer called 'source' and a final consumer called 'sink'. In between you have arbitrary transformation steps. You usually range over channels and close the source when it is depleted. The only difficulty is proper error handling. It usual looks something like this: func source(out chan&lt;- sourceType); // close this channel when there is no more input func step1(in &lt;-chan sourceType, out chan&lt;- type1) { for item := range in { out &lt;- actualFunc1(item) } close(out) } func stepN(in &lt;-chan typeN-1, out chan&lt;- typeN); func sink(in &lt;-chan typeN); var ( c1 = make(chan sourceType, bufferSize) c2 = make(chan type1, buffSize) cN-1 = make(chan typeN-1, buffSize) cN = make(chan typeN, buffSize) ) go source(c1) go step1(c1, c2) go step1(c1, c2) // spawn multiple but watch out for double closing channels (sync.Once) go stepN(cN-1, cN) go sink(cN) You can wrap them into closures if you need more control. If some step is slower than the others you can spawn multiple instances of this worker.
I'm using this light framework, https://echo.labstack.com I saw some benchmarks and it's clearly faster than others
That's some really nice structured example. Thanks. Would you mind taking a look at my current code ( I have understood the concept ), it's getting deadlocked cause I'm not able to properly close the channels. I have added `sync.WaitGroup` too for the same, here is the [Playground](https://play.golang.org/p/Fk0fiSQA-Hq)
To be able to build containers from inside other containers.
That's not what protocol buffers are meant to be used for. You might use them if you are writing your own DB but not if you are using an existing DB.
This is an interesting tool and I would like to check it out. At work we run a cloud like service and let users run arbitrary containers on our host VMs. I also recently added a feature to build container images (via a kaniko builder) and run them on a host. This is all for ML. Docker runs as root on the host. What are some ways to run this tool given this use case to check security. If you were to make a container from this code and then run it you would potentially get access to other containers images on the host? To be clear, only one container is ever running on the host at a time. 
When you have multiple writers you need to have WaitGroup. Each goroutine will have pointer to the WaitGroup and defer Done() function of the WaitGroup. So channel will be closed in main thread after wg.Wait() call. This means that we wait until all writers completed the work and we can safely close the channel.
Yea that makes sense, as it’s a management container. 
That’s a really good example of a good use case. 
Here would be an MWE: https://play.golang.org/p/9ERIMmjC6yd
Thank you all for you suggestions! I will check those out and see how it goes.
[https://play.golang.org/p/DV0w6YBUEtB](https://play.golang.org/p/DV0w6YBUEtB) I have changed a little bit your code. When you have multiple writers you need to use sync.WaitGroup (please see my comment below in another thread). Also, you need to use buffered channels, so where will no deadlock between writers. A not buffered channel allows only 1 message in the channel. Regarding real example, you wrote it by yourself and I fixed some things:)
I think this is probably the cause. Probably in the future we'll be able to use goroutines and we'll have a web framework that will handle stuff like this for us. In the meantime, you'll have to do it yourself.
You have disabled Garbage collection, why?
So that I can do it manually with runtime.GC() for testing purposes and to see what happens in real time.
This is common practice in some [build pipelines](https://docs.gitlab.com/ee/ci/docker/using_docker_build.html#use-docker-in-docker-executor) .
this logging platform we use recommends doing it, I'm guessing to grab logs from the central daemon? https://www.scalyr.com/help/install-agent-docker This relevant part: "As mentioned above, the typical command to start the Scalyr Agent command is below:" docker run -d --name scalyr-docker-agent -v /tmp/api_key.json:/etc/scalyr-agent-2/agent.d/api_key.json -v /var/run/docker.sock:/var/scalyr/docker.sock -p 601:601 scalyr/scalyr-docker-agent
Yea I’m seeing a bunch of good responses for use cases for it. Very interesting. I was more thinking about using it in ones own customer facing services, but these are all good options. 
docker:dind does not mount the host docker daemon. hence "docker \*inside\*docker".
Are you disagreeing with me? I am not sure what you mean. A year or so ago it was common to mount the docker socket so that you can interact with the docker host daemon. Is there another method?
Why not just use Consul?
Golang is a GC language so its pretty pointless trying to fight that, if you want manual control over GC then use a different language as 99.9% of code written relies on GC. GC rarely gets in my way, use pprof to profile the code to see if it does. The few times GC has gotten in my way it was easily worked around with a preallocated resource pool or buffer.
[removed]
[removed]
[removed]
https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk 
Perhaps you should share the original code that you think was leaking memory, rather than trying to hijack the GC. You can analyse with \`runtime/pprof\` and/or \`runtime/trace\`, or we can probably spot a memory leak. &amp;#x200B; The stdlib HTTP server certainly doesn't leak memory by default.
If you allow the docker socket to be mounted into the container, the container is effectively system root.
[removed]
[removed]
Gosched doesn’t appear to change the behavior. Good idea though. Seems like I need a way to split my callback function into multiple functions, and hand control back to the JS thread as needed.
I remember doing an experiment with this once and all it took was a simple ```docker run -it ubuntu bash -v /:/system-root``` or something similar from within the container and suddenly you have a root shell on the host file system, fun fun fun!
I am not trying to fight it, I am simply fiddling and trying to understand how things work, read what I wrote "testing purposes" as in trying things out not putting things in production or attempting to skew how things were meant to be used. This all started when I created a simple Hello world http app and noticed RAM usage keeps going up and up.
This is very common. Generating domain names for containers created at run time for instance, but my favourite example is user permissions for containers that are started at run time. Done right it's beautiful, done wrong and it cripples and organisation as pinning it down is a mare 
This is the original code. its a simple Hello World app. I am not hijacking the GC for evil motives or to try to change how things work. I just want to expedite the GC process so that I can see if it actually cleans things up. but to my surprise the heap numbers just keep going up. How should I go about understanding how things work if I dont attempt to fiddle with low level stuff. Should I 
No actually a lot of people do it to use docker in docker. Because dind has apparently some issues. The author of dind wrote themself, that to expose the deamon to the container, would be a good alternative. That is why this post is so interesting.
Generally I agree, then I got to PGP. It’s still pretty widely used so I don’t think it should go. It’s not broken per se, but it it is certainly getting outdated. Would be a mistake to drop it. 
*Hey just noticed..* it's your **3rd Cakeday** shovelpost! ^(hug)
Assuming root created a user group for docker, beforehand. So that you could run this command without pw.
Most of our apps are Java so we have to do things the Java way, that means using the Jenkins CI/CD pipeline. Thankfully, we've generalized the pipeline so that whatever app, be it Java or Go or .NET, can flow through it smoothly.
You say above that: &gt;This all started when I created a simple Hello world http app and noticed RAM usage keeps going up and up. ￼But, I can't reproduce that. RAM usage settles quite nicely. I run this: package main import ( "log" "net/http" "os" "os/signal" "runtime/trace" "syscall" ) const hello = `Hello world` func main() { sig := make(chan os.Signal, 1) signal.Notify(sig, syscall.SIGINT) f, err := os.Create(`trace.out`) if err != nil { log.Fatalln(err) } defer f.Close() err = trace.Start(f) if err != nil { log.Fatalln(err) } go func() { &lt;-sig trace.Stop() os.Exit(0) }() http.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) { writer.Write([]byte(hello)) }) http.ListenAndServe(":8888", nil) } And hit it with a bunch of clients, then view with `go tool trace trace.out`. RAM spikes but drops after GC, and returns to baseline when the clients are stopped. There's no leak there that I can see.
FoundationDB has a layer designed for storing protocol buffers: [https://www.foundationdb.org/blog/announcing-record-layer/](https://www.foundationdb.org/blog/announcing-record-layer/). Similarly, Google Cloud Datastore works pretty well with the generated types: [https://cloud.google.com/datastore/docs/concepts/overview](https://cloud.google.com/datastore/docs/concepts/overview). Otherwise, you options are pretty much what others have described (assuming you want it indexable with some ability to assert constraints):- \- Serialise to JSON, and store in Postgres JSON field (you lose some benefits of backwards-compatibility) \- Similar to above, you can map the generated struct into some underlying data abstract object, that is, an ORM \- Store blob in a blob store (Postgres works too), and index serialised JSON into ElasticSearch (or other search engines)
CockroachDB
It all runs in a goroutine. On startup, read the date of the existing binary (keep it in mem somewhere). Check for presence of binary by file name. Use date to determine if it is newer than the date on the binary at startup. If newer binary appears just do a controlled exit and let init system (e.g. systemd) restart it.
Yeah, I've seen a few similar things where the docker daemon is monitored via the socket file, and any changes are then used to apply new configuration options *inside* the container. I wouldn't be surprised to see that kind of situation in production quite often.. *sigh*
This one about channels may be useful, too: [https://youtu.be/KBZlN0izeiY](https://youtu.be/KBZlN0izeiY). &amp;#x200B; There's also this about the evolution of go from its original compiler to a self-hosted infrastructure by Rob Pike: [https://www.youtube.com/watch?v=KINIAgRpkDA](https://www.youtube.com/watch?v=KINIAgRpkDA)
Money and time probably. This tool seems like the equivalent of a GitHub scraper looking for keys/config. 
&gt;A year or so ago it was common to mount the docker socket so that you can interact with the docker host daemon. Not wrong at all, and this is still the case. I think the person who replied to you was suggesting - or under the impression - that you were using a "*[docker-in-docker/dind](https://hub.docker.com/_/docker)*" container as part of your build process. For most situations this is a *[bad idea](https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)*. In fact, mounting the docker socket from the host is the recommended way for build environments - due to the need for caching.
It does :) You can also do things like package foo const red = gx.Color{255,0,0}
I'll contact you this summer :) Actually you'll be able to try it out online next month.
He was referring to the Volt app. V the language will be released this summer. You will be able to try it out online next month.
`docker-in-docker` was never mentioned..? If you're using that image to build other containers then you may want to rethink your approach too. (i.e [lack of caching, and issues with nesting](https://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/).) Mounting the socket and interacting with the host Docker installation is likely a better way. 
&gt; I was more thinking about using it in ones own customer facing services, but these are all good options. ever use a load balancer? Sophisticated ones listen for docker events on the host (by listening to the socket; bound into the container) and are very very very public facing.
The ones I use take events from kubernetes so I haven’t seen that behavior. 
No readme ;-) Don't use those relative looking package imports "Linky/config". It implies that I have to clone it to the root of a GOPATH as Linky. Instead use your github namespace like "github.com/dummyuser123456/Linky/config" so that if you "go get" the project, it will be in the correct place. Or look at using Go modules and commit a go.mod file so I could check it out anywhere I want. NewLinkService has the chance of going into an endless sleep loop of there is an error connecting to the db. It's not really common to have a constructor do this. The point would be to properly initially your object. You should do the database connection looping in another call, because it would be surprising for the constructor to not return like this.
Couple more... Don't commit your binary build. And you should be able to use the standard Go db driver to allow a pure Go sqlite3 option so someone could use this without postgres. It would make testing easier too 
Traefik relies on having the socket mounted for it.
Oh no, the readme didn't commit by mistake, sorry! I've fixed that. I will look at changing up the imports to address that point and I can definitely make it DB agnostic. Re: the looping, there are limited attempts so it should end eventually - originally I had it just log.Fatalln(err) but when I introduced docker-compose I needed to have the server wait for the postgres container to be ready and I wasn't sure if just sleeping a random amount was any better. Appreciate the comments!
Nice post! I am trying to call wlanapi and extract information elements from WLAN\_BSS\_ENTRY, but this [API](https://docs.microsoft.com/en-us/windows/desktop/api/wlanapi/ns-wlanapi-_wlan_bss_entry) provides me `ulIeoffset` and `ulIeSize`. It's quite simple to use offset in C or even Python. C++: ```c // Information Elements PBYTE pIeRawData = (PBYTE)bssEntry + bssEntry-&gt;ulIeOffset; PBYTE pBeaconFrame = (PBYTE)&amp;beaconFrame[index]; memcpy((void *)pBeaconFrame, (void *)pIeRawData, bssEntry-&gt;ulIeSize); index += bssEntry-&gt;ulIeSize; ``` Python: ``` def __process_information_elements(self, bss_entry): self.raw_information_elements = b"" bss_entry_pointer = addressof(bss_entry) ie_offset = bss_entry.IeOffset data_type = (c_char * bss_entry.IeSize) ie_buffer = data_type.from_address(bss_entry_pointer + ie_offset) for byte in ie_buffer: self.raw_information_elements += byte ``` But in Go, I don't know what is the difference, maybe GC? I used this code but cannot get the expected value. ```go entry := blist.wlanBssEntries[i] pEntry := unsafe.Pointer(&amp;entry) fmt.Println(*(*[255]byte)(unsafe.Pointer(uintptr(pEntry) + uintptr(entry.ulIeOffset)))) ``` And my whole project is [here](https://github.com/AmyangXYZ/GhostTunnel-Go). Could you give me some advice? Thanks!
What about specifying a dependency in your compose file? https://docs.docker.com/compose/startup-order/ 
Doesn't work unfortunately - it (per my testing) only waits for the container to start, but the service itself won't be ready so the connection will fail. There are a couple shell scripts (https://github.com/vishnubob/wait-for-it) you can use to get around that but it felt...heavy? I'll have to explore how to handle that type of situation better. Really do appreciate your input though! I'll definitely make all the changes above asap.
No problems on windows 10 for me &amp;#x200B; do you have a copy of the error message?
I tested it on Windows 10 too. Error was "Couldn't Create Directory" In downloadImg function.
Wtf is a service bus...
Should be a line after that with more information I suspect a permissions issue
Yeah I know, I'm not at the computer with windows 10 installed, I'll try it as soon as I get my hands on it.
This is really helpful with references to books and other resources. Many thanks!
What am I missing here? you are scanning for open docker HTTP API ports right ? simply mounting /var/run/docker.sock as a volume between 2 containers isn't going to make it show up running on the container on an externally available IP/Port, unless I'm missing something ? Couldn't you just do with this a few lines of bash piping name output to a docker -H command ?
"How to allow the community to destroy a good language" spf13 edition.
[https://github.com/golang/go/blob/master/LICENSE](https://github.com/golang/go/blob/master/LICENSE)
For now it only does that yeah, but I'm currently coding the attack part which uses the docker client library. I find it better than to use the user's binary, which is why I use a language like Go for this. What I'm currently doing is going to try let the user have an interactive terminal as root on the vulnerable host through the exposed docker socket.
Popular frameworks are gin and gobuffalo. I believe both coming from previous rails developers.
Ok cool. I was thinking I was missing some way that simply mounting the unix socket into a container made it vulnerable, which would make this a really big deal as like others have said, many proxies use this method (such as traefik). I love to find cool stuff like this to use as a reason to build stuff in go too :) Just for education sake also, metasploit does this : https://www.exploit-db.com/exploits/42650
Why not same account as OP?
Kind of sounds like a successor to their Azure Event Hub? From the link: &gt; The Service Bus package provides concise idioms for sending and receiving messages over the AMQP 1.0 protocol as implemented by the github.com/vcabbage/amqp package. &gt; &gt; Azure Service Bus is a managed message broker that offers queues for one-to-one, service-to-service communication and topics and subscriptions for pub/sub-style messaging. It provides reliable asynchronous communication between microservices without requiring management of a complex broker infrastructure. tl;dr: sort of like Kafka, but on Azure.
I actually work for Containous, on the enterprise edition of Traefik, so yep I know about this, hehe. But still, some of our users tend to use the \`--api\` option on their production and end up exposing their socket, despite the documentation being pretty clear about this not being a good idea. Thanks for the metasploit link :)
Or more in general: https://en.wikipedia.org/wiki/SOLID :) 
How did you get to this conclusion? Honestly no ill will, just confusion.
Logged into diff account on diff devices.
very cool. I'm currently banging my head against trying to proxy chronograf via traefik (as part of the tick stack)
I have to say, there's no "framework" in Golang most likely (I was finding a framework for Golabg like Laravel in PHP before). Instead of calling them as framework, it's more like a "library". Since you were using Rails before, it's a great framework which might makes you feel "wtf" while using Golang to write the web service from the beginning. It's kinda hard to explain about this since I'm not a native Engliah speaker. Anyway, I will suggest (and I'm also using them): `Gin`, `Echo`, or even the native `net/http`.
What do you mean by this ? 
Tricky question. They do. But they open sourced it. The license is about you can use it as you want but you have to refer to the original licence. Github also has rules. If Google would decide remove Go language source code from Github, anyone would has the right to republish it because of it was already published at least once by Google in the past. But the development, brand, core team controlled by Google. You can fork it create something else from it legally like go++. It does not bother me. I like the fact that there is a huge rich entity - Google - who cares about the Go.
Those are very real issues indeed, I guess the advantage is that of improved security of not mounting the host docker daemon.
What is bothering you, specifically? 
&gt; There are just so many web frameworks around […] This is quite ironic because many Go programmers will tell you that you don’t need a ~web~ framework for your Go projects. But I’m not surprised to see such a long list considering that many web developers with backgrounds in Ruby on Rails, Node.js, PHP are the ones behind these projects. It is understandable, they want to have the same tools they had before. I don’t have any recommendation, I don’t use a framework, but they all seem to offer the same features, so I guess you can choose whichever has the best name (?) or the most similar syntax compared to your programming background. [1] https://awesome-go.com/#web-frameworks
I watched a talk by one of their head developers. He’s hilarious. Yes, it’s basically rails ported for Go. I didn’t consider a framework until I saw his talk and how it pretty much does everything rails does. Very impressive work. 
I'm just pointing out that there is also a possibility of building docker images inside a docker container without mounting the host docker daemon with docker:dind
I certainly wasn't suggesting/recommending it, both methods come with drawbacks, "docker:dind" does not allow access to the host docker daemon which is more secure. "docker:dood" does mount the host docker daemon which gives you caching, etc.
Are you referring to gin or gobuffalo?
Buffalo. :)
"SELECT * FROM tag" Then "SELECT * From item a where not exists (select 1 from tag where b.item_id=a.id)" 
I believe and hope that the simplicity of Go make it more resilient to failure. 
after testing/using almost anything out there I'm now down to just using [httprouter](https://github.com/julienschmidt/httprouter) and standard libraries template engine.
Yes it does. And while the language is de jure open source the deciscions made for the main fork are really top down. In manner of "we discussed and I've decided". So de facto community doesnt have much sway. But the real concern of mine is that Google is very politically biased company which holds monopoly, bullies competitors when possible, tries to close of users in their ecosystem and does not respect privacy. "Don't be evil" was lost. I've been moving away from all Google services after James Damoore Google memo scandal which revealed how ideological / far left the company culture is.
After trying many frameworks, something really clicked with Echo for me. For me, it's simple, just works and it's fast. Kind of reminds me of Python's Flask. For me, it's the perfect balance being a minimalist framework... just a little more than just using the stdlib taking care of all the boilerplate I wanted, but not a complete full stack. I still feel I'm in control of everything I want and need. The documentation is awesome too. Echo devs, if you are reading this... thank you very much for Echo... I appreciate all the hard work that went into this. 
maybe map DB's data relationship to go struct is must, maybe is not. it's need case by case to . &amp;#x200B; for me , maybe this way 1: \----------------- \`\`\` **create schema temp**; **set** search\_path = **temp**; **create table** item ( **id INT generated by default as identity primary key** ); **create table tag** ( **id INT generated by default as identity primary key**, **name VARCHAR**(160), **item\_id INT references** item (**id**) ); **create view** item\_tags **as** **select id**, ( **select** *array\_to\_json*(*array\_agg*(*row\_to\_json*(taglist.*\**))) **as** array\_to\_json **from** ( **select tag**.**name**, **tag**.**id** **from tag** **where item\_id** = item.**id** ) taglist ) **as** tags **from** item ; *-- golang query this maybe* **select** *row\_to\_json*(**row**) **from** ( **select** *\** **from** item\_tags ) **row**; \`\`\` &amp;#x200B; then go query this: \`\`\` **select** *row\_to\_json*(**row**) **from** ( **select** *\** **from** item\_tags ) **row**; \`\`\` and get json to unmarshell to go struct. &amp;#x200B; &amp;#x200B; but, way 2: \--------------------- why two table in DB ?? why not just one table like this \`\`\` **create table** item\_with\_tags\_json ( **id INT generated by default as identity primary key,** tags json ); \`\`\` &amp;#x200B;
I develop on Linux, cross-compile, and use Ansible to deploy to remote servers. 
The honest answer is there are no reliable frameworks in my experience. At least buffalo seem to be travelling in that path. But I would be a bit skeptical about using any framework until it reaches at least 1.0 and a few months (if not years) in prod and mature. Also, one gripe that I've with buffalo is it tries to do web+frontend stuff too (js etc.), while I wish something like django-rest-framework that exists only for developing HTTP APIs. The lead developer of buffalo has an infectious enthusiasm and at least for his sake, I wish the project succeeds :)
On an unrelated note: for a closed source app, once compiled and shipped, how can Google/someone claim that the app has been developed in Go and license guidelines not respected? 
What are your requirements regarding a web framework? It's often not the web, people want a kind if full stack handling CRUD till the DB. When talking about the web you indeed don't need one. Take a look at http.Handler, http.HandlerFunc, and http.ServeMux. They are the most important parts you need to distribute and handle web requests. I created a personal toolbox around the standard in https://github.com/tideland/go/tree/master/net/webbox. Still adding a few more helpful functions. Feel free to copy the parts you need. Only be aware that every 3rd party library with its own dependencies drives you deeper into the dependency hell (the reason why my little lib only depends from the standard lib).
AtmanOS - a golang unikernel \- GopherCon 2016: Bernerd Schaefer - Go Without the Operating System [https://github.com/bernerdschaefer](https://github.com/bernerdschaefer) allows you to cross compile go programs to run directly on Xen hypervisor \- port of go's runtime and standard library to the microkernel and system packages \- currently around 3000 line of go and 150 lines of assembly &amp;#x200B; &amp;#x200B;
They can't. Even if someone would use licenced technology on a private server that would be impossible to tracking down. I mean you as Google can not go to a business and say that "Hey they use my tech without my permission!". That would require insight info from that business and accusation against them. I think the license and forcing people to follow the license it's two different things. Last one is beyond technology, it's law. However it can be supported by technology, but it could be difficult after they open sourced the whole Go stack.
Great article! The difficult part for me is deciding when and how to say "no" to someone. I.E., the person expended a good amount of time and effort to implement a given feature, but you're not sure adding that is giving the right direction to the project, or the future maintainaice effort is worth to having it. But for sure guiding contributors is part of being an open source maintainer.
All languages have a de facto BDFL or steering committee of some sort, otherwise nothing would get done ever. The "Google is a neo-marxist monopolistic company pushing for vendor lock in" is 50% nonsensical and 50% irrelevant to the discussion.
Yes. But that doesn't address the point: 1) They generally are not top-down. 2) They don't serve private interests of a coorporation who competes for end user market. I wish it was nonsensical. But evidence is out. Overton window is skewed far in the left. [https://cdn.static-economist.com/sites/default/files/images/2018/09/articles/body/20180922\_USC938\_0.png](https://cdn.static-economist.com/sites/default/files/images/2018/09/articles/body/20180922_USC938_0.png) and sillicon valley companies seem to be leading the charge. You can also read class action law suit against google by it's own employees when people are being bullied and fired for 'wrong-think' 1984 style. The relevance of this if ofc personal responsibility. Willful blindness is a choice one is free to take.
But in law words, is someone (police, whatever) entitled to peek into your business, based on someone's claims? Once they put their nose into my code to investigate the claims, they have to analyze the whole and basically, I'm done. They have my "secrets", if you know what i mean. Isn't this a violation?
For example by providing evidence that the Go runtime is included in the binary (e.g. by representing dissassembly and/or a call-graph or something like that - most easily, by pointing out the symbol-names, as long as they are not stripped). Because this would be a civil case, not a criminal one, they don't need to prove it beyond reasonable doubt, but only make a sufficiently strong case that the judge agrees with them. They also can use discovery to request internal documents pertaining to the software (e.g. issues, E-Mails…) and find mentions there. If they can present a relatively good argument that it's a reasonable suspicion (which should be pretty easy), they can probably even force disclosure of the source code (if nothing else, to an arbitrator). *Proving* in a civil court that a software is written in Go is actually pretty easy, I'd imagine. It requires first having the suspicion, though, which seems harder. Then again, I can't really imagine a reason why anyone would violate the Go license, is super permissive. It basically only requires you to state that you're using it (by including the copyright disclaimer), which companies don't lose anything from.
&gt; Once they put their nose into my code to investigate the claims, they have to analyze the whole and basically, I'm done. They have my "secrets", if you know what i mean. Isn't this a violation? There are multiple things protecting you here. a) You can refuse discovery by claiming trade-secrets. b) A neutral third party can investigate the claim (usually the court, I'd guess). c) It is illegal for them to use any secrets they learned from discovery. Meaning, if they do, you can countersue. And I would assume that violating these rules would actually be a criminal offense, which is a much stronger protection than the license. In general, law is complicated (and IANAL, mostly working from first principles here). But there *are* protections in this case and general engineer-mindsets like "if they can see the code, they can use my secrets" doesn't apply. Corporate lawyers will be *very* careful about that.
&gt; And while the language is de jure open source the deciscions made for the main fork are really top down. In manner of "we discussed and I've decided". So de facto community doesnt have much sway. I don't think this conclusion carries. Yes, the decisions are done top-down, but they are not done in a vacuum. The Go team has a vested, personal interest in making sure Go succeeds (their jobs literally depend on it), so they do listen carefully to anything the community has to say. Cases that are cited as evidence to the contrary usually use a very biased notion of "the community" (usually it's "people using Go who agree with me") and "listening to" (often it's "if they don't do it exactly as I want, they didn't listen").
Yes, I agree, it's a violation to use closed source code without license. But if I call the police and say "Facebook use stolen secret Google technology" Police would need to make sure I don't lie. *How do you know that information?* \- they would ask. Police does not have the right by law to look over all of the Facebook source code. They would need more specific information about the crime before they act. If police or any organization what does the investigation is not careful enough that can make financial damage against the company and they could suit back the Police. So, a stolen secret code only can be revealed if someone knows that specific secret. If your project is one-man-business it's impossible to become a suspect. But in this case is almost impossible to get real amount of money from that business because it's too small - since it's a one-man-business. As your business grown, more people have to be employed. Your income increases, more people know about your secret, and the damage what you cause to the company what owns the license is also increasing. And the risk that someone suits you is also increasing. I think the main question are that person just made a product for himself from that closed source code? Or he also makes money from it? Does he sell it? Does he do it directly? It's sophisticated and depends on a lot of things.
[removed]
Or you can have a join struct that represents single relationship. Post Tag PostTag PostTag would represent a link /join between single tag and post. Both Post and Tag would have many PostTag. 
Really, you don't want to think of it as mapping tables to structures. It's really queries to structures. From that point of view, mapping many-to-many queries is no different than any other query.
I asked the same question a couple of month ago. The responses mostly encouraged using only Go standard library. I did that and couldn’t be happier, it works great and doesn’t require almost any set up The net/http package is a framework in its own. It has templating, a router and practically everything you would need something like flask or express for. Most other frameworks are just a thin layer on top of it designed to make it look like something from another language but the only missing functionality was server side session. The only package I am using is scs session manager. In fact, I was so happy with the idea of writing my own that I even went back to my react front end and replaced some imported stuff with my own optimized code. 
Thanks a lot for sharing that :)
Here, is it necessary to use buffered channel for `ch1` , cause `func1` is always slower and also it is the source ( so it only needs to send the message to `func2` ). Also, I see you've put `defer wg.Done()` after the `time.sleep`, any specific reason to do so, after all, it will only be evaluated when the function finishes right ( Only it's arguments are evaluated ) ? &gt;The deferred call's arguments are evaluated immediately, but the function call is not executed until the surrounding function returns. 
Google spearheaded the project, and so became the stewards. The license has always been the same, a google branded bsd style license. Anyone can 'fork' the project to take it in another direction. However, if you want to contribute to their project then you have to play by their rules. There is no denying that the project is under the thumb of Google, but who cares.
Curious, why put everything in `internal`? Looks like lots of useful components that could otherwise be reused or extended without requiring a fork.
that's basically MIT with defensive modifications
Because that way their APIs can be changed. Otherwise, it could be problematic if people depended on them, and then chasquid changes could cause accidental breakages to others. That said, I've externalized a few packages already ([log](https://godoc.org/blitiri.com.ar/go/log), [spf](https://godoc.org/blitiri.com.ar/go/spf)) based on requests, so if there are some internal packages that you are interested in using, let me know!
I only have experience using go's templating through writing Helm charts, so this may not be correct in all cases. The way I was able to treat templates as functions was by creating a dictionary and passing that in as the current context and then hard-coding the key you want.
Control by a company that already controls far too much.
Same here. I'm only starting to use Go but I have subscribed to their All products license for a couple of years. As a professional software developer they are absolutely worth it, Even if I were not in this profession then I still think they are worth the money.
Note some APIs explicitly return valid data even with a non-nil error. E.g. any [`io.Reader`](https://golang.org/pkg/io#Reader).
How about some usage examples? What does it do? I've been thinking about building something like this for myself lately, it sounds interesting
It really depends on the package you are using for db access, so I'd check up on the documentation. Are you using an "ORM" like gorm, a light-weight package like sqlx, or raw db/sql? In general though, I would recommend reading up on how struct scanning works. That will give you a good baseline knowledge on how result sets are mapped to structs. &amp;#x200B; In addition, the way that you structure your structs depends on other factors such as your applications query patterns. For example, you may have some paths where you want eagerly fetch all of your data, and other times where you only want the parent.
Exactly, where the error is used to signal for example EOF. Not because they don’t care and think an error alone is sufficient. I think you always need to be specific to make sure that other developers touching the code also understand what’s expected. Or maybe I don’t understand the question clearly...
I mean in a small way I'm kind of with you in terms of large companies controlling platforms and languages like this (certainly Oracle's moves to monetise Java updates falls into this category), but describing Google as "neo-marxist" would be disputed both by marxists and the people who run Google. In the case you described Google is mostly concerned with not artificially restricting its labour pool and how one of the largest coherent blocks of potential workers - women - who account for about 30% of their actual staff would be repelled by the company allowing such obviously discriminative views to be publicly accepted into the company culture. It's less ideological and more just wanting to keep the labour market as open as possible for them. It's a cold, hard business calculation and almost the exact opposite of marxism in that it just attempts to maximise shareholder value.
[removed]
[removed]
Hi, your project looks really cool and I'll give it a try when I have some free time. I've been working on a similar [project](https://github.com/cezarmathe/trackexpenses-android), it's an Android application, and they have quite similar concepts, it would be really cool if my frontend app would use your backend api, I might look into it.
[removed]
Thank you for the tip, I'll try it out.
Unless you are working on a system that you know will need aggressive disk optimization I wouldn't worry about this. You'd lose queriability for little space savings.
Create the channel and then pass it into each go routine. I use this for a network crawler/search indexer and it works well.
Looks like a great concept, though I don't think I'm the only one who cringes at the thought of having to say the word "Hexya" in any professional setting.
This doesn't answer my question though. What kind of control are you afraid of Google applying to the Go project? It is an open source project that can be forked, and is maintained by a large number of people, not all Googlers. While the top core maintainers happen to work at Google, the project can be maintained by anyone. So.. What specifically are you worried will happen? 
As a person who's tried out a lot of them, if Echo is a cousin to Flask then what would you say is the best Go alternative to a big batteries-included framework like Django?
I would avoid using frameworks, they aren't really needed in Go. Instead, I would learn how to use the Handler/HandlerFunc pattern that in the standard library, and then choose router/middleware packages that are compatible with that pattern to reduce boiler plate (gorilla/mux, chai, Alice, etc)
There seems to be pretty thorough postman documentation linked at the top of the GitHub readme.
&gt; ripzap is an update of zerolog taking this concept to the next level with a **simpler** to use and **safer** API and even better [performance](https://github.com/bloom42/rz-go#benchmarks). so now it's not a fork but update? Are you trying to increase the value of your project with this obscure terminology? &amp;#x200B; &gt; give an advantage of some ns to ripzap There's no advantage. Your benchmarks fluctuate between runs making zerolog faster in some runs and rz-go in others. The difference is statistically insignificant. What's more important are allocations which are exactly the same. Not surprising, given that it's basically zerolog. &amp;#x200B; &gt;Did you read all zap, zerolog and ripzap code and understood it before commenting and see why it's not lame ? I read and compared all of your code and it is lame. It's not just JSON streaming encoder: * array.go - same * ctx.go - same * defaults.go - part of zerolog/globals.go * encoder.go - same * encoder\_cbor.go - same * encode\_json.go - same * event.go - same * fields.go - same * formatter\_console.go - refactored zerolog/console.go * hook.go - same * http.go - zerolog/hlog/hlog.go ported to new API * loglevel.go - part of zerolog/log.go * sampler.go - same * writer.go - same That's not even core functionality. That's all of zerolog with a bit different API pretty much all of which is in config.go and logger.go That took some work, no denying that, but your library is still pretty much zerolog.
Hi, just intall the Go extension (Rich Go language support for Visual Studio Code (from Microsoft, that's correct). That's all you need to start programming Go in VSCode. For build, install, ect you can either open a command line (my preferred method) or use the control pallete (ctrl-shift-P, type go and ...) BTW, a few VSCode handy extensions: * Bracket Pair Colorizer * TODO Highlight * Bookmarks and another handy feature it's breadcrumbs, you can toggle it on from the view menu option &amp;#x200B;
Nicely done! It's a little amazing how much this resembles my own project (https://github.com/aclindsa/moneygo). I didn't exhaustively look through, but here are a few thoughts (more comments than criticisms): * I opted to create an abstraction layer for my 'store' instead of using the database directly. This allows for mocking out testing differently than you might otherwise be able to, and might make it easier to change out how you structure your database later, without having to change code all over the place. * I prefer double-entry accounting * What do you think about allowing users to add their own currencies? Then the responsibility for maintaining them as they inevitably change is shifted away from the maintainer. It's probably okay if you're only dealing with currencies, but if you start dealing with other securities like stocks or mutual funds, it gets harrier. * Currencies have different levels of precision - maybe you handle this, but I didn't immediately find where.
[Buffalo](https://gobuffalo.io/en) is probably what you're looking for. I think it was inspired my Rails. It's the only big framework in Go that I know off the top of my head.
This is what I ended up doing. https://stackoverflow.com/a/18276968
I have.
The `http` package.
It turns out to be a an issue regarding slashes... People can't seem to whether they want to use forward or backwards slashes? &amp;#x200B; Take for example: [http://www.wadewegner.com/2014/12/easy-go-programming-setup-for-windows/](http://www.wadewegner.com/2014/12/easy-go-programming-setup-for-windows/) C:\Users\dev&gt;go get github.com/golang/example/hello C:\Users\dev&gt;tree C:\Go_Rust_Work\go Folder PATH listing Volume serial number is 82CD-B1F1 C:\GO_RUST_WORK\GO ├───.vscode ├───bin ├───pkg └───src ├───git │ └───dev │ └───hw └───github.com └───golang └───example ├───appengine-hello │ └───static ├───gotypes │ ├───defsuses │ ├───doc │ ├───hello │ ├───hugeparam │ ├───implements │ ├───lookup │ ├───nilfunc │ ├───pkginfo │ ├───skeleton │ └───typeandvalue ├───hello ├───outyet ├───stringutil └───template C:\Users\dev&gt;%GOPATH%/bin/hello &lt;-------Why would you set GOPATH=C:\Go_Rust_Work\go then use /bin/hello for the call? That doesn't work! 'C:\Go_Rust_Work\go' is not recognized as an internal or external command, operable program or batch file. C:\Users\dev&gt;dir C:\Go_Rust_Work\go\bin Directory of C:\Go_Rust_Work\go\bin 02/10/2019 02:40 PM &lt;DIR&gt; . 02/10/2019 02:40 PM &lt;DIR&gt; .. 02/10/2019 02:45 PM 1,956,352 hello.exe 1 File(s) 1,956,352 bytes 2 Dir(s) 337,553,252,352 bytes free C:\Users\dev&gt;C:\Go_Rust_Work\go\bin\hello.exe Hello, Go examples! C:\Users\dev&gt; But, given the system's environment variable for Windows cannot be GOPATH=C:/Go\_Rust\_Work/go. How am I expected to get this to work? It makes no sense. 
I think for most of usecases one dones not need any framework for web development in golang. A small library like httprouter is enough. In my project, I am even not using httprouter. I wrote my own tiny custom router according to the project needs. 
An example using multipart.Reader would be extremely helpful. multipart.Reader will allow you to read the parts of the uploaded file(s) directly without storing the whole file(s) in memory. 
Great suggestion! I'll have a look at getting some example code together now :)
*Woah!* It's your **5th Cakeday** jh125486! ^(hug)
I can post some of the code I have tried, but unfortunately I’ve had no luck and the files end up corrupted. Great video by the way thank you for sharing!!
the cost of such api is \~20ns for 12 fields because we need to loop. Do you think it's worth ? (it's a real question). Benchmark10Fields/uber-go/zap-4 1000000 1127 ns/op 0 B/op 0 allocs/op Benchmark10Fields/rs/zerolog-4 3000000 514 ns/op 0 B/op 0 allocs/op Benchmark10Fields/bloom42/rz-go-4 3000000 509 ns/op 0 B/op 0 allocs/op Benchmark10Fields/z0mbie42/rz2-go-4 3000000 536 ns/op 0 B/op 0 allocs/op &amp;#x200B;
Would love to see this become a Caddy plugin. Would get automatic TLS for sending mail over TLS without needing any configuration. [https://github.com/mholt/caddy/wiki/Writing-a-Plugin:-Server-Type](https://github.com/mholt/caddy/wiki/Writing-a-Plugin:-Server-Type)
The `.vscode` in your GOPATH indicates that you're trying to open that as your workspace root. Your workspace root should be the directory your code lives in, for example, `&lt;GOPATH&gt;/src/github.com/golang/example/hello`, or if you're using modules, wherever you check out your code outside of GOPATH. Also see: https://golang.org/doc/code.html On the topic of "slashes", Windows uses backslashes in file paths, UNIX-y OSs like Linux and macOS use forward slashes. Go uses forward slashes for import statements. I think you would benefit from starting by working with the `go` tool in a command prompt, rather than trying to do it with VS Code tasks, especially if you're unfamiliar with the language.
Compared to the kind of control Oracle has on Java and how a significant portion of the industry is dependent on it, I don' see what the fuss is about Go being spearheaded by Google. The language is open and you can write your own compiler. The compiler and standard lib are also open source. What more do you want. Unlike with Java, there is no run time that they can suddenly lock behind a paywall out of the blue like Oracle did with Oracle JVM. 
todo highlight just doesn't work for me on windows 8.1
I'm simply asking what everyone else thinks about it which will help inform my own opinion. I don't know enough about Go - it's very new to me. I'm looking at expanding my skill set and Go seems to be the trend right now so I'm exploring it. Personally I hate the company and wish it would die but the popularity of the language definitely intrigues me. 
Thank you
Have an upvote for honesty! (And it made me laugh too)
I'm not using any modules. I don't even know how the basics yet! But I do want to use a proper workspace as instructed. The slash comment isn't entirely true. For example: PS C:\&gt; ls C:/Go_Rust_Work/go/src/git/dev/hw/main.exe Directory: C:\Go_Rust_Work\go\src\git\dev\hw Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 2/10/2019 4:13 PM 1970176 main.exe PS C:\&gt; ls C:\Go_Rust_Work\go\src\git\dev\hw\main.exe Directory: C:\Go_Rust_Work\go\src\git\dev\hw Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 2/10/2019 4:13 PM 1970176 main.exe But never: C:/Go\_Rust\_Work/go\\src\\git\\dev\\hw\\main.exe &amp;#x200B; I guess I'll just have to type it. This is really stupid.
I was literally looking this up this morning, thanks! 
I guess I shouldn't have oversimplified my statement about path separators on Windows. Windows will accept `/` as well as `\`, though I guess not mixed. You can always tab-complete things from the command prompt, but I can't see a reason why you'd ever need to give a full path to anything. Change to the directory with your code and just run `go` from there; no need to give the entire path every time. `go run .`
I'm not sure why you're using tasks if you want to just start a project and start working. You could probably just use the launch file generated for you when you run with the debugger. No changes necessary unless you want to get more specific about where you have your program's entrypoint. Besides the program field, you probably won't modify anything else. While I haven't used a tasks file in my Go projects, but the following launch file gives me three different ways I can launch the debugger in my project: https://github.com/PaluMacil/dwn/blob/master/.vscode/launch.json I barely modified it from the original, but I had two commands with a different entrypoint than the main application. One has an argument passed in. If you do want to run install, I guess you could type that in, but it just compiles the binary like the build command and then copies it to the bin folder in your gopath. It might be useful if you're working on a CLI tool, but you aren't going to be doing that constantly. Since it's a personal project, I have some quickly assembled and half complete areas. But it works just fine. Most the UI is in a different (Angular) repo. Still, I can answer questions on it 
That is fair enough. The reason I had asked for clarification was that your original question showed obvious bias towards Google, and I was trying to understand what kind of associations you were making between Google and the Go project and what problems you initially anticipated. So that being said, I would recommend not making much of an association between the goals of Google and the goals of the Go project. The association is that the project started at Google, and some Googlers are maintainers, but its open source, can be forked, and community driven. I realize some people will have interpretations on how effectively community-driven it is. But it still covers the issue of a bias towards Google impacting the status of the Go project. 
I agree, I don't mind a good newsletter but the amount of spam from that one is just getting annoying 
You're right and I think that's what I'm struggling with. I understand I need to map my queries however the golang application logic has a certain object modelling as detailed in the question yet the query is returning multiple rows per object. In the example below there are two `Item` each with multiple `Tag` objects. Do I understand that you think it is best to create a `struct` object to represent the output of the *query*; or is it better to rewrite the query (into a view as recommended here and in S.O) to map to the application level objects? SELECT i.id item_id, t.name tag_name FROM item i JOIN tag t ON i.id = t.item_id; item_id | tag_name ---------+-------------------- 1 | foo 1 | secure 1 | tough 1 | scalable 2 | bar 2 | insecure 2 | Hard to Understand (7 rows) 
I like the idea of using a view to keep the database in charge of data retrieval and the business logic on the application side. In response to your question on two tables this is just for standard data normalisation (and we have a lot more than two tables for various queries/de-duplication). By putting all into a single structure this is more of a NoSQL approach and I'm afraid we aren't willing to go down this route yet. 
I will build a prototype of this today - I presume the `PostTag` would then have some helper function to output the strucuture used by the other areas of the application?
We are avoiding an ORM like Gorm and focusing on sqlx and database/sql. At the moment we are building the access patterns and keep coming across the issue of trying to map the output of these "JOIN" queries to our various application objects so we are looking for a generic solution with any recommended best practices. 
I need to improve my SQL-fu to see what this is supposed to be doing and get back to you as my initial experiments are showing no results... 
[removed]
Why can't I seem to play it in NZ?
Same in UK
Thanks for the share. I will try it soon. Honestly, I'm just glad I'm not the only one uncertain ... when it comes to the whole tasks.json thing. I haven't found any concrete solutions yet for VS Code.
All my previous projects just barebacked with the standard http library, it's crazy capable and fast as you could ever need. Recently started a project for a high volume API and didn't have the time to get it all neatened up so I rolled with gin. It's pretty nice!
the code you posted above is sound but it's more likely where you;re calling it that is the issue. Can you throw your code into a gist or a git repo so I can take a look?
That has nothing to do with golang. It's SQL and absolutely right. Look at sql aggregation functions like concat if you want to group the tag_names into one field. You can use SELECT DISTINCT if you only want to get eg one item_id, with the first tag_name found. But it is easy to group the result with golang, if you use map with item_id as key and a slice of tag_names as values.
Are you saying that someone could somehow violate the Go license by compiling and distributing their own code with Go? I don't see how that's possible so I'd be interested if you have a scenario. I know I could violate the license by doing something with the Go code itself, but I don't see how the Go license would ever apply to my code just because it is compiled with Go.
For many2many I'd allways use a third table, which is then the index for this relationship. Post { id title } Tag { id name } PostTag { post_id tag_id } To avoid making duplicates, create a unique index for both columns in the PostTag. The PostTag is easy to maintain, if you just create and drop rows within the methods the same methods for Post and Tag.
&gt; Are you saying that someone could somehow violate the Go license by compiling and distributing their own code with Go? I don't see how that's possible so I'd be interested if you have a scenario. Technically speaking, the runtime is licensed under the Go license - so *technically speaking* you may violate the license if you don't include the necessary copyright notice. That would only apply to distributed binaries (as they contain the compiled runtime, but your source doesn't contain the Go source). IANAL and have no idea if a) that is correct and b) any court would rule as such :) However, the question I tried to answer was how to prove if something is written in Go (or more general, prove that a binary contains copyrighted code). TBQH, I find copyright super annoying, especially as it applies to open source software. Wouldn't trust any judgements without a lawyer - at least if I was afraid of getting sued (i.e. developing commercial software).
That page has mixed content (https &amp; http), so css and fonts aren't shown and it looks like in the early 80's with a much to big headline :)
&gt; So that being said, I would recommend not making much of an association between the goals of Google and the goals of the Go project. One more thing to keep in mind is that historically, the Go project was not shy about making decisions that went against Google's best interest (e.g. the GOPATH layout).
&gt;You can run C directly on the CPU So confirmed, you need the runtime to work with the OS, these are two different actions. Code compiled in C, is converted to x86 assembly, therefore is running directly on the CPU, with calls to OS related functions (ie malloc) which in themselves are generally written in C and compiled into X86 assembly when you build the kernel. By the way, not disagreeing that a C runtime is required, but the runtime is technically an API to the Kernel, but the instructions compiled down are at some point executed directly on a CPU, when the kernel schedules for it to happen, and maps it into memory, and then sets the instruction pointer of your compiled program to start executing on a CPU.
not mine, just share interesting project 
In the US, the video just keeps loading and never actually plays. On mobile and wifi, but other videos are playing no issue
Very cool. As pointed out by another user, it looks like this is entirely based on \`chromedp\` . Got any good resources I could follow so I could send some PRs your way? I tried and failed to replicate our (my workplace) use of url2png in Python about a year and a half ago. Golang would be even better to prop up as a microservice like you have here. The 2 things I'd need from this before I could use it though would be: 1. Save the images as PNG 2. Choose size constraints. We use it mainly to create thumbnails of various sizes. The other issue I had was I wanted to skip S3 entirely and have the thumbnails generated on demand in real-time. Unfortunately the process was too slow when trying to do a small gallery page. I would consider this purely a bonus, as not paying for url2png would be pretty sweet on it's own.
If you want a full stack web framework, I would probably look at Beego or Buffalo and see what clicks for you. But IMO, if you are new to Go, it might get more constructive and helpful responses if you let people know what features of Django you used, and that you would like to know some good options in Go to use that covers your requirements. I say this because Django is big, and most people rarely use all features. Maybe in Go, there are better, simpler, more idiomatic ways to solve your requirements. So, just because a full stack framework was used in another language, maybe it's not the best option in Go. I actually did use Django for 5 years in addition to Flask for another 5 years. But, when I came to Go, I first spend time learning to create http projects only with the stdlib. Then once I felt comfortable, looked at stdlib+httprouter, stdlib+gorilla, and stdlib+chi. Only then did I look at Gin and Echo. Then finally Beego and Buffalo. For me, Echo hit the sweet spot and I have no regrets. I'm not saying don't use a full stack framework. What I'm trying to say is that in Go, blindly jumping into the full stack framework might be doing yourself a disservice. Go is not Python and you should come at your solution from a Go perspective. Many in the Go community would argue that using Echo (what I chose) is not in the spirit of Go. That's ok, I did my due diligence and it fit my requirements, stays out of my way while I code the business logic, and more importantly it fit my brain. Good luck!
You know what hasn't come a long way? That sites mobile view. 
Exactly my use case. I'm stuck in passing the channel, somehow it doesn't close and which hangs the program. 
I started learning Golang because of a project that required concurrency and using asyncio await with Python was mildly infuriating to say the least. After porting my Python code to Go for that project, the bulk of that time being learning to build out structs for my JSON vs classes, the whole thing just fell together beautifully. Save for a couple little quirks I really like it. So I'm working on a couple projects, one of which was a web app I was trying to implement using Wagtail and the database model wasn't working out the way I wanted. I decided to look into Graph databases for it because of a ridiculous recursive structure that would be unpleasant to do in SQL, at best. Wagtail just wasn't a good fit. I'm sure Django could have worked but I'd probably feel like I'm throwing away 70% of the functionality of Django so at that point, why use it? So as my next learning project with Go I decided to try building out this web app using Go and a graph database. Everyone seems to suggest just using stdlib for Golang web apps, but I still want to explore the other options out there. The problem is Golang web frameworks, whether they're as pointless as some people claim or not, exist in a horribly bad signal to noise ratio environment right now. With Python you've got two major options with a few smaller edge case outliers to look into. 90% of Python web app cases fit into either Flask or Django. It's a super mature language with mature frameworks. But if you poke around looking for Golang web app frameworks you get dozens of smaller projects. Who knows if "the one" Golang web framework has even been made yet or if all these will just fade into obscurity. In the end I'm confident in my ability to get some web pages served with Golang easy enough with what tutorials are out there. Probably the only thing I'd be concerned about is auth, but that's not an immediate need for me. Right now I just need ridiculous recursive database query performance which I think I'm making progress on.
The first selects all the tags (you get the items (ids), too), the second the rest (items without tags). This way you get everything with only two queries. Of course if performance is not needed or you have to get only a few items, then a select by item id for the tags is ok. 
What's your question?
&gt;You are traveling via rail route SomPointA to Destination. You have to buy all the different types of food available across the stations. &gt; &gt;All the food items may / may not be available on each station. Given JSON data, &gt; &gt;find the optimal way where you will be able to get all the food items at the minimum price. You can buy different items from different stations. &gt; &gt;In case two stations offer the same food at equal prices, you need to buy it from the first station. i have mentioned it above , with the sample input and output :) 
Video never plays
Yeah, there are the API docs on README, but I can come up with a better example. E.g.: Creating an Account, then a Category and a Transaction. &amp;#x200B; Thanks!
Awesome project, will definitely check it out! Thanks for all the tips! &amp;#x200B; 1. Yeah, I've seen that, but opted not to for now. But if things get more complex, I'll revise it. 2. \_Don't know that is is. Searching\_. 3. That's better, but there's more complexity as well. Maybe in the future :) 4. I'm using just two decimals to deal with precision.
Hey man, that's awesome! If you wanna chat about integration, just send me a message! You can find me @jonatasbaldin on Telegram :)
Homework?
This is one of those cases that you abuse the shit out of zero values. Couple loops will do it. Create a destination to store the result. map[string]struct{price int, station string} Parse to a map[string]map[string]int. Loop through the destinations: for stationName, station := range ... Then loop through each product for productName, price := range station .. If dest[product].price == 0 || dest[product].price &gt; price Then set the product dest[product].price = price dest[product].station = stationName Should do it. Throw it on playground. I’m on mobile so I can’t type well. 
[removed]
thanks will try it !! 
https://play.golang.org/p/2HBBdFzagzZ This was way harder than it should be on mobile...
not exactly , trying to build something , where the input will be like this . so yeah stuck on this part. new to GOlang
While we are at "best": What is the best dish and what the best holiday? There are just so many dishes and holiday options... If new to Go: Keep away from a framework.
This doesn't play, uploading again or uploading a copy to another streaming site would help
Hey Folks - there seems to have been an issue with a higher resolution version of this video, I've reuploaded a 4k version and reposted - new link is here: [https://www.reddit.com/r/golang/comments/apecm7/go\_simple\_http\_file\_upload\_tutorial\_fixed\_video/](https://www.reddit.com/r/golang/comments/apecm7/go_simple_http_file_upload_tutorial_fixed_video/)
No one is going to do your homework for you - you're asking for someone to write the solution to the entire problem.
*Woah!* It's your **4th Cakeday** Bake_Jailey! ^(hug)
I mean... that's a perfectly fine thing to do if you want to add an option to your application to skip verification for dev purposes. It shouldn't be default though.
Hi, I rewrote the app. Here it is [https://github.com/mseshachalam/x](https://github.com/mseshachalam/x) any feedback is much appreciated. 
&gt; e.g. the conflict between type params () and normal params () ? In D there's never any conflict between type (compile-time) params and normal (runtime) params. At the declaration, CT params appear first: ``` void templateFun(Type0, Type1)(Type0 foo, Type1 bar). ``` At usage, there's an exclamation mark to distinguish: ``` auto funPtr = &amp;templateFun!(int, double); ```
I've been following the `generics` discussion on'n'off... at slide 126, you write: ``` contract comparable(v T) { var b bool = v &lt; v } ``` implementation is still a long way from now but wouldn't this be problematic if we reuse parts of the current compiler (SSA) logic that could optimize that code out ?
`s/comparable/ordered/`
The specification doesn't say anything about implementation, so ... who knows? 😅
Websocket is just a transport, there's no way to answer your question without more information/code.
One thing I feel is always missing from these kinds of articles are that tight coupling isn't always a bad thing and over abstraction is as bad if not worse than not having any at all, at least it remains readable.
With this case in mind: contract comparable(v T) { var b bool = v &lt; v } How do I implement a type where I am not a prisoner of existing semantics of Go's operators? If I want to avoid the default behavior provided by operators like `&lt;` or `==`, I define a method like `compare` or `equals`, and that's fine, but if I want to use a data structure which doesn't support my contract, or use types where I can't implement these methods, I am out of luck. 
Are you aware of ledger-likes and r/plaintextaccounting / [https://plaintextaccounting.org](plaintextaccounting.org)? I totally get rolling your own, just wanted to point out, there's already a big corpus of work.
Are you asking this because `v &lt; v` is always false? If that's the case then, no, it is not a problem. The body of a contract is not a function (although it looks like one): the idea is that it gets typechecked, not fully compiled. And typechecking happens long before optimization decisions are made (in the current compiler the code isn't even in SSA form at that point). So that's not a problem, but the fact that contracts introduce things look like function bodies but aren't and produces weird looking expression, such as the above, is a weakness of the current proposal, IMHO.
This looks great! Definitely, I'm going to try it, one side question, how did you decide to go with full commands? instead of the ”aliased” version. Nothing against, just wondering because when a cli app becomes part of my workflow I always try to optimize my time to type those commands with aliases. I have an idea but interested to read the maker pov. 
This brings back a horrible memories. I've worked with clients who insisted on having https on every endpoint on their internal network. Cool. Except they weren't going to use a publicly recognizable domain name that they could get real CA signed certificates for. And they weren't going to run an internal CA so we could add their CA to a certs file. No, they were just going to self-sign every cert on the box that needed it, and tell everybody to click through the certificate warnings. This meant that we had to build into the software we were selling them the ability to ignore certificate errors. We made it configurable, rather than turning it off for all our clients, but I was annoyed we had to do it at all. 
Your post lacks some context. So next time better take this image along your headline. It's more generic you know...\*rolling eyes\* [https://i.kinja-img.com/gawker-media/image/upload/s--lAuMncOC--/c\_scale,f\_auto,fl\_progressive,q\_80,w\_800/rjm0jauliuomkdnzwvff.jpg](https://i.kinja-img.com/gawker-media/image/upload/s--lAuMncOC--/c_scale,f_auto,fl_progressive,q_80,w_800/rjm0jauliuomkdnzwvff.jpg)
I'd like to volunteer the fact that stack traces have as much place in Go error handling as basketballs have at a football match. With properly written error handling, potentially with nested errors, you don't really need stack traces. It does seem useful for debugging, but you do have stack traces in the debugger, so no need to add code to actually include this in your application domain. Also, it gives you a bad solution to an apparent problem (ie. not quite getting how good error handling should go in Go). Now of course this is not entirely your fault, as the standard library and official materials provide really scant information or examples for this, but there exist some really nice blogposts on the subject.
The point is that creating an internal CA is so easy, it shouldn't even be needed for dev purposes. 
Thanks, very helpful!
```go var Canceled, DeadlineExceeded error ``` should be ```go var ErrCanceled, ErrDeadlineExceeded error ```
nope &amp;#x200B; [https://golang.org/pkg/context/#pkg-variables](https://golang.org/pkg/context/#pkg-variables)
Hey, I had to profile go for the first time recently and this: https://flaviocopes.com/golang-profiling/ helped me a lot.
To be fair, ErrFoo is a pretty common pattern. Seeing those errors not in that pattern looks odd now.
I didn't write the package, but if he's wrong he's wrong 🤷‍♂️
As far as I know, the Contract Draft does not intend to solve this problem.
The problem with bundling the binaries is that you need every dependency those binaries have, including whatever dependencies they may have on system setup. Basically, set up two identical blank machines or VMs. Install the binaries in the usual way on one of the machines. Now, without involving your Go code at all, simply copy the relevant binary files over to the blank machine - i.e., start with the ADB binary - and attempt to run. If it fails, you have to debug, and work out what unfulfilled dependency there is, then copy that over (and add it to your list of what needs to be in place). Comparing the two machines (which should have started identically) should at least let you see what got added. For EACH such file, you also need to look into the license for that dependency, and see if you are allowed to manually carry it - frequently, you are not, and will be opening yourself, your company, and your clients up to copyright infringement claims. Assuming you run into no copyright issues, then you basically need to take that list of files (and possibly configuration steps) and turn it into steps your Go code can run. There are a variety of tools for packaging binary files into Go executables, and how you do this will depend on which you choose. Major issues you may run into: License/Copyright violations; or License compliance issues (i.e. if Apache licensed, you may also need to include and reproduce the NOTICE file, if GPL, you may need to reproduce a LICENSE file, etc.) Some binaries may need superuser permissions to be installed in their usual places, so you then have to find out if it is even possible to install per-user and how to do that. Massive file bloat - what was a nice small Go utility may balloon substantially as you load it full of binaries it has to put in place. Failure due to install variance - what gets installed on your test machines may not be the same as what would be installed on a given customer's machine, so what your Go program adds may not be sufficient in some cases, and you'll only discover that when it fails.
Not sure what you really want but if you want to initiate a download in a browser, it is maybe better to send a download msg with a URL. You then set the browsers location into a hidden iframe with JavaScript. The server of the url needs to send the Content-Disposition: attachment header to trigger the file download dialog.
Convincing people that SQL isn't the be-all, end-all of query languages is even now still pretty challenging, even after the NoSQL revolution. But I consider this to be a major weakness of SQL, because AFAIK most servers actually send back all row data exactly as seen, and I often run queries that can have noticeable redundancies in the returned data like this. Generally, I would define a struct to accept the incoming data, and then in the query loop, convert it into the "real" objects I want. ORMs try to make that step more slick, but to be honest, over the years I've come around to the not-entirely-unpopular opinion they aren't as helpful as they look, and IMHO this is one of the reasons why. Almost all ORMs are table-based, rather than query-based, and so you get mismatches like this. The easiest thing to do in Go is just to accept the incoming query and populate the desired objects.
Thanks for the feedback! I believe it could be useful not only for debugging but for production as well. For instance, there is Elastic APM (and Sentry), where you can send production errors and monitor it. It also displays stack trace of error and makes easier to figure out what is actually happened. However, APM does not show any source fragments for Go, despite it shows sources for other languages, e.g. js.
[removed]
Does that memory profiling show you the data of the objects from one function to another?
Do you mean you have it functioning fine on the same host already? If so, check your firewall to see that your ports are open. Otherwise, if you're looking to send a file, then you might fine a websocket a touch awkward for this purpose, but if you for some reason will have the simplest result by doing this, then I suppose you could try base64 encoding it and then including it in a message. Dealing with small images in that way isn't too uncomfortable. The biggest downside is that you won't have the caching you'd have from serving these images a more traditional way, but that might not apply to how you're consuming them as you technically haven't even mentioned if you're using a web browser. If you aren't using a browser, consider using a plain old TCP socket, a multipart form request, or perhaps ftp. Any of those should work out pretty well for you. Otherwise, look at jtorvald's response.
Have you tried just giving it the IP/port of one of the slaves instead of the master? If I remember right, Postgres slaves are read-only... but I don't remember if they allow connections or not though. 
tbh, I don't know but I don't think so.
You create a write client and a pool of read clients. Then you use your write client for insert, update and deletes and the read clients for your selects. Not sure if there are Postgres client libraries that support this out of the box. 
I was thinking, couldn't you make something that would like context but you can set which object and functions
So, on mobile so I can’t give a lot of feedback. But I created this demonstration of how I would do it: https://goplay.space/#MRkoiK0gdGO Essentially the main highlights I see are: - you are relying on libraries to do what the standard library can easily do. That’s not recommended. - you are over complicating your code. - you are using a “util” package, which is not recommended. If you feel you need to extract functionality into a package, make it a tightly focused and appropriately named package. - your comments are not very helpful: documenting a structure as “this is an X structure” adds absolutely nothing to the conversation.
Thank you! And this is a great question. I didn’t go with default aliases because I didn’t want to force my default aliases and want to give opportunity to explore commands. You can create your own aliases, which will be perfect suit for you.
Isn't this the case with pretty much all generic code? You can't use a type which is not compatible. That's the whole point of contract, to put constraints on a kind of types you're allowed to use as type arguments.
I'm sorry but I have a hard time understanding you (maybe cause my english is not the best). Maybe the links at the end of the article could help.
&gt; A better way to have asked the question maybe would be: is the websocket built on top of http.Request somehow? That I can answer: Yes. Websockets are, at the network protocol level, an HTTP request that gets "upgraded" into a websocket via a certain protocol. The gorilla implementation maps fairly directly to this. It sounds like the golang one may be trying to add a bit more functionality and indirection to the process, which is also obscuring this fact.
Yep. https://github.com/golang/go/wiki/Errors#naming
This is question to authors of the context package, why they are dismiss the naming convention Go community should follow.
Because this package might predate the convention. But if you wanna ask the authors, golang-nuts is probably a better way
I know this very well but, and let me tell you this again, the slides are correct and therefore your comment above was wrong.
&gt; Because this package might predate the convention. No, It might not. The context package is a very young. 
The slides are not correct, since you tried to outline somehitng you don't know how to use. And you are trying to call it simple (checkout first comment). And of all possible examples (the Canceled and the DeadlineEceeded) you chosen the ugliest one. You may keep talking the slides are correct, but they aren't. What is the final words? &gt; I'd argue contracts are not. Lol. --- So, the example the ugliest? The ugliest. Why can not I comment about it? I can. And I do.
Dude, I'm out
Creating an internal CA is easy, properly managing it is hard.
ELI5 ? :)
The context package is actually quite old, it was created internally at Google way before it was open sourced as part of the x/net and then added to the standard library.a You might want to watch a talk on the topic. I gave a pretty good one some years ago.
Honestly, I would try this, but typing has been harder since my accident building my own table saw this past weekend.
I recorded this video a while ago, but it's still pretty up to date. If you look in the description section it has a code/link to get the course materials for free as well. Testing and Benchmarking in Go Workshop -&gt; https://www.youtube.com/watch?v=ZeAkcs5g41k&amp;t=192s
Google's leadership (and large finical contributions) has served Go well so far. I have no issues with Google "owning" the development since they are not a gatekeeper on the usage, only on the Open Source codebase. Now if Google takes Go closed-source for a "pro" version, requires built-in analytics, or anything that makes them a "usage" gatekeeper - their would be good reason to object.
Thanks a lot. Those are some great suggestions, specially the **profiling** part, I had been struggling to debug **goroutines**, then I found that if it's stuck you could send a **SIGQUIT** signal to get kinda the traceback, it also did help me some. What **libraries** are you talking specifically ( is it the `github.com/remeh/sizedwaitgroup` ) ? Well, I used that to limit the no of goroutines, cause I would be running it from a digital ocean server $5 droplet, which **doesn't have much RAM**, so I thought it would be best to limit that. However, it would be great to hear your thoughts on it and alternate options for the same. **Util** package is just my habit of organizing my code, it keeps it clean. **Overcomplicating** ( I do feel, it maybe simplified and hence this post ) this if you could elaborate that would be awesome. **Comments** : Ya I know, it's silly, I haven't yet thought of pushing it to a repo, hence it is as it is ( moreover it's just the first iteration, so you could expect progress there too :) ) 
Yeah, you're right. I implemented my own map because I needed to use a different kind of equality on a type than was originally intended. My implementation was good enough and has a nice property that keys stay in order they were added. Then I decided to use the same code for a different project, but now with `int`s as keys, and while it was an easy fix to replace all calls to `compare` with `==` it's not always productive to copy code around just to swap a couple of characters. What I am really hoping for, I guess, is some form of operator overloading, like in Python with underscore methods or some mechanism like type classes in Haskell.
Operator overloading has by far the lowest value-to-complication ratio of any language feature I've come across. Languages that encourage it (offhand, Scala and Haskell) are obviously worse off for it.
Nice slides, but for a talk titled "Will contracts replace interfaces?", it's a bit funny that the first mention of contracts happens all the way on slide 117/140 :)
The point is interfaces bring a lot of stuff contracts will not be able to replace But yeah, might consider switching the flow around to start with contracts and then show things they can't do 🤔
Also I had one hour to discuss the issue, and to be honest there's not that much to say that is interesting about contracts for now 😅
I agree with all that, my comment was very much tongue in cheek :)
I'd suggest checking out https://github.com/pkg/errors and the [accompanying blog post](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully)
pkg/errors is great, but it does not show sources, as far as I remember.
You were right! It was permission issue, thanks!
OP Where the video will be available? 
Not sure, but I'll share it eventually It was gophercon Israel so probably Twitter.com/gopherconil or myself Twitter.com/francesc
In, Go, errors are _not_ exceptions. They are values which have to be dealt with just like any non-error value. If you find yourself in need to have a stack trace attached to an error _returned_ from some piece of code, turn that error into a call to `panic`. Let me reiterate: in Go, errors are "normal", not exceptional. It helps to think of errors in Go in terms of robust long-running pieces of infrastructure software. Consider what should happen in a mail server is trying to process an incoming mail message and discovers an attempt to save it to a file on a filesystem fails with "no free space available". Should the server crash with a stack trace and crap your message around? I'd bet you'd prefer it to just _freaking *handle*_ that error and tell the sending program to keep the message agound and try again a bit later, and then try to communicate the problem via a log message etc. That's basically what errors in Go are about. Please read [this](http://250bpm.com/blog:4) for a good intro.
&gt; Now if Google takes Go closed-source for a "pro" version, requires built-in analytics, or anything that makes them a "usage" gatekeeper - their would be good reason to object. Well that's kind of where I was going with this question. Seems like something they would potentially implement in the future. Is there any way that any of the Golang packages/imports can "phone home"?
I wonder what the full thought process behind that was. 
I really doubt Go will adopt any kind of operator overloading, IMO Go is better off without it. In case of generic code we just have to replace all operators with generic interfaces. Go could even go as far as to reimplement all operators through them. Even if not, you can alias bulletin type and provide your own implementation.
Yeah, that's absolutely true, it's got a fairly [simple formatter for stack traces](https://github.com/pkg/errors/blob/ffb6e22f01932bf7ac35e0bad9be11f01d1c8685/stack.go#L89)
Fantastic slides. Having heard Francesc's voice many times in other talks, I almost heard the whole talk just by reading slides. :) Venn-visualization of interfaces and contracts is really, really nice! Can't wait to watch the video of this talk.
Thanks for your opinion! I basically agree with it, and I do not encourage or discourage exception-like errors handling in Go. But I still believe that many people sometimes find themselves in a situation like "if err != nil { return err }" and are not aware of from where this error actually came. Also, I would like to make an accent that the main purpose of this lib is not a stack trace itself (it's already implemented many times before), but displaying sources or exporting sources to logs, which help to figure out initial reasons faster.
I got it to work. I would edit it into the op but I pruned the post :D It was very simple after reading the code. websocket.Handler is just a simple interface for any function that accepts a websocket.Conn. And a receiver function is defined in that package that can serve a websocket when given a response writer and request - which is what I needed. So basically I just needed to take my existing websocket function, ensure that the type is set to websocket.Handler, and call ServeHTTP on it :) So thanks to everyone that tried to help, especially the 2 or 3 people that suggested reading what the socket packages do. 
To those in this thread with the typical Go Stockholm syndrome of "Go doesn't need [any feature it doesn't currently have]", y'all realize they're planning to add stack traces to standard exceptions in "Go 2", right? https://www.reddit.com/r/golang/comments/ajmh27/proposal_go_2_error_inspection/
I believe this is an active enough part of current efforts that besides it needing to be answered from people who work on compiler internals, the answer might not be the same in 1.13 this summer. I don't think any of what you listed is considered, especially line size, but I'm less certain whether they might have a cutoff after a certain instruction count. In general, the intent I've seen communicated has been to inline code that won't have an affect on the meaning of the code but will reduce jumps. For instance, if you call a simple format function and it's a pure function with a deterministic output, there is probably some criteria that could inline that now or eventually into each place it is called. The exact criteria will probably change as core developers fine-tune for performance and avoid affecting accuracy. You probably don't need to care either. It's like eliminating no-op code or like unrolling a loop in that the debugger should still be able to communicate things like line numbers as if the compiler had not changed the exact flow of the code. If there is something with a very small benefit and it will affect something that the core developers don't think they want to take on in terms of code complexity, they might skip it because they have a lot of experience with this sort of thing. Someone else might be able to give a more educated answer, but this is my answer for why I don't care. You might just want to know (which would be a nice read for me too) or have a reason you want to know, but hopefully this is a start.
The context package was added to Go standard library with Go1.7. Who cares where it was before?
Nice snippet thanks. Quick improvement: you could generate the sha256 on the fly by using a io.multiwriter
Hmmmm ... Google
I'm living this exact same horror every day. Trying to change it from the inside for the better. It's... difficult. 
https://github.com/golang/go/wiki/CompilerOptimizations#function-inlining
It was an awesome talk, thank you! It's too bad you didn't have enough time to go over error handling slides, but that's nice you published them so quickly.
True! For efficiency you don't actually have to bother saving the file to begin with in this case. The doSomethingWithFile function was more of an example than anything else. I'll definitely keep this in mind for future reference though. I had actually been thinking about seeing if I could get away with throwing the file-reading bits in a separate go routines, possibly syncing them with channels to report errors etc. etc. But I figured that wouldn't help to get the basic idea across here.
Interesting commentary on HN regarding Go and this topic: [https://news.ycombinator.com/item?id=19135965](https://news.ycombinator.com/item?id=19135965)
&gt;I can't really imagine a reason why anyone would violate the Go license, is super permissive. It basically only requires you to state that you're using it (by including the copyright disclaimer), which companies don't lose anything from Indeed, i've used Go since it's a Go subreddit, but mine was a more generic question after the (different) scenario that comes to my mind, of paid apps that are just a rebranded Blender ([link](https://www.geek.com/news/scam-rebranded-blender-3d-modeling-app-being-sold-for-77-1310615/)). Somehow i've landed into thinking about me, dealing with someone that shipped binaries of my open source code. &amp;#x200B;
(Again on mobile) Libraries: neither of the ones you import are needed. - `sizedwaitgroup`: See my example for how to do parallel requests with a limited pool of gorountines. - `gorequest`: For requests, you just create the request and add headers to the request struct prior to actually executing the request, no libraries needed. Same with proxies. Util package: did you read the blog post I linked? They are generally the opposite of “keeping the code clean”. Over complicating: I’m mostly referring to a much larger set of abstractions and conversions than you need to use. 
Your gonna be disappointed then, because Go core team is moving forward with attaching stack traces to errors in new versions of go along with other error handling changes. 
&gt; obviously worse off for it Can you give some examples? It's not obvious to me.
Sure, it's a real programming language after all. Go libraries can "phone home" just as easy as NPM packages (see `init()`). I don't think there are any indications this is a real threat though.
&gt; Do I do something wrong? Yes, you're not sharing any of your methodology. You're not going to get any answers unless you show us all your cards. See also: http://www.catb.org/esr/faqs/smart-questions.html
If you're interested in more optimization resources, try [https://github.com/dgryski/go-perfbook/](https://github.com/dgryski/go-perfbook/)
I though I wrote enough for experienced people. If you wonna exact code I've run, here it is: https://gist.github.com/funny-falcon/f69ee71c55bbf12340e2c1dbad55e3d1 I ran `greeter_server` in one terminal, and `greeter_client -g 90` at other.
It's exactly the "experienced people" that want to know everything about your methodology. Performance measurement exercises everything from your software to your OS to your machine's CPU and memory... all of those details will have an effect on your results, yet you're sharing none of them.
What annoys me about "SemVer" is that this concept dates back to at least the 80s (and has been taught to me like this), yet the authors of the spec pretend it's a new thing they invented.
At that point, don't interfaces basically do what contracts do
I've shared at least CPU, looks like you've missed it. OS is Ubuntu. Memory doesn't really matters because working set is smaller than L2 cache. Man I don't want to make a blame war here. Do you have an experience with GRPC in Go? Then just tell me: "I'm tuning GRPC this way, and it is faster than light." Or "yes, guy, it is slow as a snail, and you cann't get any faster than default settings". That is all I want to here from a man who have experience with GRPC in Go.
I know that on the same server Redis and Tarantool could serve couple of millions of "Hello World" requests using just one CPU core. I know that simple binary rpc protocol could serve million rps with client and server both written in Go on less capable CPU. 90krps Hello World requests looks like a turtle for me.
Wait a second. Is this the same Frances Campoy from “justforfunc”? Stumbled upon your YouTube channel a couple weeks ago and just love the videos! 
Consider a set of microservices all 100% internally facing, deployed inside a VPC with appropriately set security groups. Of course, those wont show up on global github search as they would be inside private org repos.
I'm not talking about that.
My two favorites are https://github.com/gin-gonic/gin and https://github.com/go-chi/chi Choice depends on size of project. I think gin is very well done and tested in prod, and chi is rather small and simple.
Isn't that very common thing they do in silicon valley? I mean taking some old stuff and presenting like it is some new thing.
Francesc, but yeah that's me! 😅
That's not creepy at all 🤣
There is a great [Go Tooling in Action](https://github.com/campoy/go-tooling-workshop) workshop from Francesc Campoy that covers the go toolbox including profiling tools like pprof.
What was it called before?
Thanks for the great summary! I find myself agreeing with your conclusions. Go has this understandability about it, and contracts are fairly confusing in their mechanics. The generics / types thing seems decent though a little ... too Java-y? I guess I wish for a more elegant solution, but maybe it doesn't exist
Do it if it makes sense and you understand why you're doing it. Don't listen to people who make blanket pronouncements about what features you should and shouldn't use; they're usually inexperienced. It's there because *someone* has a valid need and a good reason to use it.
[removed]
Not sure if it is your problem, but instead of using atomic, try using local counters and sum them afterwards. 
Ah, so you’re the one responsible for me ripping out all my REST calls and replacing them with gRPC. ;) I have a special fondness for your videos as you spend less time academically chatting about things, and just get down and code them, explaining it clearly why you’re doing it. Take an empty project and just go for it. The code reviews were great as it really makes “idiomatic go” into a concrete concept. I started using interfaces everywhere after I saw the IRC client video where you abstracted virtually everything out into interfaces so that the client never depends on concrete types. I realized how easy it would be to bolt on TLS and/or compression without changing a single line of the library. In short, you make me a better programmer. Thank you. 
&gt; I don't want to make a blame war here. If you don't help us, we can't help you. That's what you should take away from the link I shared with you. I help build and test systems that run billions of gRPC calls a day across dozens of golang-based services. We don't "tune" our services, in that the majority of our services run on Ubuntu without any kernel tweaks whatsoever. I will say that our services often run with thousands of goroutines, so by limiting yourself to &lt;100, you may not be unlocking the full potential of your architecture... I can't say without knowing more. Benchmarking requires making many runs while tweaking single parameters through a broad range of values. You have a lot more work to do before you can make any conclusion. Please read the link I shared if you haven't already.
&gt; Don't do this... Make a post with a clickbait title?
It’s so easy to run a CA and deploy the root with GPO or Device manager. It hurts so much when companies do these things. 
I've had to interface with IOT devices that used self signed certs. This was the only option :/ 
I do not recall a name, just the distinction between major release, minor release, and patch level with the appropriate semantics.
I’m battling TLS right now. I saw the InsecureSkipVerify flag, and even in development, I said “no, I’m going to do this right from the start”. Set up a dev CA; root with 2 leaves for client and for server certs. Rolling OCSP, when I find out how poorly OCSP is implemented. There’s a staple value, but good luck getting it from a connection in time to drop the connection if it can’t verify it. And as far as I can tell, none of the base code even validated the OCSP response. To top that off, you need to roll your own OCSP requester because the standard library doesn’t include that; fortunately it has an OCSP parser. But that was a dead end. So I started rolling with CRLs. Except, again, the standard library has no CRL checks at all. You’ve gotta grab them yourself with your own requestor. I get it, it slows things down and “nobody else does it so why should we, hur dur”. But give me an option to just turn it on for god sakes. Instead, because it’s an internal CA, I can define where my CRLs are located and have the server/clients pre-fetch the CRL, and check on connections (VerifyPeerCertificate) against the list (which, again, you’ve gotta implement yourself). Then I routinely update the CRL throughout the day to check for updates. Works pretty well but is hardly a task for the newbie. It’s no wonder people just say fuckit and disable verification checks. If you don’t understand TLS, all of this stuff would fly way over your head, and you would make seriously bad decisions just to make it work. Self signed certs still give you encryption, so to the average manager or network ops guy, it looks the same as a proper TLS connection. But half the purpose of TLS is -authentication-, which is why this flag shouldn’t exist. The TLS library needs a bit of an overhaul, or at least some level of enhancement. I would suggest some better hooks for the OCSP Staple for one. First class support for CRL caching/storage is another. I would also suggest a stderr debug message, warning of the InsecureSkipVerify flag. It would annoy the average developer enough for them to take action to suppress it by fixing it properly, and would be more likely caught in a review or by dev ops guys who may not be reading the code fully. 
Alternatively you can put [pgBouncer](https://pgbouncer.github.io/) in front of your database - you can configure it in a similar way to u/jtorvald's suggestion with read-only and read-write backends. This will work if you'll have several systems talking to your Postgres cluster.
I wanted streaming encryption for large files and network streams so I wrote a simple wrapper around AES-CTR + hmac on io.Writer and io.Reader streams: https://github.com/Xeoncross/go-aesctr-with-hmac I'm having trouble seeing how Adiantum handles actual streaming of data, it looks like it requires the entire `[]byte` slice to be loaded to calculate the signature, though I could be reading that wrong which would allow for wrapping the encoding/decoding in a `.Read()`/`.Write()` loop.
This actually came up yesterday so this is fresh in my mind. During the compile phase, function calls are given a "complexity weight" depending on a number of factors (/u/tserkovich 's link has a good summary). If that weight is below a certain value (80), the function can be inlined. Here is another link for reference: https://about.sourcegraph.com/go/gophercon-2018-micro-optimizing-go-code#the-inliner
The atomic inc will kill performance. Have a local goroutine count and sum it up at the end. 
Nope. Atomic could increment to many millions on one-cpu-slot system.
So what you’re saying is it makes sense to pick tech that’s cheaper to build, albeit worse. 
From multiformats.io: “Multihash is a protocol for differentiating outputs from various well-established hash functions, addressing size + encoding considerations. It is useful to write applications that future-proof their use of hashes, and allow multiple hash functions to coexist.” In short: it stores the hash function in the hash to be able to use multiple hash functions and or be able to upgrade in the future. For people like me that never heard of this term and after clicking this post and clicking to the repo still wonders what this is about ;-) Personally I wish reddit posts and git repos are a bit more descriptive about what it is and what it solves.
`s/exceptions/errors/g`
Here updated code: [https://play.golang.org/p/5hKv0ybc4CL](https://play.golang.org/p/5hKv0ybc4CL) 1. No reason to do this. 2. Moved back \`func2\` to loop. 3. You need to use WaitGroups if you have several readers and want to avoid data loss.
Very nice, but shouldn't the resulting block hash always begin with given amount of zeros in order to be valid? 
This is very apropos. I was about to implement similar in the next few days as I had just finished our filestore in Cassandra. It probably makes sense to write to tmp on disk instead of leaving the file in memory, then streaming it off to the database after safety checks. 
&gt; I will say that our services often run with thousands of goroutines, so by limiting yourself to &lt;100, you may not be unlocking the full potential of your architecture... I can't say without knowing more. And it again shows that you didn't read question carefully before blaming me. I clearly said that 90 goroutines we the best option, and either increasing number of goroutines or decreasing it produces worse results. Billion of requests per day is just 10krps. Given you mentioned dozens of services, looks like it is less than 500rps per service, therefore less than 100rps per core. Yes, GRPC will be sufficient for your setup. As well as plain HTTP + XML.
Not sure why people are downvoting this perfectly legitimate question. Must be Google staff.
Fair enough :)
I think it was mostly just that they standardized it, which, in turn, means that standard parsers for it can be created. In particular, they standardized the way that pre-releases with extra text after the version number itself, such as `1.0.0-beta`, work. That being said, it can be a bit awkward the way it gets talked about sometimes because it does definitely sound, at least some of the time, like people are saying that they came up with the whole thing from scratch, which is very, very false.
One important thing to consider, as is mentioned elsewhere in this thread, is that errors in Go are not exceptional. They are part of your normal control flow, and are values to be handled. This is important because in languages that *do* have standard, throwable exceptions, it's a major anti-pattern to use them for control flow. Why is that? Partly because exceptions expend time generating stack traces, etc. It's a performance hit, especially if the failure case is frequent. I'd be careful with the performance overhead of this code on errors that aren't all that exceptional, ie: json decoding from input sources such as http requests.
Thanks, ya I wrote that reply even before I started reading the blogpost now that I have read it I understand it's unnecessary. Anyway I also refactored `main.go` : ``` func main() { db, err := utils.InitDB() if err != nil { panic(err) } start := time.Now() output := utils.ReadFile(os.Args[1]) errorWeb, counter := 0, 0 out, errCh := make(chan utils.SendNotif, 10), make(chan error, 10) for _, url := range output { go utils.MakeRequest(url, out, errCh, start, db) } for i := 0; i &lt; len(output); i++ { select { case res := &lt;-out: counter++ fmt.Printf("%s Done %s : %d\n", Green("✔"), Green(res.Url), counter) case err := &lt;-errCh: errorWeb++ fmt.Println(Sprintf(Red("✘ Websites errored : %d : %s\n"), Green(errorWeb), Red(err))) } } close(out) close(errCh) defer db.Close() fmt.Printf(Sprintf(Bold("Total time taken %.2fs elapsed\nTotal : %d\tWebsites Done : %d\tErrored : %d\n"), Green(time.Since(start).Seconds()), Green(errorWeb+counter), Green(counter), Red(errorWeb))) } func checkError(err error) { fmt.Println(err) } ``` But for some reason it gives error as ``` panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x4c965a] goroutine 581 [running]: database/sql.(*Stmt).ExecContext(0x0, 0x792d40, 0xc000012108, 0xc000f5da20, 0x9, 0x9, 0x0, 0x0, 0x0, 0x0) /usr/local/go/src/database/sql/sql.go:2301 +0x4a database/sql.(*Stmt).Exec(0x0, 0xc000f5da20, 0x9, 0x9, 0x78ff60, 0xc002c7ca20, 0xc002da8ab0, 0xc000f5daa0) /usr/local/go/src/database/sql/sql.go:2330 +0x65 ``` Now, I am getting a hard time debugging this, so I'm reading [debugging-go-code-with-visual-studio-code](https://scotch.io/tutorials/debugging-go-code-with-visual-studio-code). I know that it's **panicking** in inserting to database but I'm not sure which is the null reference here, the `db` variable or the `Domain struct`. Also, I don't know why it's happening, I mean it shouldn't happen. Do you know any better ways to debug these kinds of error ? Thanks.
Probably depends on how big your data is and if/how much concurrent access there is (you will need locking?). Want to use https://golang.org/pkg/sort/ to make binary searches faster? Want to use a bloomfilter? HyperLogLog? Will you need to shard the maps? Wrap these in a benchmark and add *your data* + *your usage example*.
When I am trying to find errors like that, I look at the first place in the error trace that is my code (as opposed to core or library code) and try to work out from there what the issue is. I can’t see the entire trace or the entire program so I can’t give more detail than that :) 
When I am trying to find errors like that, I look at the first place in the error trace that is my code (as opposed to core or library code) and try to work out from there what the issue is. I can’t see the entire trace or the entire program so I can’t give more detail than that :) 
I do not actually need anything that sophisticated, I'm just curious about which method performs better.
Thanks! That's true, for any place where error generation is frequent, there can be a performance overhead.
Try out the testing package. It has some fantastic benchmarking operations. Build a test for each, and feed them each the same data, and it will be the right answer. I would be interested to see the results as well. 
As a general rule, for actual projects like this I would recommend separating your implementation - from you domain/design. I would also recommend looking at embedded databases for Go to save having to run MySQL for such a simple project. 
Looks like they’re still calling for submissions until March. Keep an eye on it; it may be worthwhile but you won’t know until they announce speakers. If you’re in the TO/MTL area, it’s worth it as there will be other Go programmers you can network with. 
I would be interested to see a benchmark of that. Mutexs are pretty slow, so I would be a little surprised to see them running that fast. But interesting nonetheless. 
Adiantum designed as a block cipher (despite it uses fast stream cipher as an implementation detail). For disk encription, it uses block of 4096 bytes. It doesn't calculate any signature. I didn't read this particular implementation though. I only looked at PDF file which describes algorithm.
In C++ they use bitshift for io redirection. That’s just a fantastically dumb idea. 
Sorry, ty for the correction :)
That’s what the Readme.md file is for, yet so many people don’t do it well. I’m a big fan of self documentation, where you don’t write War and Peace about your code as it stands for itself. But then so many of them have such insane file structures that I can’t figure out wtf is happening. So yes. I agree. We need better documentation. 
I didn't use mutexes. I've used aromic increment. But believe me, mutex around single counter is capable for millions operation per seconds as well.
I think 90 concurrent requests might be too much, most likely io scheduling is the bottleneck because you're running client and server on the same machine, run this benchmark for a longer time and look at cpu utilization, try to find balance between goroutines number and system load. Checking ctx.Done() is also not needed, because once it gets closed SayHello will return an error and return from the loop. sysctl net tweaking can help as well.
Thanks :) Feel free to copy-paste as much as you can use! The nice thing here is that you can actually decide how long you want to have the client on the other side wait for. There's nothing stopping you from implementing the doSomethingWithFile bit as a go routine and returning the all-clear to the client on the other side while processing the contents further. Of course the same is true for guaranteeing the file made it somewhere safe, no need to return anything until it's checked, and streamed to a redundant database/filesystem somewhere :)
When I’m writing tests, I often create some baseline benchmarks. Eg, testing code paths that connect to redis, I benchmark the raw calls, then also bench my code, so I can get a differential speed. Then I know if it’s the backend or my code causing a slowdown, and can take action accordingly. I would recommend doing that. I’m sure atomic and mutex are reasonably fast but I don’t know about that fast. 
Hm, are you sure you can return the all clear to the client? I don’t know the specific details but my understanding was that the io.Readers in http were streaming from the client, and as such, you may not be getting the full response until you’ve fully read it. After reading and caching to disk, one could respond, and then process with a goroutine for sure. I also don’t know the internal gory details of net/http tho. 
I did a test and atomic does not affect this code in a negative way. 2,7 GHz Intel Core i7 16 GB 1600 MHz DDR3 10 goroutines: with atomic: 139862 reqs, 27972 rps 90 goroutines: with atomic: 221111 reqs, 44222 rps 10 goroutines: without atomic: 139966 reqs, 27993 rps 90 goroutines: without atomic: 213359 reqs, 42671 rps 200 goroutines: without atomic: 214305 reqs, 42861 rps Using local counter and a channel to return the value to main.
I think I got the source of the error. Setting the max no of open connections solved the problem. ``` func InitDB() (*sql.DB, error) { URL := fmt.Sprintf("%s:%s@tcp(127.0.0.1:3306)/%s?parseTime=true", MYSQL_USER, MYSQL_PASS, MYSQL_DB_NAME) db, err := sql.Open(DB_DRIVER, URL) db.SetMaxOpenConns(100) return db, err } ```
Hi, &amp;#x200B; I'm one of the organizers so hopefully can help answer your questions. &amp;#x200B; We decided to have a slightly-longer CFP deadline from the beginning. Mainly to enable speakers who wouldn't know their availability many months out. &amp;#x200B; CFP closes Mar.18 and we hope to have all speakers announced first week of April. &amp;#x200B; We're a group of engineers and a designer who like the Go language, the ecosystem and the community. There hasn't been an event in Toronto, so we figured why not go for it. &amp;#x200B; Combined we helped organize: PyCon Canada, Dutch Clojure days, Go meetup Toronto and Ottawa. &amp;#x200B; We setup a nonprofit called GoCon Community Group and make no money on this event. We did take on sponsors (Toronto is a pricey city). &amp;#x200B; Our high-level goals are to: &amp;#x200B; 1. put together the best possible community event 2. connect would-be employers and employees (networking) 3. if money left over, give back to the Go community &amp;#x200B; Best, MF
Scenario 2 is more efficient if you're likely to have key collisions.
Just wait until a self-signed cert expires, so you set up a new self-signed cert and firefox refuses to connect to it forever after because it doesn't match the old, expired self-signed cert. 
No sure, you're right in that you can't tell the client you've got everything before it's sent everything. I was meaning it in the sense that once you've received everything it's up to you when you want to tell the client you're actually sure it's safe and secure. An io.Writer is just that, and so whether you're writing that out to a bytes.Buffer, a file on a memory-backed filestore like tmpfs, a local disk, a remote NFS share. Heck, if you'd like you can push it into an S3 bucket and not return until you can give the client it's object-id. In-memory, you'd lose the file if the service crashes. On-disk locally and it might be gone if the container or server instance goes down, etc. So it depends on how sure the you and client need to be it's made it. The nice thing about this snippet to me is that it's reading in small blocks so *potentially* not using to much memory, and it's looping over all files in the upload in one go. So you're flexible in how you want to leverage that.
These people definitely exist, but this reads more like a wish list to me (like many job postings). I wonder what they expect to pay...
If you're encrypting files, AEAD is the recommended choice. Your best options there are AES-GCM or ChaCha20-Poly1305. These will be safer than Adiantum as well. Adiantum is designed for disk encryption, where you have to operate on fixed-sized sectors and you can't store nonces/MACs anywhere.
Why is it highest? Is it because of demand of golang developers due to increased popularity or is it due to the complexity of the work golang developers would do? 
hey Bontano. Yes in blockchain implementation but I defined a different rule where it's enough to start with 1 "p" otherwise it would run forever on our laptops :)
1. What if they're using external proxy such as Nginx/HAProxy? It's not HTTPS everywhere, but a pretty common setup. 2. Is there any code that toggles this on startup? 
So, a Go developer earns more in the US than a surgeon or an engineer at Boeing? I have my doubts.
&gt; That being said, it can be a bit awkward the way it gets talked about sometimes because it does definitely sound, at least some of the time, like people are saying that they came up with the whole thing from scratch, which is very, very false. Yeah, and this hybris is why I do not really like this project. If they would just show a bit of humility and acknowledges the historic precedent, then everything would be fine. Just add a foreword explaining how this document just aims to standardise existing practice.
No problem! Your humility is appreciated!
Unfortunately, Go's implementation of AES-GCM does not support streaming. This has lead to projects like https://github.com/minio/sio wrapping AES-GCM to break a stream up into ordered blocks.
I wonder if it’s because only experienced developers pick up Go. 
Please forgive, I new here, but GitHub currently lists 208 issues tagged with 1.12, why the RC1 then? Also I thought Go has time-based releases and 1.12 was supposed to come out by February 1st, does anyone know the reasoning why it was pushed back to March?
Wasn’t Go initially developed to be an easy entry for new developers?
**Bars** of gold pressed latinum.
Then use http, not https. The latter might confuse some to think they have security when they don't. 
I think it would be nice to see some improvement on the build metadata section. The spec says you're supposed to ignore it, but there's no other place in the string to put important data such as platform/linkage information (obviously not a huge issue for Go, but hear me out). If you're building a native library and want to supply builds for musl and glibc for example, it doesn't make sense to version them differently. There (imo) needs to be some "extensions" to the standard that allow the build metadata to be used to make decisions about which versions should be used. For the musl &amp; glibc example, I want to be able to publish `mylib@v1.3.15+stdlib.glibc` and `mylib@v1.3.15+stdlib.musl`, and give people the ability to say "hey, I need this library dependency, but I need the build for musl". Why do I need to either a) register two different projects (`mylib-musl` and `mylib-glibc`), or b) abuse major version numbers like using odd version numbers for glibc, and even for musl? Even more so for libraries that target multiple architectures - `mylib@v1.3.15+stdlib.glibc-platform.arm64`. _There's no reason I shouldn't be able to host those all in one place, and have package managers **know** how to pick the version they need to pull in_. The packages are semantically equivalent, and the only difference is linkage/platform information. (Also, `:`[and probably `@`] should be allowed in build metadata. That it's not is totally asinine.) 
I believe the target it to ship every February and August. They have never waited for the first of the month before. Go 1.12 will most likely come out in the next few weeks. 
Probably because most of the companies using it are still in silicon valley, so the massive wage inflation there (and rent prices) has a disproportionate impact on the average salary. 
No it's not the only option. I dealt with that before: https://godoc.org/github.com/fishy/httpsproxy#NewCertPool &amp; https://godoc.org/github.com/fishy/httpsproxy#DefaultHTTPClient
[removed]
Use cases in general :) Thanks for the list. Are you implementing it with an interface (e.g HandlerFunc)? Or do you just implement a func which is returning a func?
From the [docs](https://github.com/golang/go/wiki/Go-Release-Cycle): "release cycle is aligned to start on February 1" and GitHub 1.12 milestone was recently shifted from February to March.
Just gotta add the new one to the store. Self signed is a really bad way to do things in production. Obviously all roots are self signed, so why not spend the extra 10 minutes creating a long lived, 20 year, 4096 bit key? Or better yet, ECDSA? Then sign sub keys to your hearts content. It’s because of poor documentation. People are left finding out via blogs on how to do things. I’ll be honest, a lot of security documentation is written pretty arrogantly. “You need to fully completely understand TLS, PKI, ECC, RSA, etc, or you’ll do it all wrong wrong wrong, so we won’t document this in case you screw it up cause you’re a dumb newb”. How about write higher level functions for those dumb newbs and point all the low level primitive functions towards those in their documentation? Frustrating to say the least. 
Ah yea, exactly. I usually wait until the object is fully committed until I return an all-clear for the client. It usually takes less than 100ms inside the infrastructure to write the data (unless they have a very large file), so the upload time is the lions share of that. No need to shave off 30-50ms when they've already waited 3-4 seconds to upload from their shitty wifi already. ;) 
Did you run it through a profiler? But, there is https://github.com/gogo/protobuf that can generate faster serialization code.
I don't get it. Are there any real problems that need solving or is this just doing things for the sake of doing things?
Interesting. I've always been told how slow it was to use a Mutex, but this pretty well dispells that. Are you running over a network socket or are you running an in-memory buffer connection? I like using: "google.golang.org/grpc/test/bufconn" That way, I can also run coverage on it instead of separate client/server. That would eliminate the network from the equation. Granted, if you're connecting to 127.0.0.1, then you're pretty much the same speed anyways. To me tho, 90krps seems pretty fast. 
Going low-level with some Epoll. The kernel is pretty stupid fast for this kinda thing. 
Is not support yet. Please take a look at &amp;#x200B; [https://github.com/golang/go/issues/27571](https://github.com/golang/go/issues/27571) &amp;#x200B;