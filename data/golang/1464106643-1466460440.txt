That is, https://github.com/go-playground/log, which seems to be just joeybloggs despite the overreaching organization name.
There seems to be an unwritten challenge of writing the speediest HTTP router in Go, and as long as none of these HTTP routers claims to be ready for real-world use, I see nothing wrong with this. These speed routers are just not made for you and me.
Interesting, I'll definitely address this if it becomes a problem. Although, it doesn't seem like hashicorp/serf is a go library you would include in your go projects -- it seems like a tool that just happened to have been written in go... So I don't suspect any import conflicts that will require import aliasing.
it's just a name :)
hashicorp/serf is the underlying library for Consul and Nomad.
Pretty much. We all have a network shared folder that "My Documents" is typically remapped to. That location is backed up, but nothing else. Nothing on the Unix servers or any other location.
Does the `proto` package not support streaming (i.e. `io.Reader` and `io.Writer`)? That seems strange.
Ahh, so the v3 beta of protoc supports Go with the plugin, then? the grpc-go code still mentions need to compile protoc from source... that's a nice change.
Why this exception that all goroutines exit when the main goroutine exit ?
It uses that library underneath.
It's convenient to have a mechanism to exit the program regardless of what goroutines are running. Even though `os.Exit` can do this, it was a design decision to give the main goroutine this property. It could have gone either way, honestly.
OK thanks, I wasn't really considering a browser-based solution. But I could be wrong -- is this really now on a par with native windowing for apps?
&gt; github electron OK, another browser-based solution.
I am looking for a toolkit that: * is ready for production use (not alpha-only) * is actively maintained, and * uses native widgets rather than a browser (HTML/CSS/Javascript). Looking at the responses so far, it seems that none of the described toolkits meet my needs. Thanks to everyone for responding. 
Vulnerability scanner for Linux: Vuls v0.1.4 Released - Scanning Docker Containers https://github.com/future-architect/vuls#usage-scan-docker-containers - Show scan histories using peco https://asciinema.org/a/emi7y7docxr60bq080z10t7v8 For details see chanelog: https://github.com/future-architect/vuls/blob/master/CHANGELOG.md
Great call. I can't believe I forgot ``gofmt``. That was actually the first pull request. I will work on breaking it up. If you have suggestions, it'd be awesome if you comment on github so I can incorporate them. I want to make this into a robust tool. I dislike Googling for financial info because each stock takes several clicks. Thanks again for the feedback.
Protocol Buffers 3.0 supports streaming, and forms the foundation for gRPC, which was explicitly designed to support streaming.
We also use Protocol Buffers for communication between mobile apps and backend. PB messages really small compared to JSON, in the range of 10 times less, that makes them great for use when one wants to keep the latency bounded.
The router I have created in the process of learning the programming language Go. The task was not intended to achieve maximum speed. But once it happened ... it's not bad. I'm not to blame, that he was fast. Sorry :)
Nope the proper way is a license file. Also why GPL ? Why not MIT or something permissive among those lines
A lot of individuals do this to keep projects organised. I do the same. I wish that Github had some concept of projects above repositories (sort of like BitBucket does).
I also cannot understand, how code generation leads to language fragmentation. Generated code is still plain Go.
But the code that generates it, is not.
&gt; On your webpage your client consuming the JSON is almost certainly Javascript in the browser where it's a native object. But you still need to actually parse and verify it, because just using it as an object is susceptible to XSS attacks, no? I think if there is an advantage to be had for JSON, it's going to be, that browsers come with a function to parse it natively, which might be faster than a custom deserializer for protobufs. And I don't find it obvious that this advantage is dominating comparing to the more efficient wireformat of protobufs… 
I believe he is concerned that if the generics isn't specified in the language specification then we will end up in a situation where one or more code generation tools would be created to provide the functionality and not be compatible with one another. This could cause a situation where we would have to download a specific generation tool as a prerequisite to using someone else's code. I can see this causing dueling dependencies but not exactly language fragmentation. 
Good effort, but if I wanted generics, I would use a language that supports it.
nice! compiling protobufs v3 from source is painful
You're right, routing on Content-Type, combined to path and method, could be useful. Thanks for sharing your thoughts.
Yeah, that's what stopped me looking into grpc a while back... compiling a big C++ project was just too much work.
Agree. Which is why I think it's a dependency problem and not language fragmentation.
Please use TOML for configuration files. JSON is a data *exchange* format. It was not intended for people to write by hand. TOML is. see https://npf.io/2014/08/intro-to-toml/ and https://github.com/toml-lang/toml
I actually got annoyed enough by the to write a rant about it: http://arp242.net/weblog/JSON_as_configuration_files-_please_dont.html The chief problem is the lack of comments. And JSON is not *that* readable. Its two chief problems are the lack of comments and readability. And strictness. Its *three* problems are lack of comments, readability, and strictness. Some parsers also don't give very useful errors... Among its problems are such diverse elements as lack of comments, readability, strictness, and lack of good parser errors.
&gt; The decision to use Go was deliberate, because we needed something that had lower latency than Java (where garbage collection pauses are an issue) and is more productive for developers than C, while also handling tens of thousands of client connections. Go fits this space well. I like this. IMO in terms of GC perf Go will be looking Java in rear view mirror for most applications. And memory usage Go is already an order of magnitude less than Java.
JSON also suffers from lack of good types - all numbers are floats, and there's no datetime type. Read your post about JSON, totally agree. You should check out TOML, it's a lot like ini, pretty intuitive, and pretty easy to write by hand. Better, IMO, than rolling your own, which then no one else can generate without also rolling their own.
You do need to parse it, but [JSON.Parse has very comparable performance to eval](http://www.vinylfox.com/json-decoding-speed-comparison/). When you talk about more efficient wire format keep in mind that in the browser you would also have to transmit the protocol definition to the client and factor that in to overhead, which really only makes sense if you're sending multiple messages of the same type. Once WebAssembly is out and established though I expect more use of other serialization formats.
While your point about JSON is valid, TOML is not a pleasant format for anything with nested structure.
I personally really like Jsonnet. Hashicorp's HCL is worth a look too.
&gt; Replace &lt;-make(chan int) by select {} and it will work. This doesn't work for me in the playground. Still displays a deadlock message: https://play.golang.org/p/yWqSEIVYE9
Although not mentioned, manual memory management is probably a sight better in Go than Java.
I've never actually had a problem with the whitespace, it keeps the files consistent IMO. For the string issue there, you could always just explicitly make it a string. The main reason I like YAML is it is extremely readable, and has other nice things like comments that JSON doesn't offer. It is a lot more complex than it seems, but you don't need to take advantage of those more advanced features if you don't want to (which for config files, you probably don't need to).
Other comments here: https://www.reddit.com/r/golang/comments/4k2k84/zap_fast_structured_leveled_logging_by_uber/
&gt; Personally I like my logs to look great on the console out of the box (with no or little configuration). I don't think zap offers this. You can always write a small tool that parses the output and prints it out nicely. Guys at Joyent took this approach and it works nicely. 
Yep, it can be used, but I am at a loss to understand what benefits does it give
Well, have you checked **sync.WaitGroup** ? https://play.golang.org/p/XPs0ip_-vx Golang documentation is just wonderful, spend more time reading it.
A modified JSON format, with unquoted object keys, comments (//) and trailing commas would be a nice compromise. json5.org is close. I'm just afraid they've gone too far (single-quote string and block comments are maybe a step too far in terms of complexity).
nice write-up. I couldn't help to notice that some of those C++ bindings (and their beautification) could be handled by a general library. something like what I tried to convey in my 'gopy' article: https://blog.gopheracademy.com/advent-2015/gopy/ especially: """ gopy may be just a first step towards a tool suite akin to what SWIG is for C/C++ but for Go. This would help the percolation of Go through “foreign” code bases and strengthen Go’s case as a C replacement. I encourage people interested in this idea to join us at the go-binder organization. """
No one expects the JSON configuration! 
As someone who has no idea whatsoever what those are, a little description in the Readme would go a long way.
Isn't phoenix antithetical to the 'go way'? I mean, it is literally an opinionated fat framework similar to rails, where as Go tends to prefer smaller libraries put together on top of the standard library. Don't get me wrong; I love Elixir and Phoenix and have several production apps in Go as well, but this seems like trying to mix oil and water. Why not just use Elixir if you are going with such a large framework?
yes, I think the part that generates the C scaffolding (with the minute details of "sharing" pointers between Go and C, following go-1.6 CGo rules) could be shared and form the building block of a SWIG-for-Go.
What's the matter with grpc.io?
Hey everyone! I'm the primary author of zap - thanks for all the interest. Please keep in mind that the API isn't finalized yet (I hadn't planned to publicize the library until v1.0). I've got a variety of improvements and cleanups planned before we commit to API stability. If you're interested, you can track the [Version 1.0 GitHub milestone](https://github.com/uber-go/zap/milestones/Release%201.0).
It seems interesting but an example of how you use it would be nice.
What's wrong with [Ragel](http://www.colm.net/open-source/ragel/)? I doubt anything will ever outperform it and it has Go support since forever.
Crashes on Samsung Note 5 with and SDL2 error.
It is definitely possible to write an Android app in 100% Go code, take a look at [gomobile](https://github.com/golang/go/wiki/Mobile). The biggest thing preventing people from writing in Go seems to be the lack of APIs exposed. If you are looking at building games in Go for mobile, you could check out [engo](https://github.com/EngoEngine/engo) (Disclaimer, I'm a maintainer on this one) and [ebiten](https://github.com/hajimehoshi/ebiten).
Of course, I'm still in development so not a lot of time for tutorials. In the end, lets say you want a function block for Square root. Construct it from the blocks library. sqrtblk = blocks.Sqrt() Lets say this is the only function you need, no graph. You can read from a database that Sqrt accepts a float64 value named "IN" and returns a float64 value named "OUT", or you can access that data by calling: params_in, params_out := sqrtblk.GetParams() params_in and params_out are Parameter structs with methods GetName() and GetType(). So run it like this. inputs := map[string]interface{}{"IN": float64(2)} outputs := make(chan map[string]interface{}) stop := make(chan bool) err := make(chan flow.FlowError) go sqrtblk.Run(inputs, outputs, stop, err) The output and err channel you read from, the stop channel you may write to. out := (&lt;-outputs)["OUT"] Run checks the types of the inputs and the outputs to makes sure everything is implemented correctly. And now you have the sqrt. I admit, this is verbose, but here's the deal. Because it's made like this, with the graph structure I've created, which is ran and read from the exact same way (they both use the same interface), you can call long strings of processes. And, an AI program can create graphs intelligently by calling functions like AddNode, AddEdge, RemoveEdge, RemoveNode. I will let you know more once I have implemented that, but that is how it works.
They didn't switch. They wrote a relatively small part of the system in Rust, majority of it is still in Go. See e.g. https://news.ycombinator.com/item?id=11647260 (by a Dropbox guy who worked on the part that was written in Rust): "Nope, honestly. Go is dropbox's primary infrastructure programming language. There's an extensive internal library/culture/toolset around go, so it made the most sense to use that."
I've been looking for something like this, very useful. Thanks!
Same on Galaxy S7 Edge: http://i.imgur.com/KNwqQop.jpg
Same on Nexus 6p
&gt; engo So it seems Engi has taken on a life of its own? I'm currently staying away from the projects that use GLFW and am currently experimenting with golang.org/x/exp/shiny. I have a prototype platforming engine and would like to abstract it into individual components that can be used in other projects. My current prototype builds for desktop and mobile and I'm planning on exposing the same interface for GopherJS.
same on Nexus 5x with the exact same error, I guess it's the same for anybody who has a 64bit arm cpu
This should be fixed now. New builds are uploaded but it will need some time until they hit google servers. Build on github is also updated. I now load libraries with full path to .so, not by name. I am not sure why this worked on different arm7 devices I tested on before.
C/C++/SDL devs also need SDLActivity.java. You can probably write 100% pure Go Android app, but as soon as you need to check/use some service or use native Android UI you will need to call Java. I believe gomobile under the hood still interacts with Java, it implements Native Activity and probably have some C/JNI code for that. I needed for example to show keyboard on highscore, I am not sure if that is possible with gomobile. Also, with SDL you can use SDL_AndroidGetJNIEnv to get env and call Java methods, don't know if gobind can somehow be used for that.
Still crashing at this point. I'm used to Android updates only taking a hour or so, so you might want to verify.
I just realized I didn't actually answer your question. Graph's contain an edge map of type map[Parameter]([]Parameter) Parameters contain the Address of the block that uses them, their name, and their type. The goal is for graphs to begin running at initialization all the blocks which are satisfied by the initially passed inputs, by first passing them to all their connected input parameters. All blocks share an output channel, and once any of them pass an output, it's going to pass that output to all connected inputs, and check to see if any new blocks have their inputs fullfilled. This continues in a loop until the output nodes are satisfied for the graph, and then it passes a stop command to all it's children and returns the data on it's own output channel. All code needs to know is what parameters the graph takes, which are provided, and it will be indistinguishable from a primitive block (which are defined in the blocks package, and must be created by the user). My goal is that graphs will be immutable and stored in a database such that an AI can log every "try" it has ever made, and use them freely without worrying about instantiating them. I don't quite have this working yet, but it will!
Same, tried fresh install from play store 
Finally, that was long overdue. Glad to see it live.
I've played atound a bit with golang, but can't seem to grasp what would be the real benefit? Can some kind soul please explain this to me? :)
&gt;I'm currently staying away from the projects that use GLFW and am currently experimenting with golang.org/x/exp/shiny. Yes, shiny is very interesting to follow, why are you staying away from GLFW though ?
about time to remove that -short flag from tests.
you might like https://github.com/nhooyr/color
Sorry, my bad. I was wondering about the real benefit of the subtest/-benchmark feature, not the language itself. 
Neat.. I have a bunch of tests where I am testing two different implementations, so I end up doing things like func TestLogIndexedSqlite(t *testing.T) { store, err := NewStore("sqlite", ":memory:") if err != nil { t.Fatal(err) } doTestLogIndexed(t, store) } func TestLogIndexedPg(t *testing.T) { store, err := NewStore("postgresql", pgTestUrl) if err != nil { t.Fatal(err) } doTestLogIndexed(t, store) } for each test, which gets a little repetitive, so now I think i can instead do func TestSqliteStore(t *testing.T) { store, err := NewStore("sqlite", ":memory:") if err != nil { t.Fatal(err) } doTestStore(store) } func TestPgStore(t *testing.T) { store, err := NewStore("postgresql", pgTestUrl) if err != nil { t.Fatal(err) } doTestStore(t, store) } func doTestStore(t *testing.T, s Store) { t.Run("test=testLogIndexed", func(t *testing.T) { doTestLogIndexed(t, s) } t.Run("test=testLoadFile", func(t *testing.T) { doTestLoadFile(t, s) } } and have one doTestStore that runs through all the tests. I can kind of do this now, but the result would just be a single success or failure and 'one giant function' wouldn't work for benchmarks anyway.
It's a bit like this: [cli](https://github.com/mkideal/cli)
Nice summary. One thing though: how the json package unmarshals numbers into interface{} is configurable. If the integer value is important set the decoder to [UseNumber](https://golang.org/pkg/encoding/json/#Decoder.UseNumber) to unmarshal into a json.Number type from which you can retrieve the exact int value. 
This lets you resolve (via a reverse lookup of sorts) an IP address to one or more hostnames based on the /etc/hostsfile alone. IP address -&gt; any associated names in /etc/hosts
There are some questionable statements in the article, so perhaps Go is not that bad. Go slices are not linked lists. Also, comparison of slices should probably be done by iterating them and comparing the elements which will return true if both slices are empty. Without code it's hard to judge what went wrong in comparing two slices, but I wouldn't blame the Go compiler for that. I don't see why Go is not an imperative language (there are statements to change program state, like if/for, there are subroutines etc, so Go matches the definition). Wikipedia seems to agree with it, too - https://en.wikipedia.org/wiki/List_of_programming_languages_by_type#Imperative_languages Go has multiple package managers. Since vendoring is now a good option to avoid leftpad-like problems, go get or gb vendor work just fine. Yes, it's different from what Node or Ruby programmers would expect, but I don't see how it makes a language worse.
One thing I have briefly experimented with (with poor results) is trying to get a glx context from the gldriver for shiny. For me: Pure Go Official Library &gt; Pure Go &gt; Cgo Official Library &gt; Cgo
Yes there is, unfortunately, and it's definitely confusing to newcomers. Here's what you need to know: when running/building/installing, if a package is already "installed" and the sources are not more recent, it will not be rebuilt. This is very fast and what you want most of the time. Unfortunately, neither `go run` or `go build` do this by default. Here's what each command does do: - `go build` builds the target and its dependencies but does not install them. - `go build -i` builds the target and its dependencies and also installs them. This is faster on subsequent runs. - `go run` is like `go build` but runs the target. It also does not install the target or any of its dependencies. - `go install` builds the target and its dependencies and installs them Unfortunately there is no `go run -i`, so what you want most of the time is: go install &lt;main-package&gt; &amp;&amp; &lt;binary&gt; [&lt;flags&gt;] ... You can verify the various behaviours by passing the `-v` flag to each command. This will show each package as it is rebuilt. If a package is already installed, you will not see any output. You can see this in the last lines of the following example, as compared to the other attempts: eg. [alec@cavern:~/Projects/gometalinter]go build -v . github.com/google/shlex gopkg.in/alecthomas/kingpin.v2 github.com/alecthomas/gometalinter [alec@cavern:~/Projects/gometalinter]go build -v . github.com/google/shlex gopkg.in/alecthomas/kingpin.v2 github.com/alecthomas/gometalinter [alec@cavern:~/Projects/gometalinter]go run -v main.go github.com/google/shlex gopkg.in/alecthomas/kingpin.v2 ... [alec@cavern:~/Projects/gometalinter]go run -v main.go github.com/google/shlex gopkg.in/alecthomas/kingpin.v2 ... [alec@cavern:~/Projects/gometalinter]go install -v . github.com/google/shlex gopkg.in/alecthomas/kingpin.v2 github.com/alecthomas/gometalinter [alec@cavern:~/Projects/gometalinter]go install -v . [alec@cavern:~/Projects/gometalinter] 
"3 areas in which I need to learn more about go" is more like it. I'm not going to take criticisms of the language seriously from someone who thinks that slices are go's terms for linked lists or that a language without classes can't be imperative. 
&gt; I spent at least two hours trying to reproduce the exact case, and I wasn’t able to. In the end, I just became incredibly frustrated. The most glaring issue was it seemed that a package I was using started to hide errors that were being thrown in my code, which caused some extremely freaky and strange behavior. Frankly I don't think anyone can draw any conclusions reading this. The author probably misunderstood some concept (slices aren't linked lists, they're views onto arrays; errors aren't thrown in go), but since no example has been presented, nobody can really say much about any of this other than come back when you have something concrete to talk about. &gt; Map/reduce in the Go native libraries is something I’m looking forward to seeing in the future. I agree with this part, map/reduce style functions are useful and I miss having them available. Gee, maybe Go needs generics? Why did nobody think of this yet. /s &gt; At the same time, Go isn’t really imperative either. While methods can be bound to structures, classes don’t exist in the typical sense of the term. By deciding to leave out core concepts from both functional and imperative languages, I’m not exactly sure what the “go way” is to do something. Object oriented `!=` imperative `!=` has class inheritance. Go's objects are named struct types, and in place of class inheritance you can use composition. &gt; Go has no Package Manager [Glide](https://glide.sh/) matches the described features pretty much exactly. Caveat: there are others and I haven't thoroughly reviewed all the options.
You're missing json.RawMessage, which can be incredibly useful for parsing the json object in stages. I like to think of the example where you might be using a message bus with a standard base message format (correlationIDs etc) but the content may differ based on another field. You put the content in a json.RawMessage field and unmarshal it only once you know what it is and if you actually need to. Also useful for more dynamic structures: https://github.com/mitchellh/mapstructure
Okay. I guess I'm just not seeing the use case, but I suppose someone needs to do that without using the system resolver.
Also http://go-gopher.appspot.com/go-on-github
I think the author confuses "object oriented" with "imperative", not having written code in any non-OO imperative languages.
Perhaps I'm mistaken, but I believe youtube has the full array of 64 characters, they replaced the `/` with some other character, `+` is still there because it is url-safe. Anyway, TIL. Thanks.
Just checked: you're right, my mistake about youtube.
I don't mind reading articles that are critical of Go, as long as they are well written and convey well formed points. The first two points contained no examples or details, and also contained wrong information. The 3rd point seemed like he just didn't research the availability of package manager solutions. This was a terrible article. 
This is actually pretty rad; I'm going to play with this later. 
In a benchmark measuring benefit from parallelism: consume = func(p int) { m.Lock(); sum += 1; m.Unlock() } I would recommend you (re-)read https://blog.golang.org/pipelines instead of this blog post.
/r/xlab_is it's nice to see your library take off a bit! I'm looking forward to seeing how this progresses. 
Woo, congrats!
No wonder there's no more of those "Andrew and Brad hack on something-written-in-Go" videos. :D
While I don't necessarily disagree with everything said in the post, opinionated pages of authors who have been programming with a language for just a week are, honestly, a waste of everyone's time. For the record, I've been programming Go for exactly six weeks (it's been my full-time job for the last four weeks), and in my experience part of learning a new language − any language, no matter how simple and "easy" − is being confused and frustrated about something because *"this would be so much easier in language foo I'm familiar with!"*. In my experience, *every* language has something new and subtly different from what I've been used to. *Different* doesn't necessarily have to be "worse" (although it sometimes is, of course). Now, I share some of the frustrations and annoyances from your post, as well as some others you didn't mention. But ... are they real problems? Or are they just the result of my inexperience and lack of knowledge of Go? As far as I am concerned, they could be either, and I am hesitant to truly form an opinion until I am reasonably sure I know everything there is to know. For me, it takes **at least** a year of serious programming in a language to *truly* understand the subtleties, design decisions, and trade-offs that have been made. Other people are probably smarter than me and can do it in a shorter amount of time, but I am highly sceptical that someone can do this in just a week. There is a quote: "a person's opinion changes over the years. Except for the opinion that [s]he is right." I don't know from who it is, I actually got this from a random `fortune(6)` many years ago, but I find its wisdom profound.
I'm not trying to be a wet noodle here, but what are the advantages over go-ini?
Aw, thanks! I was really confused to see this on my Reddit front page this morning until I noticed it was the golang subreddit. :) 
This seems like a much simpler way to do things, no? https://gobyexample.com/worker-pools
Someone with a Chromebook that can talk more about it? it sound super interesting, enabling Go on Chromebooks could be a revolution to all those students with only this laptop in their hands.
My assumption is that cores not gonna fight for it: consumer is relatively fast comparing to isPrime. but i'll verify that. Thanks!
Also in this category of awesome little tools (albeit not in Go): https://github.com/posva/catimg
congrats =)
You need to register somewhere the websockets that are connected and send to all of them. Don't forget to clean up after the user disconnects.
Hi, I created this to improve my go and docker knowledge and will br very happy for feedback . * didn't test it on OSX thanks Miki
They would be better served installing crouton and a full, (mostly) kludge free Linux desktop
Oh the day the web opens up for udp multicast for regular users. 
I looked at your README a while earlier and honestly it felt like a number of talking points there were ad hominems against gomobile, even though your email to golang-nuts talked of drawing inspiration from gomobile. While I haven't looked at the internals of your project and I understand your frustration with the current situation of gomobile, i think it'd be worthwhile to at least have a consistent view of gomobile across your communications, whether it be positive or negative. Personally, I think it'd be nice to have different target APIs in gomobile and I'd even file an issue for it if I were you. Some things take a lot of work and it's worth discussing with others, raising an issue on the issue tracker would bring about that. At the same time, if your goals are solely with Android and are that disjoint from gomobile's goals, I totally get that as well. A bare cgo api sprinkled with a few helpers will surely serve those that have similar vested interests.
Congratulations!
That break will break on the first websocket that was disconnected and not send the message to any websockets after it. Also I would consider doing each send in its own go routine, or use buffered channels, since send can block.
He said "the golang subreddit", a.k.a. r/golang. It's not the same situation.
I think https://github.com/xormplus/xorm gives the perfect balance between being simple and being convenient
I think https://github.com/xormplus/xorm gives the perfect balance between being simple and being convenient
I think https://github.com/xormplus/xorm gives the perfect balance between being simple and being convenient
I think https://github.com/xormplus/xorm gives the perfect balance between being simple and being convenient
I think https://github.com/xormplus/xorm gives the perfect balance between being simple and being convenient
Finalizers are not guaranteed to run in timely manner, or even at all. A much safer approach is the one taken in "Blade: A Data Center Garbage Collector" ( https://arxiv.org/abs/1504.02578 ), although that does require a small patch to the runtime. 
Run your code with race detector - [this](https://github.com/JamesMilnerUK/pip-go/blob/master/pip.go#L91) is unsafe. I doubt you gain any significant perf. benefit from running it in parallel. There probably are better optimizations that can be done.
So you mean it's a static blog platform?
&gt; it felt like a number of talking points there were ad hominems I was feeling a bit frustrated after a week of fighting through this all. &gt; your email to golang-nuts talked of drawing inspiration from gomobile. Yes, this was the second thought, because actually I've got a lot of inspiration and motivation and some code samples from gomobile. But anyway, I did this all only because gomobile has flaws in its design. &gt; raising an issue on the issue tracker would bring about that. Yeah, that was original idea but I decided to write my complains in the README because with an alternative solution attached, my words won't be just bike-schedding. I really expect to see some co-operation. And yes, the changes required will break gomobile, so it probably will be 2.0 and probably the current authors would reject such ideas. IMHO. &gt; bare cgo api sprinkled with a few helpers Surely you've got my ideas. It's a bit disappointing that this can't be done with gomobile in its current state. 
If you _really_ insist on parallel access without locks, you can allocate the inside slice beforehand, and set the "slots" in parallel.
maybe there was some issue with github :)
You can also visualize memory consumption but you need the heap profile not the CPU profile.
C'mon, this is just a light-hearted post to congratulate Brad. Did you really have to bring this up here and now?
It's strange how you are mingling with `runtime` package here, generally the user should be configuring GOMAXPROCS and you shouldn't set it as an upper bound in `PointInPolygonParallel` IMO. You must be testing against some pretty large polygons to want this code to run in parallel? Otherwise, why not just leave it up to the user to spin up a goroutine and test point-in-polygon for e.g. each polygon? You would get some huge benefits from SIMD instructions, but obviously that means writing assembly or waiting until Go has an auto vectorizer of some sort.
[removed]
He referred to the language as golang, when I used it in my book, they be snarky and tell me to call it Go, and you say I can't do that as a return favour?
for fun
CRUD is a verbal mismatch for HTTP. Put, Post, Get and and siblings are your friends. Get to know them, they make building applications a lot easier.
&gt; Try to write a complex validation framework like the Java Validation spec Wasn't that the whole point of the OP's link?
I think Go is a fantastic language for beginners. In my day it was C, which taught me fundamentals about memory management, io and networking. The first books I bought on coding was TCP/IP Illustrated Vol 1 and Unix Network Programming. I really believe that Go is the natural successor to C for many types of development, with less of the hassle. I also feel that it's probably easier to go from Go to other languages than vice versa.
HTTP has nothing to do with crud nor op's question. 
GET POST PUT and DELETE have nothing to do with crud. They are part of a protocol. Using them you can implement CRUD for recording some type of data. With the POST request alone you can do all the steps of CRUD. Two totally different layers in the OSI. Edit: well actually you can't record data with them, you have to pass it on to something else. 
That involves locking. This little function has barely anything to do, my gut feeling says parallelism gives almost no gain, so locking would push it to the slower side.
I'm suggesting original poster consider HTTP data handling semantics, i.e. PUT/GET/DELETE rather than CRUD semantics. The verbs mean different things, and should not be trivially mapped to the other set. Doing so myself caused me to miss the real beauty of HTTP for a very long time. Today, I choose to build everything I can using the HTTP verb set, even when there's no HTTP over the wire, and I was simply suggesting that that OP might benefit from their use, as I do.
You must add a license to it else nobody can use your code. Also by looking at some of the files the imports are out of order. Please run gofmt on your whole package and subpackages.
&gt; You also now risk having business logic spread across both the app and DB which some people don't much like. &gt; While this is a worry, what should be stored in the database is 'data logic'. If your business logic is inherently tied up with your datastore to the point that you must enforce all data go through your intermediate wrapper this is a very bad design. Not that I want to have a go at you, but I come across this idea (That code should not be in the DB) constantly and it is problematic. Databases provide certain consistency guarantees and stored procedures can be part of this.
You are wrong in including HTTP. But I also thought I should point out that PUT is an all but worthless HTTP Verb and I advise against using it where possible. POST and PATCH occupy the 'submit a new item' and 'change the attributes of an item' requirements, PUT is only suitable for 'place this item at position X' actions which are rarely required.
Thanks for the project. I'm trying to use it with goamz library, and it fails because of some differences in GET/POST requests. I wonder whether it's problem of goamz or goaws. To be precise, goamz talks to SQS with GET queries in format of "GET /queue/name?AWSAccessKey...", but aws command line client uses POST in form of "POST /". The second one works with goaws, whether first one (GET /queue/name) returns 404. I would love if someone could explain why there is this difference exists in a first place(GET vs POST, / vs /queue/name). Is it some legacy, or different versions, or something else? Looking forward to use goamz and goaws together!
Looking forward to the new video then. :)
Exactly, these are just comments, and have been much needed for a long time. I've been using them, very helpful for all my uses, and they really add to python's main focus IMO, that everything can be accessed, written to, treated as an object, including now parameters!
At the same time, this doesn't seem like a golang thing to me.
The use of reflect.Select seems quite ugly here and in general I'm not sure what advantage is preserved.
&gt; You are wrong in including HTTP Wrong how? &gt; I should point out that PUT is an all but worthless HTTP Verb I couldn't disagree more, but I certainly did feel the way you did once. Allowing the caller to set the ID makes applications much easier to stitch together and keep synchronized.
Using HTTP semantics makes applications easier to scale, replicate, distribute data and/or work nearer to the end-user, synchronize, backup, and integrate with -- even when no HTTP over the wire is in use.
&gt; It's orthogonal to CRUD Maybe yes, maybe no. While it may be technically, I know of few developers who spend most of their time in SQL databases who've even considered upsert (PUT) semantics, so I'm not 100% in agreement on this. &gt; Please show me how you do the equivalent of a standard BEGIN… COMMIT cycle with a caller supplying the ID over HTTP PUT Does your DB not allow you to set the ID column manually? And, finally, [PostgreSQL supports upsert semantics](https://git.postgresql.org/gitweb/?p=postgresql.git;a=commit;h=168d5805e4c08bed7b95d351bf097cff7c07dd65)
Check out https://github.com/Spatially/go-workgroup
I have to disagree on panic-ing. It depends on the use case, but if you're building a production system, crashing the whole program is rarely something you want to do, programmer error or not. It can lead to cascading failures, among other things. Panic-ing is more well-suited to initialization issues, it can be better to just drop the request or serve an error for problems that happen during normal execution. Also, since a data structure like this (even if I disagree with it's existence in the first place) would likely live in a library, it's doubly-better to return an error than panic.
But they are putting it in Developer mode anyway, which means it's fairly open and insecure. AFAICT Crouton's Linux environment is technically no more invasive to ChromeOS than this limited Go environment, other than taking up more HD space. (Of course allowing this while forbidding crouton can be a matter of policy, I would just find it a strange policy)
What's wrong with just using Redis for Go unittests?
Love those =)
I don't get why they didnt just write to separate files instead of file format fuckery
+1 In other news, I'm waiting for people to re-implement header file includes and the preprocessor in Go.
I had the same problem yesterday with boto(python) and I made some changes... Perhaps you can clone the repo and try to build locally and see if that helps.
I will do that - appreciate the comments thanks!
done! 
Happy I could help. I know it's not the most pleasant part of developing things but it has to be done. Good luck with finishing this, looks promising. Thank you for your efforts.
I use make almost solely because it automatically provides shell completion for its commands. I can add a Makefile with all the various go commands I need for a project and they are all documented and easy to run.
https://play.golang.org/p/USEI1oCU6d
I would prefer not to, but when you have multiple versions of the same application deployed it is great to be able to query a service and find out what version it is. Version numbers, build numbers, commit hash, build date... You can add all of this to your executable target with a Makefile. Handy when you wonder when, or from what commit, something was built. The other nice thing is `make test` for your build system if anything more than `go test` is needed. What about dependencies and other setup outside of your project? `make deps`is a reasonable target to add that sets all of this up. As far as build pipelines go (continuous deployment) a Makefile is fairly portable. The special commands that you enter into your build system are not. So yes, I like to avoid a Makefile (or whatever) but some build/test/package cycles aren't are a little more complicated. 
From the comments in julienschmidt/httprouter for router.ServeFiles: &gt; // Internally a http.FileServer is used, therefore http.NotFound is used instead &gt; of the Router's NotFound handler. &gt; To use the operating system's file system implementation, &gt; use http.Dir: &gt; router.ServeFiles("/src/*filepath", http.Dir("/var/www")) In other words, you need to either use a different router library that doesn't have this property, or just don't use the ServeFiles method - it is all of 11-lines long, so you can replace it readily. Edit: See [examples here](http://stackoverflow.com/questions/9996767/showing-custom-404-error-page-with-standard-http-package) for doing this with the vanilla http package, or with gorilla/mux
Exactly. I like having locality of reference for simple things with easy-to-forget command options. `go build` doesn't bother me much, but some of the other development-related commands have easily-forgotten flags that I'd rather just have make fill in for me. Here's a makefile I use: ANSIBLE=ansible-playbook -i conf/hosts.txt ANSIBLE_LINUX=${ANSIBLE} conf/linux.yaml ANSIBLE_OSX=${ANSIBLE} conf/osx.yaml JS=Root/JS/v.js GO=*.go SCSS=Root/CSS/*.scss .PHONY: build build-linux install clean up upconfig initial initial-osx setup-dev-environment lint fmt-js fmt-go fmt sass check build: ${GO} go build -race build-linux: ${GO} env GOOS=linux GOARCH=amd64 go build -o googlies.linux install: go install clean: go clean up: build-linux ${ANSIBLE_LINUX} --tags up upconfig: ${ANSIBLE_LINUX} --tags upconfig initial: ${ANSIBLE_LINUX} --tags initial initial-osx: ${ANSIBLE_OSX} --tags initialosx setup-dev-environment: npm install -g eslint npm install -g jsfmt brew install sassc go get -u github.com/golang/lint/golint lint-js: ${JS} eslint ${JS} lint-go: ${GO} go vet lint: lint-js lint-go fmt-js: ${JS} jsfmt -w ${JS} fmt-go: ${GO} goimports -w . fmt: fmt-js fmt-go sass: ${SCSS} sassc --load-path Root/CSS/ --sourcemap Root/CSS/all.scss Root/CSS/all.css sass-watch: sass --load-path Root/CSS/ --no-cache --watch Root/CSS/all.scss:Root/CSS/all.css check: lint fmt sass None of the targets are particularly complex (certainly not the ones starting with "go "), but it's executable documentation for how to make the project go.
The jury is still out on the exact definition, but at that point, it's an integration test and not a unit test.
Yeah that response really shouldn't be getting upvoted...
As I noted by, "Sync is handled for you". I think I misunderstood the intent of your original comment. 
Don't understand why you have to do this? It seems the template should just work. Now if you are trying to inject HTML or JS into the template, then the escaping would happen. But to turn off escaping, convert the string to template.HTML type, and pass that in. Play with just template and a string value, so the string value will get escaped. ( https://play.golang.org/p/mfSAMt7d10 ) Play with template and a template.HTML string value. No escaping will be done. ( https://play.golang.org/p/ToF-u9cvmo )
Such as?
Write an intercepting response writer like this: https://gist.github.com/nhooyr/9b7b432496716b364bc3a00f08152387 All you need to do is create a handler that wraps router.ServeFiles and set the error handler of interceptingResponseWriter appropriately. If you have more problems, I can cook up a full example.
Nothing at all. And here's a package that makes it easy: https://github.com/stvp/tempredis
Thanks for saying that, I use Windows exclusively on my home PC and it frustrates me seing Go projects that have unnecessary dependencies to make (or other Linux-ism/Unix-ism). Plus, being able to write a build script in plain Go is so much nicer than the horrible stuff that a Makefile is.
In theory, yes, but not everyone will have it installed, and really, why add another language to your project if you don't have to?
Gimme is more for smaller snippets of code, rather than packages with a longer life (which are more suited to vendoring). By copying code into your project, you are taking ownership of it. It's an alternative to dependencies, not a replacement for them.
And "small snippets" can't have bugs or problems? ;-)
They can - I expect people will manage it manually. More tooling might help, but I want to wait to see what people thought.
In the past I've run into `ErrBadHTML` errors when trying to run JavaScript files through the template engine, which was my motivation for ensuring that it's properly escaped _as JavaScript_. Unfortunately, I'm having trouble coming up with an example that demonstrates how to hit that error, but if I can reliably demonstrate when it becomes an issue, then I'll follow up here.
If somebody puts in the effort to develop and support the port, why not? It does not affect you in any way.
I'm not upset, I'm just surprised. I'm actually glad the project is healthy enough that esoteric ports are possible.
A lot of the core Go team are Plan9 people.
Doesn't look like it, as it has a Redis server and full text search.
also https://github.com/daaku/go.redis
I would love to see a full example! I'm still new to Go and am not sure what a handler like that would look like
&gt; They only exist to prevent a particular kind of less-clueful companies I'm curious who that would be. Ideas?
Could you please provide an example of what would multiline struct tags be useful for?
Neat. I think it might also be useful to return the previous value in `Set` and `Unset`.
https://www.reddit.com/r/golang/comments/4m2ftg/torus_a_modern_distributed_storage_system_by/ (author here :) )
&gt; os/user &gt; The Current function is now implemented even when cgo is not available. :scream: This is awesome for cross-compilation. `runtime.KeepAlive`and `runtime.SetCgoTraceback` also look like fun additions! 
Nice article. Here is another well done post which might provide inspiration for adding a small note about using `defer`: https://medium.com/@matryer/preferring-defer-6c597b887120#.wvce65pd7 Edit to add after seeing the responses from /u/Don_Equis and /u/Matthias247: It might be helpful to use a sync.WaitGroup (deferred) instead of the channel. And possibly change the counter to a string mutation. The example is obviously contrived and not meant to be an expansive explanation of concurrency. Link to more detailed and thorough articles if it seems right.
While useful I don't think that's the intended usage for struct tags but hey we can wish! Thanks for answering
But the Plan 9 port was done by the community, not by the Go team. 
Fun fact: the Go 1.7 compiler is *faster* than 1.6, because they won the speed penalty back, and then some, in the space of a couple months thanks to the more maintainable code. So you were just being an asshole about things you didn't know anything about for no good reason :)
I tried to write a command line flag library to do just that a while ago, but like you'd expect trying to cram all the data into struct tags became rapidly untenable. I ended up just defining metadata about the flags through function calls. It's github.com/bieber/conflag btw, definitely still a work in progress
ZOMG 5%-35% CPU time reduction. Congrats Go team! Cannot wait to test 1.7.
Looks nice, but not needed. I have just implemented the same pattern today with two lines of code ...
Agree on most points, and blindly using mutexes without understanding the complete picture and not having a good concept for concurrency in general is a recipe for disaster sooner or later. The Go way of fixing that race condition would actually also have been to swap the `i++` and `&lt;-finished` lines - which means that main function would only use the shared variable after it is guaranteed that the child goroutine no longer uses it.
The approach I decided to take was writing a "spec" for each argument, I found chaining function calls to be too verbose, so just made a simple parser for both options and arguments. So you configure a command like this: d.Opt( console.DurationValue(&amp;timeout), "-t, --timeout=TIMEOUT", "This is an option that has a complex description that will need to be wrapped onto "+ "several new lines. This will make it difficult to make it look 'nice' in the "+ "configure function. But that's what we're aiming for anyway.", ) d.Arg( console.StringValue(&amp;source), "SOURCE", "The source repository to clone a template from. May be given in different formats "+ "(e.g. full Git URL, or short-hand URLs for popular Git hosting services, like "+ "github: gh:eidolon/gonsole)", ) d.Arg( console.StringValue(&amp;destination), "[DESTINATION]", "The destination for the template to be cloned to. If the destination does not exist, "+ "an attempt will be made to create it.", ) It doesn't let you do more complex things like validation within the spec (like, mutually exclusive parameters for example), but you a lot of CLI libraries don't let you do that with the method approach either to be fair! Edit: People downvoting, can you at least say why? I'm quite new to Go, and am learning the language, it'd be good to get some feedback rather than random downvotes. It's a bit off-putting.
https://66.media.tumblr.com/2ddc80b2f528080ac7775ba8bbc29f98/tumblr_mhwmqk6ojm1rihc88o1_250.gif
You have an odd definition of fun. :)
Yeah if you want a full package and don't mind maintaining the dependency. Sometimes it's worth it.
I'm sure someone else can provide more details, but from what I understand UUID's are not k-sortable, take 128bits to store, do not store/sort as well in databases, and are slower to generate. Also, however unlikely, UUID's I believe have a higher chance of creating a duplicate ID.
Ah thank you!
Also excellent way to encourage nodejs like building of meaningless libraries.
Cool, thanks
Aww yiss. No more shelling out to `id`!
The package is about readability which matters, not LOC(lines of code).
Don't get excited. The code just reads the $HOME variable which was easy enough to do originally and occasionally wrong: https://tip.golang.org/src/os/user/lookup_stubs.go#L22
With what little bandwidth that saves I'd argue it would be a wash considering you have to wait for a handshake timeout to release the socket.
Hurray! Congratulations Go.
Fair enough. I suppose the value gained from it is subjective. 
Your equality operator when comparing a slice is misleading
No shit? Any non atomic value isn't goroutine "safe". Also why do all your posts have clickbait titles? Go back to node.
Cheers to removing unnecessary public map restrictions imposed by encoding/json string keys. I'll be rethinking some of my set implementations for 1.7.
https://play.golang.org/p/0dIiKsOuoK compiles. What else could you need in a struct tag?
*This post turned out longer than I thought it would. Please don't take it as an attack on your observations but merely as a different opinion from someone who initially felt the same way about several things in Go as you do.* &gt; 1. The s structure is created even though I may not need it. &gt; 2. Even worse, it is returned uninitialised in error conditions. Make it so that the function returns a pointer to a struct and not a struct. This lets you return nil. (as you have noted in your post) &gt;Here I feel the language is forcing me to do something awful (return a structure I know is invalid) and expect the caller to deal with it. Since your function also returns an error, you are anyways expecting the caller to deal with it. &gt; 3. Repetitive code for dealing with error conditions for calls. It's not repetitive because they're not the same errors. Let's suppose you have a try/catch block like you have in traditional languages. In that case, you'd be catching specific exceptions to handle them appropriately. This is no different. And if you have a single generic catch, that's frowned upon in most of the languages that have try/catch blocks. The advantage of handling errors like Go does is that how you handle an error is visible close to the point where the error occurs. Now when you compare this with how pattern matching can help in F#, I'm going to cry foul. F#, Haskell &amp; the likes have a rich type system and features that let you do some amazing stuff. You won't find any argument from me if you say that these languages are more concise than Go. &gt; but when I'm returning a structure, I need commas Definitions and instantiation aren't the same. You'll see similar difference even in languages like C# where a field declaration in a class ends with a semi-colon but the object initializer syntax uses commas to separate the field/value pairs. &gt; I can see the benefit of allowing a comma on the last line, to support quick refactoring, but forcing it seems odd. Why commas for some constructs and not others? Apart from compiler requiremenst (I guess). consistency helps. Think about when you add a field to the struct. While adding the field in an instance, it is common to miss adding a comma at the end of the previous field if there wasn't one earlier. &gt; Also, some more 'unusual' syntax (depending on your background) is present, I assume to save space: something := createAndAssign() This is what I felt too when I started out. However, I've found this immensely helpful in being able to quickly determine whether a variable is being used for the first time or not. &gt;// rather than var something SomeType something = assign() You can do something like this in Go. &gt; But some space saving constructs such as ternary operators are missing No arguments. I too would like to see this in Go. &gt; Difficult Debugging ~~I would definitely like some editor/IDE integrated debugger for Go~~ As pointed out by /u/bbrodriges, the VS Code plugin supports Delve for debugging. It's pretty neat. 
The socket is closed and never ESTABLISHED, what do you mean by "release the socket"?
Yes.
&gt; I would definitely like some editor/IDE integrated debugger for Go There is Visual Studio Code with Go plugin which supports Delve for debugging.
https://github.com/jpillora/go-ogle-analytics
Also, IntelliJ supports debugging with the Go plugin too, and it works pretty great.
It's actually pretty scary what he is doing there. He isn't utilizing the language given solutions for handling race conditions at all. Like you said, he is using techniques outside of the language, which, in it self, isn't inherently bad, but if he continues doing so, while not using the language provided features, he will have a very bad time. And so will others who will have to maintain what he is writing. So instead of looking for better ways to do this (like any programmer would) he just settles with something he already knows, which is a bad practice. 
This seems relatively clean and clear to me (and not too unlike the F#): func LoadSettings() (s *Settings, err error) { raw, err := ioutil.ReadFile(GetSettingsPath()) switch { case os.IsNotExist(err): return CreateDefaultSettings(), nil case err != nil: return nil, err } s = &amp;Settings{} err = json.Unmarshal(raw, s) return s, err } I'd be returning a pointer because it's potentially a larger or more complex object (optimizing heap allocations in a one-off function is a bit ridiculous), but I think the author needs to get over the uninitialized object thing - just check your errors first, and try to make uninitialized objects useful (so you wouldn't need CreateDefaultSettings). A good discussion of exceptions is out of scope of a quick post, but I disagree that exceptions are better. Exceptions create magic paths through our code that cannot be seen clearly by the reader, where you can have strange side-effects you don't think about (maybe the file gets closed, but it's left half-written and invalid). I've seen plenty of index and key errors that should have been handled leak upwards because nobody considered the cases and unit tests (if there) never caused them to raise and because they were calling someone else's function that had explosive edge cases. Pure functional code is about the only case where I'm not too worried but otherwise you're hiding cognitive load for later. YMMV - that code was an exceedingly large code-base and it deployed into production and worked *most* of the time, but I'd rather people think about error handling as part of their code and API up front than later ($0.02) I don't think you should persevere at learning a language if you're not feeling receptive to some of its opinions, since you'll just be miserable with it. Unless it's hurting your career or team, use what makes you happy and productive.
Oh the sweet smell of 2012 and picking on minuscule details of a new language, interspersed with a lack of understanding. Only that the language isn't new anymore, and everything that's being said here has already been said, countless times. This might as well have been a copy &amp; paste job of a hundred existing articles on the internet. Don't get me wrong, I don't mind criticism, if it were useful, or novel. But reiterating what has been said over and over again is not useful to anything but generating some clicks.
nim would be a better fit **IMO** it can be run as script and it is really fast
Ridiculous! I've been coding on and off in Go since it came out of beta. These same issues keep being repeated because they are real issues. The opinionated decisions were made but, in some cases, they were wrong. That's right, the coders of Go made some wrong choices. But they're sticking with them because reasons. I'll keep using Go and will continue liking some parts and hating others. But just because they are what they are doesn't mean they are the best or even good. Error handling, for example, is one of most annoying things. This could easily* be changed. But, because of inertia, stubbornness, and that silly bit about not making changes to the language we won't get better error handing. You're allowed to talk about how great it really is and I'm allowed to complain about it. Generics is another item that sucks and could be fairly easily* fixed but won't. Again because of reasons. Oh well, but that won't stop me from complaining about it, because it's just wrong. Etc. (* ) "If it's so easy why don't I fix it." *(Don't be that guy, he's an ass-hat.)* I don't fix it because I'm not that smart. To paraphrase, I'm smart enough to recognize genius but not talented enough to have it myself.
You could also consider Julia, which is supposed to have good python integration.
&gt; Error handling, for example, is one of most annoying things. _"It's programming with error values. Simple programming, yes, but programming nonetheless."_ You might have to re-read [Errors are Values](https://blog.golang.org/errors-are-values) and [Error handling and Go](https://blog.golang.org/error-handling-and-go). 
*&gt; you may not think it's worth it* Didn't say that. Just that I wouldn't stop complaining about the things I don't like. Comes with having a child's mind in an old man's body. (Though, I do think error handling could be fixed without introducing breaking changes.)
go-debug (https://atom.io/packages/go-debug) for Atom also integrates with Delve for debugging.
Then they could've just linked to any of the existing articles, to introduce their audience to them. **Edit:** To be fair, they can of course write about whatever they want on their blog. I'm more annoyed by the same repetitive stuff getting posted to this subreddit.
I don't think anyone who's been coding Go for more than a few months hasn't read these articles. I understand the concepts but still find the actual code tedious and repetitive. 
The semi-cop-out that are map and slice being generic, but no other containers being able to use it irritates me a bit. If you don't think people need generics, you shouldn't make a language whose two basic containers use them as an exception. Errors, not so much - unlike in Python, I can read Go code and assume that the paths through a function are as written, rather than every function call or raw dict lookup potentially causing cascading magic function returns that also need guarding against in any stateful code. The stability of the language is also a huge appeal, coming from Python and the 3.0 split back in ~2008 that *still* hasn't been resolved for all libraries or for many large codebases.
Update: I just finished implementing Graphs. Loops are almost done! Then all I need are switches, and custom types, and it's all done :)
&gt; I don't think anyone who's been coding Go for more than a few months hasn't read these articles. That's why I advised to reread them.
https://github.com/fncodr/godbase/blob/master/password.go#L45 So, two things here.. You're only checking for the return value of 0, as you only care about equality, so you probably want bytes.Equal instead. But don't use that either. The problem with both of those methods is they return as soon as possible, which means a clever attacker can gain knowledge about the hashes you're comparing based on how long your code takes to return. This is a [timing attack](https://codahale.com/a-lesson-in-timing-attacks/) What you really want is [subtle.ConstantTimeCompare](https://golang.org/pkg/crypto/subtle/#ConstantTimeCompare) 
&gt; Error handling, for example, is one of most annoying things. Well, error handling is always going to be annoying, in the sense that it's annoying having to deal with errors. However, I find Go's approach to be one of the least annoying of any programming language I use. I mean, don't talk to me about Java-style exceptions. Checked exceptions are awful and have totally failed to solve the problem they set out to solve (programmers ignoring errors); unchecked exceptions are a debugging nightmare because a null pointer happens somewhere you had no idea it could and suddenly you have a 300 line stack trace of mostly other people's code and no indication of which part of _your_ code was the root cause. As for generics, it's not that it won't be fixed, it's that they're waiting until they have the right fix. Again, Java is a good example of how bad it can get if you roll out the wrong fix. ([Accidentally Turing complete!](https://arxiv.org/pdf/1605.05274v1.pdf)) There are definitely things I dislike about Go, but I decided that they were too trivial to make me avoid the language. (For the record, those things are: The hopelessly inadequate logging library, the stupid default date and time format, and the fact that there are two different assignment syntaxes and you need to use both. Told you they were trivial.)
I don't mind Go's approach. Just the noise. FWIW, here's my ideal syntax solution to reduce the clutter. Mock up with bad names for clarity. package main import ( "fmt" "log" ) // could be a type signature type ErrorHandler1 func(err error) error // or could be an interface type ErrorHandler2 interface { Handler(err error) error } func liveErrFunc(err error) error { returnReturn err // HERE'S THE FIRST CHANGE. Must return from caller's scope, not just this scope. } func debugErrFunc(err error) error { log.Println("Now we're logging.") returnReturn err } func main() { fmt.Println("Hello World") var anErrorHandler ErrorHandler1 // using the type directly anErrorHandler = liveErrFunc for _, num := range []int{1, 2} { if num == 2 { anErrorHandler = debugErrFunc } result, anErrorHandler := erroringThing() // HERE'S THE OTHER CHANGE. // We're allowed to put a function pointer variable in place of the error variable here. // The compiler adjusts accordingly for the new syntax. // Existing code works. New code can be abstracted away and even changed at runtime. } } 
I'm glad that you agree it could improve code readability. I agree with the abstraction part in most cases as well. However I don't think simple things like this(as you have said) could make things hard to understand, it's just a Boolean, the aspect is simple enough, there are nothing magic in the implementation. How can simple things like this hurt the understandability? I think when you said it is simple yourself, you've proven it. 
The main problem is how to handle some expected errors, and bypass unexpected errors? The easiest way to handle error is just panic(), but it's irresponsible and should not happen in stable applications.
Go is good a option. Cython, numpy, numba, ... are other options. For example, [spaCy](https://spacy.io/) uses cython to make a speedy nlp toolkit usable from python. Maybe you should try both options. 
So you think the errors package is perfect, but I think it could be improved in some cases.
This is an example of error generated by fmt package in [docker source code](https://github.com/docker/docker/blob/v1.11.2/daemon/graphdriver/plugin.go#L24). Could you tell me how to catch the error? Do not say lookupPlugin() is not exported method, it's just an example in popular go project
Ha this reminds me of the time I decided to try angularjs 2.0 and after doing all the things required to get the "Getting Started" tutorial running on my box my project had over 1200 files and 350+ node dependencies....
&gt; I'm glad that you agree it could improve code readability. I agree with the abstraction part in most cases as well. My point sort of was that readability is the wrong metric, you should go for understandability ;-) This is not a pedantic distinction or play with words. A good example is rspec (a testing tool for Ruby) which tries very hard to be readable − which it is − but fails pretty hard at being understandable. Most JavaScript libraries and frameworks − at least those that I've used − also fail very hard in being understandable. &gt; However I don't think simple things like this(as you have said) could make things hard to understand, it's just a Boolean, the aspect is simple enough, there are nothing magic in the implementation. How can simple things like this hurt the understandability? In this particular case, I don't really think it matters a great deal, and it's a bit of a bikeshed. I would personally just use ints myself (probably, I never had to do this beyond 1 variable so I can't speak from experience), but if I would somehow inherit a codebases that uses this package (or something similar) I would continue using it...
You show the most general way to generate error: create an error struct. But it's annoying, you have to write a log of codes for the error.
i used to use python for the same purpose but then one day i was writing something (deciphering a string that used separate caesar cypher for each word) and the python program took too long, the same program in Go took very less time (python code might have been shitty) from then on i use Go for most stuff, small experiments that can be done in the repl are still in python, network/computation in Go. I even created a Go local package with a ton of helper stuff for commonly used functions. So, yes it can be reasonably be done in Go.
I think a single-line `if` (both in prefix and postfix style) should be backwards compatible? New keywords (like `returnReturn`) are never backwards compatible, since someone could have used that as an identifier...
Just did. They haven't changed and don't provide any help in reducing boilerplate cluttered error handling in my code. Either I'm not understanding something obvious or I'm not as good a coder as I like to think. Likely that latter so I guess I'll continue to curse the darkness. Sorry about that.
Godoc looks broken, was that intentional?
I just noticed that auto completion does not work anymore and jump to definition is very slow in LiteIDE with 1.7 beta 1. 
I posted here to get advice on go idioms. Is this the wrong place to do that?
I agree a single-line if would be backwards compatible. It's still verbose for my tastes but better than now. Saves both lines and braces and is more readable. I do like the function call to return the error, if it occurred. Makes the happy path completely visual clutter free and puts the error handler and return out of the way. Others won't like it because it moves the error handler and return out of the way. ;-) ReturnReturn is definitely horrible. It was just to get the idea across.
you need to update gocode. I'm not sure about jump to definition but its working great here with neovim and vim-go.
How can I update gocode on Ubuntu ? Thanks
`go get -u github.com/nsf/gocode`
Yet another amazing screencast by /u/campoy
No, I can't. But you are blaming Go for Docker's mistakes.
I think this type of thinking is valid when you have existing code and can't migrate away easily, but it sounds like the needs of the author are amenable to rewriting it. While you can certainly profile the code, find the slow parts and see if you can speed up those aspects in some lower level language, that complicates your workflow quite a bit. If you make a change you have to rebuild your package, which might mean redeploying it (even in a virtualenv) in order to pick up changes. Also, debugging things becomes much more complicated. I do think it is more difficult to use Go to replace a scripting language like Python in some ways, but as others have mentioned, you often have a result that is more than fast enough. It also has the benefit of producing single executable, which can save a huge amount of time over deploying virtualenvs or installing via pypi on servers. 
Yep, I wrote about how I do that here: https://dmitri.shuralyov.com/blog/18
Does it also work correctly wrt $()?
Nope, but I'll try that.
As far as I know it does. I've been running the thing on hundreds of shell scripts (mostly gathered from test inputs in `busybox` and `bash`), so it should be solid when it comes to common practices. Of course, bugs might appear if you start doing things a little differently. Take [this issue](https://github.com/mvdan/sh/issues/2) for example. If you do find a way to make it error where ash/dash/bash don't, please let me know :)
Really cool, but IMO forcing a style in shell is a guaranteed way to prevent people from using your tool. Go worked because it was a new language. Organizations that have already used shell for years and have established style aren't going to switch because of a random tool, they're just not going to use that tool. Edit: my work place is a prime example. I was excited to see this, then instantly disappointed when I saw the enforced style as they would never adopt it.
I'm not asking that everyone start using this, nor that this become the one and only style for shell. I wrote the parser to teach myself about that sort of stuff, and thought that I might as well do a formatter like `gofmt` while at it. From my experience though, very few people enforce a style in shell programs. At least not in projects I've contributed to. Often they more or less follow a style, at least when it comes to indentation, but not much else. And they don't have a tool to enforce it. So in a way this could be useful to some projects, and that's what my intention was.
&gt; My point sort of was that readability is the wrong metric, you should go for understandability ;-) So I'm saying that the thing is too simple to worry about "understandability". I'm no interest to play with words, if I misunderstood your point, I'm sorry :) The examples you give are much more complex than this package, those are the cases that I agreed with the abstraction part, but not this one.
AFAIK Go is something that especially C and C++ devs use to make their works a lot easier. Perhaps learning C and/or C++ might be a better bridge towards learning Go than Python? Since C and C++ are more closely related to Go than Python? I have a few more experiences with other languages, but all of my programming experiences are just basic level.
What's the problem with a module? You should look at the benchmarks. :)
That's a great technique! I've updated the write-up linking to this thread, thanks!
My team is just starting to learn Go. I am sending this to everyone - it's a fantastic introduction to all the tooling.
hi /u/interactiv_ - fair points. I'm not ready to give up just yet because I think I've not had the chance to see where go cancel excel, e.g. (from what I've heard) concurrency. Probably after trying to write a web server app I'll have a better understanding
hi /u/sacado What I mean, but probably didn't describe well enough, is that the first line of the function is stating the intent to use a part of the stack for a data object, which may or may not be needed. I'll return this object whatever, leaving it up to the caller to make sure they use it only if it is valid. I have to ensure that I return the error properly but also leave it in the callers hands to make sure they check the error before using the object. It's nothing to do with the performance of the code, whether it is on the stack or allocated on the heap and passed back as a pointer is going to have no impact on a function called only once in an app like this, and one of the things I like about go is the C style explicit option to choose whether the stack or heap is more appropriate. I suppose it's a balancing act - having these options gives you more control over memory, copy/return sematics etc but means that at times the code will be more imperative than declarative.
12:00 Please compile static regexes only once in global scope.
Does `Write` return an error? If so you should check and handle it.
What I am most impressed about here is the Gopher that guy is holding in his profile picture. I want one!
I think this one is the best yet, because it is light and quick showing off a lot of useful tools. It is really fantastic. 
When did they show that they're willing to not merge optimization steps that are too slow?
First, [it doesn't work](https://play.golang.org/p/xYWd3jAlhn). Second, even if it did work, then the user's code will not be executed, which is a sub-requirement of the challenge as stated later on. If things like that were allowed, I would have stopped at `SetMaxThreads(4)`, which instantly crashes the program.
You wouldn't be in doubt if you took the time to actually watch it to completion. Code starts sloppy and tightens up over the course of the video showing off tools that help it do that. These tools would have no purpose if he wrote perfect, optimized code off the bat -- hence would be impossible to demo. What you are complaining about is 100% required to show how the tools work. Have to omit an **err :=** to show how errcheck works, have to have code to optimize to show how profiling and go-flame works, etc. 
TravisCI already has a package called Gimme. At first, I thought that's what this post was about. https://github.com/travis-ci/gimme
How is a CLI tool an apps host? Or is DeployIt not just a tool, but a service you're selling? If that's true, that should be presented better. Regardless, "apps hosting" and "hosting resources" are really the same thing. I can just as easily version control my code on Github, or self-host with Gogs or similar, and then push to deploy to another self-hosted server with Dokku (or even Caddy with hooks). I wouldn't pay for some centralized hub, as I can host that, or if it is analogous to a Docker Hub, then that's free to host as well. If you are selling server management/deployment/orchestration, then there's things like Kubernetes or Rancher, also free.
This is great! Wish it had php support as well so i could use it for work. 
Crossed my mind, but I'm not a big fan of naming things `go*` just because they're written in Go :)
&gt; [...] but couldn't find easy to follow tutorials. That's the problem, you are probably trying to implement something that you barely understand. Here is the [official documentation](https://godoc.org/golang.org/x/net/websocket) for the _"websocket"_ package and there are [enough examples](https://github.com/golang-samples/websocket) to get started with it. I doubt you will find a step-by-step tutorial explaining what every keyword does in the code, just read the documentation because that is what it is for. **EDIT:** I believe people coming from a JavaScript background, and specially from the Node.JS community tend to get things for granted, just install this bunch of random packages in my project and make some function calls and I'm done, right? I would expect people to learn the basics of every concept they want to implement in their projects before they start doing something with it, this is not like learning how to drive where you don't need to know how an engine works. In this specific case not knowing what is a web socket and/or not having an understanding of how it works will surely affect the final product.
There is certainly a competitive advantage to GO.
The official [backend example](https://golang.org/doc/articles/wiki/) is actually quite a good tutorial. It assumes knowledge of HTTP protocol, which you shall know by the time you doing backend. I went through it when I wanted to know how HTML shall be done with Go.
 I agree we could benefit from more examples in documentation, but at least we don't suffer from the opposite problem, which is to show tons of shallow examples but no thorough documentation on what methods, parameters, overloads and data structures are available in a package. I used to think the .Net platform got this right, but with the newer stuff it seems harder and harder to find anything but shallow examples. 
Better solution - change jobs
Thanks for posting! We updated the Chrome extension so that jump-to-def keeps you on GitHub. It feels pretty magical. You can install it directly here - but watch the video first! https://chrome.google.com/webstore/detail/sourcegraph-for-github/dgjhfomjieaadpoljlnidmbgkdffpack?hl=en 
Yeh yeh it's easy to hate on php. Laravel and modern php isn't so bad, you should leave your bubble more often. I quite enjoy working in my php codebase, not as much as I enjoy idiomatic Go of course, but it's not as bad as everyone makes it out to be. 
I didn't know Stockholm syndrome was possible for programming languages, but there you go. 
You need to sign up on Sourcegraph.com and add your repositories there. Then it'll work. We built it this way so it never sends your code off GitHub. 
`fmtsh` :P
see how github.com/uber-go/zap handles this. standard Go logging is simplistic, and encourages amazingly crappy logging. the problem with "errors are just values" is that at the very least - errors have *parameters*, if not also cause errors and origins (file:line or stack trace). if you just dump printfs to stdout, you hand totally unparsable goo to your log collectors; which is why those are often based on document indexing engines - which seems crazy for logs. switching over to zap had many huge benefits, such as: the library makes it easy to use constant values for error names (so that they can be *counted* when there are millions going through log collectors), they have named parameters so that you can do meaningful work with these counts. from logs, you should be able to compute aggregate performance numbers, reliability rates, etc. you can't do that if you are just pasting strings together and dumping them to stdout with no more structure than a timestamp. an unambiguously parseable format (json, thrift, csv, etc) also makes it easy to transform logs into the format that is most suitable for collection. I think the standard logging library is as lame as it is because Google uses something totally different for real-world use (related to Borgmon, etc.). You need to be able to correlate messages that relate to a single http session, etc. So you if you don't have thread-local re-assign of loggers, then you need something like what Uber's zap does to hand derived loggers around. I can go on. When I import third-party libraries, they dump junk into my stdout, and usually provide no way to override the libraries logger so that I can make its logger conform. You don't need a complicated library. You just need an interface that can be overridden so that the formatting can be made to conform to what the overall app needs.
I'm a not a PHP dev but you're an idiot if you snub a language.
There's no windows notification support :(
**[SYN flood](https://en.wikipedia.org/wiki/SYN_flood)** --- &gt;A SYN flood is a form of denial-of-service attack in which an attacker sends a succession of SYN requests to a target's system in an attempt to consume enough server resources to make the system unresponsive to legitimate traffic. --- ^I ^am ^a ^bot. ^Please ^contact ^[/u/GregMartinez](https://www.reddit.com/user/GregMartinez) ^with ^any ^questions ^or ^feedback.
What I observed when playing with time.Sleep() statements in pubsub.go: * Once a client is listening, messages do get queued for that client. The client can process messages in a slower pace than they come in. * A client does not receive any messages that were sent before the client started listening. (I think this one is kind of expected. The queues build up on the clients' ends. No active client, no queue.) * If the server exits before the clients finished reading all messages, all unread messages are lost. (To verify this, comment out the three client&lt;n&gt;.Wait() statements in pubsub.go and also *all* time.Sleep() statements in the code, then compile and run, and wait for a couple of seconds. The three clients will complain about a receive time out.) 
'$ 0.375 / 32 MB Memory / month' for hosting ? Is that correct ? Sounds very good to me. If this is true then I certainly will try this. But how about processor load ? And can I connect a domain name ? Would be great for some of my small projects. The '300 deployments for $30' as noted elsewhere is now gone ? 
Thanks for the report. We'll try to repro on our end. Do you have a URL to a page that exhibits this issue?
didnt know about `cat &gt; main.go`. :)
That would imply the OP was preview to other articles about this topic. The internet is a BIG space - things appear and disappear at a whim. And I doubt the OP read every bullchit post before they posted their bullchit post. Just food for thought to expand narrow minds.
Check out the [Build Web Application with Golang](https://astaxie.gitbooks.io/build-web-application-with-golang/content/en/index.html) free book (read online or download). There's also the [Go Web Programming](https://www.manning.com/books/go-web-programming) book (it's currently a MEAP, it will be released this month by Manning).
Yeah, nope. I don't have a Windows machine or know anyone that uses Windows. PRs welcome though! :)
Oh, I thought you're referring to Match. Yes, if you write an arbitrary MatchWriters is not safe to use (as noted in the doc) and no one should use it unless they know what they are doing. There are legitimate usecases of MatchWriters beyond Java gRPC and HTTP2; BTW, all http2 implementations I know of today ignore dup-acks. Do you know any http2 server implementation that panics on dup-ack?
Found a few more to add when I have time: https://arxiv.org/abs/1212.6183 https://arxiv.org/abs/1503.08768 https://arxiv.org/abs/1604.04892
This is great, was thinking about a utility similar to this a few days ago, nice to see someone already implemented it.
I'm just curious why on earth a static site generator would need to support WebSockets?
&gt; the first line of the function is stating the intent to use a part of the stack for a data object, which may or may not be needed You're prematurely optimizing. It's very unlikely that your bottleneck is a few bytes in a stack frame which are only "wasted" in the error path. Heap allocating your structure would probably make the main case slower anyway. This is a non-problem, but even if it was a problem, it's not Go specific. You'll have the same issue in C, C++, Rust, etc.
Edgy
Write a new error struct is annoying. You have to implement Error() interface for each error struct. My package is a helper to do this, you just need one line code for each error type. And as rrr00bb said, logging and errors are strongly related. So my package provide the trace and formatter interface, too.
You're the author so you are in control of how you process the data you receive. You don't need to replace all commas, just the ones in the time part of the date/time field. Your users shouldn't care how you're parsing their data. I've offered something you can adapt to get around the issue, but if you're just wanting to complain, steer the course. You're doing great:)
I also tested it and was pleased to see that messages get buffered. The next question is, how do we tune the buffer size? Obviously we dont want the publisher to block until the subscriber picks up the buffered messages (like with a go chan), but we also dont want to have memory usage explode because a subscriber has hung and messages are backing up. I suppose by that stage, you probably want the a broker-based pubsub system instead.
Mangos' sockets have two options, OptionWriteQLen and OptionReadQLen. These might be what you are looking for. (I must admit I have not tested these options yet. According to the docs the default size for each option is 128 messages.)
Great screencast! Informative, concise and inspirational!
```echo $GOPATH``` is set properly. The directory $GOPATH/src/github.com/revel/ exists as well. My project is outside of github.com/revel/ and is contained within github.com/&lt;mygithubname&gt;/&lt;myproject&gt;. 
What happens when you run the equivalent of `type go` and `less $path_to_go`? Are aliasing or wrapper scripts involved, or are you dealing with the base go binary?
&gt; it's unable to be found. What does that mean? "unable to be found" is not a go error message. What does go build actually say?
Have to think about it but yes, and it is not really specific to Go. Basically an error type in Go is an interface, i.e. can be any other type. What you are asking for is to be able to discern between the different types of errors. (a struct could contain the parameters for the errors you are thinking about). In that case, what you could do is not returning an error interface as the sentinel for your result but return your own error type (very probably a pointer, and which would still implement the error interface most likely). But in the case you may have different error types as return value, you can't beat an interface and a type assertion. That's probably the general case to put in use. But indeed, otherwise you would have to delve into regexes because a tool like Guru might be a bit too slow, although that would be the right way to do it probably.
Have a look at https://github.com/xormplus/xorm A really cool ORM
Are you using any non Go code in your project? Maybe C/C++ code with cgo?
Have a look at https://github.com/xormplus/xorm A really cool ORM
Why not use [runtime.Goexit](https://golang.org/pkg/runtime/#Goexit)?
https://gobyexample.com/ is a great place to start for a bunch of basic stuff like reading files, etc. It starts with just basic syntax, but the later items are a nice introduction to the standard library in practical terms. Let's see, the most widely used packages probably include net/http, io, fmt, and os. I'd also explore the packages at https://golang.org/x/, which is the 'extended standard library.' These packages are useful enough to get recognition by the go team, but not yet stable enough to be included in the core library and be subject to the Go1 compatibility guarantees.
awesome thanks
It seems nice after glancing the README. However I'm afraid I cannot use this because the license is GPLv3. A permissive license like BSD, MIT, Apache would be great.
The community wide thing you are looking for is called "idiomatic" or "idiomatic for/to Go" or "Go idiomatic". No need to invent a name for it.
HTTP is fundamentally stateless -- with the possible exception of authentication when using a token based system like OAuth -- but even then the token is the state and can and should only be stored on the client-side... If your application requires additional state, keep it on the browser side using a modern single-page-application framework or similar technique of your own. It's very important these days to separate user experience (front-end, browser and mobile) from data manipulation and processing (back-end, on server).
I plan for a package for every noun in the system, with collections being independ of the single-entities. In each noun package you have each HTTP verb (GET/PUT/DELETE/POST) that you can apply to that operation and in my case, yes, I intend to have a server for each operation, which will get wrapped in a Docker container for deployment, and many operations will have corresponding workers that will asynchronously process notification events from queues fed by a pubsub notification system. Lots of tiny pieces, lots of flexibility, and the promise of being able to add functionality after-the-fact without modifying existing code...
I've been using this [this watchrun](https://github.com/loov/watchrun)
Neither C nor C++ are easier to learn than Go. Languages are dime-a-dozen, good programmers can and will use many in their careers. Whatever helps OP learn to program is what OP should be using...
First 10 seconds of reading source: check your errors. https://github.com/m-abdelrahman/faseela/blob/5dbf6f3f0f20f0ac3e80fcd943a8caee4efa1e6f/models/auto_increment.go#L14-L15
Nothing about websockets has anything to do with "broadcasting" a message (really, sending multiple messages). WebSocket is a client-server protocol, nothing more nothing less.
Ok, noted. Actually I just want to focus on append multiple times in a slice. Btw, thank for your comment.
[Docs](http://revel.github.io) : [Release Notes](https://github.com/revel/revel/releases/tag/v0.13.0) : [Godoc](https://godoc.org/github.com/revel/revel)
... by running your own, special-purpose epoll event loop: https://github.com/tevino/tcp-shaker/blob/ecd883184f3bbb80eea18ee4c4b85867f3a02bff/shaker.go#L160 *Really* doesn't seem worth it. If it's performance you want, try a userspace minimal TCP stack. Also, you should probably be testing application-level functionality; simple TCP proxies/load balancers and SSL unwrappers will fool this.
OO?
Thanks, fixed.
interesting that the docs say " If all other goroutines exit, the program crashes." for some definition of "crashes." It is a bit tongue in cheek, overall. Not meant to be a huge enlightening moment :) I definitely find it odd to exit main() and wait for other goroutines to exit, so I tend to block forever. It's more of a mental model limitation and less of a philosophical opposition to Goexit. Might make sense to use Goexit instead.
I've been doing some websocket stuff lately and my issue was being able to find client-side websocket examples, there seemed to be several examples for server side websockets with Go, so I'm surprised you couldnt find them. I initially built my small websocket client with /x/net/websocket, and later moved to Gorilla's websocket library. This was so i could use conn.ReadMessage (which resulted in a complete JSON message) vs x/net/websockets conn.Recv() which will hand you an incomplete message if you didnt supply a big enough []byte buffer. There was no tutorial for using Gorilla websocket lib as a client, but as is the Golang way, I found a good example in either the examples directory or the test code. Reading the source is a very common approach in Go, rather than relying on tutorials.
Sorry, you're completely correct. The actual build error is: ```cannot find package "github.com/revel/revel/testing" in any of : /usr/local/go/src/github.com/revel/revel/testing (from $GOROOT) ($GOPATH not set) (build)``` I'd also like to note that I'm using Atom for my editor, if that helps. 
When I run ```type go```: ```/usr/local/go/bin/go``` 
I don't really understand why `runtime.Goexit()` is recommended here? Doesn't it make more sense to actually design a program in such a way that goroutines just finish, when their work is done? And for keeping `main` alive, and therefore the process, there is `sync.WaitGroup`. It is much more graceful than any other method mentioned here. &gt; It’s likely that any failure of a server ought to end your program, so having errors panic() will end the process. In that case a call to `os.Exit(1)`, or any non-zero status code you like should be the way to go.
Nice work jeevatkm .. thanks
Of course, yes. My reply wasn't supposed to imply disagreement about your suggestion to handle the error.
Blocking forever is usually a sign of code that is not testing-friendly, so I hope readers read this blog post as a curiosity rather than something they should be doing. (In its own right, it is indeed a very extensive list of how to "block" forever in Go.) For `main`, I usually let that handle OS signals, at least catching `os.Interrupt` to do a graceful shutdown. I.e. it handles the OS process' lifecycle. If I have more ways to kill it (e.g. a specific RPC), I will just let the `select` listen for EOF on more channels. Overkill? Maybe, but it gives me a warm fuzzy feeling, and it's testable. In some cases I've made a [cancellable context](https://godoc.org/golang.org/x/net/context#WithCancel) with `context.WithCancel(context.Background())` and waited for `&lt;-Done()` on that in `main`. Then the signal handler only needs to cancel the context and the whole context tree will know. Cleaner, but I only do this if using some framework that already cares about `Context`s.
If someone is annoyed by the way revel build and packages, you could try [mars](https://github.com/roblillack/mars). (API compatible with revel, but can build with `go build`.)
Show the output of `go env`.
You have an error in your regexp. This pattern works for your test case: ``` "^(([1-9]x[1-9]:[1-9])|q)$" ``` However it is still a little limiting. Are you really only allowing numbers of 9 or less for the values? This seems more flexible : ``` `^((\d+x\d+:\d+)|q)$` ``` Note the back ticks as a string literal so that you don't have to escape the back slashes 
Why are you running JavaScript through a templating language in the first place? Templates are about dumping out data in an easy way, but JavaScript is a programming language, not a data language. If you just need to pass some values into JS, just say &lt;script&gt; window.myValues = {{.MyVals}}; &lt;/script&gt; &lt;script src="/assets/js/myscript.js"&gt;&lt;/script&gt; And in `myscript.js` do all the value wrangling that needs to be done.
&gt; ($GOPATH not set) your GOPATH is not set.
Also annoying:duplicate post. 
Congrats, Hugo is definitely my favorite static site generator :) Edit: and good work on the cobra and viper libs, been playing with them a bit myself lately.
This is the opposite of that. Instead, the idea is people take ownership of code snippets (which they would otherwise copy and paste) and don't build gigantic dependency trees and all the risk that goes along with them.
Yes, this is for a sudoku grid so 1-9 is perfect. Thank you very much for your help!
Can we please not use this subreddit as a general announcement channel for projects written in go? I consider it fine and a very good idea to announce your project here once, but after that, individual releases should be announced in a project-specific ML or subreddit or whatever.
you may try something like https://play.golang.org/p/oZn2Oy_jMq
That would really depend on your use case. It sounds like the person who wrote this blog post is trying to deal with arbitrary logs from arbitrary users, in which case I agree you are pretty much stuck dealing with pre-formatted data. If this were for some kind of internal monitoring project though? Yeah I'd just tell people to fix their log files. Even in the first case, I'd probably build everything I can around the concept of getting clean structured log input where timestamps and fields are machine readable, and then just deal with parsers to try to get any arbitrary log format you run across into your machine-readable format. Then if people want better performance and more reliable parsing, they can start sending you your properly formatted logs on their own. In general I think printf style logging needs to just go away. Logs should be read by machines more often than by humans. In the context of a machine parsing your logs, it makes no sense for you to take structured data in your app (the time, a status code, and error msg) and try to turn it into a line of text, only for some other service to have to try to reverse that process. If a human wants to read it, you can always do that same formatting you used to do, just do it at log viewing time and not during the logging itself. 
The idea is that there is an interface: `type Zeroable interface { IsZero() bool }` This would then be checked when marshaling types to json, and if the field is marked `omitempty` would cause the field to be omitted if `IsZero()` returns true. This is a simplification of the current method of making the field a pointer, where `nil` is the "zero" state. It should be noted that `time.Time` currently implements this method. 
I agree. And plus I don't want to keep up with 10 different subreddits to keep up-to-date with some projects written in Go. Congrats Steve and the Hugo community!
There is nothing else going on. If anyone goes and ready the hugo source because of this thread I think it works out.
Did definitely grow into a bit of a beast.
Weird, if I click run on your playground post I also get 7050. If I run it on my local vm, I get 50000. Looks like it diverges at ((oldValue - oldMin) * newRange) which is essentially 100000 * 50000. If you just try to fmt.Println(100000 * 50000) you'll see an error that "constant 5000000000 overflows int" If we declare your variables as int64s, it seems to work fine: https://play.golang.org/p/-8fCjTKv_P I really don't know why the playground would default to int32s there where my local Go(1.6.2 on linux) defaults to int64s, but there you go. Sorry for the poorly structured reply btw, wrote this while debugging it while eating lunch. 
That's fantastic news, and this is the perfect place to post it. Thanks!
Shameless self-promotion - Here's a 5 minute screencast on the basics of using Gorilla websockets: http://www.goin5minutes.com/screencast/episode_4_websockets_with_gorilla_websocket/
If someone isn't interested they can skip over the post... And nginx already has its own subreddit b/c its community is large enough to warrant it. Smaller projects don't need an entire subreddit dedicated to updates. If it's related to Go I don't see why it can't be posted here. I like finding out about new/updated Go projects and I would think that /r/golang of all places would be the place to find them.
I think most packages would have substantially better documentation if they just made more use of godoc's built in examples support: https://blog.golang.org/examples Seriously, there's no reason why most libs can't include a collection of these along with their tests, and yet most of them skip this.
&gt; And plus I don't want to keep up with 10 different subreddits to keep up-to-date with some projects written in Go. That's why most projects have an -announce ML, so that you get the news about your favorite projects delivered right to your inbox. In case of release-announcements, github even gives you a convenient RSS-feed. There are dozens of more appropriate channels for release announcements than pushing it to a 20K subscriber subreddit, 98% of whom won't care. If you do care, subscribe to one of the other channels, that's your right and privilege. I'm sorry, but that's just basic communication etiquette.
I'm looking forward to seeing how it affects the Shootout results.
what if you want to implement that logic yourself? would you use reflect.DeepEqual instead of `==`?
Here is the direct link to the changelog as well: https://github.com/fatih/vim-go/blob/master/CHANGELOG.md#17-june-7-2016 Please open an issue if you see any errors or bugs. Also don't hesitate to open new feature requests or to give feedbacks! I'm more than happy to listen :)
I find in most realistic programs, `main` waits for *something*, doesn't just block forever. It might be a listen-accept loop returning with an error..
I use [gomon](https://github.com/c9s/gomon)
https://github.com/mattn/anko 
I just don't click on the posts that don't look interesting. If you have decided that you want to read everything, that's your prerogative, but it's not fair to also complain that not every message is personally interesting to you.
There's a cost associated even with posts you don't read. &gt; it's not fair to also complain that not every message is personally interesting to you. True, and that's not what I'm complaining about. I am complaining that it's not fair that there is a specific subset of posts for which far more suitable channels exist that are still posted here. i.e. even if the cost of spam to me would be negligible (it's not); if the cost to the other party of *not* posting them is zero, it's a fair complaint.
There a few advantages for REST over RPC (in certain contexts), including the idempotency and global caching (CDN) available on GET requests as well as the stateless assumption. iirc, HTTP 202 is a valid way of accepting a PUT / POST request but deferring the result (usually with a requestID in the response and some way to check on progress). I think it's fair that you *can* build a distributed monolith by accident with REST, particularly if you make some poor choices with respect to not handling outages, slowdowns and other cases. However, I don't think it's responsible to say that without pointing out that messaging has quite a number of pitfalls lurking in its closet too (as well as micro-services, to be fair). I've talked to a number of people who worked with messaging where it became a real problem - we're talking about a loss of high level overview of what was happening with nobody sure what would happen with service outages and people who spent their entire time keeping the ESB running. If good API design and failure handling is a requirement for REST micro-services, good message design and other practices seem pretty important to messaging. (Interestingly, I've rarely spotted a good write-up of these pitfalls though)
Thanks for the response! I'll research it more in depth for myself.
MarshalJSON could also omit a field if the []byte return was nil but there was no error.
Several ways. Two that just come to mind: You could process HTML requests in your Golang program and request data via AJAX calls from the Webpage to your program or you could use a persistent Websockets connection to pass data between the two. The later is what I am doing with my IRC bot I am currently working on to get a webchat output.
Ok, thanks I'll just look that up then.
Thanks bakunin!
FWIW, the Intellij plugin fully supports that. As long as it's in the GOPATH, it can be auto-completed.
What did you learn?
Nice intro to the make tool. Btw, [gox](http://github.com:mitchellh/gox) also compiles in parallel AFAIK. (I know, it is not as versatile as make.)
Gox and goxc are both great tools. I prefer make as it allows me to do much more than just compiling.
If you're interested in Make then this article i wrote for smashing mag might interest you https://www.smashingmagazine.com/2015/10/building-web-applications-with-make/ 
In the scenario where both Go, and C++ are unfamiliar to a developer, is Go easier to install, write a basic web server, compile, and run? Aside from the GO_PATH GO_ROOT confusion of earlier versions, I found it very easy to get something up and running and could see the path forward. With some other languages &amp; stacks I've gotten lost in setup, and wasn't able to see a clear path forward. Don't underestimate the power of simple &amp; clean documentation.
In case this isn't a rhetorical question, yes. Edit: Whoops, answered before I saw your edit.
I would also add: * Go has reflection out of the box--this is a useful property for things like serialization/deserialization (I understand that C++ may have recently added some form of reflection, so this point may be less valid or invalid altogether) * Go's standard library is much more comprehensive * Go's build system is much more convenient * Go's tooling is much nicer - More readable compiler errors - There are no suitable C++ analogs for vim-go, and even getting something as straightforward as autocomplete is painful
HN comment thread https://news.ycombinator.com/item?id=11855775
&gt; This is really more just aesthetic, though. I think it's than just aesthetics. The amount you need to learn to read arbitrary Go code is nowhere near as large as you need to learn to read arbitrary C++ programs. The C++ standard is so large and supports so many styles of programming that at the extreme ends of styles, the "dialects" aren't really mutually intelligible. It is also a moving, ever-changing target. I knew C++98 quite well, but C++11 is like a whole other language! These are tremendous potential strengths, of course. *If* you have experienced and skilled C++ programmers, an organized engineering team, a software architect and management willing to impose a standard coding convention on the team. For inexperienced programmers, for loose teams, for long-term maintenance by those, it's easy to get sucked into a complexity trap where different architectures are glued together inappropriately or turns into spaghetti.
TypeScript has made it more tolerable.
All the keynotes and most of the talks from the last two years were posted on Youtube not long after Gophercon... I don't know about live streaming but you can certainly watch them after. Here's the ones from 2015: https://www.youtube.com/playlist?list=PL2ntRZ1ySWBf-_z-gHCOR2N156Nw930Hm
I know they record them and put them up on YouTube afterwards, but I don't think they are livestreamed. Maybe its something the conference organizers could look into providing on either twitch.tv or ustream.tv. I'd certainly be willing to pay for a livestream of the event. 
I gave up on C++ after seeing things like this: ``` template &lt;typename T&gt; inline T const&amp; Max (T const&amp; a, T const&amp; b) { return a &lt; b ? b:a; } ``` I somewhat understand what this is doing but there is just so much to know here.
Rust is even worse.
Is there a reason why you've decided to use the netcat interface instead of DNS? The benefit of DNS is that you can use the resolver's cache as a sort of nearby cache without having to pay the penalty of a TCP connection potentially across a large distance when you create the client. For bulk lookups, the netcat interface is surely the right way to go and you were right to choose it for that scenario. However, for individual one-off queries, I would have thought DNS was the more elegant solution -- mainly because if you run multiple instance of this code (across multiple containers etc) and they share the same resolver you might get lucky and get a hit on the local DNS cache. Even if you don't choose the DNS solution, you don't appear to be handling cases where the link to the whois server fails due to timeout or similar (due to the connection not being used for some time). Do you expect the user to recreate a new client each time? Having said that, nice work. It's always interesting to see people implement things in the networking world. It'll be very useful to someone looking for something other than Maxmind for IP-ASN lookups at the very least ;)
:+1: I didn't mention it in my comment but I completely agree. C is a model of simplicity and I think the Go team did a fantastic job designing an "improved C". Not saying Go can nor should replace C, just that it's an improvement in many respects and without becoming a beast.
Yeah, it was my fault, seems like it slit trough the review :) . I've released a minor version 1.7.1 with the changes: https://github.com/fatih/vim-go/blob/master/CHANGELOG.md#171-june-7-2016 It's fixed in master as well. Thanks again for the feedback!
https://isjavascriptfun.com/?yes
Also worth noting that regexes in go are very slow -- and this will be reflected in the benchmarks that use regexes (dna, etc)
A bug in your C++ program has the potential to allow callers to execute arbitrary code on your machine. Such a bug is generally impossible in Go. In the small, I can tell you what any line of go code does, the amount of memory it's going to allocate, the general complexity of it, etc. This is impossible in C++. A simple line like `a = b` could go download a docker image from the internet. &gt; Go and C++ seem to differ in ... (reputedly) compile time What?! Go compile mongodb, I'll wait. Actually, I won't. It's a project approximately on the scale of Juju (they both have ~750,000 lines of code plus or minus depending on how you count). Mongodb, written in C++, takes 45 minutes for me to compile on my machine. Juju takes about 8 seconds. That's THREE orders of magnitude.
I think even more importantly, the organizers need to do a better job of collecting and posting slides. Preferably on the gophercon website.
If you are looking to cancel an http request, there is a Cancel channel on the Request struct. When one of the requests wins, send to the Cancel channels on each of the other outstanding requests. For example, cancelling a single request... https://bitbucket.org/snippets/patrickdlogan/G6BMb 
I am a vim user and the vim-go plugin will automatically remove unused imports for you. Still need to use the variables but definitely reduces the amount of the commented lines that you described. there are probably similar plugins for other editors.
Go is already [on par with Java](http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=go&amp;lang2=java) and it's only going to get better.
Thanks for the feedback and kind words. I thought about implementing your recommendations during development but figured it wasn't worth the time at that moment as I just made it for a silly personal project. As a result of a couple of complaints I will try to implement the DNS resolving for single lookups and connection persistence within the next few days.
I guess the most interesting part about Go is that it's [not that interesting](https://www.youtube.com/watch?v=4Dr8FXs9aJM) :D. However more seriously, after several years of considering, the best feature of Go is how packages work. This might look like a small thing how you import and declare packages, but it has a large impact how you write code and how good code looks. Few important notions are: 1. you rarely use a single thing from a package (namespace), hence it makes more sense to import a package (namespace), 2. if you import a package (namespace) you don't need to include the package-name in the declarations, 3. this encourages packages related to core values (e.g. for web application "user", "page", "admin", "billing"), 4. core values are more stable than a particular implementation, 5. this means the purpose of the program is more visible from the code rather than hidden in accidental complexity. Basically the way packages work guide you to build better software and you get it more right from the first time. The way Go packages work have impacted my code writing more than any other language (and this includes Delphi, C, C++, D, Java, C#, Pascal, JavaScript, Prolog, Haskell, ASP, Lisp, Clojure, APL, Smalltalk ... and probably some that I forgot). The second best feature is that it [fits in your head](https://golang.org/ref/spec) -- i.e. the complexity of the language has never gotten in my way. This means that the language mostly disappears when you write code and you are left only with the problem on hand (obviously, not for all problems). Of course there are nice tooling, great packages, language feels syntactically light... basically what other have said. These features aren't exclusive, but you need to work to get them in other languages. For the first one, you would need to start to structure code in a way that may not be necessarily idiomatic in that language. In the second you need to pick some particular subset of a language.
&gt;And I now always consider Go before I type any Python. Pun intended? 
[removed]
thank you! i am currently reading your book! 
thank you! i am currently reading your book! 
yeah i did ! but its kind of messed up. It tells you what things make a web framework . but it doesnt tell how to put things together. thanks
This is true, but there's a per-interpreter overhead in startup and memory, along with a cPickle communication cost (and you'd better not have un-marshalable exceptions). You don't get particularly efficient resource usage with processes nor very elegant usage compared to goroutines. You'd be better off (at least in terms of the standard interpreter) using Python 3.5 and using asyncio, although imo, the syntax is ridiculous (I really wish they'd just made Stackless Python standard) and you probably have to use aiohttp rather than requests because of the "async" keyword. Also: http://goless.readthedocs.io/en/latest/ gets pretty close to Go using gevent or stackless
this might be but if you want to benchmark 2 languages against each other at least make either both parallel or serial and not this forced "look, parallel is faster " type of nonsense 
&gt; Doesn't it use gocode as well? No it doesn't. AFAIK everything is done inside the plugin (except debugging, which uses Delve).
I have not tried the go plugin for vim. Sounds like it could help. Thanks
Go bashing is always so prevalent on HN threads... Maybe they're onto something just by being the majority!
try using sublime text and GoSublime plugin. I've found with those two key tools i can get a lot done. it doesn't define the types but it does give you code suggestions, methods, parameter names and their types, and I'm sure a bunch of other stuff I can't remember. 
Would someone mind explaining the hype about echo to me?
What hype?
Well, there are a couple of examples in this thread. /u/TotalRogue wrote "LEGIT". /u/sh3rp wrote "Looking forward to trying this out. Thanks!"
I thought that HN thread was mostly positive. Anyway, /r/programming is where you want to be if you want to hear some people hate on Go at every opportunity.
Could you put a link to your driver in here, just would make it easier to find for folks coming from Google (like myself ;D)
Same way I feel about people demonstrating JS frameworks by building to-do lists.
That's pretty much what I meant by generally. unsafe is (surprise!) unsafe. cgo is C and thus unsafe. Compiler bugs... meh, I suppose - I'm not too worried about that. What I was actually thinking of was race conditions that let you do bad things with partially written memory. This is one of the few known potential problems in Go (aside from things easily avoided, like unsafe and cgo).
If you're taking web site feedback, grey with a grey background and grey shadow makes for seriously unreadable example program code. (You have some JavaScript which fixes it, but I don't run JavaScript on random web sites by default.)
That's exactly why the Go team are so wary of adding generics to Go. You might end up with horrifically complicated syntax like C++ and Java. Also, you might end up with accidentally turing-complete compilations, like C++ [and Java](https://arxiv.org/abs/1605.05274), meaning your compile times are [essentially unbounded](http://cpptruths.blogspot.com/2005/11/c-templates-are-turing-complete.html).
Except for the regex tests...
What package have you been using?
all the slides from previous years are on our github repo. Is there something missing?
This has been a side project for the past 2 years. You can read a bit more detail in this post: https://dkumor.com/blog/2016/06/07/connectordb/ 
The Go FAQ provides excuses for `regex-dna` and `pidigits` benchmarks: &gt; The slowest depend on libraries for which versions of comparable performance are not available in Go. For instance, pidigits.go depends on a multi-precision math package, and the C versions, unlike Go's, use GMP (which is written in optimized assembler). Benchmarks that depend on regular expressions (regex-dna.go, for instance) are essentially comparing Go's native regexp package to mature, highly optimized regular expression libraries like PCRE. [`binary-trees`](http://benchmarksgame.alioth.debian.org/u64q/performance.php?test=binarytrees), on the other hand...shame on Go. We're beaten by the likes of Erlang, Haskell, and Clojure.
regexp.
Go is my future. The gap between Go and the others will narrow, though it's currently plenty close for my uses. And my point is simply that Go's regex libraries will improve -- and narrow the gap.
You mention packages. I have never understood why C++ lacks proper support for packages. The conventional explanation is that "Inclusion guards work," but is this really an explanation? Maybe they do work, but they are just awkward -- awkward in a way other C++ features are not. Inclusion guards don't feel right -- and not only to me, but to lots of C++ programmers. A C++ header is a purely *textual* device, used for a largely *logical* purpose. It seems to me that C++ ought to do a little better than that. Nevertheless, I admit, inclusion guards do seem to work, so Go's improved packaging alone would not have sufficed to entice me to convert. Syntactical lightness is important. I have programmed C++ long enough that I can actually read it, but one empathizes with the programmer who has spent a year or two coding C++ and still usually cannot read code others have written. Thank you for your informative reply.
I think you mean this code snippet ... I hope I remember correctly: defer resp.Body.Close() defer func() { // read until the response is complete if _, err := io.Copy(ioutil.Discard, resp.Body); err != nil { panic(err) // find another better way to avoid this } }() 
Wow, that's gorgeous! What other instrumentation tools are there for Go?
Check out the "Supported Tracer Implementations" section of http://opentracing.io/integration/ :)
Check out the "Supported Tracer Implementations" section of http://opentracing.io/integration/ :)
Check out the "Supported Tracer Implementations" section of http://opentracing.io/integration/ :)
Wow, that's an interesting one. Thanks!
main-foo, routes, and database would all be seen as separate packages Packages are one level of files, its not that difficult and sometimes advisable to create subpackages in your main package. 
That's exactly the problem I'm stating. I don't want them to be separate packages. They may reference files within each other in a way that would create circular or two-way dependencies, quite aside from anything else, and they would require importing. I want one single package that just happens to have some of its files located in subfolders. Database.go and routes.go both start with 'package main' - that is, `go build` should look into the subdirectories, honour that instruction and not ask any questions or throw any errors.
Thanks. Will fix.
What exactly is this can somebody Eli5 to me?
Always wanted to try vim-go, but constantly run into issues during installation on Windows and give up. Is there a guide that walks someone who has little vim experience on how to install everything and make it look as on the screenshot?
Sure my driver can be found at github.com/dancannon/gorethink 
No, it's not possible (and yes, you don't want to do that).
You can't do that. directory == package, period. You can put the data files in a folder that starts with an underscore, and the go tool will ignore it.. but if you want two files to be in the same package they *must* be in the same directory. That's the way go works. You should embrace it. Doing it differently because you disagree with the way go works is just asking for heartache and pain.
Fair enough. That was the conclusion I was coming to. Thanks anyway.
I think this has too much custom logic to be considered a good usage. I've certainly never had the need to have fields versioned like that (nor do I see the point in all fairness). Also, this can be quickly done this https://github.com/dlsniper/anyhash to prove that you can have a hashing function for literally everything in Go and be fast at it. It doesn't mean it should be used or I want to diminish your effort but it just doesn't feel right, sorry.
After writing Bash, C, Java, Objective-C, some styles of assembly, some proprietary logic programming languages/interfaces, and seeing how network and database applications ideally solve many problems, and then deciding to make a game, I wrote an alpha game application in C++ by linking into the Ogre3D free and open source game engine. I wrote a bunch of CMake after getting through just building and linking Ogre, and then a local C++ chess-like application with the engine. Watching Rob Pike talk about build times and gofmt on youtube was enough for me. I'm currently working with Go for login/db/website/game logic (which can look very C-like) and calling into povray, which is a C++ command line application.
&gt; No more header files I miss them for sure, but not worth the compiler implementation leakage into the programmer's world. Specifically there's something neat about a well described "thing in a computer" contained in a text file that fits on a screen. I'm not comfortable here in Go yet as readable code uses different patterns than in header languages.
Hmm, you link to a project which credits the OP with the tests, which makes me think he's aware of this. :)
I've used the benchmark suite as I was lazy to do it myself. Since the license in the original package states I should give credits for the code, I've done so. What are you trying to say?
&gt; It works without an external process because under the hood, it is powered by ØMQ I hate to break it to you, but zeromq is an external process. I was kind of excited and it took me a couple of minutes to realize that this is just false advertising :(
Does it use UDP and/or TCP? Anyone have experience with it to share?
Rust is much better: fn max&lt;T&gt;(x: T, y: T) -&gt; T { if x &gt;= y { x } else { y } }
&gt; they do is not use generics, just like what has been done for decades in C. This is not true. People use ad-hoc generics in C *all the time*. They just eschew type safety and make a big ball of crap using `void *` and `union` Just like Go programmers do with throwing `interface{}` everywhere
Answer below by /u/aboukirev &gt;Besides router with subgroups and all echo has infrastructure for middleware, parameter parsing, cookies, template rendering integration, static files serving, content negotiation. An entire framework. If you want just a fast router/muxer, look for httprouter, lars, or lion. net/http is good if youre doing pretty simple web application. More complex ones that require session/cookies and middlewares, this will help you do less work since that stuff is built into framework whereas you'd have to code it yourself with net/http
Just extend logging interface to add full support for JSON logging. https://github.com/labstack/echo/blob/master/log/logger.go#L11
I've done my bit and answered the questions in the survey. It made me realised that I don't use many of the tools out there at all.
Neither do I. I write go code on a regular basis, but it's mostly playing around with what's possible rather than large projects.
Throwing `interface{}` everywhere is not idiomatic Go.
There are 11 talks from https://github.com/gophercon/2015-talks that don't have slides either.
Some random thoughts: 1. Go is very productive, close to the productivity of dynamic scripting languages. C++'s focused strength is certainly not in this regard. Also, I think compiler speed is one of the contributing factor of the productivity gap. 1. Compared with most scripting languages, Go is capable of taming the code complexity of large system gracefully. In other words, it's designed to scale over the size of the system, and the size of people working on it. 1. The *whole* system of a Go program is typically very penetrable. You can trace the code down to the bottom of the stdlib or even the compiler builtins in seconds with ease (thanks to the excellent Guru and vim-go). In my experiences of C++, I doubt how many C++ programmers have ever had a look to the implementation of STL or iostream, which is hard to do ergonomically. Although some people occasionally call the opaqueness *encapsulation* and see it a good practice (which I don agree). 1. As stated above, the difficulty of static analysis of C++ has something to do with its freedom and complexity, which would prevent such useful analysis tools like Guru from happening. The closet thing in C++ world I can think of still needs building indexes before hand, which can be very time consuming for large code base, and is not so accurate if the code does some tricky things. 1. The overall coding styles are much more unified and consistent in Go ecosystem, as there is no *that* much choices. In C++, every library, framework and even application could be like having their own DSL as the best possible abstraction. 1. Following the above, integration of many third-party libraries in C++ is no as easy as Go. Their build systems are very likely to be different (CMake, Ninja, Makefile, autoconf ... to name a few). Much effort has to be spent in those housekeeping works.
It might not be considered idiomatic, but it sure is *everywhere*. Even the standard library uses `interface{}` as a poor-man's generic in many places.
`net.Context` and `sync.Pool`, and the `json` package are the only places I remember using `interface{}`. I don't consider that "everywhere."
Except now I have to add a shitload of useless braces.
I had similar sentiments as you /u/IAmSlar but I actually do maintain a number of real-world go microservices. I'd argue that this is actually a good thing though. Almost all the tooling I need is built directly into the go tool (though I wish the ability to "save" and "update" dependencies--a la godep--was build directly into the go tool) and the std lib is so good that it enables us to keep our dependencies to an absolute minimum. When asked the question about "what could be added to the stdlib," I actually forgot to mention (just now thought of it), that the logging package could use a major overhaul... It's super crude right now... Something that has a featureset comparable to something like slf4j (or hell, even just log4j) would be really nice.
Ironically? coincidentally? intentionally? When I visit that repo I get: Server Error / Oops 500 Looks like something went wrong! We track these errors automatically, but if the problem persists feel free to contact us. In the meantime, try refreshing. 
Next year ;)
&gt; that I want to sort into subdirectories There is no "I want" in Go. 
Technically it is doable. Like it is technically possible to kneel down on broken glass. Doable but insane: Invoke the compiler directly, manually, not through the go tool.
Hooray, another person that wants the same feature as I.
Oooo. I can't believe this didn't show up when I was looking in to this a couple months ago. Thanks for the link.
I guess my main question would be how this interacts with logging.
I should have been more clear. Let me explain with a story (which I am very aware is a drastic oversimplification). Bob the Management Guy (EDIT: Typing while talking is a bad idea.) gets to choose between Go and C# for his company's development. Budget is no issue. Bob could have Visual Studio installed on every machine. Bob is now basically done. Nothing the users do to the machine in general will affect the development environment. Or, Bob could have Go installed, which includes setting up all the file structures, and all that good stuff. Yeah, he can use a set-up script to do all this. But that's okay. Assuming the users know what they're doing, everything will be fine. It would take some effort to mess up the system. Now, once Bob has chosen one of the dev environments, The Company starts hiring developers. Most of them are great devs, who have worked in &lt;whichever choice Bob made&gt;. But a few are newbies. They're fresh out of school, and have plenty of experience *programming* in &lt;whichever choice Bob made&gt;, but they aren't used to working in a collaborative environment yet. If Bob had chosen C# with Visual Studio, it'd very easy for those newbies to get set up, whether it be on Team Foundation Server or GitHub or even the corporate Git server. But if Bob chose Go, those newbies have to not only learn where the coffee machine is and how to Google "build problem Visual Studio". Now they have to understand how Go's build system works, specifically as it relates to working with other people on one project. They have to understand how Git works (which, as we all know, most schools don't really teach. Not that I blame them. Git is not exactly simple once you get past basic pushing and pulling). And, on top of that, they have to figure out how their dev environment, whether it be on vim, Atom, Emacs, whatever, fits in to the system as a whole. This is where an IDE shines. IDEs allow users to work in more or less the same environment, regardless of what customization they do to their systems. IDEs work the same even if they are configured to look differently. That's a much easier support story and, more importantly (in my opinion), makes it easier for coworkers to help each other with problems. And I know this isn't the best place to be singing Visual Studio's praises, but there's a reason it's used in so many dev environments. It may not be the best to some people (though I personally love it to death), but it is standardized and fairly well-documented. Which, in the end, is the upside to basically any popular IDE. All of that said, I don't think a big, Google-driven Go IDE is necessary for most Go development right now. Most people who are using Go are using it because they're passionate about it. But that might not always be the case. Go might one day be the new Java or C#, which, while maybe not loved, gets the job done no matter what you throw at it. It might be that thing that you just *have* to know if you get a job writing code. I'm not sure what that says about IDEs in general, but, hey, there ya go. I hope that was a bit more clear, since I'm not on my phone anymore. It's not about *my* experience with Go, it's about getting Go more into the mainstream, which is usually a good way to encourage more resources tossed at a language's development.
Good point. The figure shortcode is just an example (copied from the Go Hugo Docu) - showing that you can use more than just (simple) parameters in a shortcode e.g. if/else etc.
I'm in the same boat thankz 
What did you use to generate this profile?
You could turn each entry into a struct of the value and a Boolean which indicates whether it was filled in or not.
Sameer Ajmani's [recent talk](https://talks.golang.org/2016/applicative.slide#11) has a list of companies using Go in production. Check out the jobs/careers pages of their websites!
Would this compromise performance? Long story short: client had the system done with another company 4 years ago. Software was really slow because millions of scorings would be calculated daily. They failed to provide an old copy of the system and dont even know the language it was developed. I'm mostly webdev. PHP/Python/Js. I was already taking my first steps in Go and convinced my boss to let me give it a try because it would be really fast. Thanks!
Well, yes, but probably not as much as you'd get from just using a language without static types. There are some other tricks you can do if you know, e.g., that you're only using N bits of your number, but tmornini's suggestion was good. Another way to do it is to use *int or *float, but that could cause memory accesses (and other stuff) which is (probably) slower (still faster than PHP/Python/JS, though) than type Number struct {N int; Valid bool }
Client I work for has been using Hired.com
Great idea! It looks like golang is starting to creep, if not sprint, into enterprise.
If you're using it as an int field you can also default it as -1 (not submitted) and 0-10 for actual values.
Pointer to integer is an option. If you are using a network serialization like json you could deserialize into the old value strut and it would only override the values set. It all depends a LOT on architecture and without more detail it's hard to give you the best solution.
Try go internal package. It lets you have sub packages other people can't import
I believe that *int, *float is far better as the cost of marshaling an entire other 2 objects (the wrapper object + the valid bool) is probably so much slower As always, benchmark and see. But I'd be shocked if a memory dereference (looking up a pointer) is slower than parsing the extra text. Especially since you are doing this only a few million times a day.... that's not exactly a ton of events these days. You should be able to parse millions per minute unless your data is huge.
In which world do you live where Bob the DevOps Guy gets to choose the language *and* the development environment? Bob's job is to deploy, not to create. If I handed Bob a statically compiled Go binary and Bob said, "This needs to be C#" then Bob would be looking for a new job.
Are you using this in production ? 
It will be something like this: status ├─ role: master ├─ total: 0 └─ upstream ├─ total: 2 │ ├─ success: 1 (50.00%) │ ├─ error: 1 (50.00%) │ └─ slaves ├─ asgard:40854 │ ├─ role: slave │ │ │ ├─ total: 1 │ │ │ └─ mirrors │ └─ pool/x │ ├─ state: success │ └─ modify date: 1464168153 └─ asgard:30225 ├─ role: slave │ ├─ total: 0 │ └─ error └─ Get http://asgard:30225/x/status?format=json : dial tcp 127.0.0.1:30225: getsockopt: connection refused
I'm just being a pedantic pooper. I get your point and I think it's somewhat valid. I just think Go's tooling is better than most languages.
Ugh I fight with that every day. It's like... you write code all day but you're telling me that a command line is too confusing? FFS the product you're building has a CLI on the debug port, that you wrote.
slow.
The algorithm is really simple. I got ~100 fields form going to mysql (5 normalized tables). All of them are either INTEGER(11) or DOUBLE(15,2). The algorithm itself if basically 100 conditions. if field1 &gt; 1,3 { score += 12 } else { score -= 3 } 
I created a profile archive, and ran it on pprof, based on this guide: https://blog.golang.org/profiling-go-programs Here's the source code if you need more details. Thanks. https://github.com/dlaynes/goog-sim 
We at wercker are always looking for talented go engineers http://wercker.com/careers/
Ohhh... So if you assume I didn't realize you're the author of dlsniper/anyhash then my comment makes sense. I thought cnf contributed to dlsniper's anyhash and "you" didn't realize cnf knew about anyhash. Except you are dlsniper. So... yeah... sorry for the confusion. :) I understand now that I've taken a closer look.
Define *talented*
How is the form data getting into your application? If http post you could look for specific keys existing (and use string parsing as someone above suggested) If its JSON see my previous suggestion. If the data is being injected into mysql first and then the Go application is reading out of mysql you will have to figure out how the mysql library pulls data out to figure out that answer but I bet it would be similar to JSON.
Neat project! Can you share what you use it for/what problem it solves?
*int is a pointer to an int. If the pointer is nil, nothing was entered. If the pointer is valid, but the int is 0, a 0 was entered. Go's type system is quite simple and so this is often the best option.
Been wondering this exact thing. Been looking/applying since last July. Not to many companies want to take a chance on a first timer who's only been a hobbyist programmer for 10+ years while doing IT as a day job. Would love to transition to software development. Good luck to you friend.
I like it's output, but I think that itself could be implemented atop https://godoc.org/github.com/pkg/errors . The implementation would have some unfortunate properties though -- you'd need to call a nested errors `Error` method to know where to split the error message at... However `github.com/pkg/errors` could be made to accomodate the feature better by implementing an interface like type ErrorPrefix interface { ErrorPrefix() string } if this was widely-enough requested. So I wouldn't recommend people to use this package _unless they had good reason for why I described above won't work well enough for them_. The core idea is still very nice though. :)
Godoc just parses the code, it doesn't compile it, so it's basically instant. I often just leave an instance of the godoc web server running on my machine and then I can see the godoc of any code in my GOPATH instantly and with hyperlinks to types etc. 
The application itself is in php. Only the scoring will be in golang. Im still deciding if its going to interact directly with the db or if it will be a json service, in which case will probably be json rpc.
if you can, attend golang meetups in your area. they're usually sponsored by companies looking to hire
I suspect it would, but it's shocking difficult to guess these days, but performance is essentially always secondary to readability and correctness. I like using a pointer and checking for null, but dereferencing *may* be slower than the extra payload. And, how fast does it need to be? Depending on what you're doing it's not hard to imagine hitting external bottlenecks before low-level data handing is an issue.
Perhaps. Dereferencing is not free...
No, the pointer costs two words in the common case (valid pointer + valid int) and one word in the special case (nil pointer). Bool plus int is always two words. But! The pointer causes memory fragmentation which means it's much slower and more memory wasting than the boolean once you look at the big picture. 
&gt; Still, I would love to see an IntelliJ or Visual Studio for Go. Hmm, maybe you are not aware of the *excellent* [Go plugin for Intellij](https://github.com/go-lang-plugin-org/go-lang-idea-plugin)?
If you're sending data to/from MySQL and your scoring algorithm isn't obscenely complex, it's a safe bet that the database interface will be your bottleneck.
Cool, thanks for explaining! 
The built-in templating seems to be efficient as well.
fewer
Np. :) 
Great tool!
I would expect better performance from bool + int based on predictable memory paging to the cache and branch prediction, but that's getting down to data-oriented design - probably not remotely necessary here.
Me too :(
If you follow this advice, make sure you do it in the other order: find another job, then resign..
When making updates, why not port it to Go and have the Python code call over the network? Eventually you'll have it all in Go
Is there a n implementation of option 9 for plan9 ?
You declared no "handleConnection" function. So it's undefined.
how to declare it (sorry im new to go)
thank you :)
I agree it's easier to read the example output from the README than it is how error messages are printed out normally. But that can be implemented without all your machinery, on top of an existing high-quality package. And that's just a single function. If that'd be all I needed I'd just write a function to do it, instead of introducing an undue dependency. I can imagine _some_ use cases for your extended "tree of errors" functionality, and I can see how that involves more machinery. I don't think it's something I'd use often though, and I'm unsure this would play nicely when introduced into a code base already using `github.com/pkg/errors` or a similar package. I have a hunch this could be modified to integrate with `github.com/pkg/errors` nicely, but I'm not sure what the best design for that would be.
I've been having real trouble finding Golang jobs in north UK for what it's worth. You don't say how long you've been at this company. 6-8 months is hardly a lifetime, so I would try and consistently find problems with the Python that you can fix easily with Go. That shouldn't be hard. If after a year or two there's no movement, then I'd jump ship, but I believe in commitment.
Someone posted a package or plug-in recently that automatically adds or removes import statements as needed. I need to find it for myself.
Short of leaving the job, and explaining that this wasn't what was agreed at hiring, sneaking in Go may be the best solution. I honestly don't know what OP is looking for, there aren't no magic words that will somehow make Python go away. I know a few people that was hired to work on the new shiny for a software company and instead found themselves working on legacy C++ and Delphi applications, rather than the Java platform they where promised. They all quit within 6 months, and that's pretty much the only solution. 
Really? You do realize that at the end of the day all programs equate to being an instruction set that performs operations on a machine... I'm not sure if your computer cares what language you are using.
This does not seem to be a question related to golang. Stop asking for career advices here.
&gt; The fact that you asking this question in golang specific forum is just yelling from soapbox back to people that already share your point of you. That's not exactly true, because I share your POV and not the OP's :-p +1 to everything you said.
What does it do? It's rewrite in Go a possibility? 
I like the sound of this.
Agree. I'd put it in a more simplistic way, like my no non-sense mom would say it, which I use it as a battle cry when I have to do dirty jobs like systems: migrations, upgrades, refactorings, retrofits. "you are a computer engineer, right?...isn't that a computer?...soo?" 
This is normal for software developers. The language is just a tool, not the career track.
Great feedback. Next year!
Very nice tutorial!!! Can you use GoDog with TravisCI as well and how would that work? 
Which ones?
Companies put new programming languages into job descriptions to get skilled people. During the interview you have to check the current architecture and just ask if you will be able to develop in go. 
Sounds familiar
unless you think the company is purposefully duplicitous, i would give them the benefit of the doubt. if they are good people, they will recognize that you pitched in even when it wasn't a tool you intended to use. "greenfield" Go projects are still rare and may remain so for a little while longer. the massive body of legacy code out there is just the reality for anyone running a business
i don't think anyone should portray themselves as a "$LANGAUGE" developer. rather, portray yourself as a distributed systems developer, a networked service developer, etc...don't hem yourself in to one tool, you never know when it might go out of style or your interests might shift but most importantly, don't preclude yourself from the interest of awesome companies that may introduce you to things you haven't ever touched. join a company, not a technology
 +1 to this. "golang engineer" isn't really a thing.
&gt; "greenfield" Go projects are still rare Not as rare as legacy Go projects. ;)
the first bit of the title of this page is: "AskGolang: Joined a company as a Golang engineer" what about that can't you figure out? seems pretty obvious from that it the submitter considers themselves to be a "Golang engineer" 
You know, Python ain't all that bad. You have to look at the other aspects of your job: Am I learning new stuff? Am I building something cool? Am I working with good people? Am I writing something other than Cobol? You can always write Go off hours. If you're still not happy, start the job search. Nobody says you have to stay there, but you can certainly take advantage of the opportunities available until you find a better alternative.
"Before the `vendor/` directory how did you manage your dependencies? " - I didn't write Go before the vendor directory.
Wordpress and the others can cache a page for you without having to hit the database (except on the first hit). If you can setup and deploy Hugo you can optimize a platfform like Wordpress. A $5/mo hosted site can and has served tens of thousands of pages with caching configured properly. The speed of Hugo becomes a wash when pages are deployed. With that said, I prefer static site generators because I'm a coder and prefer version control. I don't recommend generator to friends because I don't want to be their customer support.
Best comment in the thread 
I do the same thing, except, a long time ago I tried using a "Dependencies" struct that holds ALL dependencies for the handlers and passing that in. This was because Context's aren't statically typed... To test I just create a new Dependencies struct and pass it in to the handlers. You could pass this Dependencies struct in through the context if you want, I'm just suggesting against having loads of different context values for each dependency because they are references by a string which makes it very easy to make weird subtle bugs.
Interesting. The program to which I am contributing -- which is the reason I am learning Go -- does indeed use interface{}. Lacking experience with other Go programs, I had assumed that interface{} were idiomatic, because it appears in the program. On your advice, I'll take a second look at that. 
Your thoughtful reply is appreciated. I think that I understand most of it, except maybe point 2. In what way does Go scale well? Or would I not understand? The longest C++ program I have ever written (or even contributed extensively to) is less than 30,000 lines. The Go program to which I am now contributing is also less than 30,000 lines, so I don't really have experience with large programs. 
You have made an excellent, most informative reply, thanks. You write, "I don't particularly care for C++, though I've worked with it daily for the past 8 years. I don't believe that to be coincidental." So, I am a not a professional programmer but a building-construction engineer (electrical discipline) who happens to program a lot: PLCs; embedded systems; etc. This mindset means that I have never cared for Java (don't mind if other people like it, but it's not for me). It's also probably why I like C++. (I also like Perl, if that's relevant; but Perl has very different use cases than C++.) For my information, to help me interpret your excellent reply: Are you coming from anything like a similar perspective? Or is a language like Java something you tend to appreciate? 
btw it's idiomatic to use pointer receivers for types that implement the error interface
Yes. Me too. The way I see it, if that's the only speed bottleneck in my code then I'm probably using the wrong language.
Are you being sarcastic? 
Using Built-in Libraries in Python 2.7: https://cloud.google.com/appengine/docs/python/tools/using-libraries-python-27
http://memcached.org/
Now I've just run into the new environments. The flexible sounds great and all but I can't see a reason to worry about the server files and any other things, so I'm going with Standard for that reason alone. Mostly because I have no need for Flexible. All I need are memcached html pages. Check it out: https://cloud.google.com/appengine/docs
For whatever reason you're implying, that `pkg/errors` + yours on-top implementation will be high-quality solution while `hierr` by itself is not. However, `hierr`, it's fully documented, pass all `gometalinter` checks and covered by unit tests, so I fail see how it's not high-quality software. Moreover, `hierr` is completely transparent, because it's passed around like `error` and do not need any typecasts made in the code to access custom interface functions. It's out of the box ready solution for making error reporting much more better without any additional code.
No. Why did you think so?
Looks great. Nice and clean and clear. It is kind of strange to have the getHandler function which returns the handler but I can see that being quite handy if you want to extend to other types of served content. Great work!
Well for one, `main.go` imports `io.mhlg/fortunes/fortunereader` which is not go gettable. It should technically be importing `github.com/mhaligowski/fortunes-server/src/io.mhlg/fortunes/fortunereader`although the whole folder structure should really be revamped to something more succinct imo. Making the project go gettable would be nice since it would allow for easy continuous integration via Travis CI or something similar. Also, `main.go` defines its own type `handler` when it really should be using the `http.HandlerFunc` type. I also think the `getHandler` function is a bit unconventional although not wrong by any means. It's definitely has benefits in that it ensures that `fortunes` has been set before the returned function can be called, I just don't often see Go code written like this in larger projects as it's not usually expandable or flexible enough, so take that as you will. Edit: I'm also not sure why you're splitting fortunes by `"%\n"` instead of just `"\n"`. It would probably be nice to include an example fortunes file in the repository or some sort of documentation about how they're structured in the README. Also, it doesn't seem like there's any point to `result` in `parseFortunes` since it's never used. Finally, you should also really get in the habit of explicitly handling errors in Go instead of just ignoring them and crashing as you are in `ReadFortunes` when reading from a file that won't necessarily exist and in `main` when you don't check that an argument is actually given to the program. 
Since every method in a web app requires access to the db, are you suggesting one app struct with all the handlers on it?
I would be thinking about one level of abstraction to prevent this and have a cleaner separation. Handlers (unless very simple) should be concerned with - Parse &amp; validate request - Call a service layer which does your useful domain logic and maybe returns some kind of model - If the model is simple respond with it, otherwise delegate to some kind of view model templating thing This ensures your handlers keep their areas of concern simple and makes it easy to test. It also means testing your "service" layer (i.e your important domain stuff) doesn't have to worry about HTTP anymore.
"Complicated structs" ? I cant say I agree with your approach. If you have to make complicated structs then you are probably not structuring your code very well, perhaps your handlers are having to do too much. &gt; So I can pass anything to my handler functions This is not a *good* thing. By using reflection you are throwing away type safety. Why use Go if you dont want the compiler to help you?
parseFortunes should work on an io.Reader, and use bufio.Scanner to split by lines. And of course handle errors -use github.com/kisielk/errcheck to see what you miss. About package naming: if the main usage is the binary, then put main.go at the root, and the parser in a subdirectory; otherwise let the root be your parser package, and put main under cmd/fortunes-server.
Look at this project. I've passing dependencies through context (env in this project): https://github.com/deployithq/deployit Here you can read great article about what you want: http://elithrar.github.io/article/http-handler-error-handling-revisited/ It is about errors, but you can see pattern for passing dependencies to handlers. You can also read this: http://elithrar.github.io/article/custom-handlers-avoiding-globals/
https://golang.org/pkg/text/template/ ?
You may also want to move the xml spec into a separate package `tmx`, then your types will look like `tmx.ImageLayer`, `tmx.Object` etc. But yeah, `text/template`.
imho 1) there's a bug in parseFortunes, you're trimming \n in result[] but you return the other slice 2) another bug in parseFortunes - when input is empty your code will panic due to negative index 3) directory structure - I find this subjectively better: github.com/mhaligowski/fortunes/fortunes.go github.com/mhaligowski/fortunes/fortunes_test.go github.com/mhaligowski/fortunes/cmd/fortunesd/main.go 4) variable names inside unexported method should be short 5) avoid uneccessary allocations 6) typically parse* functions operate on []byte not string, due to the fact the input typically comes from (http.Response).Body or (os.File).Ready and the value is []byte - using string in your api would require conversion to string and unnecessary allocation 7) if you have a lot o fortunes you could consider having parseFromReader(r io.Reader); I know it's not needed now, but in general you'd want to do that in your real-world server code e.g. instead of splitValues := strings.Split(input, "%\n") if splitValues[len(splitValues)-1] == "" { splitValues = splitValues[:len(splitValues)-1] } result := make([]string, len(splitValues)) for i, v := range splitValues { result[i] = strings.TrimPrefix(v, "\n") } return splitValues it could be: s := strings.Split(strings.TrimSpace(input), "%\n") for i := range s { s[i] = strings.TrimSpace(s[i]) } return s To be honest this logic is weird to me - the delimeter is suspicious (%\n - why not something simple - csv?), and each value can have also a dangling \n? I'd say it's a bug and data structure should be fixed (or document/comment that it comes from external source and it must be convoluted like this). PS. I'm not sure what's the reason (are we all trying to be nice and not criticize?), but I'm not sure why there're comments saying the project is flawless. In my opinion so many little things in so small project makes it in my opinion not a good Go code.
I would actually be very interested in a small account of code if you have anything you could throw in a gist! This sounds interesting
I think you should run golint before publishing your article. All the examples are wrong. Also I'd add empty lines around code snippets and increase indentation (stdlib uses 3 spaces instead of 2) to make them more readable, so instead of: // This is how to create a Hello World: // fmt.Printf("Hello, World") // Or: // fmt.Printf("Hello, " + name) I'd write: // This is how to create a Hello World: // // fmt.Printf("Hello, World") // // Or: // // fmt.Printf("Hello, " + name) // 
I meant by "passing anything in" your dependencies to your handlers. You mentioned you used DI to handle dependencies with reflection. Not talking about unmarshalling data
There is a big difference between casting arbitrary data into datatypes and using the type system to your advantage when structuring your application. Seriously though, why use Go if you are so unfond of types. Just use a dynamic language and it would be more convenient. 
Awesome, thank you. Are there any other tutorials like this one covering neural networks/AI/ML? I want to learn more about this stuff, and Go is a great language to dive into it with.
Thanks, I'm glad to hear that!
I said "state they need". That might not be `type App struct { DB *sql.DB }`, that's just a quick example. If you can make things more modular without drowning in abstractions, do it. For example, `http.Client` contains the state it needs to make outgoing requests (`Transport`). Same thing.
link?
It seems I am not good at reddit too :)
haha all good mate, thank you for updating it. 
Nice blog post. For Consul 0.6.x, if you pass in QueryOptions{Near: "_agent"} when you query for a service, it will return the nodes in ascending order of estimated network latency (closest nodes first).
&gt;1) there's a bug in parseFortunes, you're trimming \n in result[] but you return the other slice hm, how would i cover that in test? &gt;2) another bug in parseFortunes - when input is empty your code will panic due to negative index I tried putting "" in test, it just returns empty array, which is the expected behavior 3) what do I usually put in cmd? 7) I tried using io.Reader, but got super confused. Do you read the whole string and do the split (like in your example)? Or you use SplitFunc from bufio package (I tried that but had problem when allocating the array). Regarding the format, it's a standard fortune files format: http://software.clapper.org/fortune/ Thanks for your comments!
Thanks for your response? I was pretty sure that with using the closure I am doing exactly that? (I realized I could probably use struct for that, anyway) 
Yeah, you had it - or at least, enough of it to put me on the right path. When my Head gets upgraded to https, I'm getting a location header back of: Location: https://github.com But it looks like `net/http` is retaining the manually defined port - 80 - and so it's sending an HTTPS request there. [edit] I removed some stuff that just seems confusing here and not helpful [/edit]
Sorry, I misread. Yes, you are using a closure, so you'll only pay the initialization cost once. I still think you'd be better off performing the initialization and error checking before proceeding with having the server listen. No point in having the server answering requests if they are always an error condition (such as file didn't exist or contained no fortunes). 
I love this, thanks! It has come a long way since errgo.v1, but distilled into a nice, small and usable API. The only head-scratching is about replacing errgo.NoteMask with its two errors. Now I keep only the cause, as that's needed more, but I'm open to other suggestions.
I've thought about minimal TCP stack at the beginning. But **it can not be done without raw socket which needs higher permission(usually root)**. While I don't see any problem with the current implementation, could you please point out? Also, application-level health checking will not need this.
&gt; Or you use SplitFunc from bufio package yes, you may want to write your own SplitFunc; I have never dealt with fortune format, but you may also want to handle windows line ending (\r\n instead of \n); it'd be good to put that link in the parse function comment, so it explains what we're trying to parse here &gt; I tried putting "" in test, it just returns empty array, which is the expected behavior https://play.golang.org/p/Z7vSKSLxeH - my bad, I assumed the result from it would be empty slice without looking it up, and it returns always a slice with 1 empty element &gt; what do I usually put in cmd? typically you structure your go project as a package, with public API that anyone can use; in cmd you write command line client to your package &gt; how would i cover that in test? you find a test-case that shows the problem, if there's no problem, then it's dead code and you can remove it
Forgive my lack of knowledge of Go, but I still fail to see how this is different from interfaces in any other language. Isn't refactoring out the common code (validation, in the database example) just common sense? (I'm still at the stage where I dislike the lack of generics.)
.
&gt; You shouldn't care what types are underlying the interfaces. Why? Why is a purely behavioral type definition inherently superior than the algebraic sum of different types? I agree, that purely behavioral interfaces (like `io.Reader`) are very useful and you shouldn't care about their runtime type in general, but they are useful in completely different situations than sum types. The different cases of a sum type can't usually be expressed cleanly as a (behavioral) interface, because they don't exhibit common behavior and you don't use them purely for their behavior. This isn't meant to fit use cases where a purely behavioral type definition is useful. i.e. interfaces are not used in their original intention, but only to use the existing concepts of the language to approximate a completely different concept. So, why is this, completely different concept inherently not useful or shouldn't be used in your opinion?
That's somewhat hacky. And preventing reimplementations of interfaces breaks the purpose of interfaces.
&gt; As for the generics.. why? I am genuinely curious about a scenario where I would miss them. I've had some situations where I'd want them (granted, it was because of weird design specs since we were porting a broken C# application), like when we had a server that received database queries, packaged the result in custom types, and sent them back over RPC to the queryee. Of course, the server had no idea what the queries looked like, so just stuffed the results into a type as best as it could. I managed to solve it using runtime reflection, but it wasn't pretty.
Container types are where I really feel the lack of generics... In most other cases I don't feel like I need them, but it would be really nice to have typed LLRBs and others. The major difference with interfaces themselves is that they're implicit and that you don't have to use inheritance (or even import the interface, usually) to get polymorphism. I really love Go's interfaces when I can create a map type (or other basic type), and then give it a type name and give it methods so that it can work as a perfectly valid stub implementation for testing. That's a point where I know that I've created a small and functional definition of what my code needs that's easy to provide an alternative implementation for.
&gt; That's somewhat hacky. I disagree. The complete pattern, yes, probably. The addition to an existing and established pattern, no, I don't think *that's* hacky. &gt; And preventing reimplementations of interfaces breaks the purpose of interfaces. True, but see [my other comment](https://www.reddit.com/r/golang/comments/4npz6y/preventing_reimplementation_of_interfaces_or/d45z9ky), this isn't meant for the cases where the purpose of interfaces is fitting, this is using interfaces as a bodge, to fulfill a different usecase. You can think about it this way: When people have proposed sum types in the past, they where declined (and I completely agree), on the ground that a) yes, they are useful, but b) their usefulness doesn't outweigh the cost of complicating the language, especially given c) they can be approximated by interfaces. I agree with all three of those. But what's wrong with, given we agree that they *are* useful but they should not be added to the language, to approximate them as good as possible with the facilities we *do* have? 
Hah, it is a fun joke that initially flew over my head too (I didn't come up with the name). The library is for "push" notifications, and named after "Buford Van Stomm", a bully character in a children's cartoon.
That seems needlessly dismissive. I really like Go, but there are some problems for which it is just not well suited. Go's small feature set has enormous benefit in certain situations but is a hindrance in others. As much as I'd love to use it for most everything, I've started rewriting some projects in Pony. I think the two are very complementary in many ways.
Another good way to get work experience is to freelance on remote golang jobs on platforms like upwork. In the beginning it's really hard (you might send out 50 proposals and only get one reply), but after you have earned a few hundred dollars, people are starting to approach you for work.
I don't think I ever really miss using generics directly. As Brian Will says in his YouTube videos, "It's really hard to write really good truly generic code." However, what I miss from C# is the stuff made possible because of generics. Mostly that's all the stuff in linq. I could still implement Where(), First(), FirstOrDefault(), Exists(), OrderBy() etc using the same type of parameter (a lambda), but I'd need to write the implementation for my slice of employees, my slice of customers, etc. Not everyone has written C#, but the names tend to indicate the general utility of those methods which take something implementing IEnumerable of a generic type and return the new IEnumerable of that type after evaluating each member with the lambda. You just can't have it both ways. You can't have the straight-forward simplicity of Go (both in readability and in slim overhead) and the types of built in capabilities you have over collections in other languages. You can shim this if you're willing to automate the Go implementation with code generation, but I'm uncomfortable with the added dependency and plan on implementing what I need. I'm new to Go though, and I don't have much requisite experience to make expert statements on language design, so there could still be another way to go about this, and I might be missing an existing alternative.
I cannot follow your reasoning, but I might overlook something. In `train()`, `expected` is either 0 or 1, and so is `actual`. Hence `expected-actual` is either of 1-1, 1-0, 0-1, or 0-0. So `delta`--the result--can become 1, 0, or -1. Correct?
How did you retrieve the raw content? I'm more curious for future debugging stuff.
Hey folks. I couldn't find a good enough comprehensive tutorial do to Google Sign-In, so... I wrote one. It's pretty basic, nothing fancy, I just wanted to put everything into one place. I hope this helps someone. :) Cheers. Shees, I'll fix the typoes tomorrow. :-)) 
Ah yes, I for some reason read `expected-actual` as a variable name and not an expression and assumed it was the direct output `isAboveLine`.
When I was figuring out how to do this for the first time I went off of [gplus-quickstart-go](https://github.com/googleplus/gplus-quickstart-go), but now I usually end up just using [goth](https://github.com/markbates/goth) since it's so darn simple.
It's more &gt; if you're trying to turn Go into [ruby | haskell | rust | javascript] then just fuck off and use [ruby | haskell | rust | javascript] Go isn't perfect, but it knows what it is.
The core API works with the Node/Elem interfaces defined in the tree package. xmltree is a default implementation for those interfaces. xmltree was meant to be lightweight and non-volatile. You can change the structure like you would with Java's DOM, but you're on your own. With that said, it's quite possible to create a tree that's more like Java's DOM that's designed to be altered in-memory. EDIT: Off the top of my head, the two things that will be affected when adding or removing nodes from the tree is the node positions and namespaces. If that doesn't matter to you, you can probably add or remove nodes without too many repercussions.
I'm sorry it came off that way. I was on my phone and not able to respond in full. I was pretty careful not to use profanity. I can talk more about it now, and will do so in response to the original poster. In my experience in the go community, which I've been a part of for almost 4 years, there are a couple people who are rude, and I wish they were not so vocal in the community. However, the vast majority of the people in the community are articulate, polite, and totally accepting of everyone. No one's perfect 100% of the time, but I really think in general the community is pretty good. I do find that an inordinate number of people who are new to the language tend to discard the voices of people experienced in the language. I'm not sure why that is.
I'm not sure what you mean by "All the examples are wrong." If that were the case I would not have been able to take the generated screenshots which I use in the article. I understand you have a preference for how you'd like your documentation to look, but it's not a requirement to *how* it works. The canonical Go style is a single tab, it is not 2 or 3 spaces.
I think this the content of this slide presentation is world-class: https://talks.golang.org/2016/applicative.slide#1 However I hate these presentation web pages because they aren't mobile device friendly. I would prefer the content to be in pdf or plain old html with hyperlinks. Call me a luddite ;) One other thing: the hardest part to crack my head against in this talk was the variadic function with the ellipsis operator found here: func First(replicas ...SearchFunc) SearchFunc { for i := range replicas { go blah(i) } return Result{} } } It made me backtrack here: func FakeSearch(kind, title, url string) SearchFunc { return func(query string) Result { } } Then another backtrack here: type SearchFunc func(query string) Result WOW! So powerful, but there are few different concepts applied to make it happen. 1)nothing new here but the type definition with a name "SearchFunc" was made which defined itself as a function type with one string input parameter and the named "Result" type return parameter. 2)I was startled/stunned/fascinated with the type definition to make the entire "SearchFunc" function fit as a return type within the FakeSearch function within golang. It's nothing new in c++ templates, but I never saw anything similar to generics/templates behaviour within golang before. This is coming very close to that. This example is sophisticated, but simple enough to understand to convey and encourage others to use/create similar patterns. 3)Then finally another function that uses the SearchFunc type as a return type again, but this time it also uses a variadic ellipsis passing the same SearchFunc as the input type. WOW! An array of functions returning "Return" type which is essentially are arrays of stuff, but then returning an array of the combining results coming from all the functions started and completed in parallel on replicas if the first server was too slow that were passed in. !!! WOW!!! SO AWESOMELY POWERFUL and so few lines of code! Most elegant! Hats off to Sameer Ajmani and the golang team for making the golang the coolest programming language on the planet! 
Nice touch. You saved time for all those curious to try this example. Thank you. 
I have to say that one of the things I liked about this lib was(is) consistency. Consistent use of .Wrap makes it easier for me to feel comfortable about. The guidance to just pass errors up without context, except when ... makes the lib harder to use. IMO
A few days ago I ran into EXACTLY the same problem. Now I know why. Thanks for sharing.
just use tcpdump.
I have a github repo that looks to achieve the above with all platforms. https://github.com/duckbunny Adding a config loader next, for loading configs from multiple platforms.
That's too bad - but makes sense. I know you can use tcpdump for unencrypted stuff, and tcpdump + a self signed SSL install in your own trust chain to capture encrypted traffic - or similar. That's bulkier than I wanted tho. I was hoping there was a hidden debug setting or something in net/http that I just hadn't found yet.
Aren't you using Google+ though? I only skimmed through your tutorial, but it seemed like the user info you were getting back had Google+ related information in it about the user's photo and profile url. I'm pretty sure all Google OAuth2 logins are Google+ logins.
Reflection is slow. Reflection hides type containts from end developer. Reflection requires extra care. And reflection requires additional documentation. In general there is three problems with reflection. First - in Go it's really slow if you use it in hot paths. Not only because of type casting but because every interface value have to go in heap, those making additional work for GC. Go have many options for struct and primitives (and even slices) to stay on stack - increasing your thouput. Purposely neglecting it requires serious reasoning. Second is the fact that reflection requires extra code care. We have type system for a reason - it allows us to catch implementation errors and type containts violations during compilation stage, and not in runtime. When you use reflection you effectively say "I'm going to bypass type system, but I know what I'm doing". The question is - are you really? Third is that code with reflection is hard to read. Every cast, every check, every runtime generation is additional "understanding point" to anyone who reads your code. So when that person see it, the question "why?" is certainly going to be there. If you can prove that you need it because it allows, for example, more generic handling of structs and filling them (json marshaling comes in mind), that that's ok and cool. But you have to prove it. Because reflection is a trick. Think about those point every time you use reflection. If you can justify all of them, then by a means go and do it. But if there is another way - maybe you should consider it?
I was debating on that. I'm actually not sure. I'm just looking into it now. You might be right. The only difference I can gather is the user info URL. I'm using this : https://www.googleapis.com/oauth2/v3/userinfo. Where as you are using this: https://www.googleapis.com/auth/plus.login. Which is plus.login. But meh. Still, might be the same thing. :)
Agree - working with collections is somewhat tedious and boring after you got used to fluent api. But as time goes by, I'm starting to consider that the reason that we don't have an intersection or difference method is that we can implement them using channels. Then your control flow is suddenly changing and can be easily made goroutine safe and more lazy like. But then - you don't always need this - sometimes you just need to have results right now and channel overhead is unnecessary. Having both implementations in std at once would be tricky, and having just one is bad.
&gt; Go doesn't have sum types. In general, it doesn't need them. I can not repeat often enough, that I completely agree with this :) But I also repeat that I think a major reason for that is, that it can already approximate them closely enough to be sufficient in the cases where they're useful. &gt; This is not always intuitive when a solution has already presented itself, even if that solution is hard to fit into Go's semantics. Let's say I consider it true that there is always a way around the sum-typey-solution to a problem. That still doesn't necessarily mean that it's *inherently better*. go is a pragmatist's language, I'm a pragmatist and I don't see why I would need to, if I already have a perfectly working and easy to understand solution in the way of pseudo-sum-types, why I should need to "turn it inside out" to make it a non-sum-typey solution, which might be less obvious and thus also harder to understand. &gt; […] I would guess that there are different ways to approach the problem that don't require quite as many gymnastics in the code. I'd be happy to talk about any particular cases you have encountered. So, let's talk [go/ast](http://godoc.org/go/ast). I would be interested if you are able to come up with a design of that package that doesn't require pseudo-sum-types (what that package does is pretty much what I describe, it just skips the very simple additional step to work with embedding). But even if you do, I'd claim that sum types are an established solution to this problem and I would be *very* impressed if you'd come up with a solution that doesn't include them and not feel completely foreign and hard to understand. And I don't see anything wrong with using the well-understood and obvious way to represent an AST, even if that means you need to work around the limitations of the language.
You can check out mine, it's STD lib only: https://jacobmartins.com/2016/02/29/getting-started-with-oauth2-in-go/
Ah okay. That makes sense. Thanks for the clear-up!. :)
The fact you can take screenshot of generated doc does not mean your comments are valid Go comments. I'm aware of a few rules for them: - function/method comments should begin with the function name - package comments should begin with "Package &lt;package name&gt;" From https://blog.golang.org/godoc-documenting-go-code. If you have ran golint over your Go code it would give you warnings. I was not talking about canonical Go style, but about indenting code snippets within a comment. After taking closer look at stdlib there're either 3 or 4 spaces used, e.g.: https://github.com/golang/go/blob/master/src/sync/cond.go#L37-L52 https://github.com/golang/go/blob/master/src/net/http/filetransport.go#L17-L29 I did not find any comment with code snippet in it that was formatted as yours.
I don't really get the point, why would you bother? I'd just add a comment to the interface saying: `// do not add implementations.` and `panic()` in the type-switch.
To add some detail in my use case I am using XML as a template so rather than creating whole XML from scratch I would just search paths of relevant element/attribute using Xpath and replacing them using Java Xpath API in a pre-existing xml file by reading it in memory. So far I have not found a straight forward way to do that in Go. 
I'm seen a similar (maybe not) issue and solution in sqlx. http://jmoiron.github.io/sqlx/#advancedScanning Nothing wrong with asking the user to resolve possible ambiguities. With struct tags maybe?
anonymous structs seem like one of those things the language allows that i have zero interest in ever using...if a type is useful enough to create in a Go program, its probably worth it to have both a type declaration and an accompanying "NewFoo() *Foo" constructor.
&gt; I don't think I ever really miss using generics directly look for any place you have a parameter of `interface {}`
Using the string "usd" as the value of Currency. It works if I say that Currency needs to be a stripe.Currency instead of interface{}, but since stripe.Currency is a string, why can't it be type-asserted to stripe.Currency? testAcct := stripe.NewStripe(keys) testChargeObj := &amp;chargeable.ChargeObject{ Amount: 1000, Desc: "Test Charge card ID card_&lt;id&gt;", Currency: "usd", Source: "tok_&lt;tok&gt;", } testCharge(testAcct, testChargeObj) func testCharge(c chargeable.Chargeable, charge *chargeable.ChargeObject) { res, err := c.Charge(charge) if err != nil { c.HandleErr(err) } fmt.Print(string(res)) }
&gt; So Currency needs to be flexible on type. What if you make your Currency a string and convert to and from other currency types on the fly? I guess there will not be many different ways of expressing a currency, and none that could not easily be converted to and from a string value. This way you would save yourself from having to mess around with empty interfaces and type conversions.
How can I do that? I read that you can convert from an interface to something, but it's harder to convert from a string. When Currency was a string instead of interface{}, the error that the left hand was a string and not an interface type.
I believe the problem is not the type assertion itself but the fact that the type `stripe.Currency` is different from the type `string`, although it has the same underlying type. So if the interface object has the dynamic type "string" (after assigning "usd" to it), it cannot be asserted to be a StripeCurrency. According to the [GOPL book](http://gopl.io) (section 2.5 on page 39), the reason for this is that a type declaration like `type Currency string` provides "a way to separate different and perhaps incompatible uses of the underlying type so that they can't be mixed unintentionally." Hence it would seem that if the interface variable Currency contains a string, you would need to first type-assert it to a string and then convert the string to a stripe.Currency, like: str, ok := obj.Currency.(string) // test ok stripe := stripe.Currency(string) Working code here: https://play.golang.org/p/JOAZ0V6Wym And about type assertion versus conversion: here: https://golang.org/ref/spec#Type_assertions and here: https://golang.org/ref/spec#Conversions
Without seeing the code that you're generating, I don't see where the conceptual problem is. It sounds like you're making everything too flat. If I were writing something to represent those tables from scratch instead of generating it, I'd expect it to be something like: type AccountTableRow struct { Id int TypeId *AccountTypeTableRow } type AccountTypeTableRow struct { Id int } There's no conflict there..
[A recent comment I made about Go](https://www.reddit.com/r/golang/comments/4n0oin/why_go_instead_of_c/d3zzk43), pointing out that, for me, it has turned out to be far less about its features, much more about its simplicity. Few languages can be so great while remaining so easy to use.
Declaring a type within a struct as an empty interface isn't about methods at all.
Currency isn't my type. Thanks for the help though, it's resolved. :-)
Embedding mutexes is one of the coolest applications in Go. It really improves readability and drives home the conceptual intention that a data structure is lockable.
What are you trying to create or features are you looking for that aren't satisfied by an existing product? (either Wordpress or Hugo)
While Wordpress continues to be the dominant CMS... It comes from a time that PHP was the "best" and easiest in town. You could build a Wordpress "clone" in Go, but I ask why? What would be better is to see where Wordpress is powerful (ui, plugins, ect...), and then see where it it is weakest. Then build it from the ground up. Understand the creator of Wordpress wanted to make an "OS" for the web... Is that really necessary? Really you would want to make a platform for basic sites, that with plugins (micro-services) can be made into a blogging platform, shopping cart, ect... The (massive) Monolithic architecture is also representative of the time it was created. And could be broken up, but realistically that would have to be done with a new platform, and would be to difficult with Wordpress.
You're right, that was poor phrasing and not what I meant at all. Let me fix it.
&gt; Now we get to where I cant seem to find a good answer. I want to figure out a way to dynamically spin up a new call of runBenchmark() whenever a core/thread finishes working on its last task. This is a pretty good use case for channels. Feed your jobs into a channel, have some amount of goroutines reading off the channel and performing the work. Each goroutine could simply loop reading the channel, this way when it's done with a job, it picks up the next. You can then experiment with the ideal value by re-running with different numbers of goroutines as until you find your number for ideal throughput.
You mean like this? https://forestry.io/
Thanks a lot! You and /u/Crast have helped me make a big connection in how concurrency works. I thought channels and goroutines were separate things, so I was focusing on goroutines first and then I was going to work on channels. You guys have helped a lot! 
I think I use strong and static interchangeably a lot by accident. I corrected the post because what I meant was I like static types. Thanks for the feedback!
Totally agree. I love it's simplicity. I don't feel constrained by that simplicity at all. It actually feels enabling. ...Except for generic types. I really want those.
The priority queue uses LevelDB as the backend for storage, which is just a very simple key-value store (by simple, I mean it only has 3 main functions, db.Put, db.Get, and db.Delete). To store, it just needs a key and a value, which for the Go implementation is just `key []byte, value []byte`. So what you might be able to do is encode the struct to a binary format using the gob package, and store the returning []byte slice as the value. Then just decode it each dequeue. Edit: Also, because of how it's structured so it can remain extremely fast, it's not possible to change the priority level of an item already in the priority queue (this may change in the future using some replacement technique). New items can be added with a priority level to a priority queue by using the `NewPriorityItem()` or `NewPriorityItemString()` functions.
As I said I prototyped the project first in C++. In other words, now I have two versions of it side by side - Go and C++. Pretty much same functionality at the moment. Absolutely fair comparison IMO. And absolutely no significant difference in compile time. C++ is bringing in a few heavy libraries from boost.
More against flexible: It's more expensive and very buggy. The deployment is a complete mess. 
Here's a small example that feeds numbers to a pool of workers, and waits until all the work has completed: numbers := make(chan int, 16) var wg sync.WaitGroup // Spawn 6 worker goroutines for i := 0; i &lt; 6; i++ { wg.Add(1) go func() { for num := range numbers { runBenchmark(num) // worker goroutines will stay in this loop until there is no more work available on the channel } wg.Done() }() } // Feed numbers to worker pool for i := 0; i &lt; maxNumber; i++ { numbers &lt;- i } close(numbers) // wait for completion wg.Wait() This is a simple way to throttle parallelism. 
Here's what I've done and going to do. I made a second app spot with a long shitty name that I hope no one will guess and then I'll run something on that minus the content to get cache running. There's no way to run memcache locally.
Actually, this will probably end up being an advantage for me because App Engine is where I run Adsense, and it's no good to run it locally.
How do you use this right now and do you run Goque in production or deployments?
Cool! Quick question: Do you know of a way to check the maximum number of possible ~~goroutines~~ threads on any given system? For instance, if I know that I won't have any blocking IO, and the system has n ~~cores~~ threads, is there a way to tell Go that I want it to always have n-1 threads active? Like, numRoutines = sys.getNumThreads() - 1 // Spin up that number of goroutines I know that's a long shot, since Go is basically designed to keep you from shooting yourself in the foot when itcomes to parallelization. 
Then look at [Hugo](https://gohugo.io/), you can even get a very rudimentary editing interface in the same vein as Ghost with the [Caddy](https://caddyserver.com/download) web server (and the hugo 'plugin'). Hugo is a static website generator, like Jekyll - it also supports [themes](http://themes.gohugo.io/).
I have actually thought about this several times but I have not been able to conclude on anything. WordPress works fine and has great support and user base. It almost unpresidented. I like Hugo but it is a higher level to entry than WordPress. One could try create a "WordPress killer" in Go, but is that likely to happen? What is the motivation for creating a WordPress in Go? Just to have a CMS in Go? I guess there is nothing really stopping you (or anyone) from trying but if it will catch on is another thing. And I suspect it demands great amounts motivation because it is surely a big task. And remember there is no such thing as a perfect CMS. ;) These are some thoughts I manage to write down now. I'll probably get some more later. I suspect there is a marked for a couple of good CMSes in Go (if they do not exist already?). 
Ah Great. I will give it a try. This is my Java code snippet which I would like to try in Go Document newDoc = dbuilder.parse(filename); XPathExpression xExpr = Xpath.compile("/Properties/Property/Value[@value='PHONENUM']"); xExpr.evaluate(newDoc, XPathConstants.STRING); NodeList nodes = (NodeList) xExpr.evaluate(newDoc, XPathConstants.NODESET); nodes.item(0).setNodeValue(req.phoneNum1); nodes.item(1).setNodeValue(req.phoneNum2); return newDoc; 
Too bad they haven't had a commit in 7 months! I actually tested cayley out about a year ago and it seemed super promising.
Your comment expresses the flexibility of Go (or most languages in general) as I understand them. please, see my comment: https://www.reddit.com/r/golang/comments/4nwph3/go_vs_wordpress/#thing_t1_d485i7m
The person who controls the repository seems too busy -- I wish they would convert it to a more community oriented project and give some of the people working on it (thinking of dennwc in specific) direct commit privs. The network isn't dead (https://github.com/google/cayley/network) and it is a great piece of tech. 
Haha, you're welcome :) I just happened to have talked to the guys working on this a couple times. I've done some work on Hugo, and so they wanted my opinion. I'd love a "Wordpress that works like Hugo", so the fact that someone is building it is awesome.
By what definition is Go not a strongly typed language? The way I've heard strong/weak typing defined, it basically comes down to how languages deal with implicit type conversion. Go only implicitly converts types dealing with function arguments (method receivers and interface parameters) as far as I'm aware of; it doesn't even implicitly convert among _numeric_ types, which is quite common among other "strongly" typed languages.
the problem with a localhost requirement is that it discounts the power of the web. Being able to log in from anywhere from almost any machine to administrate and update content on your website is what makes modern-day CMS's so popular.
For starters, that would really break encapsulation. My code would suddenly fail to compile because a third party package that I import added a type that implements my interface. It would make comparing `interface{}` impossible as well.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/hance] [Goque - Disk-based, high performance stacks, queues, and priority queues for Go.](https://np.reddit.com/r/hance/comments/4o03s5/goque_diskbased_high_performance_stacks_queues/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/hance] [Advanced Go Tips and Tricks (pt.2)](https://np.reddit.com/r/hance/comments/4o0640/advanced_go_tips_and_tricks_pt2/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/hance] [Introducing dexec](https://np.reddit.com/r/hance/comments/4o063s/introducing_dexec/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
It seems (according to the wiki) that the definition is pretty loose and subjective. The wiki also suggests &gt; For this reason, writers who wish to write unambiguously about type systems often eschew the term "strong typing" in favor of specific expressions such as "type safety". Which is probably what I should've done :) That being said, the author was mixing it with the term static (which does have a meaning) so I stand by the first point. He has apparently fixed this mix up now. 
Cool project, but missing two requirements for me before it will be viable for use: 1. Not persisted. 2. No object-graph mapping. If it's written in Go I would expect to be able to use Go data directly, like Neo4j with SpringData. 
... Why are you spamming a link to your comment on several other replies ... ?
I totally love them to pass into text|html/template instead of maps and interface{}s. On large codebases it may prevent some conflict, if you like to name your types in a generic way, but represent data differently depending on app requirements. For example, you could have a News struct, with a nested Comment struct (list of comments within a news), and vice versa you could have a Comment struct with a nested News item (best rated comment list for example). Anon structs are a good way to represent both data structures, and you can still use embedding to provide a common underlying data type for individual news/comment structs
&gt; dexec is a small Go library allowing you to run commands inside Docker containers as if you are running them locally using the os/exec package.
I found this: https://github.com/forestryio Maybe if it's open source, you'll find your answer here. :)
Honestly if I can't download it and run it on my own server it's a bit of a deal breaker for me :( I've been burned by saas before
Neat, although in these scenarios I would probably opt for a traditional DB, even something bound to a single program like SQLite or LevelDB. As soon as you start writing to persistent storage, you inevitably run into problems of corruption etc...these seem to cry out for a mature implementation.
A very quick blog post about what I learned building this server : http://blog.mbassem.com/2016/06/14/fuzzy-dns/ EDIT : Fixing the link
* Is your go plugin installed? * Is your go version configured? * Did you run vscode with the proper GOPATH environment variable? I remember having to run some command in vscode to have a 'code' command line app which would launch it, so that it would have my GOPATH from my shell when it ran.
Just in case this isn't clear to everyone reading this, this is not something you'd ever want to use. What could possibly go wrong? [Well...](http://arstechnica.co.uk/security/2016/06/german-student-university-of-hamburg-typosquatting-attack/).
This blog post is an introduction and tutorial for: https://github.com/ursiform/sleuth
I guess you didn't get the project correctly. You control the DNS records. You control the domains you will redirect to. It's just as if you are delegating the resolution of a certain subdomain to a custom fuzzy DNS server of your own control. 
I got it to work for the most part, for one package it is still not working (gorilla/mux).
Thanks a lot! Sat down just now to look into it myself, and boom, there was your reply. Today is my lucky day, it seems.
So, how does it actually *work*? The only hint I could find for that was in the FAQ of the github page: &gt; A: That's not a question. But have you checked to make sure your firewall allows UDP traffic on port 5670? So I assume it does some kind of broadcasting on a well-known UDP port then?
I'm not exactly sure what you're asking. There's a baseline of information I'm assuming a reader has if they're interested in service discovery, namely that there needs to be some sort of messaging/networking layer. `sleuth` is built on top of ZeroMQ. If you want to know more about ZeroMQ, I've posted the Wikipedia link and the top-level description in the blog post: &gt; If you’re not familiar with what ØMQ is or why I’m calling it magic, [here’s the top-level Wikipedia definition](https://en.wikipedia.org/wiki/ZeroMQ): &gt; ZeroMQ (also spelled ØMQ, 0MQ or ZMQ) is a high-performance asynchronous messaging library, aimed at use in distributed or concurrent applications. It provides a message queue, but unlike message-oriented middleware, a ZeroMQ system can run without a dedicated message broker. The library’s API is designed to resemble that of Berkeley sockets. It uses the Gyre implementation of the Zyre framework for proximity based networking built on top of ZeroMQ. Since ZeroMQ and Zyre are fairly well-known, and the post was long enough, and the Wikipedia link was available, I didn't explain it "from the ground up".
Ah, I assumed it would proxy DNS records to resolve real-world records. But it just uses its own zones... Oops, bad assumption on my part :-)
What I think /u/TheMerovius is asking is, how does discovery work? Does it use multicast broadcasting to discover other clients? What happens when multicast is disabled, ie: EC2?
We try to be a helpful community. 😃 Plus, given the relative simplicity of the language, new gophers can learn enough to help others practically overnight. One of the many subtle side effects of simplicity by design.
Thank you so much! I've never really fully understood how errors work 
No. The graph is defined via N-Quads, which represent both data and relationships. Unlike Neo4j -- everything is just an n-quad (which is of course subject, predicate, object, label). This makes it simple to implement your own graph adapter to data source and to reason about. 
So Microsoft Frontpage or Adobe Dreamweaver? I realize these tools are discontinued/out-of-date/shitty, but this is what designers used to use.
To be fair, they are separate things, you can use one without the other, but the important thing to recognize is that communication is the key part here. When you start a goroutine, you can initialize it passing parameters using the syntax `go somefunc(param1, param2)` that is a form of communication. But after you've done that, you've got no way to kill that goroutine, or get a handle on that goroutine, and that communication only happened once. Channels facilitate by allowing you to create a (optionally buffered) pipe that can be both written to and read from multiple goroutines, and sending goroutines theoretically don't have to know who's listening on the other end of the channel, giving you a clean way to communicate a continuous stream of values.
This is going to be so useful. I'll often write and use methods directly on the struct, or directly usesomething from a third-party package, especially when starting work on a new app or feature. It's tedious to then go back and replace things with interfaces. This should cut down own that a lot, which means fewer excuses not to write tests.
That was a good read. Having separate packages for each model might work.
Yes. I know those tools were bad at the time, but I wonder if it wouldn't be possible today to make a GUI web tool that doesn't suck. 
Manish, founder of Dgraph. Surely Cayley started before us, but we just raised a big seed round from VCs -- so we're expanding our team and committed to the project long term. In fact, even now it's really stable and fast -- though lacking functionality which we'll build over time. So, I encourage you to try it out.
Unit tests is the purpose it was built for. Just don't over do it ;)
sorry, it was a IFTTT experiment gone bad. I turned it off. 
We are using the official Prometheus client with a high traffic (~1.2 billion reqs / day) application. It mostly works well, without noticeable overhead. The only significant problem is the [HTTP instrumentation](https://github.com/prometheus/client_golang/blob/f6b16ed25641d9035a0847266c01325df0402035/prometheus/http.go#L78). It causes *significantly* increased CPU load. We eventually replaced it with a custom, lightweight (minimal allocations) middleware which solved the issue. I should have some before/after flamegraphs somewhere, I'll see if I can find them.
Agree with ChristophBerger. Maybe have a look at ORM tools first. E.g. have a look at gorm: https://github.com/jinzhu/gorm You can just define the struct and let gorm create the DB for you, then you can retrieve objects and map them to the struct or save a struct straight to the database without writing any getters or setters. (to be honest it sounds odd a bit to me if you want to have code generated for every single get/set. So, I might misunderstood you). Another cool thing is automigration feature. When you e.g. add a new field into a struct, gorm can automatically create that new column for you. However, so far I feel that the go community tend to rather build the things straight from the standard library. So you should always consider whether it's faster to develop now and easier to maintain later if you just write a few functions by yourself rather than relying on an ORM. Have fun with go!
Nothing fancy, this merely to extend time.Duration: xtime.Day, xTime.Week. The full example section shall explain :)
Good question, I started this off as an experimental golang project, just to brush off my skill. Like any other cron packages, we provide similar sets of basic features, what sets us apart are probably just API syntactic flavours, or maybe some advance features like admin panel. But I would argue the goal to this project is to provide minimal and simple APIs (inspired by clockwork) to get the job done :)
Although I definitely won't be hitting that amount of traffic yet, I am really interested in seeing your graphs. Any chance you can share your middleware? :)
If you've decided to use Prometheus and that will never change, the advantages of using go-kit/metrics are not many. — /u/bbrazil &gt; it's trying to be the lowest common denominator so key features of the Prometheus client are lost such as full floating point support Prometheus is the design inspiration for metrics; in retrospect I think it was a mistake to try to change the data types and I'll probably move to floats in the near future. &gt; It also still requires you to construct all your Prometheus metrics, so you're not really making things simpler when it comes to changing later. No, it's definitely simpler: changing the implementation is changing one block of code in the func main, rather than changing all the callsites. That's the whole point.
Can you use Evan Miller's technique mentioned [here] (http://wizardmac.tumblr.com/post/104019606584/whats-wrong-with-statistics-in-julia-a-reply)?
Thank you for sharing this!! I am writing something that needs to limit the number of workers. My solution now is so much crappier than this.
I think it is related to this. I pulled the source from our repository. But even after I go get all the packages it is still not working for that one package.
Did you even run the snippets? I'm not talking about a typo here. It appears that you're using a wrong method name consistently. &gt;We can also convert an Integer, Float value to a string using Iota method of strconv &gt; i := 10 &gt; strVal, _ = strconv.Iota(i) &gt; If we observe carefully, all methods of strconv are returning two values not one. The first value is the actual result, whereas "_" contains the error message if the operation fails There's no `Iota` method. And the `Itoa` method returns only one value, not two. Posts like these are really irresponsible as they can frustrate beginners Edit: screenshot of the relevant section - http://i.imgur.com/9fZ1hwh.png
Is there a non-realtime commandline version that works over stdin/stdout? (So that I could use it with [de](https://github.com/driusan/de) or [acme](http://research.swtch.com/acme), but only when I want to look something up..)
I would bet he did run it and a spell checker changed it on him. edit: well, that doesn't explain the two returns vs. one.
&gt; HTTP instrumentation We also developed our own prometheus http middleware, if its of interest: https://github.com/weaveworks/scope/blob/master/common/middleware/instrument.go In particular we were trying to filter out the request duration of long lived websocket requests.
Yep. 2 options right now, will be working on more things like this. Do you want it to display the results in the terminal, too, or in the browser? 1) You can turn off the live-updating, always-on behavior in the editor plugin. See https://github.com/sourcegraph/sourcegraph-vim#vimrc or https://github.com/sourcegraph/sourcegraph-sublime#auto. Then you just use a hotkey to jump to usage examples. Or you can just keep that browser window in the background (that’s how I use it, since I use a full-screen WM on Linux). 2) The underlying tool it uses is https://github.com/sqs/godefinfo. It accepts similar flags to `godef` (filename, offset, etc.), and then you can open a URL like https://sourcegraph.com/-/golang?def=NewStaticCredentials&amp;pkg=github.com/aws/aws-sdk-go/aws/credentials&amp;repo=github.com/aws/aws-sdk-go/aws/credentials. (Fill in the def, pkg, and repo values that `godefinfo` returns.) We have an HTTP API but it's not documented; check your browser's network inspector in the meantime, and https://github.com/sourcegraph/sourcegraph has all of the code for the server if you want to dig deeper.
Did you 'go install' it? This is required to get code completion with vim-go.
Thanks, I will definitely look into it. I develop it on the go as soon as I need something. current limitation is that it doesn't scan anywhere outside of the specified file.
Doesn't this completely defeat the purpose of goroutines? The largest nicety of goroutines is that they are baked directly into the language and thus easy to use. Also, the fact that they are *not* threads, but closer to green threads (multiplexed by the runtime onto preallocated batch of os threads) means that pooling is largely unnecessary. There are other ways to tune goroutine performance, such as with with GOMAXPROCs, and jazz. Can someone explain to me where (or how) this would actually be useful?
Thanks, I can try that. I'll let you know in a few days when I'm back at the office.
I gave up trying to understand it. I suggest having a single init function and expose an initialization function to receive the config in the dependent package. import "somepkg" func init() { Conf := loadFromTOML("config.toml") somepkg.Initialize(&amp;Conf) } 
I think `switch` is easier to read and understand than `if ... else if ... else` and will always choose `switch` when the two are interchangeable. The difference between them is you give each the `if` and each following`else if` a new and separate condition to evaluate. You're not limited to testing a single value like you are with `switch`.
When you're testing a single variable against multiple values.
You are the second commenter to misunderstand this, somehow. I am not an amateur. I had hoped that by putting "switch {" in the title you would gather that I am *not* talking about cases where one is comparing a single variable to multiple values, but cases where one is comparing a series of boolean expressions from top to bottom as is typical of if-else statements. I want to know which one should be used when neither `if` nor `switch` shines, and what you describe is an obvious case where `switch` should be used.
I think the question is about using switch like this, where you can test anything and are not limited to a single value: var x, y = ... switch { case x&gt;y: ... case x&lt;y: ... default: ... } to replace the series of if/else if/else you'd write in a language with a less generalized switch.
Are there any examples or more explanation on what this does and how it works? 
This is an argument over semantics. If it's your project use it wherever you'd like. If you are contributing to a project with `if-else` chains all over the codebase then use those.
Which one is faster?
I see what you're after, now. I didn't read carefully enough. The Golang doc says using `switch (true) {` in place of `if-else…` chains is idiomatic, so that seems pretty clear IMO.
Sorry, I've had crazy days at work and am just now getting to these. It's more the time involved. I can spin up 10 small, custom-templated Wordpress websites in the same amount of time as a single Go (Hugo, etc.) implementation. I love Go, and would love to be able to charge customers for a Go site, but with the clients I'm working for, they don't care if it's a Go site with some kind of CMS or a Wordpress site, and Wordpress is the more value-creating option because it's so much faster. 
I won't claim to be a stellar programmer, more of a coder really, but I find myself liking to use "switch {" more than "if else if" chains. I just think it easier to read most of the time. Your mileage may vary
It's more just that I love Go, and hate (HATE) PHP. PHP is by far the fastest solution for custom sites, at least for my business. If there was a similar solution or workflow for building websites with Go, then I'd love to migrate to it, because I love Go! I realize Go isn't PHP, and a Go CMS would never be Wordpess. I was more just testing the waters to see if anyone else out there has had similar thoughts/taken action to migrate to Go. 
no, switch statements prevent the function from being inlined (if you compile your code before commit e41f527f4d56a94b33ab73efaae3575760916194) and currently if your switch contains a break statement or you type switch your function will not be inlined. 
Did you watch the ~90 second video? It shows you how it works in real time. I found it very helpful before I ran the 1 command it takes to install it
Oh, I missed it somehow. Thanks! It looks very useful indeed.
&gt; This is an argument over syntax. FTFY Apologies for being pedantic. Peace.
I'm honestly baffled at all the downvotes going around this thread. A pool of workers (whether thread or goroutine based) is such a common and fundemental thing in programming, I have no idea why anyone would be against them in general. Sure, there are use cases where you don't really need them, but opposing them on principal? Really?
what are all of the rules to ensure a function is inlined?
You know what, that feature has been my head for while, I will definitely put it in :) and it will be something like this, c.add(gron.Once(10 * time.Hour)).
huh really? I've tried multiple times to find the list without any luck.
Personally, I use switch iff I would otherwise need to write "else if". I wouldn't use it only to replace "else".
The formatting is also all over the place :(
Would using libgit2 bindings help to get this project cross-platform? https://github.com/libgit2/git2go
Needed something like this a few months ago and the closest thing I came across for Named Entity Recognition was this: https://github.com/sbl/ner You could also do: https://github.com/advancedlogic/go-freeling or http://nlp.lsi.upc.edu/freeling/node/1 (it has an HTTP endpoint you can connect to).
I'm still on my way to reach my C++-level skills in competitive programming with go. This article doesn't show any tips or tricks, just some language basics, which are not sufficient to crack contests ;)
I agree with you, the clearest way is to avoid DI, but that doesn't mean that using DI (even with interfaces) doesn't give advantages. Frameworks like Martini rose up just based on those advantages. Even if it's not the idiomatic way of doing things, it has educational value - if not even a real world value to a disciplined programmer. I agree that an object factory is detrimental to code quality (I in fact repeatedly mention it). As for being specific: an invoke call is not a bad practice, considering you use one where you actively don't want to enforce interface usage. Consider: does a function declaration make your code clear, or is it function invocation? I prefer clear declaration, the inject.invoke in this case just bridges the gap in a way which also has advantages for when and if you decide to refactor whatever you are invoking. I could expand more on this.
OK got a little inspiration so v3 is released. https://github.com/go-playground/pool/releases/tag/v3 now supports a limited consumer goroutine and unlimited goroutine pool
The simplest approach to this is to use Mikolov's (creator of word2vec) `word2phrase` algorithm. I've used it production a few times and people always like the results, it's simple to implement, needs minimal tuning and is fairly fast. * Paper: http://papers.nips.cc/paper/5021-di * Orig C implementation: https://github.com/nicholas-leonard/word2vec/blob/master/word2phrase.c * Python implementation: https://github.com/travisbrady/word2phrase/blob/master/word2phrase.py
It might be just something I'm doing wrong. Feel free to enlighten me what I should be doing here? I just extended this practice from what i saw with *string and from what i remember in C
Why do you need it in go? There are plenty of ftp clients who can do this.
This looks interesting. But will need implementation . I expected to find something ready :( 
I'm wondering why you'd need that at all. FTP, SSH, ... do the job very well. Even with GUIs.
Hey, you made it to the go weekly mailing list! http://golangweekly.com/issues/114
Because it's so incredibly easy. I currently use a PHP one, and there's just no comparison with clients and the like. It just works, from everywhere (I use multiple laptops, a macbook and a linux laptop). And even for external people, I can simply give anyone a link and password and it just works, no fuss, no installs, no nothing.
How does is the queue different than a buffered channel, which had far better performance?
Just mount your server using [SSHFS](https://en.wikipedia.org/wiki/SSHFS). Now you have first-class access with _any_ app that can read and write files — Finder, Atom/Sublime Text/Emacs/vi, etc. I don't understand why you'd want to share a server's file system with multiple people. Surely Google Drive or Dropbox would be much better if you're collaborating on files.
So if it works, why are you looking for a replacement? Just to have something written in Go instead? Or something specific?
It seems to me, having a sql_test.go file in sql which exports the internals (so they are only visible during tests) is a cleaner solution. It's often overlooked that you can have test-time only exports that way.
Now it have unlimited size. In future I want to add more features like get without delete from queue and get all data from queue and some other. Also channels are not good with many producers.
This code is half a year stale, and http2 support is now in net/http.
&gt; Now it have unlimited size. Backpressure is *good*.
1) &gt; I can't use a for/while/do while You do not need 3 kind of loops. That's why Go has only `for`. Similarly templates have range. You do not need anything else. 2) &gt; I need to iterate and control the iteration. `{{range $i, $v:= .Dir}}{{$i}} {{$v}} {{end}}` 3) &gt; You can creatively create a function Yes, that's the way to do it, if you need something extra. For example I like to create a `join` function for convenience in many projects. Also on a small project, I happened to do some strange loops and I needed a function to find me the `last` element of a slice. var fns = template.FuncMap{ "last": func(s []string) string { if len(s) == 0 { return "" } return s[len(s)-1] }, "join": strings.Join, } Ta-da! I created the function with simple Go code. But from that small project, it was easy to see that having complex logic and loops in my templates is not so good. They make things unnecessary complex, harder to test and harder to maintain. Nevertheless, if you really need it, you can make it. 4) &gt; It all lead me to believe that text/template &amp; html/template isn't made to do logic. To my experience, logic in templates is bad. Try to use as little as possible if you cannot avoid it altogether. The heavy lifting has to be done before you reach the template rendering phase.
Place the required logic in your application and/or template functions. It will reinforce better separation of concerns. 
The general experience with dynamic websites using Go is that you will use Go as a service to power the interface, and consume the data from a frontend _(generally written in JavaScript)_. That is what is popular nowadays with the myriad of JavaScript frameworks out there, otherwise you will end up having a static site generator which is the other approach that some people are following. If you try to translate the big features of a dynamic scripting language like PHP then you are going to have a bad time, but if you translate your knowledge to JavaScript, for example, and power the website using a backend written in Go then _that_ is going to give you better results.
&gt; Why do you keep hurting yourself? Why would you start a comment by saying that? It's just hurtful.
Right, well, that means that we have to write methods to access all needed members of internal structs, and wrapper methods/functions for all non-exported methods and functions. That is exactly the kind of nuissance we are trying to avoid.
Thanks!
Thanks! 1. The reason I don't use gofmt and golint is because I couldn't get them to work, but I'll try again. 2. Hm, I tried to use the same variable name, but the compiler wouldn't let me? 3. Sorry! :D 4. You're completely right.
thanks for the insight!
Cool. Feel free to dm me on here or the Gophers Slack if you need help with anything https://gophersinvite.herokuapp.com/
This is great. Great job with hosty by the way, it looks awesome. Thanks xrstf 
Would event handling be a form of polymorphism?
It isn't really about the language, its about the data you need to manage. All modern languages have perfectly functional packages for connecting to most available databases. So, that isn't a real factor. Do you need to store graph data? Documents? Data that fits well into a fixed schema that is likely to change rarely if ever? Data that is highly variable and would benefit from a "schemaless" database? Do you need it to be always consistent, or is eventual consistency acceptable? Keep in mind also that it's perfectly acceptable to store info in multiple databases, depending on the data domain. So, store authentication info in Postgres, time-series data in a Cassandra cluster, some documents in Postgres using the recent JSON enhancements, and maybe some key-value stuff in a Redis cluster. Look at some comparison articles, which are easy to find if you include at least one of the things you are looking for info on and the term "vs". Autocomplete will start to fill out the search with similar products simply because that's what people tend to search for when they type in "postgres vs" for example. If you are just doing a general app, need something to learn with, I would suggest going with Postgres. It'll serve you well with most types of data, including JSON documents, has excellent documentation, is free, and so forth. Eventually, when you think you are comfortable enough with that and the app, you can start optimizing, maybe move some data to a cassandra cluster or whatever. 
The Go 1.7 Release Notes Draft https://tip.golang.org/doc/go1.7. Not sure what has changed since beta1 though. Anyone? 
Android provides two independent interfaces for comm depending on your interest in either. Regardless, the question you pose can be generalized in "polymorhism? why?", which is what I'm exploring with my question. Honesly, I don't expect much given what I typically see on reddit, but summarizing the human experience based on reedit seems pretty dull-witted so I figured I'd ask. At best, I don't know what to expect, but that's life eh?
This reminds me a bit of the old story by Joel Spolsky about [architecture astronauts](http://www.joelonsoftware.com/articles/fog0000000018.html). Ok, maybe he exaggerates a bit... I did have some attacks of *architecture astronautism* in the past, but I feel that it happens much less to me with Go. Go seems to much more support [duct tape programming](http://www.joelonsoftware.com/items/2009/09/23.html) than over-abstracting.
I suppose you're agressively avoiding text/template and html/template which aggressively use reflection? I'm apparently missing the point - half of the community is excited that you can combine assemly and C code in go, and the other half is looking at reflection and solutions built with reflection as the root of all evil. It's not black magic, and due to the size of the codebase it gives benefits in the same scale. Using go idioms to provide an app of that scale would lock us into a refactor/slow development limbo, for in the best case - the same result. Imho: the best line od code is the one you never have to write
I think that my last quote/opinion might have come from here: https://blog.codinghorror.com/the-best-code-is-no-code-at-all/ - posting just for posterity
I think you are looking for [Identity and Access Management](https://cloud.google.com/iam/). Though it's also interesting to know where your stuff is running (i.e. if it's running on the Google Cloud or not). Also, the authentication you describe should be pretty simple, you just want to `if !strings.HasSuffix(user.Email, "@example.com") { http.Error(res, http.StatusForbidden, "forbidden") }` or something.
`TestServerFactory` seems unnecessary, also package name is part of the name, so: package testserver type Params struct { ... } type Interface interface { ... } var New func(Params) Interface // whereever you init it testserver.New = server.NewTestServer Also to ensure that it's used only during testing, append `_test` to the filename. Just curious, why was the Server necessary for testing `sql` stuff in the first place? I.e. which case required both exposing and server? Note, there might be one additional approach, separate out the validation funcs. e.g. in `package sql_test`you import server and sql both, but to verify the internals of sql you have a file `sql_internals_test.go` with `package sql` which contains necessary validation funcs that can access internals.
Thanks for pointing the direction, found this https://www.toptal.com/go/going-real-time-with-redis-pubsub and it hits the use case perfectly.
Seeing binary size go down again feels amazing!
There's no CRDT in Cassandra or MongoDB.
Actually made this for a friend, so I already know who I'll be messing with &gt;:3
If you leave a down-vote, please also leave a comment as to why
The [12 factor app manifesto](http://12factor.net/) was written for SaaS applications and apparently is based on the accumulated experience and knowledge from that particular field. It might not fit very well to other kinds of applications. Config files still can and do make sense. BTW, I am not in the SaaS business, so perhaps someone can explain the following to me: If, according to factor #3, environment variables are the one and only means for storing config data, how do they pop into existence? How do they survive a restart of the shell (let alone a restart of the whole system)? Aren't they initially read from some .rc file, which is nothing but a... *config file*? Another BTW: It seems the 12 factor manifesto was written before distributed configuration registries like etcd became popular. I wonder if the authors would promote those instead of env vars if they wrote the manifesto today.
If you want to do server side templating, you can look at ego or egon for an erb templating method. It generates go code from template files, so it's not as convenient at the built in text/template or html/template. It was suggested to use javascript, but that's a non-answer really - the person is basically saying "if you want to do a front-end, don't use go". You may look at some projects like hugo for some ideas.
Vault is cool, but I think configo do a different thing. It focus on config parsing with the ability to set default value or specify as "required", validate configured value and at the same time supply a simple interface.
Logging to human readable output stdout also doesn't really fit with structured logging either.
Maybe I'm interpreting the 'environment' part a bit more broadly than just 'environment variables'. config files may come from the environment as injection, population (a la chef/vagrant/ansible) and even as a service (etcd, consul,...). Main point of it - don't rebuild your app on config change, don't bundle config with the app... Depending on the amount of config for your app, environment variables may just be unsuitable
Can you replicate the issue in a unit test? Try using a lib I pulled out of the standard library - github.com/fortytw2/leaktest to see if anything is leaked after the test ends
You can easily implement CRDT yourself on top by never updating a cell in place but only appending new data and using a merge function on read. Because Cassandra is using last-write-win eventual consistency and it does not use vector clock, all in place update are risky if you care about your data. For more detail see: https://aphyr.com/posts/294-jepsen-cassandra
I'm using this exact fork of egon: https://github.com/SlinSo/egon - I can't say that I'm exactly thrilled with it, it needs some work before it could be closer to EJS http://ejs.co/ - some deviation with syntax, etc. Generally I'd advise to stick with html/template. It's syntax is a bit removed from go (which is also my biggest butthurt), but it's a very close fit for what a template engine should do. You would get the benefit of speed by using EGON (it's compiled into go code!), and you can pretty much use the full go syntax (structs, chans, etc.). It does require a build step before you invoke go build/run, which adds to complexity.
Thanks, it does get a little silly but that put into words exactly what I was trying to work out.
Yes. I use Cassandra daily at work, I'm quite familiar with the limitations :) Just thought the wording was a little misleading, because cassandra does not have CRDTs in the sense that Riak has them. But yeah, I agree with you.
i did not know about appending _test to a package name... thats an interesting feature!
Sourcegrapher here. We got a lot of interest on our interest form (https://sourcegraph.com/tools/editor?expanded=true) for IntelliJ, so it's definitely on our radar. If you sign up at that URL, we'll let you know as soon as it's ready!
I am a newbie at golang and so would be happy to make something like this just for practice if it doesn't exist already. Presumably the entire front end can be lifted from extplorer. If the back end API is well documented it should be reasonably easy to replicate. Ping me if interested!
That project appears to have some features (history, cookies etc) which would help, but it has no UI, so rendering quality html and css and integrating the DOM with something like otto would still take years to do alone, I imagine.
&gt; Simplicity Equals Productivity. \*skip screwed up formatting of package docs\* \*scroll through multiple pages of index of functions\* \*close tab\*
But 90% of people think they are the %.01
Forgive me to starting from the most basic if your profiling skills are far beyond this but are you sure you're not looking at cumulative stats? Maybe try something as simple as the follow to reveal the running goroutines: func init() { go func() { timeout := time.NewTicker(5 * time.Second) for range timeout.C { buf := make([]byte, 1&lt;&lt;20) stacklen := runtime.Stack(buf, true) log.Printf("STACK TRACE\n==============\n%s\n==============\n", buf[:stacklen]) } }() } 
As with any other distributed database, you can check Aphyr blog and find its throwing your data away :) - https://aphyr.com/posts/284-call-me-maybe-mongodb - https://aphyr.com/posts/322-call-me-maybe-mongodb-stale-reads But there is also a bunch of very bad design decision. And while feature rich, the code quality is very bad and full of critical bug.
&gt; We all love git No we don't. Its commandline user interface is one of the worst I've ever seen, the gitk UI is an archaic mess of 1980s GUI conventions, its documentation is incredibly confusing, and it's various "features" get in your way about as often as they helps you. Something like half of the top ten questions on Stack Overflow are about git :-/ For a tool, that's pretty ridiculous... Even if git would not be of questionable quality, supporting only one VCS is severely limiting (I *think* it only supports git, but the animated GIFs are too confusing to follow so I'm not sure...) *Edit*: also, this is the **third** time you've posted this ling in /r/golang in a month. That's pretty spammy...
Byte slice is more convenient when you need to pass big chunk of data across app. It's passed by pointer. String on the other hand is passed by value. It's battle less allocation vs immutability.
Being passed by reference is irrelevant -- the compiler could in principle (if it doesn't already, which I'd find odd) pass strings by reference safely _precisely_ because they're immutable. The reason `[]byte`s can reduce allocation (which is where you were right -- they can) is, since they're mutable you can reuse the same chunk of memory many times with different content without the GC having to free and allocate stuff.
What ~~library or libraries~~ packages are you referring to? Most things come into and leave your Go process as byte slices and there isn't a need to have it become a string. If you need rune iteration or use the data as a map key, then make it a string. It's not difficult. 
Dependency management 
If you want something socket-oriented, use something like zeroMQ or nanomsg. If you want a message broker, something like Kafka would be the way to go. Both have their pros and cons.
That is the right answer! If you believe you are in the 0.1% region you can give Cassandra a try. But if you do not want to loose your data stay away from MongoDB. If you want to work with your data, I mean doing more than reading / writing single data sets than take a relational database and PostgreSQL is the one to GO! :) 
Here is a very got example that MongoDB can kill your project and why: http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/ I would not say that MongoDB has no usecase but I do not get why they choose to put DB in the name.
"Go isn't as big and popular as some other languages, so it doesn't matter."
It has garbage collection meaning it can't be used for low level system utilities, kernels, games, or anything else. I have personally disproved the second. ;)
Yeah I agree with you, it's still in beta at the moment and should not yet be used for production. But the team working on is very solid and should have something stable soon and pass Aphyr Jepsen test. The reason I mentioned it is to say that by using Postgresql for the initial version of your application you are not tightly coupled to one product (mongodb or cassandra) and can easily switch to something that scale better but support a subset of the PostgreSQL syntax in the future without having rewrite all of you persistence code. In general regular SQL database can get you very far. For example even large website like Stack overflow run on only 4 Microsoft SQL Servers. https://nickcraver.com/blog/2016/02/17/stack-overflow-the-architecture-2016-edition/ 
Because []byte is used for random data that you get from a file or over the wire or whatever, and returning string from various stdlib functions would require an allocation since it copies the []byte. So, not only is it good to keep things as primitive as possible for as long as possible, it's also a performance thing.
Go isn't Object Oriented.
You wrote a kernel in Go? Cool! Link?
Syntax highlighting.
Go ignores 40 years of programming language research.
https://github.com/boomshroom/goose That project is being put on hold, and might be replaced all together, as I'm working on making one that's cross platform and has a generally cleaner structure.
Rust is better.
It is exactly this that makes the lack of 'const' decorations so egregious in Go. It's a huge opportunity for optimization that is largely discarded. Disclaimer: not a compiler engineer, I bet some deeper level of whole-program analysis could enable similar optimizations
&gt; [shafreeck/toml](https://github.com/shafreeck/toml) is a modification version of [naoina/toml](https://github.com/naoina/toml), adding the abililty to parse complex struct tags. I'm curious what this means exactly. Is this a syntax extension to TOML or just a difference in what type mappings can be configured for deserialization?
I don't think this would annoy Gophers, they're already saying it.
. . . You know what? I normally use prefix incrementers a lot. But I've never even reached for it in Go. I didn't even know it didn't have one. I wonder if that's because I just haven't needed to use one, or if there's something inherent about how the language works that makes it unnecessary. Huh.
"We here at Google have decided to discontinue development on Go and put all our resources into improving PHP." (no I don't work for Google, but if they said that, I think it would be annoying.)
rust is better.
There are lots of times when `io.Reader` or `io.Writer` reads/writes data that's not really a string at all. For instance, a list of IP addresses could be stored raw in a file. `[]byte` is kindof more of a raw storage (without any structure) than `string`.
Gophers would benefit a lot from a good relational database written in Go.
I have never used APNS, but from what little I've researched on it in the last 5 minutes I don't see why not :P
ANN: Dependency Injection/IOC Framework.
Go is the new COBOL. 
BTW, please check https://github.com/rescrv/libmacaroons for that matter, macaroons are used not only for authentication but also for authorization!
http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/
What are you guys talking about, Go is an Asian game of skill. 
This actually true unfortunately.
Use PostgreSQL, please don't give yourself much time, you may convince yourself to use something else which is quite unnecessary.
Any compiling benchmarks ?!
I'm not all that familiar with the internals but might point you in the right direction on this one; I'd say a more apt comparison would be to compare strings and fixed-size arrays. If there's any performance penalty using the latter, then (afaik) it's most likely caused by optimizations leveraging the property that arrays are mutable while strings are not. There's also the slice overhead. I've encountered some [unexpected behavior](https://play.golang.org/p/shJS-jV8-0) while setting up an example. This does however clearly illustrate how the underlying fixed-size arrays are two additional objects that must be tracked by the GC. To figure out the overhead of the latter, you could compare slices to fixed-size arrays.
To give a full explanation, as there is quite a bit of confusion and misinformation in this thread: * Both `string`s and `[]byte` have a very similar data layout. They are values, that contain a pointer to the data and a length - `[]byte` also contain a capacity. You can think of them as `type string struct { ptr *byte, length int }` and `type []byte struct { ptr *byte, length int, capacity int }`, respectively. In particular, slicing creates new `[]byte` resp. `string` structs with the same `ptr`, but different `length` and `capacity`. * The *only* difference between `string` and `[]byte` is, that `string`s are immutable. You *can't* change the content of a `string`, but you *can* change the content of a `[]byte`. This is expressed in the fact, that `s[i]` isn't assignable if `s` is a `string`, but `b[i]` is, if `b` is a `[]byte`. * The fact that strings are immutable is the reason why they don't have a capacity. The use-case of `capacity` is mainly `append` - if a `[]byte` has additional capacity, `append` can just re-use that and save allocations. That doesn't work with `string`s, as another `string` might share that additional space, so modifying that would violate the immutability of `string`s. * There is no difference in what data they can contain. A `string` doesn't *have* to contain valid utf8. It is most often assumed that they do and the language gives special operations for that (e.g. `range`'s behavior on strings), but it also copes just fine with arbitrary bytes. The reason for that is, that everything else would require expensive runtime-checks. If you want to assume that a `string` contains valid utf8, use `utf8.ValidString`. * There is no difference in whether one of them is a reference type or not. Gophers like to say that in go, everything is pass-by-value and they are right, in a sense. But realistically, you can think of pointers, `chan`, `map`, slices *and* strings all as reference types (in case of `string`, the reference is an immutable one, however) and of `{,u}int{,8,16,32,64}`, `byte`, `rune`, `float{32,64}`, `complex{64,128}`, `struct`s and arrays (so e.g. `[8]byte`) as value types. I know that this is considered heresy, but calling it differently is just confusing to newcomers. In any case: Either both are value types, or both are reference types, there is no difference between them. * You can slice `string` and `[]byte` respectively, without copying the underlying data, as outlined above. For `string`, this is the only thing you really can do to them, whereas for `[]byte`, you can also change the contents of the underlying array (but must be aware of that when passing it around). * Whenever you convert from `string` to `[]byte` or the other way around, however, you *have* to allocate and copy data. Otherwise you can't preserve both the mutability of `[]byte` and the immutability of `string`. If a `string` and a `[]byte` share data, you could modify the string by changing the contents of `[]byte`. (There is one, uninteresting, exception, with the expression `m[string(b)]`, if `m` is a `map[string]T` and `b` is a `[]byte`. But that's it.) So, the reason why people largely avoid `string`s are: * `[]byte`s will, in general, need less allocations if you don't share them. That is, if you *know* that a `[]byte` only ever has one owner, that owner can do more, useful transformations to it, without allocation. For example, to replace a sub-`string`, you *always* need to allocate, whereas to replace a sub-`[]byte`, you *might* not need to (if the original isn't needed afterwards and the modified slice fits into the capacity of the original). * Every `string`, except when coming from a literal, will incur at least *one* extra allocation, as it must have been read as a `[]byte` originally and then converted to a `string`. So if you want to return a `string` from a library, your user might incur an ultimately useless allocation, so returning a `[]byte` is less safe, but more performant, in general. * All the "features" of a `string` you mention are just minor conveniences, they have equivalents in the `bytes` package. And if you really want them, you can always decide to do the conversion yourself. That doesn't work, if the library returns a `string`, a user could then not decide to *not* incur the performance penalty. It's kind of a sad state, as `[]byte` are less safe, so every function and method using a `[]byte` must document their behavior in regards to ownership and concurrent modifications and it is relatively easy to fuck that up (pop quiz: Without looking at the documentation, what parts of a buffer can a `Reader` modify? What about a `Writer`? Can a `Reader` keep the slice around? Can a `Writer`?). However, it is the only way around egregious copying when massaging data. In the long-term I would wish for better optimizations in the compiler around `string`&lt;-&gt;`[]byte` conversions, so that we can use them more interchangeably without worrying about allocations (just like escape analysis lets us mostly forget about whether something lives on the heap or the stack). But we're not there yet.
Golang 2.0
_Reference_ is a heavily overloaded term, sorry for muddying things up! In this case when saying _pass strings by reference_ I meant _without copying the underlying text data_. In this sense _a two-word struct containing a pointer to the actual data that is passed by copy_ is _by reference enough_, especially if it's an unexposed implementation detail. I'm sorry you've got downvoted, you're raising a perfectly valid question about what I've said.
Kudos for pluggable KV
It's okay! :-) "Reference" can be used a hundred different ways, and I was assuming you meant reference a la c++ (standard "pass-by-reference"). Cheers.
I keep meaning to add Bleve search to my blog. Gotta get around to it. 
I thought the preferred json web token flow was to NOT use cookies and just pass the auth in each request header??
lol so true, the fact that it does
Doesn't isokey implement the use case that joepsie says is a valid use of JWT?
why? i dont think any language should have this
This really isn't a great article. Lots of assertions that are just supposed to be taken as fact. There are many cases where a JWT gives you a lot more flexibility and ease of use than a session would, specifically because of the specification around them. Edit: typo
Cool. Yeah, I should have said I think yours is pretty cool and I wasn't trying to knock your work.
i know this is pedantic, but i swear every usage of "your" on the first page should be "you're" and it's driving me crazy...
I think you're off by an order of magnitude. The `reflect.Select` function is [85 lines long](https://golang.org/src/reflect/value.go?s=57637:57706#L1925).
&gt; If your coming from another language (Python, Ruby, PHP, Java, JavaScript, …) as many new Golang developers Except the incredibly annoying "you're" typos, you need to understand something. _The language is called **Go**._ Not Golang. Not GoLang. But if you really insist then you should go back and edit this article to include Pythonlang, Rubylang, PHPlang, Javalang and JavaScriptlang.
C++ developer detected ;)
This isn't pedantic. I noticed it immediately as well. Also, &gt; reaching for the standard libraries net/http the **standard library's** net/http &gt; common for building HTTP API’s. for building HTTP **APIs** &gt; when building API’s. when building **APIs** 
`os.Args[1]` is stdin? I thought stdin was a file, `os.Stdin`. Isn't `os.Args[1]` just the second argument (the first being the program name)?
Will fix the your/you're issue. However go/golang are used interchangeably all the time. 
The README is taken completely from the original creator and I've been too lazy to update it. I am taking it (somewhat) seriously.
Last I checked, "C++" was a postfix operator.
&gt; gophers told me "frameworks" are bad Gophers stongly favor libs over frameworks, as libs offer a much higher degree of freedom and flexibility. Calling all frameworks "bad" is a rather extreme standpoint IMHO. &gt; but for gophers anything that isn't in the std lib is a framework Definitely not true. Who told you this? Don't listen to the Go haters. 
Built a SPA and used local storage to store JWT. Then a requirement came in that we needed to support being able to click a link and download a CSV file. Because of various browser differences, it can be impossible to support sending data from localStorage on click to trigger a file download. With cookies it we wouldn't have even had to think about it.
I don't use gofmt.
This works and saves me time. Excellent!
If you are using the Go library HandlerFunc it lacks the ability to process parameters in the URL. You might take a look at: http://www.gorillatoolkit.org/pkg/mux -- It is the most popular mux -but slow - if you have a lot of URL paths. There are a bunch of them available. Also please provide the server side code so that a more meaningful answer can be provided.
Well, it takes a few seconds to upload to production using SFTP! ;-)
thats a lot of photo downloaders
Wow, congratulations! Regardless of what this project is about, it always inspiring to see people achieving year-long goals and challenges. Would love to see some blog post on how your understanding of Go was evolving or changing or whatever personal impressions this project left. 
Helps me learn the Language. I know Rails and Django, but I'm not sure I know those languages as I should.
Mainly static typing (safety) and better performance for CPU bound tasks. Generally at the cost of development speed.
Probably has something to do with the fact that `somevar++` is [a statement](https://golang.org/ref/spec#IncDec_statements) in Go, not an expression, so there would be no difference between prefix and postfix variants.
Oh yeah. Totally forgot about that.
This is incorrect and there have been decisive discussions in this at the Google Group for Go. Golang for search, Go for discussion.
Makes sense, actually. I think this might be a good way to illustrate the difference between a statement and an expression to some learners.
Well done. A lot of projects are what I am looking to do myself. Thanks for the inspiration.
The toughest part about JWT tokens is logging out. This article is pretty good. I'd really appreciate it if there's a follow up article describing the logout process.
The final piece for me was a mental image of a old fashioned bucket brigade. Imagine 20 people shoulder to shoulder, passing buckets from the first to the second ... all the way to the twentieth who empties it on to a fire, then passes it back to an identical group of twenty who carry it back to the water source. Inline code execution is sequential, one line at a time, something we all understand. So in traditional code execution one bucket would run down the line to the twentieth person, get dumped on the fire then be returned back to the water source to begin anew. If we need more water we have two options: the traditional threaded model -- duplicate the entire setup and double the throughout. CSP is modeled such that as soon as the first person hands the bucket to the second, he/she immediately fills a second bucket and waits for the second person to take it. Repeat this all the way around and after the first bucket gets emptied onto the fire, you now can empty a bucket every hand-off. In CSP you keep the workers busy more frequently and get greater throughout than a single thread (though probably higher latency), but typically lower than a fully parallel thread solution (though easier to reason about and implement correctly). I'm hoping that microprocessor designers can figure out a way make channel operations more efficient. If they do, CSP's benefits will really shine as today they're 2-3 orders of magnitude slower than a function call. I'm not complaining! Go, and channels in particular, are better than sliced bread. Just saying that hardware based channel ops would kick Go and CSP into an even higher orbit.
Have you browsed Russ Cox's [Bell Labs and CSP Threads](https://swtch.com/~rsc/thread/)? In particular, I'd recommend Cardelli and Pike's paper on Squeak as it's a simple language and it shows the compilation's C output that can be worked through to see how CSP can be implemented. Pike's Newsqueak is also worth a read.
Oh ok, then please ignore my comment; in this context it makes no sense at all.
A dozen years ago an opinion about uselessness of frameworks was popular among PHP adepts. Because, you know, "PHP is special and unlike other languages it has been created specially for web. So, frameworks do not add any additional value but just make things more complex". Looks like opinions have changed a bit since that time in PHP community. 
They are different operators. They do different things.
I don't know... it talks about paradigms a lot, yet the Go example was meant to show how not to write concurrent Go code. Go authors go the extra length to tell you not to share memory, but to share data over channels. &gt; Suppose I write some crafty code in Go that is very delicate and I am super careful, super disciplined to ensure all proper locking happens around a map. But then, someone decides to come along next week and add some contributions to this code. [...] Hide the implementation from others and only provide safe functions to access/modify it. That's probably what you should do in any programming language. 
Is *the usecases where JWT is particularly effective are typically usecases where they are used as a single-use authorization token* from http://cryto.net/%7Ejoepie91/blog/2016/06/13/stop-using-jwt-for-sessions/ relevant?
Thank you all. I will have a talk on Taiwan Open Source Community conference "COSCUP 2016" about this project. Hope I can inspire more people to learn Golang :) http://coscup.org/2016/schedules.html
## Warning, rant incoming. You know, the problems I've had with Rust the numerous times I've tried it have little to do with ownership and the borrow checker. My problems have more to do with: * The syntax is extremely awkward. It almost feels like it was specifically designed to clash as badly as possible with every single language feature, especially lifetimes. * The really, really empty standard library. * Time. * No rustfmt as a standard feature. * Cargo is terrible. It's slow, the Cargo.toml file is poorly documented, and so on. * Rust's crate/module system is almost worse than C header files. That's quite the accomplishment. * The error messages that the compiler creates are very poorly formatted. The messages themselves aren't terrible, but they're almost unreadable due entirely to how they get printed. And this hasn't been changed or seemingly even noticed for years. * Bizarre naming conventions. I want to like Rust. I really, really want to like Rust. I really like its ideas, and I've tried to get used to it on many, many different occasions. But every single time, I find myself banging my head on the table, and it has very little to do with ownership.
From just a short look: - Huge interfaces - I can't find any tests, neither the main repo nor in github.com/iris-contrib - Don't get tricked by the benchmark in the github repo. The real source of the benchmarks is here: https://github.com/smallnest/go-web-framework-benchmark - Just another fasthttp implementation 
Maybe it's the second sentence that annoys gophers?
&gt; Go authors go the extra length to tell you not to share memory, but to share data over channels. This is one thing I don't really understand. Go often sells itself to Python programmers as supporting easy shared memory parallelism, but then it tells people not to use it? You can do non-shared memory parallelism in any language (with varying degrees of overhead). 
I know this is a rant, so I won't dig in too much here. &gt; No rustfmt as a standard feature. It's coming. It's taken a while because of reasons, but we will get there. &gt; Cargo is terrible. It's slow, Do you mean Cargo specifically, or `rustc`? Remember, Cargo calls out to `rustc`, and Rust is certainly less fast at compiling than Go is. Just want to make sure the rant is targeted correctly, it makes it stronger ;) (Oh and we're getting close to incremental recompilation, which in practice will boost compile time speed a lot) &gt; the Cargo.toml file is poorly documented, Is it possible that maybe it's just a bit hidden? http://doc.crates.io/manifest.html has a lot of stuff, but if you have specifics, would love to address them. &gt; And this hasn't been changed or seemingly even noticed for years. We have actually just shipped new error messages, and are currently working on a total revamp of all parts of it.
Well put, that was exactly the sentiment and intention of the article.
Which part of Rust is not essential complexity? The only thing I can think of is maybe the macro system. Everything in Rust is there to do something useful. 
My "world" related to programming was quite small at the time, but I recall being eager to accept PHP frameworks. They bring sanity to a wild language and I still use them nearly every time I need to work with the language. Similarly, I was eager to use web frameworks with Go. However, after some time (experience) and admonishment from others, it was clear that most of what i sought from frameworks was already available from the standard library. It was only one or two steps from that that I started writing libraries to fill in gaps. Looking back, I spent months wasted on learning different frameworks' ways of doing things rather than learning APIs, interfaces, and idiomatic Go. I definitely see a purpose for frameworks in Go, but for web, the use case is slim. For microservices, the use cases are more clear, but there is still great benefit to thinking in terms of libraries rather than frameworks. In Go, "framework" tends to imply a lack of orthogonality, so I treat them as suspect.
Updated. 
Why does monotime.Now() return a time.Duration struct, rather than a time.Time like the standard time.Now() function? https://golang.org/pkg/time/#Now 
The biggest factor that stops me from using rust is the tooling. Racer can't even autocomplete `println!`
Context: not all of those keywords are implemented. Some of them are reserved just in case we want them in the future, without affecting the grammar. Or because they used to be a thing, but we left them reserved when the feature was removed pre-1.0. My rough count shows 14 of these keywords in this state.
Why only look at keywords? Go has a lot of special-case hardcoded syntax for stuff which is a first class feature in other programming languages. For example: multiple return types, iteration, variable arity operations (map access and type casts), slices and maps in general, all those builtins like append which would be library functions in any other language, etc. Also, note Go does not include "false" and "true" as keywords but Rust does. 
How are modules worse than C header files? I personally find them much nicer.
&gt; It's coming. It's taken a while because of reasons, but we will get there. I'll believe this, when I see it. rust dropped the ball by not being opinionated early on this, now their users are getting opinionated on formatting and their opinions will only get more cemented as time moves on.
https://github.com/dragostis/pest/blob/master/src/parser.rs fn prec_climb&lt;F, G&gt;(&amp;mut self, pos: usize, left: usize, min_prec: u8, last_op: Option&lt;(Option&lt;Self::Rule&gt;, u8, bool)&gt;, primary: &amp;mut F, climb: &amp;mut G) -&gt; (Option&lt;(Option&lt;Self::Rule&gt;, u8, bool)&gt;, Option&lt;usize&gt;) where F: FnMut(&amp;mut Self) -&gt; bool, G: FnMut(&amp;mut Self) -&gt; Option&lt;(Option&lt;Self::Rule&gt;, u8, bool)&gt;; That's just picking a trending github repository and opening a random file... maybe it's the exception, but it's not lovely - there's more stuff there for the compiler than the human that has to implement and maintain it (it's only syntax highlighting that lets me spot the argument names).
This is certainly a complicated signature, but as said elsewhere in this thread, it's not for nothing. Specifically, this function seems to take two closures, which are already relatively complex, but with it, you also get them unboxed, which is great for efficiency. (I have seen much worse, but also, many more which are much better. I've been programming in Rust for years and I've written a signature this complex maybe once or twice.) I would also take slight objection to "more there for the compiler than for the human", signatures are good for humans too. After doing some Rust, this isn't the worst. Everyone has a different tolerance for this kind of thing, of course. A newtype for the `Option`s used here would make this a bit cleaner.
Yeah, this would be really interesting. I know because that's how it was for me. Go is a simple language that you can learn in a week, but probably won't completely master until many years.
Is there a point in using fasthttp? Isn't the magnitude of one DB call going to trump everything else, http handlers included?
That's the point of a monotonic clock, it is not a time.Time. You can't get time.Time from a monotonic clock. You can only get the duration between two events in the same run of your program. You can not send it across the network to compare with another clock. Sorry about the rant, but time.Time or civil time have all the complexities of a global social construct thousands of years in the making, and an operation system setting that the user can change in your timed loops, but it is the only way we have to communicate time. monotime is more like a stop watch with two buttons. Asking for time.Time from it is like saying:"You stop watch is nice, can you add a calendar to that?"
I'm not sure "share nothing" is really the right characteristic to assign to Rust. In fact, Rust encourages sharing across threads, but it prohibits sharing in a way that leads to data races. Rust has mutexes just like Go does, which allows you to share mutable state safely across multiple threads. As far as initializing state goes, it's pretty trivial with `lazy_static`, which transparently initializes on first use (and is thread safe).
&gt; The Assert and Require package of Testify provide some helpful methods that allow you to write better test code in Go. Nope. https://golang.org/doc/faq#testing_framework
Was a pain in the rear to test each handler separately. I ended up just testing the unauthenticated, then authenticated separately - from main. Here's the start of some test code: http://pastebin.com/kJY3373i
Are there any tooling for on-file-change event to re-compile and re-run tests? I use this setup with Node and I find it really helpful than having to restart the tests each time
Go has around around 15 less keywords. There are more accurate details in the parser implementation.
Rust is still young. I agree it has some more growing to do I agree that the std lib is maybe too sparse. I get it, this is the principled and high-minded postion....let X be a library concern...but things that ship in the std lib just tend to be more polished I also don't have a strong need for no gc...but thats me
Thanks, well explained. I would counter then that monotime.Now() should not return a Duration, and should instead return an int32, uint32, or direct struct, since it's not a duration, nor a unix timestamp.
I've written a few bits and bobs in Rust but have never worked on a larger project with it. Immutable by default and extra compile time sharing information seem pretty great, but Go got to me first and spoiled me for simplicity. Rust just _looks_ a lot more complicated: * lots symbols in the language syntax (eg &lt;&gt;, =&gt;, &amp;*, ..[.]) * some weird syntax choices (`'labels`, pattern matching stuff; a lot is different from c/c++/java for no discernible reason) * macros * operator overloading * implicit returns Rust touts a focus on _zero overhead_ abstractions, but that overhead doesn't go away, it's just converted into cognitive load. At the end of the day, Rust feels like its authors were experts in programming languages and Go feels like its authors were experts in building software.
It's probably a better way to define monotonic time than most others. A duration from an unspecified point in time.
Of course not. The point was not whether it is hard or not. The point is simply that more LOC == more bugs. People write code and people make dumb mistakes. To write a relatively complex assertion might take 8 lines of code. Then I have to review it and maintain it. Do this dozens or hundreds of times and I *promise* you have a bug in one of them. Cases that come up far too frequently: AssertStringSlicesEq(in, out) // sort and compare AssertStringStringMapsEq(in, out) ...and so on. I know I am swimming upstream here, but this isn't even about things like generics (which solve the same problems, but bring new ones). There's literally no downside to this that I can conceive of. Yeah, you need a multitude of functions, but so what. Write once. Debug once. Use forever. Predictable names alleviate a lot of pain. This would handle 80% of assertions I ever need.
I wanted to get into Rust earlier, but the syntax just kept changing and breaking my toy programs, making me essentially have to learn the language over again. Do you know if they have a "language freeze" guarantee by now, or if they still change?
I see nothing simple here
You need to stay away from win32 programming... that is a simple as it gets.
&gt; You can keep your test bugs, if you like them so much. Sure, I will keep my test bugs and I'll keep chuckling to the idea that someone is unable to write a helper function on their own.
Unwilling != Unable.
Unwilling is even worse in this case. :D
&gt; The Since implementation doesn't correctly overflow/underflow, that's why we haven't yet added it upstream. Could you clarify what's wrong with just subtracting two integers here? Usually to compute the distance we just convert two arguments to a signed type before subtraction. However, `time.Duration` is already a signed type, so we can just subtract. It should work for overflows, shouldn't it? See spec: https://golang.org/ref/spec#Numeric_types &gt; The value of an n-bit integer is n bits wide and represented using two's complement arithmetic. https://golang.org/ref/spec#Arithmetic_operators &gt; For signed integers, the operations +, -, *, and &lt;&lt; may legally overflow and the resulting value exists and is deterministically defined by the signed integer representation, the operation, and its operands. Am I missing something?
I was inspired by the [WeGo](https://github.com/schachmat/wego) terminal app and wanted to create something similar and portable. I'm a frontend dev who is just dabbling in GoLang for the first time and I'm interested in any mistakes or errors I've made, or any feedback or advice you could impart on me. Thanks for looking!
Of course! It's a new one I'm trying out which is called Dracula (https://github.com/dracula/dracula-theme). In the screenshot I've got it with the BobbyRussel zsh theme + Source Code Pro font.
Thanks a lot, I'll check that out!
I don't think this: for i, line := range tubesAtStation { go func(last bool, stationID string, line string) { [...] messages &lt;- "" }(i+1 == len(tubesAtStation), stationID, line) &lt;-messages } is going to get you the parallelism that you think it is. Unless I'm missing something (and I could very well be), you're adding the overhead of spawning a go routine, then blocking at the end of the loop before starting the next iteration which spawns another go routine.
We'll just have to disagree.
Not integrated with Go specifically, but there is https://facebook.github.io/watchman/.
Here's the approach I use http://choly.ca/post/go-json-marshalling/
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/unikernel] [Unigornel: Clean-slate unikernels for Go](https://np.reddit.com/r/UniKernel/comments/4oyuau/unigornel_cleanslate_unikernels_for_go/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I mean to say that "sooner or later you have to tackle the beast" is not really true with Go. If you're writing Windows UI, it might be a fun exercise to do it in Go, but if that isn't your end goal and you have to eventually write a Windows UI, then stick to C#.
dude, I was going to ask the exact thing ! The theme looks sick !
I apologize in advance for the bike shedding, but it's just "Go", not "GoLang". Edit: OK, here's some more useful criticism: 1. `utils` is not a good package name. It doesn't tell users anything useful. 2. It looks like you're ignoring errors in your `Fetch` functions in utils.go. You probably shouldn't do that. 3. You also probably shouldn't panic (like you do in the Fetch function). Return an error instead and let the caller decide how to handle it.
I'd probably use [libui/ui](https://github.com/andlabs/ui) or [walk](https://github.com/lxn/walk)
In this app [...] is a bunch of expensive requests that should happen in parallel. How would you change it to spawn routines concurrently?
2013, apparently. In all seriousness though, this is the first I've heard/seen this happen - do other distros do the same?
Or better yet write a Web Ui.
Go is the only language I know of which specifically has syntax for multiple return types. Rust, Scala, Python, and Javascript have a tuple syntax which is superficially similar, but tuples are a much more general feature. But in practice, Go's multiple return types are designed for error handling, which wouldn't even be necessary if Go had generics, because if it did, you could just use an Option&lt;T&gt; and get type safety and less verbose code as a bonus. Go is absolutely full of cases where they added syntax specifically to solve one particular problem, unlike other languages which have generally useful features that solve that problem and a whole bunch of other problems at the same time. This is what I mean by hardcoded special case syntax. 
You probably want [sync.WaitGroup](https://golang.org/pkg/sync/#example_WaitGroup)
&gt; The more LOC you write the more bugs you have. This is completely not true in the small. If you're talking about orders of magnitude, sure. 10 lines will generally have fewer bugs than 100. But 10 lines will be unlikely to have many fewer bugs than 15... especially if those lines do the same things, but the 10 just has denser lines. var oldNames []string for _, e := range entities { if e.Age &gt; 60 { oldNames = append(oldNames.Name) } } oldNames = [e.Name for e in entities if e.Age &gt; 60] The first one is 6 lines, the bottom one is a one liner. The complexity of what the code is doing is identical. The one line is much denser... but I don't think either one is particularly more likely to have bugs. In general, lines of code is a poor measure of pretty much anything except lines of code. 
The bugzilla discussion https://bugzilla.redhat.com/show_bug.cgi?id=1038683
Cool!
Looks good to me. https://play.golang.org/p/b8_NKTeeKc
Thanks, I will find this useful when I get round to doing it 
Interesting. Can you share the reasons for choosing Mini-OS over rumpkernel?
If you read https://github.com/kataras/iris/issues/93, it sounds like the project is still actively being developed and being tested that way, and tests will be a priority later.
Our goal is to create a highly specialized unikernel system. We aim to write as much as possible in Go. So we started with a very minimal operating system which was easy to understand and customize. Since rumpkernels are based on the full NetBSD kernel, it was not a very good fit for our objectives. There are no other arguments for our approach. It's just the approach we took, and it certainly has its downsides. We don't claim it's more efficient or secure than the rumpkernel alternative, though it could be. It is however, more specialized, one of the characteristics of unikernels.
Fair enough. Nevertheless, interesting project, wish I had equally interesting projects back at the technical university I went to.
So cool!
I'm curious about this. I understand your concern for removing something from the standard library, but considering the above, that this could be an implementation from the NSA, then I'm actually glad for the awareness 
That is pretty cool. 
Since at least Wed Dec 18 14:25:44 2013 -0500, apparently
Go frameworks bring sanity to Web programming in Go as well. That is if you are building a decent size application. Frameworks do give you everything and a kitchen sink but I've found out that otherwise I'll have to import a mishmash of libraries myself and then add quite a bit of my own on top of that. One just needs to find a well-rounded framework. Also, in the near future many frameworks will become libraries. The reason? Go 1.7 has Context in the standard library and Request embeds Context. No need to build a framework around custom handler signature that includes custom context. 
Don't use Fedora then, since they prioritize security before flexibility. Arch and derivatives are stricter when it comes to respecting upstream, so feel free to switch, that's what distros are for.
Just to clarify the situation for me. I understand that go is statically compelled by default, so this does not impact me if I build with go tools that I downloaded directly from golang.org and deployed on fedora, right? So this only impacts someone developing on fedora with fedora's distribution of go or someone making a fedora distribution of a go program?
Do you mean https://en.wikipedia.org/wiki/Dual_EC_DRBG? Which is just elliptic curve used to add a backdoor to a random number generator, not how you would normally use elliptic curves. It looks to me like they just removed P224, and left P254 and above in place, so they probably feel 224 is too short for any program in fedora to use, but elliptic curve is generally ok to use.
It seems like you're saying the same as /u/hahainternet above, can you give an example? I just started learning go so this would be helpful 