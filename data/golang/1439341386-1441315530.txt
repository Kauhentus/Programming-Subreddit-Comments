I'm just being sarcastic :). It's a play on the whole "social justice warrior" culture that has invaded software in the last few years.
Hey, this is cool. My eyes weren't immediately drawn to the diff example in the comment (took me several reads to find it). I think you should show an output example in its own code block.
I don't understand how this actually simplifies the creation of JsonObjects. How is it any easier than map[string]interface{} or any more performant than creating a struct?
Thanks for your feedback! I just added *big.Rat support :) [FormatMoney](https://github.com/leekchan/accounting#formatmoneyvalue-interface-string) ac.FormatMoney(big.NewRat(77777777, 3)) // "$25,925,925.67" ac.FormatMoney(big.NewRat(-77777777, 3)) // "$-25,925,925.67" [FormatMoneyBigRat](https://github.com/leekchan/accounting#formatmoneybigratvalue-bigrat-string) ac.FormatMoneyBigRat(big.NewRat(77777777, 3)) // "$25,925,925.67" ac.FormatMoneyBigRat(big.NewRat(-77777777, 3)) // "$-25,925,925.67"
And the recent activity is *not* related to fixing that. The project was rather dormant before that.
&gt; Care to describe why this is better than goconvey? SÃ³, I think with `bro` has a different proposal.
Looks nice. Though I'm always vary of new cron like implementations - getting cornercases right is tricky. There's not always 24 hours in a day, sometimes 2am happens twice in a day... and other time related stuff that's no fun.
This is a repost, I screwed up the title the first time and didn't notice.
do jobs overlap? how about dependencies?
Just for the record, what you're describing is generally called "mobile code" in CS. But there's only a few systems that can do this in a fully general way, such as Gambit/Termite.
What do you mean by "job overlap"? And yes, there are dependent jobs. See https://github.com/ajvb/kala/blob/master/examples/example_dependent_jobs.py
&gt; Whether the variable is a pointer and whether the method is a pointer method are independent from each other; pointer methods can be used on non-pointers and non-pointer methods can be used on pointers. Except for situations when you can't take an address of a variable at all (say, when it's in a map). [See this](http://play.golang.org/p/D9LynET52R).
And Plan 9 (which actually does timesharing; Oberon does not) even more so.
&gt; It is an absolutely crazy idea to have users function run in a separate goroutine in the same memory space as a) the supervisor and b) other users code. It's not really all that crazy, it's just that Go might not have the necessary mechanisms to implement it properly - you'd need hard resource control to reliably cancel computations diverging in both time and space (and time might actually be somewhat easier to control for than space). The runtime would also need to feature functions for module loading and unloading, something the current Go runtime also doesn't support (and maybe never will?). You'd probably need a more Oberon-like runtime for this to work.
The code is simply for internal use like sandbox so security is not the most important issue (of course security is very important when considering for the entire environment). I agree I need to rethink about that for more detail because it's apparently not what I original thought (capture the state, dump it, etc.). Big Thanks! 
I really need to rethink about this. Really appreciate your suggestions. 
Consider using something like http://github.com/thejerf/abtime to get the unit testing going. It's hard to test the corner cases without full control over time. Edit: Oh, and I haven't changed anything recently; the README.md always referenced "scheduling" code :)
See the original reply. You're starting a circle.
Mark it's a markdown processor that support all the features of GFM, smartypants and smart-fractions rendering. It was built with a nice-ish concurrency model that fully inspired from __Rob Pike - Lexical Scanning__ talk and the __marked__ project. And of course it's an open source project, that build for fun. I learned alot from doing it([re2](https://github.com/google/re2) mainly), so I'll hope some of you find it useful. Thanks.
&gt; It's not really all that crazy, it's just that Go might not have the necessary mechanisms to implement it properly Yes, I was referring to go :) It's not a huge problem in e.g. python.
This makes me sad because I was *literally* writing the same thing and watching the same talk. Good job!
You should not be sad, I'm sure you learned, get a lot of experience and of course, have fun when you did it. There's a lot of things to do to make it stable(v1.0), and it will be great if we can share ideas together. You're always welcome to contribute and share your thoughts, Thanks @barsonme.
Go-plus for Atom is now fantastic and either on par or better than GoSublime - I just switched last month.
Sorry I just looked quickly and noticed you print colored logs: https://github.com/ajvb/kala/blob/master/utils/logging/logging.go#L14-L17 I'd recommend to avoid doing that, it makes logs impossible to parse by machines or read from a log file.
I just wanted to say, thanks a lot for iocontrol. It's been a very useful package for me. 
I've implemented this bit to disambiguate which parts of a stream were guilty in slow operations. For instance at DO, we have a local caching layer that was said to be 'slow' when a cache hit would occur. Since cache hits are streamed to the requester, it was a bit hard to instrument and find the guilty part, since you can't just: - measure time to prepare response - measure time to send response As both the `prepare` and `send` parts are happening at the same time. Developing this, I can now say "out of 24.7s to pull the bytes, 400ms were spent waiting on the cache and 24.3s were spent waiting for the client to accept the bytes"[1]. In that case, I'm pretty happy I can say my cache isn't part of the issue =P [1]: https://i.imgur.com/uWdzTri.png
http://stackoverflow.com/a/12754757/1685538
i dont understand what is "left to right syntax" what are languages that are not like this ?
`int x = 7` is read "x is an integer equal to 7." 
Heh, well I'm not sure what I meant :P I guess I wanted a sales pitch why I would choose your new library instead of something proven like blackfriday.
Look at the types: C: int (\*x[])() Go: var x []func() int Which of these more clearly tells you that variable x is a slice of functions producing integers?
Pike had a talk where he stated reasons why they choose left to right. The main complaint was how god awful it was to use function pointers in C.
Not that I know of. Maybe fork and modify it yourself? There are a few forks of it it seems (at least one that adds AES encryption)
Error handling is some of the most important logic.... That's been the honeymoon the whole industry is wearing off from, that error's could be ignored or handled with magic.
A distinction needs to be made between read LtR and parsed LtR. A few languages are parsed RtL but read LtR just because of how parsing works.
C syntax has been described not as "left to right" and not as "right to left" but as [a clockwise spiral](http://c-faq.com/decl/spiral.anderson.html).
&gt; the objection I've heard to Go is that it ignores the last 40 years of computer science innovation People who say something like this usually have a myopic view of what Computer Science is really about.
Thanks! Yes, I will probably go into some more depth in the next post. I just haven't gotten around to installing a syntax highlighter plugin.
I agree. I was just reiterating what I've heard elsewhere. 
Ignoring the functional is acceptable for a highly pragmatic language, sure. But isn't Go lacking in the OO department as well? I think the feeling is that Go is for people with nostalgia goggles for the 60's.
Good point, but ain't enough to make it fly. :( There is still too much missing. Now I'm at a point where I don't know enough about kerberos to fix it on such a low level (lost somewhere inside asn1). So any other _working_ kerberos libs around?
What features would you say are lacking? Also, why the 60's? The peak in popularity of C was in the 80's and 90's, and even in the 2010's, people start developing new software in C. Seriously, the level exaggeration to make Go look older and more old-fashioned is astonishing.
What I mean by TCP-like is that it has properties more similar to TCP (reliable, ordered, no duplicates, byte stream/connection based) than UDP (unreliable, unordered, possible duplicates, only individual packets). &gt; WebSocket is a protocol providing full-duplex communication channels over a single TCP connection. Additionally, WebSocket enables streams of messages on top of TCP. TCP alone deals with streams of bytes with no inherent concept of a message. I choose to ignore the messages of WebSockets and treat it as a stream of bytes in my code.
To save you a lot of trouble, try godebug . simple, and very efficient https://github.com/mailgun/godebug there is also a nice article on CloudFlare blog about godebug, and also on mailgun blog.
I agree with this. The only thing go is really missing over other languages is a whole lot of heavy syntactic sugar. Those people seem to things that the only thing thats happened in 40 years of CS i coming up with more syntax to do the same things. That extra syntax just lets you do complicated things with shorter code. Not better, not faster, not more readably, but just with fewer lines of code. All of the syntax lets you build a new custom language from your base language, for every project. Every app ends up with its own programming language. What an nightmare. Go forces you to break up those complex things into smaller simple steps. And to keep using the same language for each project. Not just for your benefit, but for everyone elses too.
well... there is range and make optional arguments, and generics for builtin types, all that stuff you can't do with your own types and functions. That's magic for me. Disclaimer: I'm just a few days into go, so I might be wrong.
 I meant it as in writing one tiny for-loop isn't really that much more work. I needed to write one more loop than I thought I needed is all. But on the topic of hiding expensive operations, what about the `append()` builtin? IFAIK, when the slice being appended to is too small, it'll copy the contents to a new array but use the same array otherwise. Isn't copying to a new array also O(n)?
&gt; Actually, the objection I've heard to Go is that it ignores the last 40 years of computer science innovation. I would assert that if anything, it's the exact opposite - all the lessons of the last 40 years of the maturation of CS were taken into consideration and everything was thrown out that wasn't unquestionably free of any cons. You can't really do that if you ignore history.
Virtually every language aside from Smalltalk or CLOS/CL (or Self) is "lacking in the OO department", that's hardly an argument against Go.
If the slice is writable (and it always is in Go, if I'm not mistaken), you can't pass it to somefunc purely on the basis of general type theory, because somefunc might attempt to write into the slice a value of the interface type **a** that isn't actually **mytype** (there could be *other* implementations of type **a** besides **mytype**) and you'd either get immediately a type error at runtime, or later an outright crash, depending on how that assignment would be handled. This is conceptually independent of the way of how the values are represented. Furthermore, when it comes to representations, interfaces don't work the same way in Go as they do in other languages since Go values don't have headers and the two types (a value and an interface reference to that value) are not of the same size, interface values contain explicit type information. And even if they happened to be the same size (16B on 64 bits?), they'd have different physical bit patterns anyway so you'd have to physically convert the data anyway. In contrast to this, in languages like Java, an array of objects of some class can be treated as an array of objects implementing an interface (that is implemented by said class) simply by pretending that it is like that, since it's the same physical pointers to "headered" objects in both cases. On the other hand, in exchange for this (occasional? or even rare?) hassle, you get internal pointers in Go as a compensation, and in most cases, you'll generally probably use much less memory for comparable amount of useful data in Go - also better cache use. Totally worth it in many people's book. Of course, Java also got this wrong *by actually allowing this kind of array casting.* They've paid for it dearly by risking type errors at run time, as I wrote above. Complex interplays like this (subtyping-induced covariance and contravariance problems) are why in general, generics and OOP-style subtyping are an explosive mixture (slices *are* generics in Go - they're just privileged in the sense that you can't create your own generic types). As is a number of other features, which is one of the reasons why Go tries to remain as simple as possible.
It is my understanding that the "C4" GC for Azul's very advanced Java systems works like this, to the extent that it should be an almost-zero-pause system, but Java does have some benefits in terms of a more restricted data model, so everything is a sea of tiny objects, except for arrays (and furthermore, they do need a very, very good GC for precisely the same reason - because everything is a sea of tiny objects). I'm not sure how C4 would be applicable to Go, though. Besides C4's being very complex (and actually requiring a custom OS kernel), Go's internal representations might pose some problems for the elaborate C4 that I'm currently not aware of.
It's usually just not intended that any unixey os'es work that way. You are of course free to do it but doing so should never be recommended to anyone else. I have go installed in ~/.opt/go because the home directory is the default location for things owned by me. You can read about /usr/local here: http://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/usr.html
Since no one has commented, I'll be the one to say it: thank you to the team building this; you indeed are doing the community a service. I, being selfish and focusing on projects I'm interested in, have only read the 1.3 source.
Memory is on a shared heap that all goroutines can access. How can the GC safely collect memory while its possibly being used by other threads? To answer your question: in 1.5 it does. There is a small window where everything is stopped, but the bulk of the work is done in parallel with other goroutines. See: https://talks.golang.org/2015/go-gc.pdf.
&gt; I avoid this problem by using languages that include overloading Then you get an entirely different problem, in the presence of subtyping. Yet another pair of features that conspire to confuse the programmer... Negating your argument about code readability, of course.
Aha. In short, no good reason to not own `/usr/local`. But the link is truly informative, thanks. 
You could potentially run in to troubles but from the top of my head i don't think it's likely. Other software's "sudo make install" might expect that /usr/local only is writable by root and possibly setup executable permissions in a way that would allow administrator access by replacing the content of such an executable with bad code. It's your machine and you do what you want. If someone were to target you in an attack they will probably succeed using other exploits or methods anyways.
Thanks for this exchange, still too vague to me. I can't make a rational decision if the _only_ reason not to do something is fear :) I have had no trouble installing and running stuff on my machines in which I own `/usr/local`, in fact everything got simpler after I did so because I never have to run `sudo` again and I manage most of my binaries with homebrew as well. I found thi bit informative (from the link you posted): &gt; The original idea behind '/usr/local' was to have a separate ('local') '/usr' directory on every machine besides '/usr', which might be just mounted read-only from somewhere else. It copies the structure of '/usr'. These days, '/usr/local' is widely regarded as a good place in which to keep self-compiled or third-party programs. The /usr/local hierarchy is for use by the system administrator when installing software locally. It needs to be safe from being overwritten when the system software is updated. It may be used for programs and data that are shareable amongst a group of hosts, but not found in /usr. Locally installed software must be placed within /usr/local rather than /usr unless it is being installed to replace or upgrade software in /usr. 
Big thanks to Rick Hudson and Co. Your work on this expands the kind of things you can do with the language and that's fantastic for the community.
So I didn't realize that when you receive on a channel there was a second returned variable to indicate if the channel was closed. I've updated the playground example with the fix. http://play.golang.org/p/DFPNgP8n1N You could also do this with a custom second channel but it isn't needed, unless you really want the to use range loops.
Yep, hehe.
Haha neat, if you got time later feel free to check out the help request post I posted on here. Cool project though!!
Outside of the question of the need for locking shared memory for runtime state and bookkeeping[0], â¦ even with incremental, continuously-running garbage collection, you could still face issues where the collector just can't keep up to allocations: dC/dT &lt; dA/dT (C: bytes collected; A: bytes allocated). Process resident set size (RSS) continues to grow, because the heap is growing at dA/dT - dC/dT. You could say that this is the result of degenerate server design, but this often occurs with improperly scaled systems. You'd see this manifest itself in different ways with different runtime releases. In pre-1.5, you'd see long pause times; in 1.5 and 1.6, you'd hopefully see the kernel out-of-memory (OOM) killer taking action. Neither of these are desirable. No matter which runtime you are using (including 1.5 and planned 1.6), you still have problems with heap fragmentation in spite of the allocator using caches for objects of a given size class. Heap fragmentation results in unnecessarily large heaps, which, in turn, grows process RSS. Deploy your servers in memory-constrained environments (e.g., containers), and the OOM killer will be constantly cycling your jobs; or you'll swap if that hasn't been disabled. This is why heap compaction is important, something which Go does not perform nor is it planned on the runtime's roadmap. Unfortunately heap compaction is difficult to achieve without some measure of runtime locking. In specific terms of the allocator (it is modeled off of TCMalloc, which has known issues with fragmentation), sparsely occupied spans of a given size class are never consolidated into fewer ones. This is especially problematic for long-lived objects. In spite of how much folks in the Go community have historically derided Java, the HotSpot JVM has solved most of these problems for years now: compaction and low collection time. The dirty secret is this: you need a highly-parallel collector (-XX:+UseParallelGC -XX:+UseParallelOldGC), NOT a concurrent one, and pin the memory pools to fixed boundaries reflecting the containerization environment -Xms == -Xmx and -XX:MaxNewSize == -XX:NewSize. That is all! If you keep new generation reasonably sized (e.g., &lt; 800MiB) and deploy instances decently accordingly to load test regime (you should do this for anything you care about), you'll easily have end-user pause times &lt; 10ms. The trick that is Java-specific is not violate the [weak generational hypothesis](http://www.cubrid.org/blog/dev-platform/understanding-java-garbage-collection/) in your server's design. You get excellent performance, because you only have minor garbage collection events (from not violating weak generational hypothesis) and small memory footprint thanks to heap compaction. Go does not use a generational memory pools. I think the work on Go's 1.5 collector is admirable and awesome, especially with getting the pause time to be low, but the point of why I am mentioning this is that similar performance can be had elsewhereâand I love Go, mind you. AFAIR, too, the continuously or bounded-duration pause time mechanism that is being used in 1.5 was also used in Java's concurrent mode collector (CMS) in its so-called incremental mode, which isâwhatâfour-some years old now? The problem with HotSpot CMS is that it is non-compacting. It has a compacting failure mode, but it is SLOW (ca. order of seconds). [0] â There are probably strategies that could be used to shard the bookkeeping by mutator thread (a thread that the serving application is running in, not the runtime), but that increases complexity drastically. TCMalloc, which I mention in the writeup already does something like this with thread-local allocator pool caches.
Java's GC is ahead of Go's in many ways, but I think you might be giving Java's GC a little too much credit. Watching engineers and SREs try to tune JVM GC settings is often comical. There are so many knobs, it's almost a full-time job just trying to make services behave. It's far from just magically working. 
You guys also added AES support to gokerb, right? Does gokerb work for you? Anyway, gssapi looks promising, thanks for that. I'll give it a try. Edit: FreeBSD is working also.
Definitely an overkill, but still worth giving a look. Thanks a lot!!
The project is down now, but thanks for sharing. I too am writing an in-browser game in Go and have a question about your front-end: I'm a kernel engineer by day so the server-side stuff has not been a problem but the front end is looming. I'm ramping up my environment to support developing JS now (my dev server is a CLI CentOS VM, so I've been distracted setting up Samba to view the html easily etc.) but GopherJS looks interesting. I feel like as someone completely new to Javascript I'd be better off trying to write it natively so I 'get' it more, and GJS doesn't exactly look tidy, but of course it would be more convenient. Could you describe your experience with it? Thanks and good luck!
You and others who read this may find this interesting: [How Go differs from Java from a GC perspective (video)](https://youtu.be/aiv1JOfMjm0?t=8m44s). (This isn't "disagreement", just, elaboration.)
This is another small project I've been working on recently. You can use it with UDP or raw ethernet (root required, Linux only for now) sockets. I'm also debating the idea of making a WoL proxy which captures magic packets and forwards them on to different machines based on which port they arrive at, or something similar. Any suggestions are appreciated!
It tries its best, but I wouldn't care to guarantee there's something, somewhere that would be nondeterministic. If you explain why you need what you say you need, we may be able to be more helpful. Especially in terms of the other constraints you may have. For instance, how hostile are the users? It's one thing to strongly guide users that are basically cooperating, it's another to be robust against attackers. Haskell, for instance, has a couple of flags you could flip that, combined with some type signatures, could guarantee what you're looking for to some extent (google for "safe Haskell"), but you may not find that suitable for other reasons. (But it is designed to allow you to rigidly control the IO environment, which you could construct as deterministic by construction, while still leaving you a full language behind it.)
By the way, taking the final example in the link: &gt; void (*signal(int, void (*fp)(int)))(int); &gt; "signal is a function passing an int and a pointer to a function passing an int returning nothing (void) returning a pointer to a function passing an int returning nothing (void)" I think the Go equivalent would be a variable defined [like so](https://play.golang.org/p/aQvAD_pMLJ): var signal func(int, func(int)) func(int)
Author of zedlist here. I have never been employed, never called for Interview, and never received a reply from my job application despite having Bachelor of Commerce in Finance and 5 years experience in web development. So, to find out why? I am building a job recruitment service from grounds up. So far, I have been working on the project for a month now. Today, I'm open sourcing my efforts, so anyone who is interested can checkout the code, hack on It and If you are a real geek contribute back. The code base is well tested, I have exclusively implemented the project in Golang. It is not for release yet, but you can test it if you know what you are doing. And it can be a good starting point to learn about large web service projects. Any kind of feedback is warmly welcome.
Ah, you'll also want to read up on [Ethereum](https://www.ethereum.org/), which should at the very least be interesting. "Safe Haskell" offers you the chance to define your own language with its own safe implementation with reasonable effort. Haskell's good at compilers &amp; interpreters. Depends on what you're looking for.
Gorethink has a built in connection pool which you could use with a `MaxOpen` set to `1` to get the same effect. The readme on the the GH repo has a better description of this than I can provide here so I'd recommend reading that. Hope this helps. Edit: The advice above is probably still the best way to solve your problem. But the code you have should work if you change `session` to `Session`. Remember in go the capitalization of the first letter denotes private vs. public. Anytime you see an `cannot refer to unexported name` check the capitalization.
To be fair a lot of *problems* with tuning is due to programmers not understanding how their language works. The thing with programming is that, no matter what language you use, if you write apps complex enough *eventually* you will have to get up close and personal with its internals. Which sometimes cause PTSD in developer who then proceeds to cry in the corner yelling "ADMINS DID IT, IT WORKED ON MY MACHINE FINE" from time to time
This worked perfectly thanks! I knew about the lowercase rule but I'm confused about the existence of both r.session and r.Session. 
I've read through the readme, but unless I'm wrong, the MaxOpen open refers to a particular session, which would still require me to pass around this session pointer, no? Anyway, your and /u/callumjones's tip worked, thanks!
Heh, well, unfortunately, "languages people know" and "languages with side-effect control" don't overlap well:-) In that case, I think I personally would start with the Go playground code, but with the understanding that I would be forking Go, with all that implies. You will have to make some modifications, and it will take a few iterations. But the Go codebase is a good choice for that. It's very readable.
&gt; The caching does not impact me because Iâm actually taking the same program and running it on different systems. they had to cut quite a bit to make that happen: https://blog.golang.org/playground in vanilla go, try to run that: package main import ( "fmt" "os" "runtime" "time" ) var a int func main() { go func() { for { a = a + 1 runtime.Gosched() } }() go func() { time.Sleep( 10000) fmt.Printf("Count: %d\n", a) fmt.Println("Hello, playground") os.Exit(1) }() select {} } it will return different value every time, and in different range depending on cpu type and load 
 apt install nodejs apt install docker apt install mongodb npm install express npm start now my phone is web scale
Also note that you're shadowing your globalâfix this by assigning to your global rather than init-and-assign: var err error // Note the '=' and not the ':=' session, err = r.Connect(r.ConnectOpts{ Address: "localhost:28015", // Database: "coffeehouse", DiscoverHosts: true, })
Just a few comments: var cookieHandler = securecookie.New( securecookie.GenerateRandomKey(64), securecookie.GenerateRandomKey(32)) This is almost always a bad idea. Every time your application restarts (or crashes), you generate fresh keys: meaning you can't decode sessions from five minutes ago. All users are effectively logged out at once. You want to generate static keys and serve them from a config file (out-of-repo) or environmental variables. if encoded, err := cookieHandler.Encode("session", value); err == nil { cookie := &amp;http.Cookie{ Name: "session", Value: encoded, Path: "/", } http.SetCookie(response, cookie) } You probably want to explicitly return the error here (typically from a MAC or timestamp failure) rather than just doing nothing. I totally get the motivation behind writing short, concise tutorialsâbut you might be erring a little too far on the side of brevity here.
Caught this while compiling :) Go's compiler rocks.
Hmm that's useful. Since GoRethink pools connections, don't I need to start the pool somewhere? If I just call `Connect` inside my view functions then there's no guarantee that they're pooling, right? They might just be opening new connections since there's no earlier connection hanging around. 
I'm pretty sure it starts the pool implicitly when you first call connect.
It sucks Indeed. I don't know. Maybe I'm terrible at expressing myself like what you have said. The thing is, they never even call me or email me back. So I have 0 interviews. I plan to build something bigger than this, maybe scarier so someone can see I really know what I'm doing and not bluffing.
&gt; The thing is, they never even call me or email me back I've been there. I think networking is important too. I'm really bad at that outside the work environment. Keep up the good work and you will land a job eventually.
You can build Android apps in Go. Now you can run Go inside Android apps. Circle of life complete.
You probably aren't quite testing what you think you are. I added a "Benchmark_nodefer" that measures not using defer (i.e., `c.l.Lock(); c.i++; c.l.Unlock()`), and also added: func BenchmarkBareLoop(t *testing.B) { for i := 0; i &lt; t.N; i++ {} } func BenchmarkBareIncr(t *testing.B) { var counter int for i := 0; i &lt; t.N; i++ { counter++ } } for comparison: __Edit__: Per suggestion, added BenchmarkAtomicIncrement, which uses atomic.AddUint64: $ go test -bench . PASS BenchmarkLocked_add-4 10000000 160 ns/op BenchmarkLocked_nodefer-4 50000000 32.9 ns/op Benchmark_noMethodCall-4 50000000 30.5 ns/op BenchmarkUnlocked_add-4 1000000000 2.66 ns/op BenchmarkAtomicIncrement-4 100000000 11.1 ns/op BenchmarkBareLoop-4 2000000000 0.89 ns/op BenchmarkBareIncr-4 2000000000 0.89 ns/op ok _/home/jerf/tmp/gomutex 12.820s Approximately 75% of the observed slowdown in `BenchmarkLocked_add` is the defer, not the lock. Also, since people are often not used to seeing numbers scaled like this, remember what 30ns is; something that takes 30ns can be done 33 _million_ times a second. I was once writing some code where I considered making two code paths, one using locks when necessary and one using no locks when the user could guarantee that was safe for me, but since the basic operation the code was locking around generally took several dozen _microseconds_ in the fastest possible path, the locking was literally lost in the noise. (Also, contention turns out to be highly unlikely in practice, for various reasons. Just not quite impossible.) Be _really_ sure that locking is your problem, with lots of good profiling that really conclusively fingers the locking itself, proving you're locking and unlocking literally _millions_ of times per second, before you leap to the conclusion that it's a performance problem on its own. 30 nanoseconds is very small number, and while it _can_ add up if you manage to do it several million times per second, it takes a _lot_ for it to do so, because it doesn't take very much other work going on measured in microseconds before the lock management is not even remotely your biggest problem. To say nothing of _milliseconds_. In fact, profile before leaping to _any_ conclusions about performance problems. (And to be clear, I'm talking about the management of locks themselves. Having over-large critical sections is a different problem entirely. Locking could be completely free and that would still be a problem.)
Aren't you supposed to defer your unlock before you lock?
It's bad to own that directory because any program that you execute will _also_ have RW access to that directory. So you essentially open that area of your system up to any arbitrary executable you download and use.
Nevermind! It was a thread exhaustion. Thanks for the awesome work, I guess we can see you are thread safe :)
No, I havent written any project in C or C++. But I have done projects in Java,PHP and Python but its long ago before I migrated to Go and I didnt share them on github. I do have ruby projects( even had a gem that have been useful to many people.
thanks for the advice. Yes almost anyone I came across here has no clue what golang is. I have just givenup the idea of getting a job here. My plan it to keep implementing my ideas, till find a good one to use as my busimess.
It's not strictly necessary to do that...
Yes. Correct. But I don't download and run stuff arbitrarily, and neither should anyone. In the case of OSX users we often use homebrew.
A defer is a statement that can be executed at any point in a function. It dynamically allocates a closure. I think it's possible that the compiler could be made to optimize unconditional defers at the start of a function but it currently doesn't. 
Your benchmarks should include concurrent calls to *locked.add.
Why is the returned `body` a `string`? This should be an `io.Reader` I think!
Ooh. I'd started implementing mine from scratch, so now time to rip that out :P Are there any similar packages I should be looking at before picking this one?
Two out of four benefits mentioned on the front page are about not having to use **environment variables**. &gt; - No enviroment variables to set &gt; - Multiple working copies without changing environment variables Is this really a benefit or just a personal preference?
Seems like cgo doesn't work. Or can I just apt the missing things? NVIM_TUI_ENABLE_TRUE_COLORS=1 nv ht.go $ go run ht.go # runtime/cgo exec: "arm-linux-androideabi-gcc": executable file not found in $PATH
that's probably more a C-syntax vs Go-syntax comparison than a L2R vs R2L comparison Better: var x []func() int // Go L2R (int func()) x[] // Hypothetical Go R2L [](int func()) x // arguably more Go-ish I dont see any advantage L2R. 
I think it's a stretch to say most of the time applications have no panic recovery. Most apps I've worked on have had panic recovery some place. If you use net/http, you have panic recovery. Having another type of defer statement wouldn't make any sense. How do you know whether your function will be called in a context which has panic recovery further up the stack or not? In the vast majority of cases the overhead of defer is negligible. In the other cases it's usually possible to restructure your code not to use it. 
We forget these usability truths as we grow and are exposed to decades of weathered computation tooling. Good on the Go team for finding or keeping their young selves. The positives described in this writeup are a big part of why I am using the language.
I think the clearest explanation of their motivation is in the FAQ. The Go authors agree that vendoring, taking a copy of your dependencies, is the path to repeatable builds â we just disagree on the method. The Go authors are recommending vendoring by copying the source of your dependencies into a folder inside your package, then rewriting the source of those vendored depdendencies to accomodate. gb also recommends vendoring, but with its project based approach, it can give the same result â all dependencies are bundled within the project, without rewriting the source code. This is important, and I believe other Go programmers agree. 
If you could share a PR of your current state it would be a great way to allow people to make inline comments and collaboratively review your code. I have some comments but would be more inclined to share if there was a PR.
Pull Request; It's how all discussions on GitHub usually get started
It might also be interesting to compare to [`atomic.AddInt32`](https://golang.org/pkg/sync/atomic/#AddInt32) (and/or [`atomic.AddInt64`](https://golang.org/pkg/sync/atomic/#AddInt64)). Which is how most simple counters are synchronized. (But as /u/jerf says, you also need to be comparing against the non-defer locks for it to be relevant).
A pull request is a proposed change to a repository so it consists of the difference in commits between the proposed branch and the target branch. In your [recent PR][0] the net change between the all the commits and the master branch is zero. That is why there is no change. Why don't you try creating a branch, writing your unit tests as suggested above, push this branch and create a PR that targets master and uses your unit test branch. It would be a real example that walks you through the process. [0]: https://github.com/Gacnt/mysqlOpenID/pull/1
That gets trickier... this is all in one thread. If I understand them correctly, spinlock performance is only interesting in the presence of contention.
In general, I don't suggest `defer`ing a cleanup statement until the resource has been acquired. In this case, lock acquisition can't really "fail" (if it does, it does so by locking forever and the defer won't be run anyhow), but in the general case, if it somehow can, you'll be deferring a function that may be running on an uninitialized or partially initialized resource.
I get this gcc arm-linux-androideabi-gcc $ cd $ go run ht.go # runtime/cgo /data/data/com.termux/files/usr/tmp//ccLkp1B1.s: Assembler messages: /data/data/com.termux/files/usr/tmp//ccLkp1B1.s: Warning: end of file in comment; newline inserted # runtime/cgo /data/data/com.termux/files/usr/bin/ld: cannot find -lpthread collect2: error: ld returned 1 exit status If you want to know how to easily reproduce this, just import the net/http package
This maybe sound funny but check if your email really works. I have had my email not sending anything for a couple of months and thought I am getting rejected everywhere but in fact none of potential employers ever got any email from me ;)
This is 'cute' behavior, but I think the inconsistency is harmful to the language IMO. What inconsistency? Well, sometimes this shorthand doesn't work. Example: a map with struct values (not pointer to struct). Map values are not addressable. Methods that work on Foo do not work on map[string]Foo. Worse, with methods like String(), many callers will fall back on some default behavior and do The Wrong Thing. My guidance: Never use a map with sruct values, and always define methods in structs with pointer receivers. Frankly, a "method" with a non-pointer receiver is not a "method", it's a "function". Further opinion: Go's lack of const-pointers or clear pointer own/loan status hurts the language, as does their guidance to not call method receivers "this" or "self". 
I wish this was simpler in go. sort.SortByKey(people, func( p *Person ) { return p.Age } ) Guess that needs generics though :(
Before Python had key functions, this was called "decorate sort undecorate".
As you've more or less stated, the `sort` package assumes that you'll be sorting items based on their values, or values that are at the ready. You don't go into too much detail about exactly the kinds of values or objects you were sorting, and why their "true value", which is apparently some int value, wasn't simply precomputed and already available. But I can believe there are good reasons for it; perhaps that value is simply never necessary after the values are in order. Going back to this "Schwartzian transform", it's a nice idiom in Perl for sure. But even in Go, the general approach is pretty sound. All you're doing is making a new list of values easier to compare, each value corresponding to an element in the original list, and sorting by proxy. Here's an example of a generalized way of doing that, applied to your example: http://play.golang.org/p/ph2EOXC9pd One of the major advantages of the `sort` package's approach with its `Interface` type is that it lets one defined type act upon itself without bothering with a great deal of `interface{}` conversions. For example, it's really cheap for the IntSlice type to compare two elements with `x.Less(i,j)`. Must less expensive than calling `x.LessVal(x.Key(i), x.Key(j))`, even if your key values have been cached. Take that advice as you wish. But, concretely, there are some things in your approach you should fix. You're really not gaining anything but complexity by trying to lazily initialize your Key values, because you will need to compute all of them. It also doesn't make much sense to use a `map[int]T` when the values of your keys are bounded, and you expect to use all values of 0..N. In short, use a slice. By using a slice, you can "prime" all your values in parallel without worrying about synchronizing access. 
Your general idea is fine, but your Less implementation is not going to behave how you expect. You'll want something like this: func (s sortPeople) Less(i, j int) bool { a, b := s[i], s[j] if a.Age != b.Age { return a.Age &lt; b.Age } if a.Name != b.Name { return a.Name &lt; b.Name } return a.Phone &lt; b.Phone }
Yup, too hasty an example.
Like anacrolix mentioned Go will cleanup your fds. However, most operating systems will clean your mess up once your process exits.
My first attempt at a bot was [here](https://github.com/Vaultpls/Twitch-IRC-Bot) then I tried to make it into a framework after I made the bot itself which sort of screwed me in the end. Spaghetti code and all and a ton of other things with no organization occurred. Today this changes with my new project! Hopefully I can continue this type of coding style.
Thanks! Forgot about that one.
I don't disagree with what you said, I just wish it was simpler. I'm not an expect on the finer points of types an interfaces, but couldn't go implement an Orderable interface for types to enable this sort of thing? I think that is how things work in something like haskell with `Ord`... fmt.Println(1 &lt; 10) fmt.Println("bob" &lt; "alice") works, but you can't write func isLessThan(a, b: Orderable) { return a &lt; b } Is this the generics issue again? I don't really care what it is called, just that writing sort.SortByKey(people, func( p *Person ) { return p.Age } ) sort.SortByKey(people, func( p *Person ) { return p.FirstName } ) sort.SortByKey(people, func( p *Person ) { return p.LastName } ) shouldn't be any more complicated than that. Go knows how to sort numbers and strings, I'm giving it a function that converts from a Person to something it already knows how to sort. Why can't it just sort it? I have a feeling I am going to get downvoted again for using the work 'generics'.. I bet that in a year or two this will be possible and people will say things like "Remember when we had to write 10 lines of code to sort arrays by different things?" Your `SortByProxy` is nice though, I modified it for the Person example. It gets things down to: proxy := make([]int, len(needsSorting)) for i := range needsSorting { proxy[i] = needsSorting[i].Age } SortByProxy(needsSorting, sort.IntSlice(proxy)) fproxy := make([]string, len(needsSorting)) for i := range needsSorting { fproxy[i] = needsSorting[i].FirstName } SortByProxy(needsSorting, sort.StringSlice(fproxy)) Then I wrote: func (pl People) BuildStringProxy(tf func(p *Person) string) sort.StringSlice { proxy := make([]string, len(pl)) for i, person := range pl { proxy[i] = tf(&amp;person) } return sort.StringSlice(proxy) } Which gets it down to SortByProxy(needsSorting, needsSorting.BuildStringProxy(func(p *Person) string { return p.FirstName })) SortByProxy(needsSorting, needsSorting.BuildStringProxy(func(p *Person) string { return p.LastName })) Which isn't too far off from what I would like to see.
I miss answered anyway. If the application crashes, the OS cleans up. No leak.
Is it not the case that the key must b e calculated for every element to be sorted? If so, why not just calculate all the keys at the start? You don't need the caching logic then.
Isn't it more like a simple irc implementation to connect to the twitch chat? Why not use an existing IRC lib and build on top of it.
Yup -- it already does that $gb vendor help gb-vendor, a gb plugin to manage your vendored dependencies. Usage: gb vendor command [arguments] The commands are: fetch fetch a remote dependency update update a local dependency list lists dependencies, one per line delete deletes a local dependency purge purges all unreferenced dependencies Use "gb vendor help [command]" for more information about a command. Additional help topics: Use "gb vendor help [topic]" for more information about that topic. 
This isn't a route though. Like I'm not setting the route for my own get request It's a returned url string from an openid request 
"sort" is a really interesting case, because it shows off both the parts of generics that Go does have, and shows off the parts it does not. Contrary to popular opinion, Go does have some "generics", in that interfaces can provide "generic algorithms" ignorant of the underlying implementation, which the sort package does. What it does not have are generic types. (This isn't rhetorical slight of hand trying to make Go look good... in my considered opinion it's actually important to understand that "generic" is not an atomic thing on its own and consists of many parts, or you don't really understand how to use them in any language.) Consequently, one of the answers to the question "How can you program in a language missing generics?" is that it's only half-missing generics, and arguably has the more useful half. (And arguably does not. I mean the "arguably" literally.) Lack of generic types has a lot of consequences here. One of them is that trying to reuse `sort` code is actually a pain because it's virtually impossible to express the 'real' types. The other one is that because of that, the real "Go" thing to do here is to... not. When you can't use the type system to reuse code, Go's pragmatism is that maybe you just need to duplicate a bit of code.[1] The Keysort package should go ahead and simply provide its own sorting routines. Start by copying &amp; pasting the sort code if you like. It's OK, it'll end up diverging enough to make it worthwhile. Then you can fix all those other problems you mention, too. It's OK. It is not part of the Go philosophy that, having provided "sort" in the core library, you must always and only use that sort. It's the Go philosophy that you ought to have a really good reason to use another implementation and not just reach willy-nilly for half-a-dozen sort routines because they're cool or Web Scale, but if you really do have the need, go for it. I suspect you'll find quite a few things you can do that makes this approach work better for you. Also, regardless of the fact that it's called `sort.Interface` in the core library, I would consider calling an interface `Interface` to be a code smell, as silly as `type Struct struct`. That's just old Go code that can't be changed now ([copyright shows as 2009](https://golang.org/src/sort/sort.go)) but probably shouldn't be copied. [1]: To be honest, this is where Go's pragmatism and I have some disagreements, but I'll concede it works better than I'd expect. Still, Go is clearly not averse to some copying and pasting, and my current score for "core libraries I've copied and started modifying for some very good reason" is at 3. It turns out that they can provide a really nice base of working code for you to mutate if you need to... the vast bulk of them are quite nice under the hood, and well covered in unit tests, and it's been a pleasure to start with them rather than start from scratch.
It's a good answer nonetheless, thanks.
What's about wgo ? It use go tool IIRC 
https://play.golang.org/p/Y-qeGzy15q
The "not relinking every time" fix is a Big Deal.
it's not canonical, so you may have to write your own parser: ```canonical urls: scheme://[userinfo@]host/path[?query][#fragment]``` or you can parse the url with net/url and write your own parser for just the URL.Path and decode it to whatever data structure you want from there. edit: here's a quick playground: http://play.golang.org/p/qLag2qXR99
Split on / and zip odd-even elements into a map ?
Regex... the computer equivalent to black voodoo.
yeah I didn't know about it until recently either heh. it's pretty cool especially since it's one of the very few ways to easily do encrypted transmission
Try this out. Please let me know if anything needs correction/improvement. https://github.com/codemodus/parth Edited to add: Benchmarks are provided comparing available functions with the typical alternatives. And... path.Base() is just slightly faster for looking up the final segment (42ns vs 51ns in parth). Parth would be useful in the case that you would like to leave the string to (whatever) type parsing out of your code, and/or in the case that you need to lookup by positive segment indexes or negative segment indexes lower than -1.
Gorilla mux handles this pretty well
Yep, almost definitely `path.Base` then. More complicated cases can use `strings.Split` (and its variants) and manipulate the `[]string` returned.
It is indeed the case that the key must be calculated for every element. This is essentially the same thing as calculating them all at the start, the two options are essentially refactorings of each other. Explicitly calculating them at the start will require similar constructs to my 'caching' example above, you still need a place to store the results, but now you also have to explicitly iterate over the whole set and call it. Either method is fine, but I think this way is slightly cleaner, and saves you the +N on your explicit iteration.
Hi, This is my first time using concurrency patterns. I doubt this would be useful to anyone outside the Mac SysAdmin community, but I'd appreciate any feedback on the way the process() function is structured. https://github.com/groob/autopkgd
See [motemen/ghq](https://github.com/motemen/ghq).
this was just a rough implementation, now you have said that, I think an io..Reader will be better. But Im kind busy, would you submit a pull request If you don't mind? Or open an Issue with an examplle Implemntation? That way It will be helpful to me to see what benefit an io.Reader will bring over a string. Thanks. 
sorry, but would you show me an example please? Thanks.
Not really using Macs for servers. I manage many OS X workstations/laptops. One of the constant annoyances with managing end user machines, is having to know when a new version of Chrome, or Flash etc has been released. [Autopkg](https://github.com/autopkg/autopkg) is a tool used to automatically download new versions of software and add them to a repository.
&gt; ReverseString is very allocation-heavy http://stackoverflow.com/questions/1760757/how-to-efficiently-concatenate-strings-in-go FYI for OP
Thank you very much for your feedback :)
Ahh makes a lot more sentence. I read sysadmin and my mind jumped to server sysadmin. 
you worded your question as if its a route and not a string. if its a string, just split it.
Checkout https://github.com/sabhiram/go-wol It is a completed application with storage and aliases. It is my primary wol driver in a several environments. Your code coverage and testing seems better, but I like the storage/alias mechanisms used in go-wol. Maybe think about ripping that piece out and adding to yours. Looks good though.
i did, was just pointing out where the logical break that causes answers the be given for the wrong/incomplete question you are asking. people tend to read up to the point where information is given and stop when the little footnote-notes are added. what i am saying is, for a number of people, they may have stopped reading when they saw the "()"
The usage would look something like: // FrontMatterData would be a struct type with fields for values you'd want to read in var frontMatter FrontMatterData m := front.NewMatter() m.Handle("+++", (&amp;frontMatter).HandleFunc) // I'm not sure if the dereference would be necessary here err := m.Parse(anIoReader) You'd handle the error if you needed. The anIoReader would be left with the rest of the contents unread and frontMatter would contain the read data. Unless you want the same `m` to be reused multiple times it might be a better idea to roll all of this into a single function though.
Fair enough!
the MD5 function actually calculates a SHA1 hash?
`PseudoUUID` is not returning valid UUIDs. [A randomly generated UUID needs to have specific bits set](https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_.28random.29).
It's "MD5 encription"[sic]!!
Seems kind of silly to use Gorilla for session management without including [sessions](http://www.gorillatoolkit.org/pkg/sessions).
Have you seen https://github.com/sourcegraph/rwvfs? How do the interfaces compare? Maybe we could make them compatible, and have both httpfs and in memory fs.
This is an excellent resource, I just added it to my bookmarks. Thanks! It would be interesting to see how many of these take advantage of Go's concurrency mechanisms instead of just C/P from other languages.
Zigging instead of zagging, I might suggest: base := "http://steamcommunity.com/openid/id/" if strings.HasPrefix(url, base) { return url[len(base):], nil } else { return "", errors.New("Unexpected ID format in return") } Morally speaking, you're basically OK treating the prefix as an opaque blob that you choose not to understand, and as long as you see it, just chopping out the ID you want. You're safe with that because you'll check to make sure that the correct blob is there. This technique is virtually guaranteed to be a bug without that HasPrefix. (Which I may have backwards, I'm not looking it up.) The reality is that if the URL that you get back changes in any way at all, you want the error, not code that unconditionally just takes the last bit.
https://github.com/beorn7/perks might also be interesting. It's a fork of http://godoc.org/github.com/bmizerany/perks with some bug fixes. It offers an efficient streaming quantile implementation, as well as topk and histogram functionality. We use the streaming quantile implementation for the Summary metric type in Prometheus's Go instrumentation library: http://prometheus.io/docs/concepts/metric_types/#summary
Native-go parallel matrix multiply uses channels and goroutines. The rest of blas/native is serial at the moment https://github.com/gonum/blas/blob/master/native/dgemm.go
my router doesn't support ssh. Would telnet work?
dd-wrt usually has ssh running, are you sure you are running [dd-wrt](https://www.dd-wrt.com/site/)? 
Well I'll be.. the http package works! You're the man.
It's cool that you did this, but it seems like an awful lot of code to pick a random element in a list twice. Doesn't the whole thing just boil down to... var ( adjs = []string{"amazing", "super", "good enough"} nouns = []string{"jonathan", "man", "person"} ) func randItem(list []string) string { return list[rand.Intn(len(list))] } func generate() string { return fmt.Sprintf("%s %s", randItem(adjs), randItem(nouns)) } 
&gt; Do you have any better idea to tell the GC that there is a live reference in there? Could be handy indeed, but currently there's no way except storing the pointer in a global map somewhere, AFAIK. The authors of latest bindings into Java use this technique, see the Â«Reference tracking between Garbage CollectorsÂ» section in https://golang.org/s/gobind &gt; To manage this, when the generated stub code attempts to pass a pointer from one language to another, it registers it with a global map maintained in the objectâs host language. This map provides a unique reference number which is passed to the target language. I hope this issue would be addressed as soon as things with GC will calm down over a few more releases of Go. By the way, what's the performance penalty of using the map approach? Without any evaluations it's hard to say that telling GC about any "live reference" will perform better than plain maps.
Netcat will usually work if you just want to transfer a file 
You would have to use "something" to get the binary there. And chmod it executable. But, then it should work. 
&gt; since every payload will go into the heap anyway, so you might as well use the "boxed" interface{} version to discriminate with a type switch. Sometimes I like to call Go a modern scripting language. For a scripting language, Go gives you a significant amount of control over whether something ends up on the stack or heap, given that up until pretty recently all scripting languages put everything on the heap, unconditionally. However, for a systems language, Go gives you essentially no control where something goes, or at least not with any reasonable degree of effort. And you'll always be at the mercy of any changes in future releases. Go isn't really suitable for tasks where you care about that very deeply. The way I see it, you've got two choices: Care less (no sarcasm!), in which case, yes, the `interface{}` solution is basically as good as you're going to get. Since you've budgeted a full `int` for the tag you might as well let that be a runtime-managed type pointer anyhow. Or, alternatively, don't back to Go. Honestly, I lean with the second one. I question the long-term viability of any project built against Go in its current state, precisely because you care about a lot of details that are in _massive_ flux right now. If things stabilized in another 3 years you might be OK, but you're in for a world of pain trying to keep up with Go as a moving target right now. This is only the first of many places where Go is going to fight you. Go's runtime is pretty deeply Go, and lacks the abstraction that something like the JVM has where there's this bytecode layer between the language and the runtime. There's a reason people like to back to those. The crazy wild-card alternative is: Fork Go. Be unafraid to reach in to the internals and _make_ it do what you want. If you're interested in implementing your own language, you should have the requisite skills to do that. Go's internals are as clean as any language implementation I've ever seen. Basically, the idea being if you are going to find yourself unable to track Go's evolution going forward, then you should at least _reap the benefits_ of that as well and make changes that suit you. Trying to stick to "pure official Go" kinda ends up being the worst of all worlds.
good call, hadn't thought of that.
Thanks.
Yea, I'm not meaning anything negative to the project. The output looks great, configuration seems to be decently extensive. I like the (mentioned in another comment thread) ability to use the default log and continue to get this - the only part that I don't really understand is why so much text processing was chosen. 
Eh, not sure what you are looking for since the bit that isn't implementation specific is just like few lines of code. Here's how you make a listener. http://golang.org/pkg/net/#example_Listener Just replace the go function with your own handler function.
Thank you. I have seen examples of this a bunch but was wondering if there was other things I was missing. If I was missing something, I was hoping for an open source one that tied it all together. If there isn't, I will probably play around with this and use channels to communicate with the main go routine to keep things synchronized. Thanks again for the help.
In the blog post (maybe I should have submitted that instead) there are some benchmarks than you can run locally. BenchmarkLoggerNoFlags-4 3000000 404 ns/op BenchmarkLoggerWithFlags-4 1000000 1314 ns/op BenchmarkCoLogPlainNoFlags-4 1000000 2023 ns/op BenchmarkCoLogPlainWithFlags-4 300000 5008 ns/op BenchmarkCoLogPlainWithFlagsAndFields-4 100000 16337 ns/op BenchmarkCoLogColorNoFlags-4 500000 3447 ns/op BenchmarkCoLogColorWithFlags-4 200000 6465 ns/op BenchmarkCoLogColorWithFlagsAndFields-4 100000 18200 ns/op It's actually not that much, specially if you don't activate the regex for key-value extraction, and I'm sure there is a lot of room for performance improvements. The standard log only gives you bytes, so any feature you want to add to it needs to come by parsing those.
The colors are just a detail are only there when you run your program manually, non-terminal outputs are plain text. You can also plug other formatters like JSON. Plus, the main selling point of leveled logging is that you can log only your errors in production, although I do indeed know several people who log everything.
With the upcoming golang 1.5, would you avoid the need for the cross-compile toolchain?
I will have a look at it :) I guess it's no problem at all, only a small Glue wrapper is needed
Thanks for your feedback! You're right, the code is very simple and actually looks very much like yours. It might get more complicated in time though, using more dictionaries, and other string combinations.
It's easier to fork and change gccgo in this case.
Used: LiteIDE, IntelliJ IDEA Currently using: Atom, VIM
Atom + go-plus + project-manager
Eclipse + Go Plugin.
Thanks for the response. I should probably have mentioned that using Go as a target is only meant for prototyping. It's not a big deal if I have to _care less_ at this point. I'd like it to resemble an actual "C" tagged union, so that I have a more meaningful prototype, but it would do anyway. Later on, if the language were to get more serious, I could consider forking and tweaking Go's runtime, but I think it would make more sense to write a runtime from scratch for this language idiosyncrasies.
vim + vim-go
I've posted before, that's why I'm confused about this...
emacs with go-mode, goimports, and gofmt hooked onto file save and some plugin I forget that lets me inspect or jump to symbol definitions. I also wrote a yasnippet template for if err != nil which I use endlessly.
Now I'd found some time to test it. I've a pkg conflict on FreeBSD for heimdal, so I tested it on Ubuntu 14.04 (both heimdal and MIT is installed). go get github.com/apcera/gssapi works fine without any messages. As far as I understand your implementation, I need to load the library first to get a *gssapi.Lib to work on. Unfortunately this tries to load the MIT lib instead of heimdal which fails: _, err := gssapi.Load(nil) fmt.Println(err) -&gt; libgssapi_krb5.so: cannot open shared object file: No such file or directory So I had to manually add a link to libgssapi_krb5.so.2.2 and after that it's working. I made a test web server and I can authenticate via kerberos tickets. It's low level fiddling with gssapi and the server startup is quite slow, but at least it's the first working lib [for Golang] to handle kerberos authentication. Thank you. :)
Atom + Go Plus
Use Interface: http://play.golang.org/p/bdjNjGSKLr All (known to me) ML languages allocates their Algebraic Types on a Heap. So that, Golang will be on par with them. Edit: fixed url Edit: fixed url again
á( Í¡Â° ÍÊ Í¡Â°)á Am I such a minority? The choosen one?
I really want to use atom but its text rendering is so awkward to look at.
The go plugin devs from Intellij presented a lightning talk at gophercon 2015. When asked if there was a roadmap to releasing an official IDE for go their answer was a simple "no".
vim with vim-go and Sublime Text with GoSublime. I end up using Sublime Text more when it's not a project I started, just because I don't have anything in my head about how to navigate a project yet and Sublime tends to be faster for getting that.
Emacs with go-mode. 
You should note that this isnât actually doing the GeoIP lookup in Go, but instead using a service that provides the lookup over HTTP.
&gt; print source code Why would you need to print your source code?
I disagree on many points. The post largely boils down to Microsoft Windows semantics are often dumb/limiting and Go doesn't work around them in all cases. In particular, when a program needs a temporary file but after creation doesn't need to refer to it by name, then on a real OS the best way to do that is to immediately unlink the directory entry after creating and opening the file. That minimizes the window during which the process stopping uncontrollably (think SIGKILL) will leave the temporary file around. After the file is unlinked, the program can continue to write, read, seek the file descriptor indefinitely as desired without further worrying about clean up. IMO Microsoft's failure to allow a way for an open file to be deleted is the bug (and it causes all kinds of silly problems such as issues upgrading a running program/service).
Feature wise LiteIDE is by far the best. You name it, it supports it. For example it will show symbol info including the remarks (not only the function definition). Refactoring works well and very fast. However, I do not really like its layout and design. To much screenspace is wasted on bars that are to wide and its not as tweakable. And then there is also the question of continuity: there are some small bugs but there has not been an update for several months now. I now use Atom + Go-plus although its not very responsive and has almost no special features (compared to LiteIDE). I try not to use other packages because they will break of even slow it down more. But I like the design and layout :-) And I know it will improve and still exist in the next years. 
To read. Was that not obvious?
Textmate + Keyboard Maestro + TextExpander + Alfred + Dash
TL;DR * Static memory allocation * easy paging (so it's fast) * support for multiple keys to a value * tools for benchmarking your particular application (see which configuration is best for you) * lots of inbuilt replacement algorithms (or implement your own) for your use case * LRU * Time Expiration * Round Robin * Random Replace * Second Chance I originally built it because we wanted a way to cache users by their API key, name, email and id without messing around with keeping multiple caches up to date; but it turned out faster than golang-lru, so we started using it everywhere!
Just check the source of net/http for an example.
I'm not disagreeing with the uselessness of syntax highlighting ;-) Nor is appealing to authority that great of an argument ;-)
But appealing to **knowledgeable** authority is.
o_0 but the trees!!! Seriously though you're the only person I know who does this... But whatever works.
I mean go-sublime, vim-go and the likes bring to you everything you'd need in an IDE to an editor. Edit: s/vim/editor
Use an `init` function to initialize these variables.
Example please. I've tried so many variations. Here's mine: var Thing *template.Template func SetupHandlers() { Thing, err = template.ParseFiles(baseTemplates...) } This gives the error: &gt; undefined: err
So for this case there is actually a file_flag_delete_on_close that can be used during creation of the file handle that will do as it suggests and once the last handle is closed will delete the file.
Mobile apps for VCS systems or responsive Mobile VCS sites usually enable reading for me. I'd rather have to scroll left and right than manage pages of code and making sure they remain organized.
Definitely, glad to help. So if you pass a `nil` config struct to `gssapi.Load( ... )`, we sort of "guess" library locations. You fell into the section case statement [here](https://github.com/apcera/gssapi/blob/master/lib.go#L220-L233). What you want to do is initialize a `gssapi.Options` struct with `LibPath` set to the library location. For instance, my `kinit` is in `/opt/local/bin`, and my corresponding `gssapi` library is in `/opt/local/lib/libgssapi_krb5.dylib`. Because we do dynamically load (via `dlopen`/`dlsym`) the library headers, it's best to be explicit on that. One word of warning: we haven't done much testing around the thread safety of the package. So, let us know if you run into issues around that, if that fits your use case. Thanks for trying out the library.
in vim-go it is just using :GoDef(gd) and then ctrl+o to go back :)
I've never found the appeal of running tmux, specially for vim. Then again, I am running a tiling window manager; but tmux being limited to one window and vim having buffers and tabs, what's the benefit?
I disagree with syntax highlighting and find it distracts from everything with candy and fireworks.
https://golang.org/doc/effective_go.html#init var Thing *template.Template func init() { var err error Thing, err = template.ParseFiles(baseTemplates...) if err != nil { panic(err) } } 
I prefer programming remotely in SSH most of the times (multiple computers, no need to commit/sync after every change). If you keep the Tmux session running on the remote machine, not much set-up is needed before you can start programming. Your windows and all are still in the same layout and are in the same state. Just connect, open Tmux and you're good to go. You could even borrow someone else's computer. But I'm not using a tiling window manager still. So maybe that's why I like Tmux so much. On-topic: I'm using Vim with Vim-go, without some extra features like auto completion and auto-importing of packages.
There's another one that I've used (will edit later when I get can to my source and take a look at it), but I prefer this method over http lookups because I've found the speed to be much better, and you get the consistency of not having to worry about a site being down, etc. 
I'm honestly not sure what the difference is these days - it's just a bunch of text windows and keyboard shortcuts either way. 
Emacs with go-mode and other things that execute go-fmt on save, and compile the project showing the errors on save or change.
Apparently my only error is thinking err is already defined by template/Template. The examples I've been following all use 'err' so I made that assumption. Anyway, just adding 'var err error' solved all my issues. Thanks.
Yes, you could call it personal preferences, but the science has shown differently. Different colors grab your attention in different ways. A multitude of colors is the bain of publishing and the web. Advertising uses color to distract you from things. And on and on and it's too much to go into.
Use [template.Must](http://golang.org/pkg/text/template/#Must)
Your variable `err` is undeclared. Try this: func SetupHandlers() { var err error Thing, err = template.ParseFiles(baseTemplates...) }
Acme, Go tools and custom tools
Emacs. Gofmt on save. With gofmt set to goimports which does both formatting and imports cleanup. ;; go get -u github.com/nsf/gocode ;; go get -u code.google.com/p/go.tools/cmd/goimports ;; go get -u code.google.com/p/rog-go/exp/cmd/godef (exec-path-from-shell-copy-env "GOPATH") (add-hook 'before-save-hook 'gofmt-before-save) (setq gofmt-command "goimports") (add-hook 'go-mode-hook (lambda () (setq truncate-lines t) (setq indent-tabs-mode t) (setq tab-width 4) (setq compile-command "go build") (local-set-key (kbd "C-c C-r") 'go-remove-unused-imports) (local-set-key (kbd "C-c k") 'recompile) (local-set-key (kbd "C-c C-f") 'gofmt) (local-set-key (kbd "C-c C-k") 'godoc) (go-eldoc-setup) (set-face-attribute 'eldoc-highlight-function-argument nil :foreground "green")))
Great start! Just a note on filenames and package names: We usually use underscore case (hello_world) instead of camel case (helloWorld)
Thanks! The get/put thing comes from me not liking to type fmt.Println and fmt.Scanf, and also from having learned Ruby in the past, but it's probably just a laziness that I should get over. 
Some favorite features that you get with intellij and not others is auto import, inline documentation lookup, and proper jump-to-source (even for external and core packages)
Thanks, I'll keep that in mind! What do you mean, blow out the stack? Sorry I'm a bit of a scrub. I'll do a quick rewrite later tonight, thanks for the advice! 
Same here! A must to go! ;)
My first reaction was the same as yours, use the precedence, map to 0, 1, 2, etc. Hacked up another way, without the abstraction of math. Perhaps simpler, at least to understand? func choiceCompare(choice1 string, choice2 string) string { if choice1 == choice2 { return "It was a tie!!" } if (choice1 == "scissors" &amp;&amp; choice2 == "paper") || (choice1 == "paper" &amp;&amp; choice2 == "rock") || (choice1 == "rock" &amp;&amp; choice2 == "scissors") { return "Player 1 wins!" } else { return "Player 2 wins!" } } 
You never _need_ an IDE. Sometimes you think you do but if work without one you'll find how easy it really is. 
Just because Rob Pike has done great things doesn't mean everything he thinks is golden or correct. Syntax highlighting is unnecessary but very useful when you have it. Anyone who denies that is lying. 
O(n) eviction seems a little scary once the size exceeds a cache line. Benchmarking with a maximum size of 3 seems very optimistic. fyi, you could implement BÃ©lÃ¡dy's algorithm in O(n lg k) instead of O(k n^2).
I tried to learn Go without "help", and I gave up within the first few minutes. I tried it with Lite and I'm attached. Having autocompletion and continuous linting is amazing for my sanity. 
 var Thing *template.Template func SetupHandlers() { Thing, err := template.ParseFiles(baseTemplates...) if err != nil { panic(err) } } In this case, the code will compile, but when you assign a variable using :=, like Thing, err := template.ParseFiles(baseTemplates...) *both* Thing and err are assigned to new local variables. The package global Thing is not assigned. This is [variable shadowing](https://en.wikipedia.org/wiki/Variable_shadowing). On the other hand, assigning with the = operator, like Thing, err = template.ParseFiles(baseTemplates...) tries to assign to already declared variables. Thing is defined at the package level. However, err is not defined yet, so you will get a compilation error. This is why we first define err, then use the = operator to assign to the local err variable and the package level Thing, var err error Thing, err = template.ParseFiles(baseTemplates...) A playground exemplifying this effect is [here](http://play.golang.org/p/wtWyBKVCjf). Hopefully this clears things up!
Thanks for sharing. 
https://golang.org/doc/effective_go.html#package-names
Well, I believe you're confusing the use of color in imagery to draw attention with colorschemes being distracting. I'd argue that precisely because colorschemes use color to draw attention to certain constructs, it's why it's easier for us to know their limits and reach.
What are you looking for? TCP is a general protocol. You listen on a port, accept connections, and data moves through this connection. It can be anything, JSON, HTTP, TLS, files etc. You can take a look at https://github.com/aubble/goChat which is a TCP chat server for an example. Its not that well documented but the code is well written. Take a look at net/http for a HTTP server etc. In the end TCP is just a general protocol. You should google some networking books/concepts to get a better understanding. Trust me, it will help a lot.
You can get around autocompletion by just using the language consistently and you'll begin to memorize things. I'm really looking forward to Go 1.5s introduction of `go doc` so that I can ditch dash/godoc.org. Ultimately I get around a need for autocomplete by referencing documentation constantly. When I do have autocomplete (such as when I work in C# or something like that) I find myself generally referencing docs even after find something in autocomplete menus as the only real benefit I've found from autocomplete (and seen from other developers) is to save those too lazy to type out code constantly. So, based on personal experience, the "requirement" for _help_ is strictly artificial and something you forced upon yourself mentally. I'm sure you're capable of doing things without _help_.
&gt; Having autocompletion and continuous linting is amazing for my sanity. They do already answer you _slightly_.
package names aren't supposed to have underscores either, although people break that rule. see: https://golang.org/doc/effective_go.html#package-names go lint actually has a package "name with underscore" warning: https://github.com/golang/lint/blob/14b90a5a5501db8773a53730d1f814ccb13271f6/lint.go#L507
Absolutely almost exclusively LiteIDE. Good stuff.
One option would be instead of `playAgain`calling itself in the case of invalid input, use a normal loop inside of `playAgain` where invalid input just causes the code to return control to the top of the loop and try again to get input. Hope this helps!
In the minority, Komodo
yes, it is. I just want to take advantage from free resources. Maybe I need to consider about a file on disk for self-host option.
Here is an explanation about this: http://blog.golang.org/gos-declaration-syntax
There's no need for a separate IDE, thr plugin runs an almost (if not all) IDEs from JetBrains,including the free version of IDEA. Is there a specific reason to want an IDE that ships with the plugin installed by default vs installing it on your own? 
github.com/dustin/go-probably
Another one here, I find Eclipse + Goclipse very convenient 
I saw a proof-of-concept demo video of neovim + asynchronous live-linting of go code. I can't wait until something like that gets integrated with vim-go
I would separate your learning curves. Vim is excellent, Go is excellent. Learning Vim or Go -- excellent. Learning a new language and a new editor at the same time tends to have an exponential interaction, making learning both (or either) significantly slower than if done sequentially. I would learn Go in an editor you are comfortable with, it is really easy to learn, a few weeks later you will know Go. Then I would dive into Vim, and a few decades later you will know a small fraction of Vim! 
This package is used by freegeoip. :)
That's right, the freegeoip package for Go provides an http.Handler that you can embed in any http server.
Author of freegeoip here. Great article, but keep in mind you don't have to read resp.Body to a byte slice and then unmarshal. You can do that directly by calling `err := json.NewDecoder(resp.Body).Decode(&amp;geo)` thus saving GC work.
No. Not color in imagery but color that attracts, or distracts, your focus. When you're reading an article, you don't want that article containing black lettering to be littered with red words and orange and blue lettering. Even spacing of letters and underlining of words can jump you off the track a bit, interrupting the flow or draw your attention to one particular word if that word is different from the rest. While that is the intention of color highlighting, drawing your attention, the problem lies with color schemes that highlight everything. If functions are blue and variables red while comments are green, it becomes a blur, a mishmash that no longer makes sense and gives a halting, stop-and-go to reading as every change in the rhythm of the color changes.
Acme, sam, and Unix. 
Yes, you're right, a nil config ain't the best choice. I'd set the keytab and relied on the doc which said otherwise the OS default will be used, which would be fine. You said you're using Heimdal as default (at least on FreeBSD you've set it as a requirement), but you start with MIT which become the default option if not explicit set to Heimdal. Maybe better documentation will help... ;) &gt; we haven't done much testing around the thread safety Thanks for the warning. I plan to replace a service written in Python which hardly handle the growing amount of requests. I need something faster and thread safety is vital. I have to do some performance tests and this will also show if there is an issue with the thread safety. I'll let you know, but I can't promise to test it soon.
Yes
Hey! Thank you for providing the service. Good tip! I didn't think about that.
Instead of using global variable running, id rather make playAgain() return boolean... your way is correct, but i prefer not to have globals unless i really need it. func playAgain() bool { put("Would you like to play again? (y/n)") var again string get("%s", &amp;again) again = strings.ToLower(again) if again == "y" { return true } else if again == "n" { return false } else { put("That's an invalid response!") return playAgain() } return false //Should never reach here.. but return is needed.. } if not playAgain(){ return //or break }
[vimcasts.org](http://vimcasts.org/episodes/archive/) Vim has many ways of managing your workspace (sessions, tabs, windows, buffers). I recommend you to start with ["Working with buffers"](http://vimcasts.org/episodes/working-with-buffers/) and ["The file explorer"](http://vimcasts.org/episodes/the-file-explorer/).
You never print *all* of the code, you narrow it down first. There's also the fact that text on paper is less straining to read. **Edit:** Not to mention that using marker pen on a TV is usually a big no-no.
There's "goimports" as a replacement for gofmt in all major editors to get a really simple auto import on save. It's definitely not as nice as Intellij's, but in practice it works really well. There are also plugins for godef on all major editors as well, which provide proper jump -to-source as well. There's no inline docs lookup that I know of, but godef seems to do the trick for me and Gosublime includes the method definition in the gutter so I can tell what types are required for a given function. The IDE integrations are nice, but I prefer the lightweight editors with the simple tools to add all the IDE-like features I need. Quick startup is a feature that intellij just can't match right now. 
lightning talk: http://youtu.be/3sy0hR0BIiM
Pretty similar to everyone else. When I was newer and more worried about learning the language than an editor as well, Sublime with GoSublime worked wonders. I've since tried Emacs with go-mode, and Vim with vim-go. I've stuck with Vim. I would suggest to anyone planning to use Vim+vim-go to get YouCompleteMe as well. Not only do you not need to use omnicomplete, but YCM is much snappier and doesn't have that split second delay when trying to complete something. It also shows type information in the completion which is great.
Proved on 10 student (I wouldn't call that representative) on a dynamic language where these 3 representations mean different things: foo: bar foo : bar foo :bar The title of the paper is &gt; The impact of Syntax Highlighting in Sonic Pi And that's what it is, nothing more, nothing less.
emacs with go-mode, go-fmt on save ... and some other tools
yes.
I saw a video of one of the go developers discussing this topic. Basically vim-go is his editor of choice but only because he already knew vim really really well. He basically recommended to just use go-sublime if you are not already a vim master. 
You can always do what I did. Decide to learn vim, try vimtutor, see how hard it is and (the tricky part) spend one year slowly forgetting what you've learnt. Rinse and repeat about 2-3 times until you catch the disease :) But really, the way that works for me is to go through the basics (vimtutor) a few times, from scratch, until it becomes muscle memory.
no
Web assembly has basically hailed Javascript as the king. For Go to get anywhere near that status it would need to dethrone Java on Android. Which is something that could well happen.
Will Go enable incompetent monkeys survive in the industry like Javascript did? Hope not. 
Over time, I think Go will take the place of C++.
In essence, JS was the only language for a platform that exploded. I don't see that opportunity for go. It could become a dominant domain language, but still has an uphill battle considering some well discussed weaknesses, like lack of adequate generic support.
I haven't used vim-go, but I'm assuming it's in the class of the equivalent for Emacs that I have used, and probably better... That being said, I would echo that you look more into a major dedicated ide, like intelij eclipse or lite. 
For anyone that's unfamiliar with VIM, I normally recommend Atom with [Go-Plus](https://github.com/joefitzgerald/go-plus). It makes for a really pleasant coding experience, with little to no setup. For anyone who's at least a little familiar with VIM or is interesting in picking it up, VIM + [vim-go](https://github.com/fatih/vim-go) + [YouCompleteMe](https://github.com/Valloric/YouCompleteMe). The learning curve for VIM is pretty steep (when compared to Atom), but if you're willing to put in the time and effort it can be incredibly rewarding. After close to a year of consistent use, I finally feel like my productivity using VIM has far exceeded my productivity using Atom.
Woohoo!
I am a recent convert to vim + vim-go, I was using Sublime + Go-Sublime, Sublime was slow for me, I tried to remove packages etc. from sublime but didn't work. So I started learning vim, from vimcasts, some articles, help in vim etc. first I started using vim commands in sublime using vintage/vintageous. then after 2 weeks I jumped to vim full time. It has been more than month and I am using vim + vim-go + tmux as my daily driver. I don't know everything about vimv(don't know if that is possible too :)) but I know enough to get my work done without any issue and if I get stuck on something I use help or internet. http://vimcasts.org/
Writing an editor in JavaScript. What could go wrong.
If say this was to happen, would games become natively cross platform or would there still be a bunch of stuff to stop that
Connect and attach in one go. ssh blah@blah -t tmux a
Yes
There is anyways GopherJS.
I wish Go to explode like that
&gt; When you're reading an article But I am not reading an article. I'm trying to understand something that reads very differently than any text in a human language. &gt; While that is the intention of color highlighting, drawing your attention, the problem lies with color schemes that highlight everything. That's simply called a "bad colorscheme" (or maybe, just the wrong colorscheme for the language you're working with) and cannot be used as an argument against syntax highlighting. Specially considering that colorscheme choice is a personal thing.
this is great great job!
&gt; My face is red, I might have cause a bit of confusion with the title. What I did was create a RESTful API Documentation from the annotations in Go code. Where the consumer doesn't mind/care whether it's Go behind it or not :) 
The fact that Javascript exploded as it did has no meaningful relation with it being used in browsers. In fact it wouldn't be hard to imagine that Go could replace Javascript if someone would willingly put in the time to create a proper Go runtime for browser side. The problem would be the adoption rate among developers and browsers (Firefox and Edge would need to ship with the same runtime)
&gt; Related improvements to the scheduler allowed us to change the default GOMAXPROCS value (the number of concurrently executing goroutines) from 1 to the number of logical CPUs. So this means that goroutines default to running in parallel now, instead of concurrently, right? That is, assuming your computer has multiple cores.
Looking forward to installing this and seeing how the concurrency and GC improvements play out.
Version 1.0 is out: https://github.com/zx48/linq/releases/tag/1.0
It doesn't matter. There is no standard. I usually order my source code in the order of importance, i.e. when reading from top to bottom, your depth of understanding should increase maximally. But that's of course kind of fuzzy. :)
No, it doesn't matter. In general, I believe the convention is to put `main()` near the end, but I doubt it matters much. Put it where it makes the most sense.
It boils down to handling 404 errors on the server and serving out the index.html page or whatever loads your client side app. Once thing to note is that because your page can be loading from any path, you probably need to set the base href in the index.html page.
Thanks /u/synakx and /u/CaptaincCodeman, I see the light now. Thinking on doing some regex so it only redirects under /app/ folder, since I'm fine with go handling any other 404. You rock!
Go team delivers consistent, measured, leaping enhancements to the language and platform. Congrats on doing it again!
I'm really excited about this release! It's so awesome to me that they've managed to build the whole toolchain with Go. I know it's not an uncommon thing with programming languages, but it's still an amazing milestone. Congratulations Go team!
That is indeed a good point. I will take care that vim's learning curve does not distract me from what I actually want to learn at the moment--which is go. 
Is the Go GC written in go? How does that work out with the compiler?
Parallel execution and concurrency are related concepts, not opposites. So if your code is set up to run concurrently (uses goroutines), it's more likely that it'll be running on multiple cores simultaneously.
Changed to Go 1.5 and looks like the Mongo driver mgo stopped working. Anyone else have this issue? :/
The runtime package (which includes the GC, maps, channels, scheduler, etc) is written in Go, but the Go code is a bit gnarly and uses the unsafe package in places. The compiler has a special mode for the runtime package to prevent it from doing certain things like implicit memory allocation. You can almost think of the Go used in the runtime as a subset (but like 98% subset) of the full Go language. 
Just install locally? They have binaries for Linux, OSX, Windows ...
I'll see if I can't clarify some of the docs. As you can imagine, it's not the most popular use case, so I think you're the first external user. (that I know of) Definitely let us know and please, file issues!
Could be the same issue I had - connecting to localhost failed but it worked if I used 127.0.0.1 ... I *think* it's something todo with the network resolving perhaps looking for an IPv6 connection first rather then IPv4 but that's just a guess. Normally localhost resolves to ::1 and 127.0.0.1 and the default for MongoDB is only to listen on IPv4.
Test 3 needs to be run on 64bit go or you blow the stack.
I didn't know about this! It looks like gox is more mature and full-featured; mine is closer to a shell script. His also works for Go &lt;1.5 by rebuilding the toolchain.
I ran into issues with 'host=localhost' in my DB connect string using lib/pq when I upgraded to Go 1.5. Similarly, changing it to 'host=127.0.0.1' fixed the problem for me.
Installing packages in go is trivial. `go get whatever`. Finding them is also not hard. Use godoc.org, go-search.org or just google it. NPM is no better at answering the question "which package should I use?" or "can I trust this package?". The lack of versioning is an issue for large-scale projects, but it doesn't really impact new developers. (pulling the latest version usually works) Pegging versions doesn't make dependency management issues go away either. It's all to easy to introduce mutually incompatible versions of code from separate libraries, end up with orphaned libraries, or stale libraries with security vulnerabilities, or be forced into a corner when upgrading to a new version for some feature you absolutely have to have. NPM is as good as any tool, but it to has its own set of problems. For one building platform agnostic C++ bindings is a real chore (and many of the things people use Go for would require such bindings) and for another everything in the Node community seems to have a 6 month shelf life before it's replaced with something else. I mean how many Javascript build systems are we up to by now? If that's what "driving the community" leads too, maybe we're better off for it.
If I understand your question correctly, you have a development server on your LAN, but are using a different computer to log in and develop. I believe it's your firewall preventing other LAN computers (and remote alike) from connecting to port 8000. Check this first before anything. It shouldn't effect anything if you are using the same machine for everything. But it sounds like you want to view the page on a different machine. Just open a browser like firefox and open http://localhost:8000 and then on a different pc on the LAN visit http://192.168.1.8:8000 if you are logged in SSH, just use curl or w3m to view your localhost site and see if it works. If you are trying to use your browser from a different machine you would have to open port 8000 on the server end. On a local network you would have to open firewall port as well. If you don't have apache or nginx (or another server) already on port 80, you can probably just use 80. Then you can type http://192.168.1.8 in a browser on the LAN. There are many request types, you probably have heard of POST, GET, there are others as well. When you visit a web site it is a GET request, when you "post" or "upload", it is a POST request. (generally.) Optional: Try adding a line in your /etc/hosts file to bypass DNS and use your own fun domain names: 192.168.1.8 funtime.com funtime 
Ok, so go is comparable to C++ circa 1992 in that regard. Got it, thanks.
`yum install golang` tries to download old version ``` Package golang-1.4.2-2.12.amzn1.x86_64 already installed and latest version Nothing to do ``` Is there another way to download to redhat linux using commandline?
&gt; someone who has not coded in any statically typed language and who has no idea about memory management. You don't need to know anything about memory management in Go. It's handled by the language runtime, similar to Python or Perl. 
Sure. This is a graph of GC pause time in ms for one of our production apps that I just rolled to Go 1.5. The large drops you see are when I deployed one, and then all, of this particular service's instances. The Garbage Collector in Go received a lot of attention in 1.5 (https://golang.org/doc/go1.5#gc), and by merely recompiling and deploying, this service gained a large improvement in the amount of time the garbage collector spends pausing running Goroutines so it can collect. If this isn't what you're looking for, I'm happy to answer a more specific question :-)
Although, like in Python or Perl, you still *should* know how the memory management works so that you can write code that's nicer on the runtime. For example, just because there's a GC doesn't mean that you should allocate and then throw away large chunks of memory constantly; that will run badly no matter what you do.
So excited about the easier cross compiling!
Can you suggest any good material to start off ?
I've been doing a lot of JS lately and was curious about relative performance, so I converted your function to JavaScript... TL;DR it's a bit slower, but only takes about 5% longer. First I cleaned up the go a bit so I could follow it more easily: func countPrimes(limit int) int { // Return if less than 1 if limit &lt;= 1 { return 0 } // Get the sqrt of the limit sqrtLimit := int(math.Sqrt(float64(limit))) // Create array numbers := make([]bool, limit) // Set 1 to prime numbers[1] = true numPrimes := 0 // Count the number of olds if limit%2 == 0 { numPrimes = limit / 2 } else { numPrimes = (limit + 1) / 2 } // Loop through odd numbers for i := 3; i &lt;= sqrtLimit; i += 2 { if !numbers[i] { for j := i*i; j &lt; limit; j += i*2 { if !numbers[j] { numbers[j] = true numPrimes -= 1 } } } } return numPrimes } Times on my somewhat old mac: 2015/08/19 21:14:48 Test 1: 25 took 1.005Âµs 2015/08/19 21:14:48 Test 2: 664579 took 118.712526ms 2015/08/19 21:14:50 Test 3: 5761455 took 1.543064149s 2015/08/19 21:15:07 Test 4: 50847534 took 16.911457224s And then I translated it to JS. A regular array (object) was too slow and small, so I just swapped in a typed array of Int8s. (Yes, uses 8x the memory needed... whatever.) function countPrimes(limit) { // Return if less than 1 if (limit &lt;= 1) { return 0 } // Get the sqrt of the limit var sqrtLimit = Math.floor(Math.sqrt(limit)); // Create array var numbers = new Int8Array(limit); // Set 1 to prime numbers[1] = 1; var numPrimes = Math.ceil(limit / 2); // Loop through odd numbers for (var i = 3; i &lt;= sqrtLimit; i += 2) { if (!numbers[i]) { for (var j = i*i; j &lt; limit; j += i*2) { if (!numbers[j]) { numbers[j] = 1; numPrimes--; } } } } return numPrimes } Equivalent times running with node (stable: 0.12.7) Test 1: 25 took 0.001 sec Test 2: 664579 took 0.121 sec Test 3: 5761455 took 1.656 sec Test 4: 50847534 took 18.866 sec 
To be fair, there's nothing about this code that takes any particular advantage of go; it's just math in a loop. The compiler isn't going to do fantastic things with it, and so the V8 optimizer will do an excellent job as well.
Yup. A lot of attention has been given to the Go tools being completely written in Go, but not as much has been given to the way this was done: [Large chunks of the original C code were automagically translated to Go code using a custom tool. As you can imagine, this resulted in a lot of un-idiomatic and/or inefficient Go code. Original slowdown was in the order of 10x. They were able to bring that down some for the 1.5 release, but that aspect is still a work in progress and a lot of effort is going into it](https://talks.golang.org/2015/gogo.slide#1). Hopefully by next release, Go tool performance will be back to around where it was before.
It's worth pointing out it's not the `go run` tool itself that is slower, but the compiler toolchain it calls to compile your program.
Could this have something to do with the new Go DNS resolver in 1.5 no longer using cgo? https://golang.org/doc/go1.5#net 
FYI at Gophercon I learned a phrase that made parallelism and concurrency easy for me - "parallelism is doing many things at once, concurrency is managing many things at once." Concurrency would be managing all the Go routines at once, even in a single thread, parallelism would be 2 goroutines running side by side on two different threads/cores.
is this the base for runc (new container initiative runtime)? well written and cool posts, thanks
me too!
Looking at the minor changes at the bottom of https://golang.org/doc/go1.5 I saw this: &gt; The net package will now Dial hostnames by trying each IP address in order until one succeeds. The Dialer.DualStack mode now implements Happy Eyeballs (RFC 6555) by giving the first address family a 300ms head start; this value can be overridden by the new Dialer.FallbackDelay. Looking at the wiki for [Happy Eyeballs](https://en.wikipedia.org/wiki/Happy_Eyeballs) it states: &gt; An application that uses a Happy Eyeballs algorithm checks both IPv4 and IPv6 connectivity (with a preference for IPv6) and uses the first connection that is returned. When you stated that you had to manually enter in 127.0.0.1 instead of the hostname 'localhost' to get the connection to work, it makes me think that this new Dialing scheme is returning the ipv6 address ::1 instead of 127.0.0.1 when dialing for 'localhost'. Might be worth looking into further. 
And they've included a FreeBSD build again \o/
if the db requests are being performed faster than the incoming network requests, you should be ok to reduce the db pool size by the proportionate amount the other way is a little less determinate - if your db responses are slow such that your network gatherers are twiddling their thumbs, increasing the number of concurrent connections may not help - as it will depend on both your db and requesters hardware capabilities. 
For an introduction: golang-book.com
Nothing
What does `go env` give you? Two ideas: * Do you have a space in your username? That can sometimes cause problems. * Maybe the permissions really are set such that go can't create the folders. You could try: `chmod -R 777 ~/projects`. 
You only need 2 channels. var c1 chan databaseRequest var c2 chan redisRequest Then make workers pull off the same channel: for i :=0; i &lt; numberOfDatabaseWorkers; i++ { go func() { for { req := &lt;-c1 // do database stuff c2 &lt;- redisRequest{} } }() } for i := 0; i &lt; numberOfRedisWorkers; i++ { go func() { for { req := &lt;-c2 // do redis stuff } }() } For cleanup you can either close the first channel, wait for all the database workers to finish and the close the second (look at `sync.WaitGroup` to see how to do that), or I tend to prefer some sort of `exit` channel that you close once and pass to every worker. Then every time they do a send/receive do it in a select: select { case &lt;-exit: // when exit is closed this will happen return case req = &lt;-c1: } As for the connection pool, `database/sql` is already using one. You can adjust the number of connections it will make with http://godoc.org/database/sql#DB.SetMaxOpenConns. I would first try it with the defaults and then if you are concerned about performance start tinkering with the options and benchmark/profile. But the defaults are pretty good and worrying about it now may be a sign of premature optimization.
I never said that syntax highlight doesn't have benefit and I don't really know where you found statement about the lack of value in syntax highlighting in Go. You ask me to be skeptical, I am. Just not in the same direction than you. Actually, my original complain was about presenting a paper as proof when it has so many difference with how professional develop in go.
That's almost a best-case result, happening in the real world. Kudos to the Go team for another excellent release.
Yep, they did a very great job! 
No... I edited my post. A constant connection should be fine. I must have been thinking about the issues I had a few years ago with web sockets when it was more "bleeding edge". I just want to see what other options I may have.
Fantastic! I did not know about this. I will do some research in to it.
For any one else looking at this as a reference: http://caniuse.com/#feat=eventsource
Find something new to riff on. We've all heard that one. 
One of the things that keeps getting brought up is GC pause time and how it affects real-time applications like games. In a 60 FPS game, one frame is roughly 16 ms. This is a short window to get stuff done, so a significant delay can mess things up. It's my understanding that in Go 1.5 the GC is concurrent so that application code still executes during the 'pause' phase and that Go 1.4 that would have stopped everything. Ref: [Go GC Solved pdf](https://talks.golang.org/2015/go-gc.pdf) -- especially slide 14. SO ... That means that in my 16 ms slot to do work, with a GOMAXPROCS &gt; 1, the application is running even if the GC has been triggered by heap growth, right? Further, the GC runs (concurrently) only when heap growth has triggered a GC pass, right?
I think it still would. The dd-wrt version I have does not use libc, but uses musl instead. And, I know some versions use uclibc. Even though I'm linking statically, it seems that I still have dependencies on the cpu / operating system of the target. Now that 1.5 is out, I'll toy with it a little more and see if any things are easier.
Sweet! I'll try that out on my Yun!
Glad it's appreciated! :-)
In the event you need the next level of performance, you may consider whether you can cheat. Some garbage is generated by net/http (which I assume you're using), simply because it is work to do a high-quality job of HTTP parsing. However, examine your handlers. How many headers does it actually use and pay attention to? How hard does it process the URL parameters? What exactly does it do? Does it use HTTP pipelining, ever? If the answer is "not many headers" (especially if the answer is "zero") and "no pipelining", consider replacing it with a socket server that simply takes in the request, and textually crawls over the packet. Parameters can be extracted as slices of the original bytes, URL decoding can be done in place, etc etc. Some care is required, but this process would generate virtually no garbage on its own. A bit of pooling and even the core []byte could be salvaged. It's all just numbers. (Be sure to put a request size limit on your code to armor yourself against attack. Hopefully you've already got one set on the server anyhow you can just copy.)
After recompiling my packages with the new 1.5 chain, I can plainly say that I see huge improvements in GC. In one case I had to explicitly call runtime.GC() to keep things under control with 1.4.2, and that's no longer an issue. Excellent work by the Go team!
I would wait for this one http://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440/ref=sr_1_1?ie=UTF8&amp;qid=1440079776&amp;sr=8-1&amp;keywords=the+go+programming+language I would use online resources until this book gets published
&gt; For now I think it would be in the area of premature optimization Oh, yes, agreed for now. That's a big step to take. But it's a nice one to have in the back of your head in case it comes up. It's one that you might consider harder if we didn't have Go 1.5 in hand, but, well, now we do. :)
Sure, why not? It should be easier to upgrade them afterwards, no? And keep track of the differences between your version and the upstream version.
[**@bradfitz**](https://twitter.com/bradfitz/) &gt; [2015-08-20 13:21 UTC](https://twitter.com/bradfitz/status/634354642311233536) &gt; @Jonathan\_Blow @brianhatfield @mischanix the design goal is 10ms. The runtime team found some bugs late in the cycle, to be fixed in Go 1.6. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
SSE are quite easy to implement with just net/http. They have some advantages over WebSockets, but one possible big downside is absolutely no IE or Edge support. I recently abandoned a beautifully simple SSE go server in favor of a more complex WebSockets one just for IE :(
I checked out it seems to be a good book to start-off. Thanks.
Thanks for the links. I'm doing the tour now. It's really good.
I am cross compiling for windows. Building for windows/386 is now extremely slow while windows/amd64 compiles at comparable speeds to 1.4.2. Unfortunately, I am stuck with windows/386.
Geany and a terminal.
OK I don't know any more myself I'm afraid. But you might find more help on the go-nuts forum...
Have you tried go build -v to find which packages in particular are slow?
Git submodules are the way to go IMO. 'go get' will now fetch them. Shameless plug : I've been working on a tool to manage go1.5+ dependencies with the main objective of keeping packages "naturally" go-gettable with their pinpointed dependencies : https://github.com/hectorj/godm 
It looks like you cross-recompile stdlib every time you run cross-compilation. In case if you compile for your host platform/arch, you already have .a files of stdlib in GOROOT/pkg, but it's not the case if you cross-compile
Thank you for the suggestion. My build for windows/386 is rebuilding everything while windows/amd64 does not. That would explain the difference. My native build for darwin interestingly is rebuilding a handful of packages each time. 
+1 for Eclipse with Goclipse plugin! I'm back to Eclipse after bouncing around for many years, and now i have enough RAM and processor to handle the huge load of all language plugins i have loaded on my setup =) Goclipse plugin is SUPERB!
http://www.gilesorr.com/blog/vim-colours.html
I'm on macos too, $ export GOOS=windows $ export GOARCH=386 $ time go install dbox/cmd/... real 0m7.356s user 0m20.768s sys 0m3.096s So first time I've compiled with `GOOS=windows GOARCH=386` took quite a long time, but in `$GOROOT/pkg` now I have `windows_386` with stdlib compiled for this combination. Consequent cross-compile run much faster (of course I've removed `$GOPATH/pkg` and binary artefact) $ time go install dbox/cmd/... real 0m2.121s user 0m3.935s sys 0m0.545s
Awesome -- It's down to 8s now. It's now rebuilding all of the non-std packages on each run. Do you have any idea where the tmp files are stored? (I checked $GOPATH/pkg and don't see a windows_386 folder there)
Don't remember exactly. I think it's safe to just delete the whole $GOPATH/pkg and let the compiler rebuild it on the first run. Also, if my advice helped you, it'd be nice to edit the OP post with the instructions, so that other people would solve their issues more quickly.
I had been using Acme for a while. It was definitely interesting and different. But eventually I caved in back to Emacs. How long have you been using it? Could you share your experience.
Yep - your link is better. Mine was only correct for about 24 hours ;-)
emacs with go-mode
vim-go author here. So many great replies! Thanks all :)
vim-go author here. If you already know vi well or at least the basics just check out the wiki with blog posts, faq and screencasts: https://github.com/fatih/vim-go/wiki Also check out the vim-go documentation to get a feeling about the commands and mappings and how you can combine them. Happy coding! 
Intellij + Go plugin, intellij is amazing, hopefully go support becomes somewhat official.
Not 'my' code here, I was mostly trying to understand whether op's code (op's intern's code?) had anything go-ish about it. Once I understood it didn't, I was curious if JavaScript would be any worse, and there's one way to know for sure... One thing I'm curious about, will the go compiler efficiently pack the array of bools? I would have to do that myself in JS, unless UInt1Array becomes a JS thing.
When upgrading versions it is recommended to delete your $GOPATH/pkg. 
Grep for 'cannot find package "(.*)"' and add "go get \1" to your travis file. i.e. the travis output tells you, what packages are missing (e.g. golang.org/x/net/context) and you are indeed not installing them in your travis file.
A second (and unrelated) problem is &gt; found packages rand (cgo1.go) and rand2 (cgo2.go) in go_appengine/goroot/doc/progs which seems to indicate, that the directory go_appengine/goroot/doc/progs contained both a file with a "package rand" and a file with a "package rand2" at the top. This is probably related to the fact, that it is only a documentation directory and not supposed to be build. You should probably replace your "go test ./..." with a "go test github.com/miko-code/raygun4goGAE/..." to test only your code.
I wish that was the problem but it is 3x slower :(
Kudos indeed for rushing it out the door! [1] [1] https://github.com/golang/go/issues/12226
Thought this might be helpful to others, so have posted it here to help with discovery via search engines. The [baseconv](https://github.com/knq/baseconv) package is useful when working with extremely large numbers (larger than int64) and needing to convert that to a base10/16/etc representation. Specifically, we wrote this to deal with very large numbers (much larger than int64) stored as strings in a database, and have a specific use case wherein we also need to encode/decode them to shorter representations of them for use on URLs. The baseconv package is also helpful for things such as encoding/decoding UUIDs to shorter string representations (ie, from hex to base62), which can be done in the following way: hexVal, err := baseconv.Convert(someNumber, baseconv.Digits62, baseconv.DigitsHex) Additionally, there are some quick helper functions to handle the common use case of encoding/decoding to base 10 representations: decVal, err := baseconv.Decode62(someNumber) The package isn't limited by any specific character set, so you can do encoding of a number using any arbitrary character set, for instance: val, err := baseconv.Convert("15949", baseconv.DigitsDec, "ab143") Which will give you the following string: baa1133 The baseconv package is tested/covered. Please also see [the godoc page](http://godoc.org/github.com/knq/baseconv). Comments / questions / input / test cases are always greatly appreciated!
base62 encoding. i like it!
Could you talk about the decrease in throughput, if any, that you have faced? As you know, the new GC trades lower latency for reduced throughput but I think hard numbers would be very interesting to read. Also, I hope the guys at [Qihoo](http://blog.golang.org/qihoo) update their post with similar results.
Rushed? It was behind schedule. Need more people diving into betas and release candidates.
&gt; Intellij Same here
[**@eth0_blog**](https://twitter.com/eth0_blog): &gt;[2015-08-21 02:36:02 UTC](https://twitter.com/eth0_blog/status/634554523541995521) &gt;Expvarmon now shows avg [#Golang](https://twitter.com/search?q=%23Golang) GC pauses. &gt;To quickly compare mem/GC w/ Go 1.4 &amp;amp; 1.5, use it. &gt;[*github.com*](https://github.com/divan/expvarmon) [*pic.twitter.com*](http://pbs.twimg.com/media/CM5j-gSWsAAG5WB.png) [^[Imgur]](http://i.imgur.com/vuq26Y1.png) ---- [^[Mistake?]](/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3hstnb%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
I'm writing a distributed weakly connected filesystem: https://bazil.org/
I'm sorry, but can someone tell me what this is?
TextMate (with provided syntax highlighting and scripts)
I've spent the past year or so writing a series of high-performance, very parallelized libraries designed to solve a somewhat esoteric problem in the field of numerical astrophysics. It involves a bunch of super-fun computational geometry and generates some pretty gorgeous pictures. At a language level, Go is pretty great for numerics (although there are still many problems with it). You have good control over the memory layout of your program without risking the types of bugs that come with manual memory management in C or Fortran, and there aren't too many fancy language features getting in the way of optimizing the crap out of your innermost for-loops. And, of course, it's also dead simple to write code in it. The library ecosystem for this type of thing is pretty miserable, though. It's annoying to have to write, test, benchmark, and optimize things like Savitzky-Golay filters or univariate splines from scratch. I won't name names, but some of the Go-based numerical libraries that *do* exist are so slow and poorly written that they're not worth using at all (and in some cases, they can't even be fixed without introducing breaking changes to their APIs). Cgo helps a bit, but it's hardly a panacea.
Do you have univariate spline code that's distributable? It is indeed a pain to write from scratch, so if you've already done it... Definitely agree with the desire for a richer ecosystem of libraries. It is a nice language for numerics, but it's hard to break the cycle of developers need libraries which need to be created by developers. We're working on mat64 (and gonum in general). It takes a lot of effort to build up the functionality (and we're all volunteers). It's gotten much better over the last year, for example, linear solve is now based on lapack, either with a pure-go implementation or with cblas/clapack backing. It's true that the API is still in flux but we're getting there.
This library allows you to use R from Go applications. It is a RServe client, which communicates to R using TCP.
Cryptocurrency trading bots.
This exists for anything. Awesome-pythin, awesome-php, awesome-css, awesome-javascript. Just Google it! Edit: I even think there exists an awesome-awesome list to list the awesome lists.
Command line tools. Easy to cross-compile. Fast to write.
Both of those are fine. (As far as I know. I don't have experience with a lot of the functions in gonum/stats). I'm not a huge fan of replacing simple for-loops with library calls (unless I'm writing code in Ocaml or python ;-) ), but if you are, gonum/floats is pretty much exactly what you want.
Currently working on a program which will use support vector machine learning to predict physician sub-specialty based on prescribing trends
Does anyone know when Google App Engine SDK will move to Go 1.5? Current Go SDK (version 1.9.25) is using Go 1.4.2.
TLDR: use a mutex or channel instead, unless you are brave and on a machine with 16+ cores
Well, please join us if you're interested in helping to build things! For example, we have the BLAS code to support banded triangular matrices (the more general form of TriDiag()), and it would be nice to provide useful functionality to mat64
check it out, guys, it's awesome the `go list` command is amazing, didn't know about that one my favorite trick was this (it uses method values): type Server struct { /* Server state */ } func (s *Server) index(w http.ResponseWriter, r *http.Request) { /* Code */ } func (s *Server) edit(w http.ResponseWriter, r *http.Request) { /* Code */ } func (s *Server) delete(w http.ResponseWriter, r *http.Request) { /* Code */ } func (s *Server) Register(mux *http.ServeMux) { mux.HandleFunc("/", s.index) mux.HandleFunc("/edit/", s.edit) mux.HandleFunc("/delete/", s.delete) } 
Sure thing, I will get a full parts list up ASAP. (I have more hardware on the way)
also, [the slides mentioned are available now](https://www.reddit.com/r/golang/comments/3husww/stupid_gopher_tricks/) and very much worth your time
OH GOD, NO, STAHP .... Sorry. This is cool. I just have PTSD from working with bioinformaticians who love to integrate R with EVERYTHING, then hand me a loosely-coupled pile of programs that need to be analyzed/traced independently to figure out why they're not working as expected. In an go-heavy environment I can totally see how this useful.
~~You would still need a write lock and copy the map in your example~~. It is indeed meant to be used with wrapper functions, and the documentation has some examples[1]. It's not that is really dangerous to use, it's just not recommended unless you need it, as you just proved, it's not always straight forward to get right. Edit: forget what I wrote, I misread your example, I have no idea if that would be safe. [1] https://github.com/golang/go/blob/13b5dc885b8dfd550b5f8cac0e9c0a9463f30fd7/src/sync/atomic/value_test.go#L169
Ha, I can only imagine the pain!
I approve of your name. 
Channels and goroutines with the aforementioned REST api around it. It's not as "robust" as RabbitMQ (i.e. we can't cluster the system, yet) but we never really needed that. I designed it with the full intention of plugging the core event loop into a RAFT library at some point in the future when time allows, so I'm not too worried about that. We've been running the system in production for months now and have yet to lose any production data to a software bug. Eventually we will have hardware failure, but we have enough monitoring and auditing that I'm not worried about that. Clustering/failover is a nice to have for us, not a necessity. For us it's more important to make more optimal usage of the 100's of servers we run in order to keep costs down.
Thank you for the reply, great to hear your thought process!
&gt; Go build just compile the executable file and move it to destination. Go install do a little more. It move the executable file to $GOPATH/bin and cache all non-main packages which imported to $GOPATH/pkg. the cache will be use in the next compile if it not changed yet. It is a normal behaviour
That makes me sad. Our build is already too slow.
big.Float support has been added. [FormatMoneyBigFloat](https://github.com/leekchan/accounting#formatmoneybigfloatvalue-bigfloat-string) ac = accounting.Accounting{Symbol: "$", Precision: 2} fmt.Println(ac.FormatMoneyBigFloat(big.NewFloat(123456789.213123))) // "$123,456,789.21" fmt.Println(ac.FormatMoneyBigFloat(big.NewFloat(12345678))) // "$12,345,678.00" ac = accounting.Accounting{Symbol: "â¬", Precision: 2, Thousand: ".", Decimal: ","} fmt.Println(ac.FormatMoneyBigFloat(big.NewFloat(4999.99))) // "â¬4.999,99" fmt.Println(ac.FormatMoneyBigFloat(big.NewFloat(-4999.99))) // "â¬-4.999,99" ac = accounting.Accounting{Symbol: "Â£ ", Precision: 0} fmt.Println(ac.FormatMoneyBigFloat(big.NewFloat(-500000))) // "Â£ -500,000" ac = accounting.Accounting{Symbol: "GBP", Precision: 0, Format: "%s %v", FormatNegative: "%s (%v)", FormatZero: "%s --"} fmt.Println(ac.FormatMoneyBigFloat(big.NewFloat(1000000))) // "GBP 1,000,000" fmt.Println(ac.FormatMoneyBigFloat(big.NewFloat(-5000))) // "GBP (5,000)" fmt.Println(ac.FormatMoneyBigFloat(big.NewFloat(0))) // "GBP --" 
How easy is it to get involved with the project?
Very. Initial code review tool setup seems intimidating but docs are good and it's very few steps... Just a lot of words.
Make it work, *make it right, make it fast*? Parts in italics TBD? ;)
Well, the obvious solutions for the future would be 1) parallelizing the compilation process (now that it's probably much easier), 2) daemonizing the compiler process so that it could run almost instantly, especially if it uses any amount of caching.
Probably more like how Oberon does GC, I'd imagine.
Play: http://play.golang.org/p/6MzYfk6cEd
Can you please share the .tmux.conf file? That tmux bar looks sexy!
same here
Hey caleb, the last one worked for me. Thanks a ton. I'm loving your bootcamp videos.
https://play.golang.org/p/hDmc2rszJ-
Save some time and use gox. You can use gox with 1.5, just rebuild your toolchain and make sure you set the go bootstrap path. https://github.com/mitchellh/gox
Not quite but I see where you're going. You show roles := []string{ "Architect", "Engineer", } which may be why I get &gt; at &lt;.&gt;: range can't iterate over {[Architect Engineer] company-name 2014} Possibly because "Role" is part of an outer slice? People: []AllPeople { Role: []string { "Architect", "Engineer", } }
Yup, that's the idea. But would that actually work? When FlagSet calls failf, it'll call it's own failf method, not the QuiteFlagSet one, right? So it seems like I'd need to just use my own version of the whole flag library, which is definitely too much trouble for such a little thing. Hmm I wonder if there's some way to detect we're failing in the usage and inhibit printing it... Ah that would work I guess, just set a variable after we've parsed the flags successfully. Oh wait, no because then -h doesn't work! Aughhh. :)
Im using a poor man's way and works great: i rename the .git to something else so it wont be treated as a submodule and commit it. Later if i want to update the repo i just rename it back to .git, pull changes, rename again and commit.
Try posting your revision on the playground?
Well, it's on that line, and it can't be anything else. And you can't fit a string in an empty interface. (and as of recently, you can't fit an integer either; we used to allow pointer-or-less sized integers or other stuff in there, but no longer) 
I think the Go Contributors should take this as a tangible "thank-you" from the community they serve. Only Rust and CoffeeScript have more stars... https://github.com/showcases/programming-languages 
1) a simple HTTP server: http://golang.org/pkg/net/http/#ListenAndServe It creates a new goroutine (lightweight thread) for each HTTP request. 2) Press "ctrl+C" and run your program again 3) https://gobyexample.com/ https://golang.org/doc/effective_go.html
I should really remember to do that when I ask these questions. Working on it now but getting a simplified version is ... difficult.
You're a lot closer. My code may need adjusting for your example. The output now is &gt; Architect Architect Engineer and Engineer EDIT: Whoops! It works. I just needed to remove one line of my code. Thanks!
2: You can use gin to do code reloading on change: https://github.com/codegangsta/gin
on twitter : @golang @rob_pike @_rsc @bradfitz @enneff @francesc 
https://play.golang.org/p/ad_RpNApZq Alternative way of doing the same.
Out of curiosity, do you use this library? And what do you use it for? I have a couple suggestions depending on your use case.
so you might like this colorized version of mine http://imgur.com/q0RJxzV
Actually that is [vim-airline](https://github.com/bling/vim-airline) with [tmuxline.vim](https://github.com/edkolev/tmuxline.vim) and [powerline fonts](https://github.com/powerline/fonts). Here's the vimrc settings for airline: let g:airline_powerline_fonts = 1 let g:airline#extensions#tabline#enabled = 1 
It's perfectly normal to spawn a goroutine whose sole purpose in life is to wait for something to happen. You don't have to conserve them, or at least, not to anywhere near that degree. You shouldn't be writing this much code trying to conserve them. Unless you're simultaneously running many tens of thousands of processes, you're not going to run out, or even notice the resource consumption. This is actually an important element of learning how to use Go fluently and if this is the sort of thing you are doing, probably something you really want to fiddle around with until you're comfortable with. You'll find it really opens up the possibilities when you see how easy it is.
I don't know about inefficient, but it's not cancellable. If you wanted to be able to "stop" a chrono you'd have to wait it out. Also, just thought it might be fun to use the go-routines since they are fun :)
I've an entire home automation system written in go: from sensor data collection, security system, alerting (jabber, Twitter) and a lot more: https://github.com/barnybug/gohome/
I've written lots of command line tools with Go. I have one project that parses chat logs saved from a game to search for various keywords/all messages from a player/etc. Another that takes a database file that a game provides that contains data about each item. It migrates it out of the database into an `encoding/gob` file to be loaded later for faster access of data. It has several flags for querying data and even includes a lua interpreter with modules for looking up data and working with it. Another is a bot for Slack that has it's own system for users to report actions and provide statistics. You can do all kinds of stuff with Go!
Awesome tool! At work we had a devnull@ email account that we used for massive tests and recently we found out it was redirected to one of the IT guys. What could possibly go wrong if you redirect devnull to your own email? I'm sure he'll be more than happy to hear from this tool :)
Thank you for doing this talk. As someone who: is (mostly) part of the 90% of lurkers you mentioned, and someone who tends to write non-idiomatic go, I'm very glad there's a core community member advocating such opinions. I was going to write much more here, but to be honest, anything that I try to convey will likey be overshadowed with questions and demands that I cease writing non-idiomatic go. And that I just don't have the time or energy to deal with blind dogmatism. Again, thank you for having the broader audience in mind. 
Sublime Text 3 + GoSublime + bash 95% of the time, Conception-go 5%.
1) I would rephrase this as Go doesn't expose the event loop directly. The event loop exists in Go, but is managed by the runtime. A simplified view of how it works is the following: You write all your code as blocking synchronous code which runs in execution contexts called goroutines. These are similar to threads with the primary difference being that they are managed by the go runtime and not the OS. The runtime can detect when your code is at a blocking call boundary such as a read or write. If it knows you'll be waiting for the result of some operation it runs code from another goroutine until that piece of code blocks.
&gt; net/http is automatically spawning one goroutine per request, so you don't see it. They're still there and you can still use them freely. This is the explanation I was looking for, thanks!
Exactly. If you're using the net/http library then the server does exactly this. You provide it with a handler that is called for every request. Each request is then processed in its own goroutine by the handler. There are some catches to be aware of though. All the magic the runtime does won't work if you call into a C library. In that case the call will be fully blocking. An example would be if you had accesses to a sqlite database.
Good to know, thanks!
Check out 'gvm' on github. It makes it easy to install multiple versions and pick which one you want to use.
To save the time to search github: https://github.com/moovweb/gvm 
There are a few ways to do this. You could install go 1.5 in a different folder and change your GOROOT variable to point to the new location. You could always rename your current go location to something like go-old and put 1.5 in go. Not the most sophisticated, but it works. 
If you use Mac OSX, the best way to switch golang is using `brew switch`. Just `brew switch go1.5` or `brew switch go1.4.2` to quick switch golang version without any extra setting.
http://stackoverflow.com/questions/13101298/calling-a-pointer-method-on-a-struct-in-a-map
http://play.golang.org/p/zov9m5OrXZ
Iâve been using https://github.com/travis-ci/gimme in order to switch between 1.4.2 and 1.5 (and the beta/rc releases before the final release) Works just fine under both OS X and Linux.
I also just migrated to it from godeps and have been very happy. Especially now with go 1.5 it doesn't require any gopath mangling and also works with recursive projects. 
There are also a few good examples of calling Go shared libraries from Python and C: * https://github.com/shazow/gohttplib * http://blog.ralch.com/tutorial/golang-sharing-libraries/ These both use the -buildmode=c-shared improvements in Go 1.5
Right now I'm using Go 1.5 primarily, but if I want to test something against 1.4 I have a simple alias setup: alias go14="/Users/nathany/src/go.googlesource.com/go1.4/bin/go" Of course that doesn't cover all the other tools. Also note, I've installed from source, as I like to keep tabs on new developments.
I can see how the usage is familiar; but working in vi(m) (my daily workhorse) is - as far as i can imagine - completely different than actually getting work done with ed (or ex ftm). Perhaps I still use vim like I would use notepad too much. 
what's funny is that a domain called id-rsa.pub serves content over http only
The `ed` workflow is usually very structured. `ed` is less suitable for making corrections to code as it cannot really *edit* test, you can only add and remove text. The only command that really edits things is `s` but it's damn useful. What I like with `ed` is that it forces you to think about your edits before doing them. I believe this leads to a more structured workflow. When I use `ed` to develop Go code, I use the `!` command for compilation without having to leave `ed`.
That's a compile time error, not a runtime error
I simple have the two versions in two different directories and link the go/godoc command to /usr/bin and done.
Sublime Text without GoSublime because of latter's bugginess
Damian killed it.
You could always use a custom FlagSet and then call yourFlagSet.Parse(os.Argv) to get the behaviour you want.
You should add a huge note to the section on symlinks to *never use symlinks*. Anyone reading that guide for advice on doing so will surely not understand the caveats.
Would you mind to explain why?
symlinks are one of those features that are quite likely to fail for reasons unrelated to your code. There are a bunch of situations where they're not going to work, such as when a filesystem doesn't support them.
I've got various libraries servicing the visual effects industry. Two are bindings to C++ libraries and one is pure Go http://godoc.org/github.com/justinfx/gofileseq http://godoc.org/github.com/justinfx/openimageigo http://godoc.org/github.com/justinfx/opencolorigo gofileseq includes a tool called seqls for listing rolled up sequences of files. 
Seriously, we're having this discussion? We're talking about the audience who would be looking up how to do basic file operations. Focus on that. And sure, throw in a note about how not all filesystems support permissions! It doesn't need to be a fatal, but if you check for err!=nil after trying a permissions-related call that wasn't supported, it may not be obvious that the failure isn't necessarily critical. 
Thanks for explaining that.
If anything I would say the opposite. If symlinks are not supported it will fail pretty obviously and let you know. Symlinks also do not hide anything and tell you where they point and that they are a symlink. You will see symlinks more often in Linux. Hard links on the other hand are trickier. You might not know that there is another hard link to the file somewhere else, and you might think that you deleted a file, but it is still taking up space because there is still a link to the file somewhere else. Because you might unknowingly have multiple hard links to the same file you might change data without realizing you changed another file.
Cool. Just regarding the hashing example, for large files you will want to avoid copying the contents of the file into memory. Here is an alternative approach that does not require that level of allocations: http://stackoverflow.com/a/15892717/1327984 
I decided to [experiment](https://github.com/MrSaints/go-node-ffi) with it by calling Go functions through NodeJS using node-ffi, ref, and ref-struct - for bindings. Go 1.5 is awesome.
It hasn't caused me pain at all, but I'm not a new developer or someone new to portability issues. When you write what is basically a "cheat sheet" of basic file operations, your audience is going to largely be new developers who may not know these things, and are quite likely reading your page instead of the actual documentation, which also does not mention potential caveats. [Go didn't even support symlinks at all on the Windows platform until 1.4.](https://github.com/golang/go/issues/5750), and simply returned an error when attempted. 
I know that go-autocomplete and go-company exist. However, they use their own completion backends, because of which anyone who wants Go completion in Emacs is stuck to using autocomplete/company. This package uses the native completion-at-point functions provided by Emacs, so you're free to use any framework you want, including ido/flx, helm, company, autocomplete, etc. Right now, the package only provides basic completion functionality, I would like to add tooltips/annotations later on, so any help is welcome.
why?
Who cares about compilation time? My calculation-heavy code runs 2x slower when built with go 1.5 .. I'm staying with 1.4.2 for now.
If I do not trust Peter Bourgon then who would I trust? From now on I will manually clone/copy to the vendor folder and delete the .git folder. Thank you for the answer and good luck with go-kit!
True. With all the tools running on every save I come to expect that everything works after that from a compiler point of view. On top of that I use a script to to build and run in one command.
This container will be useful if: - you'd like to get started with Golang (in general) without having to figuring out the Go path, libs, editor, plugins, settings... - you'd like to try the editor quickly, Docker then acts like a package manager but without all the hassle (docker run/docker rm)
Give url with a code, which placed on [play](http://play.golang.org/).
&gt; https://github.com/mailhog/MailHog It really isn't different. I noticed MailHog will allow you to eventually send the mail for real, which mine does not. When I first wrote MailSlurper in Java back in 2011 I didn't find a lot of programs that did this. So I wrote something. Now I've seen quite a few of these. Either way it is a fun tool to write and I have found Go to be the perfect language to write it in.
I actively use Windows and Linux. Was getting the delay on both.
The Windows delay is something I am getting too, and it appears to be a bug with Emacs :( No delays on Linux here.
Where is this linker optimization documented?
I did the same. It works perfectly. For Go version management I use GVM: https://github.com/moovweb/gvm
Nice list. You might consider adding something for this [portable memory-mapping package](https://github.com/edsrzf/mmap-go).
Does [the example from the docs help](https://www.godoc.org/golang.org/x/net/websocket#Dial)? If you need TLS, it looks like `DialConfig()` might be what you're looking for.
Code you provided is not a websocket. What you linked is just a simple tcp server. In case you didn't know, websocket is a protocol used for dynamic communication with http server to help creating dynamic web apps. There is actually an official golang package used for this: https://godoc.org/golang.org/x/net/websocket
Does this offer any advantage over the standard library buffered reader/writer?
Yeah since buffered reader/writers AFAICT do not allow you to read only specific parts of a file (e.g: read bytes 10 - 15) without the requirement of a delimiter.
How large is the performance improvement of this? How does it compare to using `mmap()`?
How does it reduce the load without improving performance?
Have you considered just extending the standard library package and trying to put that change in to the language?
Its good for reading just like ReatAt... But I also need the WriteAt to be cached
Looking good! I'm very interested in event sourced applications. I've only cast my eye over your documentation, but it doesn't seem that you're doing entity snapshotting at all for your event stream? I'm not sure if Martin Fowler covers it, but if you've got 200,000,000 events for an Entity, you don't want to replay them all to get your Entity state up-to-date, it's best for the Event stream to have a recent application state snapshot to start from and then just replay all the events that have happened since that snapshot. Otherwise, I love it! Edit: to clarify, I'm not saying that you would discard your event stream prior to the snapshot, just that there would be regular snapshots to shorten the required replay events for an entity.
Try looking at the socket.io Go example. 
Writing to an mmap'd file will usually only be synced to disk when the fd is closed.
So, first of all let me say I'm very sympathetic to the goals and general ideas here. I've been in the business world long enough to know what this is for, where it's coming from, why it's a good idea, and why every business system ends up including a half-assed version of this sooner or later if it doesn't start out with a whole-assed one, and it's neat to try to start with a whole-assed one. But there's two major issues with this, I think. First, perhaps ironically considering its strong business sponsor, Go is one of the more hostile languages to this sort of fundamental paradigm shift. A lot of this code is basically dynamically typed without the convenience of being a dynamically typed language. You've even got the basic `Variant` type in `Value`. That's not a criticism of this code per se, because you can't do anything about it, it's fundamental to the language. Go wants to be written in idiomatic Go, and in a lot of ways Go makes Ruby look wishy-washy about its opinions. If you are interested in pursuing these ideas but are not really that tied to Go, you might want to consider Haskell, whose type system will eagerly play along with you, and even enforce things like "modifications to the underlying values can only be done via events being processed in the sanctioned manner", all the while maintaining full strong typing. Secondly, if you are tied to Go, there are ways of making this more native Go, and simplifying as well. First, pull the data types out into a subpackage. It clutters up the godoc. Second... I don't even know exactly how to put this, but... this proscribes a lot more specificity than it really should. `Command` is probably one clear place... `Command` should be an interface, rather than a concrete type. Because `Command` is a concrete object, you find yourself implementing getters (which because they are generic, can not be type safe), an overly-generic setter, the `String` method (which itself should be an interface and looks an awful lot like TextMarshaler), and so on. What you probably ought to do is turn it into an interface. You can also offer a stock object that easily embeds into implementations that implements the boring stuff like Acknowledge and and AggregateID, but leaves the implementer of `Command` as a full object, which is allowed to be type-safe. I'm not reading your source code, but I'm going to assume that the methods that your system cares about are `Acknowledge`, `AggregateId`, `Execute`, `Receiver`, and `String`. Of those, a simply-embedded object could be provided for default implemantations of `Acknowledge`, `AggregateId`, and `Receiver` (I think), leaving just `Execute` and `String` to be implemented normally. `CommandDefinition` would actually become part of `Command`. What it would then be is the specification of the metadata necessary to deal with the command. Basically, you'd be specifying "class methods" in your interface, a powerful technique: type Command interface { Name() string Construct(Form) Command // ... } var commands = map[string]Command func Register(c Command) { commands[c.Name()] = c } Notice that `Construct` method there... this is also a powerful idea. If you put a "class method" in your interface whose job it is to take some input in and return a new value of the "same type" (not expressible in the Go type system but you can document this requirement... if indeed it really _is_ a requirement), you don't need to try to create a generic instantiator yourself... you foist it off on to the object. Which is where it belongs anyhow. It may be difficult to see my point at first, but I think you'll find that if you propagate this idea through, an entire layer of code will melt away, a lot of the type safety will come back, and it will be simpler to use the library because instead of preparing objects of the correct shape and then jumping through hoops to use it, you'll only have to prepare objects of the correct shape. I think there will still be a bit of the "dynamic language embedded in Go" in the end... but it's possible that with just a dash more of cleverness it might be able to be entirely chased away.
I think it's always correct to treat the exported functions as your API. I could imagine cases where someone might export fields that they don't want the user shouldn't touch for marshaling purposes, but doing something like that makes me squeamish. Public structs can have as many or as few public fields as you want, just like in any other language. In general, private structs should have private fields unless you have a specific reason to do otherwise. Public fields in private structs can be used outside of the package if they're embedded in public structs. Suppose you have this code in some package called `pkg`: type private struct { A int } type Public struct { private B int } In some importing package, the following code will work just fine: p := new(pkg.Public) println(p.A, p.B) This is something that you might do in some cases where you have some common set of methods and fields shared by a bunch of exported structs, but I'd generally avoid it because I don't think it plays nicely with `godoc`. There's no performance difference between exported and unexported fields/methods/etc.
I wrote a post describing how to use the HTTP streaming feature in Go here http://blog.fmpwizard.com/blog/http-streaming-using-go
&gt; why every business system ends up including a half-assed version of this sooner or later if it doesn't start out with a whole-assed one, and it's neat to try to start with a whole-assed one. This strikes a chord with me. I've been under the same impression but failed to put it into words as clearly as you just did. &gt; A lot of this code is basically dynamically typed without the convenience of being a dynamically typed language. This occurred to me as well while writing the code. At times it felt like implementing the runtime for a dynamic language. However, the dynamism is restricted to the boundaries of the system (i.e. capturing / processing input parameters). This made me realize that I actually want to model dynamic behavior which Go's type system allowed me to. The standard library gives examples for this in the [flag](http://godoc.org/flag) and [reflect](http://godoc.org/reflect) packages. Maybe modelling commands should talk more inspiration from the `flag` package (which is doing the same thing -- capturing typed input parameters). &gt; you might want to consider Haskell, whose type system will eagerly play along with you I did consider Haskell and play around with it from time to time. Then I look at Go's tooling and fall back to it (documentation, editor integration, the oracle, gofmt, go get, ...). Go doesn't make me think about the tool and gets out of the way. Haskell is still too hard to use for me. Ultimately this is a question of familiarity. At the moment my focus is on producing value with the tools I know (Go, Ruby, JavaScript) instead of learning yet another technology, as nice and useful as it may be. &gt; First, pull the data types out into a subpackage. It clutters up the godoc. Good point. I've created an issue on GitHub for this to keep track of it: https://github.com/dhamidi/ess/issues/1 &gt; this proscribes a lot more specificity than it really should That's a valid point? How much specificity should it proscribe? The mental model used by this packages is not unlike `net/http`: there is some object that processes requests passed to it. In `net/http` these requests are of a concrete type, `*http.Request`. That was the motivation for using a concrete type for implementing commands. I don't see the value of `Command` being an interface yet. &gt; Because Command is a concrete object, you find yourself implementing getters (which because they are generic, can not be type safe) My first reaction was to say "I don't see how to get rid of those" but then it occurred to me that code that produces command objects and the code that consumes them most likely live in the same package. Your suggestion definitely warrants some thought. Given a default implementation of command, this change shouldn't impact a lot. &gt; instead of preparing objects of the correct shape and then jumping through hoops to use it, you'll only have to prepare objects of the correct shape I'm not sure I'm following on this one, but I guess it will become clear once I'm making the changes you suggested. Thank you for taking the time and writing such an elaborate reply!
I really think you've re-implemented the operating system's page cache.
Easy enough to test: touch test.go cat &gt; test.go &lt;&lt; EOF &gt; package main &gt; &gt; import ( &gt; "bytes" &gt; "fmt" &gt; ) &gt; &gt; func main() { &gt; b1 := []byte("hello") &gt; b2 := []byte("world!") &gt; &gt; if !bytes.Equal(b1, b2) { &gt; fmt.Println("different!") &gt; } else { &gt; fmt.Println("same!") &gt; } &gt; } &gt; EOF go build test.go strings test.go | grep bytes
Pretty much jerf covered most of the issues. My main problem with your approach is the dynamic typing. Here's one of my attempts https://github.com/egonelbre/event. Of course, I'm still not happy with -- feels like I'm missing something obvious how to make it better.
Don't use assert and use proper testing https://golang.org/doc/faq#assertions
Want one too :-)
That sounds like something you should document so they can look into it...
&gt;Go, on the other hand, allows for both using variable as much as streams. You can either `json.Marshal` or `json.Encoder` an `io.Reader`. I'm not a native speaker and I know that in English you can "verb any noun", but it seems that this should really be written as "You can either `json.Marshal` or `json.(*Encoder).Encode` and `io.Reader`". &gt;If you cannot declare as constant, then declare as a type (`name := "Carl Sagan"`). If you cannot declare as a type, then declare as interface (`name := T("Carlos Sagan")`). I think "type" here should be replaced with "variable" or "simply typed variable". Because declaring as type would be something like `type CarlSagan string`.
To other confused people: Vagrant the virtual machine utility, not vagrant the memory debugger :)
&gt; I think "type" here should be replaced with "variable" or "simply typed variable". "Concrete type" is the generally used terminology, I believe :)
&gt; choose the relevant data-structure for your use case Thanks!
A friend with a vinyl cutter made it for me 
A friend with a vinyl cutter made it for me 
&gt; Given a default implementation of command, this change shouldn't impact a lot. It is a technique I consider a bit underused in Go at the moment. Go doesn't have traditional inheritance, so in particular you don't get one of my favorite patterns for this, the Template pattern, but you get some elements of it with composition... if you need an object to have a certain behavior you can provide it as an object and implement it for people, allowing them to compose it in from the bottom, rather than driving the rules from the top. It means they might be able to screw up the implementation but they might also be able to extend it successfully too, so... it's hard to make the call on which is better. The combination of a required interface and a provided object that implements as much of it as is sensible is at least a reasonable compromise with the Template pattern. It's also the sort of thing that leads me to think there's another such pattern or three waiting to be discovered by people. Go is mostly OO so it's mostly OO patterning, but there's enough difference that a few other things might be optimal that one would not normally consider in Java.
The MySQL driver has a NullTime type : https://godoc.org/github.com/go-sql-driver/mysql#NullTime I'm not sure if that is compatible with SQLite date-times, but worst case you can see the implementation [here](https://github.com/go-sql-driver/mysql/blob/master/utils.go#L447) and make your own for SQLite
No idea whether that'd work, but can't you use a pointer?
Fencepost error
It's a good pattern to learn because you can use this pattern for any type, including your own custom types.
Geany + console
Try the [StripPrefix method](http://golang.org/pkg/net/http/#StripPrefix) in the net/http package 
&gt; In fact, I'd argue the opposite: export only the bare minimum required, and think hard about anything else you export beyond that. Every exported symbol is weight added to your API, and risk of API breakage if you have to change it. Since in Go we are generally distributing everything as source, rather than "public" and "private", I tend to think of it as "public" and "fork it to make it public", rather than private's implication of "nothing you can do will make this available to you". Consequently, I think it's very safe to default to a rather minimum, "make easy things easy" clean API, maybe with some intermediate stuff in there if appropriate, but you don't have to write your API for the rare mega-expert who needs deep, deep access into everything... let them maintain their own fork, they're probably going to be screwing around with it anyhow. That is, you don't have to worry about that use case when creating your public Go API, so, well, don't. Keep it simple or at most intermediate and let the experts joust with the source themselves.
I'm sure it would have failed when I first posted it. You guys have been very helpful.
You're thinking of valgrind, not vagrant.
In the link you provided it seems the main issue they have with assert is based on error handling. Did you see any issues with how I handled my errors? I used assert mainly to save some typing. I should probably remove it if anything just to remove a dependency. 
I just had the need to programmatically control Vagrant over Go. There is nothing fancy and it's just a wrapper, but it's intended to be used within another Go application. I wish there was a proper API over Vagrant which I could use, couldn't find anything. So for now the only way is wrapping the commands.
These are the Java times: Test 1: 664579 took 56ms Test 2: 5761455 took 702ms Test 3: 50847534 took 9.062s
Gotcha, I don't know much about the Java so thanks for the clarification.
I see now that omv provides a YAML file which can be used to control Vagrant. This is indeed very interesting. I'll have a look at it. Probably would like to integrate it into the `Create()` method. So instead of a rubyfile we could use a YAML to declare a box.
Try this : r.Handle("/imgstrg/", http.StripPrefix("**/img**", http.FileServer(http.Dir(fs.ImgStoragePath)))) I removed the forward slash from "/img/" 
indeed. Not the first time I mixed those two up :-/
I tried it and it's still not working. I'm almost 100% sure I made a fundamental because I'm like really tired. https://github.com/mkocs/imgturtle/tree/rewr_org I'd be very happy if you could take a look. :)
I'm guessing that you are working on http.go line 40. I can't find anything wrong with the code. line 40 is fairly isolated form the rest of your code, because you didn't define a handler for it; therefore, it is likely that fixing this one line could solve your problem. I suggest creating a new servemux using the net/http package and commenting out the gorrilla/mux and negroni code so that you can try troubleshooting methods with line 40.
While I can understand the lack of substance statement I'm wondering what other languages could have these arguments made for them. They could each individually be made about other languages but I don't think many other languages/platforms would pull them all together as well just off the top of my head.
&gt; Build time (compiling our code) is slower with 1.5. Previously Go 1.4 built our engine code in ~4.5 seconds, for 1.5 it's closer to 12 seconds. The build times have been slowly getting worse over the releases with this being a significant slowdown. It was already getting noticeable and therefore annoying, I expect with 1.5 for this to increase. Any word on when reversing this trend will become a priority?
There is no issue per sei. As you noted, you have a dependency that you don't control. I am assuming that you are coming from python :) Also, use Table-driven tests, It will clean a lot of your code https://talks.golang.org/2014/testing.slide#5 let me know if you need help 
&gt; I think it's very safe to default to a rather minimum, "make easy things easy" clean API, maybe with some intermediate stuff in there if appropriate, but you don't have to write your API for the rare mega-expert who needs deep, deep access into everything Couldn't agree more. Part of the design process is knowing what kind of 'demographic' might use your library, and what it does. Designing a crypto-related library for REST API users? Minimise the sharp edges and keep to a minimal API surface. Writing an SQL driver? You might want to expose more to allow flexibility for downstream packages to leverage, etc.
Are types of `*C.char` and similar never garbage-collected? I'd think you would run into the same issue otherwise.
The issue here is that the memory backing the Go string, which in this function is returned to C code, might be GC'ed and there's no way for the C code to know that happened. Is it correct to say, then, that it's never safe to return a Go type from an exported cgo function, and that you should always return `C` types instead? If so, why does the compiler allow it (and why are types generated for string, interface, etc)? If not, what are the cases where it is safe? (Edit: removed a minor nitpick that undermined my main question.)
&gt; First, pull the data types out into a subpackage. It clutters up the godoc. I just tried doing that. Turns out that it leads to a cascade of changes due to import cycles, so doing this is on hold. Probably this problem disappear once the commands have been refactored.
Looks great! Pretty clean API, and the interface docs are good, though it could use a little more in the way of examples. I will very likely use this.
One more thing: In theory, if you maintain a pointer to the memory inside go, the GC won't collect it and the pointer will remain valid *until go gets a moving GC*. So I *think* it *currently* would be safe, but it probably won't remain safe in the future, so you should still not do it.
&gt; Distributing a single binary (regardless of filesize) instead of hundreds or even thousands of files for a web application is faster and easier. I might be missing something here but distributing a Go web application also includes transferring 'hundreds or even thousands of files'. No?
You are building a image URL that beginns with "./imgstorage/" That is not the URL you want because it tells your browser that the image is based in a subdirectory of /img. Your URL needs to start with a leading slash. In another comment you said that you wanted to use URL like ../imagestorage to load images from a parent directory. That is not possible since the Go FileServer calls [path.Clean](http://golang.org/pkg/path/#Clean) which removes relative path information. The FileServer only allows access to sub not parent directorys. 
Mostly the process for it is: write it -&gt; unsatisfied -&gt; try to find better approach -&gt; rewrite it -&gt; unsatisfied -&gt; try to find better approach -&gt; rewrite.... etc. I've rewritten it at least 5 times. The first one pretty much was verbatim translation of https://github.com/gregoryyoung/m-r to Go. The "try to find better approach" mainly involves figuring out what to call things to make it clearer and remove the dependencies. E.g. such as the `event.Aggregate`... whether to call it Recorder and remove the Id, Version from it and use callbacks etc. Here's what I have left from those experiments [ZIP](https://dl.dropboxusercontent.com/u/4300994/Go/events.zip).
When I use it like /imgstrg/&lt;path&gt;.&lt;file extension&gt; and use a handler for /imgstrg and link a file server in the imgstorage outside of the project folder (which is what I meant by ../imgstorage) out it still never gets called. INF: File /Users/&lt;name&gt;/Documents/workspace/go/src/imgstorage/4c0/0f4/883/e23/f4463c0.jpg has been created. INF: Content of uploaded image (976914 Bytes) has been copied to /Users/&lt;name&gt;/Documents/workspace/go/src/imgstorage/4c0/0f4/883/e23/f4463c0.jpg. INF: serving static file =&gt; img.html with image 4c0/0f4/883/e23/f4463c0.jpg INF: request for /imgstrg/4c0/0f4/883/e23/f4463c0.jpg. 404, not found. INF: serving static file =&gt; error.html This is the upload success message and the error message when trying to fetch the image The handler looks like this: r.Handle("/imgstrg", (http.StripPrefix("/img", http.FileServer(http.Dir(fs.ImgStoragePath))))) fs.ImgStoragePath = /Users/&lt;name&gt;/Documents/workspace/go/src/imgstorage/ and my path string for the template is now being built like this (just wasn't on GitHub): img := Img{title, "/imgstrg/" + imgPath} 
That's a good catch, but why wouldn't Go consider values returned to a C scope escaped?
Thanks for trying to help. The error remains...I also tried to just place the directory in the project root and change the path in the template to /imgstorage/&lt;path&gt;.&lt;file extension&gt;. It can't even find that. It only works, if the imgstorage directory is placed in public/img/
The fs.ImgStoragePath var has no value assigned within the http package context. Please check that the variable has the right value.
It does have a value. The value is whatever you assign via environment variable or user input. In my case right now, it's "imgstorage/"
Nice project. I am interested by making a reddit notifier for telegram in Go, i will use this lib.
I chose it because I plan to, and I know many people like to, build corpora from Reddit. This makes it easy to share the corpora with others, and use them with other tools, distribute it between workers, etc.
I am a layman, but interested in linguistics. That sounds great. :)
What would be the advantages over [hugo](https://gohugo.io/)?
I wonder if it would be possible to build php extensions now? That would make my day.
Yeah baby! 
&gt; That comes pretty close to the template pattern. I'd call that an abstract method. There's nothing particularly driving it to be part of a template, it's just, unimplemented.
&gt; The types are not the issue, the question is, if the memory was allocated by go or by C. You can build a go string (with unsafe) that points to memory allocated by C and it won't be GC'ed. This is a good point, although I doubt people ever really do this. (You'd probably just return a `*C.char` instead.) I think the broader question still stands, though: why does Go allow you to return Go-allocated memory (such as strings, interfaces, etc.) via cgo exported functions if they could be GC'ed at some future unknown point? It seems like something that the compiler (or the cgo tool? I'm not sure on the breakdown) should be able to disallow, and probably ought to?
I managed to fix the problem. I now have a route /{id} to serve the html page with the image path and a route /img/{id} to serve the image file itself. So glad it works now. 
Sorry for picking nits, but I'm pretty sure every compression algorithm will need to be at least linear timeâ¦
Not really. You want both the main program and the plugins to share the same runtime and compiler-generated type info (for interfaces to work). Afaik that is not currently the case. So you would still need to treat the plugins as basically a separate process and wrap it to transfer type info and so on. And you can already do that now (just with separate processes). I might be wrong, though.
&gt; why does Go allow you to return Go-allocated memory (such as strings, interfaces, etc.) via cgo exported functions if they could be GC'ed at some future unknown point? Well, it is not necessarily wrong to return go allocated memory. You *can* do it correctly (if you make sure to retain a pointer in go). But I think mainly, the implications weren't really clear when go1 was released. But you'd have to ask the go team for a good answer to this :)
But the article points out, that goroutines work just fine? So, yes, while you are doing work, python will be blocked, but you can export a non-blocking API and do whatever work you want to do in the background.
FYI, I am working on a tool to automatically create CPython C extension modules, modeled after the gomobile tool: https://github.com/go-python/gopy there are a few Go constructs not supported yet (interfaces, maps, chans, funcs with pointers in arguments) but, hey, PRs accepted :) EDIT: it only supports python2 ATM. hth, -s PS: nice blog post.
Python is multithreaded, it's just that its GIL effectively blocks parallel execution. Native modules can release the GIL, which allows Python to execute other code on other threads. This is what the `PyEval_SaveThread()` and `PyEval_RestoreThread()` calls in the goroutine example do. For more info, see https://docs.python.org/3.4/c-api/init.html#thread-state-and-the-global-interpreter-lock
To paraphrase Ian on this: &gt; The compiler needs a target in which it can collect up all of the dependencies. Although the `func main()` will never be called.
Yeah, well said. Any time you interact with Python types you're going to need to take the GIL. I think the advantage to using Go in a Python module will likely be very self-contained tasks which could take advantage of the concurrency of Go or use some of its packages. "Go off and do this thing and let me know when you're done."
There's no mechanism yet to programmatically load shared objects at runtime. That's the purpose of the "plugin" build mode (see https://golang.org/s/execmodes), but it wasn't done for Go 1.5. 
I didn't think of it that way. I don't know if "constant speed" is a better term? What it refers to is that the speed doesn't vary (much) depending on the input. If you look at the times for the default compression it varies from 7 to 66 MB/second depending on the type of input you give it. That can of course be a huge pain when doing load balancing or use it for backups, etc.
Yes. Maybe one day it could be interesting to craft input that causes a big number of collisions in the internal go or zlib deflate hashing algorithm (they are different) to see how easy it would be to overload a server that serves user content with on-the-fly deflate/gzip.
another week, another static website generator ;)
&gt; Technically I'd imagine all practical conventional stream compression algorithms are basically theoretical computer science constant time per block. I don't think so. I don't know a lot about them, but AFAIK most compression algorithms use some kind of data structure that is built up during the course of the compression and which needs to be traversed for every new "block". So I would actually assume most compression algorithms to be superlinear, instead of linear (note, that technically this algorithm isn't really linear. It's only linear if we fix the alphabet size).
Yes, see below, I pointed out that the issue is, how the memory is allocated, not what it's type is. Note, that I can create a *C.char, that is backed by memory allocated by go, just as I can create a (go) string, that is backed by memory allocated by C (using unsafe). The type is close to irrelevant.
You are welcome.
With how it uses closures, I suspect it would cause a lot of garbage collection. Can anyone speak to that?
Agreed - the type is not important. Only how the memory is allocated, ensuring that it is not reclaimed by the Go GC as soon as the function exits.
Because some of us are stuck in hell, and whenever we try to get out, all the others stuck with us drag us down.
cheers!
&gt; only python-2 supported for now This is probably the single worst thing about Python. It's been 7 years and people are still treating version 3 as an afterthought.
Yup, already discussed here previously. See [this](https://www.reddit.com/r/golang/comments/3bqm94/isomorphic_react_with_go/) and [this](https://www.reddit.com/r/golang/comments/2s2agu/duktape_bindings_for_go/). Any isomorphic app don't have quite performance. It related to data fetching mostly. So, any isomorphic app should be cached.
You've at least 7 services there, three of which are databases (which are extra fun). You're likely well past the point that you need a configuration management system of some form. When I was investigating this over a year ago I looked at Puppet, Salt, Chef and Ansible and ended up using Ansible. This came down to it's docs being much easier to understand, and the design didn't have any obvious scaling issues in terms of config expressiveness that the others had. Though it turns out Ansible is only okay in terms of expressiveness (by which I mean the levels of exceptions, mixins and inheritance you need to manage a non-trivial configuration), something like http://flabbergast.org would be really nice to be able to hook in when things get really complex.
That's why it's everyone's priority. Probably some sites have moved to Python 3, but certainly not the majority, yet.
This is great. I've been using Go to write numerical code for a while now, but since astronomers generally only know Python, C, and sometimes Fortran, I've pretty much had to restrict it to stuff that would be used in house. I was planning on writing a bunch of CPython wrappers in the immediate future, so this could save me a ton of time.
It sounds like you want to say that the variance of the rate is low. "Constant time" is an entirely different thing.
Would love to have you take a closer look at OMV and let me know if you can help add features/ideas to the project to take it to a better level!
Have you looked at Kubernetes? I've recently been playing with it on AWS and started on Google Container Engine today... Really loving it so far 
Generally when I want to use Python 3 one of the libraries I want to use still hasn't updated and I'm stuck with it.
True, but then you're serving the location of your packages over an insecure link that anyone can tamper with. Github pages don't support https, and I'm a paranoid security guy :)
Good point! You could use Cloudflare to secure the client-server connections (see https://me.net.nz/blog/github-pages-secure-with-cloudflare/ ) but the origin server would still be using an insecure transport. I guess you get what you pay for :-P
It seems flummox is being deprecated in favour of Redux. Would you like to update your repo to reflect that ? On other note, its a very good effort. I love golang and React and a starter kit like this helps a lot.
Custom import paths were there before Go 1.4. What was introduced in 1.4 was a mechanism for enforcing them, so that a user could not have both `mig.ninja/mig/client/mig` and `https://github.com/mozilla/mig/client/mig`. Only the import path specified in the package can be used, if one is specified.
The best thing that could happen to python is that they halted all further development until they made a 3.X version 100% compatible with 2.7. It could even be through an emulator or some other mechanism that made some of the 2.7 code slow, but still worked in a 3.X environment, and you could eventually figure out what's slow and port it to 3 syntax. Next best thing would be to get the py to go and go to py stuff working well in 2.7 and 3 and then support bridging between the two :D 
Sure, I have an issue for that. See: https://github.com/olebedev/go-starter-kit/issues/1. I don't mind if some good man send me a pull request :)
If it would be absolutely identical parts, client and server, maybe it is correct to name this application "universal". But! The client and server parts is NOT fully identical. So, that's why I called it "Isomorphic". Check this out https://en.wikipedia.org/wiki/Isomorphism
But I mean exactly "isomorphic". And I don't know what for javascripters mean "isomorphic". Could you tell us?
You are right, I got the terms mixed up!
I have used Go to model and design concurrent massaging programs. so not much heavy number crunching (where C++ is still the king in my domain) but still better than python's capabilities (except if you correctly use numpy broadcasting, but physicists tend to prefer writing explicit loops, or shy away from wrapping their head around the broadcasting mindset) I have been using python as a vehicle for Go and a glue with the other C++ processing frameworks: all our main applications start from python, loading C++ classes via reflection. Interfacing any language with (c)python is easier than with C++, and physicists are already familiar with python so, I went with go-python, betting that, over time, they'd see how nice Go is :) I actually started with: https://github.com/sbinet/go-python where a sizeable subset of the C-API of python2 was wrapped, with the intent to be able to write python modules in go (and having the main in Go, starting the python interpreter, as was required before go-1.5) but it was still less than elegant (details of the C-API were leaking into Go) thus the new go-python/gopy binding generator. ah... you meant, extending go with python rather than the other way around? Well, for the kind of scientific applications I develop and maintain, extending/scripting go with python would hurt more than it would help (been there, done that with C++/python applications). Besides, the compilation time of go (even that of 1.5) is very competitive with launching the python VM and dlopening a bunch of .so scattered all over the FS. (and you get the nice single executable that you can distribute on the Grid, your cluster or what have you) 
Truth be told, implementing design patterns (and I am mostly talking about GOF design patterns) in Go like in any other OO language is redundant and unnecessary overhead. Given the nature of Go, as in not being fully object oriented, not supporting inheritance and being more functional than OO - there is no real need for design patterns. Simple function composition will solve you most of the problems design patterns try to fix. In Go world, people like to use word "idiom", which is something between a "pattern" and a "good practice". If you are looking for a solutions that mimics specific design pattern - ask away, and I'm sure a lot of people will help you out. :)
http://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/ Not sure if you are looking for something like this, but it is a good write up nonetheless. 
The first place to check would be the [official blog](https://blog.golang.org/index). The topics there vary wildly, but a few of them are useful write-ups of things like [context](https://blog.golang.org/context) and [error handling](https://blog.golang.org/errors-are-values).
No, you should never "provide" an interface, meaning you never pass `interface{}` to a function. You should receive an `interface{}` in you repo, but when you call it, you pass a `&amp;User{}`. I can make it more clear with more words. :D
I think I'm gonna go with the 3rd approach and do as you and /u/klaaax have said about having a common DAO which would be the base.go I think. I'd just add the common functions onto that and any model specific functions would go on the model's DAO itself.
Thanks for pointing that out. Fixed now!
I am aware of these libraries. I haven't used them either but I have also heard that they make your binary huge and they slow down compile times significantly. Also they might require some extra coding to handle the embedded assets. Is anyone here actually using any of these libraries to deploy single binary web applications instead of multiple files? Is it a good trade off? Any experiences?
This is exactly what I needed for a little side project of mine. Thanks!
&gt; It turns out that cross-compilation was one of the hindrance in writing an OS How did you get to that conclusion ? From the Goose readme: &gt; Go's lack of pointer arithmetic means you remain fairly dependant on asm to do things that would otherwise be trivial in C. 
You mean more of a disaster than python 3?
honestly, the runtime wasn't even that hard. Most isn't implemented, some is NOPed, and the rest is hand translated from c. The hard part is knowing how to make an OS in general, and using go doesn't make that any harder or easier.
Wow, bootgo (https://github.com/jjyr/bootgo) is a neat hack. It gets harder when you try to go further, though. A big difficulty is that much of Go's runtime relies on operating system calls, but when you *are* the operating system you can't do that the same way. Go requests pages of RAM from the OS, but when you're writing the OS you have to use the raw memory space you're handed by the processor or hypervisor. You can't ask the OS to write to a file or socket; you have to implement a filesystem and networking stack. You can't ask the OS to start a thread per core; you have to implement a scheduler to coordinate them first. Your code only gets to talk to hardware (real or virtualized). So you have to implement all these concepts on bare metal (or the hypervisor and/or very limited abstractions provided by system firmware), and hack the Go runtime to call your implementations rather than make syscalls. Julia Evans wrote a series of blog posts about writing a minimal kernel using Rust: http://jvns.ca/blog/2013/11/29/writing-an-os-using-rustboot-and-rust-core/ which is great for getting a feel for what it's like to work in kernel-land. Rust has the minor advantage that it's built from the start so that you don't have to include any runtime your program doesn't use, but there's still the unbridled joy (read: pain) of working without the things we're used to in userspace. Even in languages like OCaml, teams have built "unikernels" -- single applications compiled to run on bare hardware, in effect -- which is, practical or not, a pretty cool hack. MirageOS (http://www.cl.cam.ac.uk/projects/ocamllabs/tasks/mirage.html) is the name of the project here. I think OSes are tempting because it feels like a very advanced space. For my part, I'd be impressed if someone could make a substantial contribution to the practice of Go-y Web app development--how can I stand up a basic CRUD site more quickly without taking on all the ills of mega-Web-frameworks?--or static analysis to catch more of my bugs or any number of other things. We have OSes that we get by with, but there is a lot else that we still don't have. :)
I use https://github.com/davecgh/go-spew for printing deep object stuff for debugging purposes. And to look at them. 
Spew was another recommendation I saw elsewhere.
it always had.
&gt; imagine mouse lag because an interrupt handler allocated memory that triggered the garbage collector Offtopic, but still worth to mention here - earlier versions of OS X were adding a 32ms lag to the mouse input. http://iaintnoextra.tumblr.com/post/31374405045/john-carmack-and-osx-mouse-lag
&gt; The complete runtime is implemented in Go. I apparently wasn't very clear :) You would need to *re*implement the complete runtime and (in particular) everything it needs in go. "Go" wasn't the emphasized part of that sentence. :)
Video yet? 
There's also https://github.com/yuin/gopher-lua - I'm not sure how they compare. Anyone know? (Note this post is from March 2015.)
FYI the pprof_mac_fix may not be required if you're running 10.11 (el Capitan)
I think we'd expect nothing less for a non-beta release ;)
Nobody replied so I went and searched: https://www.youtube.com/watch?v=fVSgWh7iXwg&amp;list=PLzT643y4OYZp0K4YhPmmaLtnZzlVrbz0G It's not there yet but the talk is allowed to be recorded: http://yapcasia.org/2015/talk/show/6bde6c69-187a-11e5-aca1-525412004261 so I assume it will be uploaded later. 
AFAIK That feature is experimental, though. So there should be such discussion.
Is there an upgrade guide somewhere? It's not obvious what the intended upgrade path is, or what actually gets overwritten during upgrade.
Much prefer working with gopher-lua as it has a working luar implementation and all around feels more well designed.
What's there to break? It's not like it on by default. If you use it and it breaks something of yours you were the one who tried it out.
&gt; The problem is that those packages behave a certain way, and attempts to change how they behave to "improve" or "fix" the semantics will almost certainly break real use cases. Luckily, now we have go-fuzz, which can help detecting breaking changes... to a certain degree.
I used this with gopherjs so I could run lua -&gt; go -&gt; js in my browser. It was pretty fun, but kind of ruined by the constant unearthly screaming of Dijkstra from the afterlife. 2/5.
It's surprising how git subtree or even submodule is never mentioned in the context of vendoring. IMO it's the only sane way to be able to track the history of 3rd party libraries within your own code.
I could, but I am still learning all the node modules (reactify, webpack, css-modules) and how they all work. And I am pretty comfortable with original Flux, and learning redux again is too much of cognitive load for me :P
I am doing a similar research but I am in an early stage, I am interesting to know how is your research go.
I'm sure if they tried, it would split the community, stagnant development from most users' perspectives, and open the door for several other languages to come in and eat Python's lunch. That would really suck. It's better to hold fast to the number system, and join the golang sub-Reddit.
Sounds a bit like the "Gnome syndrome" to me. Go tends to become fundamentalist. You can see this as well in the discussion about generics. Originally their absence was only a trade-off because the authers didn't find a way to implement them in the first place. Go has received a lot of critics because of missing generics; and instead of trying hard to find a good solution (look at Rust) the problem itself gets a religious status: do you believe in generics or not? And, to be clear, I like carefully made decisions what to include and what not, but it shouldn't be a religion like the ridiculous minimalism of the Gnome project.
Alternatively with travis-ci (easier too!): http://loads.pickle.me.uk/2015/08/22/easy-peasy-github-releases-for-go-projects-using-travis/
Well, at least they aren't up to throwing features away like the Gnome team, are they?
Exactly. Why ask people in a forum, dedicated to the problem domain, about their opinion and advise when you can ask a search engine instead. Good job mate!
Check golang-nuts and the issue tracker and you might revise your opinion.
[**@bradfitz**](https://twitter.com/bradfitz/) &gt; [2015-08-22 07:40 UTC](https://twitter.com/bradfitz/status/634993448961970176) &gt; My \#yapcasia talk on \#golang debugging, profiling, and optimization: &gt; https://docs.google.com/presentation/d/1lL7Wlh9GBtTSieqHGJ5AUd1XVYR48UPhEloVem-79mA/view#slide=id.p (includes demo script notes) &gt; See Speaker Notes! ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Thanks! Travis deserve the lions share of the credit.
I find your analogy interesting. The reason Gnome failed implementing extreme consistency (what you call fundamentalism) in their UI is that the UI is a very personal thing, where adaptation to the user only has advantages. However, if the desktop was intended to be used simultaneously but many users (as a large code base), no tinkering at all would be a strong requirement to not turn everybody crazy. There is nothing more fundamentalist than a language spec, yet it is completely necessary. A consistent standard library is also a very good thing. There is always room for improvement with external packages.
in my code base, relative imports seem to be breaking, but it was a small project, therefore I changed relative imports to absolute imports and it is working seamless.
`&amp;thing{}` and `new(thing)` are not the same. They are only the same for struct types. `NewThing()` is misplaced in the list, IMO, because it is not part of the language, it is a pattern. Other languages call this a factory function and it is useful if there is some initialization you *must* do beforehand.(like, say, `os.Open`, which is the same thing, just differently named). There are also three things missing from this list: `var foo = bar`, `foo := bar` and `make` (which is kinda special). Go doesn't distinguish between stack and heap values, so creating a variable via `var` or `:=` and then returning an address to it is the same as using `new()`. I don't think anything of these *needs* to be taken out. The problem is kind of overblown, I use all of them often. If anything *needs* to be taken out, I would take out `new`. And possibly `:=`, though I'm ambivalent towards that one. It makes some code shorter/nicer, but it's semantics are sometimes confusing (especially to beginners) and you can get type inference with `var` too. There is also `make`, which needs to be taken into consideration somewhat. If I would take one thing out of go, it would be naked returns. I think they are the completely useless and a lot of the time actively harmful to readability. The second thing I might consider taking out are arrays. They have confusing semantics too (they are copied, unlike slices) and are awkward to use (if you have a `var hash [40]byte` and something wants a `[]byte`, you need to use `hash[:]`). I would also like to take out `string`, but that would need to be replaced by a `const`-like keyword for slices, pointers and maps. So it would trade a complication for a simplification and add a lot of power in the process. This would also work well together with taking out arrays. But: go 2.0 will likely never come (for appropriate values of "never"). It is completely futile to have this discussion until there is a RFC in regards to backwards incompatible changes.
I would allow var to be used only on the package level. Inside function bodies the short declaration syntax should be the only one allowed, in my opinion. Reason being that many people get confused about initialization and zero-values with the var-syntax without an immediate right-hand-side. In that aspect, the := operator forces you to be explicit about the value of whatever you're declaring.
Just out of curiosity: what were the dealbreakers? Did those Go versions violate the backwards-compatibility promise of Go 1?
Not really. A constructor is usually a class method, not a function and serves the expressed purpose to make inconsistent instances of a class impossible. The difference is admittedly subtle, but there is a difference.
There is a better way. Don't limit yourself to using `errors.New()` and `fmt.Errorf()`. You can (and often should) create your own error types that convey more information. For example, if you're implementing a parser, you might want to return something like the following. type ParseError struct { Expected []Token Found Token Position int } Give that thing an `Error()` func and it's an error. 
I understand what you mean. But it's [really called a constructor](http://golang.org/doc/effective_go.html#composite_literals).
That's because the dev of python 3 broke the compatibility without giving something good enough to compensate the annoyance and interest the python dev. 
&gt; I would also like to take out string, but that would need to be replaced by a const-like keyword for slices, pointers and maps. So it would trade a complication for a simplification and add a lot of power in the process. Interesting. Can you expand on this? Why don't you like `string`? How do you envision the `const`-like keyword being used? What power would it add? 
Yes, I know I can do it for my code, but I would like to see also in other packages. ```os ``` for example tries to solve it, but is ugly and not common. 
So lets say I want to deploy this to an actual machine. How would I go about doing that ? Can I create a bootable CD/usb from this ? If yes, how ?
Thanks! This is what I was looking for!
In two steps: i := 0 ip := &amp;i
To semantically answer your question, I would take out non-pointer method receivers. Non-pointer method receiver is just another function argument. It's redundant and confusing sometimes. It also fits the ideologically, by declaring a method receiver you are doing it because receiver should be mutable data the method operates on. What's the point in having immutable method receiver? Method receiver should always be mutable. It would clear confusion. For example when you implement an interface with pointer receivers, but then the value of your struct does not satisfy the interface. Pointer to it does. Solution? Method receiver must be pointer. And make both pointer and value satisfy the interface implementation. It is already working for non-interfaces, where pointer receiver automatically takes the address of that value (&amp;foo).bar() == foo.bar().
No, the backwards compatibility was theoretically fine, there was nothing wrong with the API. It was just sort of niche bugs that happened to impact our app in a negative enough way that we couldn't ship with them. I don't remember what all of them were. Go 1.4 in particular was a garbage collection bug involving CGO and uint16 pointers that caused an intermittent unrecoverable panic. Something that wouldn't affect most people but was totally a no-go for us.
Agreed, haven't thought about that apparently :)
`err.Error()` returns the error string.
For one it doesn't even support database drivers returning all types go has. Let's say you have a field that is an array of ints in your db. Now you have to return it as `[]byte` and create a custom scanner on top of `database/sql`.
I think the reason is, that `new(T)` creates a Pointer to a `T`, whereas `make()` does not create Pointers, but values. I don't think this is a *good* reason, but I think it is the historical explanation why there were two different keywords and then, with go1, no one thought about conflating them. One way to unify them, would be e.g. replacing `new(T)` with `make(*T)` (or `make(T)`, but I think the former is better understandable, because then `make(T,â¦)` always returns a `T`, no matter what kind of type `T` is).
For the sake of consistency, it should be possible to do it like this: `i := &amp;int(0)` But at the moment, the "cleanest" one-line solution I could come up with was this: `i := func(i int) *int { return &amp;i }(0)`
For questions about built-in types, there's a dummy package "builtin" which exists just to give documentation: $ godoc builtin error type error interface { Error() string } The error built-in interface type is the conventional interface for representing an error condition, with the nil value representing no error.
replacing new(T) with make(*T) is basically a great idea, it was even discussed at some point on the godev list, but they decided not to do it because they thought it would look too confusing to people coming from other languages. but honestly I think it lessen confusion, since coming from another language if you see new(type) is a thing, you're going to think it'll do constructor-y stuff and is the main way to allocate new types, when in fact in go you barely ever use it.
I saw on SO that you tried one suggestion and still need more performance. I would suggest profiling your program. If you still need help, then you can post all the supporting documentation and code snippets. Here's a guide: https://github.com/bradfitz/talk-yapc-asia-2015/blob/master/talk.md General things to be aware of: algo time complexity, burdening the garbage collector, and slice appends. 
I've thought about how cool this would be for zero downtime http servers. You could load new route handlers, and all of the current requests would finish executing under the old handlers while new requests would go through the newly loaded handlers. 
Named returns are okay, but bare return is the devil. 
You have a point.
"no-go" lol
 ip := &amp;0 sp := &amp;"" tp := &amp;thing{}
It's weird that it's not `.String()` instead.
To play devil's advocate here, your definition of "works" is "it compiles and doesn't crap out when I start it".
Wow, I'm a big fan of horrible puns, but that one was totally not intended!
I know this is silly, and something that can be fixed with a good IDE, but I am a function() { //stuff } Kinda guy. I'm not trying to start a holy war, and I know WHY Go forces a stylistic choice on you, I just really want that option. Maybe even as just a compiler option. Personally, I think problems like this that are silly and small are what's keeping a lot of people away from a lot of languages. As programmers, we like our creature comforts and our habits, and when a language doesn't cater to them, we don't like to use that language. I've been soldiering through this petty grievance because I really like Go and I think it will go far.
&gt; (for example: What if I do `type int struct{ â¦}`?) You'd get the same thing you get now with `new`: http://play.golang.org/p/zYx43z7NG9
&gt; Personally, I think problems like this that are silly and small are what's keeping a lot of people away from a lot of languages. I believe more people will be turned off by having no universal style for all go code, than will be turned off by not having their own pet style be universal. If that is really something that bothers you enough not to use the language you'd have to be pretty petty, IMO.
I think you'll enjoy using Go more if you learn to not sweat the small stuff like brace placement.
I'd try to get rid of the negative effects of null. Make the pointers act as if they were initialized with a zero value, like their non pointer counterparts.
&gt; I don't know. It is a convenience to not have a -&gt; operator, but I don't see a good way around requiring it, if it is really such a problem to not see whether a method uses a pointer or a value. It certainly is better than having no value receivers. Personally, I'd rather have the confusion over pointer and non-pointer receivers than to ever have to type `-&gt;` again. I have a limited amount of mileage left in my wrists. I'd like to preserve my ability to type as long as I can. :)
The return value inconsistency in `io.Reader`. The specification should say that implementations may return either a positive number, or an error, but not both at the same time. The current lack of that guarantee breaks the usual error handling pattern.
slices being invariant
Just like we have had a few community solutions for vendoring and versioning, I think we need a few "community official" solutions for templating to support parametric polymorphism, which is what people usually want anyways when complaining about generics.
I hope to see a thread on what Go 2.0 should add to the language, but saying more here will be out of topic. So I'll put my though when the post (and if) will be created. If already exists please link it in the reply.
You could also: type Vector [3]float32 And then define methods .X(), .Y(), and .Z() if you still really want to use those designations.
I had issues when upgrading from 1.2.1 to 1.3, so I've held off on upgrading until I have some time to do thorough testing. It turns out my original code had a bug in it that was actually producing the output that I expected (given my assumption about how bufio.Read worked). Some underlying change in implementation in 1.3 caused my code to break but it was expected behavior for bufio.Read... it just so happened that I had used it incorrectly. 
Why do you not want a VPS? You can get one for as little as $5 per month.
This is minor, but I'd like to see `log.Logger` become an interface rather than a struct.
Yes, definitely!
I think default values for function parameters would be a nice addition. The inability to overload functions has the drawback of sometimes causing code duplication. This would help with that. I'm guessing this won't happen, though, by the same reasoning that outlaws function overloading.
Yeah but if you now use godeps with the vendor folder it'll break testing or compilation. It's not a big deal, and yeah it's beta, but it doesn't just work.
&gt; Non-pointer method receiver is just another function argument. No, it's not. It's what decides whether a value implements an interface, and that's how Go achieves polymorphism. Remove interfaces and polymorphism from the language and _then_ they would just be arguments... but... uhh... that's a pretty different language. Much less useful.
Was this also a part of the fifth go challenge? 
Yes, strings are `[]bytes`. The differences are: a) Certain operations are disallowed on strings, like using an index expression as an lvalue. b) Thus, strings are missing a capacity-field in the in-memory representation, as reslicing them doesn't make any sense (you couldn't change the resliced contents so you would end up with zero bytes anyway). And c) the language provides you with syntactic sugar to range over the runes in a string. I assume c is what you are talking about? My answer to that would be, that this might be better done via the stdlib anyway. Treating slicing and indexing as a byte-wise operation but ranging as a rune-wise operation is a bit weird and inconsistent, IMHO (especially as strings don't *have* to contain UTF-8, for good reasons). I think an iterator in the utf8-package would be a better design for that, it makes the language simpler (hey, another thing I would take out!) and [is not a *lot* more difficult to use](http://play.golang.org/p/3yOsNkJy8S). [edit] Yes, my implementation of RuneIterator is not correct. Making it correct is left as an exercise to the reader :)
You're right, strings are bytes. I meant that a character is not a byte (c). Thanks for the insight.
I love this for the same reason I love the way Go handles pointers: it prevents magic from happening and keeps you in control of things that matter.
This seems to just over complicate a simple processes. All of that extra work to avoid setting your GOPATH?
I completely agree. Am I missing something? I'm not knocking docker whatsoever, but isn't exporting 2 system variables once then "go build x &amp;&amp; ./x" way faster/easier? 
I wish they would take out nil and support optional types; null checks feel primitive and old-fashioned and I don't see any reason to continue supporting the Billion Dollar mistake. Plus, optional types might streamline Gos error handling. Operator overloading would be really nnice too! 
Some men just want to watch the world burn
My fault for scanning the article and jumping straight to the repo :)
You can't do this on the playground, but put it in another file with an unassuming name, so no one notices it. 
I use OpenShift and I'm really happy :)
That's what I'm doing now on a 512 meg box - it works fine and only uses about 5 megs currently, but SSHing into the server is a pain to handle code changes (I don't have a good workflow set up yet). I'd rather do continuous deployment or something like that. 
This has caught me several times. I'd completely agree.
+/u/CompileBot go --with-errors package main var true, false = false, true func main() { fmt.Println((1 == 1) == false) }
TBH those things don't bother me at all. I don't mind having 2 ways to new something, as you've pointed out, one gives you the possibility to initialize the fields. The third isn't really a language feature, it's a guideline. For 2.0, I'd love to see the addition of operator overloading to allow 3D linear algebra code to look nicer that it does now. I understand the scare of seeing operators abused but the stdlib can and will set the tone for right usage of the feature. And, if I am allowed to dream, I'd like a GC that can run, on request for a given amount of time. GC.run(2) runs for 2ms and comes back. I am not a compiler/runtime dev so I have no idea how hard this is, but I really don't understand how this is not the standard for GC. 
I usually leap to Heroku for things like this, but Google Container Engine, RH OpenShift and/or Engine Yard are also decent options. Although I *can* set up a VPS (or many of them) without any issues (automated via Ansible/Packer), unless I want to spend time maintaining itâupgrading packages, monitoring alarms, potentially waking up at 2AM if the DO VPS diesâI typically prefer to push to an PaaS service. The nice thing about Go is that the performance:resource-usage ratio is so good that you can get away with undersized PaaS plans relative to things like Rails/Django/etc.
No, you can, go just doesn't allow the previous statement because the order of assignments changes what the operation does. This works: var true, false = 1 == 0, 1 == 1
IBM bluemix uses cloud foundry and is reasonably priced with a free tier. You could reasonably host 4 or 5 apps for free there.
Wait, then how does `stringutil.Reverse()` work in the go examples? http://golang.org/doc/code.html Is it because yours is a declaration?
I think that's an inconsistent way to tell them apart. If it can be converted to string, I think the method should always be named .String().
Reminds me of [this](http://stackoverflow.com/questions/30262509/union-object-acts-like-a-structure) question on stack overflow 
Appengine is freaking awesome. One thing to keep in mind, if you use 3rd parties librabries, you will need to hack their source code to use [urlfetch](https://cloud.google.com/appengine/docs/go/urlfetch/) 
No it is not built-in https://golang.org/ref/spec#Keywords
I don't really like switching on errors (if the program could fix the error, why didn't it do that the first time?) but detecting them is easy if you do: var SomeError = errors.New("some error") func Foo() error { return SomeError } if err := Foo(); err != nil { if err == SomeError { ... { } Or func IsSomeError(error) bool {...} if err := Foo(); err != nil { if IsSomeError(err) { ... } } The standard library tends to take this approach where you might care (ENOENT for file operations, for example).
Features: * User-space back-end for checking auth user|login data. * Optional sub-package which provide flexible brute-force guard, with the possibility to saving (or restore) state-database to your hard drive (or keep it in memory). * Possibility to use own back-ends for brute-force protection. * Possibility to use own/existing gorilla-compatible store for cookie sessions. You can try [DEMO](http://gelada-demo.drunk.systems/), and then look on a demo code [here](https://github.com/iu0v1/gelada/blob/master/examples/main.go). Doc's: [1](http://godoc.org/github.com/iu0v1/gelada) [2](http://godoc.org/github.com/iu0v1/gelada/authguard). PS: comments and critics are welcome; thanks in advance;
But it has vendor lock-in and is on the pricier of the sides
Downvoting-as-disagreement is considered poor reddit form but is very common on /r/Golang IME.
I actually found #define TRUE 0 #define FALSE 1 in the code of a developer that had been fired a few days before that. 
Can someone explain this error for me? I haven't started programming Go yet. 
Tip: Learn to read/write Haskell or something similar, after that you will spot things like this instantly. 
He has redefined the type with name string to be an int. So when he declares a string it is actually an int and hilarity ensues trying to assign to it.
It's not even the struggleâit's the time. Even an experienced vet with a library of Ansible scripts has to deal with the machine failing, updating it to handle CVE's, configuring new sets of keys. If you're a small team (or solo dev) then the effort quickly starts to consume a non-negligible amount of time.
That is indeed evil! 
Hm, I never thought about it from the extensibility angle. I mean, a minimalist language like Go doesn't seem like it needs many more builtin types. However, predicting the future is pretty tough, and you're absolutely right that this is necessary in order to add new builtin types.
&gt; Declare one, and voila, it is. No. Because if some package I use declares a *log.Logger for logging, I can't assign my interface value to it. I think declaring it as an interface (and taking out the default Functions) would encourage much more modular logging. The solution to this, currently, is to make your logger an io.Writer instead and then use log.New. But that makes it a lot harder to get meta-information and so on in.
&gt; Operator overloading would be really nnice too! Strong disagreement. There are *very* narrow domains where this is useful (I can think of Computer Algebra and Scientific Computing. Not really anything else) and for these domains, some DSL is better suited anyway. For all the other code, operator overloading just makes code surprising and complicated.
But that would negate every advantage of Pointers. If there is no meaningful nil, you could just always use Values. Think about how to implement a linked list with that. It's just weird. Even python has nil (or rather None, which is the same thing). [Edit] Come to think of it, I really can't see any language that doesn't have nil in some form or other. Haskell maybe. But I'd argue that even Nothing is just a way to write nilâ¦
If you program in Go, the vendor lock in doesn't matter too much.
The platform choice alone is a big win. It's statically compiled, therefore: * it doesn't break silently when either duplicity or python-boto updates; * it doesn't require endless fidgeting with virtualenv to try and downgrade to fix the above problem; * Go does not have a 2.7/3.0 split yet, so this tool and its libraries won't suffer from "version schizophrenia" the way duplicity does.
For many simple applications the choice of DB does not matter too much.
The one issue I have with using appengine is when I want to use SSL with a dedicated IP with it. It costs too much compared to if I go for someone like linode. Have a look at linode no complaints and it works well: https://www.linode.com/
My understanding of their pricing is they don't charge for container engine if you have up to 5 nodes, but container engine runs on top of google compute engine and you still have to pay for that so its not completely free!
I was more interested in how it works internally. E.g. what algorithm does it use for incremental backups? How does it achieve efficiency in operation? What kind of keys does it use and can it work with GPG keys (and what is the advantage of having the backup tool manage its own keys, which is the impression I am getting from the docs)? As for the platform advantage, I've worked enough with Go to have experienced every one of the above (besides a 1.0/2.0 version split, naturally).
'type string int' is at the end of the file.. (scroll down)
You can use the builtin Cloud Datastore, you can use managed MySQL or whip up any database you would like on Compute Engine. Also the integrated log service is really nice and free. No need for Loggly or something like that. 
Also, where is the vendor lock-in exactly and why should the guy asking care about it at this stage? Depends on which services you use and most of them are provided in some similar way or another by competing clouds. Logging, queuing, cron, nosql datastore are all services fairly easily to convert to equivalent solutions if it ever comes to that. In my view, trying to prevent vendor lock-in is a form of premature optimisation.
That is true. We pay $36/month for VIP + Google Apps is required. Although they say the GApps requirement is going away. But it's still there.
works ;P http://play.golang.org/p/ItdRLe2cy4
I guess it keeps the tool chain consistent and predictable as they are contained within a docker image. While ./x is nice, containers are much more powerful for deployment.
Thanks for this. This is some of the content that is really missing in the Go community. It's all there if you're willing to read the manual, but it's nice to have someone demonstrate the nuances making it easier to digest. For example, the --alloc_space flag is something that was lost on me. 
I think the first brace is required to not be on its own line due to the way semicolons are injected
Oh I have, and it works great for my own code. What I'd like more specifically is for there to be some mechanism of capturing the log messages of a package I'm using and sending them into my log configuration. It's not a huge deal, and low-level subpackages shouldn't log, but it does come up.
How does it lock you in?
A full hosting os, probably would be a lot of work and then your hosted apps would be subjected to the garbage collector. Now something like a lib on top of the XEN hyper-visor where you run native on a tiny image would probably be useful. Very much like mirage. Would be more targeted but still relevant and you'd let XEN deal with the real hardware.
Im going to give this a try i think... http://jmoiron.github.io/sqlx/ 
What C compiler + flags did you use? And what Go version? edit: So, using GCC (5.2.0) `-O0` runs at around 40 seconds. `-O3` runs at ~17 seconds. eric@archbox /tmp/c-vs-goLang-Quicksort/c $ ls Makefile quicksort.c quicksort.h eric@archbox /tmp/c-vs-goLang-Quicksort/c $ gcc quicksort.c &amp;&amp; time ./a.out 0: 1804289383, 1: 846930886, 2: 1681692777 took 38491.886719 0: 7, 1: 37, 2: 51 real 0m39.748s user 0m39.650s sys 0m0.063s eric@archbox /tmp/c-vs-goLang-Quicksort/c $ gcc quicksort.c -O3 &amp;&amp; time ./a.out 0: 1804289383, 1: 846930886, 2: 1681692777 took 16032.280273 0: 7, 1: 37, 2: 51 real 0m17.208s user 0m17.130s sys 0m0.063s eric@archbox /tmp/c-vs-goLang-Quicksort/c $ Go 1.5 runs at ~22.5 seconds. eric@archbox /tmp/c-vs-goLang-Quicksort/goLang $ ls quicksort.go eric@archbox /tmp/c-vs-goLang-Quicksort/goLang $ go build &amp;&amp; time ./goLang a1[0]: 5577006791947779410, a1[1]: 8674665223082153551, a1[2]: 6129484611666145821 n of 100000000 took 18.312330137s to run. a1[0]: 30554741346, a1[1]: 217339476874, a1[2]: 223812424683 real 0m22.488s user 0m22.353s sys 0m0.193s eric@archbox /tmp/c-vs-goLang-Quicksort/goLang $ Go always builds with optimizations on. Rob's said before in go-nuts that the reason there's no compiler optimization options if there's any they can use, they'll (safely) use them. With most C compilers, you have to turn on optimizations. The 17-22.5 second difference could very well be GC + Go's immaturity. 
I really like the look of this, wondering about deploying at larger scale simply due to simplicity and easy of use across different platforms - is it possible to restore single files? Or will it become possible? Either of these two answers would be awesome (with an obvious preference for option one ;)
Also using ints is a bad idea in this case. In C int is almost always a 32 bit number. Especially on 64 bit OSes and machines it's still 32 bit. In Go int is a machine dependent type, which is 64 bits on 64 bit OSes and machines.
a) If your data can't be NULL, use `string`. If your data *can* be NULL, you'll have to use `sql.NullString` or something like it anyway. I don't see, how that affects your "portability"? (I thinkâ¦ maybe? You can also use a pointer. Not sure) b) If you don't want to put `sql.NullString` like things into your struct, you can scan into an anonymous struct and then manually copy the fields over with whatever logic you like. But I find it difficult seeing your problem. I don't see how PHP specifically makes this easier?
 type __ *[]*__
the portability problem comes from the fact that the standard sql package does not contain a sql.NullDate so you have to use mysql.NullDate which locks you to the mysql package (not sure if theres an alternative in sqlite etc packages) I havnt tried a date pointer... Ill have to try that. I thought about the anonymous struct thing and its probably my best bet (because yes i dont like sql.NullString in my struct if i can help it) Im not having any PROBLEMS (i.e the code works) but the development of said code feels clunky is all... and when that happens I like to think theres a better way.
And php/java etc make this easier by allowing nullable primitives 
s * 1000 -&gt; ms Î¼s / 1000 -&gt; ms
I'd be very sympathetic to any effort to have language-level matrices in Go. (If for no other reason than that I'm getting pretty tried of writing `grid[y*width + x]` two dozen times per day, but the reason you mention is better.) I'd be interested in seeing some of these proposals. Do you have any links to them? (and to subsequent discussion?)
&gt; the portability problem comes from the fact that the standard sql package does not contain a sql.NullDate so you have to use mysql.NullDate which locks you to the mysql package (not sure if theres an alternative in sqlite etc packages) I havnt tried a date pointer... Ill have to try that. You can use a mysql.NullDate with any other sql driver too. Or just copy-paste the type into your own code and use that (then you don't need to import the mysql-driver. Also, in my experience, every SQL database has a different feature-set (in particular, dates are AFAIK one of the things that differ wildly) so you very probably are not portable between databases anyway. :) &gt; and when that happens I like to think theres a better way. I like sqlx whenever I need SQL stuff :) It gives a good tradeoff between simplicity and power, IMHO. [edit] To elaborate on portability: For example, how you give placeholder in prepared statements varies, sometimes you need positional arguments, sometimes you need '?' (I think mysql does that) and sometimes both work.
`sql.NullString` is a "nullable primitive". It gives you *precisely* the same semantics, just slightly different syntax.
21seconds against C's 17 seconds with -O3 is still surprisingly fast IMO - I wonder how Java would perform here, since Java was still outperforming Go in a bunch of synthetic tests from the language shootout not long ago. EDIT: fixed the figures
&gt; 17 seconds against C's 21 seconds with -O3 22.5 seconds vs C's 17 seconds, but yeah. I think it could easily match Go if you ignore warmup time. I tried writing this in Java but I've actually never written Java before and I keep getting heap overflow errors, probably due to using `Arrays.copyOfRange()` recursively.
Well its a struct not a primitive
&gt;I was stupid and deserve all the downvotes. Nice try, take my upvote.
Yeah, maybe warmup time is a contributing factor? Idk. eric@archbox /tmp/c-vs-goLang-Quicksort/java $ time java -jar Untitled.jar Sat Aug 29 12:58:05 PDT 2015 Sat Aug 29 12:59:20 PDT 2015 real 1m16.966s user 1m16.853s sys 0m0.113s Edit: running the quicksort 2000 in a loop brings the speed down from 1 minute to ~18 seconds. Although I think the JIT was optimizing out code so I'm gonna try it again.
I agree completely, which is why I think that `&amp;int{0}` is a perfect way to allocate and initialize a new int pointer.
Interesting. So if I understand the argument, the size of the integer being sorted will effect performance? But I'm only rearranging pointers and am not tracking the time to build the array of random numbers, only to sort it. I did try it with an array of 10k random numbers generated from excel and got roughly the same performance difference.
Thanks for this great explanation! go1.2.1. gcc 4.8 without any flags. I'm pretty new to programming in general and very new to c and goLang. Thanks for pointing out the optimization flags in c. Looks like I have some reading to do! :) Still very impressive that go is almost as performant as C!
Is this without jvm startup time?
What were the results for 1.4?
They discuss the differences between hot and cold JVM, and the conclusion is that it doesn't make much of a difference. http://benchmarksgame.alioth.debian.org/u64q/measurements.php?lang=java#about 
Those times also include building the array, no? The sorting was only 16.032s for c and 18.312s for go.
Regex-dna I consider a bit of a joke. I don't mean "I'm a fanboy and I don't like what it says about my favorite language, waaaa", I mean I'm a polyglot and it doesn't say much of anything sensible about a language. It basically seems to measure if the default RE engine uses Perl regex or an NDFA implementation. Useful in some sense, but if you don't like the default choice you just go grab the other for your language. Binary trees says something real about the GC, it seems to me from seeing other implementations in a number of languages. It's not surprising for Go to still be behind Java there.
Yes you do. Here is the error you will get when you try to use the default http client: Get http://www.google.com: http.DefaultTransport and http.DefaultClient are not available in App Engine. See https://cloud.google.com/appengine/docs/go/urlfetch/
Also: https://play.golang.org/p/6PUJYbSWDF package main import "fmt" func main() { if "x" == "xâ" { fmt.Println("this doesn't happen") } else { fmt.Println("but this does") } }
Go 1.2.1 was released in March of 2014 and a lot has happened since then, you probably want to check out Go 1.5 :)
Maybe that [Brad Fitzpatrick talk on profiling](http://yapcasia.org/2015/talk/show/6bde6c69-187a-11e5-aca1-525412004261) would be useful. 
Yeah, I compared the printed times, e.g. Sat Aug 29 12:58:05 PDT 2015 Sat Aug 29 12:59:20 PDT 2015
&gt; The 17-22.5 second difference could very well be GC + Go's immaturity. What in the Go program would either allocate memory or cause the garbage collector to be run? The only part I can see is the allocation of a large array at the start and then it's freed at the end. 
I understand that it should be performing better and there is obviously a bottleneck somewhere. Buy 20 req/s is plenty to handle "thousands" per day. Thousands of requests per day is very little.
It's hard to say what part of the code is running slow without seeing any code. But if I had to guess I would say there is is a lock somewhere, which is used in every request. This would explain the regular speed of a single request, but the slowdown when increasing the concurreny. Because basicly a request has to wait until the another request has unlocked. PS setting db.SetMaxIdleConns and db.SetMaxOpenConns to 1000 is not necessary and db.SetMaxIdleConns a high might reduce performance if a connection is closed by the database, but still waiting in the application.
The data files are plain text CSV and available from the public SCM Repository and I try to keep upgrades for different languages separate, so it's usually possible to see what changed from the version-to-version patch file. Here's a cleaned-up patch-file -- I'll leave it to those more interested to make the comparison clear: name,lang,id,n,size(B),cpu(s),mem(KB),status,load,elapsed(s) --- data.csv 2015/08/13 17:56:31 1.363 Go 1.4 +++ data.csv 2015/08/19 21:10:21 1.364 Go 1.5 -binarytrees,go,6,20,752,21.552,175716,0,60% 57% 56% 57%,9.438 +binarytrees,go,6,20,752,24.312,185988,0,55% 53% 54% 54%,11.332 -binarytrees,go,4,20,688,105.287,337552,0,92% 94% 92% 92%,28.494 +binarytrees,go,4,20,688,209.908,322420,0,88% 87% 88% 88%,60.204 -binarytrees,go,9,20,548,91.965,287616,0,17% 83% 0% 2%,91.957 -binarytrees,go,7,20,567,93.136,288796,0,0% 0% 100% 1%,93.145 +binarytrees,go,9,20,548,172.092,280696,0,50% 49% 48% 41%,92.604 +binarytrees,go,7,20,567,184.408,279044,0,52% 47% 46% 48%,97.377 -binarytrees,go,8,20,814,64.194,265788,0,86% 86% 85% 85%,18.901 +binarytrees,go,8,20,814,64.144,257128,0,80% 81% 80% 80%,20.125 -binarytrees,go,1,20,516,91.002,286328,0,1% 11% 1% 89%,91.021 +binarytrees,go,1,20,516,175.908,280024,0,46% 48% 46% 48%,94.746 -binarytrees,go,2,20,694,103.849,337948,0,92% 93% 92% 94%,28.131 +binarytrees,go,2,20,694,214.592,330164,0,87% 87% 86% 87%,62.155 -binarytrees,go,5,20,1000,114.033,337396,0,98% 98% 97% 98%,29.258 +binarytrees,go,5,20,1000,184.240,287692,0,79% 76% 77% 78%,59.782 -chameneosredux,go,5,6000000,957,7.348,1020,0,1% 0% 0% 100%,7.349 +chameneosredux,go,5,6000000,957,26.712,1740,0,72% 70% 70% 72%,9.484 -fannkuchredux,go,1,12,900,65.294,1024,0,100% 99% 99% 99%,16.464 +fannkuchredux,go,1,12,900,65.116,1788,0,100% 99% 99% 100%,16.379 -fasta,go,3,25000000,1344,6.172,2856,0,85% 85% 86% 89%,1.798 +fasta,go,3,25000000,1344,6.200,3956,0,65% 57% 76% 69%,2.327 -fasta,go,1,25000000,1036,7.308,1024,0,0% 1% 0% 100%,7.307 +fasta,go,1,25000000,1036,7.180,1772,0,1% 1% 0% 100%,7.180 -fasta,go,2,25000000,1388,6.649,11172,0,44% 74% 54% 46%,3.058 +fasta,go,2,25000000,1388,6.572,11736,0,69% 60% 48% 42%,3.056 -fastaredux,go,2,25000000,1236,1.744,1024,0,4% 0% 1% 99%,1.745 +fastaredux,go,2,25000000,1236,1.824,1748,0,0% 1% 100% 0%,1.824 -fastaredux,go,3,25000000,1237,1.746,1024,0,1% 1% 3% 100%,1.747 +fastaredux,go,3,25000000,1237,1.824,2180,0,1% 100% 0% 4%,1.824 -knucleotide,go,2,25000000,1531,144.169,265312,0,66% 93% 96% 58%,46.265 +knucleotide,go,2,25000000,1531,124.968,265904,0,60% 58% 100% 94%,40.160 -knucleotide,go,1,25000000,980,195.128,390420,0,93% 69% 88% 71%,60.999 +knucleotide,go,1,25000000,980,179.852,265824,0,91% 68% 99% 67%,55.386 -knucleotide,go,3,25000000,1399,30.710,256752,0,91% 99% 91% 91%,8.298 +knucleotide,go,3,25000000,1399,29.972,259884,0,91% 93% 93% 92%,8.141 -knucleotide,go,5,25000000,1268,72.347,272744,0,38% 44% 83% 100%,27.521 +knucleotide,go,5,25000000,1268,69.116,274556,0,84% 99% 43% 36%,26.558 -mandelbrot,go,3,16000,894,25.502,31748,0,100% 100% 99% 100%,6.413 +mandelbrot,go,3,16000,894,25.588,32184,0,100% 99% 99% 100%,6.443 -mandelbrot,go,1,16000,823,51.968,31272,0,100% 100% 100% 100%,13.037 -mandelbrot,go,2,16000,837,41.506,35380,0,100% 100% 100% 100%,10.408 +mandelbrot,go,1,16000,823,55.600,36268,0,51% 2% 100% 53%,27.453 +mandelbrot,go,2,16000,837,41.976,34720,0,99% 100% 100% 100%,10.545 -mandelbrot,go,6,16000,700,47.185,31116,0,100% 100% 100% 100%,11.819 +mandelbrot,go,6,16000,700,46.968,33192,0,99% 99% 99% 99%,11.837 -meteor,go,1,2098,2986,0.124,0,0,0% 0% 100% 0%,0.126 +meteor,go,1,2098,2986,0.124,0,0,0% 100% 0% 0%,0.127 -nbody,go,1,50000000,1310,22.925,1020,0,1% 0% 100% 0%,22.919 +nbody,go,1,50000000,1310,22.020,1732,0,0% 1% 100% 1%,22.006 -pidigits,go,4,10000,607,4.104,3620,0,1% 1% 4% 100%,3.866 +pidigits,go,4,10000,607,4.660,9912,0,27% 31% 33% 28%,3.921 -pidigits,go,2,10000,674,3.946,3612,0,69% 2% 5% 34%,3.772 +pidigits,go,2,10000,674,4.616,9336,0,31% 30% 26% 34%,3.889 -regexdna,go,7,5000000,652,87.186,467180,0,1% 54% 26% 22%,86.345 +regexdna,go,7,5000000,652,86.824,361056,0,3% 3% 3% 92%,86.370 -regexdna,go,1,5000000,733,151.843,579096,0,92% 73% 75% 71%,48.962 +regexdna,go,1,5000000,733,126.500,581808,0,74% 71% 82% 78%,41.622 -regexdna,go,8,5000000,785,86.779,513712,0,77% 100% 77% 77%,26.323 +regexdna,go,8,5000000,785,87.252,641832,0,93% 76% 77% 83%,26.655 -regexdna,go,2,5000000,789,48.491,549688,0,64% 64% 95% 69%,16.642 +regexdna,go,2,5000000,789,49.052,474400,0,68% 72% 76% 74%,16.969 -revcomp,go,3,25000000,543,1.135,160720,0,2% 1% 100% 1%,1.137 +revcomp,go,3,25000000,543,1.176,165936,0,89% 11% 3% 3%,1.153 -revcomp,go,1,25000000,1243,0.915,250680,0,88% 9% 26% 3%,0.755 +revcomp,go,1,25000000,1243,0.980,259504,0,91% 1% 25% 1%,0.837 -revcomp,go,2,25000000,546,1.106,160948,0,0% 0% 100% 3%,1.107 -spectralnorm,go,2,5500,668,15.781,1024,0,95% 96% 94% 96%,4.149 +revcomp,go,2,25000000,546,1.136,166076,0,98% 0% 2% 4%,1.116 +spectralnorm,go,2,5500,668,15.720,2112,0,96% 95% 96% 97%,4.102 -spectralnorm,go,3,5500,536,15.719,1024,0,99% 99% 99% 99%,3.963 +spectralnorm,go,3,5500,536,15.704,2892,0,100% 99% 99% 99%,3.954 -spectralnorm,go,1,5500,411,15.698,1288,0,0% 1% 100% 1%,15.694 +spectralnorm,go,1,5500,411,15.700,2904,0,100% 0% 1% 1%,15.695 -threadring,go,5,50000000,405,14.660,2080,0,0% 1% 1% 100%,14.658 +threadring,go,5,50000000,405,131.336,3212,0,53% 53% 52% 51%,62.868 
My guess is that you aren't sharing code for secrets but we can't really help you otherwise.
Yes, one thousand is the last number I tired :). I started with 30, 100, 200... but they all give the same result. 
i also update my benchmarks: https://github.com/kostya/benchmarks/commit/010f3ec72ebf5a7b1e2c78ac6ed7b7f76e4d1f52
Host the code in a private git repo. Set a hook on git to hit an update URL on your server that causes it to pull the changes and then rebuild.
Company policy, or what have you, totally understandable. 
Company policy :(.... After digging deep I found out if I ran the select query in db.Query without row scan and etc.. (I know DB.Query should be used if you expect results but just for testing purposes ) I get about 5000 req/second . On the other hand, this code causes cols, _ := rows.Columns() rawResult := make([][]byte, len(cols)) dest := make([]interface{}, len(cols)) for i, _ := range rawResult { dest[i] = &amp;rawResult[i] } result := make(map[string]string, len(cols)) defer rows.Close() for rows.Next() { rows.Scan(dest...) for i, raw := range rawResult { if raw == nil { result[cols[i]] = "" } else { result[cols[i]] = string(raw) } } results = append(results, result) } the req/second drops to 20. So the issue isn't if the DB can handle the request or not
&gt; You also get free SNI support. So you can have cheap SSL for your-domain.com but not all browser support SNI. To be fair, that's pretty much just IE6 on XP (Chrome on XP unaffected) and some early Android 2.0 versions. Even corporate users are on IE8 now. I agree that turning away users is bad, especially if you expect those kind of users, but the IE6 ship has definitely sailed.
If we're talking about large sizes then yes. You see memory is slow. And if one version does 2x more memory writes than the other, it's likely that it will be slower.
I just updated to gcc 5.2 and goLang 1.5. Here are my new results: * c: 17s * go: 23s
&gt; go1.2.1 Sounds like we have an ubuntu user who just did `apt-get install golang`. Do yourself a favor; `apt-get purge golang` and head over to golang.org and get yourself the latest copy of 1.5. 
&gt; Backups should be automatic and set up once. If you're not *testing your backups* on a regular basis you're risking catastrophic failure: * What if your backups are corrupted? Missing some files because you messed up a glob along the way? * Did you make sure your S3 permissions were correct? Did a software bug overwrite older backups? * Did a software update along the way cause incompatibility with your backups? * Ansible module deprecated? Syntax changed? Do your "from scratch" CM scripts still work 12 months later on a fresh install of Debian 8? No? * Did an attacker turn off the cron job that invokes duply each night? (I hope you're running Dead Man's Snitch) Streaming replication is something like [WAL-E](https://github.com/wal-e/wal-e) that can stream Postgres backups to S3 (or similar), allowing you to roll-back your DB every X interval (minute, if you so desire) and/or restore it to a new box and have it be up to date quickly. You get that 'for free' with services like Amazon RDS or Heroku Postgres, which is a big plus. I'm not sure what else I can add to this thread. You may think I'm overstating the failure modes, and you're welcome to think that. But I hope it illustrates all the "ops" related issues turn a $5 VPS into hours of regular upkeep and/or monitoring to keep running smoothly. Of course, if it's a tiny side project that doesn't matter, then do what you like!
Found gvm on github. Made it super easy to upgrade
That summary is unfortunately a strawman against itself, it doesn't reflect either the characteristics of the JVM or their own measurement philosophy. Specifically I have two complaints: 1. The "warmed" vs "cold" example they provide, show measurements being taken within the code, using good-old `System.nanoTime()`. Whereas none of the actual benchmarks have self-reporting measurements, they're all externally gathered. The actual benchmarks therefore include JVM start-up time but that "warmed" vs "cold" example doesn't, in either case. For short-lived benchmarks (anything measured in the low seconds), that's going to be a significant factor. 2. The "warmed" example isn't very warmed. It just drops the first iteration. Depending on the benchmark in question and various compilation threshold parameters, this may not even be running JITed code by the 2nd iteration; let alone the optimised version. Java compilation goes through several tiers. You would need to examine the output of Java Compilation Log to know if you were actually running the fully compiled version or not. Disclaimer No 1 - the description of their methodology and the code snippets do not match, I'm going by the code snippets. Disclaimer No 2 - this depends on the benchmark, some benchmarks take long enough on a single pass to have been fully JITed by the second iteration. 
Oh, that's easy: complex numbers. Is anyone using these?
Just curious, was he an old c programmer?
Wait... Is this surprising? I thought java was horribly slow.
That's only the JVM startup. It gets pretty fast after a while.
I'm still amazed this myth continues to persist. Java was slow 20 years ago before they implemented JIT compilation. For a very long time, Java has been one of the fastest languages available. It's unlikely to ever knock c and c++ off their perch, but it's not all that far behind for most workloads. 
I'd remove ```u := new(User)``` and only allow ```u := &amp;User{}```
&gt; It's a tough pointâ¦ ? &gt; Some other languages use pcre natively as their regex engine. I don't understand a standard library having a wrapper around pcre as having anything much to do with "natively". *iirc* the GHC implementation used-to provide arbitrary precision by wrapping GMP and, to me, that would make not allowing programs written in other languages to also use GMP *a bit too arbitrary*. Same with PCRE.
&gt; That summary is unfortunately a strawmanâ¦ That summary is not shown. This summary is shown -- *"The largest and most obvious effects of bytecode loading and dynamic optimization can be seen with the meteor-contest program which only runs for a fraction of a second. â¦ But please don't just assume those warmed-up timings will be a whole lot faster for the JVM programs shown here, at the workloads shown here."* &gt; The "warmed" example isn't very warmed. It just drops the first iteration. The "isn't very warmed" examples take between 2 minutes and 22 minutes elapsed-time for their 66 iterations (except meteor-contest). When 3 tenths of a second is a concern don't measure with "good-old System.nanoTime()" measure with JMH. &gt; You would need to examine the output of Java Compilation Log to know if you were actually running the fully compiled version or not. Actually, I have. &gt; the description of their methodology and the code snippets do not match Why would "the description of their methodology" match "the code snippets"? You're told that these are - "some **additional** (IntelÂ® Q6600Â® quad-core) elapsed time measurements" to compare "against the **usual** Java program measurements shown in the benchmarks game".
JVM is really fast nowadays (after it starts up). HotSpot continuously monitors your code's performance in near real time and looks for slow sections, then recompiles and optimizes them while it's running. It's ridiculously effective but it takes a little bit of time to find the slow points, so the longer Java apps run, the faster they get.
That's just the memory model of th JVM. It'll use as much memory as you give it and the more memory, the faster it'll go. If a Java process is sitting at 2 GBs usage it doesn't necessarily mean all that memory is allocated. 
glad im not the only one! I looked at gorp but gorm seemed more supported and it wasnt very unclunky either
&gt; Actually, I have. Good for you, there's no indication of this in that link however, hence it being open to interpretation. Someone was bound to have had the time on their hands to do it thoroughly, but strangely these are never the same people who write those articles - or if they are they just can't be bothered to share the proof. &gt; Why would "the description of their methodology" match "the code snippets"? Because it's quite confusing if they don't. &gt; You're told that these are - "some additional (IntelÂ® Q6600Â® quad-core) elapsed time measurements" to compare "against the usual Java program measurements shown in the benchmarks game". OK. So there are apparently thorough tests done, but not reported; a simplistic test done and reported, with misleading code snippets; followed by a big "even though it's completely different is is definitely the same". Well I'm convinced, sheer force of assertion beats presentation of actual evidence from deterministic test-cases. 
I did.
Well, for example, if you use regex in php, you're using libpcre. That's just how PHP presents regex, and any other way of using them would be counter to the design of the language. Go presents regex through [the regexp](http://golang.org/pkg/regexp/) package, which is part of the standard library. This is a library written in go, as is basically all of the Go standard library. What the submissions for regex-dna Go #2 and others does is include github.com/tuxychandru/golang-pkg-pcre/src/pkg/pcre, which is a lightweight wrapper presenting libpcre and converting between Go and C types. From where I stand, that's more elegant but hardly different from using [os/exec/](http://golang.org/pkg/os/exec/) to run 'grep' for pattern matching. 
X-Post referenced from /r/raspberry_pi by /u/dpapathanasiou [Go version 1.5 on the Raspberry Pi](https://www.reddit.com/r/raspberry_pi/comments/3iz3e4/go_version_15_on_the_raspberry_pi/) ***** ^^I ^^am ^^a ^^bot ^^made ^^for ^^your ^^convenience ^^\(Especially ^^for ^^mobile ^^users). ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher)
&gt; From where I standâ¦ You'd have a lot of people in-this-subreddit telling you that the other programs are only faster than the Go programs, because Go takes a different approach to regex ;-) 
You do seem to be confused. 
Thanks, mate! I was just about to go build it myself but the ADD took over and I started browsing reddit. Total Baader-Meinhof moment.
&gt; But I wouldn't use cgo to show how fast Go isâ¦ *"These are not the only compilers and interpreters. These are not the only programs that could be written. These are not the only tasks that could be solved. These are just 10 tiny examples."* Let's try to remember that 10 tiny examples should not be confused with a final definitive statement :-)
Would be great if you could post this as the solution to the stackoverflow thread you started - sure it will help a few souls out there :)
I think part of the reason that it's persisted is because of Java's insane RAM usage. If you have a large amount of RAM then Java is very fast, but otherwise it winds up paging to disk a lot, which slows everything down. I remember another set of benchmarks from one of the 1.5 betas which had Java as twice as fast as Go in one category, but using *5 times* as much RAM. Android Studio with one file open in a small project can use upwards of 3 GB of RAM. Similarly, [Minecraft Windows 10 Edition](http://minecraft.gamepedia.com/Windows_10_Edition), which is written in C++, uses about 200 MB of RAM just sitting in place after loading a world; normal Java Minecraft quickly uses 1.5 GB and keeps climbing.
I followed this link http://stackoverflow.com/questions/26564084/golang-restful-api-load-testing-causing-too-many-database-connections , however, It didn't really change the number of requests/sec by much. The only thing I can think off is because the Table is InnoDB so because the test is querying the same table and rows there might be a lock on the rows? . 
The number 1 thing that I'd like to see is functions in builtin to support using map[Type]struct{} as a set. union, intersection and difference would probably be fine. In the go code that I work with, people tend to heavily favor []Type over map[Type]struct{} because of the verbosity involved, when they are returning a set (un-ordered, unique list).
Not all Go ORMs can handle pointers to time.Time: https://github.com/astaxie/beego/issues/1019
I know that feeling. In java i roll my own DAO's using springs NamedJDBCTemplate its the only spring i can stomach
go 1.5 is available from the repos of Arch Linux ARM.
rand() returns a 16 bit integer, so the C version has to deal with a lot of repetition, which many quicksort versions [have trouble with](https://en.wikipedia.org/wiki/Quicksort#Repeated_elements). Like yours will swap all elements &lt;= the pivot, and the next recursion will be the size of the previous minus 1, making it O(n^2 ) on those small equal ranges. You probably want random() instead of rand().
These are some great benchmarks. Thanks for taking the time to create and share them.
In my case (with boltdb instead of mysql) the difference between getting 20/s and 20000/s was the time taken to flush writes to disk, to satisfy the "D" for Durability in ACID (requiring that transactions not complete until the data is fully committed to storage). On a laptop it was bound by the disk rotation/seek. On a server with a battery backed disk write cache it was instantaneous. If you're testing on a desktop/laptop without such a write cache, and you're using innodb, you might try the option "[innodb-flush-log-at-trx-commit=2](http://stackoverflow.com/questions/10458095/innodb-bottleneck-relaxing-acid-to-improve-performance)" to make it flush writes ever second instead of stalling transactions waiting for writes to finish immediately, at least to confirm or rule that out as the cause. On good server hardware you should not need such a workaround. Additionally, when testing with "ab" I like to add the "-k" option to reuse connections with keepalive, like any browser would. Like "ab -n 1000 -c 10 -k". Otherwise you're testing tcp connect round trips more than the server itself, though it shouldn't have mattered much with localhost. 
&gt; It basically seems to measure if the default RE engine uses Perl regex or an NDFA implementation. To a first approximation. To a second approximation, it measures how smart your regex engine is with optimizations for literal strings in regexes. The current #1 on regex-dna is there precisely because of its literal optimizations. This is actually an interesting thing to measure because a ton of regexes have some kind of literal string in them. So if your regex analysis is smart enough to degrade to literal substring search and stay out of the matching engine itself, then you end up with a regex engine that will probably perform well on regex-dna. Assuming you get the rest of the details right, of course. :) In this regard, i don't consider regex-dna a joke because its measuring a really really important class of optimiazations in regex engines. The problem is that folks might read too much into it without doing a proper analysis of what is actually being measured. (I don't mean to be uncharitable. The analysis is a lot of work. I've been wanting to write a blog post on it for some time, but always balk at the amount of work required.)
Thank you for your input sir. I will give it a try tomorrow and let you guys know how it worked out. 
Hmmmm. On one hand, that's frustrating because I'd really like to have access to language-level grids (even just 2D would be great, although I find myself working with 3D grids just as often, and higher dimensional grids are more annoying to manually index). On the other hand, the Go team's reluctance to add features that are less than perfect to the language is something I've always really liked.
Ah, good point. I'll do that this afternoon.
I really like how I could read through main and understand how all the pieces fit together. I think that one of the signs of good design is how easy the code is to change. Let's say I wanted to make this in to a command line tool. How easy would that be? The concerns about processing and http request is mixed in with the concern about how to store and retrieve shortened urls. I think those should be separated.
I might be missing something here, but I don't really see how doing your own routing means you don't need to use middleware? They seem almost unrelated. After all you don't *need* to use "middleware" at all. However if you do your own routing you can still use it if you want. The concepts are disconnected. In fact this is what I have done on a recent project. I've done routing myself, but I've wrapped the handler in "middleware" to do logging and de-compression.
Yes, mrjones did have a major rewrite a month ago. Still, I prefer the smaller API, structure, and better coverage of this implementation. Also authorization flow can be directly wrapped by an vanilla interface. I'm unaware of a real world provider which still allows repeated key values or RSA signatures. In either case, I'm open to adding support if a use case is found. I should allow the base round tripper to be configured as oauth2 does. I'll take that as an issue. Thanks. 
In the former, you've multiple threads accessing and mutating `sum`, so you'll have race conditions. Using channels avoids this, as would a mutex. https://golang.org/ref/mem has the full details. 
Note: If the public demo gets overloaded at any point, you can spin up your own instance using Heroku deploy button in the README.
&gt; In your second example, add the summing goroutine to the wait group. You'd also need to close the channel once the first set of goroutines are complete, so what you'd want is the `wg.Wait()` and `close(messages)` in a goroutine, and move the `for` into the main body of the code.
but if you limit the memory usage, java looses performance. there is no free lunch.
As one other note, since I've seen this problem mentioned on /r/golang a few other times before, bear in mind that processors take basically one cycle to add a number, and that as cheap as goroutines and channels may be, they're substantially more than "one cycle". You will see massive _slowdown_ trying to do this concurrently. In fact you basically can't get any concurrent speedup simply adding integers, because one processor can easily keep up with the entire memory bandwidth from your memory bus if all it has to do is add integers. Again, I know you didn't ask, but it comes up pretty frequently.
Here's another way to do it without data races. Start some number of concurrent summers, let them all share the input source, and then merge their results. http://play.golang.org/p/oKtq8GoI73 
The example limits memory usage to what's required, rather than what's required to run well. There will be a more sensible compromise.
Try putting long running tasks or the http response in a go routine? `go func(){ code... }()` this will put each response in a go routine and then your server can do other sheyot
liWamka
Sort of. Much of the core functionality is implemented via syscalls. None of that would work in a "pure go on bare metal" environment. The runtime is pure go, but it still relies on a bunch of c code in the host os.
I agree with this. Even if you embed a log.Logger in to your new struct, it does not satisfy a dependency for log.Logger. I'd like to see the same thing for http.Client. edit: removed quote
I wish geohash didn't have the problem with edge cases, where nearby locations have completely different prefixes; it'd make it a lot more useful.
What's wrong about the scoping rules in Go? I think they're pretty much what you would expect for a block-scoped language designed in recent years. Or is it just that you're not used to block scoping? That seems to be the issue with many new gophers who seem to come from languages without it, like Python. edit: Really, it's remarkably straightforward. Take a look at the spec: https://golang.org/ref/spec#Blocks (plus "Declarations and scope" immediately following it)
This proposal addresses safety when it comes to passing pointers between Go and C code: https://github.com/golang/go/issues/12416
I strongly disagree with any first-level language support for matrices. IMHO, what makes go a great language, is that it is slick. To keep it slick, any new features should only be included, if it will be used in the *majority* of programs written in that language. I don't see, how matrices make this cut. What matrices are to you (and people in a similar domain as you are, which naturally biases your view on how big the relative number of people wanting this is), functional tools are to other people. For example, I would like to see algebraic datatypes and operator overloading, as I'd like to use go for computer algebra. I'd like to see weak references, as that allows very slick database APIs. But I can totally see that these features are edge-cases. Most programs won't and shouldn't use them. So a DSL is better suited for that.
Cross-compilation comes as standard, just do 'env GOARCH=arm go build ...'. Add GOOS=linux if compiling on non-linux.
&gt; That semicolon could be part of the if syntax, though. [It is](http://golang.org/ref/spec#If_statements) &gt; It could even be replaced with &amp;&amp; (and the assignment could evaluate to true). Ugh. Assignments aren't expressions for a reason.
&gt; If anything needs to be taken out, I would take out new. And possibly :=, though I'm ambivalent towards that one. Heh. My first thought was `:=`, but my second thought was "If I post that I'll get downvoted to hell".
That's right, but it's not the case for all geo hashes some implementations fixed the issue
It's alright, but not perfectly good in my opinion. Definitely not as good as Go. It's way easier to build, and ship systools created using Go (hell, you don't even need to install Node and npm dependencies). Goroutines also makes it really easy to work with concurrency which is useful in say processing large reports / logs. And personally, I find structs, and interfaces in Go to be incredibly powerful. That, coupled with its *semi-strict* typing makes for a very organised, but simple codebase. I personally don't think it's short-sided at all. It's the reason why loads of new dev/sysops are developed in Go instead of Node (Heroku, Github, Salesforce, HashiCorp, CloudFlare, bit.ly, and CoreOS are among the many companies). It's a great language (with a superb compiler).
Ah, c'mon. Javascript isn't a good language to begin with, and Node's event loop is a terrible abstraction.
Ah apologies for my late response, I forgot to check back. That's unusual. The size of the entire package (with `node_modules` installed) shouldn't be larger than 12MiBs. I had a look at the source code. It's a bit convoluted for me to comprehend, but it seems like during the unmarshalling process, it'll attempt to convert it to the return type that is set (`string` in this case). It recognises when a struct is returned, and if _contains_ a string (or even a pointer to a string, i.e. `char *`), it'll read until the null terminator. Alternatively, you could define the return struct, and [read from it as a string](http://tootallnate.github.io/ref/#exports-readCString), but it seems like it can make inferences about that already (depending on the ffi implementation - node-ffi supports it).
Yes, we're always getting more and more memory since it's invention and yet we always end up using it. Talking about memory like an inexhaustible resource in a dangerous path Java people once went down --I know that's not what Go team is doing, but I guess some Go haters/punk-hipsters will nitpick this particular blog post, which uses an argument proven wrong by time.
If anyone is interested in the original article the GC is based on, [a PDF is at Leslie Lamport's page at Microsoft Research](http://research.microsoft.com/en-us/um/people/lamport/pubs/garbage.pdf). 
1. No. There are many nice packages which already solve this issue. 2. In my case it's doesn't needed. However, this functionality is really needed in most cases. I will add this feature as soon as possible. Thanx. 3. There is no problem to add some hook-handler. But users already have ability to use own auth back-end (AuthProvider). In this function, you can implement any method of two-factor authentication. 4. I can implement this feature, if someone need it. But it's will be only wrap around existing library. It would be redundant, because this functionality can be obtained with using ready-made middleware packages, IMO.
Great post! Code reuse has been an issue in Golang. This was very thorough. From my perspective unnamed type `interface{}` should be used with extreme caution. It makes sense in this example, but we don't want a bunch of gopher younglings making every parameter `interface{}`. It is statically typed for a reason. Casting can be costly. Switch statements can clutter. If there is a way of grouping under a common interface, we should focus on that. Even if they just have a Write() function or something :) Loved the post. Just wanted to add 2Â¢ for anyone new.
Go 1.5 doesn't support MIPS yet. I think gccgo is the only option at the moment.
Go1.5 doesn't support MIPS yet; gccgo is the only option for the time being for YUN. I think there's ongoing work to implement mips64 in Go1.6 and adding mips32 later.
Thank you for the feedback provided, I applied go fmt and improved some of the error handling syntax
Quick review: * http://goreportcard.com/report/hlandau/service * Combine import statements * Combine global var declarations. * stutter "sdnotify.SdNotify" -&gt; "sdnotify.Send" * stutter "exepath.AbsExePath" -&gt; "exepath.Abs" * stutter "caps.DropCaps" -&gt; "caps.Drop" * remove negation "caps.EnsureNoCaps" -&gt; "caps.Exist" Otherwise it looks really good and nice to use.
Thanks for the feedback. I've rectified some of these issues.
I put a zero width space after the second x.
http://golang.org/dl/ ?
I had similar issues when I started a couple of weeks back. What follows is what I've learned (as opposed to best practice) **1:** Go really doesn't have nested packages ala python &amp; co. even though on disk the packages are nested within other folders... in other words net/http != net.http net/http *is* the http package located inside the net folder (which itself must be a folder that can be found from ${GOPATH}/src/.....) **2:** Even though a go package is contained within a folder, any *.go file in that folder with the package &lt;packagename&gt; declaration belongs to that package **3:** package main is the executable, and its entry point is the function main() Ok example time! GOPATH = ~/home/edayo/gostuff gostuff/ --src/ ----myapp/ ------http.go ------json.go &lt;file: myapp/http.go&gt; package main func main() { ... } &lt;file: myapp/json.go&gt; package main func json() { ... } given this structure running $ go build myapp will create an executable file called myapp because of the **package main** declaration. Now that I have my app built! I decide to add handlers and I'd like to put all handlers in a handler package. gostuff/ --src/ ----myapp/ ------http.go ------json.go ------handler/ --------index.go --------users.go &lt;file: myapp/handler/index.go&gt; package handler func getIndex() { ... } &lt;file: myapp/handler/users.go&gt; package handler func getUsers() { ... } I can now make use of getIndex() from my main function as follows &lt;file: myapp/http.go&gt; package main import "myapp/handler" func main() { handler.getIndex() } I typically tend to put utility code in lib so... gostuff/ --src/ ----myapp/ ------http.go ------json.go ------handler/ --------index.go --------users.go ------ lib/ --------tools.go &lt;file: myapp/lib/tools.go&gt; package lib func validate() { ... } The validate function can now be used elsewhere in the app as follows &lt;file: myapp/handler/users.go&gt; package handler import "myapp/lib" func getUsers() { lib.validate() } I hope this points you in the right direction.
Appreciate the detailed reply, but I was referring to seeing more examples of architectural design patterns. I do think more people should be writing examples as you have there, with package and filename included!
Oh ok. I agree. It would help a lot to see design patterns of that sort as well as a discussion/mention of the trade offs involved. One such that I've picked up along the way is to build my main app as a package and have a cmd package that creates the executable myapp/ --cmd/ ----myapp/ ------main.go ----installer/ ------main.go --installer/ ----installer.go --myapp_main.go - &lt;file: myapp/cmd/myapp/main.go&gt; package main import "myapp" func main() { myapp.Run() } - &lt;file: myapp/cmd/installer/main.go&gt; package main import "installer" func main() { installer.Run() } - &lt;file: myapp/myapp_main.go&gt; package myapp func Run() { ... } - &lt;file: myapp/installer/installer.go&gt; package installer func Run() { ... } Key benefit is that it makes testing somewhat more robust. Personally this approach has also made it easier to reuse my code in other projects as the structure helps me think in terms of composition which results in my writing more focused loosely coupled packages.
me too
Do you mean that you set GOROOT_BOOTSTRAP to the root of the source tree you just built and then tried to rebuild it? That won't work; the tool binaries get deleted as part of the build process, making it kind of difficult for the bootstrap process to call them.
Again, I mean in a more architectural sense. Designing the project as a whole rather than how you should format your code.
[removed]
so for the bootstrap, where and which tools should be there?
[This site](http://www.golangpatterns.info/) has some pretty good design pattern stuff. Sounds silly, but I usually just google "golang design patterns" to yield some pretty good results. Lots of gophercon stuff has excellent examples (pipelining with chans, stuff like that).
That's my question too!
It may not be the best to use the flag package from a package. execpath is incorrect. Args[0] is entirely arbitrary, it can say anything. A correct version is here: https://godoc.org/github.com/kardianos/osext Have you seen: https://godoc.org/github.com/kardianos/service ? 
How on Earth has "we have lots of RAM now and will have more in the future" proved _wrong_ by time? I can't hardly even requisition a server at work with less than 32GB of RAM. If I try, they look at me funny. Servers are, of course, a major use case for Go. But in practice, I find it to be very memory efficient in general as well. [The Go team certainly isn't being more slovenly than Java](http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=go&amp;lang2=java&amp;data=u32), and my runtime allocation generally pretty much resembles what it ought to based on the code I wrote. If you're using 16GB of RAM with a Go process, I all but guarantee you you're doing a lot of useful work with it, not "wasting" it. And the only time I've had a Go process just sort of chew on RAM indefinitely was when I had a true memory leak, written by me (can't blame a language for keeping in memory what I told it to), which was very quickly diagnosed by the built in memory profiling. I mean, if you accept hand-crafted C code as the golden standard [it doesn't even fare too badly against that](http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=all&amp;lang=go&amp;lang2=gcc&amp;data=u32)! So, how does this in any way resemble a language design team ignoring RAM usage issues?
You'll need a seperate, existing, precompiled Go toolchain. You can get a precompiled toolchain from the [Go download page](http://www.golang.org/dl). Put it somewhere temporary, and then set `GOROOT_BOOTSTRAP` to it's path when you run `all.bash`. Once that's done, you can use the newly compiled toolchain instead, although a toolchain can't be used to compile itself. If you want to for some reason, you can just copy the `src`, `pkg`, and `bin` directories into a second directory, and then set `GOROOT_BOOTSTRAP` to that directory's path.
I don't think I dial every time. The design was to dial once, create an original session and then copy whenever it is needed in order to reuse the socket pool
I dimly recall learning years and years ago that writing daemons in a garbage collected language is Bad. Anyone care to enlighten/correct me?
I've found [this post](http://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications) to be most helpful understanding how interfaces allow you to architect your code in a clean, and easily extensible fashion.
I'm not an expert, but I think the regex stuff is skewed because of the implementation of their benchmark. If you look, it recompiles the regex in a loop. There might be a better way to do it that will be more sensible.
&gt; If the path does not exist, RemoveAll returns nil (no error). So, when 'Deleted: ...' is printed, if you `ls` that exact path immediately after the program runs, the directory definitely exists?
&gt; Go is a strongly-typed language so itâs possible to build convoluted APIs based on pedantic type distinctions, but the end results will be fragile and ugly â just like in Java or C++ . . . Personally I like to use the empty interface for plumbing and only pin things down to specific interfaces or concrete types where I need to for performance or correctness. :( :( :( A blemish on an otherwise good article.
It's true that abspath(argv[0]) is not strictly guaranteed by the OS to point to the executable path. But it would also be very unusual for it not to. At that point, you'd have to basically be trying to break things. The alternatives, such as reading /proc/self, aren't portable. Well, I suppose that isn't a big deal since all sorts of non-portable functionality is supported, but abspath(argv[0]) seems good enough. Still, since your package seems very extensive in its platform support, I'll switch to it. kardianos/service looks interesting and I'll take a good look at it. Edit: [I've postponed switching to osext.](https://github.com/hlandau/service/blob/master/exepath/exepath.go#L12)
I have saw Viper, it is good, but there are something different: * it looks too heavy when use it (when use shell env, set default, get variable...) * no `required` validation * configor could handle configurations for environments
Yes, after execution with no errors, the directories definitely still exist. The only possibly weird thing I'm doing is that I'm simply executing with go run instead of compiling and then executing. I have several things like this I just treat as scripts.
A good place to start: https://github.com/golang/go/wiki#learning-more-about-go
And then look here: https://github.com/golang/go/wiki/Projects
Apparently you don't understand mockery.
1.5
Here's an article that I just came across that addresses larger system design with go. Might find it useful: http://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/
So I had an idea a while back but never was able to execute on it... Go has been at the forefront of a resurgence of interest in command line application development. There are hundreds if not thousands of really interesting programs out there on github and the like. Someone could write a program (ala godoc or go-search) which found all these programs and built a way to visualize or search for them. (I mean its pretty easy... just look for `package main` go programs) Super-useful utilities like [lantern](https://github.com/getlantern/lantern) (which lets you circumvent censored regions) or [ngrok](https://ngrok.com/) (which lets you run servers locally which are made accessible over the internet) or the craziness that is [terminal-ui](https://github.com/gizak/termui). But there are also programs just sitting out there. Like this [tetris](https://github.com/k0kubun/tetris). Did you know that thing actually works in windows? There's something really special going on here and I don't think very many people know about it.
It should work, so this is a bug. Open an issue: https://github.com/golang/go/issues
Ok, there's some cool stuff in here catching me off guard.
Code looks wrong to me.. You are walking root, but joining with the current directory to get the full path. Why the discrepancy?
I believe `RemoveAll` doesn't check if the directory exist or not, it will just tell you that it deleted it. Your code will work if you pass to it relative paths, because you are getting the current working directory and appending that to whatever `Arg(0)` has, so if your current working directory is `/Users/reddit/Desktop` and you pass `/Users/reddit/messy` it will try to cleanup `/Users/reddit/Desktop/Users/reddit/messy`, but if you'll pass the directory relative to your current working directory so `Arg(0)` will be `../messy` it will work. PS: pay attention to your `fmt.Println` messages
Passing around empty interfaces (and always munging them into the type you need) is pretty gross. I'd also argue that, since every program needs correctness, it's quicker to do things the right way to start, instead of running into more debugging headaches down the line.
I tested your code without editing anything and it works just fine with relative paths. I'm using OS X 10.10.5, GO 1.5
Looks great, I would change the return type from `interface{}` ("any") to `struct{}` ("void"). Although that would require a more verbose `return struct{}{}`, so maybe it's not a good idea after all. It's just style.
Thanks! So my guess there is probably an error not being reported preventing the delete.
I won't pretend to understand the issue you stated, but is osext not reliable on linux? I have always experienced it to return the absolute path to an executable. Or perhaps the absolute path isn't what you want in this case. Mostly interested in case there is something osext can do better.
It's important to distinguish between the absolute path and the real absolute path (i.e., the path that is both absolute and dereferences all symlinks, such that the resulting path involves no symlink traversals.) /proc/self/exe returns such a real absolute path. But that destroys the context, which some of my code makes use of. i.e. the issue is that, for the path to the program $PROG, the value of dir($PROG)/.. varies based on whether $PROG was realpath'd or not. This becomes a problem when launching a new process, which is used for fork emulation. Certainly, this is a rather obscure quirk of UNIX on which I have come to rely. I should probably stop relying on this behaviour, so I'll have to consider changing it. But the only alternatives are to use paths relative to the root of the filesystem or maybe store things in $GOPATH, neither of which are very good for e.g. local configuration files. /etc/foobar.conf is fine during production but not development, and $GOPATH/etc/foobar.conf would be feasible although weird.
Maybe you are overtesting or you are doing too much in init?
thanks for sharing this.
&gt; Create a file in the package with a build flag !test There's no test build flag, so it won't work.
Don't do important stuff in your init() for the very same reason you don't flag.Parse() in init() of the main package when it has tests. Separate the logic to a global function and call it from main().
tried looking here http://robpike.io/ivy/mobile but there's nothing yet. As a side note, that page is fun: http://robpike.io/
The convention is that when you define such a method, you mention which interface it's part of. So by implementing String(), you're implementing (in this case all of) the Stringer interface.
My bad... =] http://github.com/lucasvmiguel/goauth
&gt; But thereâs one thing thatâs intriguing: the thread-ring benchmark got regressed significantly. What it does is âpass a token between one thread and the next thread at least N timesâ, so I guess the new GC is not doing optimally in the concurrent execution. This test is probably not exercising the GC so much as exercising changes re GOMAXPROCS. The go runtime attempts to optimize for this sort of "worst case" use of go-routines, where go-routines are invoked in a chain with little or no parallelism between them. See "Worst cases" in https://docs.google.com/document/d/1At2Ls5_fhJQ59kDK2DFVhFu3g5mATSXqqV5QrxinasI/edit. In addition to GC, GOMAXPROCS changed significantly in 1.5. In 1.4 the default value for GOMAXPROCS was 1, but in 1.5 it was changed to be the number of CPU cores. When running tests comparing 1.4 to 1.5, it would be helpful to see results with comparable GOMAXPROCS settings. For the quad-core system, I would guess that these benchmark results are comparing GOMAXPROCS=1 with Go 1.4 vs GOMAXPROCS=4 with Go 1.5.
&gt; x509: certificate signed by unknown authority &gt; If you get this error it means the certificate used by the SMTP server is not considered valid by the client running Gomail. As a quick workaround you can bypass the verification of the server's certificate chain and host name by using SetTLSConfig: Unfortunately, if you haven't discovered this already, you will: At scale, SMTP servers do _not_ have correctly configured TLS. In the general case, you have virtually no choice but to always deactivate that. Unfortunately, as a result, encryption in the SMTP world is a joke, and MITM is virtually impossible to stop in the general case. Personally I fully support the aspiration shown here of defaulting to secure and having people discover themselves that they can't actually send emails securely. Every person who learns about that and becomes bothered by that takes us that tiny step closer to someday fixing the problem. However, I observe that from a pragmatic point of view that shipping a library that basically defaults to not working due to a security hissy-fit is a bit harsh. Let me be 100% clear: It's the stupid real world to blame here, not your code.
Now I totally can't reproduce this. I am guessing it was something environmental that prevented the delete, but for some reason it wasn't raised as an error. Ohh, well. It works on my machine :)
Maybe you should take the Tour of Go (http://tour.golang.org/welcome/1) first.
I went the route of duplicating code for every database struct. In the end I found two things change between structs. 1) One is the comparison to see what fields need to be updated. In go all fields in a struct are set with their zero value even if you didn't define them when you initialized the object. You have to be aware of this. type Santa struct { HoStrength int64 Phrases []string } func (s *Santa) Update(newS *Santa) { if newS.HoStrength != 0 &amp;&amp; newS.HoStrength != newS.HoStrength { s.HoStrength = newS.HoStrength } // check length and range over strings being aware of "" empty string } 2) The other is dealing with the conventions of the database package your using. Mgo mongodb pkg has a type M map[string]interface{} for storing data and sql sets columns with func Exec(columns interface{}...) and func QueryRow(columns interface{}...). Other pkgs may behave differently. In each case you have two options 1. hard code it or 2. create one func using the reflect pkg to iterate over the fields in a struct. 1) Hard code dbSanta := mgo.M{ "hoStrength": santa.HoStrength, "phrases": santa.Phrases, } db.Exec(santa.HoStrength, santa.Phrases) 2) Reflect I'd take a look at this stack overflow. http://stackoverflow.com/questions/23589564/function-for-converting-a-struct-to-map-in-golang It links a package that will handle turning structs into map[string]interface{} which is useful for mgo and []values which is useful for sql. Other than those differences, I like create a SantaDataStore struct {} and define my functions on that instead of the struct itself because it allows me to have different datastore backends for each struct, for example a redis and an SQL. **In the end...** You can get away with doing most of it with reflect, and then do a manual comparison function to compare the new struct and the database version
Well, part of why I suggest that is that if you try to do this with the standard library, the first thing you're going to end up doing is... writing your own ORM-esque sort of thing. Maybe not literally, but close enough. If you're writing real CRUD apps, ORMs aren't a bad idea. Many of the ORM problems arise when you consider them as the _only_ method of accessing the DB, and then try to jam then in everywhere, even where they don't belong. If you consider your ORM as _a_ tool rather than _the_ tool for accessing the DB, and use them only on tables where they make sense, and keep the ORM away from anything that isn't CRUD-y, they aren't so likely to turn into monsters.
&gt; When running tests comparing 1.4 to 1.5, it would be helpful to see results with comparable GOMAXPROCS settings. [Contribute comparable programs.](http://benchmarksgame.alioth.debian.org/play.html#contribute) &gt; For the quad-core system, I would guess thatâ¦ The program code is [available](http://benchmarksgame.alioth.debian.org/u64q/program.php?test=threadring&amp;lang=go&amp;id=5#sourcecode).
Sorry I should highlight that it's the function declaration without a parameter name is what I'm confused about
Its perfectly allowed in Go. Replace that `X` with a `string` and you can see that it works just the same. 
Take a look at [the spec](http://golang.org/ref/spec#Function_types). Function declarations have a parameter list which is made up of types, optionally with identifiers. For example, `func example(string)` is perfectly valid. If one of the parameters has an identifier, however, then all of the parameters in the same list must have identifiers. It works very similarly to return values: `func (r *reader)Read([]byte) (int, error)` vs. `func (r *reader)Read([]byte) (n int, err error)`. I believe that part of the reason for this is simplification. Parameter and return value lists have the same syntax, and they all have the same syntax in all uses. For example, interface declaration: type Exampler interface { Example(int) } or type Exampler interface { Example(n int) }
Fair enough. You can still encounter this even internally though. I have.
Yep. That is why I mentioned it in the FAQ.
Well, no, this is a web site, but I think you answered this question by your answer in the other thread.
Looks like they've already decided [you only get one option to tweak](http://blog.golang.org/go15gc).
Not 100% sure I did this correctly, but I submitted a very small change to KP's program that, on my machine, doubles performance. https://alioth.debian.org/tracker/index.php?func=detail&amp;aid=315157&amp;group_id=100815&amp;atid=413122 (The submission process seemed a bit byzantine, so I'm worried I might have missed a crucial step in the instructions somewhere).
Say I'm writing a function to satisfy an interface, I need to include all the parameters to the function even if I don't need them. This allows you to place a parameter without using it. Indeed you could do the same giving it a name as well, but if you are not going to use it why name it.
Neat! I maintain a [similar email library](https://github.com/jordan-wright/email). Always nice to see other approaches. Keep up the great work!
Last year the talks were recorded. I assume they will be again this year.
Here are some details about this Learning Path collection of videos, the $99 price ends on Sept 2nd Introduction to Go Programming Presented by John Graham-Cumming 5 hours 17 minutes Mark Bates on Go Core Techniques and Tools Presented by Mark Bates 5 hours 14 minutes Mark Bates on Go Database Frameworks and Tools Presented by Mark Bates 1 hour 35 minutes Mark Bates on Go Web Frameworks and Techniques Presented by Mark Bates 5 hours 51 minutes Go, the new open source language from Google, is known for its simple syntax, rich library, easy concurrency, and scalability. Itâs used in software systems where âscale big and run fastâ is the daily mantra. As you work through real-world examples and task-based lessons, youâll learn the complete language and discover how useful Go can be.
This is the fundamental nature of interfaces, you never have to declare that you support an interface. The fact that your "object" implements all the methods of the interface means that the object implements the interface. It is an automagic property. Pair implements a method called String() string. This is the only method required to satisfy the Stringer interface, therefore, pair can be a stringer. You can say, it walks like a duck, talks like a duck therefore it is a duck. 
Thanks everybody, now I understand.
Ahhh, the Go way^TM
I don't know the answer to your question, so I'm not trying to dodge out of answering it. If I wanted to figure it out, I'd use the [benchmarking tool](http://golang.org/pkg/testing/). It's fairly easy to set up. If you need help figuring out how to properly simulate an http rendering call, holler here and somebody will help you. There is one special case to note here, though. As Determination points out, Linux has special support for taking a file and stuffing it down a socket without any userspace intervention. Your benchmark probably won't trigger that code, and you'd have to use an external profiler to see the "real" speed. Unless you're going to serve many thousands of small pages per second from static files, though, it won't matter. (Of course, if you are doing that, it may.)
I think it does. &gt; Recently, I saw an article on Reddit that claims âthe Benchmark Game has been updated to Go 1.5. Other than regex and binary trees, weâre equal to or faster than Java across the boardâ. That was quite surprising ... 
By implementing String, pair satisfies the interface for Stringer, and thus implements Stringer. It's that simple :)
Is there a way to partition Go programs so that part of the program runs with GOMAXPROCS=1 and another part with GOMAXPROCS=4 ?
He says that he finds the comparison to Java surprising. 
One option, depending on how the program is structured, could be to use runtime.LockOSThread: https://golang.org/pkg/runtime/#LockOSThread
&gt; If one of the parameters has an identifier, however, then all of the parameters in the same list must have identifiers. One can use blank ones, though: `func f(_ int, _ string) { ... }`
And that makes you what? Cocksucker? Cunt-head? What are we teenagers?
Sick burn, bro.
You're hopeless.
[This is you](https://i.imgur.com/dXCIeMc.png)
[removed]
IMHO it helps to have a neatness fetish when programming. a) I use scripts to automate the install of Go tools in one location b) I use scripts to set up each of my projects in a separate GOPATH. Because I use the z utility this is easy and saves a lot of clutter. So each module (or closely coupled group of modules) will have it's own Repo. This stops my head exploding with the complexity of lots of mixed up things -- benefit! And because I try and automate as much as possible it does not feel like I am losing any convenience. (caveat -- I do not program large things)
I have one GOPATH on my system, which is not a repository. I have two types of repository: Go code repositories, which directly contain *.go files, and Go environment repositories, which contain other files. Projects which build executables, rather than libraries, generally have a corresponding environment repository. These may be named &lt;project&gt;.t, where &lt;project&gt; is the code repository. Environment repositories typically contain any documentation files, configuration file examples, HTML template files, etc. They contain a simple Makefile which does the following: - If a GOPATH is already set, use that. Otherwise, set the GOPATH to this directory. - If the GOPATH is not set to this directory, symlink {bin,src} to $GOPATH/{bin,src}. - Run go get &lt;project&gt; if it hasn't been run yet (this is recorded by an empty file named .gotten) - Run go install &lt;project&gt; This has some advantages: - People familar with Go can work with the code repositories how they like, and use go get. - People unfamiliar with Go can just clone the environment repository and run 'make', even if they don't have a GOPATH set. This is easy to explain. - The structure of repositories imposed by the go tool is quite suboptimal for repositories which need to contain lots of documentation, templates, assets, etc. These can go in the environment repository, keeping the code repositories clean. Since some of these assets may need to be built via makefiles and non-Go tools, some build scripts would be necessary in any case; this keeps them separate. - If someone doesn't like the environment setup, they can customise it while still using the same code repository. There are some disadvantages: - Two repositories to keep track of, commit, push, etc. - ./bin/ points to $GOPATH/bin/, which means that depending on how you design the program, it will consider the directory above the directory containing the executable to be either $GOPATH or the environment repository. This requires some care if this is important, e.g. if it uses executable-relative paths like $BINDIR/../tpl/ to find templates. If you get the executable name via abspath(dir(argv[0])), this works fine. If you realpath argv[0] or use something like readlink /proc/self/exe, it doesn't.
This is what I'm wondering about. As /u/Determination talks about, though, static files are read off disk which could be slower than parsed templates cause they're held in memory. I'm wondering about sites that have a high load with hundreds and thousands of templates, though. That would be a lot of memory but it's not something that affects what I do. Until his answer, I was thinking of parsing the templates but saving them to disk as static files, instead of immediately sending them out on the wire but, as I said, then you have the slowness of reading them off the disk.
Pretty much https://envoy.co/ Should have added that in the comment.
File a feature request bug.
while the post is context free, I did go read the code and go "hmmmmm!" which was worthwhile for me.
This article looks like an introduction. It states that existing successful package managers have standards of rich metadatas. But it doesn't even start to explain why those metadatas are useful (neither for the other languages or for Go). This isn't obvious to me.
A little late, but it's honestly even simpler than that: export GOOS=windows export GOARCH=amd64 go install std Only bad taste from the article is that the simplicity of this isn't mentioned in the article. Feels like YAAGP *(yet another gb promotion)*. Installing from source isn't event required. On windows, for instance, you can download the 1.4.2 and 1.5 archive distributions and do: set GOROOT_BOOTSTRAP=c:\path\to\go-1.4 set GOOS=linux go install std
Just commented on this, applicable here: https://www.reddit.com/r/golang/comments/3hy0n3/cross_compilation_with_go_15/cupdzqo It's not that complicated.
Yeah, I've used Python and previously Perl for almost 2 decades in total. I can't think of a single time I looked up any package metadata beyond name and version. 
Iâd like the use of comments as compilation directives to be removed. Comments should be just that: comments. Changing or removing them or adding or removing an empty line shouldnât change the generated code.
btw, the casting only works with fixed-size structures. For example, https://play.golang.org/p/_rgpOuHkkP
Extremely handy stuff, eh? Ease of cross-compilation is one of my favorite features overall. :P Hope it helps.
I think that source code is not an appropriate medium to store this information. We are already starting to see mistakes like custom import paths and generate directives in the code when they should be outside of it. Other attempts like godeps and gb work, but they are not well designed. Go should have a metadata file if we want to have a good dependency system.