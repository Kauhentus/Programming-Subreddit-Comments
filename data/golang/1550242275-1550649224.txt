Oh goody, another Linux distro. Oh goody, another Linux distro for running containers. Oh goody, another Linux distro for running containers securely. Oh goody, another Linux distro for running containers securely with Kubernetes.
Viper looks super cool! Yes I do have a config file under the hood. Two ways to load the config, loading the config file via a cli option and via an http post request. Some options are configurable via environment variables as well. Will definitely check out viper as well. I was interested in knowing what people are comfortable using. Is directly working on config files quicker or does a ui makes life easier?
All good man :D. I generally have the same feeling about another Linux distro. Expcept this one of course ;)
Thaaaaank you! Godspeed. Just one last question there is one particular condition in the simple API i need to implement - "It shouldn't be a REST API, assuming that the class will be isolated from the controller tier. If you think of this within a web framework, it’s a class that might be instantiated within the view layer" Does this directs towards clean architecture too? And what exactly does instantiating a class in view layer works? Just need to confirm. Again, thanks for all the help. 
Thaaaaank you! Godspeed. Just one last question there is one particular condition in the simple API i need to implement - "It shouldn't be a REST API, assuming that the class will be isolated from the controller tier. If you think of this within a web framework, it’s a class that might be instantiated within the view layer" Does this directs towards clean architecture too? And what exactly does instantiating a class in view layer works? Just need to confirm. Again, thanks for all the help. 
I expected a video.
Interesting! It looks like http.Request.MultipartReader() does indeed call mime.multipart.NewReader() which goes and sets up the whole reader bit, including checking to see if it wasn't setup by another MultipartReader and some calls to things like mime.ParseMediaType() to double check it's actually multipart etc. Now, in setting that up it eventually only uses http.Request.Body with is public, and has mime.ParseMediaType() figure out the boundary from the headers. So you could go ahead and 'shadow' mime.multipart so to speak, and change that constant (possibly calling it yourself and feeding it the http.Request.Body and boundary). In reality though, I wonder if it would make a big difference. Sure, you'd get fewer calls to Read(). But even now I'm sometimes not getting the full buffer filled (a smaller buffer like 512 bytes will, but a 4K buffer will sometimes not read more than 3951 bytes). So the next question would be, would a client like a browser who's uploading a file actually send more than 4K blocks?
Thanks, that makes sense 
alpine is not good enough anymore ? i based all my work on alipne is it wasted!!! nooo!!!! :)
It'll be released in a week or so, CERN is in charge of that
:D luckily it is not. Talos can't be used as a container. Strictly for making a machine a Kubernetes node.
once you issue JWT token authing request is not that expensive. It is basically a fetch from db and some hash generation in worst case scenario.
Great! If you can, please publish a link here when it's out. Would be awesome!
Rrally ? i see them usually around 150-200 bytes. That is less than average HTTP header. I don't think it will be a drag on performance unless he plans to send like 500000000000 per second.
Oh ok, that is fine. Good luck guys. 
Because in one case you're using a string and in the other a rune (i.e. you have actually made two allocations) Read this: https://blog.golang.org/strings
Thanks!
Francesc you’re the man. I really like your knowledge sharing content and how you are involved in the Go community. But it could be any community, you just sparkle the joy everywhere! Just for func, FOSDEM and now CERN?! Thanks for doing this for us all :)
What about distroless from google?
&gt;Interesting! Haven't seen that one before. But you can imagine Talos as distress but not as a container. Talos is installed with a kernel, initramfs and root file system. It is similar in that there is no package manager, no shell, and in this case the "app" is the kubelet.
As the saying goes, C gives you enough rope to hang yourself, C++ gives you enough rope to hang yourself... and a gun. 
Definitely looking forward to days 2 &amp; 3!
its using epoll on individual connections which have their own go routine so i dont think the multithreaded concerns you bring up would apply
I applaud efforts like this. A suggestion: tell potential users why to use Talos vs other minimal distributions like CoreOS.
Appreciate it! Excellent suggestion, and we are already internally discussing this as a result of the response from Reddit.
&gt;contractual obligation thank you for your response unfortunately, I am in the obligation to use golang or other solution that has a binding to golang. if there is any, please help me
Thanks! Doing my best to share some knowledge!
This way I don't know if I can pipe the data in the PUT request. I think the best option is `io.Pipe()`.
You can use types instead of callbacks to make API for routes much more friendly :D
&gt;Does this directs towards clean architecture too? And what exactly does instantiating a class in view layer works? If you haven't taken the time, please watch the video. In YouTube you can speed up the player to 1.5x. Clean Architecture allows you to separate IO concerns, like REST or HTTP RPC, from the core of your business logic. The true entities as you'd find in REST are the business models. The View Model is the JSON/Response structure you return from your controller. You're controller is the ViewModel. The Input/Output of the Use Case (Uncle Bob calls them Adapters) separates your controller from the logic. Let's say you watch the video and try something like I recommended. You can easily plug in your Use Cases to gRPC (HTTP + RPC by Google) as you can plug in to REST API with Chi. For each, the controller will map its input to the Use Case Input and include a Presenter. In the case of gRPC, the presenter will make the Output to the gRPC contract response. In the case of REST, the Presenter will have the w ResponseWriter instance as part of its state. For an advance topic, transactions, checkout [https://www.deusdatsolutions.com/#tricky\_transactions](https://www.deusdatsolutions.com/#tricky_transactions)
Yes, it also has to do with the way UTF is encoded: [https://en.wikipedia.org/wiki/UTF-8](https://en.wikipedia.org/wiki/UTF-8) Check the table of encoding examples, that explains the difference
The no shell part gets me though. Maybe you could have some sort of secure process to decrypt a partition that would overlay the filesystem with some subset of standard system utilities, and then it gets locked back up when the login shell is exited, or something like that. I just think something like this heightens my security concerns in some ways. How would I go about deploying a HIDS or antivirus? How would an IR team go about getting packet captures and doing whatever other investigations? How would I go about mirroring traffic to a NIDS? Obviously these things don't depend on a shell, but deploying and managing them often does. I think it's a hard sell to a huge portion of the market without the manageability issues solved. That's my feedback anyway. Hope it's somewhat helpful at least.
0x20ac is the Unicode rune for the Euro character. 0xe282ac is how the rune is encoded into a UTF-8 string. If you check the [Wikipedia page for UTF-8](https://en.wikipedia.org/wiki/UTF-8#Description) it has a handy table of how various Unicode rune ranges are encoded into bytes. 20ac is in the range that takes 3 bytes to encode; the first byte is 1110xxxx, then you have two 10xxxxxx bytes. So: ``` 11100010 10000010 10101100 1110xxxx 10xxxxxx 10xxxxxx 0010 000010 101100 = 0010000010101100 = 0x20ac ```
Have you ever looked at Wicket? [https://wicket.apache.org/](https://wicket.apache.org/) I think that this is what Go is missing. There are plenty of REST routers out there. I have not found anything in the Go world that allows complex, server side renders. Why server side renders? SEO. Right now if you want to have SPA that renders on the server you have to jump down to Node or Rhino in Java. Such a hack. A framework like Wicket allows you to render on the server, and on the client with Ajax enabled (but fall back to the server). Something like Go + Wicket should reduce memory and increase speed.
Excellent points. In theory, you should be able to handle most of this via Kubernetes. You can sort of think of Kubernetes as you're userspace. not 100% convinced that works for something like AIDE, but we have intrusion detection in our radar. The whole "deploying and managing " bit relies on Kubernetes. I hope that helps!
Yes, I know how go works, thanks for asking.
Why should it be? 
I’d recommend a couple of things. First, abstract the storage from a map[string]int to an interface, perhaps name SequenceCounter. Second: why read in 10,000 characters? Use a bufio, read the first five, then one at a time. Slower? Perhaps by a little, but easier to understand, may use less RAM, and is pushes a chunk of complexity down into super well tested standard library code.
Don’t check the splice length, check the number of bytes read.
Well I didn't say it should be. It would be nice to have a language infrastructure that was syntactically sweet like python go or Julia. That was as fast as go or Julia that was portable like python is mostly because of anaconda. Or that was portable like Java. basically it would be nice to have a language that had all the pros and none of the cons of a modern language
By the way why should any language be object-oriented? Code reuse.
Indeed, very bad mistake on my part. I avoided the common deferred mutex unlock due to the additional overhead. This did in fact result in a race condition. I've fixed this in the most recent commit. To ensure that this does not happen again, I added tests that would trigger Go's race detector in the event of a data race. It tests all exposed methods. I've also added the race flag to the CI builds to ensure that builds with race conditions are considered failed. Thank you for spotting this!
I’m quite confident it does. 😊 They added HTTP/2 quite some time ago... https://www.nginx.com/blog/nginx-1-9-5/ 
You can reuse code in go also, requires some more detailed planning but it can be done. I’m not talking to oop levels but you can get close enough.
I don’t believe I suggested every reverse proxy does...
Right so how do I find out if it ever will be expanded to Oop?
This. I use the Viper package in my go apps and Kubernetes w/ config maps that can be updated on-the-fly.
OOP is a con of modern languages, particularly with respect to inheritance. What aspects of “OOP” are you looking for that packages, types, methods, struct embedding and interfaces don’t cover?
Please define OOP. 😎
Go is object oriented. * Types have methods, including basic data types. * It offers [encapsulation](https://tour.golang.org/basics/3). * It doesn't have explicit inheritance, but [allows a user to compose objects](https://en.wikipedia.org/wiki/Composition_over_inheritance) with mechanisms like [struct embedding](https://golang.org/doc/effective_go.html#embedding). * It allows polymorphism via interfaces. What do you think is missing? IMO, go implements OOP much more cleanly, and with much more flexibility than some other languages.
While it depends on the implementation as to whether it would be considered idiomatic, the concepts of OOP can definitely be expressed in Go. &amp;#x200B; As for adoption, most prefer to use the right tool for the job. If I'm writing a server or cli, I'm writing Go. If I'm working with AI/ML, I'm writing python. &amp;#x200B; Many languages can be simultaneously functional and oop and procedural, and so it can often be just a stylistic choice based on the type of work you're doing. &amp;#x200B; Structs are similar enough to classes, you can embed other structs for encapsulation or composition or inheritance, you can uses interfaces and embedding for polymorphism or abstraction, and everything can be an interface{}. &amp;#x200B; The shift here is really in the role of satisfying interfaces by duck-typing rather than explicitly declaring which interface you're implementing. &amp;#x200B; Hope that helps
*Praise Talos*
Sure, but can it run Skyrim?
A router is a router. A router has nothing to do with the way you render your views. If you want SSR, do SSR. Where's the problem? 
I built [a command to download and upgrade](https://github.com/lpar/goup) using the binary package from the main Go web site. Doesn't have Windows support (yet) though.
Thank you your response was very helpful. so I guess this is different from C in the following ways (outside of just syntax): declaration of interfaces which one must implement and the fact that methods can be associated within structs? if you have experience in a traditional object-oriented programming language versus go would you say that go feels more natural and helps to avoid some of the issues present in 00P such as changing a base class and incidentally changing the behavior of a child class?
Learning from tenF0ld in other comment.
Also thinking of a concrete example like the QT framework in C++... Would inheriting from some widget object and then extending the functionality or making its specific to what one would want be easy and go just as it is in python or C++?
Hell I’d love to know myself, but as a guy who *wants* a Go gig. 
This.
Unfortunately you are wrong. Nginx DOES NOT proxy http2.. it "converts" it into http1/http1.1
Honestly, just Google "remote golang jobs", and look at where the job aggregators get their data from. There's also a `#job-market-only` channel [in Discord](https://discord.gg/jtAfKFy).
There are Qt bindings for Go that solve this through a base widget type that gets embedded into custom widget types. You get a similar effect in that the custom widget gains the base functionality through thr automatic delegation to embedded types methods. 
That's really cool. If you were to set up a brand new GUI framework would it be more awkward and/or difficult and/or more code then if you used a traditional object-oriented language? I would like others opinions on how this style of o o p is in terms of whether or not it's natural and whether or not it takes more or less code etc etc to do certain things. I know I could go do a project myself as I have in the other languages that I've learned for trying to avoid that 😁
I don't think so, and thanks god, ken, rsc, rob, etc that GOLANG is not OOP
The posted tool looks like it’s trying to help with html template sites. My question is how about something like Wicket for go? This project reinvents routing. Why not reinvent template rendering instead?
Go by design is intended to be used flexibly, it offers OOP when you need it, but to use other paradigms when you need it as well 
You've already got arbitrary cropping and blanking in the base library with the compositing functions built in. All you need to add is anything that can draw your polygon - such as the github.com/llgcode/draw2d library with the draw2dimg component. Use draw2d to render your filled polygon to a new Image, then use the Porter-Duff compositing with mask implementation in image/draw and use that polygon image as your mask. They give an example using a circle and a font-glyph at https://blog.golang.org/go-imagedraw-package. Doing the same with a polygon is trivial.
Hah! I can tell which slide you pointed out Pikes draconian syntax highlighting B.S. (10 -&gt; 11)
RemoteOk seems a place. I’m London based and just picked up a remote Go Job via snap.hr So there’s a few options I guess?
this doesn't answer my question: what is your current problem? why would you need to re-invent template rendering?!
Why are you being so toxic though? I was seriously curious about your position and if you are consistent with your position of avoiding panics at all costs, but it seems like you are not interested in having a respectful discussion.
A "full" ring buffer should not overwrite the oldest entry, but it should block until the pointer to the oldest entry is incremented to free up space.
&gt; What do you think is missing? As per Alan Kay's definition, message passing. 
This looks good. Epoll, select, kqueue are nice mechanism that often get a skip for many people.
Your channel example is actually better than the code in the this repo as it blocks when its full, instead of overwriting the oldest data and losing data if you have more Puts() than Gets(). However if you have written a proper ring buffer before that uses mutexes or atomics for locking and benchmarked it for your application, you would will find that each has different performance characteristics and depending on the use case will out perform the simple channel example. In my experience in a high performance application I first implemented channels for a simple ring buffer, but it resulted in the code profile spending 90+% of its time doing garbage collection. With a preallocated ring buffer you can eliminate the GC overhead and achieve far greater performance in writes and reads to the buffer.
#remote-jobs channel on [Golang Slack](https://invite.slack.golangbridge.org).
\#remote-jobs channel on [Golang Slack](https://invite.slack.golangbridge.org).
Not being toxic, just not sure what answers you're digging for, and I don't appreciate the run-around you seem to be giving me. &gt; if you are consistent with your position I feel like you're trying to give me some sort of quiz to test my understanding of golang. As if you're some gatekeeper of the language. What are you getting at?
Strictly speaking, C++ isn't really object-oriented. It does not natively provide message passing, which is the entire basis of OO. That said, there are tools like Qt's moc, which do add message passing on top of the language. 
Code reuse can be achieved in non-OO languages. The concepts needed for code reuse are much simpler: modules and functions.
Also check https://www.welovegolang.com/jobs/remote
The fundamental principles of OOP are encapsulation, abstraction, inheritance and polymorphism. As my previous post explains, go offers these features. Alan Kay's concept of OOP isn't widely taught for whatever reason. Personally, I don't find it as pragmatic of a description of object orientation. That being said, go has a mechanism for passing messages: channels.
Personally I usually prefer environment variables because they make running a service inside docker more straightforward. Config files is a close second. (I prefer StrictYAML format myself, but as long as the format allow comments, I'm not too picky.) I would be unlikely to use a UI.
Some more issues; 1) Your ring buffer does not block when its full, so it loses data when you have more Adds() than Gets(). You need to make use of sync.NewCond() to block. 2) Why are you copying data at [https://github.com/TheTannerRyan/buff/blob/11423094625a02b816a734a209f7d54029f6b176/buff.go#L62](https://github.com/TheTannerRyan/buff/blob/11423094625a02b816a734a209f7d54029f6b176/buff.go#L62) when adding to the buffer? Golang is pass by value so this is not needed and will make the Garbage Collector go crazy if you profile the code.
Yeah it's just way harder maybe some of the functionality of Julia and/or go help it
Hacker News's monthly hiring thread.
Fortunately, you’ve corrected my mistake. Thank you! 👍🏻
You don’t need to wrap it in a needless struct. A go type can be of any type.
Did not manage to spell the name of the language correctly a single time. That shows commitment. Well done.
&gt; methods can be associated within structs methods can be associated with types of any kind.
When I was looking, I think everything remote I got an interview for advertised on Stack Overflow. I saw stuff on remoteok but didn't get any interviews. It was a while ago so I don't actually remember if I applied to any there. If I had been looking only for Go (I accepted a primarily C# remote position where I was a recommendation of a former employee) I I think the other thing is in this thread sound pretty solid.
Devops/SRE role - building monitors solutions, kubernetes integrations, CLI toolkits, and a few larger scale command and control applications. Working in the government contractor space.
came to post viper as well
First, my post directly answered your question "Where's the Problem?" if that question is why am I writing anything about the suggested framework. "The posted tool looks like it’s trying to help with html template sites. My question is how about something like Wicket for go? This project reinvents routing. Why not reinvent template rendering instead?" &amp;#x200B; Second, template rending is a complex problem if you want to have true separation of concerns. For example, say you have a header, a main content, a side navigation. All three do different things based on if the user is logged in. The main content needs to load a bunch of drop downs. The side navigation has to call two services for translation and localization needs. The header has to query which nav options to show you from another service. Having one controller handle all of this is problematic. &amp;#x200B; A tool like Wicket allows you to break all of this apart. There is a header object that renders to HTML. It uses a common infrastructure to query the user's log in status. This object, a panel, also has services/repositories loaded into it which allow it to retrieve what ever information is necessary. So to the main content panel and the side nav. Through proper use of thread pools, in Java, all of the data acquisition can occur concurrently. Very simple. &amp;#x200B; It's like a SPA, but on the server side. The benefits is that it's probably faster on the first load since it's probably 1k for the page + jquery at 100k? It also enables SEO since most crawlers have a hard time with dynamic content. Even Google's. Third it keeps most of the problem in HTML + Java. Compared to HTML + JavaScript + Go + Whatever else. &amp;#x200B; Now Go is fast, and better at memory consumption than Java. If the OP wanted to do something different, implementing a component based system on top of templates would be nice. 
Nice to hear you're thinking about it.
This is basically an ad.
something might pop up on: https://www.moonlightwork.com/
That's neither the case here, nor in general in my experience. E.g in C++, boost's circular buffer overwrites as well.
&gt;Maybe you could have some sort of secure process to decrypt a partition that would overlay the filesystem with some subset of standard system utilities, and then it gets locked back up when the login shell is exited, or something like that. I'd imagine running some container with the appropriate tools/mounts/network/etc would allow you to run some of the various tools for troubleshooting. You could then spin up / tear down as needed for your troubleshooting sessions. &gt;How would I go about deploying a HIDS or antivirus? With talos the intent to to transition to immutable infrastructure -- that low level host layer should be fairly well isolated. So with that being said, I think the main focus would be the writable area ( `/var` ) and then the container filesystem if you don't scan/lockdown/establish trust with the containers you're running. &gt;How would an IR team go about getting packet captures and doing whatever other investigations? I'd expect you should be able to run a container with `hostNetwork = true` and an entrypoint to run tcpdump to initiate the packet capture and do the necessary from there ( write to a file, stream to a log server/stdout, etc ).
I'm afraid I honestly don't know. If you were to do what I did, first you'd need to be studying physics in a latinamerican university, then change to computer science, then drop out because of yet another economic crisis, start a free software consultancy with friends at the same time you become a father of twins, and burn out and crash out of that. I'll ask saner people. Maybe /u/popeydc/ qualifies?
You didn't really answer my question: where's the problem? Why can't you do what you describe in Go? Besides the fact there's no ready-made-solution for you. Nothing you describe can't be done in Go with a few lines of code. Go's default templating is really powerful. You have partials, inheritance...everything you need for what you describe. &amp;#x200B; An authorization check is done through middleware -&gt; if auth -&gt; render the stuff you want rendered. Like... again: where's the problem? All you ask for can already be done with Go.
Thanks for all the knowledge sharing Francesc! gràcies!
Very interesting. Is there a reason you left out the Scanner-solution? Anyway good ideas all around.
A buffer that losses data due to overwriting when full is not one worth using at all. C++ boosts implementation leaves the handling of what to do with a full buffer to the user and the documentation explicitly states this including saying it is NOT thread safe. [https://www.boost.org/doc/libs/1\_54\_0/libs/circular\_buffer/doc/circular\_buffer.html](https://www.boost.org/doc/libs/1_54_0/libs/circular_buffer/doc/circular_buffer.html) &amp;#x200B; The code in this thread claims to be thread safe but its not due to it not blocking when full.
&gt; leaves the handling of what to do with a full buffer to the user No it doesn't? It explicitly says, in the overwriting section, it doesn't implement option 1 or 2.
C# dev working in London with Go open-source project. PM me. Also, are you Monzo?
Concurrency-wise the dynamic languages still have a long way to go, but if you're cpu-bound python actually does an excellent job combining cython &amp; pure c-code to do the heavy lifting for it. Erlang really doesn't have anything at all in that department (and maybe that's fine as it's not used for that anyway). &amp;#x200B; So, there are two sides to the coin depending on what you need. 
That is the exact part of the documentation I was referring to and as you say boosts circular\_buffer only implements 3. This is the reason why its NOT thread safe and further stated in the Thread Safety section above. For circular\_buffer to be thread safe it leaves the locking implementation up to the user to implement and provides ideas 1,2,4 for that as I stated previously. &amp;#x200B; In contrast your missing my whole point that the golang code in this thread is claiming to be thread safe when its not and for it to be thread safe it needs to implement locking/blocking/error notification when full. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
In which case Go isn't Object Oriented, but pretty much nothing else is either. No joke, no criticism. OO has a lot of definitions. But if you use that one, then OO pretty much doesn't exist as a viable programming choice, and Go is in good company.
&gt; Go is object oriented. I don't think it is. The key characteristic of OOP is that the unit of encapsulation is an Object, whereas the unit of encapsulation in Go is the package. All the other properties commonly named for OOP languages (e.g. "Message pasing", or "inheritence") are instances of this guiding principle. Objects inherit from each other, they talk to each other, they compose with each other; all programming is innately focused on the interaction of different Objects. That's simply not the case in Go. All code in a single package shares their namespace and types are simply used as a logical grouping where it makes sense. Types can have methods, yes - but you don't organize your code around them in the same way you do in OOP. FWIW, I also don't think this really is relevant to OPs question, as I doubt OP intended it that way. But I still don't think Go really is "object oriented".
&gt; The key characteristic of OOP is that the unit of encapsulation is an Object, whereas the unit of encapsulation in Go is the package ...so treat packages like objects: put each object in its own package. Problem solved. IMO it seems like you're playing semantic games, when go does everything you need it to do to implement an object oriented design in go code. &gt; all programming is innately focused on the interaction of different Objects What you're talking about is determined by how one uses go, not what go is capable of. Sure, one can stuff all her code in a single package and it won't achieve the concept of OOP, and go won't stop you from doing that... but as I said, you can separate your code smartly and now you've got OOP. Hence, go is object oriented. Fulfills all the principles, as demonstrated in my original post. 
Hi! 1. A circular buffer does not block when it is full. Circular buffers either dynamically expand their capacity or overwrite data when full. See this [Wikipedia](https://en.wikipedia.org/wiki/Circular_buffer) article. In this implementation, since the size is fixed, the oldest data is overwritten. 2. This isn't actually the case. Without the copy, the data in the circular buffer will change if the element's data is also modified. See this [demo](https://play.golang.org/p/GLcdxuy-ukf).
Or batching. Have the client only submit a package of the last 10 or so previous points every 2 seconds. But websockets is a great option. 
Lots say that it’s missing something, or doesn’t match some definition. But honestly, those are all academic and not helpful. To me, Go is object oriented. Sure you don’t get inheritance, but it’s pretty rare that I’ve ever used that in OOP anyways, and there are good ways to do that in Go. Composition is so close to inheritance that it doesn’t really matter. 
[removed]
[removed]
Don’t use *interface{}, use interface{}. An interface (named or generic) can be a pointer or a value. 
1. A circular buffer can block when full and could expand its capacity as you say. Those are details important to your use case and for making a "thread safe" circular buffer. Your code advertises as being thread safe when its not due to the unhandled issue of when it becomes full. By adding mutexes to it to protect the reads and writes of the underlying array doesn't do anything helpful in making the circular buffer usable as you still have have to implement some type of thread safety on the application side to handle the what to do if the buffer is full scenario. &amp;#x200B; Having mutexes (thread safety) duplicated in the buffer library and application code is not needed and wasteful of resources. You either lock completely in the library and impose a feature set (blocking on full, expand capacity etc) or not at all and provide an unsafe circular buffer where the user implements thread safety in the application side and has the freedom to impose the feature set. &amp;#x200B; 2. Sure in your demo it has that problem as the copy by value is only copying the header of the byte slice being passed in. Your buffer library shouldn't be allocated/deallocating memory if the application code using it is poorly written.
Ahh that's it! Thanks!
Great feedback! Thanks
At one of Bill Kennedy's classes he walks through why he calls Go data-oriented instead of object oriented.
This looks cool, going to try to use this for some testing on one of my applications! Does this also allow you to mock external web api calls?
Do the structs have to have different types altogether? You can't embed? Or use the same type? If that is the only difference, and you simply cannot change this, then a param that has to take in different types in exactly the same param position, is going to need interface{}. This is only based on the idea that they "have" to be different types and they have to go in that param slot. If they didn't, then I'd use the same struct type for them to carry the concrete data. You can maybe use a type switch to break those functions down as well. 
Would be awesome if you share it here or twitter . Thanks
https://www.golangprojects.com/ This is good.
Considered generating for example plantuml as well? Let’s you focus on the capture part and leave the diagrams. 
Hey guys, If you guys are interested you can build your own GO devs team in India and get work done. Ping me if interested.
 func ReadConfig(filename string, config interface{}) error { c := viper.New() c.SetConfigFile(filename) if err := c.ReadInConfig(); err != nil { return err } return c.Unmarshal(config) }
I don't think the two things in your question are connected at all... I'm confused about what you're actually trying to find out. Do you think that Go is not being adopted over Python (outside of specialize use cases)? And should it be? Do you think that being Object Oriented (as it is typically defined) is an advantage for people to adopt it? Do you think that Go should be Object Oriented (as it is typically defined)? Are you interested in the community's opinion on this, or are you interested in having your own opinions validated? My own opinion: I don't think Go is Object Oriented - it can be if you choose to do it that way, but treating interfaces as if they were classes leads to strange places. I think Go is an excellent tool for creating servers with, that's the niche it was designed for, and frankly it's struggling in any other niche. This is fine, there are other languages better suited to doing those things (and similarly there are things that Python is good at and things that it's not good at - no language is truly general purpose, there are always tradeoffs made when designing a language that mean it is more suitable for some purposes than others). I don't think that languages are in competition with other - that's a bit like saying hammers and chisels are in competition with each other for space in your toolbox. You need the right tool for the job. So... what do you think?
You could use a closure for the config function: func readConfig(filename string, unmarshal func(*viper.Viper) error) error { c := viper.New() c.SetConfigFile(filename) err := c.ReadInConfig() if err != nil { return err } err = unmarshal(c) if err != nil { return err } return nil } and call it like so: readConfig("fubar", func(c *viper.Viper) { c.Unmarshal(configB) })
I answered the question. My problem with this project is that it is unoriginal. It is solving a problem that has been solved before. I suggested rather than do that, why not try something like Wicket in Go? The author shows a desire to make something. Why not a SSR library? As to your auth note, you missed the point. The individual sections need to react differently based on auth status. You don’t want the auth filter to inject HTML into a byte stream. 
gophers.slack.com have jobs channel that is world wide. 
something to add: if the config structs define a method like this: ``` func (b \*configB) Unmarshal(c \*viper.Viper) error { return c.Unmarshal(b) } ``` you could call it like so: ``` readConfig("fubar", configB.Unmarshal) ```
Major financial institution here (top 10 US bank) using go all over the shop - website APIs in my area.
It does.
That would be nice but I couldn't find anything comprehensive for go and plant uml - that was my original idea. The library has a hook to create your own reports, so it'd be possible to provide that as an add on 
Can’t you just set that at launch or in your system env from where you’re launching it? export BLAH=value
Rather than doing that, just override the values - say, read them into package vars in the var initializer (no reason not to) and then overwrite those vars in your unit test.
Or better yet, treat it as a dependency and inject the values from the caller.
There are six of these plugins and I can't run the tests for all of them manually passing the env vars for each of them, I would like to set dummy env vars through go code. Kind of like mocking but for env vars.
the values need to be set to be overriden right? but when the init func is called and the env var turns out to be empty it raises an error and the ES client is not initialized 
I wasn't aware of that, thanks for pointing it out!
I think it might be hard to write up a concrete case for switching to Go that would apply well to every company. My experience in introducing it to my studio is probably different than the next person. But maybe a good way to approach it is to break it down like "if condition X is true about your company, consider reasons A, B, and C for using Go to solve these problems". Then someone can gather then points that best represent their target audience. Some companies write services, some write tools. Some consist of C++ devs and some are Python shops. The selling points would be different. 
It is not for deciding or choosing the language but to see which feature Go developer considers as the most prominent feature, and why!
Gotcha. Well I do believe the init function is called super early. Not sure if you can control their order either. 
I would be interested to learn more about your use case. We have a NATS Streaming V2 design in the works which is aiming to be much more scalable. Prior to NATS I designed TIBCO's EMS, so we might have a shot at meeting your needs.
Thanks for the feedback, always helpful.
I adopted it over python for non-specialised cases. And I have been a production python developer since 2006. 
The markup is surprisingly simple, might be easy to just output directly. PlantUML itself is some java monstrosity :(
The highlighting I'm using is not syntactic at all, it's to point out the concepts I'm talking about
Do you think Go will ever run on bare metal?
This looks like good stuff - I'm looking forward to trying it out. Currently I build a minimal base for kubernetes with [buildroot](https://buildroot.org) but I've always had in the back of my mind an idea of the kubelet as PID 1 - but that may be a bit extreme and kubelet may not be adaptable enough for it. What you've got looks like a good step in that direction though, so I'll definitely be checking it out for my arm sbc cluster.
Go compiles to a binary that runs on "bare metal" (assuming that metal is shaped into a CPU) but it requires an OS. gokrazy is an effort to build an OS in Go, which I think uses some C too ... but not sure https://gokrazy.org/
I thought of Kubelet as PID 1 but very quickly realized that something very minimal and hard to bring down would have to ensure the Kubelet is up at all times. The Kubelet has too many ways in which it could crash, and thus cause a kernel panic. As for arm, unfortunately we don't support that ... yet. I think Talos would be great with arm and for IoT/edge Kubernetes. If your up for the challenge, I could provide some guidance on getting Talos built for arm.
@campoy being the Kondo of Go
I was never really sure a PID 1 kubelet would actually be realistic, but since it does a lot of what init does in some ways, I've just had it in the back of my mind. But it really does make sense to have just a minimal init as you do. I've got plenty of experience of cross compiling and building linux systems from scratch so I should be fine with Talos, but everything is easy before you've looked at it. I'll see what time I can rustle up in the next few weeks and let you know if I get anywhere.
Don't get me wrong. Kubelet as PID 1 would be awesome :D Here is the toolchain repo we use to compile Talos: https://github.com/autonomy/toolchain-musl I imagine a variation on the would be needed for ARM.
The Go standard library and third party libraries which stick to that theme are pretty slow at basically every kind of demanding I/O because I guess there's a general fear of bit twiddling pointers in the standard library. The *published* numbers for many types of I/O benchmark are quite bad, the highest I have seen published for RPC is like \~800MB/sec or around \~3M msgs/sec. The serialization benchmarks I've seen are also basically pathetic for a compiled language on modern hardware that emphasizes parallelism. I don't think the standard library attitude of "ewww, untyped pointers" is realistic in any application where you will need to utilize the I/O capabilities of modern hardware to a great extent. To keep up with NICs that can push &gt;10GB/sec and &gt;40Mpps, desktop nVME drives that push &gt;2GB/sec and 500k+ IOPS, you need to do whatever keeps latency lowest and avoids stalls. &amp;#x200B; Fortunately, the language does give you the tools to make your own choices. I've spent a few days on a lock-free zero copy not quite zero alloc SHM ring buffer implementation for IPC/RPC as my reaction to the published performance of basically everything in this area and I am already seeing test runs with \~300ns average latency, over 3 million msgs/sec, and up to 120GB/sec aggregate throughput with I think probably a lot of room for improvement. I am also not actually even fully leveraging the zero-copy capability with this test yet, since I am copying once to the write buffer and once from the read buffer to simulate access. This would I believe be expected to reduce performance by at least 50% on its own from the extra read and write, producer and consumer functions would likely be much faster than this.
Bingo
The `RunCounter` example is excellent, /u/campoy. I'm gonna steal that now :)
I'm pretty sure I got it from "Effective Java" or at least I got inspired from the book
- Strong typing and interfaces really do help to de-abstract code and do help with readability and "getting started" - The tooling is excellent, no third-party tools needed for doc generation, formatting etc - If you build web services or server software, Go is excellent, it provides everything you need at a low level to be productive and develop fast software But as with the other commenter here, if you make websites for a living, there are better choices. Go is a great tool when using it for the right job. 
I've never spent less time debugging complex programs than when writing them in Go. To be fair, I spend a lot more time fixing compiling errors, but the total time spent debuggi before software is production ready is definitely materially less than other languages I've used.
Hi, VP of development here and we are switching to go (or trying at least). We are switching from Python to Go (web services that serve 1m+ req/min, and some stats services), and the main reason is performance and multithreading. It is more about multithreading - leads to effective memory management (in terms of local caching inside a web app) and cost-cutting.
Also going the route of a function reduces interface magic
You are moving goalposts. Here's your original reply to my comment: &gt; A "full" ring buffer should not overwrite the oldest entry, but it should block until the pointer to the oldest entry is incremented to free up space. Which, as you can see, is false.
I think it's a pretty difficult sell at this point. It has advantages, but they're going to be different depending on where you're coming from (e.g. C++ vs Python). But the ubiquity of those languages is so ridiculous that it's hard to justify anything else. 
No I don't want a solution which is valid to everyone. I am totally with you at this point. &amp;#x200B; &amp;#x200B;
Thank you.
Cool. Thank you very much. That is a great point.
Thank you. I also think cutting the costs must be the main reason to change something. &amp;#x200B; I think that was also the target of Google, when they started developing Go. 
From my perspective, after using go I've notice that I don't need to look into stackoverflow at all. Which just answers how easy and understanding writing go is and how powerful standard library is. You basically don't need a lot of 3rd party stuff and if you do, it's easy to use and understand.
Your \`Logs\` service probably should not rely on the ENV, but accept a configuration URL parameter. That way you can test that. Maybe a constructor style \`NewLogService\`?
If you don't want to set them with test run like `ENV_VAR=test go test ./...` I think there is `os.Setenv(..)` to do it in code.
Why switching? There's no silver bullet. Introduce Go in your company, as I did, use it whenever it's a good fit for projects and use other languages (i.e. Python) where Go is not the best choice. At the moment we're using both Go and Python, the choice depends on the specific business and technological scenario.
At the company I work for, I was part of a group of people that evaluated different languages and ended up picking Go as our go-to language for all future development. Before choosing Go we had the majority of services written in Node.js and a few Elixir services. We evaluated staying with Node.js, or moving all future development to Elixir, Go or some other language. Between Elixir and Go we found performance to be comparable but liked the portability of Go. We also need to run some AWS Lambda functions and choosing Go meant we could have our internal CLI tools, web services, workers, and Lambda functions all written in the same language. Choosing Elixir would have meant using a different language for our lambda functions. My main gripe with Go is the state of affairs with package management. We're getting Go modules soonish but they still have a lot to be desired (I'm sticking with dep for now). Some small "gotchas" that you might not be aware of as you start using Go in production are: 1) you need to close request bodies manually to prevent memory leaking, 2) the default http server/client doesn't have a timeout and 3) you need to drain the response buffers if you want to reuse HTTP connections.
"Oh goody, another Minix clone". That's what people said about Linux at first. With that attitude, we wouldn't have Linux. Or Kubernetes. Or most programming languages. Innovation is often the result of small, slow improvements building on things that already exist. 
Just.. Wow. Can't you read or don't you wanna understand? Why do you need an ssr library if all you wanna do can already be done in Go? You don't answer my question at all. I simply asked what you can't do in Go right now. You seem unable to answer that. Everything you want can be done in Go already.
[removed]
Here's another package with apple , filter and reduce which uses reflection rather than code generation: https://github.com/robpike/filter
what industry do you work in?
Ads
One of the biggest advantage I found is that Go is easy to maintain. It is easy to understand code that others wrote. This makes fixing bugs or modifying existing code that much easier. &amp;#x200B; Also, all you need to run it is the executable that you build. No complicated dependencies that can break in a million ways as time passes. And your code is guaranteed to be compatible with future versions of Go. You won't need to hire an archaeologist and a witch doctor if in the very distant future (say 10 years) the code is still running and changes have to be made.
Very cool. I also switched just to the Go documentation. No more need to look somehere else.
You are right. Maybe the word switching is not correct at this point. And that solution to start with small and simple services is a good choice. Not verything has to be written in Go. You are totally right.
Yes this is a point, which I also heard a lot at the meetups. Go just runs and works, compared to other languages. And if not there will be the "go fix" command.
That's a stupid idea frankly. You are not in position to tell what others should use. It's also very arrogant and unprofessional, stinks of fanboyism and low competence. What you should do is to lay out how language does something. You should probably also compare it to how other languages do it. But do it in best possible way, with no fear that Go will košė in some comparisons. Be Honest and self critical. Also phrases like "easy to read" is not an fact, but an opinion. Plenty of programmers prefer declarative vs imperative and there remain an issue of verbosity. So you should lay it out this way.
This seems to be quite well received: &amp;#x200B; [https://github.com/wesovilabs/koazee](https://github.com/wesovilabs/koazee)
 package main import ( "fmt" "io" "log" "os" ) func main() { file, err := os.Open("./genome.txt") if err != nil { log.Fatal(err) } defer file.Close() buffer := make([]byte, 5) outputMap := make(map[string]int) for { bytesRead, err := file.Read(buffer) if err != nil { if err == io.EOF { break } else { log.Fatal(err) } } if bytesRead == 5 { outputMap[string(buffer[:bytesRead])]++ } } fmt.Println(outputMap) } 
&gt;That's a stupid idea frankly. You are not in position to tell what others should use. It's also very arrogant and unprofessional, stinks of fanboyism and low competence. &gt; That's a little bit harsh when someone was asking for some tips on the selling points of Go. We as readers of this post didn't really have any idea "how" these ideas would be presented in a book. The assumptions are pretty rude in my opinion. 
Cool. I feel there is definitely a way to write this information in a way that it could be cherry picked by the audience, as long as you don't come at it from one single application or perspective. 
There is no good answer to give to a flawed question, when entire approach is wrong, as it starts with assumption that companies should switch to go, before one knows anything about particular needs and goals of the company. That's fanboysim. This may fly when talking with people who already agree with your opinion so starting the question with why will fly unnoticed, but if you care about actually making an argument for people who are not sold on the idea it won't be helpful and will look like pushing opinions. So yeah, I might have been blunt, sugarcoating doesn't help it. It would be more useful to ask this questions in for example java subreddit and not go. Although, get ready for roasting.
I ended up going with "obj". It sounds bad I know, but is it ? Maybe. I made a git example, if you have the opportunity to take a look : [https://github.com/audrenbdb/bookstore](https://github.com/audrenbdb/bookstore)
I used this command `docker-compose build --no-cache` while building up the docker-compose file which I used to build&amp;run both backend and frontend application. It helped me to cache some of the steps inside the Dockerfile. But I am not sure that this is worked for caching the dependencies of GO application. Each when the application is passed through the Jenkins pipeline. It keeps downloading the whole dependencies from scratch. I will keep looking on this issue and if I find something out , I will inform you about it.
In one of our architecture, fully based on micro-services, at the beginning we had all services in Python. Then we decided to rewrite them in Go. Using an API gateway we managed a smooth transition: for a while both Python and Go services were in production, we just had to move routes from a backend to another when services were migrated. Zero impact to the business, zero impact to clients apps because we maintained the same RESTful interface. Other components of our applications are still in Python and we're not going to migrate them.
I mean you can downvote all you want as to prove my point. It's not people who already agree that the Go is good enough for swithcing you should convince. It's people like me who will object to it you should find ways to win over. Otherwise you are marely writing a book for people who already share your opinions. Circlejerk to put it bluntly. Go on C# reddit ask them. Go on Java reddit. Ask them. Go on javascript reddit, ask them. Here hearing what you already think being reflected back at you won't help to write a solid book.
Thank you!
For companies that have to deploy in client servers, having binaries simplifies the installation process by 1000x. You can also retain the source code without having to use stupid things like ioncube.
Go runs even as firmware! See how Google and Facebook use LinuxBoot and u-root on their servers. Talks and docs on https://linuxboot.org , and the Go initramfs at https://u-root.tk
&gt; subtraction is sometimes messed up, and sometimes works just fine A good starting point to tracking this down would be to add some test-cases .. &gt; I'm currently limited to PEMDAS, sqrt, sin, cos, and tan in the equations. &gt; I'd like to add more. I'm also interested in adding constants like pi and e Adding more operations is probably a good idea, but I think that if you do start down that path you'll _probably_ want to use a real tokenizer &amp; parser. Parsing things via regular expressions, [as you do](https://github.com/codythegreat/calcli/blob/594d1864a0fd6886a52a3596c422da3589c92af0/src/parse.go#L9) seems like it will be hard to maintain. (Almost immediately I wonder if subtraction will become confused by negative numbers. e.g. "3 - -4".) I'm sorry I can't provide more concrete help, though I was piqued by the project as I've just written a compiler to convert a simple RPN expression to assembly language: * https://github.com/skx/math-compiler
I think you misspelled "haproxy"..
I tried it, this is pretty good. 
Love Go. It is very easy to pickup. It fixes some of the negatives with C. But it is the performance compared to other options. You need a service to scale and Go is the language to use. I ported a Node.JS application to Go and the resource utilized dropped by more than 90%.
It is a very simple language which means it is easy to learn and it is easy to use. It enforces certain thing like not having unused variables which increases readability and decreases compilation times. It is memory safe, which means you will have fewer security vulnerabilities and fewer memory related crashes. It is natively compiled, so it is faster than alternatives like C# or Java and ridiculously faster than other languages like Python or JavaScript. The binaries can run stand alone (unless you use cgo)*, which means once the binary works it will always work. No outside dependencies like .Net core or the JVM which if change could cause your code to break or work not as intended. It is stupid easy to cross compile for different operating systems and different architectures (unless you use cgo)*. This means you can develop on any machine and make binaries for any other machine. Concurrent and parallel programming is ridiculously easy to implement with Go. Simple go functionName() and you've created a new processing thread. The threads are much more lightweight than in other languages like C++, C, or Java and much easier to use. They provide a very good mechanism for interthread communication through channels. It has excellent tooling for testing, benchmarking, documenting, formatting, and a bunch of other things. It is extremely easy to get 3rd party libraries to use in your project. Compilation is extremely easy and fast.
`BestValue` is totally equivalent to `Value`. When you add methods for `BestValue`, these methods are also added for `Value`.
Java 2 Go, for the bad experiences of GAE Java runtime. Each GAE Java instance consumes too much memory, needs too much time to fully warm-up. Go instances use tenth memory and startup in half a second.
Wow, that's a great recommendation!
Cookies are never secure. The most secure you can get is have the contents be confidential and the integrity be verified. A client will still be able to delete or restore their session to any point in time. You won't be able to invalidate their session either. A solution is to just store an identifier (session ID) that can be used to load the session from server storage. The only time secure cookies should ever be used is in really low security applications, like a noncompetitive game.
Not enough information, if you want a networking, then use Go, if you want a low level computing, then use C or C++, if you want something other, use other language. That's all. Go is not a good choose in many cases. And Go is a good choose in many cases.
Two words: developer ergonomics. Go is: * quick to learn and master * damn simple (25 keywords anyone?) * highly opinionated, eliminating a lot of lost bike shedding time * has an amazing standard library * has an even more amazing integrated toolset Simply put, *generally speaking* it's much easier to be productive in Go than in many other languages. There are obviously tradeoffs (insert generics gripe here) but there always are, right?
I think a good selling point is that the standard library is a modern one with modern problems in mind like web development packeges and concurrency etc. In a lot of older languages you probably end up using third party libs, which is most of the time a risky move. I think most devs are way more happy when they know they don't have to rely on something that they cannot control.
&gt; ...so treat packages like objects: put each object in its own package. Problem solved. That's not how it works. You can't claim Go is an object-oriented languages by saying "just abuse it until it works vaguely like one". Go, as a language, is not object-oriented. FTR, I'm not talking about a "problem" here. I don't think Go is object oriented and I believe that is a good thing. Object oriented programming isn't a model that fits my brain well, so I'm glad I don't have to subject myself to it. &gt; IMO it seems like you're playing semantic games …I mean. I could throw that right back at you :) I'm not the one arguing that *technically* you can make the language behave like a different one :) I don't believe I am actually talking semantics here. I'm talking about "how is the language used, idiomatically, and can that justifiably be called Object Oriented". &gt; What you're talking about is determined by how one uses go, not what go is capable of. Well, so we agree :) FTR, by your logic, Go is also a functional programming language (it has higher-level functions, after all). Or it's a dynamically typed programming language (you can, after all, use interface{} as the only type). Or it runs on a VM (just transpile into javascript). *Semantically* these statements are correct. But that's just not a helpful way to think about it.
&gt; but pretty much nothing else is either. Smalltalk (of course), Objective-C, Ruby, etc. are dead ringers for OO languages. Hardly nothing. Go also has message passing, although it is debatable if it fits the model Kay had in mind when he coined the therm. &gt; But if you use that one, then OO pretty much doesn't exist as a viable programming choice Why do you say that? There are several languages that clearly fit his definition, some of which are quite popular in their respective niches. That doesn't mean OO is the be all or end all of programming models. It is also okay if you don't utilize it.
Oh, cool, seems, Google's developers are really smart and can rewrite the tour of Go with images as a presentation. Really useful. For autists.
An array?
Ok, Konstantin. I don't know what your goal is, but if your contribution to this community is to depreciate mine maybe you should simply be banned. Any admin can help? This is getting really annoying.
PS : I don't work at Google. Maybe read the slides (#2) correctly before.
For me the best thing about go is that it's made for building things in teams. I've been a python developer and the amount of times "rockstar" programmers have produced unmaintainable and undebuggable mess by trying to show off their knowledge of metaclasses and other "magic" has driven me crazy. &amp;#x200B; Go is simple, straightforward, easy to read once you get used to it, there's a standard-ish way to do things, it forces timely error handling, has a beautiful concurrency model, easy distribution (also able to build super minimal containers with the built binaries). &amp;#x200B; Obviously it has it's downsides, but the best part of it is that I'm feeling like an engineer building a machine when using go, and I can be fairly confident things work well once compile goes through. I've been a python dev for most of my career, but since finding go, I can't think the last time I've used python unless I had to.
I would love to see it running on a raspberry pi :o
CI should reflect what's in your repository at the time of the run. Since you're working on v2, that's what you should test. Your v1.* tag(s) would theoretically have their CI tasks passed already, so no need to reiterate over them again. 
* Maintainability * Probably the easiest modern language to learn and therefore to get people / new employees to switch to * much less error-prone * better performance and fewer runtime errors than other languages that are easy to learn (e.g. scripting languages) 
You are the one with the reading comprehension problem. As far as I know, Go lacks a way to easily layer templates together in GTK or WebForms manner. I’m not saying this is impossible with Go. I’m saying it doesn’t presently exist. I’m further saying that the OP should do this. It is both novel in the Go space and useful. I have said all of this clearly and succinctly. 
Give your `Logs` struct a field `Getenv func(key string) string`. Then in your `InitFunc`, use `l.GetEnv(esURL)` instead of `os.Getenv`. This allows you to use the real `os.Getenv` in the real world, while in unit tests, you can create a test logs service with any `func(key string) string` as a mock `Getenv` func. This approach also works for `time.Now` and other things like that.
I was aware of gotcha #2 but didn't know about 1 &amp; 3. Can you elaborate on them or point to some docs/articles about them?
I’m a huge Go fanboy but I’m not sure it’s faster than C#. Especially if you use AOT compiling.
We added Go to our stack last year, using it in our data pipeline and devops tooling. Go works quite well in data pipeline as it is probably the fastest language in our stack yet simple to pick up. For example, in Mozilla's [data pipeline](https://docs.telemetry.mozilla.org/concepts/pipeline/data_pipeline.html) they use [custom nginx module](https://github.com/mozilla-services/nginx_moz_ingest). In our system we do the same using Gin. It is also simple to build and deploy as you can run `go build` and let it work everything else out (incl. getting stuff from go modules), instead of figuring out how to build nginx and its dependencies. 
I appreciate the feedback. I've been looking into the subtraction since I've posted the project on reddit, and it does seem to confuse negative numbers with the subtraction sign. Once I get a little more time to look into the issue I'll fix it. I've been considering the use of a tokenizer. You are correct in that the regular expressions are getting harder to maintain, especially for LaTeX conversions. BTW I dig your project. I've always wanted to look into learning assembly as a side hobby, but I haven't had the time to do so just yet.
Barring what others have said, is there a reason why os.Setenv is not working for you?
I think you are confusing encryption and authentication.
 most of the arguments are very valid, wanted to add: \-go is both good for prototyping services, and full scale production, start small be able to scale up as needed \-extensive standard library minimizing outside dependencies the general argument (subjective without much research of course ) is that you could feasibly achieve lower initial and lifetime cost, can have quality, and also can get high speed, at scale.
Don't. Write an adaptor that provides an interface between your model and elastic search, then mock that adaptor. The elastic client already has it's own unit tests, you don't need to test the client again in your code, and mocking the elastic server is a huge task.
I developped a small-size project in go. What really seduced me, after the language itself, is the simple and lightweight binary executable it produces. It takes me 10mn to fully set up a working vps and start my go program in it. Copy/Paste the binary. Amazing.
You might get some pointers from this thread! [https://www.reddit.com/r/golang/comments/aq66rg/what\_is\_the\_single\_most\_reason\_that\_you\_chose/](https://www.reddit.com/r/golang/comments/aq66rg/what_is_the_single_most_reason_that_you_chose/)
Per the post, they're using major subdirectory, which means both v1 and v2 after in the repository at the time of the run, hence the question.
Curious what tech you plan to use for CICD. Jenkins? Travis?
"I’m not saying this is impossible with Go. I’m saying it doesn’t presently exist." &amp;#x200B; Then you should actually look at the templating library. As i already told you: you can embed, extend or inherit templates just fine with Go's standard library. Want a template to behave differently in certain conditions? You can do that just fine. You keep saying how this and that is not present or doesn't work, but you yet failed to show me a single thing that you can't do in Go. From the things you want. Seems to me like you never actually tried to work with Go to find a solution to your problem. Otherwise you'd have noticed there's nothing stopping you from achieving what you want.
travis for this specific repo and GitlabCI for some others
What if you accidentally used it in a block of code thinking that you will overwrite the previously declared variable? That is how bugs are created. This is a conscious design decision which makes your code safer.
If you are playing the role of expert, and I the novice, please, master, show me how to cleanly separate the process of populating data for the templates from a controller who has a specific job. For example, a controller that gets a post. It updates some backend, then asks for a render. How can the templates be arranged, in normal go, such that the post controller only has to know about how to populate its section of the template while the other templates load their own data. Simple inheritance does, to my knowledge, solve this problem. I truly want to know. At present I’m doing wicket because I could not find good solution for complex rendering in Go. Many people both on Reddit and in the wider Internet say that SSR is a fool’s errand. That SPA plus Go services is how to do things. 
Found this: https://github.com/shirou/gopsutil Documentation for the process sub-package: https://godoc.org/github.com/shirou/gopsutil/process Here's an example with how you could use it: package main import ( "fmt" "log" "github.com/shirou/gopsutil/process" ) func main() { processes, err := process.Processes() if err != nil { log.Fatal(err) } for _, proc := range processes { pid := proc.Pid ppid, err := proc.Ppid() if err != nil { log.Println(err) } cwd, err := proc.Cwd() if err != nil { log.Println(err) } username, err := proc.Username() if err != nil { log.Println(err) } creationTime, err := proc.CreateTime() if err != nil { log.Println(err) } fmt.Println(pid, ppid, cwd, username, creationTime) } } 
Awesome! Going to try it out and try to contribute in the future.
Maps and arrays are already reference types in Go.
This is good advice in general but you probably also want to have an integration test with a fixture ES (e.g in a docker container or something) and some fake data to make sure that the interactions are correct. Unit test fakes are great for validating logic and invariants and processing of results, but generally only encode your assumptions about server behavior and thus need to be complemented by an integration test.
Thank you all for the responses! I've finally gone to the other way: create a separate branch for v1, because having a v2 directory where all the development happens felt too weird and does not fit well with my current workflows for development / CI/CD.
Trying out a new style of recording these videos, would appreciate some feedback as to not only the content but the production quality! &amp;#x200B; Enjoy folks :)
OK but OP is asking for a mocked interface for a unit test, and you're talking about a full docker component for an integration test. two very different things
[mpb](https://github.com/vbauerster/mpb) uses this pattern.
Maps and slices are, arrays are not. However, if you really would like to sort an array using the sort package, you'd need to use a pointer or better, a slice of the array. Otherwise it would be a bit hard to implement `Swap()`.
Indeed. That's why my comment was not a top level reply. It's additional information, not an answer. 
There's no point to encrypt data if you haven't verified who will be decrypting it. 
Same. I love the unit test auto generating. It got us really into TDD. And funny enough we ended up needing to write our unit test skeletons manually as well (the default generated skeletons don't work for functions with side effects) but the style the auto generated ones has helped us figure out a nice convention to follow when writing our own. Overall, it's just a really nice experience making sure the important parts of your code have test coverage.
[not an expert here - but this is how understand pointers] Pointers point to an address in memory and are not independent of the values to which the point. In your first example 'b' is a copy of the value of 'a'. 'b' is strored as a separate address in memory. In the second where you use a pointer 'b' points to the address in memory of 'a'. So you use a pointer to change what's actually stored in memory. You'll often see pointers used in method calls like in your last examples because a functions arguments will be passed in as copies of values by default. So if you want to update a data structure through a method you need to use a pointer and point to the underlying memory. 
Oh I definitely agree you still need the integration test, but that's with a real elastic server not a mock. If you're going to mock out the server you night as well mock at the adaptor level and save yourself a lot of headache.
In the first example (with the pointers), objects are passed by reference. This means that the function receives the addresses of the already existing object instances and any operation inside the function happens directly on those instances, which is probably desired behavior because then, you can mutate data in that object. In the second example, copies of the object will be created for the function, which wastes memory. Furthermore the copies will be destroyed upon leaving the function, which means you cannot mutate anything. This also happens with primitives but primitives are generally small in size and you expect them only to be used for reading. If you want to change a primitive by supplying it in a function, you have to supply them as a pointer too.
What's the advantage to using a library for this versus just writing the dozen or so lines of code necessary to run a worker pool? Concurrency is trivially easy in Go at the language level.
- `*user` is a pointer most likely because the `updateUser` method would mutate the user. If it accepted `user` instead of `*user`, the method would mutate a *copy* of the user, and you wouldn't see the effects outside of the method call. - `*sql.DB` is meant to be goroutine-safe. it contains [synchronization primitives](https://golang.org/src/database/sql/sql.go#L360) and shared state for that end, so it's passed around as a pointer and every goroutine needs to access the *same* `*sql.DB`, not one that's 'equivalent but not the same exact one'. In general: - Using pointers for large structures avoids copying the whole structure on function calls, and can be a decent bit faster due to that. - Using pointers is usually required if you want a function to mutate state inside of your type. - Using pointers is a *must* if a structure contains a non-pointer `sync.Mutex` or similar - copying these is **not ok**. - Using pointers lets you keep around a reference to something internally, such that the reference tracks the target even through changes. - Using pointers lets multiple goroutines observe the same region of memory without having to close over it in a `func`.
Hey, When you do ‘b := a’ go copy the value of a in b. When you use a pointer ‘b := &amp;a’ go copy the memory address of a in b. This mean that the memory used by b is the same that the memory used by a. Copying the value leads to create a brand new variable with its own memory address. It is why when you want to modify a value in a struct method you need to use a pointer to this struct. If not, any change made to your struct won’t last when you leave the scope of your func. I hope this helped you a bit 
Basically if you pass an argument to a function and expect to get the modified value back, us a pointer, otherwise the argument will be copied and any modifications in the function will not be performed on the variable you passed to it. 
&gt;if you make websites for a living, there are better choices &amp;#x200B; Can you explain this point? Afaik every website has a stack, so i just can't see where are these better choices, because Go would shine in the backend area, and most likely win over Python, PHP, Node, etc &amp;#x200B;
You often use pointers to structs to be able to manipulate their content. An example: func main() { i := 1 fmt.Println("Before:", i) noPointer(i) fmt.Println("noPointer:", i) pointer(&amp;i) fmt.Println("pointer:", i) } func noPointer(i int) { i = 5 } func pointer(i *int) { *i = 5 } Output: Before: 1 noPointer: 1 pointer: 5 https://play.golang.org/p/9dqjHHoxs5_e And if you need the do that at least once you do it for consistency for every method you implement because it matters if you implement it on the pointer vs on the type itself. 
It's true that with that particular method it doesn't matter if there receiver or argument is a pointer because neither is actually used in the method body. However, it is clearly a placeholder (either for future functionality or to satisfy an interface), and the author wants to have the correct types so that callers will use it correctly. Additionally, it's conventional in Go to keep receivers and types consistent - if some methods of a type take pointer receivers, all methods of that type should take pointer receivers. Likewise, if a type is canonically used by pointer (the methods take pointer receivers and the "New" function, if there is one, returns a pointer), then it should consistently be a pointer everywhere it is used to be intuitive for callers.
It should be enough to delete the install directory and unpack the new release there again. At least in linux it is, Also the windows Archive (zip version) should be the same. I'm not familiar with the msi Installer or Mac. 
Yes I am on linux. I just wanted to make sure before doing it so that I don't screw up my current environment. 
Not having used either, I'd go with [gorilla/feeds](http://www.gorillatoolkit.org/pkg/feeds) based on the strength of the other libraries in the Gorilla toolkit. It also supports [JSON Feed](https://jsonfeed.org), which I like but can't be bothered to support myself.
Your workspace has nothing to do with your to version, and the Go 1 compatibility promise says all your code will still work. When you upgrade, you just replace the tool chain and standard library, which live outside your workspace.
How does this relate to Go?
[https://github.com/abenz1267/templating](https://github.com/abenz1267/templating) &amp;#x200B; This is quick and dirty. I've literally coded this in around 15 minutes. This only scratches the surface of a way of how you can work with Go templates. This doesn't even include inheritance or anything other default things Go templates can do. This simply demonstrates how you could compose a response based on structs. Even here you can already see how extremely flexible this can get. Custom template behaviour etc. etc. pp. You'd even go way fancier, way way fancier. &amp;#x200B; So yeah, i don't see your problem.
The init is written go. We are dedicated to implementing everything we need in go. 
One of the best explanations I’ve seen in awhile. Thank you.
Thanks for your reply. The use of `*` in this context is clearer now but I still have a question, this time about `&amp;`. Consider this piece of code : ``` a := 10 b := &amp;a fmt.Println(b) // 0xc000014080 fmt.Println(*b) // 10 ``` Here, `&amp;a` refers to the memory address of the variable. So what would happen if we had used `func (u &amp;user) ...` instead of `func (u *user) ...` ? The way I see it is that `u &amp;user` means the actual value stored in the given address of `u`, so I'd tend to use `u &amp;user` instead of `u *user`. But obviously it would be wrong. I don't know if what I'm saying is clear, but basically I'm trying to understand how &amp; and * really defers in that example.
You can keep the old version just in case. Just rename the directory where you unpacked the old version using 'mv' and then extract the new version into the place the old one was. I actually keep several versions around (the latest security patch for each minor version) and just 1) symlink the one I want to use into my PATH, and 2) set GOROOT to match. The second step might no longer be necessary since I think it now figures out GOROOT from where the binary is.
They do different things. gorilla/feeds *generates* RSS/Atom feeds, but doesn't read them. gofeed *reads* RSS/Atom feeds, but doesn't generate them. So it depends on what you're trying to do.
What you are saying is absolutely valid. If you want to copy/paste some code go for it, and you're probably right to do so. However, in that case though its not trival to share a pool of workers across different types of work loads. I may end up duplicating the code to address work for foo, bar, ...etc, which is fine barring the situation. If you want that worker group to behave the same way everywhere, and evolve as your system evolves, its becomes more work to maintain, and more places for bugs to pop up. I think one other thing work noting is you don't have control between the different worker groups how many workers are going as a whole. Say I have 50 workers alloted to foo worker group, and 50 to bar worker group. Then I have 100 events coming in for foo and 1 for bar, you're potentially missing out on the extra load the system can handle. If we consolidate that to one type that fans everything in, liming/maximizing(theoretically) the total number of workers becomes trivial, as well as other functionality you may want to bolt on that applies to all units of work. &amp;#x200B; All that being said, this is merely a thought experiment with some code to illuminate the idea. I have not done any serious benchmarking/profiling to draw out the performance characteristics at any sort of scale. Nor would I necessarily recommend integrating such an approach.
I don't think you can use &amp;user as a function argument, you would use unqualified user for the value of the pointer and use &amp;user when passing the argument to the function if you need to dereference a pointer to user in the calling scope.
&gt; So what would happen if we had used func (u &amp;user) ... instead of func (u *user) ... ? The compiler would yell at you, because that is not valid Go. `&amp;&lt;something&gt;` means exactly one thing in Go: give me the address of `&lt;something&gt;`. It can occur only in the right hand side of a statement like `x = &amp;a`, or an expression like `someFunction(&amp;thisThing)`. The definition of `someFunction` would look like: func someFunction(ptr: *&lt;typeOfThisThing&gt;) { // in here, this should hold: // ptr == &amp;thisThing // as well as: // *ptr == thisThing // `ptr` contains the address of `thisThing` // `*ptr` _is_ the memory location of `thisThing`, for all intents and purposes it is equivalent to `thisThing` // it is probably what you are looking for when you say `u &amp;user` // if &lt;typeOfThisThing&gt; is a struct, then `ptr.someField` is syntactic sugar for `(*ptr).someField` } On the other hand, `*&lt;something&gt;` can mean be of two things: - the action of *dereferencing* the address of `&lt;something&gt;`, if `&lt;something&gt;` is a pointer type. This is the inverse of the usage of `&amp;`, except it can also appear on the left hand side of a statement, like: `*&lt;something&gt; = "hello worldo"`. - part of a type signature - where `*&lt;something&gt;` is the type: 'a pointer to the type called `&lt;something&gt;`. 
Make a separate repo, example: https://github.com/aws/aws-sdk-go-v2 This way you'll still get the -v2 in the module name, but since it is a separate repo you can have different Makefiles.
[removed]
Unfortunately it's too much headache when you don't have a team of engineers who works for you.
I think that's a good idea. I'll have a look again when I get time
This is awesome, thank you!
It is clearly about thread safety and functionality as that is the title of this thread. Your the one being selective trying to isolate the parent comment.
I tried what you gave me above (well, some of it, the parts I could make sense of) and it still doesn't work. I get nothing but a 404 on every page. I added back in the /hello funchandler and I get back the hello world return, but I just cannot seem to get the index.html page to load. Is it not standard to put the index and css files etc in an assets folder? If not, I won't do it in the future, but I can't figure out why it's so hard to get a server to point to a html file. &amp;#x200B; For simplicities sake here is the repo: [https://github.com/JamieW87/GOWebAppTest](https://github.com/JamieW87/GOWebAppTest) &amp;#x200B;
Well, if you are building a website like e-commerce or commercial content-driven like a corporate site, then there are frameworks and platforms that are already suited for the use case and don't need something as low level as go. For example: Wordpress suffices for most B2C websites and even lightweight e-commerce. For large corporate sites you might use something like Drupal, Sitecore or Adobe's enterprise CMS (can't remember the name anymore). These provide 90% of what the customer needs with widely available developers and plugins to complete the remainder. The speed of deliver outweighs the performance benefits, and hiring engineers can be easier and potentially cheaper as there are more of them. If you are building something like Expedia, or a currency trading platform, or something with a very custom backend service requirement (more an application than a website), then Go can be a very good use case, though you still might not use it for the web component as there's more developer friendly options out there like rails or django, and instead use go for the underlying web services and APIs that provide the core feature set. Any CTO will need to weigh up what the best tool set is for the job at hand and In my experience, larger teams tend to be polyglot for that reason.
&gt; However, in that case though its not trival to share a pool of workers across different types of work loads. ... . I think one other thing work noting is you don't have control between the different worker groups how many workers are going as a whole. Say I have 50 workers alloted to foo worker group, and 50 to bar worker group. Then I have 100 events coming in for foo and 1 for bar, you're potentially missing out on the extra load the system can handle. If I put a worker group of 100 and allow it to process both, I can handle more events at a time (theoretically). &gt; It is actually pretty trivial to solve this by sharing a single semaphore channel with this different type-safe worker groups. I can have 10 groups all sharing a `chan struct{}` buffered to 50 and get max utilisation for any group. I would say the more interesting part of the library is the retry mechanisms, as opposed to the work queue. 
As a beginner, do I need to read the source code of standard package before I getting start using it?
I don't use Go very much myself so I'm not aware of what you mean by auto generated unit tests. Can you elaborate on that or link me to somewhere that goes into that more? It sounds interesting and isn't something I've ever seen mentioned about Go before. 
Adding my experience in addition to my original suggestions... I work for a large Visual Effects (feature film) Studio, and we have tons of devs using an array of languages. The primary languages in my industry are Python and C++ because of their common choice as an sdk/api into major 3rd party content creation products (Maya, Nuke, Houdini,...). It would be difficult to use Go for integration into those particular products (I tried a C-shared C++ binding around a Go library and hit issues). But Go has been an excellent fit into the space of distributed services and apis, and command line tooling, where Python would have previously been used. Go has a much better concurrency story and I have found it very easy for other devs to jump in with no Go experience and become productive in a short time. Sharing code between many maintainers is much better than C++ or Python. Python developers get a safer and faster alternative to writing C++. And deploying a Go binary is much easier than deploying a Python uwsgi application behind nginx. We have a lot of in-house apis and libs so it can be hard to use Go if we need to access these libraries, but we can little by little write Go ports of those libraries. I've also added a generic Python interpreter library wrapper to make it easy for us to call into Python and pass json between the two. 
^ this
No, just get used to reading godoc
OK the plot thickens. When I remove the index.html out of the assets folder, when I point the browser at localhost:8080 it displays what looks like a list of my home directory. When I put it back in, I get the 404 again. &amp;#x200B; Is this relevant?
Here is the repo if anybody could help. &amp;#x200B; [https://github.com/JamieW87/GOWebAppTest](https://github.com/JamieW87/GOWebAppTest)
Which app are you using to show the iPad? Assuming that is an iPad. 
I appreciate the example. My problem is that oneus is on the individual handlers to stitch together the page. Get hand to know about all of the various sub components in the common template. If this was more comple by having Header take a repository, the work of the controller become that of IoC container. Wicket provides the niceties. I recommended to the OP to make a similar implementation of niceties. That is the entirety of my problem. There is no default, nor existing system to make such complex UIs. This isn’t a failing of Go. Go, like Java, provides the base line. My entire point in this thread is that the OP is solving a solved problem. Chi, Gorilla, and the standard libraries all provide a means to handle routing. They do so in a uniform way. The framework the OP made deviates in how it defines handlers, as discussed by others. Therefore, the framework, in this regard, is not needed. What I think could be used, and is therefore needed is a component SSR like wicket for Go. Yes, of course it should be built on the Go template engine. Yes of course the engine supports nesting. What is useful is a component system that wraps all of this up into a page lifecycle enabling complex, even IoC injectable components to make smart page hierarchies that follow the Single Responsibility heuristic. 
I see what you mean, but you'd easily abstract that away, the "know all components". And no, there's indeed no ready-made library to do that. But like...why don't you create one then :D. I showed you that it's very well possible to do what you want. All you need on top is a layer of abstraction that ties components together.
The app on the iPad is Paper and I have connected it to my MacBook via usb-c. Then it is just QuickTime to show the iPad display on my Mac and record everything using screenflow :)
Very cool solution to the problem. Adaptive algorithms are always interesting. One of my professors at Stanford wrote an adaptive tcp algo that determined which tcp algo to run based on network conditions (it chose from like 30 different impls) and this reminded me of that! Well written too so kudos
Nice workflow. Would be nice if you could use your host mic and keyboard to type straight into it. 
A simple example: https://play.golang.org/p/GsZEJqVZsDA
In my company we started to test some languages and technologies last year and this is how we decided to adopt Go (Github issue notes): ## Elixir vs Golang: Final Showdown We need to decide if we are going to start our next project in Golang or Elixir, for allowing us to evaluate the best of the 2, I and Matheus came up with the following criteria for evaluating the languages: - The familiarity of the Team with the language - Community - Legibility - How easy it is to learn - Frameworks - Backward compatibility - Maintainability - Performance - How easy it is to deploy - How easy it is to write automated tests - Set of design patterns enforced by/available for the language - Estimated development time for the next projects - Compatibility the Cloud Computing Services (AWS, Google Cloud, etc) In this discussion, we should sort these criteria by their importance and estimate a score for each language in each criterion. After discussing this topic with the Team we reordered the list of subjects in the order of greater priority and created 3 tables with scores voted by the team: ### Most important topics: | Subject | Elixir | Go | Node | |:--------------------------------------------------------------|:------:|:--:|:----:| | The familiarity of the Team with the language | 1 | 2 | 3 | | How easy it is to learn | 1 | 3 | 3 | | Estimated development time of the notification sender | 3 | 1 | 1 | | Total: | 5 | 6 | 7 | ### Other important topics: | Subject | Elixir | Go | Node | |:--------------------------------------------------------------|:------:|:--:|:----:| | Legibility | 2 | 3 | 2 | | Community | 3 | 2 | 1 | | Sponsors of the language | 3 | 3 | 3 | | How easy it is to deploy | 2 | 3 | 1 | | Compatibility with Cloud Computing Services (AWS, GCloud, etc) | 2 | 3 | 3 | | Threading support | 3 | 3 | 1 | | Total: | 15 | 17 | 11 | ### Other topics: | Subject | Elixir | Go | Node | |:--------------------------------------------------------------|:------:|:--:|:----:| | Backward compatibility | ? | 3 | 2 |
Absolutely, you can definitely accomplish that with a semaphore. However, in my view the same points apply here. Its more that your individual worker groups have to account for, more potential areas for bugs to pop up, and it's extending the mental model. There are a lot of ways to do this, the proof of concept I threw out there is just one way, there are far more options out there. I'm actually concerned more about the GC hit this implementation would have more than anything. The backoff stuff is a mostly copy paste from github.com/olivere/elastic pkg, only thing I did was to apply them via a func, as opposed to a hard type. The latter doesn't lend itself to reusability.
I know. I was mostly kidding :) You were pointing out `package main` and the linkage to `func main` not syntax highlighting.
[https://www.youtube.com/watch?v=MzTcsI6tn-0](https://www.youtube.com/watch?v=MzTcsI6tn-0) [https://www.youtube.com/watch?v=PTE4VJIdHPg](https://www.youtube.com/watch?v=PTE4VJIdHPg) [https://www.youtube.com/watch?v=rFejpH\_tAHM](https://www.youtube.com/watch?v=rFejpH_tAHM)
C called the pointer type `*T` instead of `&amp;T` and then C++ made up a separate but related meaning for type `&amp;T`. But in retrospect, it would have been more clear to use `&amp;T` so that mental model for types and expressions is the same. The Go designers admit this in some FAQ somewhere but basically used `*T` because it was traditional. 
Use a JSON feed if you can. I made a feed converter. https://github.com/carlmjohnson/feed2json
There are several functions in the `os` package that will be useful here: `Clearenv`, `Environ`, `Getenv`, `Setenv`, `Unsetenv`, `LookupEnv`. One thing that I've done in places where I am unit testing environment related code is put a `defer resetEnv(os.Environ())` that resets the environment back to its original state before running the test. That way you don't have any bleedover between tests.
Same here. I JUST started getting into Go from cpp/python/java, like 3 days ago, and am starting a server project using intellij. Getting testing and packages setup has taken a little longer than I thought, and would love to know what this is referencing. I DID discover that Shift-Ctrl-T generates some unit tests for a package or file, so maybe this is it?
You can think of receivers as arguments func (u *user) updateUser(db *sql.DB) error and func updateUser(u *User, db *sql.DB) error are exactly the same thing. So if you don't pass `u` as a pointer the function would have a copy of the `u`. So it all depends on your use case. If you want to mutate the original object pass it as a pointer. 
Shit, I must have missed that in the Modules releasing link. Thanx for the clarification.
Sorry, you're right, I should have been explicit - people often say array when they mean slice, I should not assume.
You could move line 6 to line 1, and delete line 5. No need to initialize the empty slice. 
If your function is complex, you may want to move this part to a new function to reduce the number of test cases that you need. a := f(condition) // ... func f(condition) { if condition { return []int{1, 2, 3} } else { return []int{4, 5, 6} } }
I wish I could combine fuctions return value as another functions argument. It works great when a func only returns a value, but often it also returns a second value (like error type most of the time) and I get an "expected 2 return values but got 1. I get that go idiomatic way is to write this in 2 lines of code, but I wish there was a way to choose whichbreturn value to use and ignore the error. Ihooe I explained this correctly. 
&gt;if err != nil I actaully love this as I can test every func worked properly. Sometimes I skip the err checking and it often, if not every time, bites me in the arse later when it's reported by my users and I waste time tracking down the error and discover it's my own fault fir not checking the return error type.
Backwards compatibility, I can't remember ever having to change something on my old code when upgrading Go, but I can't 100% confirm that everyone had this experience
Fragility of 3rd party downstream packages. I had a 3rd party project I was relying on, PG for accessing a postgress database and one of the downstream projects it relied on changed their self hosting domain (so, not github), and when they did this it broke my package manager, dep. Since it was vendored, I had to wait for PG dev to update his project. I'm sure there could have been a way to fix it, but being only 1 year developing in golang I was at a loss and at the mercy of this "4th party" developer. Luckily I had my vendor folder under source control so I was able to revert to a working version. For this reason I keep every change to my vendor folder under source control. (Also, dep can be very very slow when starting from a clean workspace) 
 &gt;* Temporarily comment a block of code; therefore, I have to also comment variable definitions because they are not used anymore I had to read this a couple times to understand, but I know exactly what you mean! When I'm debugging a piece of code I usually move it to the top of my func and place an os.exit(1) right after it. Of course this requires the os package so I have to scroll all the way up and add the os import. I get the code working, then need to remove the .exit and back to the top again to remove the os import. I wish vscode was better at managing these import for you implicitly. You'll notice it does when you add an fmt.* statement it'll add the fmt import. However, it never removes unfortunately. I wish they'd enable that functionality and extend it to more of the std lib packages like os. Maybe this is a good idea for a vscode golang plugin. 
👍🏻
People usually design a JSON/REST API that the react app calls in the background. 
You can use the standard http package in golang to create your REST APIs and consume it using something like axios or fetch from your react code base. "mux" is also a good golang library to make the routing a bit easier. If you're worried about security, JWT would be a good starting point. You can put some user data like id and role as claims in JWT.
&gt; A buffer that losses data due to overwriting when full is not one worth using at all. I have many use cases for precisely this behavior.
I’m glad to see you used the `githubv4` package for this. Nice!
In the golang setup their are two important directories to setup. 1: GOROOT 2.GOPATH Check these environmental variable values using VS IDE Terminal. Run command *$go env* It will be like c:/User/Admin/go This folder will have 3 sub directories. 1. src 2. bin 3. pkg In src, you will have your project directory say ”sample” In that you have a file call a.gonow in this sample code you are accessing a 3rd party package *front* In the VS TERMINAL run a command - (please check the package used in your sample code.) go get github.com/nearst/front It will load all the source of this in you gopath src folder with the structure specified in the import statement. Similarly, it might need other src like error etc. Hope this might help. 
The original example never initializes an empty slice, does it? It declares a nil slice, and then initialises one in the conditionals. If you moved one of the conditional branches to be the default value, wouldn't you initialize twice when hitting the conditional branch? 
I’d optimize for readability and simplicity way before worrying about performance. 
But then I still don't understand why it's a big deal to declare the nil slice. I was only saying it doesn't make any more sense to me to change it. Is it much improved to make only one if branch? 
In non-trivial examples, I’d argue, yes. There’s a general idea that the fewer branches your code has, the less complexity it has, thus easier to maintain and change. 
Per other comments, one should read the env at startup and then inject the appropriate config values. But, sometimes you have to play the hand you're dealt. I was in a similar scenario a while back. Multiple other posters have already pointed out the basic approach. There are many ways to skin this cat, but here's what I remember of how I did it (and this is a quick reconstruction from memory, caveat emptor). Basically, you'll use `os.Setenv()` and then restore the environment on each test. Here's the [playground](https://play.golang.org/p/MQuhwTszcRX). So, your test code will look something like this (noting that your `os.Getenv()` call was missing its param; named `ES_URL` below): func TestEnvExample(t *testing.T) { defer UnsetEnv("ES_")() // Set your envars to whatever you need for testing os.Setenv("ES_URL", "http://localhost:9001") // Invoke the code under test myInitFunc() } func myInitFunc() { esURL := os.Getenv("ES_URL") // do something with esURL fmt.Println("myInitFunc: ES_URL: ", esURL) } // UnsetEnv unsets all envars having prefix and returns a function // that restores the env. Any newly added envars having prefix are // also unset by restore. It is idiomatic to use with a defer. // // defer UnsetEnv("ACME_")() // // Note that modifying the env may have unpredictable results when // tests are run with t.Parallel. // NOTE: This is quick n' dirty from memory; write some tests for // this code. func UnsetEnv(prefix string) (restore func()) { See the [playground](https://play.golang.org/p/MQuhwTszcRX) for the impl of `UnsetEnv` (fully untested 2 min impl - don't rely on it). **A few thoughts:** \- You should start your test with entirely cleared envars -- *for the envars you're testing*. Then explicitly set the envars you need. \- But don't use `os.Clearenv()` \- that unsets the entire env. There may be pieces of code that your test is indirectly invoking that require certain envars (e.g. a DB connect string envar). Only unset the envars that are relevant to the thing under test. \- Hopefully you're following the convention of adding a prefix/namespace to your envars, e.g `ACME_KEY1`, `ACME_KEY2`. The `UnsetEnv` func in the playground example unsets/restores envars based on a prefix, which seems to fit these scenarios. \- You'll want to restore the env after each test. From the perspective of your tests, the env as accessed/mutated by any `os.Xenv` function amounts to the same thing as a package-level variable. Mutate the env in one test, the next test sees that modification. Hence the `defer UnsetEnv()` idiom in each test. \- Directly related to the above, if you're mutating the env, avoid `t.Parallel()`.
No, but it is there for you to look at and has great documentation.
I get that. But it's annoying. Which is what the question asked.
Uses dramatically less memory. I've seen stories where the company had tens of servers drop to 2. The second server was for failover. As a Java programmer, that's why I switched. Once I got over Errors != Exceptions, I like Go. Also my eyes don't hurt as much from rolling them in danger because of Errs == Exceptions fallacy. 
I actually do like and follow the "bail early" pattern because I find it way less complex when you can ditch thinking about conditions and reduce the cognitive load. 
Exactly. :) it’s all about reducing cognitive load. 
Nice tutorial, worth the watch and shared with friends! In the next video, would love to see some details on how best to deal with omitted values when unmarshalling json - say optional items that you cannot use the zero values of within your application
I almost entirely agree with you, but for `os.Clearenv` ; in these sorts of situations, that's almost never what one actually wants.
Agreed. Sometimes you need to run tests against code that inspects the env, and that's what the code does, and you can't/won't/doesn't-pay-to change that code. See approach in my other post.
&gt; Use a JSON feed if you can. Why?
Would pointers do the trick? As in *int, or something of the likes? Or perhaps I am misunderstanding your question :)
Thanks for the tip about *sql.DB - I need to update the code I’m currently working on 😏
Depends on what you're trying to do. Having complete control over the environment can be useful if there is potential for interplay between how the test is invoked vs consistency in each test run. Plus I was just trying to enumerate the environment manipulating functions available, not necessarily say that every one of them should be used.
Try out [github.com/smartystreets/scanners/csv](https://godoc.org/github.com/smartystreets/scanners/csv) It wraps `csv.Reader` in a scanner-like API making it trivial to skip records. There's even an option you can pass to the constructor function to skip the first N records: ``` scanner := csv.NewScanner(reader, csv.Comma(','), csv.SkipRecords(5), csv.FieldsPerRecord(-1)) for scanner.Scan() { record := scanner.Record // []string record // process the record... } if err := scanner.Err(); err != nil { log.Println(err) // or whatever... } ``` 
If you know the length of the slice will be the same and not change you can set the values directly: var a [3]int if true { a[0] = 1 a[1] = 2 a[2] = 3 } else { a[0] = 4 a[1] = 5 a[2] = 6 } fmt.Println(a) // Output: [1 2 3]
Thank you! Very much appreciated.
You're welcome. 😊
Sounds like the job for a custom decoder. Iirc, you need to implement a Marshal and an Unmashal interface, and you’ve got your custom logic.
With pointer values you can eliminate the problem of the zero value during unmarshalling. This way you can differentiate empty string and null value for example. The "omitempty" keyword comes in handy during marshalling. In case a field has a zero value and "omitempty" is used, the json string will not contain that value. Here is the definition from the (documentation)[https://golang.org/pkg/encoding/json/#Marshal]: &gt; The "omitempty" option specifies that the field should be omitted from the encoding if the field has an empty value, defined as false, 0, a nil pointer, a nil interface value, and any empty array, slice, map, or string.
Of course. If you are an expert and you can solve any issues caused by misconfiguration by yourself, you can ignore my recommendation. These are some issues caused unstable MySQL connection. &amp;#x200B; * [https://github.com/docker/for-mac/issues/2442](https://github.com/docker/for-mac/issues/2442) (5min) * [https://github.com/go-sql-driver/mysql/issues/871#issuecomment-443205450](https://github.com/go-sql-driver/mysql/issues/871#issuecomment-443205450) (10min) &amp;#x200B; I don't want to debug user's environment issue. So I recommend 1min. Creating MySQL connection is fast enough in general. So 1min is not too short in most cases.
&gt;surely the point of a pooled connection manager is to deal with invalid connections like that? If there's a write error on the socket, try the next one? TCP is not stable than you think. In most case, \`write\` succeeds even if TCP connection is not healthy. (\`write\` writes data into send buffer in OS, not into wire) The error will happen when \`read\`. Since we \`write\` query already, it's not safe retry. (think about query like \`UPDATE tbl a=a+1 where id=1\`) So you must configure to avoid TCP error as possible.
If this is the only functionality you need from the package, I’d suggest just using encoding/csv directly and implementing the skipping logic yourself.
Loop until n with a csv.Read() inside. 
`scanner.Scan()` is the call you use to make the scanner read a new line. So you could use a counter like `lineCount` that increments on each iteration of the loop and then starting parsing when `lineCount &gt;= 5` e.g. lineCount := 0 for scanner.Scan() { lineCount++ if lineCount &gt;= 5 { fmt.Println(scanner.Text()) } } }
I don't understand your question. Golang doesn't care about it's API consumer. Imagine having some REST routes provided by Golang: - `POST /user` - `GET /user` - `POST /user/todo` It doesn't matter if the client (likely a browser) is made with React, Vue.js or pure JavaScript.
1. give an ls -l of any one of those files/folders 2. What user are you using to start vscode?
 ls -l /usr/lib/go/pkg/linux_amd64/ total 11368 drwxr-xr-x 2 root root 4096 02-16 20:30 archive/ -rw-r--r-- 1 root root 169728 01-24 16:04 bufio.a -rw-r--r-- 1 root root 177410 01-24 16:04 bytes.a drwxr-xr-x 9 root root 4096 02-16 20:30 cmd/ drwxr-xr-x 2 root root 4096 02-16 20:30 compress/ drwxr-xr-x 2 root root 4096 02-16 20:30 container/ -rw-r--r-- 1 root root 93000 01-24 16:04 context.a drwxr-xr-x 4 root root 4096 02-16 20:30 crypto/ -rw-r--r-- 1 root root 23998 01-24 16:04 crypto.a drwxr-xr-x 3 root root 4096 02-16 20:30 database/ drwxr-xr-x 2 root root 4096 02-16 20:30 debug/ drwxr-xr-x 2 root root 4096 02-16 20:30 encoding/ -rw-r--r-- 1 root root 6690 01-24 16:04 encoding.a -rw-r--r-- 1 root root 3434 01-24 16:04 errors.a -rw-r--r-- 1 root root 92664 01-24 16:04 expvar.a -rw-r--r-- 1 root root 188610 01-24 16:04 flag.a -rw-r--r-- 1 root root 388846 01-24 16:04 fmt.a drwxr-xr-x 3 root root 4096 02-16 20:30 go/ drwxr-xr-x 2 root root 4096 02-16 20:30 hash/ -rw-r--r-- 1 root root 14332 01-24 16:04 hash.a drwxr-xr-x 2 root root 4096 02-16 20:30 html/ -rw-r--r-- 1 root root 179182 01-24 16:04 html.a drwxr-xr-x 4 root root 4096 02-16 20:30 image/ -rw-r--r-- 1 root root 338206 01-24 16:04 image.a drwxr-xr-x 2 root root 4096 02-16 20:30 index/ drwxr-xr-x 3 root root 4096 02-16 20:30 internal/ drwxr-xr-x 2 root root 4096 02-16 20:30 io/ -rw-r--r-- 1 root root 131898 01-24 16:04 io.a drwxr-xr-x 2 root root 4096 02-16 20:30 log/ -rw-r--r-- 1 root root 50702 01-24 16:04 log.a drwxr-xr-x 2 root root 4096 02-16 20:30 math/ -rw-r--r-- 1 root root 203682 01-24 16:04 math.a drwxr-xr-x 2 root root 4096 02-16 20:30 mime/ -rw-r--r-- 1 root root 186128 01-24 16:04 mime.a drwxr-xr-x 5 root root 4096 02-16 20:30 net/ -rw-r--r-- 1 root root 1654142 01-24 16:04 net.a drwxr-xr-x 3 root root 4096 02-16 20:30 os/ -rw-r--r-- 1 root root 318904 01-24 16:04 os.a drwxr-xr-x 2 root root 4096 02-16 20:30 path/ -rw-r--r-- 1 root root 31296 01-24 16:04 path.a -rw-r--r-- 1 root root 57920 01-24 16:04 plugin.a -rw-r--r-- 1 root root 1386982 01-24 16:04 reflect.a drwxr-xr-x 2 root root 4096 02-16 20:30 regexp/ -rw-r--r-- 1 root root 351400 01-24 16:04 regexp.a drwxr-xr-x 4 root root 4096 02-16 20:30 runtime/ -rw-r--r-- 1 root root 3003586 01-24 16:04 runtime.a -rw-r--r-- 1 root root 111598 01-24 16:04 sort.a -rw-r--r-- 1 root root 246124 01-24 16:04 strconv.a -rw-r--r-- 1 root root 229828 01-24 16:04 strings.a drwxr-xr-x 2 root root 4096 02-16 20:30 sync/ -rw-r--r-- 1 root root 119938 01-24 16:04 sync.a -rw-r--r-- 1 root root 713334 01-24 16:04 syscall.a drwxr-xr-x 3 root root 4096 02-16 20:30 testing/ -rw-r--r-- 1 root root 343284 01-24 16:04 testing.a drwxr-xr-x 3 root root 4096 02-16 20:30 text/ -rw-r--r-- 1 root root 424470 01-24 16:04 time.a drwxr-xr-x 2 root root 4096 02-16 20:30 unicode/ -rw-r--r-- 1 root root 225066 01-24 16:04 unicode.a drwxr-xr-x 3 root root 4096 02-16 20:30 vendor/ Other than my own user group, the user I'm using to start vscode belongs to the following: sys bumblebee network power lp wheel
can confirm, I work on an online platform which integrates with our ios app, we have a REST API built in go and the sorta front end of it all is done in react which just sends requests to the API which will return JSON
Have a look at [https://github.com/Microsoft/vscode-go/issues/1914](https://github.com/Microsoft/vscode-go/issues/1914) 
After reading the article, I was able to reproduce the problem in command line by using go build -i instead of go build. Setting go.installDependenciesWhenBuilding configuration option in vscode to false have fixed the issue. Thanks!
Why not just make an easier casting of []interface{}? Then you have genetics.
```
So one way to do it is to scan the file for the offset of the 5th line, then start all of your csv operations from there. In a loop, you can just read from the file a byte at a time, add up the number of newlines, and once you've read the desired number of newlines, return how many bytes you had to read to get to that point. Of course, you can simply start reading from there since the file positon of the `*os.File` is where you want it to be but in the code below, I chose to completely isolate the act of finding the fifth line from reading. Anyhow, once you're found the offset of the 5th line, you can then re-open the file, seek to that offset, then do whatever you need to with the Reader to extract the data. In the example below, I do a `csv.Reader.ReadAll()` to store the contents into a slice. ``` package main import ( "encoding/csv" "fmt" "log" "os" ) // line() reports the byte offset of the beginning of the Nth line in a file. func line(path string, nlines int) (int64, error) { in, err := os.Open(path) if err != nil { return 0, err } defer in.Close() var offset int64 var nbytes int line := 1 for buf := make([]byte, 1); ; { if line == nlines { break } nbytes, err = in.Read(buf) offset += int64(nbytes) if buf[0] == '\n' { line++ } } if line != nlines { return 0, fmt.Errorf("could not find target line") } return offset, nil } func main() { path := "./test.csv" offset, err := line(path, 5) if err != nil { log.Fatal(err) } log.Printf("offset = %d", offset) in, err := os.Open(path) if err != nil { log.Fatal(err) } in.Seek(offset, 0) cr := csv.NewReader(in) r, err := cr.ReadAll() if err != nil { log.Fatal(err) } log.Printf("%v", r) } ```
Compile-time generic is more efficient, uses less CPU and memory.
Then what about more type inferring with := It pretty much does infer and the checker seems to already know the types. 
Maybe do this with interfaces instead, then you don't need reflection at all, you can just check whether an object implements the interface, which it will or will not depending on whether it has a generated method.
Pointers do the trick, just hoping to find a nice instructional video like yours on why pointers and how you access/set those values in your application. 
Unless something snuck in in the past couple of versions, no, you can not inspect a package for it's functions with reflect. The package will have to register the items of interest in its init function.
? sorry, not understand this.
Well instead of a new syntax to create something concretely generic. Why not something that checks at compile time the type and infers what type it is for you. So if you need a slice of strings and ints or something. var newgen := []{1, "some", true} That newgen variable would have created an underline array of those types and the := would sorta predict these types for you. Sorta JavaScripty but they wouldn't be mutable. 
The only issue with this is if you have new lines in your values. The CVS encoder will (should? I know the python equivalent does) handle a newline inside a quoted field. This solution would consider that two records. I’m on mobile so it’d be difficult, but a test could be written for that quite easily against both the stock CSV reader and this implementation.
Author here. I wrote [Flipt](https://github.com/markphelps/flipt) to solve a common problem I've seen at my last few jobs. (Almost) every engineering team has had some kind of home grown feature flag solution to help do continuous delivery but they've all seemed to have their shortcomings. &amp;#x200B; Often, this feature flag solution would be built into the original application/monolith and would then be retrofitted in someway to work with other services as the architecture scales/get's split up. This is where problems would usually arise as engineers would have to hack together a way to get feature flag data from the main app to their services and vice versa. &amp;#x200B; Also, the commercial feature flag solutions that do anything 'advanced' such as percentage rollout/segmentation like [LaunchDarkly](https://launchdarkly.com/) seemed crazy expensive to me. &amp;#x200B; Flipt is written in Go, and uses GRPC to communicate so that clients can be generated in any language that GRPC supports. The UI is built with Vue.js/Bulma/Bueify and communicates with the backend using a REST API generated via GRPC Gateway. &amp;#x200B; Full documentation is here: [https://markphelps.github.io/flipt/](https://markphelps.github.io/flipt/) &amp;#x200B; Please try it out, share it, and let me know what you think!
&gt; var a [3]int That makes `a` an array, not a slice. You probably meant `a := make([]int, 3)`.
You can log the context but that function will have to have context added.
What kind of cases/projects.
That's really neat! Have I understood it correctly, there is no database where the feature flags are saved? If that's the case, how are restarts and scaling handled?
Yeah I don't know what I don't know. The design of this language is quite different, some of which I didn't know about until this post so that's good. One of the things I am now questioning and still struggling to understand based on all of the conversation: is Go's language design is actually better for large scale projects that would typically be obvious candidates for classic OOP. Some say the language can be OOP under the current design and you said "strange places". In my mind it seems like it would be strange or unnatural, but maybe it's because I have been doing OOP for so long in the classic sense. After these comments I am actually more curious as to whether strange places are strange only because we are not familiar with them. I have no idea still if they require less code and are easier to follow or the people that have been posting trying to pass GO off as better than OOP (one person said OOp is a con) are like the people I know who still use C instead of C++ to do certain things which is silly to me. I love Python but it's still slow sometimes, but I can really crank out code in it. I was honestly looking for more people to give your answer, which was each has their strength and say it's not OOP, and OOP is clearly well suited for certain things GO is not as well suited for but that isn't what I heard from many and it's hard to know how biased they were being.
Well do you still use Python for certain things? If so what are they and why?
There's a SQLite db, so restarts are handled by assuming you backup and restore that file. Scaling isn't addressed but I suppose you could somehow duplicate the data and run parallel copies? However it seems to be a pull model. That means added latency and a ton of requests to your flag server - if you want it to be real time you need to query it during the request lifecycle. etcd and either direct watchers or something like confd seem like a much more scalable solution. This is pretty nice for having a clean UI though, and having a library instead of a homegrown solution is definitely nice!
Exactly. The db is SQLite. I wanted it to be as simple to install/get up and running as possible with no external dependences. I plan to add support for 'external' databases such as Postgres/MySQL to address the scaling concerns and allow you to run multiple copies. &amp;#x200B; As far as the pull vs push. You're correct in that adds latency if you make a ton of requests to the server. But since this will be running in your infrastructure the thought is the latency will be low enough to be a non-issue. I'm also working on adding caching server side, and you can obviously cache in your application as well, but a pull model does make this difficult. &amp;#x200B; I'd like to add streaming updates support (perhaps in a 'Pro' version?), so that your application can subscribe to a stream of events and when a flag is enabled/disabled/etc then an update will be sent to your app so that you can react to the change, which would allow for simpler cache invalidation on the client side. Or perhaps support for etcd as you mentioned! &amp;#x200B; Sorry for the "I'm working on it" type answers.. but it is still a work in progress.
Try changing/adding the User-Agent header there
The message suggests you are making several requests in a very short time. Have you tried adding a time.Sleep call between requests?
Thanks for the fast reply, I'll try this now
* "Jump to definition" (`Ctrl-]`, and then jumping back and forth, `Ctrl-o`, `Ctrl-i`). * `:GoImports` (bound to `&lt;Leader&gt;i`). * `:GoAlternate` (bound to `&lt;Leader&gt;a`). * `:GoRename` (works not so good when you have vendored stuff). * `:GoCallers` 
TBH I just use it and don't think about the place of it in the process! Go-vim automatically does go-fmt and go-vet on save and this is great and useful but it is just the way it's set up If I didn't have this I'd simply save it and run go vet and go fmt in the shell
Thanks for your reply. I got it working using j\_bono's suggestion, I'll update my post with the solution
1. XML is inconvenient to work with. 2. The fields of Atom and RSS aren’t as well thought out as JSON Feed’s. 3. If you make a JSON Feed, it’s trivial to include it on another page with JavaScript. 
If you haven't read it yet this tutorial goes over most of the features one by one, highly recommended: https://github.com/fatih/vim-go-tutorial
My favourites: * `:GoAddTags`, adds struct tags to fields * `af` and `if` text objects to select and match function definitions * `:GoDecl` (jump to a type or function declaration via fuzzy match search (ctrlp, unite or fzf.vim needs to be installed) * `:AV` and `:AS` (mapped to :GoAlternate to open vertical and in split mode) * `gd` (jump to definition) * `K` (opens the doc for the identifier under the cursor) * `:GoInfo` (show the information for the identifier under the cursor) * various snippets, my most used: `anon`, `ts`, `ap=`, `errrn`, `ok` and `gof` * `:GoBuild` mapped to &lt;leader&gt;b and so many others. Check out `:help vim-go. There are tons of features you might not be aware of yet. 
I like writing things that way. You initialize with the default and then only change it for a special case.
&gt;trying to use OOP design patterns Wait, why? What's wrong with using design patterns assuming you're building something complex enough to require them?
Move the env var loading into a function like GetConfigFromEnv that returns a struct with config data. Then have it default to your dev env setup and make another function GetTestConfig that returns the Config struct with test config.
I'm going to post my fully-working code again for completeness, but I think at this point you should consider checking out https://github.com/julienschmidt/httprouter It's well-proven, and you may find it less persnickety. Regardless of the lib you choose, I highly encourage you to read all the docs. In terms of httprouter, these are very good, and you will find information on serving static files at the root node later towards the end. The problem with trying to whack something together without fully understanding it is that you end up with unexpected or similar results. ;) At the very least, take the code below and try and add what you need to it a piece at a time until you have what you need. https://gist.github.com/flowchartsman/50d81a034e6a61743215dfd8af814400
At a high level, you likely want to write a recursive descent parsing algorithm using the xml.Decoder [https://golang.org/pkg/encoding/xml/#Decoder](https://golang.org/pkg/encoding/xml/#Decoder). The Decoder emits token each time the Token func is called. The token method will also signal when you reach the end of the document. And if you are worry about performance, you can use a TokenReader which will give you a streaming api. So you'd need a set of functions that recursively call itself and then terminate when they've consumed everything you need, where each func would pass around the decoder. Take a look at this playground as a starting point. https://play.golang.org/p/GqUOqZKHiYJ
Command line tools, api services, web services, distributed message services. Basically things I would have used python for in the past. I try to determine if Go is a reasonable solution first before considering python. But there are some cases where Go can't be used, if it has to be deeply integrated with existing python and I have no binding options. 
What are your top reasons for choosing GO when possible (other than speed) Do you I think that there are programming projects that lend themselves better to traditional object-oriented programming vs the structure of the go language?
I strongly suggest you to read Reddit Bot Etiquette [1][2] if you want to play nice with the API. [1] https://github.com/reddit-archive/reddit/wiki/API [2] https://www.reddit.com/wiki/bottiquette
I strongly suggest you to read Reddit Bot Etiquette [1][2] if you want to play nice with the API. Specially the part that explains how to define the User-Agent and program version number. If you don’t disclose your Reddit username, your bot will be ghost banned. [1] https://github.com/reddit-archive/reddit/wiki/API [2] https://www.reddit.com/wiki/bottiquette
I use python if it is for a 3rd party product with an embedded python sdk/api (Autodesk Maya, The Foundry - Nuke,...). Or if we only have Python or C++ libraries for our internal products. I use python when I have to, but I always prefer Go first. And I try to write Go clients for our products as-needed. I still haven't used Go for a project needing a desktop UI (it has always been Qt+python) but I would end up trying one of the Go UI options if it comes up. 
&gt; I don't know how to operate from the terminal Then learn how to use the Terminal first. &gt; I downloaded the package. Do you mean _“go1.11.5.darwin-amd64.pkg”_? If yes, you just need to double click it and follow the instructions.
Double-click the pkg from your Finder and complete the install. But you are likely going to encounter the terminal again at some point if you want to run the Go tool directly. You could avoid that too if you spend all your time in an IDE for your projects. 
&gt; I don't know how to operate from the terminal Then learn how to use the Terminal first. &gt; I downloaded the package. Do you mean _“go1.11.5.darwin-amd64.pkg”_? If yes, you just need to double click it and follow the instructions. You probably need to read the Go Tour as well: https://tour.golang.org/
Okay so what aspects of go make you more productive in it vs Python?
I see! &amp;#x200B; It looks very interesting! Although if it's I were to implement this, and especially in production, I would need to have support for MySQL and a caching layer, so that the service can die and restart as well as scale as needed. &amp;#x200B; Awesome with the UI though!
Gofmt means there is one consistent way to read code vs a mix of styles from different contributors. Static typing is a huge benefit because you get active help from the compilers, and accurate help from tooling like IDEs and static checkers. To be even more concrete, I can make huge refactors to my code with confidence, such as a rename of a symbol, and be sure that every call site is updated. Python is subject to runtime errors where they would be caught by a static typed language like Go ("expected 10 arguments, got 11). Tooling is just much more powerful for Go, when I can, say, Find All Usages of something accurately. Integrated testing and benchmarking is better. Integrated profiling is better. Concurrency is powerful and easy. Deploying is easier because I don't have to worry about provisioning the destination with all the python dependencies and virtual env and nginx. That's everything I could think of off the top of my head. It's pretty heavily weights towards Go. 
For the manual bson marshaling, does mongo-go lack any convenience functions for this? Seems like a real annoying pain point
It doesn't usually occur to me as often as you are implying, the difference in the OOP implementations between Go and Python. There is the way one writes code in each, and they both can get the same job done. Maybe GUI frameworks benefit alot from inheritance and subtyping, but it seems there are Go GUI frameworks making it work (I don't have much experience with desktop UI in Go. Only python). So my top reasons would be to think about maintainability and scalability. While some python developers might feel Go is more restrictive on them with types, I feel that it is only a learning curve. Once you establish your basic skill in using Go, you learn how to approach problems from a Go mindset the same way you approach Python. It becomes less of an issue that you can't do the Python way within Go. 
I really liked mgo, and I'm very sad to see it going away. I don't really like the new driver's API.
Well it can definitely die and restart and keep your data. SQLite persists to a file so as long as that file remains on your host the data is safe. If you were to run this with docker you would want to mount a volume to the host to store your data. There’s an example in the docs in the installation section on how to do that. Hope that helps!
[removed]
Thank you for all your time and Help, honestly I appreciate it. I understand what you are saying, reading documentation is difficult for a beginner though, so trying to follow along with tutorials was my starting point and hopefully getting a grasp along the way. Getting this to work, though, seems to be too deep a rabbit hole for me. I am, instead, going to try build my own web app and start simple function by simple function, slowly building from the ground up. Thanks for the code, and again thanks for your time. If I EVER get to the bottom of it (Which I intend to return to it now and then) I will post it here, just in case anybody actually cares.
Because you then cannot have runtime polymorphism. What do I mean by that? Consider a function `foo`. It may return one of two concrete types: `[]float32` or `[]float64`. What does this return? ``` a := foo() ```
Pretty cool. How does it compare to Unleash? https://github.com/Unleash/unleash
every line of the dockerfile represents a layer in the docker container. if the line itself or the files concerned by that line have not changed in between builds, then docker caches that layer and uses it again for future builds. you can experiment around with this by writing a Dockerfile as simple as this: FROM alpine:latest COPY foo . COPY bar . RUN sh in a folder with a foo and bar file in it.. run it once, then again without changing a thing, you'll see that the second build is super fast because it is cached. before running it yet again, change the bar file. you'll see in the output of the third run that it uses the cache up until the `COPY bar .` line, in which case it does not. and once one line's cache is invalidated, then all subsequent layers are rebuilt. so getting back to the previous example: if the `Gopkg.lock` and `Gopkg.toml` files aren't changed, then those layers get cached and so does the `dep ensure` line.
The bigger one
fun fact, they both have the same size - 3 words. If `foo` returns an `interface{}` they are both 2 words. But with `interface{}` there is now concrete type information available at runtime.
Well it can definitely die and restart and keep your data. SQLite persists to a file so as long as that file remains on your host the data is safe. If you were to run this with docker you would want to mount a volume to the host to store your data. There’s an example in the docs in the installation section on how to do that. Hope that helps!
Yeah it's a great package!
sorry, I mean that I downloaded AND installed it
yeah using the playground online currently
Sure, but scaling would most likely be an issue since multiple services would have to open the file together. It's an awesome mvp nonetheless! 
You can use a for loop for that: package main import ( "fmt" ) func main() { var str = "This is a string" for i:=0; i&lt; len(str); i++ { fmt.Printf("%v \n", string(str[i])) // YOUR IFS HERE } }
how do i do one character at a time till the function is ran again, which then gives me the next character?
You can cast a string to a byte slice: Given a string str b := [ ]byte(str) so you can iterate over b and process each byte in turn. See https://stackoverflow.com/questions/8032170/how-to-assign-string-to-bytes-array
http://xyproblem.info/
The for loop is (in the example) printing one character at a time. Just replace the \`fmt.Printf()\` for wathever you want to do there.
make it recursive, pass the string and current pointer to as parameters?
tx already is a pointer. You are therefore trying to pass a pointer to a pointer, where only a pointer is expected.
What if OPs bot is a web crawler? 
`tx` is already a pointer to the transaction. You can just do `foo(tx)`. You are trying to pass a _pointer to a pointer_ which is what `**sql.Tx` is indicating. 
That’s not what the parent comment was asking. It’s not about if you’ve got it working. It’s about if you’re bombarding the server with requests, which is considered poor internet etiquette. 
To help you think about this: if `tx` has a type of `*sql.Tx`, why would you expect the address of tx (`&amp;tx)` to have the same type? (This is also exactly what that error message is saying.... `**sql.Tx` is nothing like `*sql.Tx`) &amp;#x200B; &amp;#x200B;
excellent logic, thank you
ohhhhhhh that makes total sense thanks
okay makes sense, thanks. is there a way to tell if variableString is at the end so I can value it as EOF?
With respect, I think you're wrong. The parent comment was just offering a solution to my problem, I don't think their suggestion was in the interest of 'internet etiquette'. I understand where you're coming from, but it's not as if my program is making hundreds of requests per minute. Besides, I imagine Reddit has pretty solid protection against denial of service attacks, if that were the case.
Too bad it has a restrictive license -- from the comments in the readme it comes across that maybe your ambition is to make it as pseudo-open source commercial software.
Stop pretending to be a human...
Well, if it’s the last value of the for loop (it’s equal to len(str) the it is the EOF.
1. Yes, it's convenient 2. Yes, they're convenient 3. When would I need that?
You can make a function to create the slice `func mkSlice(a,b,c int) []int { return []int{a,b,c} }` Then use it in your code `a=mkSlice(1,2,3)`
Maybe look for a tutorial on YouTube.
20+ years in finance and security among others. I have been in the planning phase of refactoring a proven software architecture of my own design that is in use still today and has also been acquired several times. This is the sixth iteration of the architecture refactor and I have spent considerable time reading and researching in selecting Go.
Yes, yes, yes, great. 
[removed]
Had the same feeling. 
You could do it using `reflect`; write a function that iterates over all fields of an input struct and recurses on all children, or can take some special action if the field is an ObjectA. That won't be faster than writing the loops manually but would be a lot less code.
Okay that makes sense, thanks for taking the time to explain it! 
If you need access to both the character and the location of the character, you can do this: ```go for i, c := range str { // i is the index of where c is in str // c is your character } ```
Ya... I guess you have the same problem when reading lines with a bufio scanner.
I'm not really sure what you mean. Can you explain?
In that case, I don’t understand your question. If you are asking how to run or compile a Go program from the Terminal, then do this: 1. Open the Terminal.app 1. Execute `touch ~/main.go` 1. Execute `open ~/main.go` 1. macOS will automatically open TextEdit.app 1. Copy and paste [this code into the editor](https://play.golang.org/p/HmnNoBf0p1z) 1. Save your changes, then switch back to Terminal.app 1. Execute `go run .` to execute the program without compiling Alternatively, you can compile the program like this: 1. Execute `go build -o aashnalakhani.bin main.go` 1. Execute `~/aashnalakhani.bin` 1. ??? 1. Profit
&gt; What if OPs bot is a web crawler? What about it? Your question seems to be incomplete. If you are asking _“Will their account be also ghost banned if OPs bot is a web crawler?”_ then the answer is yes.
My program just converts Reddit embedded videos to mp4. I made it for personal use and to practice using Go. In fact, it's not even specific to Reddit, you could input any web page URL that contains a .m3u8 video (this is what Reddit uses for their videos), and it will output the video in mp4 format.
The title of your question says you are having trouble with the downloading part. If you want decent help you should try and write enough detail in your question and make sure it is accurate for your problem. Otherwise people waste time typing up response that don't help you. 
I wouldn't call it production ready. It's impressive work but sadly unmaintained and with lingering problems. In the simplest possible usage, I encountered randomly unpredictable slowness. I've reported it (https://github.com/chromedp/chromedp/issues/168), others confirmed it and it's been a year and hasn't been fixed, despite a fix apparently existing in a fork. The are plenty of bugs reported and unmerged pull requests. I ended up using node's Puppeteer library instead. For Go there's also https://github.com/mafredri/cdp, which I haven't used but looks actively maintained.
Seeing as from the other replies, that you have actually installed Go and are asking for a lesson on how to get started writing and running Go programs, have you tried following any of the "getting started" pages, both official or unofficial? It doesn't make sense to type up a getting started guide here in a reddit thread. But it would make sense to answer very specific questions about problems you are currently having. Just saying that you don't know how to use a terminal is a bit too broad when there are guides online for getting started. I can say that if you don't have a fully integrated code editor already, that you might need to run some commands to build your code. Try getting VSCode + the Go plugin if you want a free integrated solution and don't want to focus on running shell commands. 
 I have Timesheets demo version UI running on [https://timesheet-cloud.herokuapp.com/](https://timesheet-cloud.herokuapp.com/) from repo [https://github.com/valasek/timesheet](https://github.com/valasek/timesheet). Server is running but UI cannot connect - I do not know how to read PORT command line variable form VUE. Backend is written in GO. Comments welcomed. 
Cool project 
The point is that web crawlers by google would not have a Reddit user name. Why should OP have to? It reminds me of how linked in tried to sue someone who crawled their public profiles. I can understand not bombarding the server with many requests that are close together, but it brings up the question, “Do I need to create a user account to crawl public information?”
This tool ([https://github.com/cweill/gotests](https://github.com/cweill/gotests)) which is often included in setups like Visual Studio Code with the Go extension. You can make a file, then search for "tests" in the command palette, and you'll see a command to generate unit tests for the file. It creates a skeleton with a common test pattern of "given x, I expect y". It creates structs for the "x" and "y", and creates a for loop at the bottom of the test file that just loops through your list of "x" and "y", calling the tested function each time, and using the testing tool to assert a failure if it doesn't get the right thing returned. &amp;#x200B; This only works for pure functions. If you're making tests for a function that has side effects, you just replace the "y" part of that example above with some custom code to get your test done. I often create a function called "wantFn" which tests the state I expect the overall system to have after the function is called with "x". If the state isn't what I expect, I assert a test failure.
This tool ([https://github.com/cweill/gotests](https://github.com/cweill/gotests)) which is often included in setups like Visual Studio Code with the Go extension. You can make a file, then search for "tests" in the command palette, and you'll see a command to generate unit tests for the file. It creates a skeleton with a common test pattern of "given x, I expect y". It creates structs for the "x" and "y", and creates a for loop at the bottom of the test file that just loops through your list of "x" and "y", calling the tested function each time, and using the testing tool to assert a failure if it doesn't get the right thing returned. &amp;#x200B; This only works for pure functions. If you're making tests for a function that has side effects, you just replace the "y" part of that example above with some custom code to get your test done. I often create a function called "wantFn" which tests the state I expect the overall system to have after the function is called with "x". If the state isn't what I expect, I assert a test failure.
Obviously IANAL. Perhaps I chose the wrong license initially and am open to changing it. My goal is to follow a similar model that Sidekiq follows [](https://github.com/mperham/sidekiq) Open source core functionally that anyone is free to use and modify as they wish. My understanding that was since this is an application you access over the network and not a library that you link against that the GPL would not require you to also open source your application. You are correct that I would like to offer a commercial Pro version including support and other enterprise features in the future if possible. Tl;dr I’m not trying to restrict anyone from using it. If it’s the wrong license for what im trying to do please inform me. 
Perhaps licensing the generated client code under a more permissive license would solve this issue? Since the client code is the only code that would be included within your applications?
I would vote for the (very open) MIT for the open source core (I have dozens of MIT codebases). It would allow every use - even commercial. The reason that some projects don't release their open source core under MIT is because a competitor could *also* build on it and compete with the official Pro version. 
thanks for taking the time. is it possible to make the go IDE into an application I can click on and access rather than going through the terminal? I also got up to step 4, where it failed and said No application knows how to open /Users/myname/main.go.
Yeah, VSCode and downloading anything has been a process on my mac. I'll try to gather enough information about the issues that I am facing with finish setting up Go, and post a new post when I can better articulate my questions and concerns. Thank you for the help and advice.
&gt; Do I need to create a user account to crawl public information? That question should be rephrased to take in considering the context. We are talking about querying Reddit’s API. They expect everyone to abide to their rules by following their guidelines, if they discover that someone is not following their rules then they will immediately block the requests from that program. &gt; google would not have a Reddit user name. Why should OP have to? Google’s crawler translates into free advertisement to Reddit, so of course they want to let them crawl their content. Also, determining if a bot comes from Google or not is very trial, among the dozens of techniques that exist, checking for the IP address is one of the simplest ones and probably one of the first things they check. So, unless OP is Google, they will have to abide by the rules that everyone else in the Reddit community is following. If they don’t want to follow the rules, then it’s fine, their bot will just be ghosted or blocked.
I'd recommend using an Xpath library on the xml directly. I don't have experience with any Go libraries particularly, so I can't recommend one personally. This will allow you to query or the bits and pieces you need relatively naturally.
That is true
/u/mangofizzy is making a joke with regards to the title of your post. &gt; _“You appear to be a bot […]”_ &gt; Stop pretending to be a human…
&gt; is it possible to make the go IDE into an application I can click on I understand what you mean, but that sentence doesn’t makes sense. IDE stands for _“Integrated Development Environment”_ [1] which can be described as a code editor with extra capabilities to understand the programming language that you are writing, capabilities to help you with the development by providing additional tools. You should say _“make the go **program** into an application I can click on”_. --- To answer your question… Yes, there is a way to convert your Go program into an application that you can click on. Actually, your Go program is already clickable. When you compile the `main.go` file using this command `go build -o program main.go` you can double-click the resulting binary named “program”; macOS will launch a Terminal.app session, print something, and then exit. What you want to do is to open a dedicated window for your program, but you have to write code to open this window, and to keep it open until the user decides to close it. To do this, you need to create a Graphical User Interface (GUI) [2], unfortunately, Go doesn’t have a standard GUI package, so you’ll have to import one from this list [3]. &gt; I also got up to step 4, where it failed and said Your computer doesn’t understands that a file with the `.go` extension is a text file. Right-click the `main.go` file, then select the option _“Open With”_ then select TextEdit.app Good luck! [1] https://en.wikipedia.org/wiki/Integrated_development_environment [2] https://en.wikipedia.org/wiki/Graphical_user_interface [3] https://github.com/avelino/awesome-go#gui
Cool, thanks for the info! 
I'll tell you my story, and see if it makes any sense to you: I did enterprise OO C# coding for years, having painfully learned OO and switched over from imperative coding to OO over the course of a painful year or so in the mid 90's. Then around 2010 I switched from MS, installed Linux, and started teaching myself everything afresh, starting with JS. Going back to imperative seemed like a total backwards step, until I actually got into it, and then it seemed like being freed from artificial constraints. I was so used to wrapping classes around everything (even having "util" singleton classes for general-purpose functions) that I had forgotten that you can just write functions without them being methods. Go fit perfectly with my state of mind at that point. I'd done some coding in COM (Microsoft's cross-process and cross-server communication tool, pre-.Net) years ago and found it awesome. Interfaces are used in the same way in Go, and I grokked them immediately. I haven't looked back since - I like Python, can't stand Ruby (too many ways to do things, and Rails is too much magic), and don't get PHP at all. I enjoy JS but didn't find it a good fit for server-side. But Go fits the way I like t think about things. So, to get back to your questions: - Using interfaces as objects leads to strange places because a lot of good OO design relies on inheritance, and Go uses composition to do that job. They're not strange because they're unfamiliar, they're strange because you end up contorting your object model to make it all fit. Interfaces are not objects in the way that any "OO design patterns" reference would use objects, and thinking about them the same way as OO objects doesn't work. - OO is a con (and I say that having spent years in OO-land) because a number of promises of OO (like infinite code re-use) turned out to be not true. But the main promise: that system complexity would decrease because implementation details can be hidden inside classes, turned out to be a mixed bag: the complexity moved to object inheritance graphs and object lifetime management and the other gnarly stuff that OO needs to deal with. And it turned out that hidden implementation details can bite you anyway unless you're very, very careful, which most people aren't. - C is better than C++ for some use cases ;) Go folks can be a bit sensitive about criticism because Go has taken such a beating for not having generics. And y'know, tribalism and human psychology. Trying to separate that from the actual technical discussions can be tricky. And the truth is that most of the arguments are over tiny details that don't matter too much. 
I am curious about how people do that as well. For me if the type is strictly being used in one file, it belongs there. If it is a type used in more than one file it goes into types.go. But my app is small and I am working alone. I would suspect for a large team they would go in some common file 
Yeah now when I'm working on a project with multiple .go files I'm noticing it feels wonky having types laying around when they are all within the package 'main'.
Thanks your responses were very helpful. Thanks for the perspective.
I’m pretty sure OP was just using HTTP GET and didn’t use the API. I’m making an argument in favor of the morality of circumventing APIs for public information. I’m not sure if it’s right or wrong but I don’t see how Google’s web scraper is different to a web archive’s or a school project. 
Also I think that is the information I was looking for but I don't think I knew enough to ask the right questions from some light reading. I think I hear you saying that the complexity with large projects, in your opinion, with procedural languages (with other unique features in the languages of course) is just different complicated not more or less...
As close to where you’re using them is the standard. So in the same file as your usage of them. Eg, if you had a server package, and it needs to unmarshal a json object in the request, you would put it in the same file as the handler that uses it. I do diverge from that a bit, in that I sometimes have marshal types that I want to share between services. For example, my gRPC protocols are in their own package that I can call from wherever. 
I think the tooling around Go, whilst amazing, can feel a bit clunky until you learn your way around GoFillStruct, GoTests &amp; such. If there is any focus on the frontend, Golang is not a very attractive proposition. Doing Javascript everywhere is just too attractive. HTML templates is another one, that's amazing esp from a security perspective once "you get it", it just feels way way too clunky for coders dipping their toes. Go's mySQL driver has loads of surprises. Go and JSON is just pain until you develop a workflow. :GoTags et al. Even I am not confident about structuring a project. go.mod is relatively new and I think some people will again be frustrated with its workflow challenges. The debugger isn't great to use, so reaching for log.Debug which feels a bit crap compared to setting a breakpoint in Javascript. I think Go lends itself to the microservice paradigm, and then requires a huge paradigm shift in many people's minds, which is hugely challenging. The AWS SDK for Golang is a bit of a mess. I use V2, but often I really miss V1 features like CredentialsChainVerboseErrors. I love Go, but I do feel like a pioneer. ;) 
I'm using it now. It's seems well built, but I do wish it was a bit more actively maintained.
Haven’t seen it before, but it looks a lot like they’re hacking basic socket primitives onto NodeJS. Without digging, I suspect it’s via C++ addins instead of JS native, which would be the right methodology. It’s pretty native to Go to handle huge numbers of proper connections simultaneously on Go. If they’re so dead set on Node that they’ll run full sockets on it, then you’ve gotta ask yourself if it’s worth dying on that hill. If it is, Go is seriously higher speed and capacity for sockets. 
Of course never in a separate file called "types.go". What would that file even _do_?
Sorry ! I am unable to understand what you are trying to say &amp;#x200B;
Thank you actually its redirection is pending and its new page is : [https://www.scalent.io/services/golang-developer](https://www.scalent.io/services/golang-developer)
can you help me to figure which where exactly typo is ? &amp;#x200B;
That could be the solution depending on the specific use case, but I'd advice against this if at all possible. Custom marshal/unmarshal methods hides "magic" under the hood, which makes it more likely for future development to make errors on this topic.
Check out &amp;#x200B; Emitter: [https://emitter.io/](https://emitter.io/) Centrifugo: [https://github.com/centrifugal/centrifugo](https://github.com/centrifugal/centrifugo) &amp;#x200B; I have also built my own in house Real time messaging system at work for our production to suit our custom needs but its not open source as of yet. 
Please for the next article/blog post in code snippets use early returns :D 
You’re being downvoted for saying something that sounds like “I don’t care if my bot taxes others’ resources, way above and beyond what normal humans do, by accident”.
https://learnpythonthehardway.org/book/appendixa.html might also help OP.
Could it be simpler? Please let me know! Otherwise I hope to use this as a starting point for little internal "back office" apps at my workplace.
Keep large type declarations away from logic to not clutter the logic - that’s why I do it
I would do it completely different, by using this package and make a simple xml walker with that: &amp;#x200B; github.com/antchfx/xmlquery
This depends mostly on what you think a "character" to be? A byte? A unicode codepoint? If the later: in what normalization?
The only thing simpler I can think of would be paying for Github Enterprise so you can just use SAML.
what if you generate it also when it has "no use", so you always have a complete system, only the functionality is different by the plugin.
use append: https://play.golang.org/p/lLyKVuR5rYU
I'm not sure how it'd clutter the logic to have the relevant type declaration at the top of a file rather than another file... Surely it's better to keep a type you need to refer to and modify in the same place as the code it's tied to...
Sometimes it will take a couple of screens to scroll to get past the types, in that case I prefer to put them separately. That is mostly the case when I work with unmarshalling xls files and json api with numerous data fields, especially when nested structs are involved
For unmarshalling big known formats or API endpoints, yeah, that makes sense.
Really no way to escape the crap of the front end, just look for a bright side of being able to write that crap in Go
Really no way to escape the crap that client side development has become, being able to write that crap in Go would make it at least somewhat more tolerable though.
I write a lot of web applications and I usually structure my code like this: ``` ├── app.go ├── cmd │ └── app │ └── main.go ├── http └── strorage ``` `app.go`: domain types and interfaces `cmd/app/main.go`: main package `http`: http handlers or router engine using domain interfaces `storage`: storage implementation using domain interface This is overkill for small applications. In small applications I usually keep everything in `main.go`. In mid-sized applications I use separate files for types if the type has more logic, getters and setters, interface methods or custom JSON marshalling.
Yes. And anyway, it's GPL, not AGPL.
Hmm okay, fair enough. Well for the record, I do care if my program was taxing others' resources, it just seems to me like the original comment was simply offering a solution, rather than low-key accusing me of making malicious software 🤷
There is a way to do this very easily, with a paid service. Send me a direct message if you're interested. &amp;#x200B;
Sounds interesting. How do you run it? Is there are getting started guide?
Not all go packages are using git. Bzr is another source control system that you don't seem to have installed. I wonder how the error message could have been clearer?
1. No run-time dependency hell. Just a single binary to deploy. 2. Easy to keep up to date. All it takes is a re-compile with latest version of Go tooling and redeploy. 3. Fast and light weight. I have a Production service that runs with just 8 MB of heap usage.
For my university task I must to make very similar server to this but using go language: [https://codecalamity.com/uploading-large-files-by-chunking-featuring-python-flask-and-dropzone-js/](https://codecalamity.com/uploading-large-files-by-chunking-featuring-python-flask-and-dropzone-js/) I'm probably don't understand what I actually don't understand. P.s. how do you save file you uploaded? &amp;#x200B;
Disclaimer. I'm new to Golang and find it very different from my many years of Java and Android but still interesting and funny! 
Learning any new language makes you a better programmer, you learn new concept. Every language when used idiomatically teach you concept. Haskell, OCaml,... teach you functional concept. C memory management and tricky low level stuff. For Go I would say concurrency (goroutine) and dependency injection (interface).
I've used logrus fields with an "error" field for errors, along with other relevant information. Same for regular request logging, things like user-agent, ip, route, etc... have been really helpful debugging. Another tip is to use the JSON formatter in production, which makes parsing the logs into an aggregated log platform like elasticsearch, splunk, google cloud logs, etc... a breeze. 
i think it teaches restraint and to value simplicity.
It depends on the context. In many cases for "back office" apps, I found that it's mostly easier having a separate gatekeeper / gateway like [https://github.com/pusher/oauth2\_proxy](https://github.com/pusher/oauth2_proxy) or [https://github.com/buzzfeed/sso](https://github.com/buzzfeed/sso). That way you don't have to duplicate, and maintain the authentication logic across these apps.
In general I use fields to capture contextual information around a log line. For example, in a method where I’m retrieving a user’s information, at the top of the routine I might create a new `logrus.Entry` with field user containing their ID. Then in the rest of this routine, all my logging around retrieving their info with have this contextual info attached to it (say, a debug line “querying database” doesn’t need to be “querying database for user X” because you gave it that info in the context of a field). Sometimes I just need that context for a single line so I’ll do `logger.WithField(...).Info(...)` but if you’ll use the logger with this context multiple times in that routine you can create a new `logrus.Entry` at the beginning with `WithField` and then use that entry throughout the routine. To answer your specific concern about errors in main, I think what you want to do there is log the error at the error site before bubbling it back up to main. E.g. ``` if err != nil { logger.WithErr(err).WithField(...).Error(“doing something”) return err }``` This way you log where you have all the contextual info around the error to include as fields, and then return it back to its caller to be handled appropriately.
its pretty similar to all of those and c, even has some vague similarities to the ML derivatives with the pseudo tuples. programming is programming.
&gt; extracting information from the error only to attach them as fields seems unreasonable. Why? One solution that I used is to implement custom error type that contains all contextual information inside error struct as a map. In Error() you format everything nicely to simulate "concatenated strings " behavior. When it's time to log this error you type switch on it, extract contextual information and pass it to the logger as fields.
Maybe use interfaces instead, and have a plugin type that's generated that only implements the methods you need. Then you can just use type assertions against the generated plugin type to see if it has a method. Something like this: https://play.golang.org/p/3VJE4aTP2T8
Native ( as opposed to Python-style bolted-on) concurrency helps you design better apps . Concurrency is not always easy to design and reason about 
In my understanding, it means that the proposal changes the langage itself (by adding new keywords for example). Here, the proposal changes the language by adding a '?' to the grammar.
So cool!
I am using Logrus via dependency injection. If the logic requires, I add custom fields to the Logrus instance in the initialization function and then use that inside the package. I am also using JSON formatter as its easier to parse. 
Thanks! Email me and I can add you to our slack. The docs have a few examples. 
As a complete hobbyist newbie Gopher, simplicity is the concept I value most.
Being passionate about working with computers again ;-)
sometimes they end up (within a package) inside base.go, (in my case) where some of the package functions are stored too.
Are you the sole developer? Who will maintain this code base? How will you host it? What does the rest of the eco-system of existing apps look like? What are the time constraints for v1.0? Are you running on Windows or Linux? What does the talent pool look like in your area? Questions about technology choice are rarely just about choosing the underlying language to the exclusion of all other considerations.
No errors? No sudden slowdowns?
Have you looked into Google's Identity Aware Proxy (https://cloud.google.com/iap/)? 
Why is concurrency using Coroutines bolted on? I’d say it’s not as efficient as using Go or Erlang, but using asyncio is very straightforward in Python. :)
Generics are unnecessary given macros or preprocessing. I am using sed to preprocess my Go code. If that is not vintage, dunno what is..
Go borrows ideas from a lot of other languages; one of the most novel ("share memory by communicating") reminds me of Erlang/Elixir, so it might help you with those. Go also has first-class functional programming, which is a hugely valuable thing to know how to do (you see people doing this in Javascript, Scala, and all the functional languages out there). &amp;#x200B; Go should teach you to think more concurrently; that's where its strengths are. This is not specific to another language, but inline with the direction hardware is going (more cores, smaller improvements per core).
vim-go is absolutely amazing! I owe a not-insignificant portion of my enjoyment of working with Go to its finely crafted, tastefully curated brilliance. My favourite things: I use jump to def and autocomplete all the time, they're the two most critical components of my workflow, which is heavy on the reading side. Jump to def is fast, accurate and buttery smooth, and I love that you can jump into any dependency or the stdlib out of the box. Having said that, Go modules make it very painful to hack on dependencies when spelunking for bugs as all the files are marked as readonly. The [gohack](https://github.com/rogpeppe/gohack) tool makes this significantly easier to deal with, but it's still a major workflow downgrade when hunting pesky bugs or experimenting cross-project. The snippets integration is indispensable. I used ultisnip at first but it is slow as molasses so I switched to neosnippets and haven't had a serious problem since. vim-go comes with some critically useful snippets configured out of the box, especially the `errn&lt;CTRL-K&gt;` snippet, which becomes `if err != nil {\n\treturn err\n}\n`. There's also `:GoIfErr`, which does a similar thing with some extra magic to infer return types too, but I prefer the ergonomics of snippets, maybe it's just what I'm used to. My neosnippet config looks like this: imap &lt;C-k&gt; &lt;Plug&gt;(neosnippet_expand_or_jump) smap &lt;C-k&gt; &lt;Plug&gt;(neosnippet_expand_or_jump) xmap &lt;C-k&gt; &lt;Plug&gt;(neosnippet_expand_target) let g:neosnippet#snippets_directory='~/.vim/snippets' let g:neosnippet#disable_runtime_snippets = { "_": 1, } Just put a file called `go.vim` in `~/.vim/snippets` and you can put whatever you want in there. I've added a ton of additional snippets of my own to this file for some of the more repetitive boilerplate I type regularly, like this one for generating table-driven test cases that I use all the time (struct fields go at `${2}`, struct instances at `${3}`): snippet ttbc abbr func TestXYZ(t *testing.T) { ... } func Test${1}(t *testing.T) { for idx, tc := range []struct { ${2} } { ${3} } { t.Run(fmt.Sprintf("%d${4}", idx${5}), func(t *testing.T) { ${0} }) } } If you type `ttbc&lt;CTRL-K&gt;` in insert mode then fill out the placeholders (skipping through with `&lt;CTRL-K&gt;`), the result should look something like this: func TestHasPrefix(t *testing.T) { for idx, tc := range []struct { str string pre string has bool }{ {"food", "foo", true}, {"food", "boo", false}, } { t.Run(fmt.Sprintf("%d/%s/%s", idx, tc.str, tc.pre), func(t *testing.T) { if strings.HasPrefix(tc.str, tc.pre) != tc.has { t.Fatal() } }) } } `:GoImpl` is awesome for generating stub methods for an interface, I use that regularly as well. I'd prefer a mode that returns nils or zero values over the panic, and it also doesn't work perfectly if you want to implement an interface from the package you're currently editing, but it's easy enough to find and replace in that scenario and it's still a _huge_ labour saver for more complex interfaces. For example, `:GoImpl f *Foo io.Writer` will generate this (though I typically use a snippet for io.Writer or io.Reader): func (f *Foo) Write(p []byte) (n int, err error) { panic("not implemented") } I also configure `goimports` to run on save instead of `gofmt`, like so: `let g:go_fmt_command = "goimports"`. I love that I can write absolute garbage formatted code, forget imports left and right, hit save, and everything just magics into place. It always seems to default to `html/template` for me though, when I almost always want `text/template`, but having to remember that is a small price to pay for all the other things I don't have to remember. It's slightly risky to blithely accept its results, of course, but it's so rarely wrong that I've been happy with the compromise in exchange for the convenience. When I have to work with other languages that don't have tooling that's this good, sometimes I have to spend a few minutes adjusting to the fact that this stuff isn't done for me any more... by blinking confusedly at the horror I've just created and wondering why it isn't fixing itself! I use [ale](https://github.com/w0rp/ale) for error checking as well, which is not a part of `vim-go` but it's a great complement to it. Out of the box, it doesn't show syntax errors on save, only lint errors, so I configure it this way: let g:ale_linters = { \ 'go': ['go build', 'gofmt'], \} I hit save and get all the errors in the gutter almost straight away (thank you, fast Go build times!), then use `:lfir`, `:lne` etc to skip through the error location list. I also use `:GoDecls` and `:GoDeclsDir` in conjunction with `fzf.vim` (`let g:go_decls_mode = 'fzf'`), which list the declarations in the current file and current dir respectively, though I use these a lot less frequently than the stuff mentioned above. Very useful though, and handy to have in the muscle memory. Now that I'm through most of the stuff I love, I will indulge in a bit of a whinge: autocomplete is a bit of a disaster at the moment. This isn't necessarily vim-go's fault, but it is a critical part of the integration surface that it packages so it's not _not_ vim-go's fault either. I think it's just an unfortunate consequence of relying on the community for essential tooling (which golsp, mentioned later, is attempting to deal with). Basically everything got smashed when Go Modules came along. https://github.com/nsf/gocode/ was abandoned and the forks couldn't keep up with modules for months. There are a lot of people still having problems, but a lot of others fall into that classic "well it works fine for me so there isn't a problem" trap when responding to issues, which can be very frustrating when you're googling for a solution because this thing you've trained your brain to expect will "Just Work(TM) within 200ms" has broken for the third time this week for no obvious reason. There are versions that purport to work but the completion time is so bad as to be almost useless. I think all told I've unsuccessfully tried at least 10 different forks of `gocode` provided by random internet strangers in the last 6 months, which is utterly horrendous from an operational security point of view, but desperate times call for desperate measures! vim-go ships two different versions, one for modules-based projects and one for GOPATH, but both will randomly stop working for my projects from one day to the next. Purging my whole GOPATH has helped a couple of times (even for the projects using modules), but that's neither practical nor reasonable to do on a regular basis and in Australia at least as `:GoInstallBinaries` can take up to 3 hours to run from scratch. It took nearly 6 yesterday, with download performance identical on different networks. This kind of stuff has been going on pretty much constantly since 1.11, and shows no signs of abating. I have something working right now, albeit sluggishly, but it's a flimsy detente, and it's easy to feel like it won't survive. golsp doesn't fare any better, which is not surprising as they pretty much outright warn you not to use it until they actually announce it's fit for human consumption, but still, I had to try something! In its current state, it's most assuredly not fit for human consumption. It uses an astonishing amount of memory, we're talking like Electron-level memory, waaaaaaay more than gocode ever used, so if I have a even just a couple of vim-go projects open at once I'll clock about 8GB of ram used up by the golsp processes. My poor little laptop only has 8GB! And also, like the gocode and gocode-gomod forks, it frequently stops working, locks up, uses crazy amounts of CPU, the fans spool up, the keyboard starts to radiate serious heat, then I have to kill golsp and start vim again. Every 20 minutes or so. At least the Go team have acknowledged this is a gap in the tooling that would be better solved as part of the distribution (a forward-thinking and commendable acknowledgement, for sure!), however given the huge issues and shortcomings golsp currently suffers from, it's hard to see it being much good for at least a year, maybe two, and then Go 2.0 will land at some point in the future and we'll have to do the whole "all the tools are broken" dance all over again.
Focus on the last part of that error; \`\`exec: "bzr": executable filenot found in $PATH\`\`. bzr is the executable for the "bazaar" version control system. If you run Ubuntu, try \`\`sudo apt install bzr\`\`, then see if this works for you.
I think this is the kind of rationalization that one comes to when they're exhausted from being disappointed and have made peace with their workarounds. People who work with technology are great at it! Ask anyone who's still using TextMate for coding or Windows 7 users who refuse to upgrade. I agree with plenty of what he says here but let's not kid ourselves: Go is very pleasant for what it is but it could and should and will be a lot better in time.
I have similar experience with .NET and I'm quite confident in my Go skills but I would do it in .Net and only after it's almost done I would try to do it "better" in Go for learning/demo purposes. I wouldn't try to implement in Go from the start for political reasons mostly, because if there are any hiccups, delays or possible changes of specs in the project (and you suddenly need to do something that is not easy in Go - due to missing libraries or unknown bugs), the management will be suspicious and will tend to blame it on you picking a "new tech" (and "unproven" in their opinion). Also the maintainer of this code needs some level of experience with Go and the company might not have anyone apart from you and this can make picking Go for the back-end look like a bad idea.
Well, don't do that? Using sed to preprocess your source code is a terrible idea.
The GIL prevents actual concurrency. 
Yes I am the sole developer. I will maintain at least for the next 1 - 2 years the code base but I hope the product will succeed and in the future I will need additional developers to maintain it. For v1.0 I expect to have a full product by end of 3rd quarter. I still have to maintain the old project I was working on till I can do knowledge transfer to another developer. The ERP run's on Windows but the Web App is hosted and I'm using Linux, PostgreSQL with GraphQL instead of Rest API. I work from home so I don't have a talent pool limitation, I can hire anyone from anywhere in the world with the right talents. From what's I've ready Go has most of my needs out of the box so I would not have to use 3rd party libraries / framework. 
I started to pickup c and it really really feels like go. I have a real appreciation now though for := and open Interfaces. Like in c there are no strings and you have to initialize a var before you cast something into it. But I think go was a great primer for c. 
Nah, they should add generics
Why?
https://lincolnloop.com/blog/concurrency-python-vs-go/
Why did you choose sqlite over something like bolt?
“Actual Concurrency” - there, you said it. 
This is a good post. When we find something that works for Go, we should put it in the language. Not before.
Can someone who is pro-go-needs-generics explain how genetics would be _necessary_ in Go? I get it that they would be a convenience, but I’ve never encountered a situation where generics was a deal-breaker. 
This comment isn't really helpful, without an explanation of this statement.
Go and Rust made me better java developer.
It's very fragile. Just use `interface{}`.
golangci-lint configures default line length limit 120 for lll
This is suboptimal, as interface{} involves unnecessary runtime overhead
If a major selling point of Go is it's simple, widely recognizable idioms, this approach sounds like something that would be a big deterrent for somebody thinking about jumping into the codebase.
Take that logic a little further, and who even needs static typing? Dynamic dispatch all the way?
Flatten out first using xslt or similar
What exactly is fragile about that? Seems like a bullet proof strategy to me.
Define "fragile". With a known set of types, the resulting code is far more type-safe and performant than throwing empty interfaces around.
I appreciate you comment, I guess if I accept your recommendation then I'll probably use Dart with Anger or Aqueduct back end framework since my front end is build on DartAngular and in the future I'll have the native app on Flutter. I really appreciate your input...
I agree totally. Having a consistent idiomatic way to solve a problem is great, but doing so by not having common expressive language constructs often means the idiomatic way is verbose and hacky. Go reminds me of early Objective C, the language has a certain primitive elegance that you grow to appreciate the more you use it, but often you still end up hamstrung. Objective C evolved and incrementally picked up modern language constructs, it didn’t harm the ecosystem, made code easier to read/reduced boilerplate. Go can do the same.
&gt;Premature Optimization Is the Root of All Evil If you really notice `interface{}` is the bottleneck, you can resort to code generation for this specific case. If you want to have highly optimized code (but a more complex language), Rust or C++ is probably a better fit for you.
I've not found a situation where "go func()" or channels were /necessary/ for good parallelization, and yet my Go programs have significantly better parallelization than my C, Perl, or Python ones. 
Static typing isn't like generics. Generics add a lot of complexity, while static typing doesn't.
Generally it's where you want a balance of code re-use with multiple types, type safety and (often, as with monomorphisation) the run-time perfomance of static dispatch as opposed to dynamic dispatch. Taken together these things are hard to achieve without generics.
I was a .NET developer for 15 years, and moved to open source. Python mostly, but I did a year of Go professionally and still really love it for my personal projects. If it's just you for now and you need to get something out the door, and your backend is a REST API, you wouldn't be bad off choosing Go. But, I'm guessing you're wrong about not needing 3rd party libraries though - for example, if you're using Postgres, there's nothing built in and you'll at least want to check out the PG libraries and make sure that they meet your needs. Fork them, because the lack of a good versioned package manager could come back to bite you.
While I agree with your languages recommendation, I don't see generics as a "premature optimization", but rather as a thoroughly thought improvement to the language.
Personally, I'm neutral on generics. I remember getting into corner cases in C# (covariance, contravariance), a lot of time spent on abstractions that I didn't really needed, how difficult it is sometimes to analyse such code without IDE. One think I like in Go is this ascetism, if you want to overabstract, you need to think twice and maybe come up with simpler and better solution.
As there is no Go2 nobody knows what will be there. LanguageChange means just that: This is a language change.
That picture is a party foul.
Does it have to be an absolute necessity to be added, or is it sufficient that it would be a major convenience in many cases? The mere fact that many great repositories are riddled with barely readable reflection or are forced to resort to code generation in 2019 should be good enough of a reason to seriously consider generics. There are plenty of concrete examples available now at https://github.com/golang/go/wiki/ExperienceReports#generics
`sed` works on strings of text and knows nothing about Go syntax. If you aren't careful your preprocessing instructions could generate syntactically invalid Go code, or code that compiles but behaves incorrectly because the textual substitution didn't have the intended effect. Look at the [potential pitfalls](https://stuff.mit.edu/afs/athena/project/rhel-doc/3/rhel-cpp-en-3/macro-pitfalls.html) in authoring C macros, for example – and even their preprocessor is a bit safer than sed since it works at the token level rather than just `s/find/repl/`ing your source code. 
I use a "types.go" precisely when it is not "the" type I have. If I have one type and half-a-dozen methods, they all go together. If I've got 25 types whose purpose is just for marshalling or messaging or something, and they have no non-trivial methods, I'll often isolate them into a file where they don't interfere with the actual logic.
I like it! Two questions: 1. why text/template, not html/template? 2. do you have plans/ideas for pagination, esp. on the main page (index.html)? I understand this would not be needed when the front page has just the titles of the entries, but I personally am interested in a somewhat different end result, so I'm curious if I could somehow use your project in my case eventually. 
Second this. So far all the generic proposals I’ve seen for Go have been (in my opinion) not a good match for the language. Too complex or unwieldy, too magical. We love Go for its stability and simplicity. Let’s not throw that to the wayside for language features non-Go developers think we need ASAP. Let’s keep iterating. Eventually we will land on the best path to take, but don’t implement until it’s actually a perfect fit. 
The GIL prevents parallelism, not concurrency.
 List&lt;int&gt; someInts; List&lt;string&gt; someStrings; Dictionary&lt;Foo, Bar&gt; someData; Still waiting for someone to explain to me exactly how this is complex.
Can't you use a variadic parameter? \`func mkSlice(a ...int)\`
Go has generics. They've simply been made available to the language creators and no one else. You can create maps, channels, and arrays of any type! This is what bothers me to no end. Someone obviously saw the benefit of deferring the definition of parts of a type. Other languages (perhaps other than Java) have demonstrated the very real benefit of empowering users to do the same. Asking whether they're "necessary" is dishonest. Can we function without them? Sure! I can also program without a chair and use only one monitor. Are generics necessary in Go? I dunno. Was it necessary to create a sort function _per array type_ in Go? Why is it not possible to write a function that works with any channel type? The fact that devs are admitting to using macros, preprocessors, code generators, etc. should be a major red flag.
1. The Markdown processor already produces nicely escaped characters for the main content. It's true however that other stuff won't be escaped (e.g. `{{ .Title }}` and whatnot), so I'll have to fix that. Thanks for the reminder, nearly forgot! 2. Good question! I'll look into it, will definitely be on the radar. I'll see if there's some super simple method that would encompass most use cases. Thanks!
Why in the world would you use the greater-than/less-than sign as a bracket? List(int) someInts List[int] someInts List{int} someInts All seem like normal syntax given the importance (and usage) of "&lt;" and "&gt;" in EVERY MAJOR LANGUAGE.
Those modules are stored in a Bazaar version control system. You'll need to install [http://bazaar.canonical.com](http://bazaar.canonical.com/en/) so the Go tool can get the code for the modules.
Data processing behind a childrens reading product sold to schools.
Fair enough, got my terminology mixed up. 
Thanks for sharing
Does it really teach concurrency or does it just provide libs for it? Because to me there's a pretty large difference because one is understanding concepts like linearizability and knowing how to implement concurrent algorithms vs knowing how to use the language's libs and using design patterns to achieve concurrency. 
While that's fair, I think the chance of getting code that compiles but does the wrong thing is larger when using empty interfaces.
Same I'm stuck in php nightmare 
Speaking not of go specifically, but 'EVERY MAJOR LANGUAGE' in general: &gt;List(int) someInts Looks like a function call &gt;List[int] someInts Looks like an indexing of `List` &gt;List{int} someInts Looks like you're creating an object/struct containing an int. &gt;List&lt;int&gt; Arguably looks like you're comparing a `List` to an int, but most code styles discourage not spacing binary operators, and the final `&gt;` helps disambiguate. It's not perfect, but there's plenty of reason to no like the other suggestions either. 
What about `Thing&lt;OtherThing implementing Stuff, YetOtherThing&lt;Thingie implementing This or That&gt;&gt;`? When I read Rust or C++ docs, I always stumble upon those kind of things.
Not exactly sure what you think you're probably no what you actually don't understand. The example you gave tries to work around an upload-size-limit issue from what I read at quick glance. The snippet I posted does not limit the size of the file being uploaded so, unless you're using something like a FAT32 filesystem where you can't create files larger than 4GiB, you can upload something that will fill up your disk without ever running out of memory. If you remove the 'defer tempfile.Close()' line, it'll leave the tempfile exactly where it said it had put it :) 
Except D (but I'm not sure it is considered a major language though...)
Sure, brackets are already used, but I think you missed my point. The greater-than/less-than mathematical symbol is being used _as a bracket_.
Ok, but those are just long names. The underlying concept remains very simple.
So the "generics bring too much complexity" argument actually is just about the syntax?
I am all for debates about generics, and have happily advocated for both sides in whiteboard battles on the subject, but your response (which is not uncommon, unfortunately) only serves to diminish the author's point by casting aspersions on his ability to participate in the discussion because of some perceived flaw, perhaps of constitution or fortitude. I think the author addressed your concern directly: he has come to this conclusion as he has come to appreciate simplicity and elegance over time (I would call this "readability" and "maintainability" in my book), so the best way to argue against this point is to explain how more experience with Go has led you in a different direction, or how you think simplicity and elegance is better expressed with Generics, not with ad-homimem argument.
Has someone thought about how their current big programs could benefit from the contracts design as proposed? I know there are posts for and against it but what I'm interested in is someone having tried to convert a part of an existing project to use contracts and see how much of an improvement that would bring. The kind of projects I personally would like to see is data access and modeling layers or ORMs like Linq, and UI code for a big application with something like GopherJS or one of the bindings for GTK/QT. 
I think you mistook a discussion about syntax, for one about language features.
Thank you. 
[removed]
Generics are not needed. I find repeating code for each type quite idiomatic and you get used to it. This way everyone on my team can read the code and they don't need to look for more information about T, U or whatever will be defined. I truly enjoy that experience... if I needed it there is always interface{}
&gt; forces you to be object oriented Really that might be the biggest detriment of those languages imo. Go doesn't attempt to force triangle shaped problems into square shaped object models, it discourages needless abstractions and strikes a really nice balance between object oriented and procedural.
Which brings us back to generics
[removed]
&gt; What about `Thing&lt;OtherThing implementing Stuff, YetOtherThing&lt;Thingie implementing This or That&gt;&gt;`? But Go already this, just in a somewhat more roundabout way and without the angle brackets. The `implementing` thing is the same thing as Go interfaces embedding each other. &gt; When I read Rust or C++ docs, I always stumble upon those kind of things. And the problem is? 
I've used [GPP](https://logological.org/gpp) to give it C-style macros. Just for one project though.
My point is that it's very easy to build very complicated types that are very hard to read and understand.
Yet you can't nest them in Go, which makes it a lot more readable.
Well, yeah, but then I have to go read the interface defnition and then check the embedded interfaces as well if I don't know them... So in the end, no, I wouldn't say it's more readable. Just different. 
Loved the ending 
The problems come when you need to provide functionality that works on types that aren't known yet, or for which there are a cross product of different types. I do use reflection for these cases today, and it certainly works, but it makes the APIs harder to use and understand because the compiler can't help you and they rely on runtime errors and the author of the API predicting the ways it'll be misused so the errors are helpful. On top of all of that, runtime reflection and even in many cases interfaces can lead to allocations that could be avoided given something more akin to templates than to interfaces. This isn't often a problem, but when it is it can make the code really ugly to handle. I'm still not sold on any of the generic implementations, and I'm not sure if there is one that I would like, or if I think it would lead the ecosystem in a good direction, but I definitely see how they could improve a small set of really hard problems I've faced.
Honestly, I think it's because most go shops tend to be heavily run by actual software engineers; my workplace hires junior people but has a really high bar, and pays more in line with senior engineering expectations. Junior programming listings I feel like are usually companies trying to implement business logic and they prefer junior to senior since they're cheaper (up front)
And can mask bugs until runtime.
Formatted for reddit: ├── app.go ├── cmd │ └── app │ └── main.go ├── http └── strorage 
If you like Go, you should try Kotlin as well - it's comparable in terms of syntax simplicity, and it's a JVM language, so you can often convince Java shops to jump ship as it can coexist with Java and deploys easily to existing JVM setups. That being said, don't let what's written in a job description deter you; DHH (creator of Rails) famously mentioned in a talk that he finally qualified for the Rails job at the NYC Library, which required 8 (or something) years of Rails experience (Rails wasn't that old yet). A lot of people just want good developers - you can show how good you are with side projects and open source contributions. For example, if you build me a command line client for SoundCloud, in golang, I'd be mighty happy and impressed. Make it using termui or some other fun libraries and I'm sure companies will give you serious consideration.
I have very few use-cases for generics in Go, but the moment you need a complex data structure and have to fall back to interface{} to be able to reuse a well tested implementation of them, you have a problem that's made more infuriating by the fact that the language authors made an end-run around that exact issue with slice and map.
Go (and pretty much every programming language) have plenty of things that aren't strictly necessary but are hugely convenient. Functions, structs, modules, access control, etc -- you don't strictly need these things to write a program, but it makes your life a lot easier when you have them. Generics are maybe just a bit higher up the list in terms of the 'hierarchy of needs' in a programming language. 
Have you ever used a linked list from stdlib? Then you know the answer.
I can't tell if this post is satire or not.
Have you thought about applying for a Go position undercover? I have applied for .NET/JavaScript/PHP positions, and then gone on to launch products in Go. Same for a friend that moved a Node.js stack to Elixir. Some companies don't know they need Go because no one there has told them about it yet. This doesn't work in all situations, but better tooling often finds it's place from inside the company. 
I'm against generics in go because I think they solve two different orthogonal concerns that should be separate. For the first, If the go compiler was able to do some compile-time interface inference to unbox (inline) values, then there is really no reason to add generics to go at all since you could get the runtime performance and the type safety. (maybe you'd need to compiler hints to actually do this). With that out of the way, the only remaining argument is stutter caused by multiple method calls with argument boxing. This stutter is an orthogonal concern that could be handled by some other language construct (something like visual basic's with statement or a block level aliases). 
In the same way C++ doesn't teach object oriented programming. Language provide features, nothing more. What you will learn is from the research you do on how to use these features.
This article has been written in May 2015, whereas Python 3.5 (the version that asyncio got promoted to the standard library) was released in September 2015. So this benchmark is based off of a suboptimal version regarding concurrency and asynchronous programming. If you’re into benchmarks, read this https://magic.io/blog/uvloop-blazing-fast-python-networking/ or this https://blog.signifai.io/not-your-fathers-python-amazing-powerful-frameworks/
I mean, does List&lt;int&gt; look ambiguous at all to you? That's what's important. As long as what the signs are actually used for outside programming doesn't make reading difficult, it doesn't matter.
You could buy the Goland IDE from JetBrains and use that.
You could try [goup](https://github.com/lpar/goup), it doesn't create separate Go installs for each version, it just downloads and installs the latest one.
I can give a really explicit deal-breaking example: Rx. People are now starting to experiment with driving UI applications from Go, and not just servers. It brings a new challenge of handling values that change over time in fairly complex ways. Rx is one paradigm for managing that. It's available in most major languages, and widely used in industry. Rx absolutely cannot be done in a sane way without generics. I will praise you to the heavens if you can show me a package that does it without massively sacrificing typesafety, performance, usability, the Rx spec or - more often - *all* of those. More abstractly, then, it would be "building-block style libraries which don't know anything about your data types, but just shuttle them around in a complex way." 
blindly defending arbitrary language design decisions that everyone else disagrees with
I agree on "read", not on "understand". Sorry, but even if the names are long the structure remains simple.
No, the syntax being clunky is just a consequence of the larger issue, which is that the internal complexity of the language balloons to insane degrees when you try to account for generic data. 
Well, I asked about complexity and you only replied about syntax, so...
I am not a pro-generics developer but the typical use cases are generic containers/collections (especially ones that can accept both pointer and value type parameters) and generic math. The important point here is that parameter types should not be boxed because that slows down things, interferes with locality (cache hits), and makes optimization hard. I'd say these are the important use cases. Everything else can use interfaces efficiently.
Check for testing.T.Failed() in a deferred.
For a subset of problems C# can definitely be useful. Can you, using *just* the C# syntax, write the following function: T&lt;T&gt; Add (T one, T two) { return a + b; } You’d have to have something like T &lt;T where T:SimpleOrdinal&gt; Add.... You can totally write that function in C++ for example, but don’t tell me C++ isn’t complex...
While you have generic data structures with slices, maps, etc, you don't get the benefit of functions with type parameters. That's arguably the best part about the generics proposal in my eyes. Also more advanced data structures such as heaps and trees, I'd like mine to be type-safe rather than using `interface{}`. Otherwise I don't really see much use for generic types. But functions with type parameters are extremely useful in my eyes.
I've been going with a pretty basic approach. It's usually a mix of source files at the root and "cmd/" for the various main executables, if any. And I don't go crazy with splitting lots of packages. Especially not up front like some kind of skeleton project I have seen people advertise. 
The backslash is a special character.
should I use a string literal? 
&gt; I get it that they would be a convenience, but I’ve never encountered a situation where generics was a deal-breaker. You can apply this argument to every programming language feature ever implemented.
you're either going to have to use double slashes "C:\\\\Users\\\\USER\\\\Downloads" or use the lesser known "C:/Users/USER/Downloads" .
&gt; The constraints imposed by the lack of generics (and other things Go lacks) breed creativity Except when you hit a wall of Go's ability for generic solution and have to invent half broken solutions just to solve a problem with what you've got. I'm all for simplicity of Go but it does need something for writing type-safe generic code. We don't even need full fledged generics with all the possibilities from the likes of Rust and C#. Just something because Go is not very creative. It's intentionally not so. &amp;#x200B; Recently I was discussing on Github how current plan for Go 2 error values is inherently unsafe and requires go vet to properly inform developers that they're doing something wrong. Proposed API has no way of being implemented both in generic and type-safe way. Current proposal actually trades safety for generality and will have a danger of producing runtime bugs and panics due to programmers mistakes. And to make up for that we need another go vet rule that somewhat helps. I don't know but for me that screams of bad API design. Or, if we're being honest, lack of language features to implement proper API design. Because current API is probably as best as it can be with Go today. &amp;#x200B; And after seeing a couple of cases like that I'm no longer opposed against generics that much. Yes, they will bring complexity, we have to be very careful and think it through. Yes, maybe we better not implement anything if no proposed solution looks good enough. But Go still needs generics and will be better for it. Not because "language A" has them but because Go have problems of its own that do require generics at this point.
Should strive to make it portable and use the filepath package. Otherwise, backslash has a special meaning. 
this. this is the right way.
[removed]
[removed]
I haven't looked into it yet, but my team is having trouble to run the test consistantly of the package. Random slowness and deadline exceeded and things like such.
No, you should use filepath, as it's been said above.
Yeah, but still I have no real/production development experience (I do not count scripts and stuff) so they are really not willing to even start talking. Thanks for soundcloud client idea, I should do some research. :) &amp;#x200B;
Unfortunately so far I only know Groovy (Jenkins), used to work with Java and now I work in "python" software house, we have only one fun project written in Elixir and some Ruby/Rails frankensteins. I'll probably think about FOSS project and start building my portfolio. 
For transporting take a look on yamux (https://github.com/hashicorp/yamux). Regarding the audio capturing, i'm afraid you'll have to do C bindings to some native API, since that's platform depending. 
Generics encourage people to unnecessarily abstract their code, resulting in hard-to-undertsand names and a lot of complicated constraints on nested types.
Concurrency is not parallelism. Go routines and channels were created for concurrency not parallelism.
&gt; Perhaps we can infer from this that many of the people who are pining after generics in Go are not, in fact, Go users. No.
[removed]
Type declaration in the standard library are between functions and it doesn't really hurt the readability. You can still use an IDE with CTRL + click etc. or search to navigate from one unit of code to another.
Okay, I'll check those out.
Not really, it's what `go generate` is for.
I agree with the post. I think the problem about generics is not how to solve it, but rather, what is the question really. &amp;#x200B; Don't get me wrong. Yes, we need generics, and there are obvious problems that requires it, like containers, like channel handling code, and algorithms. But no, we are still unclear of what the real question is. All these problems reveals a very small fragment of the real question, which should solve all these problems in a bigger and more unified picture. It is like treating illness, while you can get rid of symptoms with some fast hack, you need to get to the root problem sooner or later. &amp;#x200B; And when it comes to Go and generics, I think the current situation is more than toleratable, while having a half-baked generics is not. That said, I am all for a right solution for generics.
I completely forgot about `go generate` which was literally created to address this issue.
They were created for concurrency to be able to exploit parallelism of modern CPUs. I get that you watched Rob Pike's talk about this topic but you should probably rethink what he said.
Like 99% of Go users that say _generics are unnecessary because..._ and then proceed with something that solves the problem that generics solve but is strictly worse an all accounts except for those guys who would have to implement the necessary compiler features.
From Go? Why is that? 
Disagree. Go's lack of generics isn't a disappointment. I was *attracted* to Go because of how concise and "spartan" it is. I frankly do not want generics, and disagree that the author's stance is due to any sort of cognitive dissonance-induced excuse-making. It's actually kind of offensive that you'd say that, because you're basically blanket-saying that everyone who disagrees with you is in the same camp of being "exhausted from disappointment."
Underrated comment. Agree entirely.
Not many places hiring for Go devs yet, but on the flip side there aren’t many Go engineers out there either. Often times if you have previous experience in a language and express and interest in Go, you will at least get your foot in the door. We have definitely put out job specs that say “previous experience in Ruby or Java, and an interest in writing Go” — just apply and see!
Building out a portfolio is very helpful. If you can show/build something someone else wants, they will hire you. 
You cannot.
[removed]
Structs and creating your own datatypes I guess, I never really used them before in any other languages, I just threw variables inside a class.
s/linked list/tree I'm not disagreeing with the point you are trying to make, but you happened to pick a very bad example. On modern computers, array based lists (like slices) will almost always outperform linked lists - even in the cases linked lists have better algorithmic complexity. https://dzone.com/articles/performance-of-array-vs-linked-list-on-modern-comp
Have you ever used a **tree** from stdlib? Then you know the answer. ^^This ^^was ^^posted ^^by ^^a ^^bot. ^^[Source](https://github.com/anirbanmu/substitute-bot)
Wasn't Objective C more or less replaced by Swift? At least where I work iOS developers have moved on to Swift.
Entry level positions sometimes pop up from us. &amp;#x200B; I'm not sure I'd consider this one "entry" level necessarily (due to the particular needs of this project) but it does show we are hiring Go developers :) &amp;#x200B; [https://1password.com/jobs/scim-bridge-gatekeeper/](https://1password.com/jobs/scim-bridge-gatekeeper/) &amp;#x200B; Keep an eye on the jobs page: [https://1password.com/jobs/](https://1password.com/jobs/)
Not all logging is just errors, so there's that to start with. So let's have a think about your example - it's great if you can log an error with that much information, but usually you would have to pass errors up the chain and wrap them to get something like that. I say that because at the point of origination for the error, you might know you're fetching a user, and that no rows were returned from postgres, but you may not be passing down context that it's happening during a GET request for /api/user. Especially where you're decoupling your DB access from your HTTP handlers, it's a challenge to get that logging with a better understanding of Logrus and other similar packages allow you to turn that around a bit: At the top level in your http handler, you can add fields for "method":"GET" and "endpoint":"/api/user" then pass that logging context down. Now every log you generate under that logging context will be marked up with those things, and you don't have to remember to log them specifically in each log.Printf. Then, in your centralized logging stack, you can look for any logs on a particular endpoint using a very standardized query for endpoint="/api/user" (o equivalent) and see what's going on.
Yep, although Swift is pretty much mandatory for modern native iOS development. Swift is also a significantly more complex language than Objective C. It’s funny, I find it easier to solve problems in Swift but harder to maintain legacy codebases than Objective C. I think a big part of the difference is the Swift language changes so rapidly, with significant breaking changes, whereas old Objective C still compiles unchanged because it evolved in small carefully though out increments.
Obviously they should each adhere to an interface. Then, I would make the master package have effectively just the interface and a registry. Inside each sub package, have the one for each provider. Inside the unit of each service specific package, have it register into the master package, the same way image/png image/jpg does. Then the user can import the ones they want to support. And you can have a master factory that does something like NewCloudProvider(“aws”) that uses the registered loader, or they can call the sub packages directly. 
The language designers gathered around a round table and discussed this inference as well, and generally agree that most of the complaints of Go generics do not come from Go users. So regardless if it is "empirically false", (that is a difficult, if not impossible statement to empirically prove or disprove) it is "mostly true" by method of inference. Obviously the /r/golang subreddit discussing generics in Go will self-select for the \_very small minority\_ of go users who clamor for generics, but again, the statement "many of the people who are pining after generics in Go are not, in fact, Go users." rings more true to me than false.
You need to use the \`blackfriday.HTML\_NOFOLLOW\_LINKS\` flag.
Look how ugly this signature is because there's no generics: [https://github.com/markus-wa/godispatch/blob/master/dispatch.go#L188](https://github.com/markus-wa/godispatch/blob/master/dispatch.go#L188)
Honestly I don't see how everyone always has to repeat the same stuff over and over again. &amp;#x200B; The argument has been made for both sides. If something pro/anti-generic gets posted some people feel (rightfully or not) obligated to at least put in some resistance in the form of such a comment so it doesn't look like it's a one-sided show - which it isn't. &amp;#x200B; I really doubt there's new things to be said.
That’s fairly hand wavy and I’d argue the dismissive attitude towards “non users” is a problem because 1) they are potential users put off by an immature type system and 2) assumption that No True Go User wants it is quite the echo chamber effect.
I started a project recently that had some similar requirements. I came across [this repo](https://github.com/elastic/apm-agent-go/tree/master/module) as an example. It works pretty well. Make an interface in the parent project, that all implementations adhere to. All of your various implementations can be in other packages in the same repo, with the dependencies required for that specific implementation. That way if you only need AWS you aren't pulling in the GCP client and vice versa.
Well, maybe they *would* become Go users if some kind of generics (or something that solves the same problems) was added. Also, count me in to the crowd of full-time Go programmers who would *love* to see generics added to the language.
Good question! I actually did use bolt at one point before switching to SQLite. My main reason for switching was maintainability. I wanted to be able to have some schema that I could evolve (more) easily. For example adding users/permissions. If I used bolt all the data would be serialized as bytes and I’d have to be very careful adding new features as to not break backwards compatibility. Not that this couldn’t be done. It was just easier in my head to reason about it w a proper schema. Also when using bolt I had to create my own indexing for things like looking up which constraint a request would fall into
It's not hand wavy, or whatever. It's whatever the exact opposite of that. It's intentional. Personally, and I think it's the right approach, who gives a *shit* about potential user's opinion on a language and how it should change to suit them? How is that the correct approach? You use the language. Then once you have experienced it and understand it for what it is, explain why you think generics are needed. What if I said "I would potentially use Java if they eliminated generics?" Ridiculous right? It's just as ridiculous in this case as well. Potential users complaining about features of a programming language they don't use is the equivalent of armchair activism. Again, like the article states, I am personally glad we have a relatively conservative language team that doesn't cave to the whims and flyby desires of the sea of programmers because programmers in general are some of the most vocally, needy, outcrying bunch of the lot.
\&gt; Golang equivalence to SocketCluster This is the wrong question. Your application probably doesn't need something that general. You can easily write a distributed chat on top of any standard pub-sub as your backend, then use goroutines to pump your data from your backend back and forth to your clients. People have done this on every technology under the sun: Redis, RabbitMQ, 0MQ, nanomsg, etc \&gt; Battle hardened with an active user base. Yes, but.. I'll bet you anything that Go uses less resources per connection than Node. So you will get away with fewer boxes than if you were running node. (Source: [Digg cut their boxes](http://blog.digg.com/post/141552444676/making-the-switch-from-nodejs-to-golang) by 50%) Here is a nice tutorial giving you the step-by-step on handling 1M connections in Go. (Hint: It's not all about language, the OS requires a lot of tuning too.) [https://github.com/eranyanay/1m-go-websockets](https://github.com/eranyanay/1m-go-websockets) &amp;#x200B;
&gt; a thoroughly thought improvement That's too good for Golang.
&gt; My point is that it's very easy to build very complicated identifiers that are very hard to read and understand. FTFY
&gt; Yes, we need generics No, no, no. You don't!
Understanding how your code actually works
While I would really like to see generics in go I'm just not a fan of the new contract proposal. I always felt like interfaces were contracts conceptually. This would be confusing (to me at least).
For me concurrency and parallelism really started to click after learning go.
Check out the Gophers Slack, golangprojects.com and the monthly HN whoishiring thread. I see non-senior Go jobs posted there all the time and I’m also posting some myself recently. If it doesn’t say senior just apply even if you don’t fill all the requirements. Chances are that companies will still consider you if they think you have potential to grow and learn. Often these entry level jobs are not advertised as people who apply to mid-level positions but are actually juniors can be used to fill these up anyway.
I'm a senior SE. I don't think most places hire language-specific jobs, at least not in my experience (currently HFT, previously medical). If you are a software engineer, you have an arsenal of languages, and choose the best for the job. A junior level has a few languages, and a senior probably has 5+ they are competent in, plus a few expert level, and can pick up a new language with relative ease. You don't hire "hammer specialists" or "screwdriver rockstars" for construction, and software should be the same. I started learning Go last week for a server my group probably would have written in Java, but we had been curious about Go for a while, so I volunteered to put together a backbone of what we needed over the weekend. I started last Thursday going through tutorials, and tomorrow will be presenting what I put together. So, I think you might have it backwards: first get hired as a software engineer, and find the right places to introduce Go as you progress.
My strong side is CI/CD/CD, I could tune current one and learn software and the project on the fly! ;) Also yeah, I have written some more or less basic suff, I was using API in my small python tool (automating tumblr stuff) and I work in software house so I know how stuff is done. Thanks for advice!
I read HN daily, best thing to start day with (with coffee of course!), also I'm lurking in Gophers slack, already found there a shitton of useful informations and links.
That's right, but unfortunately my brain is forcing me to look only for my beloved Golang. I should try to get my 10% into one of our projects so I might get in touch with real, production-ready software development cycle from real dev perspective. Thanks for advice. 
We’re hiring a Go developer in central London - https://blog.popsa.com/platform-engineer/
Have a function that converts each filename to a canonical version which will guarantee that no duplicates will be moved and move each file in your directory to a different folder with the canonical name.
&gt; I am using sed to preprocess my Go code This is Canadian Aboriginal Syllabics level of stupid. 
There's a parallel for Go: the American federal government. When Go was created, only features that all three founders agreed upon were allowed into the language. A lot got left out. Stability was favored over featureset. The excesses of C++ left a poor taste on the founders' palate. The founders saw a stabler, slimmer, safer systems language. While Go's standard library was rich, the founders believed innovation belonged in libraries. When America was born, her founders reasoned that the country was so rich in natural resources and so barren of immediate competitors that its greatest future threats must come from within--populism. Her founders favored a stable government over an agile one. Innovations must prove themselves at the state level before being approved for national promulgation. Today, America still runs under the same Constitution and still trends more traditional/conservative than the rest of the Western world. Back to Go, there's a lot of debate over how to handle generics. On the one hand, there's wisdom in the "worse (now) is better" better. It's been shown empirically that lines of code correlates very strongly with number of bugs. Lack of generics and other Go's characteristics definitely result in more code. On the other, stability reduces churn and simplicity increases comprehension. I'm of the opinion that code close to the business logic should be stable and simple. The proposed implementations, while a step in the right direction, are still too controversial for my tastes to belong with Go's history of addition by consensus.
There are tools that do this for you already, fdupes, rmlint, etc. &amp;#x200B; But, for learning purposes, sure - what do you need to do to identify a duplicate? Well, first, names are a red herring - look at the file contents. The last thing you want to do is assume since I have test2.mid, I don't need test2(1).mid only to discover test2.mid was an incomplete download, or a trojan, etc. &amp;#x200B; So you need to get a list of files in a directory - path/filepath/Glob does this; you can also use Walk if you want to process entire sub-trees. Then for each file, you need to determine if this is the first time you've seen this file - this is generally done by hashing the file - SHA1 is often used for this. Store the hash - you can store it along with the filesize if you are worried about deliberately constructed hash collisions. If the hash is not in your store, or hash+filesize is not in your store, you copy/move the file. &amp;#x200B; There are a lot of corner cases to consider - for example, do you do this as you go, preferring the first file encountered? Or do you collect all the files that match this hash, and then use a heuristic to choose which one to preserve (e.g. always keep the shortest name, or prefer names without parentheses, or the oldest file, or prefer files shallow/deep in directory structures (if you are using directories for organization), etc, etc.). &amp;#x200B; You might (you mention MID files, this is commonly used on music files that have some form of tagging) canonicalize the names as you go - extracting tags or metadata from the files to determine an appropriate name. &amp;#x200B; A common feature of such software is hard-linking - where only one copy of the file is preserved, but ALL of the names and duplicate locations are preserved by making them hard-links to the original file. In Go, os/Link does this, in which case you would need to preserve the path to the first copy made to know where to point the subsequent links.) &amp;#x200B; Have fun!
Probably not the best place to ask but is the offer for onsite or remote? I couldn't see nothing in there about location.
I don't see how it being a GET call makes it not a call from a bot. HTTP Post and Get are just ways of interacting...
I do feel that generics/templates/whatever is just a language (usually Turing complete) inside another language used to generate new code. Lisp programmers must laugh a lot, because they can use the same language to do both. As Go supports code generation as a part of build system I can't see why `go-with-genericts` can't be transpiled to go v1 code as a part of build.
It is a call from a bot, just not using the official API. My statement was in regards to whether or not it's okay to make a GET request to a web site in an automated way. If it's not for a mutual benefit such as Google's web indexing, but is for a global benefit such as a web archive -- or even just a personal benefit such as applying machine learning in order to filter out content that you don't like is there something wrong with that? I don't personally think that it's okay to stop coders from tinkering if they aren't really harming anyone and I hope the laws match. I'm not really speaking in terms of the OP's situation. Just sort of throwing some thoughts out there. 
I think Fransesc Campoy did this on JustForFunc a few months ago. 
I would iterate over the slice of files and match each name against a regex that cecks if the name has the form of a duplicate
I was not referring to performance.
best advice I've gotten is you should apply to things even if you don't satisfy the requirements. most others ignore them too. I don't think anyone I've hired ever checked all the boxes
We have an office in Toronto, if you're nearby I believe you'd be welcome to work onsite at the office. It's otherwise a remote job, most of the company works remotely. 
Are you aware of the Go CDK? https://godoc.org/gocloud.dev/blob has backends for S3, GCS, and Azure.
Because \ is an escape character, you have to have: "c:\\Users\\USER\Downloads" or: `c:\Users\USER\Downloads`. When you're constructing paths from components, use filepath.Join() etc. (see https://www.programming-books.io/essential/go/88d65c3fc0c14a4e90bfa98ba3feb231-file-path-operations) 
Thought the same thing. Ed.. ward...
Dealing with highly concurrent code without some sort of strict immutability is a bigger concern to me than generics, if I had the option of immutability or generics for go right now I’d choose immutability. I also like the [untyped composite literals](https://github.com/golang/go/issues/12854) proposal. These things and better error handling will make Go much better while on the path to figuring out a better approach to generic code in Go. What I think (hope) will happen in the end is something groundbreaking in terms of simplicity that just fits Go perfectly, kind of like how type classes fit Haskell .
The problem is seldom the what, but rather the how.
Should the go language team spend it's finite resources into worrying about what *would* make someone a go programmer, or how to continue to advance the language? &amp;#x200B; It's perfectly fine to want generics, just not want it so bad you sacrifice what makes the language so good in the first place, which is the primary argument against them. Right now for 99.9% of your line of business coding, networked service-to-service coding and things of the sort, they really aren't necessary, in my experience of doing both for a long time using both generic-capable languages and languages without them. In fact, most of the time in the languages with generics, they were just sort of peppered in there "just cause that's the way it was done", despite it not even being the most efficient method (say, using a simple array of primitives or defined types) That's the fact about the "no-generics" group and the "no generics that would ruin the language group" that is always overlooked. Almost all of us came from languages that had them. Likewise we aren't clamoring to be able to write "proper" Object Oriented Go code, there is something to be said that more aren't pushing for generics so quickly, either. I think that comes from the realization that us programmers, in all our hubris and desires to over-engineer and "over DRY" everything, think we really need them a lot more than we do.
[removed]
It's only very recently been crowned with the status of "mature", even then I have problems convincing people that it's ready for the big time despite the fact we're using it for all our new code and many large companies have migrated their existing services to golang. It'll come around in time, though I suspect Java is going to be around for a long time in the Enterprise space.
Back, back to the one side mirror you go! 
Only works with Google hosted services, correct? Since it's effectively a load balancer / entry point IIUC.
These look great, but since I host my stuff on AWS via https://github.com/apex/up ... I don't think I can place these proxies before it.
&gt; All these problems reveals a very small fragment of the real question, How do you get this conclusion?
My advice is this: Find a problem space within your current company, and implement a solution in Go. A value added business application and/or service is the best way to bridge the gap, leverage your current skillset, and grow immensely. This is coming from someone who started in a data center, grew to be a sysadmin, then a network engineer, data engineer, and now a software engineer. The fact of the matter is - what sets me apart from others is how my skills all built on one another to come to this fully capable cloud engineer. You can too, if you fill your work with meaningful projects that gather attention and build value. Also, I’d never really recommend letting a programming language drive a solution... BUT... I do love Go, and it’s what you’re trying to learn. So do that. Bonus: Never be afraid to write a library that you may use at a later date for another project. Anything you build convenience, reliability, and security around should be reused when possible.
Use type embdeding https://travix.io/type-embedding-in-go-ba40dd4264df
Oh that’s interesting. Will look into it, thanks!
Would you please elaborate on how it prevent Go being used in those areas? Especially game dev. As for my conclusion: I consider them small fragment to the root problem because solving one or all of them does not prevent similar problem re-appears and unified simplicity seems belong to a greater context.
In game dev, we need lists/trees of all kinds of assets, different float precisions in math or physics engine libs. Yes, a good generic design shouldn't only solve these problem. Not only should it solve more problems, but also it shouldn't hurt the good readability of Go code.
Forgive me, but if not performance, than to what were you referring? 
High-end game dev nowadays does a lot of almost visual-type programming, with lots of things wired together in various ways. It's very similar to the sort of thing that some of us have wanted to do with channel libraries, only even more pervasive, with lots of little modules getting wired together all over the place. I qualify it as "high-end game dev" because of course you can still do older-school, more conventional development in Go right now with less issue.
I'd suggest looking for positions where the company uses Go, not necessarily the current opening, then aim to migrate.
I'm gonna take on this challenge. What would the client do exactly though? Would it be to download the music? Play music? Or something else?
We had a very similar need and I wrote https://github.com/KensoDev/micro-auth-proxy to solve it. It works beautiful for us.
Do you hire remote? I have some go code in production atm and tossed an app in.
My problem is that Go already has genetics, just for the language implementers and not developers (i.e. maps). The solutions for working around it in most libraries I read are to pass around interface{} pointers and then type checking. That’s not a better solution than generics.
That doesn't mean that preprocessors are bad as an idea, just that the C preprocessor is bad. If a preprocessor is useful (in whatever language) then by all means, add one. Just make it better than the C preprocessor, and remove the painful limitations. Go will have generics. It seems unlikely that generics as seen in other languages is the proper solution, or else we'd have that in Go already. Go will get a solution to the problems that generics solve, and that solution, I hope, is a Go-specific solution, and not another language's solution bolted onto Go.
That doesn't mean that preprocessors are bad as an idea, just that the C preprocessor is bad. If a preprocessor is useful (in whatever language) then by all means, add one. Just make it better than the C preprocessor, and remove the painful limitations. Go will have generics. It seems unlikely that generics as seen in other languages is the proper solution, or else we'd have that in Go already. Go will get a solution to the problems that generics solve, and that solution, I hope, is a Go-specific solution, and not another language's solution bolted onto Go.
It's a perfect storm: Startups rarely hire very junior devs in general - they are mostly looking for senior or at best advanced junior, at the same time statups are way more likely to be building their software using go. Large enterprise is more likely to hire juniors, but large enterprise is conservative and very likely doesn't have a single line of go running anywhere, nor interest to run it in the next couple years..
Assuming the files are all in the same folder here's an example: You can run it like this: `go run main.go --input-dir ./files --output-dir ./files-clean --ext mid` package main import ( "crypto/md5" "flag" "fmt" "io" "log" "os" "path/filepath" "strings" ) var ( inputDir string outputDir string extension string ) func main() { // set up flags flag.StringVar(&amp;inputDir, "input-dir", "", "The input directory") flag.StringVar(&amp;outputDir, "output-dir", "", "The output directory") flag.StringVar(&amp;extension, "ext", "mid", "The file extension") flag.Parse() // exit if missing flags if inputDir == "" || outputDir == "" { log.Fatal("Missing --input-dir or --output-dir flags") } // ensure extension doesn't have a . prefix if strings.HasPrefix(extension, ".") { extension = extension[1:] } // get all the file paths filepaths, err := filepath.Glob(fmt.Sprintf("%s/*.%s", inputDir, extension)) if err != nil { log.Fatal(err) } // check if new directory for non-duped files exists _, err = os.Stat(outputDir) if err != nil &amp;&amp; !os.IsNotExist(err) { log.Fatal(err) } // if not make the new directory for non-duped files if os.IsNotExist(err) { err = os.Mkdir(outputDir, 0755) if err != nil { log.Fatal(err) } } // map checksums to filepaths so it would be like this: // b026324c6904b2a9cb4b88d6d61c81d1 [files/3.mid files/test1(1).mid files/test1.mid] // 26ab0db90d72e28ad0ba1e22ee510510 [files/test2(1).mid files/test2.mid] checksums := make(map[string][]string) // loop over all files for _, path := range filepaths { // open the file file, err := os.Open(path) if err != nil { log.Fatal(err) } defer file.Close() // hash the file hash := md5.New() if _, err := io.Copy(hash, file); err != nil { log.Fatal(err) } // save the hash as the key and append file to value checksum := fmt.Sprintf("%x", hash.Sum(nil)) checksums[checksum] = append(checksums[checksum], path) } // loop over all the checksums aka unique files for _, v := range checksums { // find the last path this could be modified // depending on what file path you want to keep lastFile := v[len(v)-1] // open the file in, err := os.Open(lastFile) if err != nil { log.Fatal(err) } defer in.Close() // create the output file in the new directory // with the same filename as the original out, err := os.Create(fmt.Sprintf("%s/%s", outputDir, filepath.Base(lastFile))) if err != nil { log.Fatal(err) } defer out.Close() // copy the file from the original to the new _, err = io.Copy(out, in) if err != nil { log.Fatal(err) } } } 
Justforfunc looks great, did not know about! 
It is a driver ☺️ I don't think that sql parser can be written in 100 lines
He’s amazing. I found him a few months ago. Most people that talk about programming do academic talks. He gets down into the code and just does it. He’s really good. He’s also on Reddit too sometimes. 
Woah that’s nuts. It sounds like something is up but I don’t know. I’ve only just done my first 1.11 module init. What’s the resultant binary size? For curiosity sake. 
How many packages are you pulling down, via all your transitive deps? Modules should just pull the repo archive at the version you specified, so unless you have some pathological repos, that does seem strange.
41mb. Reasonable to me.
37 in the go.mod. It gets into k8s, probably for their service discovery.
Yea that’s not bad size wise. Peculiar why it would be so big tho. Without grabbing the go modules I presume it’s a lot smaller? I don’t have a lot to add, but I’ll be watching this as I’m building a bunch of stuff with multi stage builds for deployment on k8. 
Maybe , if you can, post your go.sum file? 
I am the voice of truth lol
I have just found go-bindings for [https://godoc.org/github.com/gordonklaus/portaudio](https://godoc.org/github.com/gordonklaus/portaudio). This seems really promising, it also has a demo for echoing, so input and output is possible.
The tests using Gorilla do not use the best possible configuration for the scenario: - Set [Upgrader.WriteBufferPool](https://godoc.org/github.com/gorilla/websocket#Upgrader.WriteBufferPool) to avoid retention of write buffers. - Set a reasonable read buffer size. The application uses a read buffer size of 4096, which is large for both the benchmark and typical application use. A size of 256 is more reasonable to use. That's 1/16 the size used in the example. Somebody filed an issue in the repo pointing this out, but the author deleted the issue. It was issue #3.
The best one. As with most things: There is not one single best way for all occasions....
Same here, mostly just PHP , Java and .Net jobs. It’s hard and risky for the industry to jump on a new language. Go lacks a community here in the Netherlands, so businesses are not comfortable jumping onboard. Also Go has kind of an identity crisis. Google really hasn’t done a good job of branding. I have trouble explaining to coworkers what Go is and where you would use it. It can do so much. For example making websites, but a competitor language might have much better packages/tooling because it more niche. Go can’t beat Laravel + Nginx + composer.
rsync
💯
The GIL prevents parallelism and concurrency, not asynchrony.
This would be super clever and funny if it were true. 🤷‍♂️
Hey. You can also check out here our positions https://sumup.com/careers/positions/?department=Engineering%20-%20IT%20Operations Go is easy enough to learn, I think, if you have an idea on how programming works in general. Most importantly if you have the mindset around CI/CD, deployment environments (Docker, Kubernetes, Jenkins), know your things around some infrastructure like AWS/Gcloud, TLS, DB connection pools, LoadBalancers, Tracing (Opencensus, Jaeger), Structured logging, Metrics (Prometheus, Grafana), you are always in a good position to dig into Golang. As I think having the knowledge of all these other tools/things will help you discover, which other tools your fellow colleagues are missing in their toolbox. And ideally those tools are written in Go, either as CLI tools or as other backend services.
&gt; The message suggests you are making several requests in a very short time. Does it?
The UK has a surprising amount, I interviewed for two positions in the last week that involved Golang. Many companies are moving to it, not seen many remote jobs for it though. A lot of newer smaller companies are using it at the moment
``` type MainType string func (m MainType) Method() string { return "method" } type ExtendedType struct { MainType } func (m ExtendedType) AnotherMethod() int { return 99 } ```
&gt; Check out the Gophers Slack I've seen the Slack channel mentioned recently here. How would I go about getting an invite? 
I would say play, and browse. Look up soundcloud2000 on GitHub; build that but it actually works (SoundCloud2000 used to but is no longer maintained).
First result of you google for Gopher Slack: https://invite.slack.golangbridge.org/
I assume that once this is done, its not usually needed again, right? Meaning, you CI/CD setup should point the go modules to a storage area outside of the container it spins up for the build, so that you arent throwing away all those downloads between builds? Or is it pretty typical to download all that to the container itself, and toss the whole thing after the build is done? I am asking more than telling because I am just learning about setting up my own CI/CD and using Golang as well. 
https://medium.com/capital-one-tech/closures-are-the-generics-for-go-cb32021fb5b5 I could resolve all my generics issues (translating some Python code to Go) with closure. It's not easy when you start with a legacy generic code but finally i found the result better. I mean easier to read and maintain. I'm afraid that with generic in Go i would not use closure and will not learn this better way of programming.
One feedback is that don't write APIs this way. Another feedback is don't use Iris. Also, probably best to not post blogspam.
Thanks for the confirmation. I saw that link, but didn't know if it was the correct one.
Reddit has every right to apply restrictions of access of their resources to prevent abuse. They have every right to apply rate limits to ensure that nobody's app's behaviour results in a negative impact to their product or users, and it's difficult to rate limit an anonymous source. Just because they are hosting their app on the internet does not mean they are under any obligation whatsoever to provide free and unrestricted access to it.
I'm amazed by how the author touts the beauty of the Grand Unified Theory and the importance of first principles, but then outright *rejects* the core idea behind System F, an evolution of the simply typed lambda calculus, discovered **twice** by Girard and Reynolds, **independently**. Parametric polymorphism is simply the idea that functions can range not only over values, but over types as well. It is naturally born from the [Hindley-Milner type system](https://youtu.be/fDTt_uo0F-g?t=2625). It gives rise to immensely useful tools for reasoning, like parametricity. &gt;In my opinion, generics are an imperfect solution to an unsolved problem in computer science. They are demonstrably not, and it demonstrably isn't. &gt;It’s not a language where liberal experimentation with imperfect ideas is desirable. So parametric polymorphism is "an imperfect idea", but runtime reflection and the "billion dollar mistake" are fine? If anything, it feels like Go is not ready for generics.
containers - the default golang docker image is a full install of Linux if I remember correctly. The alpine one is "only" 311 Mb. if you want containers, you eat the download. 
What i really like about Go is that it is not built on the same principle as the vast majority of other programming languages that they add new features on the long road, but the core base is well established ensuring total compatibility between different versions. &amp;#x200B; For this reason my opinion about generics is a little bit divided. 
I couldn't really make sense of your folder structure - the formatting is weird. test.go files can access entities declared in other test.go files in the same package, if that helps. So you can create a mock_test.go file and have any mocking stuff in there, and it'll be available from the others test files. I have to be really careful to make sure I'm testing my code and not the sql package. Too often I've ended up writing tests that will only fail if the database doesn't work as expected, when what I need to test is that my code is doing what it needs to. if you're mocking the sql layer to test the repository, then you probably need to mock the repository to test everything else. I use a simple pattern for testing things that depend on my own stuff: type actualThing interface{ DoIt(param string)string } type mockThing struct{ doItImplementation func(string)string } func(mt mockThing)DoIt(param string)string{ if mt.doItImplementation != nil { return mt.doItImplementation(param) } log.Println("TEST: default implementation of DoIt") log.Println("got parameter:", param) return "" } func TestThing(t *testing.T){ mock := mockThing{ doItImplementation:func(param string)string{ if param == "" { t.Fatal("missing parameter") } } } err := someFunctionUnderTestThatExpectsAnActualThing(mock) if err != nil { t.Fatal("bad thing happened:", err) } } I use this to replace calls to the database for data (so the test implementation returns a static struct with test data in it) and any other libraries that aren't under test. I don't need to replicate the behaviour of the other libraries, I just need to provide suitable test returns. Needless to say, dependency injection is your friend here. Being able to construct test fixtures with everything mocked except the thing you want to test is vital.
https://github.com/golang-standards/project-layout
AFAIK, there is no "outside of the container" for the user, at least not with typical hosted CI services. The CI server spins up a fresh VM for each run. You can't do anything outside that container for obvious security reasons.
Are you saying you follow this layout? Or are you just posting a search result? That's a pretty excessive "template" for starting a project. 
We do use it in production; we have many engineering teams, so good to have a "standard". That said you don't need to use every single folder, unless you need to. Most of ours just use cmd/ and internal/app and internal/pkg as it's mostly microservices.
Damn, seems you need someone a bit stronger in Go than myself. Sounds like a great gig though! 
[removed]
[removed]
Sorry but I don't like this blogpost. And I don't really care whether its pro-generics or anti-generics, the main problem with this blogpost is that it's just pure sentiment. Like this statement for example: &gt; Go strikes me as one of the most conservative programming languages available today. It’s small and simple, and every detail is carefully thought out. Yeah, no. Go is convervative in some ways but "punk" in others (like ditching libc). It's simple in some ways but complex in others. Some things are thought out well, some aren't. &gt; Nearly all of Go’s features are bulletproof, and in my opinion are among the best implementations of their concepts in our entire industry. ... sentiment ... &gt; Contrast this to C++, which has too many footguns to count. Why does every Go blogpost have to contrast with C++. Languages like TypeScript or Kotlin or C# or the like are usually just mentioned in the passing if at all and then it's back to comparing with C++ or some horribly overengineered Java code. Always picking the easy targets. &gt; Go modules took the idea of dependency management and rethought it from first principles, then landed on a much more elegant solution that I think other programming languages will spend the next few years catching up with. ... sentiment ... and some bad forecasting ... (I mean, have you seen `cargo`?) &gt; I feel that this applies to generics. (...) None of the proposals I’ve seen (notably contracts) feel right yet. Am I reading one of those tabloid women's magazine? &gt; I used to sneer at the Go maintainers alongside everyone else whenever they’d punt on generics. If memory serves right, Go authors actually were never anti-generics neither punted on them. It's always been just the community. (IIRC.) &gt; fig. 1: the result of C++'s attempt to solve all problems ... adding on to the sentiment with a picture of some horrible creature contrasting with - what a surprise - C++ again ... I mean, yeah, C++ templates (and some other features) are horrible. _We get it._ In fact, we've known since a decade before Go was written. The last paragraph sounds reasonable. Could do without the ones above it. 
You may find this useful for your folder structure: https://github.com/golang-standards/project-layout You want to avoid doing folder structures that you may be use too from other languages. For tests it's not idiomatic to have a seperate test folder, but it is to have a seperate test package; to explain check out this: https://medium.com/@matryer/5-simple-tips-and-tricks-for-writing-unit-tests-in-golang-619653f90742
&gt; So parametric polymorphism is "an imperfect idea", but runtime reflection and the "billion dollar mistake" are fine? This, so much.
||The constraints imposed by the lack of generics (and other things Go lacks) breed creativity &amp;#x200B; Really? Then why should we limit ourselves being creative? let's remove channels and and maps and slices and unleash a train of creativity from people trying to solve problems without these High-order build in GENERICS.
So I've been slowly working on a project to figure these sorts of things out. Mind trying https://github.com/loov/goda out. goda cut ./...:\!root goda list -f "{{SourceSize .}} {{.ID}}" ./...:\!root Of course command line arguments are still in flux. And any issues and/or things that need clarification are highly welcome.
you have to use something like \`[golang.org/x/net/html\`](https://golang.org/x/net/html`) to process the output of blackfriday and add the attributes you want.
&gt; parametric polymorphism It has been said before but I believe it's relevant here: "generics" is ill-defined! So while you read "parametric polymorphism", other people are thinking of Java's compiler-assisted copy-paste mechanism. Arguably all the posts and discussions up to this point have agreed that a Java or C++ generics approach is to be rejected. Nobody is rejecting parametric polymorphism. The question is how it would fit into the language.
Because it gets me to inventing some new wheels. &amp;#x200B;
I have another example: I am currently writing a program which cashes a lot of data in memory. I reached the point in which I am making sure that appending to slices doesn't increase the capacity above the length of the slice. This means that the builtin `append` is out of the question. I wrote a function called `cheapAppend` which appends an element to the slice but guess what: I have to write one for every type I want to support! In a normal beautiful world I would instead just write: cheapAppend(slice []T , elem T) []T { ... } I am sorry to say but people who say that generics are not needed are either trolling or are delusional. I just don't understand how someone can think that this is not a problem.
Did you try running `go mod tidy` to clean up any deps that aren't being used in your code?
Just look over mod.sum and vendor some stuff
Eh? From the proposal I read the other day the proposed generics are not very different from the implementations seen in other programming languages (other than syntax). That's not a criticism though because generics are an old idea with a lot of empirical data.
There are lots of proposals for generics. Lots and lots. Any one of them (or none of them) could be the chosen implementation.
Let's just assume it does. We keep our build agents around for a bit, but if they're idle too long, they go away. Definitely don't want to keep one around just to make the build go faster.
Yes, I'm using just the golang:1.11.5 as my source container which looks to be about 800 MB with a hello world app in it and no external dependencies, so I may have overstated my 1.8 GB, and it's simply 1 GB. Still seems larger than it ought to be.
That could be the case. I've only read the one found linked in the official repository. I suspect, however, that the other ones do not introduce new concepts to the PLT landscape not seen in other programming languages.
Yep - did a diff on the files after this morning again and sure enough, no change. Using some go mod why -m indicates that it is indeed the prometheus part of my project which requires these.
Try visualizing the cache dir using kdirstat or windirstat. A picture really is worth a thousand words, even more if it interactive. It will be easy to pinpoint what is taking so much space. Bonus points if you could reply with a screenshot and maybe your findings. GL
Not sure why you were downvoted. Seems plausible.
This is how I structure my projects: https://github.com/sagikazarmark/modern-go-application
Emphasis mine: &gt; Have you ever seen someone write something to the effect of “I would use Go, but I need generics”? Perhaps we can infer from this that many of the people who are pining after generics in Go are not, in fact, Go users. Many of them are users of another programming language that does have generics, and they feel that generics are a good fit for this language, and therefore a good fit for any language. The inertia of “what I’m used to” comes to a violent stop when they try to use Go. People affected by this frustration interpret it as a problem with Go, _that Go is missing some crucial feature_ - such as generics. But this _lack of features is itself a feature_, not a bug. &gt; The constraints imposed by the lack of generics (and other things Go lacks) breed creativity. It really seems like the author is rejecting the broader concept, not a specific implementation.
people get almost as touchy about Docker as they do about generics ;)
do you need all that functionality ? In your post you mentioned you pull a few things from Prometheus. Can the bits you need be extracted out into your own codebase so you don't need to pull in an entire dependency for maybe just a few functions?
As others have suggested, check your go.sum file. One thing I’ve noticed is that even running `go mod tidy` doesn’t properly clean it up and it leaves references to old attempts and versions. As a last resort, you could backup the file locally, delete it from the project folder and run `go mod download` to have it regenerated and compare the differences. Also make sure that `GO111MODULE=on` is being set on your box and in the CI pipeline during the build phase. 
&gt; To me, Go is object oriented Yea, that's why when `a` is array, you write a.len() to get it's length, and not call global function `len(a)` like in every other non OOP language.
**Update**: I'm working on moving the client code that you would integrate into your applications into a separate folder with a less restrictive license. Should be able to create a new release later today
Also, I wanted to be able to support multiple DB backends in the future like Postgres/Mysql for those interested in scaling to more than one instance of the server. Using the \`database/sql\` package allows me to do that easily.
Yeah probably not. Of the proposals that I've read, they are mostly "here is how my favorite language does it, so this is how Go should do it" said in very indirect ways.
Here's a sample project which should demonstrate the issue: &amp;#x200B; [https://github.com/disintegratedcircuit/gomodtest](https://github.com/disintegratedcircuit/gomodtest)
I'm looking at that or just shelling out to promtool. Didn't think this would be so problematic!
The core problem isn't the default golang container, but rather the \~1 GB in download cache required. If the issue becomes the default golang docker becomes the biggest issue that's a separate issue.
I might be reading your comment wrong but you should checkout doing [multi-stage](https://docs.docker.com/develop/develop-images/multistage-build/) builds for your docker images.
I am using multi-stage. The issue is at build time and downloading all the dependencies. Pulling the container at deploy time has not been an issue and the container is only 41 MB. It utilizes the common "FROM scratch" pattern.
Sorry, I didn't read your OP closely enough. As you said you could implement something like this [trick](https://container-solutions.com/faster-builds-in-docker-with-go-1-11/) to use docker to cache to module download, cache will only be busted when your go.mod or go.sum changes. Fresh agents would still still be a problem as you said, now I haven't tried this but [this guy](https://andrewlock.net/caching-docker-layers-on-serverless-build-hosts-with-multi-stage-builds---target,-and---cache-from/#using-cache-from-and-target-with-multi-stage-builds) has an interesting approach
No problem... I'm the one asking for help! I'm sure I'm doing something wrong, just not sure what it is and trying to learn. I'll check out your links - thanks!
I would recommend just using Caddy. It can even execute templates for you. But for database stuff you'll still need a handler for that, but you could even write that as a Caddy plugin! If you do still roll your own, though, use CertMagic for HTTPS: https://github.com/mholt/certmagic
I'm running in go 1.11.5, so I should not need the variable right? fwiw I did try copying out the go.mod and go.sum and no real change
&gt; Or should I simply use nginx, caddy or something else to manage the reverse proxy and run multiple instances of my executable? That's definitely the easiest way, and the most modular way too, since it'll e.g. allow people to easily run different versions of your executable under different domains.
Was there something in 1.11.5 that no longer requires the variable? I can't find anything saying that it's no longer required, I only just upgraded from 1.11.2 and I may have missed something. I am still using the variable.
It seems a very interesting and robust project to develop a personal backup storage like dropbox. Thanks for sharing.
Guess we'll learn at the same time then 😁
I tried to kinda build one. It's not great and the Len is wrong and I just kinda took pieces from the web, which means I don't totally know what I'm doing but you can kinda piece things together for a logger. Another thing I got wrong was the form values. Still not sure how to do that but I ran out of time this weekend. https://gitlab.com/zendrulat123/prettymiddleware/blob/master/server.go
Now that I have this I'm using it forever. Much cleaner and simpler.
OO is an approach to designing abstractions, not a particular language feature. Go certainly supports object oriented design patterns.
[removed]
Thank you. I should have added that I also wanted the ability to add hosts on the fly. However the concept adds a layer of complexity I don't want to deal with right now.
Caddy (and CertMagic) can do that too.
&gt; it does need something for writing type-safe generic code. To be fair, it does have *something*. `go_generics`, for example, even comes out of Google itself. The implementation is not very pretty, or convenient, and many reject it because of such flaws. Certainly we should strive for better, but it is not like it cannot be done right now. 
Hmm.. I would typically agree to this, but I would also assume if you instruct the CI what container to start up, and that container has in its Dockerfile to use say a storage location that resides outside the container, I dont see why it would not be possible? Still, I would rather understand why there is such a large download going on and how to correct it if possible in the container, vs hacking an external storage solution if that isnt ideal. Typically as I understand it the CI spins up a completely clean Env to build from. In the case of dependencies, it is likely one build to the next may need a different set, and having old ones in a shared location could alter the build in some unpredictable way. 
Go uses [NPN](https://tools.ietf.org/id/draft-agl-tls-nextprotoneg-03.html), an extension to the TLS `ClientHello` message. Search for TLSNextProto in: https://godoc.org/net/http Make sure your server doesn't announce `h2` if it doesn't intend to support it.
I can't specifically speak for the go client, but http2 compatibility should be determined when the TLS connection is established. [https://en.wikipedia.org/wiki/Application-Layer\_Protocol\_Negotiation](https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation) &amp;#x200B;
Based on the repo you posted, the main culprits are: * https://github.com/cockroachdb/cockroach - 563MB * https://code.googlesource.com/google-api-go-client - 137.5MB * https://github.com/influxdata/influxdb - 107.5MB * https://github.com/hashicorp/consul - 75.4MB * https://github.com/aws/aws-sdk-go - 74.9MB * https://github.com/Azure/azure-sdk-for-go - 45.8MB * https://go.googlesource.com/tools - 21.8MB * https://github.com/google/go-genproto - 12.6MB * https://go.googlesource.com/net - 12MB * https://go.googlesource.com/sys - 12MB Everything else is less than 10MB and adds up to 82MB
1.8 GB is a lot. Way a lot. For me it is 51 MB in fairly medium project. So 1.8 GB is WOW. 
Any suggestions on how to drop those dependencies? As you can see I'm not using cockroachdb, etc. 
This is one person's opinion but I'm quite annoyed at writing for-loops over and over and over. I'm like my God, am I back in Computer Science 101 class here? ....manually iterating thru these bare-bones collections.
Type embedding is the correct answer, but initialization between the two is now a bit different. https://play.golang.org/p/4eZMYS9SxPe ``` var mt MainType = "main" var et ExtendedType = "extend" // Doesn't work because it's a struct not a string type fmt.Println(mt, et) ``` It's a minor annoyance, but worth mentioning IMO.
That's not feedback, that's just non-constructive nitpicking. &amp;#x200B; Instead, you might provide some reasoning or a compelling argument that might educate or convince others as to why they should follow your suggestions instead of tearing down a good-faith attempt to share an experience.
And the reason cockroach is big, is because it has many copies of embedded resources committed.
Build stuff. It's ok if it doesn't become the next app/library de-jour, just automate stuff around you to make your own life easier.
So the problem is that prometheus has it listed them as a dependency. Hence they will be downloaded. However you might be able to make minimal versions of the things you actually need. So when you look at the import graphs of `rulefmt` and `config`, you see: https://gist.github.com/egonelbre/f91c59fcc4e7617ac1f3aba39c714a71. Based on that, I would try: 1. extract rulefmt from prometheus (`goda list ./pkg/rulefmt` to get the list of packages you need) and then use `replace` in your `go.mod` to use your own repo instead 2. reimplement things you need from `config` if possible, otherwise extract similarly to 1.
Perhaps this "standard" works great for you and the author, and that's fine. For a newbie coming in its massively overcomplicated, and most projects won't need half of what's in there. &amp;#x200B; I won't comment on what I think a "standard" layout should be, but I will point both you and the OP to someone else's idea of best practices that I've found to be much simpler and incredibly useful: &amp;#x200B; [https://peter.bourgon.org/go-best-practices-2016/#repository-structure](https://peter.bourgon.org/go-best-practices-2016/#repository-structure)
Go roles in my region are use for a very specific purpose: creating microservices and working with tooling around that task. E.g. Create an Admin service in Go that uses gRPC to communicate with the Users service (Ruby on Rails) and the web app (Angular + Spring Boot) and configure your new Go service to work with the CICD pipeline (Jenkins) to deploy to AWS. Our biggest client wants this done in 1 week. Frankly, shit like this is beyond an entry level skill set.
&lt;3 &lt;3 &lt;3 Wow this is so useful! I will be studying this intently. 
Pick a project. Tons of suggestions out there, and get to creating. Tutorials are not enough, and can sometimes be counter productive if you get trapped into a cycle of doing tutorial after tutorial. Get out there and create something!
Wow, this was pretty clear. If i were to ELI5 this. It sounds like the frame of thinking is to move files based on hashes and if files have the same hash then those are your duplicates and multiple files of the same hash can be consolidated by the program. I would even go on to say that this is probably best practice in general to work with files based on hashes. Is that correct? Thanks for your detailed response. Have my upvote!
&gt;Have a function that converts each filename to a canonical version Could you explain this to me? 
If you are working on the job it would be good to figure out what you can automate. In my opinion that's a good start. Also consider that you use a computer every day. What manual things can you create a script with? (e.g) I made a script that cleans out a temp directory every 7 days that holds media content. (my side business) a process I used to do manually. 
Nginx would be good. HAproxy as well. I guess it depends on what you need. I find IMO that HAproxy does a much better job load balancing requests between multiple instances. I ran a test once of like 10,000 requests using Jmeter and found that Nginx at least in my case likes to drop requests. If you are using Nginx for auth only. Then yeah it's fine. But if you're looking at creating a web service Load balancing is gonna be a crucial component.
I like this, I was thinking of my next language to learn and I've heard good things about Kotlin.
Correct me if I'm wrong But Golang is still gaining traction. It's one of the fastest growing programming languages in the world and it rose from like 25th to 8th place over the course of a single year. Personally I think learning a largely popular language is key to get your foot in the door and then try to push Golang if you can. In my area there are a ton of Python jobs and a ton of opportunity to evangelize the goodness of Golang.
oop but uses functional approach k got it
Most people complaining about go not having generics are just using it an excuse to not pay attention to go and stick with whatever they use. If go did have generics they’d just complain about something else. Like it says in the article: plenty languages with generics do exist. I notice that many of them make the unprovable assumption that the go language designers didn’t add generics because they are ignorant of basic comp.sci concepts and techniques like hindley milner, parametric polymorphism, type inference. It’s really silly to think this, just consider the careers the go team have, they’ve been working on production compilers for decades. If you know about this techniques and you haven’t even built a compiler and OS then why would you expect them to be so much more ignorant than yourself? A lot of the complaint about generics comes from people who program in dynamically typed languages too. Like python or javascript or ruby. These languages can produce exactly the same runtime errors if you put the wrong typed object in a list as if you put the wrong typed object in a golang list built using interface{}. It isn’t fair to give dynamically typed languages a free pass while also making it a mortal sin that golang doesn’t implement parametric polymorphism. It’s really unfortunate that detractors of go have picked on this one aspect of the language design and inflated into such a big flamewar like emacs vs vim. The go language has a lot to offer and is a serious improvement over some of the existing tools like PHP for web application design. This is being overlooked since people just want to rag on the language for not implementing a feature they need for their comfort zone. 
Yeah i guess it would broaden my understanding if i would develop something new. Maybe try out some of the new features in the latest go.
OOP and FP are not exclusive of one another. OOP is focused on data abstraction and FP is focused on process abstraction. Most functional languages support composition and encapsulation, and most OO languages support pure functions.
Yeah thats true, tutorials and books often trap you in a cycle where you just feel like you have to learn more before you can start producing something. But at the moment i feel like i'm doing the same work and not progressing as fast as i did in the beginning of my learning curve.
That sounds fun and i have been thinking in the same direction, for example i created a small Go program that would compare data and show you the difference. 
I set it like this: ```code client.Transport = &amp;http2.Transport{ TLSClientConfig: tlsConfig, } ``` 
Ah, also one option would be to `go mod vendor` and cache vendor directory every time `go.mod` or `go.sum` changes.
Like a file diff?
[removed]
&gt; That's not how it works... I don't think Go is object oriented Just because you said so? You're not saying anything of substance.
I didn't know what i filediff was so had to Google. But yes. I use it to test the results of my code, sort of a manual integrationtest, i run our services before changing the code to get a "master" and the run it after and compare them with my application to make sure that the business logic hasn't changed in a unintended way. We have unit tests but yeah they don't catch everything. 
&gt; I dont see why it would not be possible? No reason it shouldn't be provided you're using your own CI servers, not 3rd-party ones. Not sure if it'd be better to connect external storage or build an image with a pre-populated package cache. 
"This" as in "depending on a buttload of dependencies while at the same time expecting the dependencies to be few and small"?
If you are on macOS, maybe write some utilities that you could couple with [Alfred Workflows](https://www.alfredapp.com/workflows/) - basically a cli tool and simple integration with another tool (Alfred in this case). I would also find a good example of code, read it, hack on it, try to understand it. Code somebody else has written.
&gt; Just because you said so? No, because of the reasons I gave :) FTR, you have not responded to me saying that according to your arguments, Go is also a functional, dynamically typed, interpreted language. i.e. that your argument, taken at face value, makes pretty much all characteristics of programming languages meaningless. &gt; Please refer to my original post, and give us a coded example of why those fundamental assumptions are broken What makes those assumptions fundamental? They don't seem fundamental to me. If that's the definition of an object oriented programming language, then Haskell is object oriented. That's exactly what I'm saying - the criteria you outline don't serve as a useful characterization of object oriented programming to me. They have both false positives (I mentioned a bunch of languages that fulfill your criteria but that clearly are not Object Oriented) and false negatives - for example, Python has class-based object orientation and inheritance and clearly supports the OOP paradigm well, but it has no encapsulation at all. Yes, Go obviously meets the criteria you set (I mean, [that's how you selected them in the first place](https://yourlogicalfallacyis.com/the-texas-sharpshooter)), but that doesn't make Go object oriented - as long as the criteria as stated and interpreted by you are not the widely accepted definition of what that means. It *definitely* isn't actually a useful answer to OPs question, as they clearly are missing *something* in Go, to call it OO.
to me plain c is object oriented. As long as you have function pointers as data, everything looks kinda object oriented. Or maybe the only good thing about most object oriented stuff, is that they enable the like of function pointers.
See, and that’s an entirely academic argument. 
I'd recommend learning how to handle concurrent programming in go. https://github.com/golang/go/wiki/LearnConcurrency
I would say that small packages are definitely enabled, and encouraged by most. You'll find things written like "a package can be large or small" and the Go tools support both approaches, but most often large packages lack focus and can be harder to maintain and use. As a relative newcomer, I have found that using a lot of small internal packages has helped me design well structured programs. Read what Effective Go has to say about naming of packages, types, and functions: [https://golang.org/doc/effective\_go.html](https://golang.org/doc/effective_go.html). Then read about \`internal\` packages: [https://golang.org/doc/go1.4#internalpackages](https://golang.org/doc/go1.4#internalpackages) I think it is easy to conclude that internal packages make it easier to use short, clear names in code. The fewer concepts expressed by a package, the less "unique" you need to make the names in that package. This also makes it easier to validate that code is not coupled unnecessarily, is properly layered, is easier to test, etc. Concrete example: if you have multiple things in a single package that need an "ID" type you'll need to name them `FirstID`, `SecondID`, `ThirdID`, etc. If instead you have multiple internal packages, all of the "ID" types can be named `ID` within their respective packages, and referred to by others as `first.ID`, `second.ID`, `third.ID`, etc. I find that the second approach scales quite nicely as the number of "concepts" (i.e. packages) in a program grows. It makes it very easy to reason about things both within a package and external to it. You'll find a lot online about layout strategies in Go projects. The two I'd recommend are [https://github.com/golang-standards/project-layout](https://github.com/golang-standards/project-layout) and Kat Zien's "How do you structure your Go apps?" talks. Slides for the latter are here [https://github.com/katzien/talks/tree/master/how-do-you-structure-your-go-apps](https://github.com/katzien/talks/tree/master/how-do-you-structure-your-go-apps) and videos can be found on youtube (she has given the talk multiple times). Neither of these presentations claim to describe "the best way," but I found them very useful as a newcomer. Coming from C/C++ I initially found the lack of `static` variables and functions lacking (and from C++, anonymous namespaces). For those not familiar, these allow for file-local things in those languages. The Go equivalent is package private, along with the ability to make a package as small as makes sense. As a relative newcomer to Go, I initially followed the recommendations I linked above and went with a flat package structure, tossing everything into `main` and running with that as I experimented. I was almost immediately faced with naming problems and confusion. When I ruthlessly segregated programs into `internal/a` and `internal/b` packages, I felt like the approach guided me naturally toward well structured programs.
Docker is written in GO, Kubernetes is written in GO, the language has gained traction with developers from a couple different industries. If Google as a company was launched into the sun today I don't think GO would disappear. Haha, as long as the maintainers somehow avoided being destroyed by the Sun. The longer GO is supported by Google the stronger a candidate to learn it becomes. So, if you think Google is going under soon, maybe learn something that isn't as directly supported by a company. Personally, I don't see Google going away anytime soon.
All languages have their pros and cons. Go is great in certain tasks but certainly has its flaws. I love Go because it matches the Unix philosophy (compared with other languages, and my background in C makes Go a very productive tool for me). IF Google were broken up someday, Golang will certainly survive. The only uncertainty is who will be directing the future development of Go once Google collapses. One thing you can be sure is that even if the future Go designer is going to take Go to the direction you don't like, you can certainly use the older versions that you liked. Who will maintain it? Thank God we have a free market, meaning there will be people competing to be the maintainer of Go, and the community will choose the leader. There will be debates and divergence, but it's not a bad thing. Your concern is valid, but there is no need to worry about it. Java is still widely used after Sun was purchased by Oracle (though Oracle made Java much worse IMO and I stopped programming in Java a few years ago). All those languages are tools, and tools will be outdated someday eventually. 
Yea see this is why I think this whole argument is so goofy. They’re not as different as people say. And even if it’s not OOP, by ones definition, who cares? It works and works well. 
That link looks really good will read through it, thanks!
"Canonical" in this case just means a representative. So, you have, let's say, files called test1.mid, test1(1).mid, test1(2).mid, etc that all represent the same data. Out of these, pick some filename that should be the representative filename, e.g. probably test1.mid. You might have more complicated examples, so you should write some function that, given a filename, returns a filename that should represent that piece of data.
Looks cool, will check it out! Thanks!
If there really is no pattern to the filenames (e.g. there are files test1.mid and hello.mid that represent the same data), you could also open the file and hash its contents. Files with the same hash very likely represent the same data so you copy just one file per unique hash.
There’s a great video series I stumbled upon recently called “JustForFunc”. It’s not academic and boring. He goes right into coding for the entire video and always has some very interesting bits of info. 
I would be less concerned about then being broken up then Google simply changing their mind and dropping it as they tend to do.
Its open source, so if things look iffy for Google then a fork wouldn't be out of the question, assuming Github can survive. As long as we include the copyright notice in the License file: [https://github.com/golang/tools/blob/master/LICENSE](https://github.com/golang/tools/blob/master/LICENSE)
I don't mind the specifics, but I'd like to have 4 points, with everything outside the area contained in them not getting "persisted" to the cropped image. Another option would be to try and skew/scale the cropped polygon to be a rectangle. 
Java survived the implosion of the once mighty Sun Microsystems and its acquisition by the Oracle deathstar, so Go should be ok no matter what.
Would assume some part of Google. Think there is far bigger things to worry about. Golang has enough momentum that it will be fine. Also highly unlikely Google is going to be broken up. 
I'd say Go is less pegged to the whims of Google then, say, Flutter. With Go, you have a pretty open ecosystem, which means that Google can add things, but not really "lock out" competitors. For example, Go will add features, AWS will add features, but Amazon probably won't really ever feel like they're ceding control to Google by supporting the Go API for AWS. In fact, I'd guess AWS likes Go, because it's a great choice for serverless. With Flutter, Google kind of controls the ecosystem in a way that does lock out vendors, like Apple. (When Apple adds features or changes UX, what happens with Flutter apps?) I could easily see Flutter going the way of the dodo because Apple just decides "nope" one day. So I'd say, yeah, Golang's support by Google is very significant. But if Google withdraws support, it could easily just move support to other vendors with deep pockets (e.g., Amazon), because there's very little vendor lock-in.
If you capitalize the name of the language like it's an acronym, what does it stand for? Maybe it's something funny?
It's a programming language, not a messaging app we're talking about. Google makes like 10 new messaging apps a day, they don't care about dropping them. Another dead project, Google+, it took them years to eventually let die, and that was only after a security breach.
Acquisition by Oracle is a fate worse than death for an open source project.
Recently I have been encouraging my new team members to pick up an arcade game (preferably puzzle game) or board-game and re-write them in Go and Wasm. It is easy to code, a lot of documents to read, and a little bit challenging to model it idomaticly, so I consider it a good excersize of all three important aspects. 
Don’t even need github...
I wouldn't say Go matches Unix philosophy in that the runtime is included in every single binary, which kinda sucks. Also, everything being statically compiled means that updating a library means recompiling every program that uses it. My two biggest gripes with Go are that the runtime is included in every binary (which it needs to right now...) and how much dynamic allocation is done
GO: Google's Obsession.
You don't. Slices in Go are contiguous pieces of memory, so you can't really create a slice with "holes" like that. What you *can* do, is loop over them in different increments, like so for i := 2; i &lt; 6; i += 2 { _ = a[i] // or do whatever }
We are awesome, CVEs or not I think meeting you all was the biggest perk of jumping, both feet in, into this job :-) &amp;#x200B; And CVEs? Well, they will keep happening. No software is immune. We will respond, swiftly, responsibly and precisely. Snappily even :-) We still have few CVEs but I think you overestimate my powers to summon them. &amp;#x200B;
&gt; We are awesome No U
Apply.
Bravo
its the new python.
It's not would the code survive, but who would govern what the official Go standard is and how it evolves. Would the current owners just continue on or would it go through some game of thrones type shit until we standardize on the Cloud Native Consortium fork. My guess is the former, possibly under a new repo, but still managed by the old guard.
thats the unix philosophy, and how does go match that?
Hard to do GC without a runtime. Hard to do concurrency without GC. As for allocation, you can almost always eliminate it in the performance-critical parts of your code. One of the things I love about Go is that you can get deep into the weeds wrt allocation, alignment, asm, etc. when you really need to.
"Go", Obviously
cool, is gojek more of a go shop than a clojure shop? i always thought they were primarily clojure after reading [https://blog.gojekengineering.com/how-go-jek-manages-1-million-drivers-with-12-engineers-part-2-35f6a27a0faf](https://blog.gojekengineering.com/how-go-jek-manages-1-million-drivers-with-12-engineers-part-2-35f6a27a0faf)
C and C++ survived the breakup of AT&amp;T and the destruction of Bell Labs. You can't kill an open standard.
Swift would have great potential to take that role, should they really think a little bit off apple realm. 
Yes. The second Google closes up shop, all Go programs will cease to function immediately.
Simplicity of the design match Unix philosophy. I home Go will survive because of the simplicity that will make not so difficult to maintain and eventually translate the code to a new language if needed.
 I feel like arguing about the UNIX philosophy is like arguing about the Bible. That said, my take on it is small programs that do one thing well. In my own uses, having statically linked binaries I can easily move anywhere and Ron has helped fulfill this in my own code more than any other language I have written. I think this koan applies here nicely. http://www.catb.org/esr/writings/unix-koans/ten-thousand.html
At this point, if Google did something we all actively disagreed with, like, I dunno, making it so every time the Go runtime started up it automatically called Google central servers, or defaulted to Google's DNS for DNS lookups, or anything like that, there's enough Go community to pluck the leadership of the language out of Google's hands and continue on. This is an even stronger statement than the one you asked about in the question. I personally hold Google at a bit of an arm's length; I'm not boycotting them, but I definitely keep my eye on them. And using Go doesn't bother me, for this reason. And I think Google knows this is the position it is in... after all, it chose that position deliberately and with awareness of the all the consequences, good and bad for them, from the very beginning.
I like the unixy way that go's tools are implemented, i.e. as a collection of binaries
&gt; you have not responded to me I don't owe you anything. No one does. And the way you're carrying on, being vague, complaining, nit-picking, you're discouraging folks from doing so. &gt; What makes those assumptions fundamental? These are widely accepted fundamentals. They're published in books, taught in university courses, talked about in seminars and conferences. If you're going to challenge these fundamentals, you need to bring a much stronger &amp; more cohesive argument than what you're doing... and don't bring it to me because the community of people who've been raised on these fundamentals is much, much bigger than just me. &gt; It definitely isn't actually a useful answer Stop trying to tear down the answers you already see, then, and demonstrate a useful answer yourself. Nothing you're writing here is cohesive...
Most languages have a collection of tools though.. that not new or especially unixy
sometimes it seems Google is more obsessed with dart, regardless of its popularity. 
The Unix philosophy is that a program should do one thing and do it well. I like Go quite a lot but I'm honestly not sure how it follows the Unix philosophy and I'm interested to hear OP's explanation.
Comcast switched to Go and is one of the largest entertainment and streaming services. I only see it becoming more popular in performance applications as Go becomes more mainstream like other static typed languages like C, C++ and Java.
The relative ergonomics of using the stdlib data structures. Are you purposely obtuse?
Static linking is one of those things that's not usually classed as unixy, but gives you enormous benefits when it comes to running things. Check out things like StaLi and Morpheus Linux, which are both tiny distros that are static-only. The main issue with normal static linking comes from the GNU standard library which is really bloated, so these distros use musl, which has the same feature set breaks down much easier.
Although, I was recently surprised to learn that a 3-index slice is legal in Go. [https://medium.com/golangspec/slice-expressions-in-go-963368c20765](https://medium.com/golangspec/slice-expressions-in-go-963368c20765)
in the case of unix-like operating systems tho, tools often do more than one thing, and sometimes not so well... but i guess this is a "philosophy" vs reality; I feel like the phrase is really just a fluff piece 
a lot of languages have complicated, monolithic tools or tools that are built to interface with plugin architectures. 
Go is also fully open source so I doubt the community would let it die. 
&gt; I don't owe you anything. No one does. I honestly don't understand your aggression, we're just having a conversation here. Imagine I would react this pissed to everything you're writing :) No, you don't owe me anything. I don't owe you anything. I'm just making an argument for why I don't think claiming Go is Object Oriented is correct or helpful. Take it or leave it :) &gt; If you're going to challenge these fundamentals, you need to bring a much stronger &amp; more cohesive argument I don't understand why you find this not strong or cohesive. A good definition of some set will a) apply to every element in the set and b) not apply to any element outside the set. I'm telling you that you're criteria don't fulfill either, because a) Python, for example, is an Object Oriented language not fulfilling your criteria and b) Haskell, for example, is *not* an Object Oriented language but *does* fulfill your criteria. I find that a pretty concise, clear and cohesive way to illustrate why I find your criteria unhelpful to actually decide whether a language should be called "Object Oriented" or not. I also don't understand why you don't think my other argument is cohesive or strong - that, applying your argument-chain at face value would make Go purely functional (as it has higher-order functions and you can just not use any side-effects), Go would be untyped (as you can just use `interface{}` as your only type) and Go would be interpreted (as you can transpile it to Javascript and run it on V8). If the argument is "you can use some features of the language in a way consistent with \$other_paradigm, so Go clearly is a \$other_paradigm language", then all of these would appear to trivially be the case. And… I just don't think (again) that's a very useful way to think about this, because by that logic, Go is *both* strictly typed and untyped, it is *both* statically compiled and interpreted and it is *both* incredibly imperative and purely functional. Those labels just seem to lose their meaning under this interpretation. I mean, you don't have to necessarily *agree* with either of these, but I'm honestly stumped why you feel like they don't at least warrant a response and instead should just be outright rejected. I promise, to me they just seem super plain. I'm not trying to pull your chain here. I'm making an honest effort to provide a clear explanation. FTR, I disagree that your criteria, as interpreted by you, constitute "widely accepted fundamentals". Like, Object-level encapsulation seems to be pretty universally accepted as a pre-requisite for OOP. And, no, Go does *not* fulfill that - it doesn't have Objects and encapsulation happens on the package-level. Types are not classes - they may have methods, but Go doesn't have constructors and it doesn't *only* have methods. Composition is not inheritance - there is no subtyping involved, which means you can't actually use it to build OOP-characteristic type-hierarchies. These differences are not immaterial - they are why your interpretation of them fails to adequately capture what is or isn't an Object Oriented language (as I illustrated above). You are bending what is considered characteristics of OOP to make Go fit them - and in the process, you might just as well apply them to almost *any* language (again, as illustrated above). The simple fact is, that *you shouldn't try to apply OOP to Go*, because it is not a language suited to that. &gt; demonstrate a useful answer yourself. I feel "no, Go is not object oriented and it never will be" is a pretty useful answer to OP. Because it means they don't get lost in the weeds and use the language in a way that makes them unhappy (because the impedance mismatch will be frustrating to them) and makes other people unhappy (because they then have to work with bad code). Making an argument that a tomato is a fruit might or might not be technically correct¹ - either way it's going to be more helpful to tell someone not to put it in a fruit salad. [1] To be clear: I am of the opinion that it's not correct. But that's obviously a whole different argument :)
It does mean something completely different though (which is why I didn't mention it :) ).
Get Out.
My guess is the former, but that's not set in stone - look at the NodeJS io.js fork and merge. And all the various spats that have occurred in the various Linux disputes.
One of y
Call it `helpers_test.go` and it'll do what you want. I do this a lot.
It's no more risky than C# being bound to Microsoft or Kotlin pegged to JetBrains. A massive entity overseeing a language can be quite positive..... except Java and Oracle. Fuck Oracle!
[https://www.itassetmanagement.net/2018/05/01/oracle-to-charge-for-java-from-jan-2019/](https://www.itassetmanagement.net/2018/05/01/oracle-to-charge-for-java-from-jan-2019/) &amp;#x200B;
Oracle: hold my beer.
One does want to be super careful with this tho. for i := 2; i + size &lt; len(a); i +=size {} Assuming size is the step size. Could even extract a slice of size as well. 
Java is a proprietary software product, not an open standard. It's like saying Flash is an open standard. 
This
No, Go is part of the GNU Compiler Collection too. The Go project has been careful to not have One True Compiler, from the start.
But is it artisanal?
Interesting. Does it plug into vitess?
Exactly. The open source fork has to be called Jakarta because they got all pissy about the trademark too. &amp;#x200B; Add that to the fact it's not even a visually nice language. Kotlin will overtake it, especially with Android moving to Kotlin.
You're right, I should have clarified.
Ok, I’ll bite. When suggesting to new or inexperienced users that they must use some third party library instead of Go’s stdlib to build something as simplistic as a JSON/REST API, you are making things more complex and dare I say anti-go. These libraries (iris included) are fine for rapid development and may make people’s lives easier, but suggesting them in this context distracts from what made Go simple in the first place. He is right about the blog spam. This is an extremely short, non explicit instruction that does nothing to teach anyone what is actually happening with the code. 
This is not true. It should be `i&lt;size`.
And yet OpenJDK is what every Linux distros ships.
It depends what you’re doing. If you’re using all of the slice per chunk then you’ll want to do i +size. But if you’re just using the nth element then it only needs to check i. Alternatively, if you can deal with odd sizes, you can just do a bounds check in each loop too and only use that instead of going beyond the bounds. 
Yeah and Linux is a clone of commercial Unix. It's still a software product, not a standard. 
I'll generally have 3 top-level folders for Go code; `cmd`, `internal`, and `pkg`. `cmd` contains folders named after binaries that are built. So, inside those folders are main packages, i.e. `cmd/foo/main.go`. This lets you do things like run `go install ./cmd/...` to install all binaries in a project. `internal` is for code that should never be re-used elsewhere, and doesn't need to show up in godoc. That's quite rare, but it's basically for setup code for binaries, maybe configuration that's also very specific to an application and not the next part... `pkg` then contains packages grouped by domain. I try to keep packages a reasonable size. Sub-packages are useful for sub-domains. Let's take an example. `auth` might be a domain, and `user` could be a sub-domain. So, you might have a `user.Repository` type that lives in `auth/user/repository.go`. Domain is a pretty tricky thing to pin down though, things like `validation` can be a domain, or `form`, or maybe things like `grpcapi`. When I'm naming packages I'll also try to name my package in such a way that it shouldn't always need to be aliased when it's imported. So that means not conflicting with the stdlib. Not conflicting with things I'm importing from third-party libs. And attempting to not conflict with any other packages in my app. This can get a little tricky, but that's why I end up with things like `grpcapi` above, because it's likely I'll import that in the same place I import the Google `grpc` package, meaning if made an `api/grpc` package, I'd have to alias it when I import it. Organising code in Go is pretty tricky, especially compared to other languages where you can just import types. Other languages are also a lot more permissive with things like circular references.
TL;DR
Why is it reasonable to assume that? Your example is equivalent to 5 * time.Second * time.Second Which is quite clearly wrong.
I'm sorry. I had no intention of upsetting either you or the person I replied to with my question. However, as go is touted as as an efficient and performant programming language, the natural assumption is the poster to whom I was replying would have meant that as well. Hence the question. &amp;#x200B; Forgive me if my question was so obtuse as to require such rudeness from yourself.
I don’t think this is a common problem, but thank you for the tool anyway.
I wish Go had a pipe operator, which makes it unixy.
Their implementation should be propriatary. A free reimplimentation shouldn't be a problem. Only Oracle managed to get a court to rule that APIs are copywriteable. Think about that... Imagine if whomever owns the old AT&amp;T UNIX and C language rights decided to crack down on system call APIs in Linux, or C library calls. We wouldn't have an industry if ever company acted like Oracle. 
Can you be a bit more specific? One tip is that you may need the [StringHeader](https://golang.org/pkg/reflect/#StringHeader) type if you're going to work with string directly.
Implement all the packages, especially numpy and such and we will see.
That is literally when I decided J**a was no longer viable for my future and switched to go. I expect a bill in the mail everytime I say the word J**a.
than* We are programmers. If then. Less than, greater than. 
*Wooo* It's your **3rd Cakeday** Redundancy_! ^(hug)
I didn't know this, that's cool. Have they written at all about how they are using Go? 
Not OP, but I'd argue that go is philosophically similar in how it approaches programming. It encourages narrow responsibility (e.g. small interfaces) and simple code that is straightforward to reason about. Go gives you building blocks that do a simple thing, and avoids adding options where they are not required. The basic concurrency implementation is a channel, and the only options it has are the type of message/data, and the buffer size. (And the goroutine, which takes no options). Compare this to python, Perl, or C - you've got thirty different options and it's not clear what they do. Or take collections - my C++ colleagues all have their favorite "default" data structures to use. While it's certainly fun to read about the implementations and tradeoffs of vectors and deques and multisets and unordered_multimaps, it usually doesn't matter. Go gives you slices and maps, and that solves 98% of your problems. The stdlib is full of tiny pieces of functionality - one of my favorite examples is `io.LimitedReader`. Tiny functionality, simple code and intent, and can be used in a bunch of places without requiring configuration. These even extends to your code design. Because Go puts such heavy emphasis on tests (and ships with a barebones testing library), it pushes you toward writing smaller, simpler, testable functions. Structs are meant to be small and composable, and exports should be limited, because Go also values clarity and "does one thing well" in any code meant to be reused. In my experience, programming in Go is like composing Unix tools. Solid building blocks that you wire together to accomplish your goal, without surprises or magic.
this is cool! admirable! i haven't had this kind of problem yet though. the `waitFor()` example isn't very compelling. i think the big problem with it is that it modifies a duration that way.
Why not? `5 * time.Second` is "five seconds", multiplied by "another second" would be equivalent to 5*1*1.
vitess needs a MySQL cluster management like xenon.
sorry, I don't understand that. Can you explain it differently, please?
**Stop with this FUD** If anything Java is more free than it has ever been. Use OpenJDK! (which btw, Oracle distributes!) I'm no fan of Oracle, but the fact that people write articles like this is goddamn absurd. I even recently heard of a large company that stopped using Java because the CTO thinks it costs money now. You know a rumor has spread way too far when a massive business decision is made based on a completely incorrect premise.
Oh yeah, I get it. I'm a former bell labs guy. 
Java is fully open source as well.
That's only true if the Duration base unit is assumed to be seconds, which seems an arbitrary assumption at best and if you did assume that then you would never write this function because "5" is already in the base unit without needing to convert. It seems obvious to me that these are conversions from base Duration unit to standard units of time, that's often how time libraries work in other languages, and the docs are clearly written to boot.
Not exactly. The open source version of Java is OpenJDK, and it does still seem to be referred to as Java. The renaming to Jakarta was for Java EE, and while unfortunate for those involved it is something that likely should have been done years ago given the ongoing confusion that existed between Java SE and Java EE. So now we have Java (OpenJDK if you aren't willing to pay for the Oracle version) and Jakarta EE.
If it's obvious to you, great.
Explains why they sued google for re-implementing java. 
You mean something like this? https://en.wikipedia.org/wiki/UNIX_System_Laboratories,_Inc._v._Berkeley_Software_Design,_Inc. Or maybe this? https://en.wikipedia.org/wiki/SCO%E2%80%93Linux_disputes
I'm not on Oracle's side here, but their suit of Google does not conflict with the fact that Java is open source.
Semantically, you can't multiply two units of time, period, there is no obvious answer. And why in the world would you think it equaled 1? Would time.Minute also equal 1 then? How about time.Hour?
You can multiply any kind of two units if they're the same unit - not hours and minutes, or bears and lions, but seconds and seconds is fine. It doesn't need to necessarily equal an integer 1, but if you want to mimic English, it should behave in an idempotent fashion if multiplied by itself. That's ugly to implement, but if the base unit is arbitrary then that's how to do it.
No clue. Most of the job postings are for Go/Java experience but I would imagine for something related to concurrency and low lag time on the backend
So 3 bears x 3 bears would be what?
I don't think I can get through to you, sorry.
The answer is 9 square bears, which makes as much sense as 5 square seconds.
You may want to mention buffered io. Many small reads and writes to a file will hurt performance. The bufio default buffer size is 4k which should match most HDDs and SSDs. https://golang.org/pkg/bufio/#NewReader
I tend to agree with you, and this comment actually helps me verbalize why I like go so much. I prefer a small, focused toolbox where I know all the tools very well to an enormous one that nobody fully grasps.
Yep I agree and to expand further by small interfaces it’s literally an interface with just one function. Something like io.Reader which reads from an array of bytes and returns the number of bytes read (typically discarded) and an error. This type of interface is extremely powerful because it can be used when reading from disk, from a network drive, or someplace else like a stream. This is what embodies Unix in my mind. It’s different to think about programming this way, to really reduce things to such small components, but I think this design is intended to help control complexity. From my limited experience complexity explodes with even a few developers. Paradoxically the less experience the devs have the faster the complexity grows. Go helps combat this
Doesn't help that Oracle did a terrible job of communicating the new license model which caused everyone to freak out about it. It's almost their own fault for taking a legalese approach without a half-decent PR approach to the announcement(s).
&gt; not 3rd-party ones. It's not that uncommon, e.g. Bitbucket Pipelines and Gitlab CI both allow you to declare some directories that are persisted between CI runs. I take big advantage of it to reduce my Maven builds from 40+ minutes to more like 6.
&gt; dropping it as they tend to do Can you explain that?
Funny, I just asked Brad about this recently. net/http starts by being unsure whether the endpoint is going to speak HTTP/1 or HTTP/2, so it spins out several connections to the endpoint. That's the pessimistic option: if it's HTTP/1, it would be performant to have a pool of connections. &amp;#x200B; During connection establishment, TLS negotiation occurs. As part of that, application-layer protocol negotiation (ALPN) occurs ([https://en.wikipedia.org/wiki/Application-Layer\_Protocol\_Negotiation](https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation)). During this phase, the server advertises "h2" (see relevant HTTP/2 spec: [https://http2.github.io/http2-spec/#versioning](https://http2.github.io/http2-spec/#versioning)). &amp;#x200B; The first connection that gets the h2 during ALPN negotiation causes net/http to kill all other connections and start putting traffic onto the one connection. Subsequent requests don't spin out new connections \*, they become HTTP/2 streams ([https://http2.github.io/http2-spec/#StreamsLayer](https://http2.github.io/http2-spec/#StreamsLayer)) on the existing connection. &amp;#x200B; \*Until MAX\_CONCURRENT\_STREAMS ([https://http2.github.io/http2-spec/#rfc.section.5.1.2](https://http2.github.io/http2-spec/#rfc.section.5.1.2)) is reached, a GOAWAY, or other connection-termination event.
Maybe you can implement it based on [Stream](https://redis.io/topics/streams-intro), which is a new data type introduced with Redis 5.0. See [this blog](http://charlesleifer.com/blog/multi-process-task-queue-using-redis-streams/) for more discussions.
I agree that the Go would be a better fit from a resource consumption perspective. At this time I don't have a budget. Right now the largest concern is time to market. Everyone knows JavaScript. Another senior developer is a fan of Elixir. In our conversations, he appears to be unmoved by the arguments for a binary, statically typed language. Therefore it's a hard hurdle to jump by requiring everyone to learn Go, and get use to Errors (which is a massive pain, since it deviates from Java/JS/C#/etc in error != exception, or that exceptions are throw far too readily in Java, etc.) We'll need WebSockets all over the place. Update a document? WebSocket notification! Get the latest chat message? WebSocket notification. ([https://youtu.be/U\_d1M9xndGU?t=68](https://youtu.be/U_d1M9xndGU?t=68)) I know that Go can handle this. It's just a lot to write. A featureful version might be an easier sell.
I think it's very unreasonable that your waitFor function already expects a time.Duration, while also still manipulating that duration afterwards. The function already asks for how long you want to wait, you shouldn't modify that afterwards. I'm not sure why you have a linter for this. It's just an error logic. 
Test stuff goes into _test.go files. Put the in any one you want.
1. Click "+" at top of GitLab 2. Click "New Project" 3. Type project name 4. Click green "Create project" button
These are the term for the current JDK: https://www.oracle.com/technetwork/java/javase/terms/license/javase-license.html 
I over simplified the example. Obviously it is very clear there's a problem because it is just two lines. Just imagine a larger function with many more lines and it's easy to forget that the argument is a duration and multiply it by a unit. Indeed, it is a rare logic bug. I personally didn't think it would happen in the wild but I found an occurrence in a large codebase recently and wanted to see whether there were any other instances of the same problem.
Not only is it OK, but it’s actually the expected way to test. Always use interfaces where possible so you can mock them. 
Thanks! My concern is that I'll be changing implementation of my configuration struct just to satisfy my testing workflow. It feels like implementation should not change based on the environment I'm running my application on - it's almost like adding additional logic to a function body based on the environment. But since I'm new to Go, maybe my understanding of interfaces is incomplete.
I am new to go. Can someone tell me what generics are and why they are useful? And what's with all the hype around it? Thanks
Well one would want to use interfaces not just to satisfy testing, but to ensure you can swap out components or whatnot. The easiest example is readers. If you only need to read something, maybe a file, in a function, you don’t pass in a function but as an interface that the file can satisfy, usually io.Reader. Then, you can easily add in a zip decompressor if the file is compressed without having to change any code. Or crypto primitives in-line to decipher the file if it’s encrypted. And then you’ve never changed the code at all, except in the functions feeding it. It makes mocking it for testing easy, but it also makes the code far more portable. 
Thank you very much, makes sense.
Start. You will either get into it or you won’t. But you’ll never know until you start. 
It's intentional. They want people to be uncertain and to pay. The way they do audits people don't want to be caught out so they pay anyway. 
I do agree with what you wrote. However, remember that we are now consciously looking at and reasoning about this particular piece of code. A programmer in a haste (or lacking coffee) can easily write buggy code like this and not realize the problem. (The bug that the OP found in an existing production codebase already proved this.) The compiler does not catch this either, and this is where a linter can help preventing ugly runtime errors that are hard to track down. 
&gt; But no, we are still unclear of what the real question is. All these problems reveals a very small fragment of the real question, which should solve all these problems in a bigger and more unified picture. Could you clarify what you mean? Are you refering to something like lisp macros? I'm not sure I understand what the 'real question' refers to here... 
I started working on go-ethereum mono repo and it’s not too bad. Feel free to ping me if you need help.
You could always bet on another horse if it comes to that. The industry will make loads of money if they are forced to switch. (Or they invest it in helping the old horse to stay in the race longer.) &amp;#x200B; No matter what, we are resourceful and we'll find a way to earn our daily bread ;-) &amp;#x200B;
&gt; other people are thinking of Java's compiler-assisted copy-paste mechanism How are Java's generics copy-paste mechanism? Java generics are precisely _not_ copy-paste, they are based on type-erasure. Sort of like auto-inserted type switch. Perhaps you're mixing up with C++ templates? 
Check out how generics work in C# and Java, might give you an idea why they are useful.