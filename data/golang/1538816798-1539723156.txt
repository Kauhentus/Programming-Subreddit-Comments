Oh, sorry for my comment, you are right. I've read the "Error Inspection" spec right now, and they're saying: &amp;#x200B; \&gt; The [errors.Is](https://errors.Is) function is used instead of a direct equality check: &amp;#x200B; Majority of values behind error interface are pointers, so given the above [errors.Is](https://errors.Is) could be only used for sentinel values, which is one non-intuitive API for me. 
I have a monorepo with go.mod in the root of the repo, works well.
This seems really impressive! Maybe I won't use Electron after all.
Looks awesome. Thanks for sharing! 
Oh. Oh, please, please don't. My laptop cant handle another electron app.
&gt; Currently at a pre-beta level (DON'T RECOMMEND USING RIGHT NOW -- come back in a few weeks after announcement on go-nuts email list). So... is this that announcement, and you jet haven't updated the readme yet?
It also allows you to chain method calls like this x.Foo().Bar().Quux() Again, as you said, not necessary, but can make code more readable depending on your personal preferences.
Or CPU. Almost every app at the top of my CPU usage list is an Electron app, and that's when they're idle. God forbid they actually have to *do* something.
I use 'go mod vendor' and edit the files in the vendor directory directly.
What about go 101?
Interesting, I hadn't seen this before today! I'll have a look over it and see what it's like and possibly add it to the list! Thanks for your comment :)
Hey, thanks for stopping by and thanks for your feedback :). I'm working on improving the README today, I'll take your advice and include some of this post to offer clarity of intent and origin. I'm new to being an OSS author. This actually has drummed up a lot more attention than I expected (I expected nothing, so even this little bit is awesome) so I feel obligated to look like I know what I'm doing with the README now.
Please add something in the title saying it is a newsletter.
You don’t really need a dedicated tool to do this since the go command has support for replace statements: go mod edit -replace=importpath=localfilepath I see there is value in this tool doing backups and restores for you of the original mod file.
great work. thanks for open sourcing it. will try it out :)
it doesn't make much difference. I normally name my functions VerbNoun - if the Noun is actually a type in the system then I think it's a candidate for being a method (Noun.Verb instead). It's not a hard rule, but I do it useful.
The correct answer is: when you have a set of functions that need to share date, methods _might_ be a good idea. ``` // The clue that we might want to use methods is that we have several funcs that take the same arguments. func foo(ip string, port int) error {} func bar(ip string, port int) error {} func baz(ip string, port int, timeout time.Duration) error {} // Methods type Server struct { IP string Port int } func (s *Server) foo() error {} func (s *Server) bar() error {} func (s *Server) baz(timeout time.Duration) error {} ``` There is absolutely nothing wrong with the version of the code that uses plain functions. _But_, if we have many functions that all need to share the same IP and Port, it _might_ be worth it to create a type, to avoid having to pass the args over and over. *Always* start with simple functions and fall back to methods when you're sure there's a data-sharing relationship between the functions. Modern software is absolutely riddled with unnecessary OOP. Sometimes inexperienced programmers think they're supposed to use methods to be Big Kid programmers, but that's 100% not the case. Creating abstractions unnecessarily just hurts readability. To understand what I'm talking about, please check out [this video called Stop Writing Classes](https://www.youtube.com/watch?v=o9pEzgHorH0). It's from a Python conference, but the truths apply to all OOP languages.
Ha. No problem. I'm glad you shared! I just thought I'd offer a little suggestion. Thanks for being receptive. 😃
I feel like most of these answers are (strangely!) missing the point. *Use methods when managing state*. - Is your function modifying the state of a struct? Use a method. - Is your function querying a stateful object (i.e.: might calling the same method with the same arguments produce a different result)? Use a method.
When you want polymorphism. 
Well put
Yeah that was also something I was thinking about. Till now we were maintaining one general purpose app and did everything in the scripting part. Having the core extended by customer specific codes would require some thinking, do we put it in the core or start maintaining different versions/forks/plugins, that needs some researching on how to do this properly and easy to maintain without cluttering out codebase. Thank you for the input.
I came here to make sure Thorsten's books were on this list, otherwise I would question the legitimacy of it
from https://github.com/vektra/mockery # mockery mockery provides the ability to easily generate mocks for golang interfaces. It removes the boilerplate coding required to use mocks. # Installation go get github.com/vektra/mockery/.../, then $GOPATH/bin/mockery
You probably want `go build` - it builds and places the binary file in the cwd.
haha, very glad I didn't disappoint! The first one is exceptional though, I'm very much looking forward to working my way through the second!
You can use a 3rd party library for this or use channels &amp;#x200B; I made this using a 3rd pary library which isnt recommended [https://github.com/Dontmindmes/Concurrent-Port-Scanner](https://github.com/Dontmindmes/Concurrent-Port-Scanner) i limited it to 25 concurrent scans
Well, when I $ go install -v github.com/vektra/mockery/.../ Fetching https://golang.org/x/tools/go/loader?go-get=1 Fetching https://golang.org/x/tools/imports?go-get=1 Parsing meta tags from https://golang.org/x/tools/imports?go-get=1 (status code 200) Parsing meta tags from https://golang.org/x/tools/go/loader?go-get=1 (status code 200) get "golang.org/x/tools/go/loader": found meta tag get.metaImport{Prefix:"golang.org/x/tools", VCS:"git", RepoRoot:"https://go.googlesource.com/tools"} at https://golang.org/x/tools/go/loader?go-get=1 get "golang.org/x/tools/go/loader": verifying non-authoritative meta tag Fetching https://golang.org/x/tools?go-get=1 get "golang.org/x/tools/imports": found meta tag get.metaImport{Prefix:"golang.org/x/tools", VCS:"git", RepoRoot:"https://go.googlesource.com/tools"} at https://golang.org/x/tools/imports?go-get=1 get "golang.org/x/tools/imports": verifying non-authoritative meta tag Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200) go: finding github.com/stretchr/testify/mock latest go: finding golang.org/x/tools/go/loader latest go: finding golang.org/x/tools/imports latest Fetching https://golang.org/x/tools/go?go-get=1 Fetching https://golang.org/x/tools?go-get=1 Parsing meta tags from https://golang.org/x/tools/go?go-get=1 (status code 200) Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200) get "golang.org/x/tools/go": found meta tag get.metaImport{Prefix:"golang.org/x/tools", VCS:"git", RepoRoot:"https://go.googlesource.com/tools"} at https://golang.org/x/tools/go?go-get=1 get "golang.org/x/tools/go": verifying non-authoritative meta tag go: finding golang.org/x/tools/go latest get "golang.org/x/tools": found meta tag get.metaImport{Prefix:"golang.org/x/tools", VCS:"git", RepoRoot:"https://go.googlesource.com/tools"} at https://golang.org/x/tools?go-get=1 go: finding golang.org/x/tools latest go: finding github.com/pmezard/go-difflib/difflib latest go: finding github.com/davecgh/go-spew/spew latest I got require ( github.com/davecgh/go-spew v1.1.1 // indirect github.com/pmezard/go-difflib v1.0.0 // indirect github.com/stretchr/objx v0.1.1 // indirect github.com/stretchr/testify v1.2.2 // indirect github.com/vektra/mockery v0.0.0-20180815001236-ea265755d541 // indirect golang.org/x/tools v0.0.0-20181006002542-f60d9635b16a // indirect ) When I $ go get -v -u github.com/vektra/mockery/cmd/mockery go: finding github.com/vektra/mockery/cmd/mockery latest go: finding github.com/vektra/mockery/cmd latest go: finding github.com/vektra/mockery latest Fetching https://golang.org/x/tools/imports?go-get=1 Fetching https://golang.org/x/tools/go/loader?go-get=1 Parsing meta tags from https://golang.org/x/tools/go/loader?go-get=1 (status code 200) get "golang.org/x/tools/go/loader": found meta tag get.metaImport{Prefix:"golang.org/x/tools", VCS:"git", RepoRoot:"https://go.googlesource.com/tools"} at https://golang.org/x/tools/go/loader?go-get=1 get "golang.org/x/tools/go/loader": verifying non-authoritative meta tag Fetching https://golang.org/x/tools?go-get=1 Parsing meta tags from https://golang.org/x/tools/imports?go-get=1 (status code 200) get "golang.org/x/tools/imports": found meta tag get.metaImport{Prefix:"golang.org/x/tools", VCS:"git", RepoRoot:"https://go.googlesource.com/tools"} at https://golang.org/x/tools/imports?go-get=1 get "golang.org/x/tools/imports": verifying non-authoritative meta tag Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200) go: finding golang.org/x/tools/go/loader latest go: finding golang.org/x/tools/imports latest Fetching https://golang.org/x/tools/go?go-get=1 Fetching https://golang.org/x/tools?go-get=1 Parsing meta tags from https://golang.org/x/tools/go?go-get=1 (status code 200) Parsing meta tags from https://golang.org/x/tools?go-get=1 (status code 200) get "golang.org/x/tools/go": found meta tag get.metaImport{Prefix:"golang.org/x/tools", VCS:"git", RepoRoot:"https://go.googlesource.com/tools"} at https://golang.org/x/tools/go?go-get=1 get "golang.org/x/tools/go": verifying non-authoritative meta tag go: finding golang.org/x/tools/go latest get "golang.org/x/tools": found meta tag get.metaImport{Prefix:"golang.org/x/tools", VCS:"git", RepoRoot:"https://go.googlesource.com/tools"} at https://golang.org/x/tools?go-get=1 go: finding golang.org/x/tools latest I got require ( github.com/vektra/mockery v0.0.0-20180815001236-ea265755d541 // indirect golang.org/x/tools v0.0.0-20181006002542-f60d9635b16a // indirect ) So we have: go install github.com/vektra/mockery/.../ and go get -u github.com/vektra/mockery/cmd/mockery and maybe something else. May be yesterday I can't install a binary because previous installation of mockery was installed before I update to v1.11 and I didn't specify the -u flag?
unless you call `go mod vendor` again the changes will stay there. `go get` won't overwrite them.
https://gobyexample.com/worker-pools
js is more commonly used. Who are you writing a tutorial for? Yourself? Then Go. The largest audience? Node.
The odds of your tutorial being complex enough for the language to matter are low. The odds of anyone besides you having a strong opinion are even lower.
If peolple want go they get Go or else
Another approach that might work is to use RPC from your core to call functions in your scripts. The scripts would be mini RPC servers that run all the time, waiting to be called. In case of an update, just start a new binary "script" that publishes the same functions, just with different content. With a bit of a "scripting library" that wraps your scripts and transforms them into RPC servers that should be pretty readable too.
Ah, you're right. In my defense the last time I tried this was a long time ago.
I would like to know the resources go-veterans say "I wish I know that earlier".
He goes around and posts a lot of negative stuff on Reddit. I've seen him post about the demise of Go earlier as well, but he didn't have any proof to back up his claims when I asked him about it.
This is [a problem currently being debated](https://github.com/golang/go/issues/24250). There's currently no way to do this cleanly, unfortunately.
I don't think the 'loop' label is needed. &amp;#x200B; You could keep the for { select { and have a return call instead of the break loop. The channel close commands could be called at the top of the new goroutine with defer() &amp;#x200B; The error handling logic for this part should exit if it can't open the file `file, err :=` [`os.Open`](https://os.Open)`("testdata/small.csv")` `if err != nil {` `fmt.Println(err)` `}` &amp;#x200B;
Are you sure you want to write to a file? If you write to STDOUT, you can redirect to any file you want, and/or pipe into another program for post processing.
Programming in Go by Mark Summerfield is excellent and very detailed. 
While I know this is possible. Having multiple file streams is impossible this way.
I interpreted the question as asking for the difference between func foo(s server) error {} vs func (s server) foo() error {} and I don't think it's your explanation differentiates these two.
Fair warning: Mockery doesn't support Go modules yet ([issue](https://github.com/vektra/mockery/issues/213)). You can use fine on old-style packages, but any imports won't resolve unless you put your entire project under `GOPATH` and then `go mod vendor`. A *lot* of tools are still broken like this, including `goimports`, `goreturns`, `go-sumtype`, `gorename`, `megacheck` and many more. Some tools have new branches but no official releases. [Here](https://github.com/golang/go/issues/24661) is the tracking issue for all the various tools.
I am using this workaround `cg "$(go env GOBIN)" &amp;&amp; go get -u &lt;some pkg&gt;`. It is not very nice, but it is ok for a makefile rule.
The use of tools not from the Go distribution that's not my way, and that's because I ask this question. :)
Make file is used to build software, it’s not language specific
Yes. But, before 1.11 I build software without make, why I need it today?
return it as an error instead. at that point it's really not a panic anymore.
Looks cool, will be exciting to see where this leads. Starred the repo. I took a glance at the basic example and noticed that method names appear to be a bit weird. For example: https://github.com/goki/gi/blob/master/examples/basic/basic.go#L29 rlay := mfr.AddNewChild(gi.KiT_Layout, "rowlay").(*gi.Layout) rlay.Lay = gi.LayoutHoriz I'm not a fan of stripping off the end of the word "Horizontal", even if it makes is a few characters shorter. It only serves as a way to confuse people, especially those that don't natively speak English. Also, Some methods appear to be using underscores, while others are not? Go recommends not using underscores. https://golang.org/doc/effective_go.html#mixed-caps
It seems to me that installing packages should not be a concern of a dependency tool, but OS package manager instead. I am not very excited about maintaining yet one more bin directory, making sure it's always in PATH (khm-khm homebrew...) that's why I've never been a fan of GOPATH's bin directory.
Go is a pretty good starting language for creating web APIs. Setting up a server is super easy and will get you straight into building your backend. I'd recommend it.
Original tweet: r/https://twitter.com/davecheney/status/1048895352781205504
Golnag Forserver was a character in my last D&amp;D campaign.
note this is 1.11 vs 1.0 (not 1.10)
&gt; really simple decision like routing I think we disagree on that line of thinking. How many different routing frameworks exist for Go right now? There's [chi](https://github.com/go-chi/chi), [mux](https://github.com/gorilla/mux), [httprouter](https://github.com/julienschmidt/httprouter), [web](https://github.com/gocraft/web), [gin](https://github.com/gin-gonic/gin) and likely more that I haven't come across. These routers all have slightly different interpretations of how you define your handlers and middleware, how you register routes, etc. Many of these routing frameworks require you to store shared context in a `context.Context` and unwrap via type assertion as you need it. One of the biggest motivators of this project was to let the user retain some type safety and write handlers as methods on a concrete context type. To do that, the router must understand that type and how to initialize it for each request. On top of that, the auto-magic registration of routes based on method names made it a _lot_ easier to generate new routes programatically. Rather than having to parse an existing go file and add lines to register newly generated routes, I could just add new methods to a type. Each method name will be unique, the compiler can catch 90% of accidental duplication (some complications exist such as the fact that `GET_HTMLPage` and `GET_HtmlPage` would map the to the same route, `/html/page`). Another benefit of this approach is extensibility. Someone can write a type that can be embedded in an application's context type. If that type provides methods like `GET_PluginAdmin`, `POST_PluginData`, etc, you can get all that functionality added to your application for free just by embedding that type into your context type. The routing implementation isn't as much a decision on routing as it is a necessity to support other features I wanted out of Attache. Does that make sense?
Thanks for stopping by. Please let me know what you think. I know it's not a finished product, but I'd like to keep working on it based on feedback from people who are able to take time to try it out. I'll try to be very responsive to issues and any PRs people choose to submit.
Have you tried it? Returning the result from a multi-return function works fine, Go splits them out into their own values when returning.
What is your issue?
Are you sure the code you posted is the code causing the problem? It seems to work fine for me: https://play.golang.org/p/8dXSnVWVS5Y (with a few adjustments to make it functional).
Are you sure error was at "Function" and not "something"? 
Golang has been build for the modern web . Its standard library include already all you need such a json marshalling and unmarshalling, http client and server etc... It also reduce the complexity, in most of the case there is only one good way to do something where with other languages you'll probably ending googling : "best json lib for ***" The tooling is also amazing from linting to formatting. Deployment is also so easy eith a single binary . I think it's a perfect language to start server-side web dev and if you have the option you should run for it. 
If Golang has a http package, why are there Web Frameworks like Rocket?
thanks, that was nearly the solution I tried, but my did not work, because I tried to pass the `map[string]A` to a function that takes a `map[string]Interface` and that did not work. Even if I cast the parameter it did not work. I guess the whole type switch and cast stuff doe only work on structs and not on slices or maps.
thanks. [https://www.reddit.com/r/golang/comments/9lm0eh/generic\_union\_function/e7c3gzv](https://www.reddit.com/r/golang/comments/9lm0eh/generic_union_function/e7c3gzv)
i was told that the go solution would be to generate code, which would be fine if I had to support many types, but since we are only talking about 2 different types its not worth the drawback. thanks
You'll need to ask that question to the authors of those frameworks. In general, the response from the Go community towards these frameworks is —You don't need them. Just use net/http— and the majority of people using them is programmers coming from other programming languages where a framework is almost a requirement _(PHP, Node.JS, Ruby, Python, etc)_ unless you wanted to write the web router, session manager, caching and all the dependencies by yourself. I don't know why /u/dannypsnl created [rocket](https://github.com/dannypsnl/rocket) But looking at the code, it seems that they just wanted to pass _structs_ to the HTTP handler and respond with HTML, JSON or Plain Text without having to write the Encoder every time. And that's the gist of most of the Go web frameworks that exist, people just wanted to simplify a repetitive task by creating one or more libraries that would —supposedly— speed up the development process.
I've never heard of rocket, but generally people use a custom router like Chi to make it easier to use parameters in URLs. However if you want a batteries included framework there are things like Buffalo. But I'd say that most people just use the standard lib with just a few third party libs for either performance reasons or because it makes development easier 
Making variables and other symbols immutable doesn't allow **mixed-mutability types** such as a "mutable slice of immutable objects" which basically voids the whole concept of immutability. JavaScript has a \`const\` qualifier which affects variables only, in the end we have variables that can point to just a certain object, which is totally mutable and prone to aliasing which misses the whole point of immutability. &amp;#x200B; The [second revision of the proposal](https://github.com/romshark/Go-1-2-Proposal---Immutability/milestone/2) will address the verbosity problem with [MQP - Mutability Qualification Propagation](https://github.com/romshark/Go-1-2-Proposal---Immutability/issues/20). This will make describing immutable types less verbose and still allow for mixed-mutability types, be sure to check it out!
Big difference. OP, fix your title. 
Check out [my response in the discussion of "immutability &amp; engineering"](https://github.com/romshark/Go-1-2-Proposal---Immutability/issues/21#issuecomment-427417357). Together with [the problems describes in the design document](https://github.com/romshark/Go-1-2-Proposal---Immutability#11-current-problems) it might help clear up its purpose.
[4.5. How are constants different from immutable types](https://github.com/romshark/Go-1-2-Proposal---Immutability#45-how-are-constants-different-from-immutable-types) explains the difference between immutable types and constants in greater detail.
Generics are a whole nother topic. Generics are about avoiding boilerplate code and make the code somewhat safer, Immutable types on the other hand are about making Go code less ambiguous and thus much safer and more dependable.
&gt; If you look at engineering from the perspective of large teams that are constantly on-boarding new people; simplicity and minimalism become very important characteristics with respect to making the engineering effort "easier". ... and so are immutable types. Immutable types make APIs less ambiguous and the intentions of the original author clear to everyone. It doesn't allow newcomers and external contributors to do something they're not supposed to do like: * changing the supposedly "immutable" identifiers of unique objects after their creation somewhere in the package the struct is declared in. * or aliasing a slice they receive in an argument and passing it somewhere else where it could be mutated. * or copying an object by value aliasing the pointers inside * and so on and so forth... Clear APIs reduce complexity a lot! &gt; other solutions for declaring intention, such as using a value receiver or getter methods - which are already in the language and get you a long way when you need them. [A value receiver is nowhere near safe, a value receiver is a shallow copy](https://github.com/romshark/Go-1-2-Proposal---Immutability#46-why-do-we-need-immutable-receivers-if-we-already-have-copy-receivers) and is thus prone to pointer aliasing! If your struct has pointer, map or slice fields then having a value receiver won't protected you from mutability issues. Getters are just the same.. you can't return an immutable alias for a slice, [you'll have to copy it in the getter, and this is both error prone and costly in terms of performance](https://github.com/romshark/Go-1-2-Proposal---Immutability/issues/21#issuecomment-427417357). &gt; others are living without it just fine (most Go programmers). Most Go programmers copy stuff. The code becomes slow and bloated by copy-code. This is not the way software engineering is supposed to work. Software Engineering is about defining clear APIs and ensuring consistency, not copying the hell out of everything because you can't trust anything and anyone. &amp;#x200B;
This is what I expected. Correct me if I'm wing, but they basically have their own custom compiler infrastructure. Go 1.0 was not very optimized and they've had a long period of time of a lot of opportunities to fix a lot of low hanging fruit. If go 1.0 was based off of LLVM, they probably would have started much faster and not had a lot of room to grow. P.S. I'm not advocating that they should have started out with LLVM. Just saying.
If you want to start web development with Go, use net/http first. I would in most of time lib like rocket is not necessary. Originally, I create rocket for practicing. Now architecture is because when I worked for my previous company, we need to unmarshal data very repeatedly in too short time!!!! So we start to design these stuff, make unmarshal data and response easier. Now we are working for some validating design and http2, but I think the point is, if you don't need the thing, why you use it? Depends on a third party should be serious and make sure it's clean for your program, right? p.s. why I'm here and telling people don't use my lib, genius 😂
Thanks for the links, the "https://www.programming-books.io/essential/go/" is an absolute goldmine.
&gt; why I'm here and telling people don't use my lib, genius 😂 I appreciate the honesty at least. :)
I wonder if there will ever be a point when Golang can't get better in performance. Its already insanely fast. But so cool to see it getting faster and faster each time!
 &gt; If go 1.0 was based off of LLVM, they probably would have started much faster and not had a lot of room to grow. they did consider using llvm &gt;At the beginning of the project we considered using LLVM for gc but decided it was too large and slow to meet our performance goals. More important in retrospect, starting with LLVM would have made it harder to introduce some of the ABI and related changes, such as stack management, that Go requires but not are not part of the standard C setup. A new LLVM implementation is starting to come together now, however. 
https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk
I’m just an enthusiastic Gopher that is praising other people’s educative articles about Golang. I believe this would be considered meaningful to the go community. Aside from mentioning what I’m working on, not one of the curated links is referring to my employer. It’s not containing any advertorial, and the newsletter always contains links that were not to be found yet on Reddit, partly because I also bring non-English Golang content under your attention (but which is translated). I can only say I hope I can continue to share this weekly letter to the community
Some details of your Rules struct look wrong; try ``` type Rules struct { Rules []RuleInfo `json:"rules"` } ``` Its type needs to correspond to what's in the JSON, so it needs to be a slice of RuleInfo objects, not a single string. It also needs to be public (i.e. named `Rules` not `rules`) so the unmarshaller can get at it. 
This really depends on your goals. Do you want to be able to code in go? Or do you want a good grasp of the internals? I prefer a mixture of projects and language deep dives to get comfortable in a language. If I were starting again I'd do something like the following: * tour of go * Super small projects e.g. web server, CLI tool, etc * Go through a couple well known go book. (check this sub for recommendations) * Build bigger projects
[removed]
I suggest never using panic unless there is no other option. Return an error instead. Users of your package, and your future self, will thank you. Where I encounter a package that panics, I tend to replace them. I've not used `panic/recover` as I don't see a need to. The only place I use panic, is in `func main()` where you have received an error and you want to fail because the process can't run for whatever reason. e.g. ``` func main() { config, err := somepackage.NewConfig() if err != nil { // there is no possibility of running without a good Config, so panic. panic(err) } service := sompackage.NewService(config) // this should run forever, maybe an API server. If it ever returns an error up this // this far, panic seems reasonable. if err := service.Run(); err != nil { panic(err) } } ``` These `panic` calls are in the `main`, on the surface and `recover` is not needed.
&gt; Immutable types make APIs less ambiguous and the intentions of the original author clear to everyone . Not necessarily. In my experience Go APIs are far easier to mentally parse and grok than, for example, Rust APIs. Furthermore I have had no issues, not one, where I accidentally mutated a value that was supposed to "be" immutable. This is all anecdotal, but like I said we don't have much, if any, data to conclude either way. &gt; [A value receiver is nowhere near safe, a value receiver is a shallow copy](https://github.com/romshark/Go-1-2-Proposal---Immutability#46-why-do-we-need-immutable-receivers-if-we-already-have-copy-receivers) and is thus prone to pointer aliasing! I understand the technical limitations of the suggestions I put forth; they do not fit the bill but they get the job done to some degree. I'm not saying these are reasons not to have immutable values I'm saying some of the use cases for immutable values are handle by existing language features - it's not all or nothing. &gt; Most Go programmers copy stuff. The code becomes slow and bloated by copy-code. I haven't seen this, so I can't really comment. A strong argument for immutability would be access to algorithms that can only be implemented under the assumption that the values are immutable. For example you can use a cache friendly sorted array for your map implementation if you know your map is read-only. You could then access this map concurrently without requiring any synchronization overhead. In the right circumstance this will probably yield better performance. I'm not sure 'making intentions clear' or 'API readability' are the best arguments for immutability since Go largely tackles those objectives in it's current state, in my humble opinion. That being said, you if you know of some truly unholy Go APIs I would love to see them.
The little go book - karl seguin
Ya, I got that from the title.
how about 1.4 vs 1.11?
There is already an active series of CLs ready to go in master. And performance looks quite improved. https://go-review.googlesource.com/c/go/+/139783/1.
I'm new to Go so you should take this with a grain of salt, but I'm having trouble finding anything that would make me say yes. For your first language, you're not necessarily even focused on that language, you're learning how programming paradigms work. When it comes time to understand while loops and for loops, for example, you want a resource that explains the meaning behind them and ways they are commonly used, whereas every resource I can find would just explain Go's syntax and how it at all differs from other languages. That isn't too say that the language itself is bad for learning, just that there are a ton of well-vetted resources out there for *learning programming* in other languages. I would recommend Python because it has tons of learning resources and Go will be somewhat familiar since it is also fairly C-like aside from the use of meaningful whitespace.
[removed]
What would be you comment on the quality of code generated by llvm as compared to the go compiler, given both use SSA
Always turn on DisallowUnknownFields: [https://godoc.org/encoding/json#Decoder.DisallowUnknownFields](https://godoc.org/encoding/json#Decoder.DisallowUnknownFields)
All serializable/deserializable fields should be exported (e.g : the go name of each field should start with a Capital Letter) https://play.golang.org/p/hRrY4oViLdd
Java has always been slow at compiling code. Go has always excelled at compiling source code quickly.
I’m a big proponent of Golang and have even contributed to development during my 3 year stint at Google. It’s a beautifully pragmatic language but it has taken a huge hit in popularity over the last 18 months. Likely due to stagnating development. Google is starting to move away from it internally as well which means fewer updates in the future. Just before I left Google they were talking about potentially moving over to Rust for some production apps. It was a fun ride but Go is just not destined to be for the long term :(
&gt; Anyone learning golang as your first language ? I think Go is an awful first language, it has a "less is more" approach that is easily confusing for beginners. It makes some pretty opinionated choices for you that you have no prerequisite or ability to appreciate nor understand. I'd strongly suggest doing the programming basics in Python, or perhaps Javascript. Once you understand basic types, control flow structure etc., and can write small programs - then perhaps give Go a shot. But I'm almost gonna guarantee you it's too complicated to start out with. 
I'd echo this. Go is fucking fantastic as a somewhat seasoned dev, you google stuff, you get the official docs and it's short and concise. But it does nothing to help out beginners, whereas Python/Javascript has 15 pages on Google from stackoverflow posts from people with similar issues to yourself. 
&gt; interface{} is annoying when you have to deal with it, like when dealing with JSON you can’t unmarshall into a struct. ??? &gt; Error handling is annoying, especially because finding the origin of the error is unforgivably difficult, but I don’t know how to improve it. I quite like https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package 
I have never understood GOPATH complainers. Do you think other languages don’t have secret environment variables controlling what libraries are used? GOPATH is just better documented. 
Right, try moving python3 installation path
I am completely lost on how to do either of those things. I’ve tried every way I could figure out to append quotes and semicolons :(
Isn't the complaint about GOPATH that you are forced to have your code in `$GOPATH/src/&lt;here&gt;` and that it doesn't work for those people in terms of established patterns?
What about channels ? Channels are not the most performant primitive compared to other languages. Also binary trees (which got improved) and serialization.
The issue with GOPATH is not that there are "secret environment variables controlling what libraries are used", it's that the gopath dictates the path of *source code* which can be especially problematic if your project has multiple languages in it.
Yes. I have ANDROID_HOME, CARGO_HOME, RUSTUP_HOME, PYTHON and other environment variables. I'm totally fine with GOPATH.
&gt; it has taken a huge hit in popularity over the last 18 months It has? I see more and more Go jobs opening up. More and more companies using it. I think we're actually at a point of increasing usage, not decreasing. Go has cleared the "new language" hurdle and now is just another of many choices that companies can feel comfortable making. &gt; Likely due to stagnating development. What? I mean, yeah, there's not a lot of new language features, but... that's kinda nice. I look back at C# and C++ that I spent many years mastering, and I can't even understand half of what people write these days. But we're getting package handling built into the go tool, 1.10 brought incremental builds into the forefront, as get automatic caching of test results that haven't changed, etc. Just because the language itself didn't change, doesn't mean there aren't a ton of environmental improvements. &gt; Google is starting to move away from it internally as well which means fewer updates in the future. They keep hiring people to work on it, so I don't think your view is entirely accurate. &gt; Just before I left Google they were talking about potentially moving over to Rust for some production apps. There are different niches for each language. Rust clearly has some benefits over Go in some areas like safety. Go has benefits over Rust in speed of development, ability for many different developers to meaningfully contribute, and ease of understanding the code. &gt; Go is just not destined to be for the long term I really don't believe that. Go has just gotten 
GOPATH is by no means the best development env experience I've ever had. Everything is in one place, it's fully under your control, it's easy to search, navigate, understand and reason about. It's also simplify tooling's job \*a lot\*. &amp;#x200B; But I witnessed more than once other developers complaining about GOPATH for exactly the opposite reason. Quotes: "Go is messing up with my home directory", "Go changes system directories", "I can't understand what is happening and where my deps are", "I don't wont to change the way I used to work with other languages – my workflow is to choose directory and go git clone". &amp;#x200B; This misunderstanding of how GOPATH is really different, and that it doesn't "messes up" with HOME directory is nevertheless a reason why many devs didn't want to try Go. &amp;#x200B; I hope Go modules will open Go for those conservative devs, but I also truly hope, that GOPATH will stay as a primary way to work with Go. It's so much easier to develop with GOPATH, and I now use this approach even for other projects in other languages (I mean, storing them under [github.com/user/project](https://github.com/user/project) path). My hope is that Go modules and GOPATH will be two ways of doing development in Go and will not conflict with each other.
I'll admit, I write Go code at work for the past 2 years and I often forget that I need to clone into my `GOPATH` and not into my standard `~/code/work` directory.
There's different issues here. The `github.com/user/project` idea is fine and useful. What most detractors complain about is that GOPATH wants you to put all your Go code, for all projects, in a single place. For someone who works on large projects that have both Go components and non-Go components--and you'd like those components to be next to each other--it can be very inconvenient.
While it's not as simple go modules, I have the same "problem". I solved it by having `~/.go/cache` and `~/.go/code`. I then have my `~/.go/code/src` as a symlink to `~/code`. In my `~/.profile` I then have ``` export GOCACHE=$HOME/.go/cache export GOCODE=$HOME/.go/code export GOPATH=$GOCACHE:$GOCODE export PATH=$PATH:$GOCACHE/bin ``` I don't `go install` the tools I used so I don't care if the code bin is not in $PATH. The limitation is that I need to keep the full `~/code/github.com/my/project` so it works with Go, but that's usually how I keep it anyways. It also completely fails to work with godep because godep doesn't like symlinks.
I *think* your questions are sarcastic, but just in case, or for anyone else who's curious... &gt; Is this new? They aren't new, they're just not analogous to `GOPATH`. They're used to customize where rustup and cargo install. If you don't customize it, then they're not set, and use the default locations. https://github.com/rust-lang-nursery/rustup.rs#choosing-where-to-install &gt; RUSTUP_HOME sets the root rustup folder, which is used for storing installed toolchains and configuration options. CARGO_HOME contains cache files used by cargo. Your project source code can go anywhere.
That's a valid complaint, I guess. I've heard more like described in the article – "Go forces me to work in a different way than I used to".
Thanks! I pay a lot of attention to Go because well, when you're working on a programming language, learning from what other languages have done is important. I don't generally comment here except in these types of situations. Same as with /r/cpp :)
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: /r/Serendipity/comments/9mg611/feedback_on_my_kamailio_exporter_for_prometheus/
Why use `interface{}` though? data := []byte(`{"foo": {"bar": 42}}` var v struct { Foo struct { Bar int } } if err := json.Unmarshal(data, &amp;v); err != nil { return rer } fmt.Println(v.Foo.Bar) Think of it like declarative querying. The struct your decoding into is your "query", kind of like GraphQL.
&gt;&gt; arbitrary Arbitrary is the key word there. You declared a specific structure for the JSON to follow... not something dynamic/arbitrary.
I think he is a secret Go fanboy. Just wants to spew BS so that Google engineers prove him wrong :). Reverse psychology ;)
Channels are not the fastest, because they offer a lot of features. If you need them all, they're pretty fast, but if you simply use them as a mutex or something like that, they are pretty expensive. If you are making extremely heavy use of channels, and if they are the bottleneck in your application, it's very likely to be pretty easy to bundle things into larger chunks of work, so I haven't sweated the cost too much in my designs. They not "free", but they're fast enough that they tend to amortize down to "insignificant" pretty quickly if you are doing anything significant with the values on either side, which you probably are. The binaries tree test isn't really a binary tree test so much as a garbage collector test. "Serialization" is basically an ill-defined question as serialization speed comes down to a lot of choices that literally affect the resulting speed by orders of magnitude. It's easy to find various serialization libraries comparing themselves to each other and claiming to be 5x-10x faster on the home page; it's rarer to see them be as up-front with the convenience consequences.
Ok, given these two JSON blobs (but assuming there are a hundred more variations we don't know ahead of time): { "Username":"Awesome" } { "ExampleSite":[ { "NameOfUser":"Bob" }, { "NameOfUser":"Eve" } ] } You can extract the values "Awesome", "Bob", and "Eve" without using `interface{}`?
&gt; Regardless, I would have been quite chuffed if some frontend language came out with their own GOPATH. Maybe REACT_PATH, and in a similar fashion you needed to have the code in that path location. I doubt this will happen because people care about the developer experience rather than just the Google developer experience, in most languages. Go is very different in this regard.
https://github.com/inkyblackness/imgui-go is really coming together nicely
That example has nothing to do with what you described earlier.
Normally, I think `interface{}` is extra annoying because of the `nil != nil` problem, but in this case I would guess the author of the article is simply unaware of the Type Switch built into Go. Without being able to switch over the type of an `interface{}`, it _would_ be completely painful to deal with. No one is suggesting a runtime generated struct that you're trying to reflect over, as far as I can tell. In dynamic languages like Python, you would never have to even deal with the types of members any more than necessary. In languages like Rust, there is a `json::Value` enum that you can `match` on to exhaustively find the result without error. With Go, the type switch doesn't tell you if you're exhaustively matching on all of the possible types that could exist there, since `interface{}` could be literally anything. Without the type switch, you would have to do a _ton_ of type assertions and error handling, which would be majorly painful as previously stated. My guess is still that the author doesn't know about type switches.
The example you wrote is effectively using `interface{}`, when it sounded like you were saying you could declare a struct somehow.
JSON isn't limited to maps though, all of the following are valid JSON: {} [] "cheese" 5 false null Very rarely do I have to deal with unknown JSON where I can't just pass it through to some other service, but it happens (e.g. build a service that generates Go types based on arbitrary JSON).
Well, if it's being generated from JSON, there's a very limited set of types that `encoding/json` will lose. From memory: * `float64` * `bool` * `string` * `nil` * `[]interface{}` * `map[string]interface{}` It's a little annoying, but doable.
As a newbie to Go who actually likes the GOPATH idea and has no problems organizing his projects in this way, I'm wondering what I need to watch out for or change with version 1.11. Can I continue to simply install libraries with go get &lt;location&gt; and they will continue to go into ~/go? What about future libraries? Will it become more complicated?
Disclosure: I am a hobby programer. Golang is easy to read. Somethings are very obvious. Golang does not need more rules/laws. Mostly when checking or studying code, I skip over the comments and read the code anyway. 
A comment is better than no comment imo. As a newbie to go it's really helpful to see comments in my editor when I hover over methods. Saved me from having to go and read through the source code.
I may of misread it but I didn't see anything about how you don't have to touch old code because of its type system. You don't have to worry about the usual hierarchy system. The beauty of how you can reuse types as arguments to create amazing libraries.
There are a dozen different ways to handle it depending on the exact nature of the data and how it needs to be handled. My original example unmarshalling into a plain `interface{}` is kind of contrived since if the data is arbitrarily-formed then you can't just typecast your way through it in a single line -- a more realistic example would use type switches and recursive descent or a stack -- but that's just one approach. Another unconventional approach that nobody has mentioned yet is using `Decoder.Token()` to parse bits and pieces at a time, which is helpful when you don't want to load the whole structure into memory. It's very easy, for example, to parse an array of a million items by using `Token` to step into the array and then repeatedly calling `Decode` to get each successive item.
We run several linters on our (production) Go code. This means we _have to_ have comments on the exported symbols. While techincally _for internal code base_ some (if not most) of such comments are superficial — simply because the packages are very narrowly-scoped (as opposed to those of, say, Go stdlib), — we still put simple comments on everything exported. Still, on some symbols (usually types) well-written comments may be a huge time-saver for those unfamiliar with the code base. Reading code is okay for getting accustomed with the code base, but the problem with this approach is that the code only says _what_ and seldom says _why._ Even though well-written code bases try hard to have their code say _why_ as often as possible, this is not always achievable, and in this case comments help big time. 
That’s excellent. Thanks for sharing! 
My organization’s largest issue with GOPATH is that we don’t use git for source control, so the “github.com/user/project” setup wasn’t immediately beneficial and was in fact immediately annoying. We’ve moved past that now though, and go modules helped a lot. 
The example was not arbitrary though, it was clearly a struct with a nested Foo struct containing a Bar int.
My one complaint about GOPATH is that there is a GOBIN that lets you put bin wherever you want, but no GOSRC/GOPKG letting you put the src/pkg directories somewhere else, so you have to use those names. Still, it's a pretty minor complaint. Most complaints about GOPATH are caused by rigid thinking making people think that the system should adapt to them instead of them adapting to a reasonably sane build tool convention.
The article says "like when dealing with JSON you can’t unmarshal into a struct", and the only JSON you can't unmarshal into a struct is arbitrary. Read the other comments in the thread please. Like this one I wrote: https://www.reddit.com/r/golang/comments/9memo1/go_111_got_me_to_stop_ignoring_go/e7edu7s/
Virtualenv is literally a hack where you copy your Python installation and then source some Bash files because it's so hard to get Python to change where it expects site-packages to live.
That \_does\_ have a predefined structure ahead of time, you're choosing to unmarshal it as a map of interfaces instead of a \`struct{Foo struct {Bar int}}\`. The only cases where I've needed to unmarshal something and some part of the payload was truly arbitrary, I was putting a nested key into a Postgres JSON column. (payload was something like \`{"foo": 1, "bar": 2, "baz": {"qux": 4}}\`, and the postgres table had columns like \`foo integer, bar integer, baz JSON\`). In this case, I unmarshalled into \`struct{Foo int, Bar int, Baz json.RawMessage}\`. I have a lot of qualms with the stdlib JSON package, but I've never needed to unmarshal to \`interface{}\`.
Man, I wish that node_modules accepted an env var consistently. I have a project where I want to move node_modules in order to get better Docker layer caching, and it's basically impossible because everything expects that node_modules is in the same directory as package.json. Some things accept a command line flag/env var, but it's not consistent at all, so you can't really make it happen.
To the contrary, Go is extremely cool with multiple projects having different dependencies. First they recommended just changing GOPATH when you change projects, but people didn't like that, so then they added vendor folders. But even that was too much trouble for people, so now they have modules. It's a problem with three different perfectly acceptable solutions. 
There are a lot of resources, just use keyword 'golang' when searching for anything. Eg: github books, repos, etc. One of them is awesome go. Go will teach you the most important thing: You know when your code sucks when you cannot write tests for it. (me) :D Also go is more of a server-side language, and awesome for cloud development but you also need to learn a js framework for the front-end part. 
I can't think of an example where you would need or want to unmarshal to an interface{}. If the data is truly arbitrary and you want to (for example) count the number of objects in a JSON blob, you should unmarshal the blob into a \`json.RawMessage\` (or leave it a \`\[\]byte\`, depending on whether or not the blob is nested) and use the JSON tokenizer to walk the tree (alternatively, you could define your own JSON AST types that implement json.Unmarshaller). This has better performance than unmarshalling to \`interface{}\` which is going to allocate a bunch of objects that you're just going to throw away, and as you mentioned, dealing with \`interface{}\` is particularly unpleasant.
You're being overly defensive and generally out of line. 1. I _did_ read all of the comments including the one you wrote. 2. The "random commenter" I was referring to was the specific example you and the parent were discussing (it was the GGP of my previous post), so it's very much relevant 3. Regarding the link you posted, even if the JSON _is_ truly arbitrary, you _still_ don't want to unmarshal it into `interface{}`, you want to use `json.RawMessage` and walk the JSON tree with the tokenizer (or unmarshal it into a JSON AST type). This is more performant and friendlier than mucking with `interface{}`. (Also, I already left pretty much the same comment [here](https://www.reddit.com/r/golang/comments/9memo1/go_111_got_me_to_stop_ignoring_go/e7em06w/))
Installation instructions are on [golang.org](https://golang.org). I don't know your timeframe but I'd suggest the Go courses (there are 2, you should start with the foundations course) by Todd McLeod. Mind you it's longwinded but it's a good course. 
I have a few weeks! Thank you for this :) I'm one step ahead already! 
&gt; The "random commenter" you are referring to was the GGP of my original post, so it's very much relevant. I didn't say it was irrelevant, but as I said in the comment that _I_ had linked to, their example code was abbreviated. The point being made is that it is dynamically accessed, so there could be loops, conditionals, etc. It isn't something that can be deserailized into a fixed structure. Your initial reply to me showed that you had not read that far into the comment chain, and that you didn't take a very generous interpretation of the code example that was posted by that random commenter. As I also said, what the article is discussing is extremely relevant. Given the context of the article, it's clear that the code example *is* arbitrary, and not supposed to be interpreted as something which can be translated into a fixed struct. &gt; As I mention at the end of (3), &gt; Also, I already left pretty much the same comment already left? That comment is timestamped 10 minutes _after_ my reply to you. I left my time machine at home, so I forgot to have already read your future comment before replying. &gt; generally out of line. I was busy, so I didn't have time to re-explain everything, so I linked you to some discussion you didn't seem to be accounting for at all. I'm sorry if that's "out of line".
What APIs are you querying where a given input can have such wildly different schemas for output? An API that behaves that way is broken, point blank.
No API would respond like that, but crawling some large JSON store could have data in various formats. It’s easier to imagine with a web crawl of HTML, but there’s no reason someone couldn’t have a large, non-homogenous collection of JSON laying around.
Hey 👋 The [tour](https://tour.golang.org) is always a good place to start if you’ve not looked at it already. But I found [gophercises](https://gophercises.com) really good. All the best 😁
a very basic proyect that implements go.mod?
I found [https://gobyexample.com/](https://gobyexample.com/) to be pretty helpful for ramping up on Go.
👉**Free, visual and detailed:** r/https://blog.learngoprogramming.com
You can try free "Essential Go" book https://www.programming-books.io/essential/go/
&gt; I have never understood GOPATH complainers. Do you think other languages don’t have secret environment variables controlling what libraries are used? GOPATH is just better documented. No they "all" don't. Emphasis on "all" here, Some will put all packages fetched in a subdirectory of your project by default.
It's good it works for you. It doesn't work for me.
Mostly how to keep the file open while calling writes to the file.
I suppose like all development and tooling, it evolves, sometimes in directions some people like, and sometimes in directions some people don't like. Like the old saying, "Ya cant please everybody" ¯\\\_(ツ)\_/¯
I guess ql is one, but that may be overkill.
Personally I think boltdb or badger meet searchable requirements just fine if you use bleve for searching.
In terms of reading material, The Go Programming Language (e)book is hard to beat. It goes through simple and progressively more complex examples and is written by some of superheros of computer science. It's free to [read online](https://www.gopl.io), but I suggest getting the physical book if you learn well that way. It's very well written and formatted. Don't bother with an IDE: it'll only slow you down in the beginning. Just use your favourite text editor and a good terminal. Sublime Text or Visual Stusio Code are good choices. Your project idea is perfect. Try implementing some sort of rate limiter once you get the core idea working. Like only fetching the actual site once every 5 seconds. To get started, try getting a small hello world webserver and slowly build up from there. The [gorilla web toolkit](http://www.gorillatoolkit.org) is great for Go beginners.
Ah, nice work!
Hm I'm really not going to be storing that much data, so bleve on top of bolt may still be overkill (I could be overthinking it though, I'm new to go). Another commenter mentioned tiedot, and that may be the way I go. This (os.UserCacheDir()) is really nice to know about though, thanks. 
Oh tiedot seems like it may be perfect, thanks!
[removed]
FWIW, my brain did initially parse the title as go1.10 vs go1.11, so I appreciated the comment.
Bleve is just an upside down index that's stored in a bolt db itself, and the defaults are sensible, so any simpler would probably just be iteration through all stored values, which means anything would work. Note that os.UserCacheDir() was added in Go 1.11 if version is an issue. Don't forget to make a subdirectory for the specific application.
[removed]
Thank you for the long response! So that's got me started. I'll be fiddling around in a text editor then. Probably Atom. I love E-books. Usually I just read them and take some notes in a word doc to use later as a reference. I also like them because I can find them online and not have to pay $200 for them at the student store. LOL. This will work well! I'm glad my project idea sounds good to you! Now I'm feeling super confident about it! Thank you so much :)
Ooo another book link. Hey, thank you!
Ahhhh, juicy link DrTran!
It'd be great to integrate this into metalinter. 
This is a good piece of writing, but if you have a problem with Go's old dependency management then something is probably wrong with you or you've just never had to experience Java's soul destroying ways.
I was talking about necessity of environment variable. Previously you could use different GOPATH per project as well as multiple paths in GOPATH. There was no need to lump all your code in a single location. Combined with vendoring it was a good solution overall.
[removed]
If you want to look [key-value stores in more detail](https://github.com/Xeoncross/go-embeddable-stores) you might find they are more powerful than you expect. K/V stores allow searching by values, using indexes, saving objects, replications, distributed storage, compact storage, flexible or strict schemas, ORM's, etc..
The help pages for the `go` command line tool are also pretty useful. `go build` and `go test` are going to be the most common ones you use.
[removed]
&gt; GoGi uses the GoKi tree infrastructure to implement a simple, elegant GUI framework in full native idiomatic Go Please, we don't need more artisanal organic crafters. Use words with actual, evaluatable, semantics.
Excellent! Sounds great :) Thank you
&gt; I'm wondering what I need to watch out for or change with version 1.11. In a word... nothing. Everything continues to work exactly the same. Go modules are disabled by default if your projects are in GOPATH.
GOPATH *really* falls apart when you have to make it work with various CI/CD tools. I've used the following for GOPATH builds: - Jenkins pipelines (in docker and out of docker) - Bitbucket pipelines - Travis CI - Gitlab CI Jenkins in docker is an absolute nightmare due to permission issues, but I eventually did work around it. You can't just set your build directory to GOPATH/src/$org/$repo_slug because docker will create the parent directories with root permissions and then go's hardcoded cache/whatever directory operations will fail with permission denied. You can make the directory tree, symlink your workspace to it, then cd to the symlink. But the official go binaries only have the root user, so you'll need to create a custom docker image with a UID matching your docker host system and a directory tree for GOPATH or at least HOME. The others are much easier, but it seems that they run builds as root (in containers) which is a questionable trade-off for the ease of use. In all of them, you've got to set GOPATH, symlink the build directory to GOPATH, set any GIT_ASKPASS type stuff, and then run the build. It's a lot of boilerplate for every build. With go modules, you run `go build` and it works on all of them out of the box.
Maybe; but that will work only on Linux.
sqlite [https://github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3) It's SQL but in a very light package. Whichever database you choose you will have to store it somewhere. You can use [https://github.com/shibukawa/configdir](https://github.com/shibukawa/configdir) to get the OS specific path or use relative to the working directory or [Executable location](https://golang.org/pkg/os/#Executable) depending on your use case. 
This could really use a better name. Even jsonschema2go would communicate more; now the name sounds like a library for using json schemas.
[removed]
[removed]
Oh, to be in your most enviable position of learning new languages, the huge open road of computer science still an undiscovered and inviting path. You make me nostalgic for my one early career. &amp;#x200B; But I digress before I even begin. First off, Go is pretty easy if you have a C background, which C++ and Java provide to some degree. It doesn't sound like your project will require concurrency design, at least in the beginning, so I would focus on building the proper structs and methods required for the functionality you want to implement. Clearly define what each aspect of the process you need to perform to make your website check, and determine if a struct is needed or not. &amp;#x200B; Because of the simplicity of Go (just structs and functions), I'd learn some of the language-specific aspects of Go by visiting these two websites: examples [https://gobyexample.com/](https://gobyexample.com/) and best practices [https://github.com/golang/go/wiki/CodeReviewComments](https://github.com/golang/go/wiki/CodeReviewComments) &amp;#x200B; Finally, one of the most important things a Software Engineer needs to be able to do is to think clearly. So let me ask you a question... Does your project, as you have described it, really solve the "***downforeveryoneorjustme***" question? Or does it do something else instead? Being clear on what you are solving for, or not solving for, is one of the most critical lessons for a Computer Science student. &amp;#x200B; Please feel free to answer me here, or ping me directly for any other questions you may have.
[removed]
Dont forget, a lot of database's under the hood use key value pairs, but it is how they organise the data and make it available. I use boltdb, and I can search on any particular value, as I have created key/value indices etc. albeit, its a little more work up front, but if the database schema and size ain't going to be large, its a great way to go. You might discover they are much more powerful than you might think.
Commenting because it’s my personal opinion that go is great for the specific questions you raised. For how to build and run it, go binaries are a lot cleaner than say java jars. No jre required just “go build” and then execute the compiled binary. I use goland for my ide which you can get for free with your edu email. It’s amazingly easy to compile go to different OS/architectures with go build options. Again just my personal opinion coming from a java background, been working with go for 6 months and love it
Best advice: Stick to the official documentation https://golang.org/doc/, especially: * Getting Started * A Tour of Go * How to Write Go Code Don't try to be clever: Install the official tools according to the official documentation (not some random tutorial on the internet or through your package manger). Don't try to be clever: Set up your workspace and folder structure as described in How to Write Go Code (not some random internet tutorial or how you think it might work just because Java works that way). Do not bother to set up an IDE if you need to learn the language fast (configuring and learning an IDE takes long and adds additional complexity which might distract from the actual language). 
this is the easiest choice imo and will make you almost feel like you're just on a server with mysql ;) it can handle pretty decent sized databases without big performance hits as well
Your comment history shows that you keep saying this, but most people's experience seems to contradict this. Where are you getting this info? 
I'll revisit this in the morning. I studied data structures with C++; hopefully that is enough. "Does your project, as you have described it, really solve the "downforeveryoneorjustme" " The project design isn't supposed to be a clone of downforeveryone. However, it addresses a similar issue (A lack of connection: Is this website the issue or is it just my connection?). My goal is to create a program that connects to websites and can record data. I'm more interested in learning the 'moves' of Go than making a nifty program. Maybe I should try to do both and tweak the concept! I'll definitely be using these resources! Everyone on this sub has been so helpful! Thank you so much :)
"It’s amazingly easy to compile go to different OS/architectures with go build options." That's very good news! I'm interested in IoT, so portability is pretty important.
The program was successfully downloaded to your computer, but Go cannot compile it because there is a problem initializing Termbox, which is one of the dependencies of this Tetris project. You can see the "panic" referencing line 124 here [1]. The error message _"handle is invalid"_ would benefit from more information. It's quite difficult to say what the problem is simply with that small text. The best I can do is give you a link to the block of code that is triggering that panic in your system [2]. What I would do in your case is to start a debugger in Termbox and see where it panics. Or start adding a bunch of _"fmt.Println"_ _(for lack of a proper debugger)_ and see where that leads you. Something tells me that the problem is with one of the _"syscall.OpenFile"_ that is trying to open the `/dev/tty` in your computer. Good luck! [1] https://github.com/k0kubun/tetris/blob/a9f0ec7/tetris.go#L122-L125 [2] https://github.com/nsf/termbox-go/blob/b66b20a/api.go#L24-L110
The program was successfully downloaded to your computer, but Go cannot compile it because there is a problem initializing Termbox, which is one of the dependencies of this Tetris project. You can see the "panic" referencing line 124 here [1]. The error message _"handle is invalid"_ would benefit from more information. It's quite difficult to say what the problem is simply with that small text. The best I can do is give you a link to the block of code that is triggering that panic in your system [2]. What I would do in your case is to start a debugger in Termbox and see where it panics. Or start adding a bunch of _"fmt.Println"_ _(for lack of a proper debugger)_ and see where that leads you. Something tells me that the problem is with one of the _"syscall.OpenFile"_ that is trying to open the `/dev/tty` in your computer, probably because you are on Windows and the code seems to assume an Unix system. Good luck! [1] https://github.com/k0kubun/tetris/blob/a9f0ec7/tetris.go#L122-L125 [2] https://github.com/nsf/termbox-go/blob/b66b20a/api.go#L24-L110
Thanks for the review. Feedback incorporated. Results below Before &gt; go test -bench . goos: linux goarch: amd64 pkg: github.com/httpimp/bloomfilter BenchmarkSeparateTestAndAdd-2 1000000 1265 ns/op BenchmarkSeparateAdd-2 2000000 702 ns/op PASS ok github.com/httpimp/bloomfilter 3.381s After &gt; go test -bench . goos: linux goarch: amd64 pkg: github.com/httpimp/bloomfilter BenchmarkSeparateTestAndAdd-2 1000000 1139 ns/op BenchmarkSeparateAdd-2 3000000 604 ns/op PASS ok github.com/httpimp/bloomfilter 3.572s 
Hey guys, I'm happy to announce go-astiencoder, an open source video encoder written in GO and based on ffmpeg C bindings. Its goal is to assemble the full audio/video encoding process in GO for people looking to: - understand how such a process work in detail - integrate their video encoder in a GO ecosystem - visualize their encoding workflow and statuses/stats of nodes in real time - communicate with their encoder through an HTTP API + websocket to tweak behaviours in real time - use native GO subtitle libraries like astisub - build their own video encoder and take control of its workflow Indeed resources to assemble such a thing in GO are scarce and I think the GO community could benefit from this project. Right now I've implemented basic examples of remux, thumbnail extraction and h264/aac encoding. I'm more than welcoming contributions. Cheers PS: the goal of this project is *NOT* to replace ffmpeg :D
Hey guys, I'm happy to announce go-astiencoder, an open source video encoder written in GO and based on ffmpeg C bindings. Its goal is to assemble the full audio/video encoding process in GO for people looking to: - understand how such a process work in detail - integrate their video encoder in a GO ecosystem - visualize their encoding workflow and statuses/stats of nodes in real time - communicate with their encoder through an HTTP API + websocket to tweak behaviours in real time - use native GO subtitle libraries like astisub - build their own video encoder and take control of its workflow Indeed resources to assemble such a thing in GO are scarce and I think the GO community could benefit from this project. Right now I've implemented basic examples of remux, thumbnail extraction and h264/aac encoding. I'm more than welcoming contributions. Cheers PS: the goal of this project is *NOT* to replace ffmpeg :D
I like https://github.com/google/gxui a lot more than imgui-go. It's written in Go and has a ton of awesome examples to look at.
Hi, can you share your code?
Thats gonna be tough, you'll need a way on the server side to store cancellation tokens for uploading data. That might be the way to go. 
You need to have the main function wait for the go routines to complete before exciting
I'm using my own crypt wrapper. Adding a rehash check (a fine idea) is no problem. You can find it at https://gitlab.com/paars/bakyun/backend/tree/master/util It's the ucrypt files.
I thought `fmt.Println` was threadsafe^(1)? The `fmt.Print*` family of functions only ever do one write to `os.Stdout` per call and that should be safe even though the order of individual writes is not guaranteed (they will be serialized by the OS). I can't right now find any explicit statement to that effect in the documentation, but I'm still pretty sure that's right. That would mean you don't need the `Mutex` here. As to your actual question, you should use something like a [`sync.WaitGroup`](https://golang.org/pkg/sync/#WaitGroup) to make the main goroutine wait for the others to finish. Check out the example in the documentation for that function and you'll see something very similar to your code. ^(1): Well, as long as any `Format(f State, c rune)`, `GoString()` and `String()` methods on the stuff you're printing are threadsafe (or at least the ones actually being used by your invocations).
If you know at least one programming language before and have some basic understanding of HTML/HTTP I always suggest https://golang.org/doc/articles/wiki/ as a Go starting point (after installing the compiler). Real life, not too simplistic and very easy. 
You can achieve this pretty easily using a context. Watch through this and Francesc actually has an example doing exactly what you want. https://www.youtube.com/watch?v=LSzR0VEraWw
What?
Except: &amp;#x200B; Unfortunately due to a shortage of hours in a day, GXUI is no longer maintained.
Author here. One problem is that even if a subset of the JSON is undefined, unmarshalling it, editing it, and marshalling it again is a lossy process. Another case where this bit me was on [AWS CloudFormation](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-reference.html) templates at work. I needed to change only a small portion of a template, but to unmarshall it I would have had to write up literally hundreds of types plus some custom bullshit to figure out which type a member of an array was assignable to - backwards and forwards - and it would have started silently losing data if the CloudFormation API ever changed.
Author here. I use the errors package, too, it's pretty great. The only problem is that it's not a language-level feature, and you have to rely on the source of the error to play ball, which may not be your code.
Oh. :( Well, I should I have noticed that and the fact that the last commit was 3 years ago... My perception skills are amazing.
So just use actual English words. If you're trying to explain something as opposed to specify it then your aim should to be understood clearly, not to save four letters.
That's fair, but I find that there are similar challenges in a lot of other languages with libraries and frameworks. If a library isn't yours, and you need to know the line number where an error came from, it's a failing of the library design/implementation. However, Go does less for you than some other languages. Similar things can be true in Python too, for example - I've worked with code that caught an error, then lost it in the except blocks, or even worse, threw an exception in the except block. There's also the code that puts a load of dict lookups on the same line and blithely raises an IndexError. Raised exceptions, like Go errors, can be remarkably uninformative about how the failing relates to the input that was given, especially in a language that doesn't always give strong hints about what it accepts as input.
I wrote a little dbms called Hare ([https://github.com/jameycribbs/hare](https://github.com/jameycribbs/hare)) that might interest you. It stores it's data in newline-delimited json files and allows all the common CRUD functions. &amp;#x200B; It works well enough in my limited testing. I keep meaning to clean it up a bit more and announce it on golang nuts, but have not yet had the time to do that.
It's worth only if you need: * portability * fast compilation * no gui * probably easier manteinance Otherwise don't. There is not magic oop to golang pattern, you need to understand what application does.
Heh I’ve been there. These GUI libraries are notorious for being abandoned . Turns out it’s not that easy.
You're still missing the point. By using the specific way of writing those things, they refer to the data structures of the scheduler, not the general purpose words they are abbreviations of. If the article said "processor" and "machine", it would be ambiguous. Maybe you'll like this explanation more: https://rakyll.org/scheduler/
Ah. Yeah, this is an interesting use-case. There were similar issues with XML for SAML that I recall. The vast majority of libraries in any given language are not typically designed with this sort invariance in mind, they're designed for unmarshalling as efficiently as possible where the goal is for APIs with structures. Have a look at something like https://github.com/tidwall/sjson and https://github.com/tidwall/gjson There are also things like https://github.com/mitchellh/mapstructure for improving handling of unknown structure by building on top of interface{} unmarshalling, and knowledge of json.RawMessage and json.Unmarshaller are also useful for more complex cases.
No, a garbage-collected language like Go will never match a manually managed one like C++ for speed and memory consumption. If you’ve already incurred the cost of managing memory by hand, it’s working properly and not leaking, why throw it away now? Rust is a more logical upgrade path than Go for C++.
If performance is critical then I'd look into Rust as well. If you (OP) want to make your codebase more readable, more portable and a lot easier to maintain in the future, then I'd look into Go. So tell us: What kind of software is it? And what aspects do you need/want to focus on?
Thank you for your help, the program that I’m using Git Bash is supposed to be emulating a Unix system if I remember correctly
This just came up: https://github.com/fyne-io/fyne
[removed]
Go binaries are linked staticly (without cgo). This means that a Go binary does not have any runtime dependencies and the system does not require a loader. Also included in the binary is the whole Go runtime (GC, allocator, scheduler) and a lot of debug info. Linking a hello world program static in C results in an about 750KB sized binary (Linux with gcc+glibc).
Versus DICs, I'm fine with this. However, it doesn't seem to cover close/cleanup func handling during premature failure. If leveraged granularly enough to allow for useful cleanup handling, it will likely lose most of it's usefulness. It's at least worth a try. Maybe something can be worked out by passing in a done channel or context type for cancellation.
It's kind of legacy app,Frequent cause of deadlocks and difficultly with feature addition and debugging 
How does it extract thumbnails? I find ffmpeg thumbnail extraction is not very accurate so I create a one second clip and then convert that to JPEGs to get my thumbnails at an exact time point 
Thanks for the detailed explanation! &gt; Linking a hello world program static in C results in an about 750KB sized binary (Linux with gcc+glibc). TIL Is there anyway I can extract the contents of the binary &amp; inspect ?
In the case of thumbnail extraction here are the steps: - your input is demuxed which means that all AvPackets are extracted. At this point, the video is still compressed. - the AvPackets are decoded into AvFrames. At this point the video is uncompressed - if you desire only 1 thumbnail per second, a filterer drops the AvFrames that are useless - the AvFrames that are kept are encoded using the "mjpeg" encoder into AvPackets - avPackets data is written into .jpeg files Does that answer your question?
I approve!
Here's an implementation of `io.Reader` that uses a `context.Context` https://play.golang.org/p/Bah5Bx2MZlz
At least on Linux the file format of executables is ELF and there are a bunch of tools to inspect these files. One that is present on most machines is readelf.
&gt; Is there anyway I can extract the contents of the binary &amp; inspect ? What do you mean by _"content"_? The source code? You can convert the binary into assembly using this: go build -o a.bin -- main.go go tool objdump a.bin 1&gt; b.asm xdg-open b.asm || open b.asm
Is it faster than doing it with ffmpeg? Actually I will create 25 thumbnails for 1 second by creating a 1 second clip and converting to jpeg, then display them, but it is quite slow And also I think that's how I get 1 thumbnail and display it as ffmpeg is not accurate I'm writing a GUI for ffmpeg
&gt; Why so many assumptions in this comments? What if OP app is IO bound but is written in C++? &gt; &gt; the irony. You are making assumptions as well. Until the OP makes it clear what kind of application it is, which he didn't, anything goes.
the runtime.
Go does allow threading and goroutines which usually manage to avoid deadlock situations - via channels, and muxes. But it has to be said that both C &amp; C++ have many mutex , locking, and threading options, so the implementation language _shouldn't_ matter so much. If the problem is that nobody understands the system as a whole, so they can't fix the deadlocks then I'd guess that porting it would be equally hard - unless you have a decide set of requirements and the implementation can be tested against them sanely. Legacy codebases are often tempting to rewrite, I think half the time the rewrite is a good idea, and half the time it would be better to write test-cases, documentation, and avoid throwing away all the lessons that have been learned and merged in over time. Without more details it's hard to know what situation you're in, but patterns aren't so different, start with the standard learning resources and tutorials and that should give you a decent flavour. 
Are you sure that sqlite is pure go? Without additional libs/dlls, just go get, go build and done?
In all honesty right now it's not faster than doing it with ffmpeg. Furthermore right now I'm using a "minterpolate" filter which is not the best way when the framerate you wish is lower than the input framerate.
For me it's the kind of "pain" you only really feel once. It's typically code you dont change all that much anyway.
It definitely isn't pure Go. It relies on a cgo interface to the sqlite3 C library. It should still be seamless for most installers, if you have a copy of the sqlite3 library or have a compiler installed. &amp;#x200B; When I only want to use pure Go libs I use bolt with Storm as a query language and indexer.
Go Cloud/Wire dev here! That's a totally reasonable perspective to take and is a use case that we've kept in mind. Because Wire providers are just plain Go functions, any application that wants to wire up their dependencies by hand will always be free to do so.
Neat project. You might find some elements here to be helpful. func TimeToEmoji(timeString string) (string, err) { timestamp, err := time.Parse(time.RFC3339, timeString) if err != nil { return "", err } clocks := [...]rune{"🕛🕐🕑🕒🕓🕔🕕🕖🕗🕘🕙🕚🕧🕜🕝🕞🕟🕠🕡🕢🕣🕤🕥🕦"} hour := timestamp.Hour() minute := timestamp.Minute() emoji := clocks[(hour+(minute+15)/30)%12] return emoji, nil }
It's statically compiled with cgo, assuming that you have a compatible c compiler in your path, you can go get and build just like any pure go library. 
So excited about this - finally stable and cross platform gui automation is maturing properly. Like cross platform AutoIt!
Neat project. You might find this code snippet to be helpful. func TimeToEmoji(timeString string) (string, err) { timestamp, err := time.Parse(time.RFC3339, timeString) if err != nil { return "", err } // Repeating the string is arguably easier to understand. clocks := [...]rune{"🕛🕐🕑🕒🕓🕔🕕🕖🕗🕘🕙🕚🕧🕜🕝🕞🕟🕠🕡🕢🕣🕤🕥🕦🕛🕐🕑🕒🕓🕔🕕🕖🕗🕘🕙🕚🕧🕜🕝🕞🕟🕠🕡🕢🕣🕤🕥🕦"} // New emoji every 30 minutes t = (60*timestamp.Hour() + timestamp.Minute()) / 30 emoji := clocks[t] return emoji, nil }
Can you: import "github.com/username/myutils/common" ?
Go already has an elegant solution for this. Dependencies can be injected manually by using interfaces. I would not use this software. 
Use semaphores — http://www.golangpatterns.info/concurrency/semaphores
This tool does the same, but generates the code that you would have to write manually. The result looks quite similar to what I would write myself.
Recently tested it on Windows 10. Installed mingw-w64, made sure `C:\mingw64\bin` was on PATH, ran `go get -u github.com/go-vgo/robotgo` and bam, it just worked. Really nice!
They define what the letters mean at the top of the article. Each one has a concise meaning. Just use those words.
It's more efficient to only loop once. Using a [scanner](https://golang.org/pkg/bufio/#Scanner) may be useful here. That link has some good examples, you may want to consider doing something like: func DoThing(r io.Reader, send func(tickets []Ticket) error) error { // create a slice of 100 tickets (e.g. tickets := make([]Ticket, 100)) // keep track of your current line number (e.g. var line int) scanner := bufio.NewScanner(r) for scanner.Scan() { // convert scanner.Text() into a Ticket object // add ticket into the slice at the appropriate index (e.g. tickets[line%100] = ticket) // every 100th line, call the "send" function, e.g. if err := send(tickets); err != nil { ... } // you'll need some extra logic to ensure the last tickets get sent } return scanner.Err() }
That being said, if efficiency isn't a concern, it's probably a good idea to read the entire file first so you don't potentially leave a file open for a very long amount of time. 
You can define a namespace, any namespace, for your whole project in your `go.mod` file. Say your repo has this structure: ``` go.mod util1/ util1.go util2/ util2.go common/ common.go ``` just have this in your `go.mod` file: ``` module mypkg ``` Then you can use `import "mypkg/common"` as you would previously use `import "common"`.
**Welcome to contribute code to make it more perfect.**
[removed]
No need for that line%100 trickery and the room it leaves for mistakes. lines := make([]Ticket, 0, 100) for scanner.Scan() { ticket, err := parseTicket(scanner.Text()) if err != nil { ... } lines = append(lines, ticket) if len(lines) == cap(lines) { if err := send(tickets); err != nil { ... } tickets = tickets[:0] } } // handle partial last chunk if len(tickets) &gt; 0 { if err := send(tickets); err != nil { ... } } if err := scanner.Err(); err != nil { ... }
I would say you should be clear enough to help a valid user without giving too many hints for something or someone nefarious to take advantage of.
&gt;Hope this helps. Certainly. This is similar to what I do in other languages. This is certainly doable in Golang, but some language support would have helped. Thank you
This is it, thanks! I was expecting golang could do better but havent found much information about After.
Very interesting. If I recall, the [gokrazy](https://gokrazy.org/) project is a full userland for the Linux kernel. I wonder how well these would work together.
Awesome article. The slides were interesting. For anyone who is interested: https://github.com/mit-pdos/biscuit
I think there’s a fundamental confusion behind your question. Your link refers to Go internal error handling, while your question refers to reporting errors to an API consumer. The former is very Go oriented while the latter has nothing to do with Go necessarily. Your first step should be to clarify this confusion IMO.
Ben Johnson's design can be accommodated to do this: https://middlemost.com/failure-is-your-domain/
Not sure how you can use OpenGL in a browser context. You have to translate those calls to WebGL first. 
This looks great at a glance; I wonder if it could (eventually) help replace this madness: [https://github.com/mholt/vidagent/blob/b49214254eb15eb3f8eba9d763e108db2dd1dcaf/cmd/vidagent/main.go#L276-L332](https://github.com/mholt/vidagent/blob/b49214254eb15eb3f8eba9d763e108db2dd1dcaf/cmd/vidagent/main.go#L276-L332)
50 shades of Go?
This is really interesting. While I made really good progress with the replace command in each module file go.mod for util1 module util1 require ( common v0.0.0 ) replace common v0.0.0 =&gt; ../common
I would prefer to put `go.mod` on your project root instead of putting it in every sub-directories, but that also works.
Maybe for performance while involving millions of timers, see [Benchmark](https://github.com/RussellLuo/timingwheel#benchmark).
I've tried uninstalling and reinstalling everything and for whatever reason this still refuses to work when everything else does. I refuse to give up learning how to do this but its certainly discouraging to get stuck like this so early on. &amp;#x200B; Does anyone have any ideas of somewhere I could find somebody to connect to my computer to help me figure out whats going wrong? &amp;#x200B;
Unless you're developing the rate limiter as an exercise, I'd recommend you use [`/x/time/rate`](https://godoc.org/golang.org/x/time/rate) Initialize with: lim := rate.NewLimiter(rate.Every(time.Second), 1) And before each task, call: lim.Wait(ctx) If you do not have a context, create one with `context.Background()`
slightly off topic but maybe relevant for you, you can greatly reduce the size of a go binary with some tricks: https://blog.filippo.io/shrink-your-go-binaries-with-this-one-weird-trick/
I just send a JSON structure in payload of a 4xx response. This structure contains an error ID (a number or unique string) for easier handling in client app code, an error message for humans and sensitive details if debug is enabled. The HTTP status can be well known (ie Bad Request) or something not defined by HTTP, like 490. If error is server-side, like database connection failure, I use 5xx status code.
Interesting, i'm going through your code
I think this example would help you: [https://gobyexample.com/timeouts](https://gobyexample.com/timeouts) Use channels and this would be very easy. If you'd like to be a bit smarter (make it possible to stop the task itself and not just the reading loop, read a bit more about the context package: [https://blog.golang.org/context](https://blog.golang.org/context) . You could cancel the context or add a timeout and check that in the task too, so it wouldn't work unnecessarily.)
If you are trying to reinvent cron, take a look at what it can do, implement it and make it better. For example, sending command output by email. 
Tried it out, expecting problems, but it built and booted just fine!
Well I've not dived into your project that much so I may miss something. But from what I see you would gain some and lose some. Indeed you would be able to play with PTS/DST more easily (as easily as a SetPts function) as well as play with frames directly but you would need to install ffmpeg C bindings instead of "just" playing around with a static library.
Why not use a time.Ticker?
Hi, my Ebiten using WebGL can be compiled to Wasm: &amp;#x200B; Ebiten 2048 example via [jsgo.io](https://jsgo.io) by Dave [https://jsgo.io/2893575ab26da60ef14801541b46201c9d54db13](https://jsgo.io/2893575ab26da60ef14801541b46201c9d54db13) Ebiten: r/https://github.com/hajimehoshi/ebiten wasmgo: [https://github.com/dave/wasmgo](https://github.com/dave/wasmgo)
thanks for the link !
Thanks. Actually I looked at the example before and that what made me confused I guess about it. The context is an interesting add on. 
Bigger writeup please!
One more thing. It looks like steps within a task are executed no matter what. This is possibly destructive when further steps depend on the previous ones. Steps in a task should be run sequentially and execution should stop on first error, marking entire task as failed.
I think it will behave same as AfterCh?. Actually I completely misinterpreted the point about the timer to start when it is created, due to a lack of channel understanding. &amp;#x200B;
well, more a misunderstanding about how timer channels work.
*OT: aren't you tired of "Blazing fast"?*
Go is awesome to use and does help to get your job done in record time. The go built binaries have a small memory footprint and are easy to move to other computers and run elsewhere. I rewrote a cli tool that was in go into c++. I was masochistic and painful, but I did benefit from it because as I was rewriting it, I was laying out reuse api's and creating c++ libraries purposed for other c++ domain specific tools. The bottom line: Everything I did with go in the first round, I accomplished in c++ in the second round and clarified some difficult to read code along the way(well worth it). Is the c++ version faster? Probably. BUT lucky for me, I came across an article about rust being faster than c. I was going to rewrite more go-based tools in c++ reusing the c++ apis from the second round, but that article changed my mind and now I'm veering towards learning rust and to reapply that go-to-c++ experience towards a go-to-rust experience. http://dtrace.org/blogs/bmc/2018/09/28/the-relative-performance-of-c-and-rust/ I'm about 33% done my go-to-rust re-working/re-use infrastructure and learning a lot about the rust compiler error messages. I'm learning a lot about how competitive rust is with go with respect to install/setup/package management. In fact the first time I heard about rust was when rust's was discussed as the inspiration for golang's new package versioning capability introduced in go1.10/go1.11. I'm learning to appreciate the equivalent of go's "go get PACKAGE" is embedded in rust's equivalent of "go build" command. You don't need to "go get" in rust, but you need to include the package name/version within a special build description file called Cargo.toml. When you run rust-equivalent of "go build"(IN RUST "cargo build"), it takes care of fetching the package sources from crates.io, and builds everything just for your particular build. In terms of ease of use, it compares well with go. Installed the rust and test packages on 3 different hardware targets/different operating systems to see if it was as graceful as go: fedora rawhide x86_64, win8.1 x86_64 msys2, odroid-c2 archlinux arm64. Rust was easier to install/uninstall than go. Rust was slower to build binaries than go, but the perceived subject runtime of the rust binaries were faster. I will be doing more thorough performance comparisons across the go/c++/rust later, but my gut tells me already that rust runs faster. Let me at least clarify my motivation for doing all this. Before the application specific go built binaries existed, the tasks were taking 6 to 8 hours to complete in sequential order. With the go built binaries being used, it takes about an hours give or take 10 minutes. The quicker the tasks get done, the quicker I can go home to my family. After having achieved that goal, I'm finding other means to shave that time even more via hardware and other software improvements. Hardware$$$ is a tough sell to management, but they're paying me to be there so I might as well find other ways to improve it with more software which is why the experimentation with c++ and rust happened. I've been a go fan for 8 years. The reason I became a go fan is because I'm seeking for perfection as a coder and to get things done. I've experienced painpoints with go for building user-interfaces across all os'es and all hardware enough to motivate me to look at other languages and other user-interface bindings for those languages. rust with qt is as painful as go with qt, but this might come as a surprise but the build time to get a rust/qt binary is shorter than a go/qt equivalent. That's why I am starting to veer towards rust. It's not easy because I'm learning to dance with the rust compiler and how to create reusable libs(aka rust crates), but I believe it's worth it for rust's runtime performance/safety. It would also be interesting to see qt itself rewritten in rust. I wonder if there is any effort toward this being done already.
This is an excellent article. Thank you for sharing. 
Nice write up, but in all honestly I don't find the idea of switching from Kotlin to Go that appealing. Sure if you are starting new you can choose Go over Kotlin. But if you are already using Kotlin and needed more performance I would choose Rust over Go anyday. 
Inspired by \[my own question here\]([https://www.reddit.com/r/golang/comments/9mnslm/anyone\_using\_argon2multihash\_to\_store\_passwords/](https://www.reddit.com/r/golang/comments/9mnslm/anyone_using_argon2multihash_to_store_passwords/)) and the code from /u/[KuraBloodlust](https://www.reddit.com/user/KuraBloodlust)
Hi, thank you for taking a look. &amp;#x200B; \&gt; Any chance you can make available a separate package from this that simply provides the graphics API? \&gt; It would be nice to have each area, e.g. audio, graphics, etc a separate packages for cases when only one or the other is needed. \&gt; I want to do some lightweight procedural drawing without any other dependencies and I think this would be useful to a great deal of people &amp;#x200B; Not sure what you meant by the graphics API (since Ebiten is already a graphics API library, and the audio package is separated). As you mentioned 'lightweight', probably you would like to have bare WebGL binding for Wasm, right? There is a GopherJS binding [https://github.com/gopherjs/webgl](https://github.com/gopherjs/webgl) but as far as I know there is no for Wasm. I think there are some options you can take: &amp;#x200B; 1) Write your own binding with syscall/js 2) Port that github.com/gopherjs/webgl to Wasm using [github.com/gopherjs/gopherwasm](https://github.com/gopherjs/gopherwasm) &amp;#x200B; 1) would be the easiest for you, and 2) would be the nicest to everyone. &amp;#x200B; &amp;#x200B;
Yeah, the single module file is probably where I’m going to go. It keeps the code directories clean. I appreciate your insight. 
That's irrelevant as this article is about AWS Lambda which does not support Rust. 
Whenever I encoded images there was a clear loss of quality. Wondering if this was me simply not optimizing the process enough. Happy to hear other's experiences.
You don't need to encode binary data. Just set correct content type or "application/octet-stream". Static serving from a HTTP server will add support for cache (HEAD, If-Modified-Since etc) and is usually a better choice, but you can implement all of that in your application. 
Thank you for the details. Yes I think something like github.com/gopherjs/webgl, but implemented directly via syscall/js, or as you suggested via gopherwasm so that it can target either gopherjs or wasm is what I was looking for. The `internal/opengl/context_js.go` file in Ebiten is using gopherwasm so that seems like a good place to compare against. I'll give it a try, if I can find the time. 
&gt;I’m not even slightly bothered by the lack of generics - years as a C programmer taught me not to need them, and I think most of the cases where they’re useful are to serve designs which are too complicated to use anyway. I see this opinion a lot, but I am unconvinced. I'm reminded of the .NET 1.0 days back in the early 2000s when they didn't have generics, and every collection use required crazy type casting gymnastics. I love go, but the lack of generics makes creating more sophisticated collections with nice convenience methods a total pain. Littering maps all over the place always feels like a giant step backwards. I agree with the author that GOPATH was the biggest wart, but second to that is anemic collection types due to lack of generics.
[removed]
&gt;using a JVM language offers other advantages such as a **deep level of traceability** and **debugging** &amp;#x200B; Is debugging really a problem with go? Admittedly, I've only been using for a few months, but I haven't come across anything that has made debugging any harder than any other language. 
Why would encoding them change the quality of the image?
No idea. Context: Used Python base64 for encoding a png image.
If you’re looking for something in-process I can highly recommend: https://github.com/gorhill/cronexpr
time.Ticker probably wouldn't work if OP needs to do things at specific \_times\_ (i.e., things like daylight savings time or timezones could screw him up), but his request isn't clear.
I agree
Some alternatives (shout out to /r/leagueoflegends): * awesome * impressive * amazing * magnificent * eye-popping (the best one) * phenomenal * majestic * prodigious * miraculous * superhuman * divine * insane
You need a call to wg.Wait() after the initial for loop. https://golang.org/pkg/sync/#WaitGroup.Wait
Looks great already, but please tell us if its "far-from-ready", "almost-ready", "yeah, ready!" &amp;#x200B;
That would also deadlock because then nothing would be reading from the channel. Actual solution is to put the wait call in a separate goroutine, that then closes the channel.
That’s awesome! Perhaps this could be useful for capybara like cross OS automated integration tests.
If there's a deadlock between threads, would it be a biscuit race condition? ...I'll get my coat.
You should be doing something like this. Whatever method you use to transform the image you must do the opposite to get back to the original image. `Image -&gt; Encrypt -&gt; B64Encode -&gt; SaveFile` `ReadFile -&gt; B64Decode -&gt; Decrypt -&gt; Image` Depending on which method of AES encryption you are using you will need a Nonce and a Key. You must save the Nonce with the file and read it back in from the file to decrypt the file. encrypted := AES.encrypt(key, nonce, data) save\_file(nonce, encrypted) nonce, encrypted := read\_file() decrypted := AES.decrypt(key, nonce, encrypted) Here's an example of encrypting and decrypting a file with AES-GCM [https://github.com/averagesecurityguy/crypto/blob/master/crypt.go](https://github.com/averagesecurityguy/crypto/blob/master/crypt.go)
Is there any chance Twitter is ok with contract work for this position? I couldn't dedicate myself as a full-time employee.
Errors are there for you to try and handle gracefully. If a library is returning an error for you to check chances are that something can go wrong. Just because it compiles does not mean errors won't be thrown. 
Sorry, what is "SWE"? Merely "Software engeneer" or something more fance?
Thanks a lot for all the awesome work and enjoy your new won time!
This question deserves much more elaborate answer, but the TL;DR is: no, not all runtime errors can be handled by code. Following your examples: &amp;#x200B; \&gt; Does the directory "/home/username/.config/myapp/" really exist? If not -&gt; create it. That's what "error handling" is, actually. You check the result of I/O operation on directory, and in case of the error "directory does not exist", attempt to fix this problem. How exactly - depends on many factors. Sometimes you can create it silently, sometimes program expect the directory to exist (and contain data). Even if "create it" works for you case, you still can have error "can't create: filesystem read/only", and you have to handle that as well. &amp;#x200B; So my advice just to accept that runtime errors are normal thing, and error handling code is often even more important than "happy path". :) It will help to accept that in many programs, not all runtime errors can be handled silently. &amp;#x200B; I believe, the core answer to your question is "no, if program compiles, it doesn't mean you'll not have runtime errors". \`GetObject()\` may have incorrect input parameter read from stdin, entered by user – there is no way compiled can check it. Or \`window()\` may hit "out of memory" situation, where it have to abort. &amp;#x200B; As for the layering question. Layers exist for a reason. They help to abstract the problem domain, and describe things more nicely and make code readable for humans. One benefit of good abstractions - concrete types, small functions, layered structure – is composability. In a big picture, you might think that it's better to throw errors at the bottom, and catch at the top, but once program components become more independent and resuable – say for tests – you'll see how handy it is to have proper error handling on all levels, and how different use cases and different programs will lead to different handling strategies (i.e. "returning up the stack, logging, quitting, retrying, fixing problem, etc". &amp;#x200B;
Just a software engineer, sorry for the ambiguity!
Thanks for your input. What my problem is is this: Let's say there are no "external errors". All paths are correct, writeable, readable, etc." No external errors at all. What kind of error could still occur here in this very example? And an even more important question maybe: If I made this in Rust, C++ or whatever: Would I need the "exact" same amount of error handling? &amp;#x200B;
Thanks for your input. What my problem is is this: Let's say there are no "external errors". All paths are correct, writeable, readable, etc." No external errors at all. What kind of error could still occur here in this very example? The problem I had with my Python version is that types are not checked. So during runtime, errors like "expecting String, but got int" could occur. And I could only detect this if I played through/tested that very specific singular situation. That was really annoying. And the Go compiler can now check this for me. That's what I like. But I still: What I don't get. Let rule out ALL (!) "external errors". What other errors are there left? That's what I dont understand. Is is some weird super random GC problem that I'm not aware of because I don't have a CS education? &amp;#x200B;
&gt; Under the hood, the C++ compiler (more or less) also just duplicates code, so in practice, doing that duplication manually with copy/paste instead of automatically with a compiler isn't all that different. Except that the compiler works about 1'000,000'000,000 times faster than the manual copy/paste solution and reduces chance of human typo errors to zero.
Great to see this library going strong. Have been using it for some fun side projects and it's really easy to use!
It's due to Go's "errors as values" model as opposed to Python's approach of using exceptions. Python looks different because you'll often use one `try` block to catch multiple possible exceptions. That's not the most precise way to do things, but it's often good enough and certainly makes the code shorter.
You can use it in any automation scenario.
That's exactly how I did it in Python. But even then I only did it for problems that can be called "external errors". And never for things like: window, ok := obj.(*gtk.Window) But what I still don't understand: Are there any errors besides "external errors" ? And if so what are they?
[removed]
You could try to access an element out of bounds such as s = [1, 4] print(s[3]) # Error that isn't caught by a compiler You could try to call a method that doesn't work for the variable. s = None print(s[3]) I mean, yes, these are easy enough to catch and correct, but there are cases where they aren't caught because the program is complex. Error codes are more old-fashioned, that's true.
That benchmark is *highly* suspect. https://github.com/RussellLuo/timingwheel/blob/ab6d7bbf55de543a3433d776a96f8df6ca86e1b1/timingwheel_benchmark_test.go#L107 The thing is, best current practice for implementing timers has been timer wheels (or other bucketing mechanisms) for a at least more than a decade; Go's implementation definitely has bucketing. If it really is true that the Go timer implementation doesn't scale well past 10M independent timers, then let's fix that!
I used [engo](https://github.com/EngoEngine/engo) and talked to the team that works on it for a while. Like it a lot for its ECS approach. What are the main differences between it and this one?
OK, I was aware of those types of errors, but those are errors that I would have to handle anyway (by implementing an actual check). I thought that there might be some potential special Pointer-Garbage-Collector error class or whatever that I just don't know about as a non-CS student. But that doesn't seem to be the case then. AWESOME!! Thanks for your help! I will be busy removing loads of code and adding loads of "_" now!! ;-)
Wise decision, /u/farslan, thanks for creating vim-go. Time is a precious thing that we can only run out of.
Engo is more like framework, Pixel is a library that doesn't force you into any particular way of structuring your program. Aside from that, Pixel has more features and is generally faster, or at least gives you tools to make your code faster. It's also very easy to use, just give it a look.
This is what I tried, it will not work for times over 1 hour
Fix the error, u won’t make the same mistake again
It's like wearing a hardhat at a construction zone. It's not fashionable and it's unlikely anything will fail on your head, but you still must wear it. The line where you test for ok and return err is wrong. If it's not ok the error is nil. Since it is a cast on a variable you just created, you should instead cast it in the single return form because a variable you create should always have the same type. 
I'm using [https://godoc.org/github.com/robfig/cron](https://godoc.org/github.com/robfig/cron) and the configuration I'm using is `AddFunc("0 0 10,20 * * *", func() { ...` &amp;#x200B; This is to execute at 10am and 8pm. Simply doesn't work. It will work for times under 1 hour but over that.. no bueno
I see -- thank you! Cool project.
Thanks /u/farslan for all the work! Hope you enjoy the break
Wow, thanks man
You're ignoring the main reason why rust was invented, to be safer and easier to write concurrent code, and instead judging it based on how simple it is. Rust never promised to be simpler than c++
Thanks, I'm in early stages of my Go usage so will likely be while but I have a particular project that will require Robotgo so if I run into issues I'll make sure to feed fixes back to the project.
Another happy vim-go user chiming in to say thank you. Enjoy your time off. Family always comes first, especially kids. Time flies and suddenly they’re halfway grown. I’d hate to miss my children’s childhood years.
I've tried this. But the image does not work after I decrypt it &amp;#x200B; **package** main **import** ( "io/ioutil" "crypto/aes" "io" "crypto/rand" "fmt" "crypto/cipher" "encoding/base64" "log" ) **func** main() { encrypt() decrypt() } **func** encrypt() { //image f, err := ioutil.ReadFile("img.png") fmt.Println(f\[44661:\]) **if** err != nil { log.Println(err) } key := "aaaaaaaaaaaaaaaa" //encrypt block, err := aes.NewCipher(\[\]byte(key)) **if** err != nil { log.Println(err) } ciphertext := make(\[\]byte, aes.BlockSize+len(f)) iv := ciphertext\[:aes.BlockSize\] **if** \_, err := io.ReadFull(rand.Reader, iv); err != nil { fmt.Println(err) } stream := cipher.NewCFBEncrypter(block, iv) stream.XORKeyStream(ciphertext\[aes.BlockSize:\], f) fmt.Println(ciphertext\[:20\]) //bs64encode based := base64.StdEncoding.EncodeToString(ciphertext) //saveFile ioutil.WriteFile("enc", \[\]byte(based), 0644) } **func** decrypt() { //readFile f, err := ioutil.ReadFile("enc") **if** err != nil { log.Println(err) } //bs4decode unbasedString, err := base64.StdEncoding.DecodeString(string(f)) **if** err != nil { log.Println(err) } key := "aaaaaaaaaaaaaaaa" //decrypt block, err := aes.NewCipher(\[\]byte(key)) **if** err != nil { log.Println(err) } ciphertext := \[\]byte(unbasedString) iv := ciphertext\[:aes.BlockSize\] ciphertext = ciphertext\[aes.BlockSize:\] stream := cipher.NewCFBEncrypter(block, iv) stream.XORKeyStream(ciphertext, ciphertext) fmt.Println(ciphertext\[44661:\]) //image ioutil.WriteFile("enc-1.png", ciphertext, 0644) } 
The best for your new breath with yours ! Cannot say how much I thanks you for the tools that's under my finger most of the day.
Hello there! Fellow hobbyist Python (and Go) dev here. &gt; Is it not true that once my program compiles and user-errors/external errors are ruled out, it will always work? No. Not if your program interacts with *any* external APIs. And even if it doesn't, it may still fail due to, for example, an out-of-memory error (not that you can do anything about that). Fundamentally, the compiler can only tell you that your program is in a runnable state. It can't help you with what happens when you actually run it and the "real world" happens. The checks a compiler performs are akin to having a mechanic thoroughly check your vehicle: he can tell you that your car is in perfect running order. He can't know about or help you with a patch of black ice or great big pothole half a mile down the road. &gt; What possible error could occur during runtime that could not be found by the compiler during compilation and is not a user/external error? They generally *are* user/external errors. For example, the compiler cannot guarantee that you a particular filepath is writable or network address is reachable because that might change at *any* time for any number of reasons. As soon as your program starts interacting with other systems, their problems become its problems. &gt; Then why all this error handling? Essentially, it's a deliberate choice by the language's designers to make error handling *very* explicit. *All* the same things can go wrong in a Python program (plus a whole bunch of other stuff that would be caught by the compiler in Go). But Python throws exceptions instead, and it's entirely up to the developer where and how they handle them, if at all. Coming from a Python background myself, I find Go's error handling a PITA and dislike the excessive `if err != nil` boilerplate. OTOH, my Go code is *far, far* more correct than my Python code because Go forces me to think about and handle errors. With Python programs, I find myself coming back time and time again to add a new `try … except` block when the program encounters some new input that causes it to fail at a place it never failed before and crash the whole program as a result. Go avoids that by forcing you to handle errors wherever they may occur. (Well, it largely avoids that. Dereferencing a nil pointer will give you that unhandled exception behaviour you know and "love" from Python.) The chief "real" problem with Go errors is the lack of context they have by default. You can't just use `if err != nil { return err }` everywhere because then you end up finally handling an error (logging it or whatever) far, far from where it occurred with no idea where it actually came from. It's important to add some context to errors by wrapping them with `fmt.Errorf("failed to do ABC to XYZ: %v", err)` or a library like [github.com/pkg/errors](https://godoc.org/github.com/pkg/errors). 
I’ve been really looking into Go for 2D game development. Anyone know of any write ups (or have some commentary to throw my way) for differences between Pixel and https://github.com/hajimehoshi/ebiten ? 
Thank you so much for your valuable time! vim-go is amazing I've been using it since the beginning!
This will be super sweet! I can't wait to see what people come up with. There are examples found here: [https://github.com/faiface/pixel-examples/tree/master/shader](https://github.com/faiface/pixel-examples/tree/master/shader) Also, don't miss out on my example I provided here: [https://github.com/faiface/pixel-examples/tree/master/community/seascape-shader](https://github.com/faiface/pixel-examples/tree/master/community/seascape-shader) &amp;#x200B;
this is your answer
&gt;\--cross-compile-common For someone unfamiliar with go (I'm just trying to run a project from bitbucket that says go is a dependency) =( sorry for being a noob. I mostly java so sdkman is my friend.
If you are sure that the function will never fail, it's fully possible to just don't return any errors, or ignore any errors it us returning (although ignoring errors is considered bad form).
Sorry for being curt. I was just pissed off due to something totally unrelated to your question.
To add to that: ebiten is being more actively developed currently.
That's okay. Lines blur and we move fast between all of our daily interactions. Sometimes too fast. I am happy that someone, somewhere out there answered me. Thank you for that.
Wasn't there some Pixel mobile/WebGL support in the works somehow?
Absolutely.. he is made of pure energy.
Of course, any form of contribution is a help to the project.
Haha, I thought the same! Maybe just wishful thinking. :)
lol I wasn't sure. Nope - I would encourage you to apply, regardless leetcode level of difficulty!
I have to do this to get to private repos in Github using `go get`/`dep`/`go mod`: `git config --global url."git@github.com:".insteadOf "https://github.com/"` Guessing you have do do something like `git config --global url."me@gitlab.xxxxx.com:".insteadOf "https://gitlab.xxxxx.com"`
Thanks you /u/farslan for your great work, because of you i meat with vim ❤️
In your example, if no errors (either from the kernel (aka memory, file access, file space, signals etc), or other sources like third party Libraries (aka GTK)), then you could "\_" all return error values, however, if any error is returned, you wont be able to the let the user know of the problem, so they can fix it, for example, your program is executing in a low privilege permissions (now desktop access, or even as simple as no window manager available), your program would simply seg fault, however, it would be better to report the error returned, and then the user can fix the issue that makes the most sense. There are errors that cannot be worked around, and requires user interaction (ie fix permissions, start X Manager, free disk space etc.) &amp;#x200B; The type safety, and compiler ensures the code is correct, but it is not possible to know the environment the program is going to be executed in will work as expected. &amp;#x200B; I hope this helps.
[removed]
&gt;Gtk can't create a window if there's no XServer running. Ahhh that's a good point. This is the type of "error class" I was "looking for". &gt;to make error handling very explicit Haha, this is definitely not an exaggeration. It feels really weird that they haven't come up with something more elegant/shorter than an endless chain of "if err =! nil". I really like that fact that go is so lightweight, but this really feels a bit awkward. But as you said yourself: &gt;Coming from a Python background myself, I find Go's error handling a PITA and dislike the excessive if err != nil boilerplate. I fully agree. However maybe I will once appreciate it in the future. I really hate interfaces now, but everybody else seems to love them. So .... time will tell :-) Thanks so much for your input. That was really helpful!
I fully understand why it is helpful, but why is it that I have never seen such a massive amount of error handling in any other languages? I only now Python, Go and a bit of Rust and Go has by FAR the most error handling code. Do other languages do it also just with a shorter syntax or are programmers in other languages just lazier? Or any other reason? 
That is a very good idea. You can do so many cool things with shaders, so that would be a perfect mix for that show. Who will contact him about this?
&gt; We will see how it can solve all the enumerated problems, without any compromises. FTR: This statement is universally false. There are *always* compromises. That you say there aren't any just means that you aren't aware of them. :) &gt; The default behavior is that an invoked goroutine gets its parent context. This (and the proposal in general) loses the advantage of explicit context passing. If the context *may* be omitted, you can no longer assume that a function without a context doesn't depend on it in any way. This opens the door to hard to discover bugs, where operations that are supposed to run in the background accidentally get cancelled when the request is over. I agree that plumbing the context is a PITA sometimes - but it's inherent in its explicit nature. i.e. it's not an unwanted side-effect, but *the intended effect* of enforcing its explicitness. For better or for worse. &gt; Additionally, checking that ctx is of type `context.Context` can be done in compile time. There is a general opposition from the Go team to having the language depend on types in a specific package. For this (compiler-enforced checks that the argument is a `context.Context`) the `context` package would need to migrate into the spec so that we can talk about it there. This has also been a road block for several alternative generics designs recently.
Thank you very much, I’ve been using your creation every single day. Enjoy you time with your family 
Thanks for creating vim-go! I just got it installed and working and it is life-changing. I've been primarily a vim user for coding since the mid '90s, and feel like my eyes have been opened since installing Janus and vim-go.
Thanks for your work man. Wish you the best with everything.
&gt; This (and the proposal in general) loses the advantage of explicit context passing. What if default behavior would be to start new goroutines with independent context, allowing user to explicitly pass another context if necessary? 
TBH the basic point of this proposal is to get rid of explicit context passing. I'm not sure why the author thinks it isn't. But the explicitness isn't about "does the function body mention `Context`", it's about "am I passing around this value as an argument".
I'm not sure why you think it is. If I'm reading correctly, it's about placing context reference to the right place and shifting explicit context passing from where it does damage to existing codebase to where it makes sense - to the goroutine start call.
&gt; to the goroutine start call. a) At the goroutine start it's not even required, so, no. There is no explicit context passing here either. It's *possible* to explicitly pass a different context, if you don't it gets passed implicitly. That's contrary to what people mean when they say "context passing should be explicit". And b) that may very well be what this proposal intends, but either way, it's not what "explicit context passing" usually is referring to. Just like explicit error handling is about actually having the error in the signature and passing around the values. You might just as well argue that exceptions are just "passing the explicit error handling from where it does damage - in the signature and in the `if err != nil` checks - to where it makes sense - the location where the error is created and where it's handled". When people say the want context-passing to be explicit, they are referring to *exactly* what this proposal (and your comment) considers damaging and a problem. You might disagree, but to the Go team, having the context in the signature and needing to plumb it around is not a bug but a feature.
`brew install go`
Doesn’t Lambda support anything that compiles to x86_64? Here .. https://github.com/srijs/rust-aws-lambda and there are a bunch more. That is exactly how people used Go on Lambda before it was officially supported. 
One option would be to move the reader into its own goroutine: package main import ( "fmt" "sync" ) func main() { ch := make(chan int) var wg sync.WaitGroup go func() { for i := range ch { fmt.Println(i) } }() for i := 0; i &lt; 10; i++ { wg.Add(1) go func(k int, wg *sync.WaitGroup) { defer wg.Done() ch &lt;- k }(i, &amp;wg) } wg.Wait() close(ch) }
Thanks everyone for their kind words. It makes me happy to be able to serve and help so many people in my life. Hope to continue it later in my life again once the times comes. 
Thanks a lot for creating vim-go and enjoy the precious your time.
For the benchmarks, you need to run a fixed workload b.N times.
Thank you fatih! 😊
&gt; What other errors are there left? Great question! Answer: it’s effectively impossible to guess, so handle them all!
&gt; window, ok := obj.(*gtk.Window) &gt; if !ok { return nil, error.New(“could not type cast window”) } FTFY
You have any update on this project?
Hey man great choice ! Having a life outside of coding is important no matter how much I love vim-go . My bigger concern is your hosted k8s project. It will directly compete with the Openshift Dedicated project I work on !
For the same reason you can't get a "slice" of 123 that looks like [1, 2, 3]. That's not how values work.
&gt; why Byte Slice of "H" is not [01001000]? Why it's [72]? How do you tell it’s one and not the other? Are you using `fmt` package to print the byte slice?
This was a wholesome thread. 
I don't understand what you tried to say. Sorry
So Long, and Thanks for All the Fish ;)
The form data are presented in program's output and the way they're stored in memory are unrelated. A byte is 8 bits and that's what is stored in the computer's memory. A byte has a decimal value (also octal, hexadecimal, etc) and that's what the program prints because the default is to use decimal numbers for printing. For other options see the formatting verbs documented in the `fmt` package.
thank you for your contributions! enjoy your family time.
Thank you /u/farslan for all of your hard work on vim-go. I hope this change will allow you to spend a bit more time with your family :)
This right there annoyed the hell out of me when i did something similar. Decided to be ok with having a hiccup twice a year. Obviously if you want to implement this for anything serious you need to think about this stuff carefully 
&gt; this doesn't seem to support updating graphs, since it renders to a PNG) You can still get continuous updates by rendering into two PNG's alternately, and displaying the one that is currently not being rendered to.
Loop over the slice and Sprintf the elements into a result string. The format string allows you to add the desired value separator. Playground example: https://play.golang.org/p/jaytvtcci9D
No, not really. I don't understand why routing, which is a really simple decision about what handler should be called for a given request, needs reflection in order to support other features. Why not just call a function from inside the handler for any other functionality needed? Let me give an example of the sort of thing I do: func router(w http.ResponseWriter, r *http.Request){ switch { case r.URL.Path == "about": processTemplate(w,"about.gohtml",nil) case strings.Split(r.URL.Path,"/")[0] == "account": if !loggedIn(r) { processTemplate(w,"login.html","account") return } session := getSession(r) params = strings.Split(r.URL.Path,"/") if len(params) &lt; 2 { processTemplate(w,"error.gohtml","not enough parameters in a call to the account page") return } data := processAccount(session, params[1]) processTemplate(w,"account.gohtml",data) case checkForComplexCase(r.URL.Path): complexHandler(w,r) case strings.HasPrefix(r.URL.Path,"api"): apiRouter(w,r) default:{ processTemplate(w,"landingpage.gohtml",nil) } } I haven't added contexts, or done much error checking here, because it doesn't add to the example. You can see how it could easily be added, though. This, to my mind anyway, is really simple and straightforward, and (importantly) easy to understand 6 months later when I come back to it. I'm not limited in any way about my routes, and retain all the power to do anything with my routing without worrying about what the framework will support. Does that make sense? I'm still struggling to understand why there's a need for a framework here...?
Thank you for your time and effort on vim-go. Enjoy the rest!
Good explanation
In GO, every variable you want to use must be declared/defined before using it, usually you do this with lines like var i int The "=" operator then assigns a value to that variable. Using ":=" you create a new variable "inline", it's type is derived from the value assigned to it. So i := 1 is kind of a shorthand for var i int i = 1
:= infers type with := you dont need to give current a type it just knows. [https://tour.golang.org/basics/10](https://tour.golang.org/basics/10)
Thanks a lot! And thanks for introducing the new Lead!
Your decision is perfectly understandable. I have great memories of meeting you in a Go meetup in Paris. Thank you so much for everything you've done!
Please do the 'Tour of Go' tour.golang.org before asking questions.
Aah, I see now: &gt; current, _ := strconv.Atoi(answer) creates a local "current" variable which masks the one at the parent scope. Thank you. 
I was not ok with it, and decided to rewrite project in Java instead... golang doesn't have ANY good and correctly working time/period based scheduler.
I second the zek library that was posted. It’s the closest one to json-to-go I could find so far. Chidley gives you a lot of structs and pointers. It’s maybe more powerful but so far zek did everything I needed and the output is cleaner.
&gt; The reason it keeps it private is so that it can make sure nothing outside of the package implements the interface but one of the 3 values you have there. Couldn't this be accomplished by defining some unexported function in the interface? 
I feel that your podcast name may be conflicting (or be confused) with https://github.com/gofrs/ Gofrs is an initiative aiming to maintain commonly used packages in the long run https://www.reddit.com/r/golang/comments/934xzi/keeping_important_go_packages_alive_announcing/
I assume we won't be the only ones to abuse the pun (gopher, gofr) :-) The spelling should be enough to distinguish this French podcast : 'Go' 'Fr', don't you think ?
Pas la moindre idée ¯\\\_(ツ)_/¯
Enjoy your new found free time! I haven't gotten a chance to write much go the past year or so but I loved using vim-go. Seeing how you found someone willing to take over the burden of maintainer is excellent. Thanks for everything, you had an extremely succesful run with the project.
&gt; What happens in reality with exceptions is that you tend to ignore most of them and only 'catch' a few selected ones. This approach has its own benefits but you loose the perception of all the cases that can go wrong but still gives you the impression of a secure program. Ahhhh OK. That actually makes sense and would explain why I see soooo much more error handling code in Go compared to other languages! &gt;So the TL;DR is that most languages ignore unlikely errors instead of confronting the package user directly with them. Exceptions are in a way opt-in while Go's error values are opt-out. In Go it is just a common idiom to not cause panics across package boundaries to give the user full control about error-case behaviour. If you figured out an error condition is highly unlikely you can simply ignore it or raise a panic. THIS is the answer I was looking for !! Thanks for taking the time and explaining that! I'm obviously not confused about why there needs to be error handling. But I've just never seen so much of it. I only have the GTK GUI code thus far and there are literally more lines for error handling than "actual" code. This is totally different in my current Python version as well as my experimental code I did with Rust. That's what got me so confused. I even checked other Python and Rust GTK apps and none of them (no exaggeration) did as much error handling as any of the GTK Go apps I looked at. 
I totally get that. That's what I mean by "external errors". And I already handle them in my Python version. There's no confusion about this. But error handling for simply calling a GTK-API seems like extreme overkill. That what I was confused about. Maybe there are some Go concepts I didn't quite understand yet. But "DoomFrog666"'s explanation cleared that up.
I’m not ignoring. First days they promised to build better C++ replacement. And base on current state I see no difference. Nor better or safe or anything else.
Thanks for all the times I didn't had to call \`gofmt\` manually!
This guy knows his graphics. OP, this is how it's done under the covers; you're just doing the blitting yourself. It's not much extra work, but you'll have to see whether it's fast enough. The PNG encoding will add overhead, so make sure you turn off all compression.
This is worth watching to see how it can be done: https://www.youtube.com/watch?v=77ZFKuMLkp4
Check out the 'Tour of Go' tour.golang.org, you might find it very helpful
I found the project where I used one of these two but I couldn't determine which. I remember manually editing the output a bit but certainly it saved me time.
https://github.com/marcsantiago/gocron Check this out
Sorry, you're wrong somewhat. &amp;#x200B; Golang explicitly represents byte array as an array of ASCII decimal code. Not just for printing. &amp;#x200B; For example &amp;#x200B; bs := \[\]byte\[72\] fmt.Println(string(bs)) Output: "H" &amp;#x200B; As you can see, "bs := \[\]byte\[72\]" this is not an array of binary bytes. Rather, decimal ASCII values
This is conversion from ASCII bytes to binary bytes
Really weird, but nice!
git config --global url."https://$CI_REGISTRY_USER:$CI_JOB_TOKEN@$GITLAB_DOMAIN".insteadOf "https://$GITLAB_DOMAIN" Add this to the job that's having this problem, works for me.
 git: 'config' is not a git command. See 'git --help'.
You were complaining that you didn't see the binary representation of a byte slice when you printed it, so I showed you how to do that.
byte in golang is an alias of uint8, but that's fine - a byte is 8 bits and a uint8 can represent all of those bits. The data is still stored in memory as binary because this is how computers work. You can perform bitwise operations on ints in go if you want. I'm really struggling to understand what your point is, but I feel like there's some fundamental misunderstanding you're having.
That question is _almost_ like asking: "Why is a Byte Slice of "H" not properly represented as eight electric charges which is the right pure representation?" What you see by doing fmt.Println stuff is a textual rendition of something you cannot see: Charges in capacitors or magnetic domains or electric currrents. 011101001 is not better or more accurate than 0x3f or 72 or "H" or whatever.
influxdb does that. use their tick stack and you can get great graphs.
I think it is especially essential to specify the N while comparing two algorithms with different time complexities. Here, the two time complexities are timingwheel's O(1) and the standard Go timer's O(log N). So in the benchmark, I need to explicitly specify different iteration counts. And so far, the only way I can find is to set the value of b.N by hand. (See the related [issue](https://github.com/golang/go/issues/24735).)
So... Is that a forever loop inside main, which has a goroutine, and now people are freaking out it's taking too much memory?
Anything to get those clicks
&gt; Inside a beta release none the less. Go 1.11 isn't beta.
[removed]
Which database? The database may already be smart enough to be doing this optimization for you, especially if you index the field in question. If you're using a half-decent database, the fastest thing you should be able to do is write a query to get the strings directly. Also, upon a new string, are you doing anything other than inserting it? If not, if the code receiving the strings doesn't need to do anything other than note the existence of the string, the fastest thing to do will be to explain to the DB that these strings are unique, and do an "upsert", which varies from DB to DB on how you do that, and let the DB do the de-duplication for you. If you do need to do something, you may still find there's a way to ask the DB to return what it actually did with your query. I'm assuming a standard relational DB just so I can be a bit concrete and it seems the most likely one based on zero evidence. If you're using something else, please let us know what it is and I'm sure someone can be more specific about the best thing to do.
We used FNV at one stage in Prometheus, we had quite a few collision issues. I'd suggest using a better hash, and even then making sure you can handle collisions.
To be very clear: are you asking for autogenerated bindings vs. manual ones?
MySQL can do that for you if you add an [hash index](https://dev.mysql.com/doc/refman/5.7/en/index-btree-hash.html) to your string column. You'll want to benchmark with loads reasonably similar to your real ones to see what is fastest. If you are looking for maximum speed, you can write a MySQL function where you send it the list of strings you want to insert, and it sends you back the strings it had to add. The advantage of this approach is that it avoids roundtrips between the DB and the application, having the database do the work it can do in-RAM and sending your app the clean results. This is again assuming that you need to do something upon the insertion of a key that is new. (Or duplicated, I suppose.) Again, you'l have to benchmark to really know.
Let me evaluate hash index never used it before.
Are there language-breaking changes required so that it has to be in Go 2.0? Aren't there already many binding code generating things, with varying degrees of effectiveness? https://www.google.ca/search?q=cgo+binding+generator What's missing?
Why you mock everything? Some blogs suggest to stop mocking net/db connections and do it at test env. &amp;#x200B;
If you convert byte slice to the string with `string(bs)`, than golang compiler blindly prints it as a string.
As you said they have varying degrees of effectiveness. In reality this means they don't really work. I'm yet to see a mobile application using Go to drive the UI(i.e. bindings for iOS). The binding generator usually means that you need to develop another C API compatible with the Go binding generator in front of the actual target.
I agree. This is an excellent idea. Seems hard, but very useful.
Clearly you have something against rust cause there's many different memory issues that are a big problem in C++ that the rust compiler will detect and try to disallow. To say that rust isn't safer than C++ is just silly. 
I don't think this is really doable for anything except C libs. Other languages have their own complexity and most language borders end up using stable C apis.
The hardest part is data structures transformation. hope improvement happens in 2.0
Thank you for vim-go! My professional life has been significant enriched thanks to you. I wish you the best in your new adventure.
[removed]
BTW, never ignore error return values.
I just did because of your comment. It doesn't really solve the problem because it stuff the files into ./.pnp, still in the same folder as package.json. It would help me if it put things into ~/.pnp or something instead.
As others have said, this is not really an attribute of the graph renderer, but the display method. What you need to think about is where you are wanting to display it. Webpage: use a javascript graph library and feed it data from Go GUI app: render to two buffers and swap which one you are displaying, how you do this depends strongly on what GUI you are using If you just want to get an arbitrary graph rendered and updated continuously in a window, [https://github.com/TheGrum/renderview](https://github.com/TheGrum/renderview) can wrap whatever graph renderer you prefer. The cmd/cmdgui example will even do it from a command line (the [plot.sh](https://plot.sh) example shows it taking a Python function plotter and turning it into an interactive function plot that you can drag and zoom), though the render is only updated when you move the rendered display. Should not be hard to add a ticker to regularly refresh it.
It depends. If you need it to be a certain size, you can always specify a more specific type (int8, int16, int32, rune, int64...). I find that, in general, you don't need to specify types, though.
How about "gauffres"? ^(NB: "gofr" sounds "waffles" in French.)
Additionally, this is setting two variables in series. The strconv.Atoi() function will return an int and an error. `func Atoi(s string) (int, error)` The \_ (underscore) is a special operator called a [blank identifier](https://golang.org/doc/effective_go.html#blank) that can be assigned any type. So as you have it written you are assigning a type of int to `current` and ignoring any error that Atoi would return. (Generally, this is bad practice and you would want to handle an error. Yadda, Yadda, Yadda.)
viper doesn't vendor anything. There is no `vendor/` folder in [the repository](https://github.com/spf13/viper). go get thus fetches its dependencies recursively (and what those are, is determined by include declarations).
Thank you for your years of hard work and contributions to the community. Enjoy your family!
&gt; Why does Go do this? why Byte Slice of "H" is not [01001000]? Why it's [72]? What is the reason behind this that Go does not represent pure binary data? To _(imo)_ simplify some other explanations; Base2 is an encoding for data, ie the classic binary zeros and ones. Two encodings can have the same underlying value. So when you're seeing `72`, that is the Base10 encoding of the same underlying value. They're the same thing. It's simply a value represented in an encoding. It could be Base2, it could be Base10, it could be Base16 (Hex), it could be Base58, etc. The value has nothing to do with the encoding. Go chose to make a byte a uint8, and all possible values of a uint8 can be represented as Base10. That's just what it is.
I was able to come up with a solution for two main issues. 1. Using gitlab with multi level projects such as https://gitlab.xxxxx.com/go/project_group/project/ 2. Using a private repo with go modules We setup a nginx proxy with ssl cert in front of gitlab. Also I setup a url responder to respond back from "go get" requests location / { client_max_body_size 0; gzip off; if ($args ~* "^go-get=1$") { add_header X-GO-GET-OVERRIDE true; return 200 "&lt;html&gt;&lt;head&gt;&lt;meta name='go-import' content='gitlab.XXXXXX.com$uri git ssh://git@gitlab.XXXXXX.com:$uri.git'&gt;&lt;/head&gt;&lt;/html&gt;"; } .... } Hopefully this helps someone who is suffering from this problem.
[removed]
What improvement?
You might also look into a reasonably large bloom filter. It might be a different way of looking at the problem space.
ok, I didn't notice that viper doesn't have a vendor directory. Thanks. By include declarations I assume you are referring to the imports. So 'go get' fetches the dependencies directly to the GOPATH only when vendor directory is missing for a package ?
The bloom filter would be useful for reducing potentially slow hits to the database to verify, but since it needs to be inserted anyway if not present, you still have a database query in either case. The bloom filter would have false positives, so you need to verify with the database if your filter tells you the item is present. Also worth thinking about: What's the ratio of new items to seen items within the stream. Are most items new or are most items seen? That can give different ideas for data structures to speed things up. As I mentioned about though, all this comes after a correct implementation and profiling.
That is an interesting idea to explore. My personal gut feeling is that it will be more natural to have the context inherited. I think that more experience with this subject may lead to better understanding and maybe an answer - which context is the right one to pass in goroutine calls. I would love if you could share this idea in the blog post comments! Thanks e1ch1!
&gt;You might disagree, but to the Go team, having the context in the signature and needing to plumb it around is not a bug but a feature. Plumbing the context, to my opinion, is not a bug and neither a feature. It is the design of the current system, and it is not perfect. As I wrote in the proposal, it has its advantages, but it comes with a price. I tried to give the full picture, and in that the pain points that I feel. I think that in this case the price is too high, and a change is needed. Not necessarily the proposed change, but a solution to the drawbacks I enumerated.
An example on how you can use Ebiten with go-chart: https://gist.github.com/peterhellberg/87f6b06b603afd7ca582811e52855013
An example on how you can use Ebiten with go-chart: https://gist.github.com/peterhellberg/87f6b06b603afd7ca582811e52855013
This may be too naive but can't you just query and then insert on a failed query? If most of your strings are expected to be duplicates you will be doing a single query most of the time.
More specifically, it will fetch any packages which aren't in the project's `vendor` folder and place them in `GOPATH/src`.
Personally I just go to the GoLang website. Download and run the pkg file. 
Ah but before you leave color, add rainbow! (its okay you can rest now, great work)
I think you’ll need to clarify. What does “in the context of another desktop” mean?
I created a desktop using the CreateDesktop function from the win32 API. I used the CreateProcess function from the win32 API to start a go program with that desktop. If I were to start a process in that go program, will it inherit the properties of the parent. My goal is to be able to start processes in go using exec in the created desktop. Better explanation?
Psst... There is no such thing as "ASCII bytes" or "binary bytes". A byte is just an integer between 0 and 255.
Although it seems it has \`go.sum\` &amp; \`go.mod\` files, shouldn't dependencies of modules downloaded to cache? Or is it because it automatically uses GOPATH mode, since he is in GOPATH?
&gt; FTR: This statement is universally false. There are always compromises. That you say there aren't any just means that you aren't aware of them. :) Could not agree more. I think it's very important that Go remains as familiar as possible to someone who comes from another OOP-based language. Introduction of syntax that don't exist in any other language and hide what code is actually doing are counter to the design philosophy of Go.
yes, that is correct.
Correct. All casting must be explicit and all mathematical operations must be performed on values of the same type.
This is completely go specific. Are you missing the part where I ask if exec inherits properties? That is my question. The windows part is just background info.
Nice little tool my guy!
This has nothing to do with Go. The documentation for the CreateWindow group of functions states: &gt; A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by child processes. If lpsa is NULL, the handle cannot be inherited. So presumably, bInheritHandle needs to be set to TRUE in your C program.
&gt; Plumbing the context, to my opinion, is not a bug and neither a feature. It is the design of the current system, and it is not perfect. As I wrote in the proposal, it has its advantages, but it comes with a price. Yes, but that is where we disagree. What you call the "price", I call "the fundamental point of what people want when they say they explicit context passing". I'm not saying it's not a pain. I'm saying that pain is the point. The fact that, to use context, you have to *explicitly* plumb it through every function in the call graph is exactly what's wanted - it means the property of using a context becomes part of the type. You might reasonably think that it shouldn't be - I'm just saying that you aren't convincing those people that say context passing should be explicit.
Implicit casting has always been a source of very subtle and hard to debug bugs and also in pretty much every language it's an obscure topic that few know well. I suspect that's why Go chose to not have implicit casting. It feels a bit annoying at first, but it starts making sense after a while. Don't mix apples and oranges, or if you do, at least be explicit about it. A cast should stick out like a sore thumb and make you reevaluate your earlier decisions that led to this and maybe go back and get your types right. 
You got the point! In the previous benchmark, while the iteration count b.N is fixed, the input size N is actually variable (between 0 and b.N). What I really want to do is constructing different benchmarking cases with different Ns (each is fixed). I have update the benchmark tests, see [this commit](https://github.com/RussellLuo/timingwheel/commit/52de9bed217582562a8b715b08c41dce7167b710).
[removed]
all allowed implicit and explicit casting (or conversion) cases are [listed here](https://go101.org/article/value-conversions-assignments-and-comparisons.html). For typed numeric values, explicit casting is required.
[removed]
I generate random data online as an SQL and use the same SQL everytime. If I need specific test data I just add them to the SQL.
Try survey. Looks interesting. https://github.com/AlecAivazis/survey/blob/master/README.md
There are plenty of other languages and toolchains that manage to produce auto generated bindings just fine. Rust’s bindgen is a solid example.
Fantastic. Thank you!
While your point isn’t wrong your argument falls apart a little since Go has quite a lot of syntax that doesn’t exist in most languages. I agree with the rest that it could hide things and goes against the philosophy of Go, but to argue the syntax being unique being a problem isn’t really the issue here. 
I think Go can preempt in loops even without anything else now a days. It’s been something they’ve been working on a while. But can’t seem to find if they actually finished it yet. 
Better: func() { obj, _ := doSomething() // Second return value is of type error obj.DoMore() } Ignoring errors leads to panics automatically, no need to manually convert them!
Generally speaking it’s better to just use a chan struct{} and close it than use a chan bool that for canceling since you don’t care about the Boolean value being true or false for that purpose. 
Clever!
Spontaneous idea: combined with some EXIF library, this project might also sort image files by the date when the picture was taken. I use such a tool since years to maintain a very basic struct for my photos collection.
Why advantage does an struct{} over a bool?
[removed]
Yeah, I was on my phone earlier so it was a bit of a pain to check. For anyone else curious: https://github.com/golang/go/issues/10958 and https://github.com/golang/proposal/blob/master/design/24543-non-cooperative-preemption.md go into depth about this topic.
 import "github.com/pkg/errors" func flaky() (int, error) { ... if err != nil { return 0, errors.Wrap(err, "this func is really flaky") } } Morale of the story: Always add context to your errors. A plain `return 0, err` is not going to help you at all with troubleshooting,
Actually because errors are just values you can get really creative with them. One great recourse on this is ofc the official go blog https://blog.golang.org/errors-are-values. In one example they embed error handling in the and get therefore just one centralised exit point. type errWriter struct { w io.Writer err error } func (ew *errWriter) write(buf []byte) { if ew.err != nil { return } _, ew.err = ew.w.Write(buf) } ew := &amp;errWriter{w: fd} ew.write(p0[a:b]) ew.write(p1[c:d]) ew.write(p2[e:f]) // and so on if ew.err != nil { return ew.err } I don't say this is a better way to handle errors I just want to encourage people to experiment more.
Ça fait plus podcast culinaire que podcast sur le langage Go :-)
readline? https://github.com/chzyer/readline Alternatively, write your own: ``` // Repl embeds an imterpreter, and handles the IO stuff type Repl struct { interpreter.State *bufio.Scanner io.Writer buf bytes.Buffer err error } func (r *Repl) Start() { r.Load(prelude.TypeDefs()) // r.LoadModule("prelude", prelude.FuncTypes()) // r.LoadFuncs("prelude", prelude.Funcs()) for { ... } ```
Stacktrace included! Now that's amazing error handling!
OP mentioned interactive. Perhaps he is looking for a solution that adds some hoverable tooltips or something?
Agreeing on this one. Easy to use, does not need to create additionals types and patch existing code Coupled with constants for error strings, it is really convenient
I like that and i think it makes code cleaner but this not always fits the needs. As you said - we can be c reative with error handling 
Would be interesting to have the option to leave the files in place but create a directory with only symlinks / hardlinks to the files.
I usually return fmt.Errorf with the error message inside, as well as some unique string or code. Makes finding it a lot easier than just a generic “db: not found” or something. 
I never tried it in Go yet, but look for readline bindings. Most modern shells use this library. It has history (with search) and completion. Perfect for interactive CLI.
Hey /u/tornato7 it has this option already if you use the -copy-only flag. I must admit, the documentation could use some more work :) Thanks for checking it out
Thanks!!
Well, only so far as the new syntax that Go has because of channels which is a unique concept to Go anyway. I don't think there is anything radically different for a newcomer outside of the &lt;- operator.
Please don't gaslight over your perception that syntax is less important than semantics. WPWoodJr's proposal was brilliant, and although his example did not address your criticism, his proposal could certainly accommodate the semantics with some tweaks. **Original Syntax:** contract Graph(n Node, e Edge) { var edges []Edge = n.Edges() var nodes []Node = e.Nodes() } func ShortestPath(type N, E Graph)(src, dst N) []E **WPWoodJr's proposed syntax:** type Node generic { Edges() []Edge } type Edge generic { Nodes() []Node } func ShortestPath(src, dst Node) []Edge **My addition:** type Graph( n Node, e Edge ) generic **OR:** type Graph generic { has Node has Edge } **My change:** func ShortestPath( src,dst Graph ) []Edge OR func ShortestPath( Graph( src, dst ) ) []Edge The above may not yet be perfect, but it is close, and working collaboratively to resolve the issues could lead to something better than the current proposal on the table. Rather than criticize someone for proposing a different color why not propose architectural changes that would enable that new color to work instead? IOW, build them up rather than tear them down. If you do, maybe we will all be able to have nice things.
Some packages like, mysql for example, return typed errors which you can cast and access additional fields from to handle them. Using pkg/errors lets you keep all the context as-is, so you can access any of the "cause" errors. fmt.Errorf reduces the context to whatever strings you manage to output and isn't good for error _handling_.
Is there any reason why a type cannot define a predicate too? Doing so would help reign in declaration creep. Also, what is wrong with making *(reasonable)* assumptions? It would certainly be possible to have an explicit syntax for when the assumption does not apply.
[removed]
Correct. If you just want to download and not install you can use the `-d` flag https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies
&gt;Is there any reason why a type cannot define a predicate too? Doing so would help reign in declaration creep. There's already type assertions for that - return true on matched type. But they only works if you know types you're dealing with. In case of type parameter, it is not obvious for me against what you need to match passed type. &gt;Also, what is wrong with making *(reasonable)* assumptions? There's nothing wrong with it, but regarding explicit syntax I don't know how to shoehorn infix notation of \`+\` operator and types information with present requirements about clean grammar of language. 
Gotcha, yeah, okay, not error *handling* \- you are right. I mostly write APIs in Go, so while I will check for error *type* if it is a recoverable error - but generally I just write the error to the client with the HTTP status code. But your point is 100% correct.
Useful tools, thanks. 💪
&gt; I think that's still wrong. Each call to BenchmarkXxx should repeat a fixed task b.N times; what you have is some preload and then b.N additions to that. Imagine a bad timer implementation where create and stop were O(existing_timers^2); b.N==1 and b.N==10 would have very different performance, where the latter is just supposed to be 10 samples of the first. &gt; &gt; You want something like b.N loops of start+stop of X timers. &gt; &gt; Also, you might enjoy https://golang.org/pkg/testing/#hdr-Subtests_and_Sub_benchmarks It's strange that your above reply can be seen at your profile page, but it is invisible in this thread :( First of all, thanks for reminding me of the sub-benchmarks, that's awesome! For the rest part, however, I'm afraid I didn't get your point. By doing the benchmarking, what I really want is the answer of "how about the performance of start+stop operations of the two timer implementations while there are already N active timers". And in the benchmarks, I constructed four cases with four Ns (i.e. 10k, 100k, 1m and 10m) and then let Go control b.N by convention. By "that's still wrong", you mean I'm asking the wrong question about performance or the method I used to find the answer is wrong?
[https://github.com/chzyer/readline](https://github.com/chzyer/readline) looks really cool. &amp;#x200B; &amp;#x200B;
[https://github.com/chzyer/readline](https://github.com/chzyer/readline) looks really cool! &amp;#x200B; For tools like this, how does one write Tests? Do I need to use expect ? or is there a technique I can use 
I'll try out `chidley`. It looks promising. Thanks.
You might perform unnecessary and costly computation between 2 writes when an error already happened. In practice this is mostly worthless.
Except not in the standard lib so everybody uses his own incompatible flavor of pkg/errors library.
I actually just read this book before starting a new job as a Go dev. Go hasn’t changed that much outside of adding new features, such as dependency management and a few others. I thought the book was pretty good, but I only got it because sometimes I like reading an actual book. The Go website is really all you need.
The book is still very relevant and great for getting your feet wet. Also check out [Effective Go](https://golang.org/doc/effective_go.html).
It still works, mostly because it doesn't use any packages outside the standard library. I have another Go book that's already outdated because it builds things with outside packages that have changed their APIs. 
The language itself hasn't changed very much since Go 1.0 just the ecosystem and tooling. The book is still a good starting point.
&gt; No, if an error occurred the operations after that become no-ops. Lol, I'm saying between 2 calls to the write function.
This, thank you for this answer. You are trying to help... I will give that a go. Thank you.
For example, I started the go program that is using exec in C using CreateProcess. When calling the function, I had to specify STARTUPINFO. I was asking when running a program with exec if it would inherit properties like STARTUP INFO.
It's only a simple SDL particle swarm. It's still early on but I would appreciate it if someone could critique my code for me.
Like all of Kernighan's books, this book will still be worth reading in fourty years.
Don't test the `readline` package, the author already did. Decouple your line processing logic and test that independently. I wouldn't worry about testing the glue code between the two.
This is similar to how I solved these problems for GitHub Enterprise. I put together a small go service modelled after [gopkg](https://github.com/niemeyer/gopkg) for my team. 
[removed]
Are you certain it takes less space in memory than a bool? I'm fairly confident that a bool takes the minimum possible space, unless an empty struct takes no memory at all, which I highly doubt. From my perspective, an empty struct implies (in fact guarantees) that ANYTHING AT ALL is allowed. I'll take a bool over an empty struct all day long.
100% agreement. This book is still the reference to own.
... that doesn't sound like something where the concurrency belongs inside the library. The caller can just call RichPreview one url at a time, very easily.
Go has Tensorflow bindings so you can run tensorflow models that are pre-trained, but I personally find it inconvenient to train models in it. You're better off with a more well-established API for training models like C++ or (my recommendation) Python. For training models, pure Go isn't ideal because it ends up introducing unnecessary overhead, while additionally not being able to use many of the implemented cuda libraries.
Strongly recommend. It's light on syntax and deep on motivation, problem-solving the Go way. It really gives you the Go mindset, and that's usually hard to find from blog posts and random articles on the internet that show you how to marshal JSON in Go. Definitely worth spending money on.
If you watch the Strange Loop channel, they're uploading the 2018 conference videos now: https://www.youtube.com/channel/UC_QIfHvN9auy2CoOdSfMWDw/videos I attended a talk there about re-implementing AlphaGo in the Go language, when it goes up you might want to watch it. It was pretty good.
Complex parameters passing, like multiple dimensions array, memory sharing between go runtime and c runtime. 
I just picked up this book as a newbie a few weeks ago. I think it's really well written, and is a nice balance between code samples and theory.
One at a time, wrapping and adding details at each point.
This is the best answer for a beginner IMHO.
Hopefully you don’t “just” write the error message. Always be in control of your output. Don’t let someone else determine what your API returns! ✅
That’s what interfaces and wrappers are for! ✅
Unify everyone else’s errors by wrapping them with your own type that implements the error interface. Go proverb: accept interfaces, return structs (six, concrete types) so no, most won’t be returned as “error interfaces”, but discrete implementations of error interface. But that’s not really at issue here...
&gt; Unify everyone else’s errors by wrapping them with your own type that implements the error interface. &gt; &gt; Sure, roll your own error system taking into account everybody's else error system. Lol no.
generally, errors.Wrap(err, "msg) works for us. However, we have some cases where this is not good. We want key-value fields that we search in splunk. We have a logger package and the logger has a logger.Add(key, value) field that will be printed when you call logger.Print\*(). We also have a concept where you make a child logger (child := logger.Child(); child.Add(key, val)) that helps keeping key values local to a function. The logger is passed around as an explicit param or in the context depending on the need. The logger prints all saved key values on any print statement and then those go into splunk and indexable and searchable fields. 
After using brew, it doesn't look like \~/go was a directory that was created. Any ideas?
`_`
This kind of steered me away from sync.Map https://www.reddit.com/r/golang/comments/6vf8bu/syncmap_examples/ What do you think? 
If there is an error with net.Lookuphost, the code is going to panic(), it appears to me. (and it seems like there would be many things outside your control that would cause a host lookup to fail) Maybe make the resolve function return the error and have main() in this case handle it? Also I would probably not pass the waitgroup as a dependency into the function, but that is me. The locking stuff looks pretty much like I would do it - may not explicitly use a RWMutex instead of a plain 'ol Mutex, but that is about it. Maybe make a reader which also locks, although the way you are printing them out should make that a YAGNI thing at this point. &amp;#x200B; As far as doing this go-idiomatically, I would ask yourself if you need a map at all, and instead use channels, unless you have plans for these other than printing them out once and then forgetting them. &amp;#x200B;
Thanks for the advice. Good point about panic() and error handling. I am planning on calling `https://ipinfo.io/%s/json` on each returned IP. Would using channels be better in this case?
You could call an anonymous function in the go-call in main, that would first call resolve (without wg) and then call Done afterwards.
I would make the gofunc handle the waitgroup stuff - using an anonymous function like so: `go func() {` `err := host.resolve(obj)` `/* do something with err maybe */` `wg.Done()` `}()` &amp;#x200B; then you could call this function in a goroutine, or not, or whatever, removing a bit of coupling.
https://en.wikipedia.org/wiki/ML_(programming_language) ? 
Wow, no need for AppVeyor?
You should be able to use the name of the sheet in the spreadsheet you want to grab in order to get the entire sheet. `shtsrv := //authenticated Sheets Service` `//values is a [] []intreface{}` `values, err := shtsrv.Spreadsheets.Values.Get("spreadsheetID", "sheetName").Do()` `//handle the error` `//printthe first value from the first row` `fmt.Println(values[0][0].(string))`
You saved me. Thanks a lot dude.
Like someone else suggested, I'd probably write some funcs that range a channel. You could have one set of workers reading the resolve channel, do the lookup, then pass the result to the ipinfo channel, and have another set of workers there doing the http call. They could either put their result into your locking map, or write to a final channel that had a single goroutine that just did your map work to avoid worrying about the lock. That way you could easily scale the number of DNS and HTTP workers if you needed to expand your processing.
I do something similar to this: https://middlemost.com/failure-is-your-domain/ 
Why are you using a map, at all? Just print out the answer immediately? Alternatively, use a buffered channel and spin up a consumer. I don't see the purpose of a map here.
Using a hash is an optimization, you can't cross your fingers and hope collisions don't happen, you always have to handle collisions. 
Hey everyone, So i've been thinking about Go and how I could use it for quite some time. The other day I finally had an idea. I was amazed how fast I was able to get it up and running. I would love to have it reviewed and have your comments and suggestions on it. &amp;#x200B; It comes with an installation script if you'd like (please let me know if you have any trouble) Otherwise if you do not want to install you can simple do: \`\`\` cd $(itree) \`\`\`
There's a lot of weird choices in there. Why make a waitgroup and then close it immediately in a good routine? Why have a waitgroup in a helper function that calls Done() once and Add() many additional times? I think you'd do well to read the Concurrency in Go book.
For me, it comes down to readability. The actual runtime cost of the reflection in attache is minimal, but I think it's a lot easier to read than your example. Your example is a perfectly valid approach, but it's not appropriate for all projects (just like Attache isn't). Attache provides a _lot_ more than just routing, though. It might actually benefit you to take a look in the code. Even if you don't personally agree with some of the abstractions, I feel like you'll at least understand what is being abstracted and why. Right now it just feels like you're being intentionally obtuse. Can you really not imagine situations in which a reusable abstraction could save some pain and time over a large hard-coded switch statement?
Use [Gorgonia](https://gorgonia.org/gorgonia)
That was me :)
You can just use [Gorgonia](https://gorgonia.org/gorgonia) to train. Less overhead than Tensorflow, define your model in Go and train using CUDA. 
Thank you 
I would keep \`wg.Done\` in the \`main\` function. It violates the SRP to put it in the map, and just looks weird. Make the goroutine invocation use an anonymous function that invokes resolve, then decrements the wait group. &amp;#x200B; As another post mentioned, you could have the goroutines simply write to a single channel with a consumer that writes to a regular map. It would remove the need for a special map here. Additionally, by doing so you would be able to easily decouple the number of resolvers from the number of arguments by varying the number of consumers, which, at a certain size, may be desirable to manage network concurrency.
To clarify one point, once you have multiple consumers, of course, then you need either a synchronized map again, or a single writer consumer. Your choice as far as tradeoffs. I noticed that in another comment in this thread you mentioned that you were worried that \`sync.Map\` would not be appropriate. Reading its docs, it seems that it should be fine so long as the keys are written either once or repeatedly by the same goroutine. That seems like the likely access pattern here so long as the hostnames are mostly unique (and if they aren't de-dupe them first).
Thank you. I don't really have a preference other that I have used it with PHP and I am more familiar. I will check those out.
This is nice, thank you.
They are so similar that you’ll have no problem with the basics. 
Do you have any screenshots of it? It'd be helpful to see something before downloading and running code.
Agree with sqlx, for migrations I like https://github.com/golang-migrate/migrate
i mean, once i write the tool/application how do i test it automatically since its interactive
I have seen awesome go and will probably revisit. Your framework will be something I will look into as well. Thank you!
Thanks for sharing.
[removed]
There are some teething issues to work out (e.g., see https://travis-ci.community/t/go-cant-find-gcc-with-go1-11-1-on-windows/293 and https://github.com/sourcegraph/go-vcs/pull/109#issuecomment-429500737), but this is great!
Here's a really simple example. https://gitlab.com/zendrulat123/goes https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk
You are 100% right about empty interface, thanks! Empty stuct creation MUST allocate some memory. If it’s not written down, it never happened...and they must fail a not nil check... 😊 But the payload could be zero bytes. Thanks for the schooling. Much appreciated...
https://dave.cheney.net/2014/03/25/the-empty-struct can explain it way better than I can. 
Thanks for the links!
I don’t know what to say. Check your hidden files. It was there for me. 
One thing to remember about parallel algos is that the work done needs to exceed the context switching overhead. Also for a cpu bound task you never want more go routines than the number of cores otherwise the context switch will definitely adversely affect you. Lastly, even if you have an 8 core machine you might have fewer cores available due to GC activity. Also, are you running on a multi core or cpu system?
Thank you for making this plugin Fatih. Sorry to see you leave. I learnt Go recently by having GOPL split on the left and VIM with vim-go on the right. I also used vim-go to code and deliver an agent sidecar in Golang recently. Running an OSS project is so hard - I have personally never gone beyond contributing bug fixes. I will donate via Patreon to show my support to future maintainers and hopefully keep their motivation up.
From what I understand, gccgo supports RISC-V. I wouldn't use that old 1.8 fork. 
Wow this looks amazing! Great documentation too!
You are right! The work to be benchmarked should not depend on b.N, which is controlled by the benchmark runner. The problem was due to my misunderstanding of the standard Go timer's benchmark [BenchmarkStartStop](https://github.com/golang/go/blob/b4150f76144808bf0015fe23be0e2ade32a14599/src/time/sleep_test.go#L163-L174), in which I mistook n (which is actually a constant value of [1000](https://github.com/golang/go/blob/b4150f76144808bf0015fe23be0e2ade32a14599/src/time/sleep_test.go#L106)) for b.N. For the preloading part, as I said in my previous reply, it is mainly for testing performance under a given data size N, since O(1) is not always faster than O(log N) until N becomes large enough (the fact that Go timer is implemented in the runtime will increase the threshold of N even further). And I have no idea how to simulate the "large enough N" case without preloading N timers. As for "preloading will affect the benchmark stability if the timer mechanism has the complexity of O(existing_timers) or O(existing_timers^2)", I'm not sure about that since I'm not an expert at Go benchmark, but I find that Go timer's benchmark also has [preloading](https://github.com/golang/go/blob/b4150f76144808bf0015fe23be0e2ade32a14599/src/time/sleep_test.go#L90-L100).
There's no point in pain, I guess it's done that way because no better way exists yet. &gt; it means the property of using a context becomes part of the type. And it should not be, context is inherent property of goroutine and should already have been moved from stdlib into builtins.
Would this be useful if I wanted to see the currently attached network drives to a windows machine?
Thank you.
I'm running on a notebook I5 with 4 cores and 8GB of RAM.
&gt; You might disagree, but to the Go team, having the context in the signature and needing to plumb it around is not a bug but a feature. Storing context in goroutine struct is also a valuable feature that besides rendering that plumbing unnecessary will also allow to get rid of unnatural usage rules for context, effectively making them part of the language.
Hi! Any word on when the issue of Go imports from VSTS will be fixed? (See [here](https://visualstudio.uservoice.com/forums/330519-visual-studio-team-services/suggestions/34888885-support-repos-for-golang-by-providing-a-url-alias), [here](https://visualstudio.uservoice.com/forums/330519-visual-studio-team-services/suggestions/20364613-add-golang-support-to-vsts-git) and [here](http://ppanyukov.github.io/2017/02/01/golang-with-vsts-repos.html). This has become especially important with the introduction of Go modules. To fully take advantage of Go modules you need correct import paths. And is effectively blocking my team from using Go modules at the moment.
We're joking, not being serious :-)
Big whooosh then
There have been _no_ changes to the language. Just out of curiosity: Why do you think there have been (relöevant or interesting) language changes?
You answered my question. “Rust will try”... There is no try I suppose this discussion have no purpose. In the of day Rust is not bad language. Rust just not cover his promises. In case if I need real low development I still will prefer C. Yes. C. Not overcomplicated C++. And yes. Not a Rust. And for everything else I still will use Go. Period. P.S. memory management very easy and straightforward in C compare to C++.
I'm currently enjoying using https://gnorm.org/ for automatically generating code for talking to the database (https://github.com/xo/xo is another option I evaluated). Mix this with any other SQL statements you need to hand write. I'd also like to echo recommendations for postgresql, sqlx, chi, and keeping it simple.
https://golang.org/doc/go1.11#riscv
As of 1.11, GOPATH is quite optional. On the other hand I could never figure out how people have so much trouble with a damn env variable
I was organizing all my server and client code un one repo. Using go I started to follow their opinion and break stuff in its own repo. Éven Js clients. And I started to realize it was the right thing to do. Then came go 1.11 and everything was nice 
Well, first of all network drives aren't actually hardware attached to the local machine so I'm not sure they're in scope of this library (though obviously they're running on hardware *somewhere*). Second, it looks like all of the OS-specific parts are currently only implemented on Linux so don't get your hopes up either way.
I get quite depressed when I see people fail to pick up a language over having to set an environment variable or where to put a {. Did Go ever have this problem way back when before there was a Windows port? I guess a lot of younger programmers have never used environment variables anymore in general.
Why q.Word is better than strings.Fields ? No more leftpad, please!
1. You can specify a commit hash or tag name in go.mod. 2. If you set something manually like in the step above, that will be converted into a pseudo-version string, as you observed. I don't believe there's any way to prevent this. The goal is for everyone to use semver. 3. `go mod tidy` is currently slightly magical and can do strange things, which will hopefully improve over time. That said, I suspect the extra dependencies are because the command ignores build tags, so the extra dependencies are probably for building on other operating systems, which is why it builds fine for you without them.
As I said, many people use this pattern and like it. I personally don't. On top of that, forcing someone into a pattern is a problem. Like, picture a console program forcing you to use powershell. cmd, bash, zsh, any other won't work. Would that be nice? I personally find powershell a nice thingy, but I wouldn't force anybody using console apps I write to use them only on powershell.
Are you aware of the Go module system introduced in 1.11?
Glad to know the builtin feature. I was trying to build some Ruby like quoting... Thanks
I totally agree, it's a matter of personal preference, coding style, etc. I always end up fighting the abstraction on these kinds of things. It all starts off cozy and happy, with the abstraction (once set up) allowing me to add (in this case) new routes really easily. And then I want to do something that the abstraction doesn't work for. I roll up my sleeves and dive into the abstraction code again, working out how I can add the new thing. And then there's the case where I can't, not without a lot of time and effort, or without breaking the elegance of the abstraction. So (depending on how tight the deadlines are) I either spend a week reworking the abstraction and recoding everything that depends on it (possibly even going to other projects that depend on it to update them), or I compromise and catch the request before it gets to the abstraction, diverting it away to a custom handler so that the rest of the code can carry on. And I live with the shame, and have the broken abstraction sitting on my to-do list for years. I love abstractions when they're needed, to black-box complexity and stop one bit of code from caring how another bit works. But they can become a problem, there are costs to abstracting complexity. Which is why I question the need for it on such a simple decision as this. But this is not intended as criticism, and I apologise if it feels like that (which I get it totally could). I was trying to understand if I'd missed something about routing that required the abstraction.
Sure, but it's not widely adopted, and any project that is not using modules must fall back to using GOPATH. The entire Go ecosystem needs to migrate to using modules before users can ignore GOPATH.
I am yet to see a production application using this implementation. As far as I've tried to use it, it mostly did not work and just choke and was unable to ever reconnect after disconnections.
Looks like the google repo points to a dead website. Have you checked their new one for downloads? https://github.com/libusb/libusb https://libusb.info/
Makefile is just an example. The only problem here is that you need a shell for the \`&amp;&amp;\` operator. Like the old saying "Ya cant please reddit users, ever" ¯\\\_(ツ)\_/¯
Nitpick correction: There have been (almost) no backwards incompatible changes to the language. There have been changes to the language. E.g.: off the top of my head, you can now do `for range foo { f() }` where with Go 1.0 you had to do something like `for _ = range foo { f() }`; that's a change in the language even though the old code still works it's still a change.
With Go 1.11 you can use Go module just now without waiting anything else, even if your dependencies doesn't use module. This outside or inside GOPATH as you want. https://github.com/golang/go/wiki/Modules
with gorgonia, am I need to create my own saver and loader of model ?
WRT `go mod tidy` I suspect the issue in this specific case is that the dependant module lacks it own `go.mod` file but has dependencies of it's own. E.g. If you `import "example.com/modA/pkgA"` which in turn has `import "example.com/modB/pkgB"` and if modA doesn't have a go.mod that says what version of modB to use; then that that information must be in *your* `go.mod` otherwise you cannot get a repeatable build. In this case your `go.mod` file will have a require line for modB with a `// indirect` comment.
Sorry, I lost you with the Haskell and Monad, let's continue the discussion with Go :-) As I tried to show in the post, it is not just pain, it also makes things impossible. For example, using GORM with context for SQL queries - just becasue GORM's maintainer object the idea of context.
You misunderstood me when I said try to disallow, when I say it will try to disallow memory issues I mean it won't compile unless you drop into unsafe rust mode. You still haven't addressed rusts safety, rust is much safer than C++ and also C while still having comparable performance. 
I tried to give a small , non-breaking change - that will provide better handling of the context. I don't think that breaking the current API is a good idea. &amp;#x200B;
There are lots of reasons you would use UDP. For instance, I help run a VoIP company and media streaming is all in UDP. DNS runs over UDP as well. 
A useful exercise for any OO-ish language (yeah i know Go isnt really OO, humour me) is to look at your code and see if you have a number of functions that have similar signatures For example `func A(x, y string, a int)` `func B(x, y string, b int, c []byte)` `func A(x, y string, a int, a bool)` If you see these kind of patterns emerging it might be appropriate to refactor `x` and `y` into a type and then move the func into methods. The reason being is that the code before implies they are coupled in some kind of way as a concept.
I guess you didn't get the packet
The problem with GOPATH was never the env var. That’s quite a straw man argument, and misses the true criticism. The issue is that GOPATH dictates a structure *above* the root of your project, making it awkward to set up. And, every project has a different GOPATH meaning you have to jump through hoops every time. Especially for people who start their project in source control. Consider An alternative implementation where GOPATH allowed you to pull dependencies into a sub folder which you then either add to your .gitignore or make into submodules. I think that would have alleviated all the complaints. Alternatively, having adopted the Python virtualenv concept of having one base directory somewhere else on your system outside of your project with a subdirectory for every project’s dependencies would have been another foot alternative. Instead we have a situation in go where there are two project roots - one for GOPATH and one for git and that’s really weird for newcomers. Heck, it’s still weird for me after 2 years of Go coding.
Funny that you mention it, I wrote a [similar thing](https://GitHub.com/mewa/faketcp) in C some time ago. Though it is definitely not production ready ;)
Maybe because of the missing session management
Go really drove home to me that function arguments, struct members, and closure variables are really three ways of doing the same thing.
 I remember a time where frameworks and libs were selling themselves as « not opinionated ». We were free to mess around. And we did. And lost a lot of time. That was for, I think, please the maximum of people. But by trying to please everybody you please no one. I now like opinionated product designed well. Like Vuejs. Because I and we as a team do not want spend 40% of our time arguing about where to put what or how we name things. Go made really strong decisions (gofmt, gopath, ..) that you may not like but it saves a spectacular lot of time. You are left only thinking about your code not your code organization. But it may not suits your taste. 
Reliable UDP? Hmmmm. Maybe we could solve this with a new protocol. One that does transmission controllably. A transmission control protocol. 
I don't know if we are on the same page here but don't you ment to say struct + function, object + method and closure are equivalent?
This question was also asked a week ago: https://www.reddit.com/r/golang/comments/9ls611/when_to_use_methods/?utm_source=reddit-android 
Thank you for the link. There is the rule there I just realised here. There it is written as: • Is your function querying a stateful object (i.e.: might calling the same method with the same arguments produce a different result)? Use a method. I added it.
quic
UDP is just without the reliable aspect. You have to add. UDP is a lot like raw Ethernet.
&gt; Key Takeaways &gt; * Testify helps you to simplify the way you write assertions within your test cases. How exactly does `testify/assert` simplify anything? You've added a dependency to your project so you can compare two integers like this ``` assert.Equal(t, Calculate(2), 4) ``` ...instead of like this... ``` if Calculate(2) != 4 { t.Error("Expected 2 + 2 to equal 4") } ``` That's fewer lines of code, but it's not simpler. With `assert`, the two ints are being passed as `interface{}` objects. Then reflection is used to deduce their types. Then finally an `==` comparison is made. That's way more complicated than just performing the `==` comparison yourself. `testify/assert` doesn't solve any real problem, but it does cause problems in the form of A) dependency headaches, and B) surprising behavior. Nobody using that package reads through the hundreds of source lines to see what `assert.Equal()` actually does. *tl;dr* You don't need an assert package.
In addition to all of this, assert libraries also lead to worse failure messages. There's just so much that the programmer knows and can add to the error message to help a future maintainer. Some assert libraries let you add a message, but by the time you get to this point you've introduced another special purpose language to your tests (assert libraries are a DSL), and you still don't have the flexibility of the simple formatted error. See also: https://github.com/golang/go/wiki/CodeReviewComments#useful-test-failures
DNS over HTTPS is an upcoming technology
Where do you draw the line between too many repetitive code and too many dependencies? Testify helps by forcing somewhat of a testing standard while sticking to the idiomatic go coding style. I can imagine a team of developers with different ways of asserting, mocking, packaging, output error messages on tests. In fact I've worked in this field to know that will definitely happen to a growing team. If it means a lightweight package will prevent this then it's worth it.
I've seen a few projects in the past year try switching to it only to abandon it after running into all kinds of issues. For example: https://github.com/syncthing/syncthing/issues?q=KCP Has anything changed?
As long as you're willing to write the code for it, you don't need any packages... First, you'll realize you have this pattern repeating in your code: ``` if someObj.someKey != "my-expected-value" { t.Fatalf("Expected \"%s\" but got \"%s\", "my-expected-value", someObj.someKey); } if anotherObj.anotherKey != "another-value" { t.Fatalf("Expected \"%s\" but got \"%s\", "another-value", anotherObj.anotherKey); } ``` And then it's not a stretch of imagination to think *"oh, I might just have an assert function that does this because I'm doing this assertion over 250 times in my code..."* So we get `assertStrEqual(t *testing.T, expected, actual string) {...}` And then later `assertIntEqual(t *testing.T, expected, actual int) {...}` And then you put them in a package because you realize you have 300 more assertions in your other project! And then you put it online because *some* people might also not want to manually write every check on their own. **tl;dr** you can use assertion packages. It's OK.
`GOPATH` and the `vendor` alternative are on the way out. With modules you develop each project outside `GOPATH` and they can use different versions of the module.
Replacing a three-line `if` with a one-line `assert` doesn't lower the number of assertions. It just lowers the line count. I'm arguing that it's not worth adding the dependency. If you write table-driven tests, you typically have one or two assertions per test. _Manually_ writing a couple `if`s per test is not some huge burden we need to overcome.
sync.Map has performance that makes it better for write once, read many situations, like a cache. Whether it fits your problem depends on more about the overall problem, but given the scenario of just wanting to do a couple of lookups simultaneously, probably it's not as good as a mutex. But my personal preference is to do a [coordinating loop](https://blog.carlmjohnson.net/post/share-memory-by-communicating/) where possible.
And how many lines does a repeating logic need to be in code before it is refactored? 4? 10? 20? Just assume some people have more than a few assertions in their code :) And they have a lower barrier for re-writing repeating blocks of code.
[libusb](https://libusb.info/) has the link to the current binary version of for windows, which works on windows 10. I have [Win-builds](http://win-builds.org/) installed too, don't know if it is necessary tho.. but i remember i had trouble before i found winbuilds. ymmv. I've used gousb in the past on windows with (some) success but did switch to a USB HID package ([hid](http://github.com/karalabe/hid )is what i used in the end) as it was easier for my task. Worked for me under windows and linux in the end. Don't even bother over darwin thats just hellish broken with the kernel security. 
Indeed double buffering only answers the "updating in real time" part of the question. Real interactivity of course requires more than that. Mouse tracking, event loops, all that stuff. 
:) I went in just to write the same comment
&gt;https://github.com/golang/go/wiki/Modules I actually disagree with you. C# is like: "have a .csproj file and a .sln file". Other than that, the project structure is as you wish. Same in node.js with node\_modules and package.json. Other than that, the project can be as you see fit. This made me create a consistent pattern that I use in all programming languages and that gets me up to speed insanely fast. Meanwhile, in Go land or Maven land, that is simply impossible and, before starting the project, I have to figure my way around where I need to place my source code so it will work well with everything. Also, Vue is unopinionated as heck! You can just drop one Vue component in an existing project and it works just fine. You can use Vue in any way you see fit! 2nd also, almost all languages and stuff still give you recommendations on how things would be good. They just don't force you onto them. &amp;#x200B; Somewhat unrelated, Dart is a nice language and unopinionated too. dartfmt, however, is "ONLY THIS WAY". My solution: disable dartfmt entirely, use the formatter built in IntelliJ IDEA with my configurations. If somebody doesn't like the way my files look, they can dartfmt themselves.
I have all of that but installing the gousb package keeps throwing the error about the missing 'libusb-1.0.pc' and nothing I do seems to correct this. I need low-level usb interface, so hid isn't going to work.
On top of that, the first thing you are told in [Getting Started](https://golang.org/doc/install) is "Create your workspace directory, $HOME/go. (If you'd like to use a different directory, you will need to set the GOPATH environment variable.)" There simply was no way for me to ever know of modules unless they were mentioned here. Coming back at the title of this post, "GOPATH **preventing adoption**" (could have probably chosen better words). You're already told in get started to either use $HOME/go or setup GOPATH. How about my "GoTest" folder in my "Tests" folder, next to the "RubyTest" and "SwiftTest" folders where I test new programming languages? You're not told "ye, you can use modules", you're told "setup GOPATH and only code there ever again", especially since GOPATH is intended to be only one folder, even if allows multiple ones.
At least I wasn't the only one who saw the problem then. Old apps will still rely on GOPATH, so I still won't be able to build it, but it's - at least - a step forward.
[removed]
I have seen [ENet](http://enet.bespin.org/) which is similar to kcp in lots of projects involving games. I'm no expert when it comes to games or networking so my insight ends here.
I prefer MySQL as it has better support for JSON aggregation as of now. and JSON aggreg basically allows you to get rid of ORM.
[removed]
No, development happens in GOPATH or, as an [experimental feature in Go 1.11](https://golang.org/cmd/go/#hdr-Modules__module_versions__and_more), in any directory you like. The contents of the Go installation directory should not be modified, as the next update might wipe away all the changes.
OK, I see. You are talking about a form of partial function application (which works best in languages that do currying), what I was referring to more or less was the equivalency (all touring-complete) of the three (actually four) programming paradigms: procedural, OOP, functional (and logical). These different ways of doing partial function application reflect each a paradigm though.
Wow. Just wow. /u/n1ghtm4n is reminding the Go way of doing things and he gets downvoted. I am disappointed by the community. I guess there's no helping it. Now that Go is becoming popular, there's a bunch of new people that do not understand the Go philosophy and just cargo cult whatever they know from other languages. Because why would they bother to learn something new? Of course they already know all they need to know. I will paraphrase Pike and say "... and the open source community has made sure Go has become less maintainable over time".
I can just imagine code complexity clients and servers have to deal with to make this reliable. Have you tried SCTP? Perhaps you didn't look hard enough. 
The go way of doing things is to completely forget about DRY? Testify isn’t perfect but if it didn’t exist I would’ve written something exactly like it for my own use.
Looks great! Definitely something to keep an eye on..
&gt; The go way of doing things is to completely forget about DRY? It's about proper error reporting and easier maintenance (among other things): * https://golang.org/doc/faq#assertions * https://golang.org/doc/faq#testing_framework 
If you are wanting something quick to do proof of concept stuff, I would also take a look at Go Buffalo. It’s a “framework” written in the same vein as Rails... right down to some of the commands. I believe as of the last version you can create an “API only” app also (no html, css, webpack, etc). 
My 2c, With higher rtt connections you could forgo the three-way handshake and acknowledgments. Any Transmissions would be handled at higher layers, possibly increasing throughput.
you create your own model. You save it to gob files or protobuf or flatbuf
Really nice. If you're interested in adding streaming/file encryption/decryption there lots of good existing Go projects. If using passwords to encrypt things I recommend you copy the "decrypto" AES-CTR + HMAC + scrypt password strengthening implementation found in [https://github.com/sselph/drive/tree/master/src/dcrypto](https://github.com/sselph/drive/tree/master/src/dcrypto). If you want to have client-side keys for a mobile/web app then you could use [https://github.com/Xeoncross/go-aesctr-with-hmac](https://github.com/Xeoncross/go-aesctr-with-hmac) \+ a Javascript version ([https://stackoverflow.com/questions/36909746/aes-ctr-encrypt-in-cryptojs-and-decrypt-in-go-lang](https://stackoverflow.com/questions/36909746/aes-ctr-encrypt-in-cryptojs-and-decrypt-in-go-lang))
It would be very unusual to find pcap files where the packets are not time sorted, so you've created a lot of complexity in your program to handle a rare edge case. See for example the mergecap tool in wireshark-common - it assumes the pcaps are time-ordered. wireshark-common also includes a tool for sorting pcap files: reordercap.
&gt; Proper error handling means letting other tests run after one has failed This is what testify does; just because the package is called “assert” doesn’t mean it works like the asserts that the FAQ mentions. The first link is talking about traditional runtime assertions, basically panic but for debug builds. It’s how e.g. pytest works. Yes, pytest’s error reporting is a bit unhelpful. And yes, one criticism one could make about testify is that the descriptive error message is optional in the checks. &gt; testing frameworks tend to develop into mini-languages of their own, with conditionals and controls and printing mechanisms Testify is a few functions, not a mini-language. It’s trivially easy to understand. &gt; the test might work better if table-driven ... The work to write a good test and good error messages will then be amortized over many test cases “Amortized over many test cases” suggests helper functions, because there’s no other way to reuse code across functions. The helper functions involved are usually pretty specific, and making a generic library like testify for table-driven functions would be bad for code readability. As a programmer, one of the most frustrating things is when I have to type a pile of code many times with small variations, to the point where my brain is sitting idle waiting for my fingers to finish. There’s a name for the trick that languages have to deal with this: it’s called a function. I like the tension between DRY and inlining in Go. I’ve definitely taken DRY too far in languages that seem to encourage it like C++ and C# and Python. But a tiny helper library like testify is so trivially understandable and such an obvious win for my sanity that I can’t imagine not using it.
Thank you very much for the good reviews and the stars on GitHub. It means a lot to us! What you see there was created in about one month of continuous development time. Ideally we find a way to work on this full-time. It's not easy to find funding, especially for such a young project. Public attention might help. We know we can do it technically, we've done it many times before (but for commercial projects).
Everyone is going to tell you that you don't need a web framework in Golang. This is true. But, in the case you want to use one, I'd recommend Gin or Meego. Have no idea what the Echo syntax looks like.
Do you mean beego
Yap
Thousands of lines of code does stuff, trust me. Bindgen is much more complete and closely describes what the OP is looking for: autogenerated stable ffi bindings. Cgo is a half baked approach towards that atm 
Why not rewrite to python? Doesnt the python runtime have the best cold start times? For lambdas that metric seems to matter most if the function is scoped well 
From [https://blog.golang.org/strings](https://blog.golang.org/strings): &gt;The Go language defines the word rune as an alias for the type int32, so programs can be clear when an integer value represents a code point. Essentially you use runes when you are dealing with potentially-multibyte-characters, rather than bytes or integers or strings.
Just found aah. I looks very promising but never made a project with it.
Decoding a UTF-8 file into its individual runes for statistics, processing or editing. E.g. at my company we use runes in a server that processes edits like Google docs because javascript handles strings weirdly and in order to account for that, we process the individual runes in files.
Thank you!
I’ve found the user management to be much more straightforward, mainly because there are fewer options in MariaDB. Additionally configuring things like TLS based user authentication is slightly simpler. Postgres has a lot of additional concepts and even if you don’t want to use them they leak. You have to have at least some understanding of them to get by. Do most projects need _object_ relational? No. The ability to define new types? No. Sub-schemas in a database? Nope. Columns that can contain arrays? I could certainly make up a use case but would arrays be critical? Probably not. All of these options increase the entropy of the system, and as devs we’re already going to do plenty of that ourselves. 
Thanks. Will check it a bit more, but Echo is the equivalent of Flask in the Python world. Sort of a micro-framework wereas Aah seems more along the lines of Django (more batteries included, but also you are farther away from what is actually happening through layers of obfuscation)
Beego seems like either dead or on its way to it. For example see [this thread] (https://groups.google.com/forum/#!topic/beego-framework/EEcpa6IgIpk)
I reviewed the code, you are not parallelizing anything - you are moving the work to another thread, and paying the costs (channels and wait group sync). If you really want to parallelize it - it might still be slower since the work is trivial - you would start multiple go routines - each starting at a different index. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
Suggesting there is only one true way to write Go code is bad for the community.
Please expand on that. Right now you're just coming off as "A rocks, B sucks" fanboy.
As far as I can see from its commit history, it i very much active, calling it Zombie is a bit of stretch.
Sorry. The "No" was to what part of my question (just trying to make sure I understand correctly) &amp;#x200B; 1. dev happens in gopath so if GOPATH is \~/go all of my go code has to live there? 2. Go install directory shouldn't be modified. Go isn't installed in \~/go right? I used brew, so it's probably in the typical brew location?
I like working with Gin.
Another potential reason for using a receiver over a function: when the function name is generic, the receiver type can disambiguate it. As an example: a.Equals(b) as opposed to Equals(a, b).
Agree. Also it looks more alive than it's closest competitor, Gin.
&gt;The sad thing is that the developer is still, once in a while, doing work on it; he is just nowhere to be found answering questions / helping users, or merging PRs. Looking at https://github.com/labstack/echo/commits/master it seems the author is actively developing it and merging pull requests. Saying it's a sad thing and calling the project dead or a zombie is insulting to the work he has provided, for free, to many users in the Go community. Maybe that's not enough for you but it's an open source project and the author isn't obligated to answer questions / help users. Your attitude reminds me of a [recent post](https://arslan.io/2018/10/09/taking-an-indefinite-sabbatical-from-my-projects/) where a great open source contributor got burnt out by the endless demand for support on his open source projects and ended up having to give up on them to focus on his own personal life and actual career.
https://play.golang.org/p/4Ts43rxDioS
Dealing with strings where you need to work with the actual characters. Using len(string) won't work for everything utf-8 supports. Take for instance dealing with the Japanese language: https://play.golang.org/p/11OSUI2-zvy
Thanks, that helps a lot!
This makes it clearer, thanks!
if byteSlice[0] == byte('!') {} Can be good for checking for prefix
Non if these is of any interest to a newbie trying to learn the langugae and of no interest to anyone using the language.
Nobody said that the way the Go team suggests to do things is the one true way. But it is still the Go team's way.
Yes, thank for your answer. And it lay under the 2nd and the last rules. 
Looks like it "imports" images, rather than indexes the images you might have scattered upon your filesystem? That's a dealbreaker for some - me included. I have around 1.5Tb of images stored at `~/Images/$year/$day/$event/{ RAW JPG Thumbs }`, I don't have space for a second-copy, so importing them would fail. I just want to index and browse quickly/easily.
Did you want to say "namespacing"?
Which RISC-V emulator are you using? TintEmu by Fabrice Bellard?
I don't know what echo's syntax looks like, but [Buffalo](https://gobuffalo.io/en) is really nice.
Hi, nice project. If you run Tensorflow models locally, please clarify. Currently it reads like you're running them on Google's cloud ("Google Tensorflow") and that would go against the privacy idea.
Even better, just index perkeep (of perkeep.org), that downloads my photos from everywhere, automatically.
See [this](https://forum.labstack.com/t/future-of-echo-project-still-alive/690/3) post on the Echo forum. The author did not respond until I sent him an email and after his one reply he dropped off. &gt; Your attitude I like the project. I want to help the project, but as a new Go developer digging in the source code of Echo not very viable. I started out with documentation, but those are not getting looked into either. In my opinion the long term viability of a project depend on either the ability of the one developer to keep up, or him allowing others to help him. From the PRs it does seem like there are others, myself included, that want to help the project, but what exactly should we do beyond submitting a PR or opening an issue? Day after day I look at the forum posts to see if I an help someone and most of the time I would not even know how to begin to help the requester.
It also had a great, active community on slack.
Anyone using webp? How do you deal with browsers not supporting it?
Damn, I wish this was integrated into Digikam https://www.digikam.org
My general suggestion is ask "Would an &lt;object&gt; do this, or would I do this to an &lt;object&gt;?". If you answer the former then it should be a receiver for readability. Consider: func (d Dog) Bark() {...} func Pet(d Dog) {...}
I'm surprised they don't mention the go frontend for llvm as that has a risc v backend
[removed]
I wrote it that way because you are coming off the same way in the other direction :) it was meant to be ironic. 
Don't need a separate build tool. I use a simple shell script that creates a relative fake GOPATH linking the code into it. Now I can clone the git project anywhere using the standard go build command to build it.
Use .gif instead
Godoc 
Been a long time away from openGL but I suspect you either need to tune the OGL options, there's a basic assumption you're missing (OGL is not intuitive) or there's an issue with the go bindings. 
&gt; Last time I tried the new Margo extension it was missing significant features vs. stock GoSublime. Things like method creation snippets. The best way to get things fixed is to file issues. With that said that, this is what snippets look like today: https://margo.sh/tmp/gs/demo.mp4 I'm sure they can be improved further, but I think they're already far better than the GoSublime snippets ever were. And now that they're written in Go, you're free to create your own snippets using the same packages that margo uses to create the default snippets.
I’ve seen this held up as an anti-pattern a lot. Beyond error handling, it also means there’s no control over when the goroutine exits. Passing a done channel or a context can help with the exit problem. Error handling can depend on the situation. Sometimes a “best efforts” task is all you need. If you’re firing off a number of worker goroutines, you’d want a wait group with an error channel. If I saw a single goroutine fired off for a task like this I’d have a hard think about what it wanted to achieve, even if it handled errors well.
Swaggo combined with echo 
Depending on who you ask, it's suggested that you shouldn't be auto-generating the API Spec docs. If you're referring to OpenAPI/Swagger documents, ideally those are the "Source of Truth" which can then be used to auto-generate code, not the other way around. For example, this project can generate client/server code from a Swagger spec for Go: https://github.com/go-swagger/go-swagger, or https://github.com/swagger-api/swagger-codegen Other tools, like [Dredd](https://github.com/apiaryio/dredd), can be used to validate the server against the spec. This also assumes the spec is the SoT, as mentioned earlier.
If you don't care about all the other features like picture content recognition or album sharing and collaboration then there is another way to get an automatic backup. There are apps watching and automatically backing up one or more selected directories. Then you only need to configure this app or the camera app to use this directory. Nextcloud is such an option.
I’m of the other opinion that Go was designed to be abused in fairly obvious ways. This is one of them. If you’re not running out of descriptors, suffering from hung cores, or have memory leaks then just do it and revisit if you’ve got problems. Better to isolate half-arsed code into its own goroutine and save the brain cycles for bigger problems. 
My preferred solution to problems like these would be to use https://godoc.org/golang.org/x/sync/errgroup, which provides a nice, idiomatic way to deal with concurrent or background tasks. I would also use a context to control the background job and signal when it should be stopped. The errgroup package also has a nice context wrapper that automatically cancels the context whenever a job returns an error.
If the task is independent, I see no issue with this approach. For example, let's say I have a service that serves a website allowing users to view arbitrary log messages from other services. Each other service sends these messages to this log aggregator service via a plain TCP connection. I would solve the issue by creating a TCP listener to run in its own goroutine, where the only job of the listener is to accept new messages and throw them in the database. Meanwhile, the "main" goroutine would be responsible for serving the website. No interaction between the two routines is necessary. The TCP listener could easily be a microservice- and throwing it in its own permanent goroutine is essentially doing just that. Of course, if throwing functions in a goroutine is just a lazy sidestep for solving some issue, then that's a problem.
&gt; I can just run gif2webp Yeah. In fact, that's exactly what this project does: ```exec.Command("gif2webp", "-mixed", "-q", strconv.Itoa(int(q)), "-o", "-", "--", "-")``` Looks like it's really just a containerized REST interface to gif2webp, which seems sort of overkill. 
I took a look at the source. It's basically because of this: ```exec.Command("gif2webp", "-mixed", "-q", strconv.Itoa(int(q)), "-o", "-", "--", "-")``` The Go part of this is just the REST API -- it's using `gif2webp` which is installed in the Docker container.
I guess it is a fun little learning experience. But Yeah i dont See a real usecase 
I mean, I don't like shitting on anyone's free software project. I just really can't think of a single scenario where this would be useful.
Yup I prefer this approach. I don't randomly spew code then have some tool tell me what it does - I decide what I want my code to do, then work forward from there.
I get the feeling OP is using this project to learn how to build containerized services, more than anything else.
Or you call goroutine on a method which is accessing map, and there goes your concurrency in panic
Most of the linters warn about ignoring errors, and if you aren't using them you are shooting yourselves in the foot. Gometalinter for your linting needs if curious
Does it already work? Last time I checked, like two month ago it wasn't even mentioned on the llvms website. 
In your entry point 1) Create a gRPC server. 2) Import a package that implements the gRPC service. 3) Import the generated package and call RegisterSERVICE function with the gRPC server and the service implementation. This is of the top of my head so it may be wrong but is how I remember it.
Context is important. In your example, the function returns an error which must be handled. But that's not specific to using \`go\` keyword, but writing good code in general. If you run a function that returns a possibly show-stopping error (e.g. error creating file that is needed further down the line), ignoring it would be a bad practice, regardless of whether this function is called with \`go\` keyword or synchronously. &amp;#x200B; I'm not a big fan of "anti-pattern" word. I found that many so called "anti-patterns" make complete sense in a different context. 
This is many months old (probably even a year old). Could you add some comments to explain what you want us to see?
Use sync.map, it handles this for you and has been vetted: https://golang.org/pkg/sync/ What you're trying to do manually is simple enough and you're going to end up with the same process, if you want to see what's under the hood: 
idiomatic == use the std lib, use go language idioms (like error as values instead of panics). idiomatic =/= what is the most popular routing library used So your question isn't really about idioms. If you are looking for ASP.net MVC in Go, there is no such thing. You'll have to go pick and choose libraries one by one. There a few frameworks claiming to be "fullstack", they are not, not in the ASP.net MVC sense.
Use sync.map, it handles this for you and has been vetted: https://golang.org/pkg/sync/ What you're trying to do manually is simple enough and you're going to end up with the same process, if you want to see what's under the hood: https://golang.org/src/sync/map.go
Really clean code
Thanks to everyone for your invaluable feedback. It seems that my instinct was probably probably on the right track. Folks have made good points about context and I did intentionally provide a fairly vague example. I appreciate the simplicity offered by just kicking off some arbitrary idempotent $THING without over-complicating more important aspects. In more concrete and production facing examples that I have come across professionally I think it is important to provide educational feedback. I have introduced the errgroup package for other concurrency patterns in the past. I think my approach going forward will be to establish similar conventions that encourage more explicit communication and error handling in a way that is lightweight, clear, and nonabrasive. Cheers!
Qemu with fedora. Temu keeps crashing something about the display memory using the default config from the temu docs. Haven't tried without a display config yet. 
&gt; fasthttp + fasthttprouter + gojay Only use them if you really really need that performance. &gt; Preferred directory structure Something like [this](https://github.com/katzien/go-structure-examples/tree/master/domain-hex) (maybe? would like to see other people's opinions on this). &gt; Does anyone recommend any good guideline? Maybe a book, or a set of docs. Thanks for the attention! There are scattered around in bunch of talks/blog posts sadly... * https://golang.org/doc/effective_go.html * https://peter.bourgon.org/go-for-industrial-programming * https://middlemost.com/failure-is-your-domain/ * https://www.youtube.com/watch?v=VQym87o91f8 * https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1 
Well two things. A. Go makes you already do functional but you split it into types. That whole reader/writer is built on functional programming. You are building out params based on methods already on certain types. B. He has a course in udemy I thought was good cause he went into hours of the interpretor of JavaScript, but then I realized I'm gonna forget this stuff cause my projects just don't have much to do with it. 
You are 100% right, but this article is also old and the author has since admitted go is now his primary language choice. He also has clearly shown that he has a terrible ego and probably not worked in environments where you have large code bases or lots of teams.
This seems like a code smell. If it's truly a fire and forget background process, then fine. But if not, then you may want to reconsider the design of your service and how you're handling concurrency in general. As others have said, passing in a done channel and/or context would likely solve the problem. Another option, design a way to have 1 or more functions running concurrently. We routinely (no pun intended) have multiple go routines running in a block where we accumulate multiple error responses. Once they've all finished, we check to see if any of the routines returned errors. 
I think you missed the point of the article if you think that the author feeling smart is the problem. The point is that Go lacks useful abstractions which can limit programmers to the point where they write less readable code. And I'd hardly say he's cherry-picking examples, reduce and reading from stdin are very common so things someone would want to do. Not to mention generics and dependencies do seem to draw back to the thesis. Generics are a useful abstraction that seem to be omitted to make Go simpler. And it deal with dependencies in a overly simplistic way that doesn't give enough power to the programmer.
Any article that uses phrases like "lesser programmers" is immediately suspect in my eyes.
Were you suspect when he said that "They’re not capable of understanding a brilliant language"? Oh wait that wasn't the author
The assert commands shave a few lines from tests here and there, but there's value in testify's diff output for things like complex json. For instance, I write large json payloads to .golden files and when I break tests, the small line-diff output from their assertEqual log is handy.
This looks to me like the author took some Rob Pike quotes out of context and made them into something they weren't. His examples were pretty contrived and not idiomatic too. Why would he use the `Flags` library in the first example other than to make the Go example seem longer? Why would he not utilize an `[]interface{}` or a variadic if you really need to handle arbitrary ints? Here's an example: ``` func sumInts(list ...interface{}) (result int64, err error) { for x := 0; x &lt; len(list); x++ { var item int64 item, err = strconv.ParseInt(fmt.Sprint(list[x]), 10, 64) if err != nil { return } result += item } return } ``` It seems like this guy just got a little butthurt and his pride was bruised because Rob and Go don't stroke egos. When I compare Golang syntax to say, Python, I do get a little sad too so I get it. Really. But when I compare it to C/C++ I could not be happier. And when I compare the community and resources available to D's? Please!
This is a very good criticism, thanks. 
[Here's a simple example](https://play.golang.org/p/wpSZweNH63O) using the flag package.
The Go code given as an example was convoluted and nonidiomatic. Conclusions drawn from it about the language aren't coherent.
That's a fair point
[https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html](https://www.ardanlabs.com/blog/2017/02/package-oriented-design.html) I quite like this style
&gt; the need of programmers to feel intelligent My code got a lot better when I started writing it for my future self, who is known by my current self to be a forgetful, distracted, busy, stressed out idiot.
[removed]
If you are using golden files and comparing them as multi-line strings you might be interested in [`gotest.tools/golden`](https://godoc.org/gotest.tools/golden). It provides diffs using the same library as `testify`, but also supports updating the files when values change using the `-test.update-golden` flag on `go test`. If you're comparing them as structures, [`assert.DeepEqual`](https://godoc.org/gotest.tools/assert#DeepEqual) uses [go-cmp](https://godoc.org/github.com/google/go-cmp/cmp) which provides better diffs. Pointers addresses don't show up in the diff and each difference includes the path to the diff in the structure, instead of just the diff line. `go-cmp` also provides some great tools for ignoring or setting custom comparison logic for fields. This can be really useful with ids and timestamp fields that may change. There is no support for structured comparison in `golden` yet, but that sounds like a good feature to add. 
https://play.golang.org/p/uB9JEk-OgA0
Or don't use `strconv` at all, and instead use `fmt.Scanf` ;)
Holy crap!! I never knew this existed!! I always end up writing something significantly shittier with buffered error channels and waiting for nil by all workers. This is awesome!
This would definitely make it better.
Sorry, it was silly of me to answer "no" to an "or" question :-S I meant, "no, you do not work inside the Go installation directory". 1. Until Go 1.11: yes. Starting with Go 1.11, Go has a new [concept of modules](https://github.com/golang/go/wiki/Modules) that allows working with packages and their dependencies outside GOPATH. 2. Yes, Homebrew treats Go like any other formula. The binaries are installed in /usr/local/go and the rest in Homebrew's Cellar. TIP: Type `go env` to see various settings, incuding the paths of GOROOT, GOCACHE, and GOTOOLDIR.
Awesome! It's fun to play with this little tool. Question: I tried `go get` and itree seems to work just fine, except for the final `cd` of the shell. Do you think the Go binary could do the shell integration itself (e.g. when passing a flag like `itree -init`), so that the project would become `go get`table?
&gt; 2015 I feel like I've already seen it a dozen times. This was a controversial blog post discussed everywhere numerous times.
https://golang.org/pkg/container/heap/ Make it so that the `heap.Interface` implementation sorts your tasks in the order that you want, then use `Push` to add tasks, and `Remove` to retrieve the next task. If you're using multiple goroutines remember that you'll want mutexes
As someone who has done code reviews for tens of thousands of lines of Go tests alone, I can say from experience that the simple `t.Errorf("whatever = %v, want %v", got, want)` pattern is a very easy pattern for lots of developers to use and read, and it provides the flexibility to be adapted to any situation with minimal changes without sacrificing clarity or familiarity. We have seen lots of attempts at libraries in the vein you describe, and to date none of them have come close. The fact that such libraries in C++ and Java still have these properties suggests to me that it's not something that can be over come in the general case.
Oh, thank you! I've missed it. I've seen the import for golang.org/x/image/webp so I thought it does the conversion. Why doesn't it do the conversion with golang.org/x/image/gif (and webp)? 
No. Periodical Flush ensures that at most one period's data can be lost - if you write erratically, you may have periods with no or few writes, and all those can be lost. (If you write regularly, then there's no difference).
Knowing myself to be a bit of a thickie is why I use Python and Go, and try to document my code clearly.
I suspect despite the changes in the various versions, at least in 1.11(changes and improvements to the toolchain, runtime, and libraries), the core of the language remains the same. I love the book's approach to the language, and I've actually recommended it to anyone who tries to learn the language. Thanks for your response. 
I liked [https://www.youtube.com/watch?v=zPd0Cxzsslk](https://www.youtube.com/watch?v=zPd0Cxzsslk)
Yes, it's definitely for learning purpose, I've shared this code only for those why want to learn something. It's cool to share your code.
I like to keep my development station minimal, so I dont want to install all `webp` related libs on the host machine, docker is handy in that case.
&gt; Only use them if you really really need that performance. Otherwise stick to the standard library. And if the performance is _actually_ faster for your application. In my limited testing fasthttp was neither fast nor http.
&gt; Only use them if you really really need that performance. And if the performance is actually faster for your application. In my limited testing fasthttp was neither fast nor http. 
I've been working on [Kommentaar](https://github.com/teamwork/kommentaar) for the last few months. It's not quite ready for a "1.0" release and there are a few knows bugs, but on the whole, it's working fairly well for us at the moment.
[removed]
Been tracking this for a while now since we moved to GitLab and sub multi levelled groups. This is the specific issue on Gitlab: [https://gitlab.com/gitlab-org/gitlab-ce/issues/45055/](https://gitlab.com/gitlab-org/gitlab-ce/issues/45055/)
&gt; inputBytes := make([]byte, 100) You only have a 100 byte arry, so only 100 bytes can be read at a time. You should increase the size. 
I saw this at Gophercon and I really really like it. I've fooled around with this layout a bit since then and it works really well for me I think. It's a bit verbose for small projects but it works super well for big things.
[removed]
[removed]
GNU `readline` is released under the LGPL license. this doesn't bode very well with Go's statically linked binaries. I myself use https://github.com/peterh/liner for things like that (it has support for history and completion.)
an example of an interactive (as in "plot being updated") plot: - https://github.com/sbinet/go-web-examples/tree/master/07-go-web-plot-gonum-svg I am working on-and-off on a d3.js backend for `gonum/plot`, so one could have an interactive (as in "hovering over the plot, modifying the plot") plot. still in the "discovering d3.js" phase :) 
ah, and I have also a `exp/shiny` backend for `gonum/plot`: - https://github.com/go-hep/exp/tree/master/vgshiny
I have already spoken to Kat after this talk, and pointed out to [https://github.com/golang-standards/project-layout](https://github.com/golang-standards/project-layout) \- which I think is a nice fill up to this talk.
I got bit by that too, when I found GO,a friend told me it was a bad language, so I never touched it, but my new boss put me in a go project, I am loving go since
Do you want to read a line and then separate them into numbers, or is it a given number of numbers that has to be input independent of lines? To read a line from stdin you can use `bufio.NewReader(os.Stdin).ReadString('\n')`. To split it on whitespace you can use `strings.Fields(line)`. You can then create an integer slice with the same number of elements as the one strings.Fields created and convert them one at a time.
&gt;They’re not capable of understanding a brilliant language but we want to use them to build good software. So, the language that we give them has to be easy for them to understand and easy to adopt. It really doesn't lol
I tried to use it for multiplayer. It mostly didn't work either. I ended up implementing something based on the [gafferongames reliable UDP](https://gafferongames.com/post/reliability_ordering_and_congestion_avoidance_over_udp/)
Idiomatic is making a gRPC API and if you need peasant HTTP you can use gRPC-Gateway
[removed]
Questions to ask about the design: What happens to the work of `svc.BackgroundJob` if the process exits before it's completed? What about before it's started? What should happen?
precisely
You can use a loop ya know...
and to add on from that - you'll have to read the whole packet in one go. can't read e.g. a header and then decide how much to read from the rest. load into buffer first, ask later. The max length for a udp packet is 65,507 bytes (65,535 − 8 byte UDP header − 20 byte IP header).
Hi chris, thanks for flagging this. Could you please send me an email? I’ll DM you my email.
I wrote this because I wanted some docs for bootstrapping devs with no Go experience in around half an hour. Most other guides (esp for other languages) focus on the language but don't tell you how to actually set up a project including unit tests, dependency management, documentation, etc. I want this to be useful for the target audience, so please feel free to suggest improvements or otherwise give feedback.
&gt; vendor Wait, ...who said `vendor` is on the way out? There's even a new command to create the vendor folder: `go mod vendor`.
read the spec https://golang.org/ref/spec Go isn't like JS, there is no need for such a book.
&gt; Why Go’s design is a disservice to **egotistical** programmers FTFOA (original author) Time to watch the long version of the final credits of the movie “Revolver” — they taught me a lot and I suspect they can teach original author a lot too.
💯
&gt; Vue is unopinionated as heck! You can just drop one Vue component in an existing project and it works just fine I don’t use vue.js but it’s immediately obvious that your sentence is internally inconsistent! To the extent the first half is true, the second half is untrue...
What kind of thing? People running out of date software in production? yes, that kind of thing will happen. If someone installs Gitea and never updates it, is that Go's fault?
People have been commenting there about how having to re-write their code base to support the newest PHP version will take around a year. Would that be a problem in Go? &amp;#x200B; I haven't run a Go program for more than 3 years yet, but so far I just had to recompile them with the new compilers to upgrade to newer versions. Is that the case for the majority of Go users?
No. First of all it is everyone's job to keep their software up to date. Second on your server you run a Go executable which has everything it needs linked in statically. Every time there is a new release of Go you have to recompile and replace it with the one on your server. PHP in contrast is an interpreter which you need on the server and you also have to update it there. Here you are also reliant on the hoster. I have no clue on how easy or difficult the jump to the next supported PHP version is. For Go, here comes the compatibility gurantee into play as Go 1.0 code still compiles today. Library code is an eternity different topic. My two cents on this is that at least a big part of Gopers know the dependency trap and write less dependent packages than seen in other languages.
&gt; The two red flags which I see is that it advocates a folder structure under cmd/XXX/* (would you import project/cmd/xxx/subfolder from main? I wouldn't) Each `cmd/XXX` *is* package main, so no, you wouldn't import from these. Further down it even says you can't import from `cmd/`.
I think either I or you are misunderstanding something. There is an example of a routes subfolder under cmd/XXX. I asumed these are imported from main only, but either way if it’s the case, I still have to see such an example in the wild and would advise against it.
I've seen it suggested that Go really appeals to beginners and experienced software engineers. It's the people in the middle who have the most trouble with it. It's anecdotal, but it does seem to me to fit the facts.
Why is your \[\]globalContainer a pointer? What dou you want to achieve with it? &amp;#x200B; I'm sure running with the race detector (-race) will find several issues - you don't synchronize access (read in http handler, write in poller). &amp;#x200B; Either use a sync.RWMutex and RLock/RUnlock in handler and Lock/Unlock in poller, or create a separate goroutine which will be the data owner of the global slice: receive updates thorugh a channel, and send current slice through another one. &amp;#x200B; (I prefer the solution with the Mutex - for this simple case it is simpler than the goroutine. But for more complex scenarios, the "select" on several channels is unavoidable).
The web browser is desktop and cross-platform. Why hammer a square peg into a round hole? What haven't you told us? (P.S. http://www.catb.org/esr/faqs/smart-questions.html)
Is there also any editor you would suggest for now? I'm continuously switching between Atom and GoLand ?! 
Thanks for the feedback! I will look into Mutex. Felt natural to use pointer when dealing with updating/changing the struct value. Should I skip the pointer? !
what about qt [https://github.com/therecipe/qt](https://github.com/therecipe/qt)
I really enjoy GoLand however if you are looking for a free alternative I would also suggest VS Code with the go plugin installed.
vscode's Go plugin is great, I have the exact same setup on Windows and Linux and it works great
Again, the post does cover that further down. `servid` has packages underneath it which can only be imported in that command and explicitly can't be imported elsewhere. Although perhaps the structure of the post does lead to these confusions, I do think the application / directory structure is sound.
&gt; I suppose by using struct tags to omit fields from being marshalled, but that's only if you *never* want the fields processed. I imagine you couple use reflection to dymically change which fields would be masked
Ehrm... 'pure go with the exception of necessary graphics library' == 'bindings to a C library' == cgo. Those are the same thing (well, unless you are comparing to bindings to a C++ library?). It is either pure Go, or it is using cgo. &amp;#x200B; There may be one or two projects out there that make do with just syscalls, or work with a display system that you can talk to over a network connection, like xgb... but by the same token, they are not going to be cross-platform (except in the sense that you could run an X-Server on Windows or MacOS - not what most people mean by cross-platform). &amp;#x200B; In general, your choices are: Use cgo and work with a library that exists on multiple platforms (qt being the example already provided by cuank, SDL being a lower-level example more in line with your 'necessary graphics library/OpenGL binding' reference), use cgo and some other library and drop the cross-platform requirement, use xgb/BurntSushi and drop the cross-platform requirement, or write only the server side in Go and just talk to the UI side.
You don't need a dependency injection framework to do dependency injection. The fact that Go often doesn't need dependency injection frameworks is more because of the cultural decision of the Go ecosystem to not write code in convoluted ways. To compare to Java, you could write your dependency injected class in JSR-330 style: public class MyClass { @Inject private Logger logger; … } Or you could write it in a more obvious way: public class MyClass { private Logger logger; public MyClass(Logger logger) { this.logger = logger; } … } In Go, that would be: type MyClass struct { logger *Logger } func NewMyClass(l *Logger) (*MyClass, error) { return &amp;MyClass{ logger: l } } … When your program creates its instance of `MyClass`, since it only takes one dependency, it's easy enough to write the "injector" manually: func CreateLogger() (*Logger, error) { … } func initMyClass() (*MyClass, error) { logger, err := CreateLogger() if err != nil { return nil, err } myClass, err := NewMyClass(logger) if err != nil { return nil, err } return myClass, nil } But if it took many more dependencies (some of which have their own dependencies), that could get a little nasty. So you can ask Wire to automatically write `initMyClass()` for you. You write: // +build wireinject package foo import "github.com/google/go-cloud/wire" func CreateLogger() (*Logger, error) { … } func initMyClass() (*MyClass, error) { wire.Build(CreateLogger, CreateSomeOtherDependency) return nil, nil } then run `wire`, and Wire writes a version of the file with a real version of `initMyClass()`: // Code generated by Wire. DO NOT EDIT. //go:generate wire //+build !wireinject package foo func CreateLogger() (*Logger, error) { … } func initMyClass() (*MyClass, error) { logger, err := CreateLogger() if err != nil { return nil, err } myClass, err := NewMyClass(logger) if err != nil { return nil, err } return myClass, nil } Wire doesn't do anything fancy or different. All it does is write your initialization ("injector") function where you pass the dependencies in to your objects. So use Wire when that function is getting complicated enough that you'd rather not write it yourself. It shouldn't write that code any differently than a human would. 
I don't think there is a consensus in the go community here. The attitude I see most often on this forum (and that I happen to agree with) is that the concept of DI is good, but that purvasive DI frameworks are bad. That shoving everything into a DI container that does a bunch of magic at runtime has many of the same downsides of global state, plus you loose a ton of compile time safety, and doesn't provide enough benefit over manual dependency injection to justify the downsides. In other words, we think Java went a little overboard with DI. To be clear, by "manual dependency injection", I simply mean explicity passing dependencies into your constructors. If your dependency tree gets complex enough to require it, you can combine this with the builder pattern to abstract away the complexities of object construction without resorting to runtime wiring. Wire is a pretty interesting approach in that is really just a code generator that aims to output more-or-less the same kind of manual, compile time safe, DI that I just described. That makes it worth checking out for my next big project, but for smaller projects it is still overkill. Even the blog post announcing Wire says as much. &gt; In Go, this often takes the form of passing dependencies to constructors... &gt;This technique works great at small scale, but larger applications can have a complex graph of dependencies... 
There are a million reasons as to why one might prefer a native app over a website.. also, that documentation is toxic af.. you'd think it was written by the miserable SO superusers who spend all their time downvoting and dismissing questions rather than contributing to the community..
I definitely do not like the idea of having to update more than one model if I add a field. Maybe they could share a base model that contains all fields shared by both?
&gt; Would that be a problem in Go? Sure, why not? Go’s compatibility guarantee is only for v1, AFAIK. Sure, v2 will strive to minimise breaking changes, but *at some point* something will likely get broken in the name of progress. `context.Context` seems a likely candidate. PHP is now on v7, so it’s no great surprise that there are some breaking changes. Go probably won’t be as badly affected, as it’s a much better designed language to start with. There’s a lot of stuff in PHP that should never have seen the light of day to begin with. 
&gt; There are a million I'll take one valid reason from OP. Thanks for following the Go Community Code of Conduct!
This is perfect, I know how to write go code but always had a hard time trying to organize my file structure. Thanks :)
Hmm, don't like to use MS tools :D But most of the people are saying that VS-Code is quite nice
In the article I recommended VS Code. Really easy to set up and I've had a good experience using it; can't go wrong with it. The only other editor I've really used is vim-go, which is mostly great but obviously requires vim experience and thus may not be suitable for everyone.
Just to clarify, they are not intended to be seen as two models, at least not the same kind of models :). Some of them are domain models (the ones in 'adding' and 'listing'), and the ones under 'storage' are just data representation "models" (you could probably call them DTOs in the traditional sense). They just happen to all be called beer.go. It's such a simple example that it may indeed feel like an overkill, but the point was to illustrate how you can decouple your domain representation from the external interfaces / DB representations etc. The goal being to be able to modify one without having to touch the other. The domain models define all properties of a beer as it is understood in the particular domain and context. The files under 'storage' define how beer is represented in a json file, or in the memory. One has the json struct tags, the other doesn't (cause it's only relevant to json), and the domain doesn't care about the json struct tags at all. Like I said, this is a simple example where they mostly happen to be the same, but in the real life you could have properties in the domain model which do not map to the storage representation and vice versa. A random example off the top of my head would be something like - the beer in the domain could provide a method called "isAvailable" which returns a boolean based on the number in stock. The number in stock would likely also be a property of the storage representation of the beer, but "isAvailable" wouldn't! One key distinction between domain models and pure DTOs is that domain models can also contain logic (as in, provide methods / functionality). Mine just happen to both define properties right now, but I plan on tweaking this a bit to add some more logic to the models while the storage representations stay the same. I think this post from Martin Fowler explains this difference really well (https://www.martinfowler.com/bliki/AnemicDomainModel.html), but I only came across it after Gophercon so maybe this could be a good addition to this talk in the future. Thanks for raising it! And yes - this does require conversions from one to the other. But I feel that the benefits you gain by decoupling the domain logic from implementation details really outweigh having to do the translation, especially in much larger projects. Similar with the interfaces - you could argue that defining the required functionality as interfaces in the domain and then having one implementation of it might feel like a waste of an interface. But it helps with testing (mocking), and makes the implementation completely decoupled from the logic which will help you later on when you want to make changes to either the domain or the implementation (it will minimise the affected areas). Wowza, this has turned into a long post - sorry! Hope it helps a bit :)
While I'm not OP, I would love to build native applications in Go as well. In my case I'd like to build a native desktop client for the many messaging services, as well as an editor that used (Xi)[https://github.com/xi-editor/xi-editor] (it would be great if Linux finally had a text editor that could handle multi GB files)..
I think vgo didn't support it at the start. It's still useful with older version of Go. https://groups.google.com/forum/#!topic/golang-dev/FTMScX1fsYk
And on top of this, I put together a project to hopefully make it easier getting started. I really like devving guis in go with Qt. I use this as my basis for every new one now. Feel free to ask questions https://github.com/amlwwalker/got-qt
I recommend VS Code too. If it might help convince you, Code is actually developed by the open source community, Microsoft only hosts it. 
Well, MS is the main developer too. But it is completely open source.
Thanks for the response! I definitely understand the example was super simplistic. I suppose having multiple representations (and the need to update them when shared properties are added/removed) of the same entity is the trade-off for the ability to decouple. In your experience, have you seen the representations of entities diverge from the domain models much? In projects I've worked on thus far, everything has been a 1:1 mapping of the domain model. Though, adding behaviors onto the models without those behaviors being present on other representations is a somewhat attractive feature of the architecture pattern. But, again, it seems like a trade-off with how willing one is to maintain these different sets of representations. In your opinion, how would you handle conversion from one to another? Have a NewWidget() function in each implementation package take a domain object as an argument and spit out its respective (DB, API, etc) counterpart?
Scratch...
You did a wonderful job. I am one such Dev, and this was a perfect introduction to me.
Exactly. This seems very obvious, and yet there are still [blog posts](https://blog.drewolson.org/dependency-injection-in-go) that say things like this about manual DI. &gt; The main downside is that it’s a pain to have to manually create the Config before we can create the Server. We’ve created a dependency graph here – we must create our Config first because of Server depends on it. In real applications these dependency graphs can become very large and this leads to complicated logic for building all of the components your application needs to do its job. and this about their obfuscated IoC container infested alternative &gt; Even though this example is small, it should be easy to see some of the benefits of this approach over our “standard” main. These benefits become even more obvious as our application grows larger.
Just be careful though, because the binaries they ship are proprietary. You can always build from source, and there are open source builds for it.
http://www.catb.org/esr/faqs/smart-questions.html#before
\&gt; whether to use dependency injection (specifically a framework like Wire) for most enterprise Go apps &amp;#x200B; Well, since Wire is brand-new, and there aren't a lot of competitors, I'd say most apps haven't needed it. 
I like to define my APIs with gRPC/protobuf, use gRPC Gateway to expose the API over REST/JSON, and generate the API docs with protoc-gen-swagger.
Never say never. Some people won't ever upgrade their software stack until they are absolutely forced to. Those people wont magically change because if they start using go. That said, go's commitment to backwards compatiblity makes upgrading to the latest version way easier than PHP. In PHP world, many people would like to upgrade, but cannot spare the resources required to do so. This isn't nearly as much of a problem with Go as it is much easier to upgrade and much less likely to introduce bugs.
By using the VS code binaries, you are giving Microsoft permission to do pretty much whatever they want on your system. It's not a friendly open source license.
&gt; It’s overly verbose, inexpressive and a disservice to intelligent programmers everywhere. The sharpest programmers I know play with languages like Haskell and Erlang at home but would rather use Go/C#/Java at work.
[removed]
There are some subtleties to do with const strings and numbers. Also some subtleties with memory access for parallel processing, like accessing same CPU cache memory thus making goroutines less efficient) stuff like that 
Unless you have seen malicious behavior that none of the rest of us have seen, that's just fear mongering. The VS Code binaries are perfectly fine. Microsoft has far more to lose than they have to gain by doing anything like you're imagining.
Then enlighten us on how to make a web gui app in Go. OP is asking for Go options afaik
Go + SWIG + GTK+/Qt
What exactly do you think they wouldn't want to make public? The insane amounts telemetry throughout their products is not really hidden. I'm not saying it is any worse that their other products, but rather right in line. Their cheering about open source, but as soon as it would matter they pull it away.
&gt; What exactly do you think they wouldn't want to make public? That's exactly the kind of fear mongering that I'm talking about. I recommend actually [reading up on things.](https://github.com/Microsoft/vscode/issues/60#issuecomment-161792005) &gt; Here's how it works. When you build from the vscode repository, you can configure the resulting tool by customizing the product.json file. This file controls things like the Gallery endpoints, “Send-a-Smile” endpoints, telemetry endpoints, logos, names, and more. &gt; &gt; When we build Visual Studio Code, we do exactly this. We clone the vscode repository, we lay down a customized product.json that has Microsoft specific functionality (telemetry, gallery, logo, etc.), and then produce a build that we release under our license.
Absolutely. Thing is they don't **want** the option of using Haskell or Erlang at work. They know not every developer in their team is an expert and Go requires less skill to produce readable code with relatively low cognitive load.
So you're saying they work in a go/Java/C# office and actually prefer to use a language their colleges will understand? Would have never guessed that
Much more detail, as linked in the post https://blog.mgechev.com/2018/05/28/revive-golang-golint-linter/
Thanks for the explanation.
I’ll try and write some tests tomorrow for this. I was looking for a Go project for Hacktoberfest. 
I'm using GolangCI-Lint currently. So I'm wondering if there is any chance of integration and what unique checks Revive does.
This has already been done. Read it again.
This issue has less do with PHP the language, and much more to do with PHP the runtime/interpreter/tools. Because the most common implementation of PHP requires a runtime component to be installed (eg: it's not a static-binary like Go), it mean's a lot of people running PHP apps like wordpress are hamstrung by their hosting providers not updating their PHP version.
One person's useful abstractions are another person's spaghetti code. Not every abstraction is worth the cost of maintaining it. Many are (see: collections and common algorithms) but many aren't. Just because you can abstract over something doesn't necessarily mean it's the correct approach. Often times a simpler approach that's slightly less abstract is better, even if it means more code. Remember, code is often written once, but read many more times, often not by the original author of the code. This means for every abstraction you introduce, others will need to learn it.
&gt; a web gui app No idea what you're talking about, but you are using a web app with a graphical interface TO POST ON REDDIT YOU MUPPET.
it wraps GML so i doubt it. i do not miss go meta linter at all, so damn slow.
Should Revive be used alongside with go vet or it covers vet's functionality?
https://github.com/fyne-io/fyne
Whats the intended use case?
&gt; There are also command line tools that come with your Go installation, godoc and go doc (confusingly named)–check out the help for those. I would remove `godoc` from that. godoc CLI support will go away in 1.12. One should just use `go doc`.
What's the advantage over [`reflect.DeepEqual`](https://godoc.org/reflect#DeepEqual)?
&gt; GOROOT is nowhere to be found You can set it yourself. But IMHO the better option is to work with the default location, unless you want to maintain the GOROOT env var in the rc files of every shell and every user account you ever want to use. &gt; the damn thing says 1.3.3! Looks like something is still mixed up. * Start with getting the output of `which -a go`, or `type -a go`, resp. See if there is more than one of them, and what their paths are. * Check `echo $PATH`. If the test above returned two go binaries, change the sequence of the two paths, or remove the wrong one from `$PATH`. * Run `go env` and inspect the paths set there. (In other words, see what Go thinks of its own identity.) HTH
I have to admit I double checked the sub after reading reply of such level. Congrats
It depends. Usually if you pass a pointer, that means the receiver can modify your data (struct). So passing by value is safer. But for large structs, passing a pointer may help performance (less to copy, but here's an extra dereference step for each field access). For your case, if you have a global config struct, that should not be a pointer. If you implemenet the data keeper in a separate goroutine, that may apply a hybrid solution: have a copy of the actual config struct and pass a pointer to that, not to the "golden" instance. 
I usually encourage reading documentation rather than just spoon-feeding but here ya go https://play.golang.org/p/YqNtUM9uuAY
You can set variables globally in Linux (/etc/profile).
That's a really neat little bootstrap! But it's not very mobile friendly 😔
What does `which go` show? Also, you can delete files in Linux while they're in use and things will carry on using them even though they're not really there. Have a look at `ps aux | grep -i go` and if there are any end them with `kill -s SIGQUIT &lt;process_id&gt;` Then set your GO_ROOT and try `which go` again.
Thought the same until I looked at the tests.
`GOROOT` doesn't need to be set anymore. `which go` as others have pointed out. Also `go env`.
Do you know you're not obligated to install go itself on your Raspberry Pi? Go suports cross build For instance, if on your **Windows** machine you execute: `GOOS=linux GOARCH=arm GOARM=7 go build [...]` (replace `[...]` with the rest of your build commnand) It will produce a binary you can execute natively on your Raspberry Pi 3 (and 2) (Please note that for olders Raspberry Pis or the Zero version, you'd have to use `GOARM=6`) 
Another thing: MTU
Could you please use \`dlv\` cli analog instead of \`delve\` in "Debugging (via [delve](https://github.com/derekparker/delve))" similar as you mentioned \`go test\`/\`go tool cover\`. Also I would like to see examples, not only list. For instance: `dlv debug main.go`
But noone wants SSL certificates /s OT: This is partly why people keep yelling SSL despite TLS being the real method for the last 20 years. One needs to start using TLS instead of SSL
Write normal comments like anybody does.
If this is an exercise or just toying around: Why would someone find this helpful. If this is intended serious: Why on earth would anybody under any any circumstance consider 2345 to be equal to 5432? If your integers live in some strange ℤ_n you should state this. If equality is based on the set of digits to represent these numbers: Why did you choose base 10 instead the more natural base 73?
I think `vgo` is important for everyone getting started with go in 2018. It's also simple.
Vs-codium is a thing you can download the binarys yourself without any branding or telemetry.
Put all your .go files to the root of the repo. That's not a general advice, but in your case the separate units seem to be not really useful on their own. A package can have multiple files, you don't need any imports and any subdirectories for that. The visibility of things laid across files in the same directory is the same as visibility of things within a single .go file.
What about the recommendation about the `pkg` subfolder from the `golang-standards` repo? I can see that that project has only 4 contributors, and the main contributor in that package has not a lot of activity on github. Should I ignore that repo?
Seems like a great read, but please do expand on the test section with an example please. Most the other sections have examples to illustrate the points!
Since this seems to be my best option, I might be using this. I know it is far fetched but I thought there might be a cross platform (by this, I mean when I compile for Mac it will use x. When I compile for windows, win32 etc) solution that doesn't bind to a c library other than for something like win32 and graphics. Qt wasn't what I was looking for but will definitely consider it. Thanks!
in main.go: you could infinite loop with just &gt; for { //your code } since you're not using the running variable elsewhere :)
Thank you for this! If I end up using Qt, I will look into this!
Yes, there's even an issue open on that repo regarding that: https://github.com/golang-standards/project-layout/issues/10 Also that repo is not official.
Funnily enough, from my code history, I can tell that my past self was an arrogant, over confident, busy, stressed out idiot. Must just be my current self that's always right... 
This looks great! It is cross platform and it only uses cgo to access graphics. I will definitely keep a watch on this. Do you think it is production ready?
As I said, I am looking for something pure go other than the graphics bindings. Thank you!
Haha, this isn't a bad suggestion, well not completely bad. It isn't preferred but it isn't that bad. I asked for a desktop GUI but thank you for the suggestion!
Haha, sadly this is so true.
I don't get this?
Easiest way: sudo snap install go --classic
A good web GUI library is GoWUT. A good web desktop GUI library is astielectron although I don't like it. If I am going to use a web desktop GUI, I would just make it in node using the actual electron and communicate with gRPC.
Same question, but about [gometalinter](https://github.com/alecthomas/gometalinter)
You could say that about literally every language tho
[removed]
Interesting. So you're saying my anecdotal experience doesn't comprehend all languages? 🤔
I don't think so. What I'm saying is if you went to a PHP office they wouldn't want to use other languages cause that's what their colleges understand. If you went to a clojure office they wouldn't want to use other languages cause clojure is what their colleges understand. It's nonsense to say Go is good cause smart people prefer to use it at work because their colleges understand it, cause you could say that about any language.
from main.go &gt; // TODO: for some reason this seems to only work on :443 The reason for this is because the default port for https protocol is 443, while for http it's 80. see section 2.3 of [https://tools.ietf.org/html/rfc2818](https://tools.ietf.org/html/rfc2818). Note that this is not a hard requirement, you can run your TLS-enabled server on any port, and any client that knows this can connect to this port, however almost all browsers and cli tools will use port 443.
I may just go this route if I can't figure it out.
Could you elaborate 
IIRC correctly you have to pay for a license for that repo if you want to use it commercially. 
That touches what I'm trying to say. Go clearly isn't as sophisticated as Erlang or Haskell. It is a worst language by most metrics (at least in my book). Yet these smart devs would rather use Go at work because Go excels in stuff that matters when working in teams.
Are these smart devs the one's that hire everyone? Cause if they aren't they're probably using go cause that's what everyone else knows
We need a meta linter to wrap the meta linters.
\`reflect.DeepEqual\` does something completely different. What this package does is something like shallow equal. The use for it is when you have a non-deterministic source that generates data/processes and you don't want to commit resources if a certain collection of that data has already been generated. &amp;#x200B; The original use case for me had to do with \[\]string and, maybe, maps. I extended functionality to the rest of the types just so it felt more complete. The comparison doesn't really make direct sense for integers, unless you're talking combinatorics.
Will you give a specific example. I don't really know of a good comment writing convention, so I was just writing stuff to help me remember what I did and to add a little explanation if someone else tried to read the code. 
From the linked doc: "Revive implements all the rules which golint has and the failures have the same concept of “confidence” that golint introduced. In fact, invoking revive with no flags has the same behavior as golint, with the difference that it runs faster." There is a list of the current rules here: https://github.com/mgechev/revive#available-rules On a quick check, of the first three rules in go-vet, it had one of the three. So I don't think it is currently a full replacement for go-vet, only golint, but it sounds like it has ambitions to be.
Ah yes. So this is more like Python's `Counter`. In that case I think it might need be more useful to return a `map` for a slice, instead of returning a `bool` for two slices.
That can be easily done, since it maps the elements to maps before forming a book opinion. I could easily make it an option to output those as well!
Not exactly, IIRC 😂, my memory tells me that if u dynamically link to Qt you are fine. If you compile. Statically then u need a commercial license. Point: I always open source my guis, and re read the license... 
Thank you! This is exactly what I needed. There isn’t really bother guide quite like this. 
There is github.com/andlabs/ui which will make binaries that don't have any dependencies beyond what the system ships with (I've used it for Windows and Linux for a settings gui) but it isn't the most fully featured and has issues with 32 bit flavours of windows
This is part 1 of a two part series, based on my "Evil Go" talk at CapitalGo 2018. Please let me know what you think!
Yeah, I built the website myself, but I'm not much of a UI dev. It'll get there, but it might take a while. :(
I'm trying to keep the main sections to things that are absolutely critical to software development. The extras (such as profiler, debugger, and code coverage tools) are referenced so as to point the user in the right direction in case they want to go beyond the basics.
So happy to hear that it helped!
I'm the tech lead and primary software engineer on the Go runtime. If you have any questions, please don't hesitate to ask! &amp;#x200B; I'm super thrilled to announce that Go 1.11 is now available on App Engine! We now support... * vendoring * regular best-practice package structures * go modules * the regular [Google Cloud client libraries](https://github.com/GoogleCloudPlatform/google-cloud-go) This is a "[second-generation](https://cloud.google.com/blog/products/gcp/introducing-app-engine-second-generation-runtimes-and-python-3-7)" runtime, meaning that we're now running stock Go in the [gVisor](https://github.com/google/gvisor) sandbox. We've removed all of the restrictions present in the old runtime, like limited socket and file access. You can even import "unsafe"! If you're a current Go-on-App Engine customer, you should check out our [migration guide](https://cloud.google.com/appengine/docs/standard/go111/go-differences) to learn how to migrate from the Go 1.9 runtime to the new Go 1.11 runtime. For the time being, you can still use the legacy App Engine APIs with the Go 1.11 runtime, but you should start migrating to the [Google Cloud client libraries](https://github.com/GoogleCloudPlatform/google-cloud-go).
Cool lib, but I'd call it `quote` rather than `q`, as the latter sounds more like a variable.
Is there an estimate on how long the beta period for Go 1.11 on GAE Standard Environment will be?
I noticed the master branch has a main function, it's common to put the main function under a `cmd` directory, inside another directory named what you want the command to be called. So something like `./cmd/pgstats/main.go` This allows users to install it with `go get` like so: `go get -u github.com/exhuma/gopgstats/cmd/pgstats` That command will download the source to `$GOPATH/src` as well as compile and place a binary named `pgstats` (taken from the last directory name) into `$GOPATH/bin`, which you should add to your `$PATH` so you can easily install go tools.
At least a month, possibly longer. Since this is our first second-gen runtime release for Go, it's hard to provide a good estimate.
&gt; I asked for a desktop GUI You didn't ask a very good question. Which is why I added the postscript. If you can ask your question in a way we understand what you actually need...
I actually noticed that on last Friday and [migrated my Go-on-AppEngine app to go1.11](https://github.com/fishy/notifbot/tree/master/appengine) over the weekend (and [migrated another app from Heroku to AppEngine](https://github.com/fishy/blynk-proxy), because the limitation before it cannot run on first gen go runtime). During the migration one thing I do miss is memcache. Yes I can use redis cloud now, but that's another account I need to maintain (and they only support SMS 2FA, which is bad).
This is a multifaceted problem. In short, no, go programs will never have this kind of problem because: - it is not an interpreted language, so once your program is compiled it does not care about which version of go is on the machine at all; - it treats backwards compat as a first class citizen. Your Go 1.x code might not compile with Go 2.0 but I suspect you'll have both versions available and supported during the transition and the transition will be easier because, again, it is a compiled language, so the most basic level of testing (i.e. is this code wired correctly) is there by default. In the current PHP world you have 100K+ SLOC codebases running production services sometimes without even one unit test. I have coordinated a PHP 5.1 -&gt; 5.4, and then a 5.4 -&gt; 5.6 migration. It's not a fun process. This is one of the things that made me want to leave PHP and never touch it again.
Hi, App Engine PM here. We are working with the Cloud Memorystore team to have a better memcache story for the App Engine second generation runtimes.
This would work but I said I didn't want c bindings to a library other than that of graphics. That library has bindings to libui which isn't Go.
Alright, that is unfortunate. It looks really nice. Pure Go other than that of EFL and it is Cross Platform!
Ok, thank you.
Is it possible to make a grpc service on the second generation runtime?
You can, but there's a big caveat: incoming GRPC requests to App Engine won't work. App Engine only supports HTTP inbound.
Thank you, I'm glad you liked it! The final cd requires you to use the install script. This is because you cannot change directories of your shell from the binary. The install script actually creates an alias for itree to do \`cd $(itree)\`. Hmm, do you mean have the install be part of the binary itself (rather than a shell script) by specifying an --init flag? That could work but would involve me re-writing the install script in go. Another solution would be to provide a single command line way to call go-get and curl the install script and execute it. Would that be convienient for you? &amp;#x200B;
It builds libui (actually libui was built to support ui and then became it's own thing as I understand it) into the app, and you're going to need a c binding at some point for any of the desktop ui's, so is the issue it calls into c code or using cgo? I don't understand why you're okay binding to opengl (which definitely requires c bindings and dependencies that many os's don't have by default) but not with a library that requires no dependencies beyond what every gui desktop already has. So maybe if I understand that logic I can help you further?
Noob question: How can a server be ready for Go 1.11? Or any version of Go? You just upload an already compiled binary and then execute it. Isn’t that one of the advantages of Go? So what am I not getting here? You want to do the compilation on the Server?
Reading other people’s code is a skill in itself. I’d say one that comes with experience. Of course it can depends on the quality of the code you’re reading but I recommend keep at it, start small and don’t stress yourself out 
Is there a way to scan the go language for security and code flaws (a la Fortify)?
I've wanted to use Golang on appengine earlier. However, I want to use the flexenv as I do not want to be locked to google cloud. When I last tried about an year back, the appengine app deployments for flexenv took anywhere from 20 mins to even half an hour for update (when we do a `gcloud app deploy` with newer sources) to be available worldwide. I filed an issue with google support and it was closed as an already known issue. How much time will appengine take now for updates ? Especially for the flexenv environment of Golang.
But gRPC requests are http2? Or do you mean AppEngine only supports http 1.1 inbound?
Flex is unchanged, so the deployments on App Engine Flex will still take a long time. Deployments on the Go 1.11 runtime for App Engine Standard should only take a minute or two!
That's right, App Engine currently does not support HTTP2. But... we're working on it :)
Thanks for the reply. Ah, this hurts. I will continue to stay out of GCP primarily because of this. I wanted to migrate some of my projects from heroku to AppEngine but can't :(
The expected scale and uptime requirement will determine the design for a project like this. Let's assume that you are dealing with a low load and low uptime. If you are sure that the maximum number of pdfs in flight is less than ram, have the pdf generator write to stdout, read it into ram, and serve it directly to the client from ram via io.Copy. Other solutions where you hold it on disk open up problems of when to clean up the temp file. Simply running rm in cron is easy, but also easy to for operator error to screw up. For extreme scale or uptime requirements, you would probably write the pdf into cloud storage, then serve a redirect to the cloud url. That way the thing that produces the pdfs can be scaled up, and the complexity of storing, serving and cleaning up the files falls into the cloud provider. 
We use two different approaches to achieve this goal highly depending on the amount of budget you have for a project: 1. Use PrinceXML, https://www.princexml.com. This is a standalone utility that internally implements sort of a custom browser-engine specifically to print pdfs. It is somewhat expensive, but in my opinion it is well worth the cost. It also implements features like hyphenation, svg integration and a javascript runtime (which allows you to use something like react or vue and charting libraries like d3). You can very easily style your documents with css, using flex-grid and even create raster images to display previews on the web. There are different methods to start the pdf generator, but we usually pass the html and css content via a stdin pipeline to the princexml process and directly read the pdf from stdout. 2. Use something lke gofpdf, https://github.com/jung-kurt/gofpdf. This is much more low level and it takes way more time to define the pdf view that you want to print. There is no hyphenation support, creating tables is quite a hassle and font management is somewhat complicated. But you can call it directly in your go programm and its free. 
Another reason for this is a main function is only allowed in `package main`, so users wont be able to import your package (or they will, just it’ll be called main, not such a great name 🤗). So this is a good separation of “here’s a package you can import in your code,” and “here’s a command you can install and run” :)
Is there a reason why you don’t allow that? Just curious 
Do you mean at deploy time? We compile and run whatever code you give us, so any security scanning can be done on your development machine.
No, more like static code analysis.
With the Go 1.11 runtime, we have removed all vendor lock-in from the product. The same code you can deploy on Heroku can be deployed on the Go 1.11 runtime on App Engine Standard. Give it a try :)
Glad you wrote this. Too often, many modern programming languages work in the unrealistic realm of a single file program, but then don't bother to mention how you should set up a realistic environment for development. For example, I was looking at Elixir last year, and then wanted to work with a second file. I couldn't find a good answer how to do it (turns out going from one source file to two source files is a huge step in many new languages). I was more used to a C style where you just include the file. I think I found a way to do it, but it was non-standard. Books often go through syntax and don't really address setting things up early on. Plus Go has made this a moving target, so if you read something, it's probably out of date. Anyhow, thanks!
(App Engine PM here) On App Engine, you deploy your app sources, not the built binary. To do so, you run one single command: \`gcloud app deploy\` in your source folder and they are uploaded, then built in the cloud with Cloud Build, then deployed to App Engine. If you are interested in providing your own binary and container image, I invite you to try [http://g.co/serverlesscontainers](http://g.co/serverlesscontainers)
(App Engine PM here) I recommend you try deploying to Go 1.11 on App Engine standard, as @sbuss said, deployments usually happen in \~1min, and you should just be able to move your existing code to it.
I was referring to the formatting: // This is a comment but //This is just giberish. 
Thanks for the info. I've since removed the main function and am using unit-tests now. Even though they are still rudimentary because I have not yet figured out how to mock my DB queries.
Please do not feel urged to change the install script. I am actually fine with calling a script. I only thought it would be nice to have all this go-gettable. Yes, the idea was to have the binary take care of installing the shell wrapper. Nothing fancy, even just calling the install script from the binary would do the trick. (And I don't think you need to curl the script as `go get` will fetch the script along with the go files.)
&gt; I'm sure the answer is, keep going, and at some point you'll have enough knowledge that problems get easier and easier, and you'll start to feel confident in your ability. Well... I mean, that is true, but I understand your frustration. Reading code for me was a skill that didn't come in for _years_ after I was already a reasonably accomplished programmer. Dunno why, really. I could always read at the microlevel, like, what does this line actually do, but reading at the macro level took a lot longer. Like, 6-7 years longer, at least. But I still do have some concrete suggestions. If you have a non-trivial library that you're using, maybe even tried to look at and read some of, use the debugger to walk through your use of it and look at literally everything the library does. It's easier to understand the code when it's actually "moving" and not just sitting there static on the page. Do not be afraid to budget yourself some hours to spend doing this; it will come back to you a dozen times over. It can also help to try to draw a diagram of the library for yourself. The act of trying to work that out can be a good exercise even if the nominal end product isn't useful. Finally, there is an old quote: "Show me your flowcharts [code], and conceal your tables [schema], and I shall continue to be mystified; show me your tables [schema] and I won't usually need your flowcharts [code]: they'll be obvious." - Fred Brooks, The Mythical Man Month. You can tell how old it is by what words it uses and the fact someone had to annotate some of the words. It's easier to understand code by staring at the data structures than the code. If the data structures are well-designed, it'll often be _obvious_ what some bit of code must be doing. Even in the standard library godoc, I relatively often penetrate the documentation to read the private members of the data type to see what the standard library is doing; I often don't actually need to read the code to understand what the code must be doing!
&gt; they are imported using the directory path This is where my thinking error lies. I thought you were importing `.go` files. Not directories containing `.go` files. Understanding that you're mostly working with directories was quite eye-opening.
Yes, if you are the only user on the system this is indeed an option. I still prefer using defaults where I can.
Why would anyone use Go 1.11 on the App Engine instead of any other service that is available online? Honest question. I don't know the pros and cons, and the webpage does not seem to address this.
Will you add support for QUIC as well?
I did not know that libui was made for UI. I do realise that I have to use c at some point because their isn't a Go OS, although that would be cool. I would prefer syscalls or cgo. I just want a desktop GUI toolkit that is close to pure Go.
Do you really need to mock the db?
Why should I pick App Engine over e.g. Heroku?
The name of the package doesn't have to match the path used to import it. You could cause chaos if you named trip packages with the paths of each other.
I submitted a change to toggle this as an option.
Any idea when Cloud SQL for Postgres might be supported?
(App Engine PM here) I used both in my career and I think both are great application platforms. The specificity of App Engine standard environment is that it scales up fast and down to zero. In particular, when your app does not receive any request, the number of instances goes down to 0, which mean you only pay when it is used. Another benefit is that App Engine is part of Google Cloud, which provide you many other products and services to build your application (Cloud Storage, ML...)
Totally not app engine related but kernel 4.19.rc6 is going to expand a pretty benign socket stuct should I start working on a pr on x/unix now or wait till it's in the mainline kernel.
(App Engine PM here) If you are a new user, just now that now Go on App Engine behaves like you would expect :) Before that, we were not supporting vendor directories, we required you to use the Go App Engine package, and you could not use all Go packages, especially not all the Google Cloud packages.
All the code you write will be in Go, the c code will be used by the UI wrapper to talk to the OS, via cgo. So all your code will be pure go. 