Alternatively to /u/koffiezet's suggestion, you can also go with google's protocol boffers, and grpc, the RPC end points it can generate for you. Both will generate to c and go, making interop easy. As for using go, we started down a similar journey to you about 8 months ago. We made a decision to not use any framework like go-kit, gorillia, etc. and it has not hurt us at all. We've got close to 20 services and things are humming along. We do use packages for working with amqp, postgresql, mysql, and redis.
Yes, but that's not a problem necessarily. Said function can always route things around if it needs to, and in general, handling errors and successes occurs in the "same place" anyhow.
That's sound advice, but it should have generated a lot of work in terms of logging, service discovery and monitoring. How did you guys handle that?
The current app is in PHP so I'd want to push some stuff to the services whilst we transition out of it, but I am indeed wanting to make it language agnostic to some extent, e.g. being able to send queued jobs from python/scala etc, if necessary. Thrift does look cool and will certainly be considered as an option. Need to get my head around it first, though. :)
cron
As far as I understood, thrift has the advantage of having a service description file, like what WSDL's are for SOAP - but in a more sane format with far less overhead. That said, if you only need to consume the API from Python/PHP/Go, REST would do just fine, and I would still choose a "no framework" approach. I made the mistake a few years ago of choosing a certain framework for some service we use internally, and now it's abandoned. It's the downside of Go being very young: there are no established major libraries, except the stdlib and a handful others.
My only proposal would be: get a bigger room! Last year, I just couldn't get in.
It's difficult to give a small example. One situation might be a large business app that has dozens of DAOs, BOs, and Services, each depending on a few of each of the others. This is a familiar mess in Java land, and one that might be organized with Guice. This library is in the same domain as Guice or Dagger.
&gt; I don't think that's going to happen anytime soon. I don't think that's ever going to happen tbh. These tools are written by front-end devs to solve their own problems, and Node finally offers them a way of writing these tools in the language they also use for all their other stuff. I'm not exactly a Javascript/Node fan, but I can see Node's use in this case.
It's *really* good. Even better if you can make it to the party the night before conference starts.
We sadly don't get to pick the room ourselves :(
Yeah, AWS at the moment, but using Elastic Beanstalk. Thanks for all info. It is much appreciated. I will investigate further!
Hey, I am an engineer on the Hailo platform team. Let me know if you have any questions about H2 or how the rest of our platform works.
Hey, awesome. :) Question - how does H2 differ from other two "dominant" solutions - go-kit and kite? I see that not all of it is yet open-sourced, but I'm looking forward to that.
Although the framework used is different, I believe Nathan Leclaire went to the kernel of the this problem [here](http://nathanleclaire.com/blog/2013/11/30/fear-and-loathing-with-golang-and-angular-js/). Totally worth reading. From his own words: "I shouldn’t be trying to parse a form at all! Cue facepalm, and guilt of hours spent solving this issue (at least I’ll know better next time). My request payload wasn’t encoded as a form, it was encoded as JSON. If I just took out the call to request.ParseForm, I probably would have usable data in request.Body that I could Demarshal. Indeed, this proved to be the case."
Thanks for this input. I was aiming to first have a stab at protobuf indeed. However, it is also interesting that I might have a steaming pile of shit to try with later on. :)
All comments are correct. Because it wasn't mentioned in them, here is one additional point about *why* these are best practices (as far as I know): Channels have a lot of semantic subtleties that are not exposed in their type. A good example of how this is expressed is the [os/signal](http://golang.org/pkg/os/signal) package. Passing a channel is not enough, you must also specify how much of a synchronization point it is. What happens if there is no buffer space anymore (or if it's an unbuffered channels that isn't read at the moment), will the sending goroutine block or will it drop values? If it blocks, what happens to pontientally in-flight requests? Are buffered channels okay and if so, how does this interact with cancellation? A synchronous API allows you to step all these things (and potential edge-cases) and express them in a safe and clear manner. i.e. if you offer me an API with `Next() bool, Value() Val, Error() error` (an iterator pattern like [bufio.Scanner](http://golang.org/pkg/bufio#Scanner)) I don't have to care how you implemented it, if you buffer or what you do in regards to in-flight requests on cancellation and you are free to change these details later. I don't have to read your tons of documentations about what kinds of channels are okay to pass and troubleshoot weird issues if I accidentally pass the wrong ones. Concurrency is a first-class part of the language in go, because it allows to hide all the concurrency as an implementation detail and let the caller figure out, if they need to call your blocking API concurrently (wrapping a blocking API into a non-blocking channel-type API is a very simple piece of code) or if it's good enough to just do it serially.
This confused me more than before. I was able to hardcode some random JSON object, post it and see the data on the server side. However, when I use form data, it doesn't work. 
Nevermind, got it working. I had my struct all fucked up (the lowercase variable names for the struct messed it up)
Hey, the main difference is that our services communicate over RabbitMQ instead of talking directly over HTTP. This allows for interesting routing patterns, such as routing to specific versions of a given service, or point to point messaging. For more information check out our blog post on [H2](https://sudo.hailoapp.com/services/2015/10/16/h2/)
Yea, I suppose I left that unclear. I achieve Dependency Injection through interfaces. So `loadConfig` wouldn't change unless things were added. It would accept necessary interfaces and assign them appropriately. Something akin to: func loadConfig(config *Config, reader Reader, writer Writer, stringer Stringer) { config.Reader = reader config.Writer = writer config.StringRepresentation = stringer.String() } (Bear in mind this is a simple case, but this is where my disconnect is happening because, as I understand it, this is essentially what go-modules is doing.) At this point it's much more clear what my intention is by using these interfaces and I'm giving a clear message not just to developers but to the compiler of what I expect to be passed in these areas. So my real question at that point is what does this do that I cannot already do (in relatively few lines of code)? **addendum** This also adds in compile time type checking instead of runtime so you can prevent a whole slew of potential failure points earlier. **edit** Added in some code to further demonstrate `loadConfig` **edit** Added addendum **edit** Another example is your from the godoc page, so I modified it to use interfaces (which you already where) and was able to reduce LOC by 10. I'm not one to care much about LOC but I'm using here to represent less work with interfaces than with this service. This is where my confusion is stemming from. I'm not trying to be harsh or anything, I just really want to understand what benefit you're providing. https://play.golang.org/p/LY9KwdRIcc
Just FYI, there is already a well established and well liked java database called H2 that has been out for some time. 
Perhaps wise to expand the readme, it is very very brief. I don't suppose the average joe knows what Statsd is, I don't at least, what is it? Nice to see the benchmark performing so well, good work!
Do you have any consumer contract tests in place? How do you ensure you don't break consumers when a provider service is updated? 
We use protocol buffers to communicate between services which allows us change services while keeping the API compatible (for the most part). However it is still possible to make breaking changes, in this case the only solution is to update the consumers, these issues tend to be picked up using our tracing tooling or simply by spinning up a dev environment and testing the new services there. This is relatively easy due to the fact that much of this process is automated.
Have you compared this to https://github.com/bitly/statsdaemon? I would be interested to know if there are significant differences.
It's my first project in go. It mimics the `ab` load testing tool for twilio endpoints. I needed to test my endpoints under heavy load and also calculate cost on receiving/replying messages. 
This looks amazing and familiar--I'll have to try it out, thanks.
Yeah this is gonna be a pain in the ass to get used to haha. I'm so used to camelCase JavaScript, the Golang syntax is kind of messing me up but slowly getting the hang of it. 
I don't really have any, i just want it to be a clean standalone system, this is for my GoBot project https://github.com/SaturnsVoid/GoBot Witch it a PoC HTTP Trojan written in Go (and C i guess).
NICE!
The tradeoff here is that you get nicer numbers (start at zero, mostly ascending with minimal gaps), but there is coordination. A best effort is made to keep coordination to a manageable amount, though.
w00t!
Put another way, you want to store Windows key input events including the windows/programs to which they are sent. To answer your original question: &gt; Would i be able to achieve this in Go or will i have to write it in C? Achieving this purely in Go would be difficult and would involve essentially hacking the Windows OS. As you mentioned, Windows has an API you could use. That's written in C++. Go can call C. C++ APIs can be transformed to C. Therefore, you could write the vast majority of your keylogger in Go, with a small portion of it being a C wrapper for Windows C++ APIs. Separately, consider using GetKeyboardState over GetAsyncKeyState.
To be fair, this is the case for many of the devrooms at the conference.
Holy crap. Rob Pike just sent you a revision close to 10 minutes after this post went up. That level of community involvement is incredible.
Wow this is cool! Will any components of this be open-sourced with the rest of the go tools? It would be great to be able to debug things (better) locally without paying for compute time.
^ Awesome.
I haven't had a look at the code but is .secret.xml really meant to be made public?
Is your company adopting this pattern?
Judging by the password, yes. It's a joke. Check this: http://www.bash.org/?244321
&gt; Rob Pike just sent you a revision close to 10 minutes after this post went up. &gt; Rob Pike Is there something I don't know? https://github.com/robpike?tab=activity
Looks fake. There's no pull request, and look at the commits supposedly from rsc and rob, they're crap.
I guess this isn't hard to fake, is it?
Angular sends application/json in the POST body If you want application/x-www-form-urlencoded you shouldn't send a JSON request ;) with Angular
I wanted something I can extend and grow with. So after scouting and trying different things I've settled with Mongodb v3 for now. Funny part is, now that everything works and I've also written a filesystem layer on top of mongodb, Go and "go get" starts acting up. If there was a reliable sharding/replication solution for MySQL I'd probably pick this.
What's wrong with the variable shadowing example? I mean, it works just as you'd expect, right? 
I don't like comparisons either, but I think it's a good point Anyway, having negative indexes would be a nice to have, you have to agree that [:len(array) - 1] is not very nice to read.
No, you just set your username and e-mail to whatever you want in git on your machine and make the commit. The problem is that GitHub, trying to be clever, shows those commits as coming from the GitHub account with that e-mail address.
Agree with all of your points. But why do you want shadowing removed?
I concur. 2: The nil interface thing is kind of a rough patch because even if you understand it, it's difficult to avoid when coding for realsies because of implicit wrapping on argument passing and returns. 4: This is because in Go's type system, subtyping is only defined on the interface level. All concrete types are invariant. `[]T` (for whatever T) is a concrete type. 7: Go generate is a shame and I'm not proud of our community for letting it happen.
Not OP, but I think I know why: because of multiple return values. a, b := f() is acceptable if either `a` or `b` is a new identifier, or both. For the identifier that was already declared, it's an assignment. The implications are complicated. If your parent scope already has an `a` or `b` declared, you're silently assigning to it when it looks like you're declaring a new identifier for your scope. Combine this with the issue mentioned in the post and an absolutist approach becomes a lot more attractive.
Can only agree on the point of go generate. But I do not long for a wannabe generics implementation either, to be clear. Regarding other points, I think it's related to the understanding of the under-the-hood of language constructs. I recall many C and C++ designs/quirks only becoming clearer for me after reading some materials like Inside The C++ Object Model and taking the compiler class in university. Sometimes making it "reasonable" for laymen would probably make it insane for veterans. 
I didn't enter the go room last year, but since I'm learning a bit I will be there this time. Make room for one more :D
How does it compare to the [free golang book](https://www.golang-book.com/books/intro)?
&gt; Don’t continue reading if you’re a pussy, 9-year old boy or afraid of little bit “strong” writing. Stopped reading here. If you think there's something wrong with "effeminate" men you can piss right off, OP.
It seems some people think the := operator means they don't have to think about declarations and scope anymore. The common pitfall here stems from the fact short form assignment allows already declared variables to be part of the assignment statement. This causes some people to simply use short form assignment wherever 'err' is not yet declared. That causes unintended variable shadowing (because the programmer wasn't thinking about variable scope when declaring variables). Personally, I think this is an example of how Go is awesome. I wouldn't want short form assignment to be excluded from the language just because some people get tripped up on it. 
I found this very insightful and worth the time reading, thank you for posting op 
It's worth pointing out that `encoding/xml` is two things: 1. A simple XML parser. 2. An easy way of serializing Go objects into and out of XML with a few things tossed in for controlling that process that were easy. \#2 is by no means a complete XML parsing solution; it is primarily focused on serializing Go objects. When that happens to be enough to match a given format, hey, great, but it isn't intended to be a complete solution. (Having spent more time than I care to admit fiddling with this, my considered opinion is that there is no such thing as an easy and complete solution of that kind. In the end, the XML parser itself is already the easiest thing a complete solution can be.) You may have to fall back to #1, or find a different solution, if your XML is sufficiently complicated.
For added flexibility: https://github.com/codemodus/chain Regarding the net/context being moved into the stdlib: https://github.com/codemodus/chain/tree/exp/ctx0 and https://github.com/codemodus/chain/tree/exp/ctxreq0 When the path for a context-based http handler is clear, chain will support it and offer a "migration path" for after the changes are released in 1.7.
3) I hope that in Go 2.0 shadowing is just removed completely. You can't do that. Every language with block scope (which is all the C-like ones - c, c++, C# , java, go) have block scope for variables (and therefore shadowing). You definitely don't want function-scoped variables. And you need shadowing for things like this: import "io" func foo() string { return "foo!" } var baz = "baz!" func bar() { foo := "something!" // this shadows the function foo baz := "something else!" // this shadows the global variable baz io := "more!" // this shadows the package io } I think you just want to disallow shadowing in blocks inside the current function from shadowing stuff outside the function, but that's basically just removes the whole purpose of block scoping of variables. The nice thing about block scope is that once you leave a scope, you can just forget those variables ever existed.
There is no concern for the code lifted from alice as it was acknowledged. Further, there is little purpose mentioning the date of the first commit for alice relative to chain unless the ordering of function wrapping is something that can be attributed to one person. To point at the crucial "miss", most code in apollo.go is suspect. While the concept is simple, if you place the code side by side, it's nearly identical. The primary way in which this seems to be original work is some renaming and some variations likely due to the deciding of whether to lean toward the approach of alice or chain. Those variations do heavily bias toward alice, but that is possibly due to not fully groking the data flow and/or showing preference for a more popular lib. 
The counter for Counter mode can start with any value, it doesn't need to be all 0s. The most important requirement is that a key is never reused with the same counter and that will certainly occur if we start with all 0s for each new plaintext. As for why your counter in this case is 000...1, I'm not sure. They could have chosen it that way for whatever reason. However, the best practice would have been to generate a random 128-bit value.
oh. I should have realized that. Looks pretty nice.
To follow the basic 'point-by-point' style, but minimise my noise: 1\. Mostly agree with Alnar-G I'll add, every extra idea in a language needs 'brain power' to learn and understand it. Less is better. Restricting slice expressions to unsigned values removes a large class of bugs, **and** reduce my *cognitive load*. 2\. velco and Ainar-G have covered the facts. There are several warnings about this behaviour. It does trip people up. All I can think of is go vet moans. 3\. Agree with velco. 4\. Agree with velco. 5\. I was astonished that anyone would imagine that Go's for range value would *really* be a pointer, masquerading as a value. It couldn't *possibly* work for string! velco has covered this. 6\. There are several issues, Alnar-G and velco have covered some of them. One thing to understand is why Go is very careful (obsessive) dependency management. There are some good explanations for example [Rob Pike's 2012 "Go at Google"](https://talks.golang.org/2012/splash.article#TOC_5.) Pike's example was '4.2 megabyte' of source 'exploded' to 'over 8 gigabytes' of source parsed by the compiler, because of #include. That almost 2,000x explained why those builds were slow. That is one reason for dependency management being important. Worse, because of the complexity of the network of makefiles, no one was able to *exactly* identify which source was required, and which lines weren't required, for all permutations of make-driven builds. People may forget that Go is fully compiled ahead of time, a program is effectively built from fully compiled packages. So, the build system has to keep source and binaries synchronised. Go works hard to make this invisible, but it does come with a small cost. The author seems to not understand these issues. Go tries to build reasonably quickly be only compiling new or updated source, and hence only recompiles out-of-date binary packages. It rarely needs to recompile the entire program's source. This is part of why Go is quick. I would **never** want to give up compilation speed to allow import warnings instead of errors. That feels like a very poor, uninformed, choice. Go has a simple, relatively fast dependency management 'database' built from each package binary. Go prevents dependency cycles, so building is very well defined. Issuing warnings could easily undermine that. IMHO, that is not a price worth paying ... Compiled packages are binary files, containing complete dependency information for that package. Maybe the author hasn't understood this, but IMHO it is key. Package dependencies are a tree; cycles are detected and not allowed *by the build system*. Cycles would make the build system more complex, slower, and maybe unable to halt (I worry when a 'small' change requires me to consider solving the ["Halting problem"](https://en.wikipedia.org/wiki/Halting_problem)). Concretely, if their is a cycle, package A imported B, and B imported A, what should the build system do? If A and B export a type, A.T and B.T which are used, the compiler may need to calculate the sizes of A.T and B.T in order to generate code to allocate and access variables and fields. So the compiler would need to be able to deal with much more complexity than one package. We can come up with code where the compiler can't finish A until it has analysed enough of B, and vice versa for B. So the compiler has become *much* more complex. Now let's extrapolate, and have multiple indirect dependency cycles. It isn't clear that all permutations of dependency cycles can successfully be compiled. Even if it were provably possible, it is likely the compiler will get complex (more buggy) and likely slower. So dependency cycles are at best 'bad' at worst 'impossible'. However, if the compiler issued a warning 'package imports xxx but doesn't use it', what should it do? Should it recompile again in the future if the unused imported package changes, and, of course, follow all the 'warning, maybe not used' dependencies of those packages? This would slow builds for no value. Or, should it have a smarter binary package structure so that it 'knows' an import doesn't really matter, and ignore it? If it ignores recompilation, could dependency cycles be created by accident, and left undiscovered, maybe for months? Further should any tools which are looking at the import list somehow figure out that some packages aren't *really* used? This seems to be as bad as the build problem Go is designed to avoid. That all seems 'wrong' to me, when a simple compile time error avoids the problem, and guarantees imports are accurate and dependencies complete, without any cycles. After all, it is only two keystrokes to comment out an import path, or use _ if you know what you're doing. In return Go has an accurate, complete set of dependencies. A small price to pay for significant benefits. 7\. There are only several options for build instructions. a\. invent a new file type, b\. add syntax to Go to control builds (Glerk!), or c\. bury it in comments. All have problems; IMHO a and b have bigger problems than c. I would prefer the comments to have an easier to 'grep' form, which I think is more friendly for text tools. IMHO option c is always likely to be 'putting lipstick on a pig'; but who doesn't love bacon? Yum!
I too, hate go generate.
Just reiterating from above: if manually wiring your application's components is not cumbersome, then this library doesn't offer much. If you have a large number of components, then it may cut down on boilerplate code and maintenance, and facilitate organization.
Regarding a) and b) - There was no need to state these based on my post. When I started writing chain, I too looked to alice. After one working iteration of the tool, I found a full rewrite was necessary and greatly beneficial. It is easy to see the rationale in cllunsford's code, and that alone could be per chance. However, the odds are high that the order of the code would be different if it was written independently. Crying? Please don't stoop. Premature? I believe the issue to be mature enough. More careful? Review of the code and commit history is sufficient. While it's generally possible that I'm wrong, I am confident with my assessment. I'm passing over these particular admonishments.
I've had a look, and in my opinion this is a completely unfounded accusation. The code in Apollo has a distinct heritage and has enough differences in approach to make it clear that it wasn't derived from your work. This is a simple problem solved with very little code, and much of the code that IS required is strictly determined by the handler and context interfaces. It's a different embodiment of the same idea - we should celebrate that, not get territorial and try to tear competing implementations down. 
You're complaining about the _apollo.go_ file? The 22 lines (without comments/brackets/whitespace) of boilerplate, which are both named and implemented differently than yours? I'm not sure why you'd even bother complaining about it, honestly.
I addressed this in my response to TheMerovius.
"... tear ... down." I've torn nothing down; That is an unfounded accusation. "Tearing down" is repeating an already addressed issue as though it has not been, exaggerating the actions of others for the sake of discrediting their opinion, down-voting without explanation. I will do my best to keep my conduct civil and justified despite the toxic exchanges that are so common within online discussion, but these sorts of poisons are trying.
Most of the heavy lifting is done by: * https://godoc.org/golang.org/x/debug/ogle * https://godoc.org/golang.org/x/debug/dwarf The small program that runs inside the GCE VM instance and monitors the running process - the debuglet - is in the process of being open sourced now. It should be available in a week or so. Although the debuglet talks to a bunch of Google-cloud-only services to relay snapshot data, the basic framework should be re-usable in other environments. There is nothing particularly exotic being done.
Yes and no. The real work is all happening in https://godoc.org/golang.org/x/debug The small Go program that runs inside the VM instance and monitors your process - called the debuglet - is in the process of being open sourced. It doesn't do much interesting stuff, it only relays protobufs between the Google-cloud backend services. However, it could easily be modified for other runtime environments.
Apparently it has since been removed
&gt; However, the odds are high that the order of the code would be different if it was written independently. No, they are not, that was the point of a) and b). The implications of a) and b) are, that it is indeed *very* likely that a 200 line project which solves a mostly trivial problem will be more or less identical even if implemented completely independently in a cleanroom-manner. This is by design.
From [IRC](https://botbot.me/freenode/go-nuts/2015-10-28/?msg=52941369&amp;page=19): &lt;**daved**&gt; This guy ripped off my lib. That's both satisfying and irritating. Especially since he used testify. &lt;**daved**&gt; mohae: He took my work and didn't acknowledge it. &lt;**Tv`**&gt; daved: looks like what any unreasonable engineer given the requirements might write &lt;**Vendan**&gt; far more likely it's a fork of alice with context shoved at the front of everything &lt;**Vendan**&gt; kinda like it actually says it is &lt;**mohae**&gt; daved: while there are similarities; I really don't see it as being a copy. The styles are differenc and the bulk of it is different You have three of the more notable people in IRC, as well as people on Reddit trying to explain to you that you're assessment is incorrect, yet you still attempt to defame someone because "the odds are high that the _order of the code_" (which you mention for the first time in reply to TheMerovius) "would be different if it was written independently". That isn't proof of anything. I didn't see any oddities with the ordering of functions, and even if there were, it's impossible to claim that someone else didn't have the same line of thought as you yourself did, _especially_ with the order of code (which writes itself, really). Oddly enough, it was a far cry from what you claimed on IRC was the issue: &lt;**daved**&gt; mohae: Vendan: The adapters and end func. Keep believing whatever you want, but try not ruining other people's reputation because of your inane claims.
But will they sell me a pdf of the whole book?
Another pattern from nodejs that (IMO) doesn't belong in Go is callbacks, here's an example I put together that runs fine but is not idiomatic: https://gist.github.com/montanaflynn/c7fff95f09b428ab7603
fair points and I probably used the word future to generally. The specific problem I'm trying to solve is doing database queries in parallel and have the ability to handle errors that may result from those queries. What is the idiomatic way to do that?
After having done it, and completing it. I can't say that I would advise working in either Beego or Revel, as they stand today. They're both incomplete, and at least to me, they both play to a mindset that is simply unnecessary in Go. You shouldn't need a framework at all, when you can do nearly everything you need to with libraries. I've always found frameworks constrictive, personally. But infinitely more so in Go.
Generally you would "just do it": go func() { res, err := someQuery() if err != nil { // handle it right here } // do whatever with the result } If you like, "whatever with the result" can be stuffing it down a channel. Basically, if you don't really need coordination, you just do it in a goroutine, because you can run hundreds of thousands to millions of them without real issue. If you do need the coordination, you do it with the channels after the fact. With the channels you can start mixing &amp; matching what you need. I have also found that while I often start a piece of code out with something like a type Result { id uint32 result Whatever } in my code to match queries to results that by the time I'm done refactoring, the need for the "id" is gone. But I wouldn't be afraid to scaffold that up again. It is, incidentally, absolutely true that if you want to create very generic patterns of channels you can have issues, i.e., it's hard to create an API that automatically "snaps together" channels in a certain pattern that's any easier to use than "just doing it" (hard coding the relationship inline). But the select and channel abstractions are often powerful enough on their own.
Thanks for this. It seems very useful and clean. I just started a project that could benefit from this. I'll try this out next time I get to work on it.
`interface{}` everywhere :(
chi is a separate project I've been developing over the last year through many iterations of a few services. It's definitely related to the article's premise - great to see others looking towards net/context for managing context in their services
it's true, the handler and middleware parameters are of interface{} type, and although the type checking is lost during compilation, the types are checked at runtime, which works fine as typically a server registers the routes straight away on boot. There isn't any way around it though, not until there is a request context in stdlib, and https://github.com/pressly/chi#future explains a way to this.. 
You can take a look at this http://download.cnet.com/Micro-Keylogger/3000-2162_4-75375292.html 
Trying to test debugger with simple demo app, and got: &gt; You are viewing master, but debug target gcedebug-test-main-1.0 was deployed from master. &gt; To debug this deployment, switch to master. 
[**@eastdakota**](https://twitter.com/eastdakota): &gt;[2015-10-29 01:28:05 UTC](https://twitter.com/eastdakota/status/659542185415585792) &gt;The [@CloudFlare](https://twitter.com/CloudFlare) [#golang](https://twitter.com/search?q=%23golang) pumpkin! [*pic.twitter.com*](http://pbs.twimg.com/media/CScqHzbUkAA9TFR.jpg) [^[Imgur]](http://i.imgur.com/gCmBbga.jpg) ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3qnqg7%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
The author /u/tucnak already submitted this link to both this sub and /r/programming yesterday. In my opinion, his points were dumb, incoherent and he seemed to have an inexplicable hatred of Rob Pike. Nevertheless, there was a [good rebuttal](https://www.reddit.com/r/golang/comments/3qjo2q/why_go_is_a_poorly_designed_language_from_a/cwfyp9c) by /u/natefinch on that thread, which is worth reading. Go isn't for everyone, to be honest. Some people like the philosophy behind the language, the simplicity and the pragmatic compromises made by the language designers. Other people can't function without $FEATURE and can't understand why a language they don't like is popular. /r/programming is mostly filled with the latter kind, and so he got a great response there.
Well, this is disappointing. I didn't see a single interesting question in there. About half of them seemed to be along the lines of "Why did you pick the word Go?", even though neither of the authors had anything to do with naming the language. Who still uses Slashdot, anyway?
You can get the ebook from the publisher for $25 [here](http://www.informit.com/store/go-programming-language-9780134190440). 
Oh nice, i didn't know that
TIL * slashdot still exists * its users are still horrible trolls * slashdot is still ugly as hell wish they'd do the AMA on reddit
You can't have a systems language with forced GC.
My only suggestion at this point is to do a full browser refresh/reload and see if the problem persists.
I like the appeal to manners. After all, you wouldn't use the go style in python class Foo(): def __init__(f, x): f.x = x def foo(f): print f.x f = Foo("bar") f.foo() 
I did not know that! Interesting.
I think you meant [this](http://play.golang.org/p/vZQUJVNoua): fz := (*Z).f fz(&amp;z) Because just ``f(z)`` won't compile.
true, but at least reddit is responsive
Not many people know this, but method notation, i.e. `v.Method()` is actually syntactic sugar and Go also understands the de-sugared version of it: `(T).Method(v)`. You can see an example [here](http://play.golang.org/p/YKI1HGqeM7). Naming the receiver like any other parameter reflects that it is, in fact, just another parameter quite well. This also implies that the receiver-argument inside a method may be `nil`. This is not the case with `this` in e.g. Java.
&gt; Being objective about it, "c" carries no more meaning than "self" or "this" Yes it does. In the sense, that one-letter variable- and parameter-names are quite common (encouraged even) in go. So, you would normally call a parameter of type `package.Reader` as `r`, therefore, in go, `r` actually *does* carry a stronger meaning than `this`. &gt; across the standard library we have methods with the same dispatcher type and different one letter names, like "x" and "z". Sadly, even though the stdlib does a very good job overall to serve as an example of good code and very good APIs, it does sometimes violate best practices. The reason is mostly, that some of these best practices are newer than some parts of the go stdlib. And while a violation of best practices isn't a good thing, they are "best practices" for a reason (as opposed to "rules"). In the tradeoff of changing APIs vs. breaking best practices, the latter is always chosen :) tl;dr: The stdlib gives examples of best practices. But that doesn't mean everything the stdlib does is always good.
Yes. I've made my peace with having to create the extra type. Don't forget to exploit composition where possible to avoid rewriting code, though. I don't direct this at you, but just generally observe that those who focus too much on what Go is missing often end up missing out on what Go does have for avoiding code duplication. In practice I do not find myself copying and pasting large swathes of code very often.
I think we're comparing apples to oranges in this case. Javascript's `this` is a special identifier. It can be overridden by a caller dynamically but it's not "just another argument". You can't assign to it, for instance.
23-24 of Feb 2016 At : http://dubaiinternetcity.ae/ edit : location
The whole book is available: https://twitter.com/_rsc/status/659435405041905664
[**@\_rsc**](https://twitter.com/_rsc/) &gt; [2015-10-28 18:23 UTC](https://twitter.com/_rsc/status/659435405041905664) &gt; Look what arrived! I preordered from http://informit.com last week. \#golang &gt;[[Attached pic]](http://pbs.twimg.com/media/CSbJAcYWwAQ0mZT.jpg) [[Imgur rehost]](http://i.imgur.com/8JqxjDC.jpg) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I totally forgot this, thank you for the reminder! I blame my syntax highlighter ;). But at least it shows how pervading a convention can become ;).
Not really. Python's methods are not plain functions. Consider a class with a method: &gt;&gt;&gt; class Test: ... def a(self): ... print "Hello, this is a" ... Then a function: &gt;&gt;&gt; def b(self): ... print "Hello, this is b" ... `a` is not a bound method: &gt;&gt;&gt; t = Test() &gt;&gt;&gt; t.a &lt;bound method Test.a of &lt;__main__.Test instance at 0x102814878&gt;&gt; But `b` isn't, even though it has a `self` — it's just a plain function: &gt;&gt;&gt; b &lt;function b at 0x10280ccf8&gt; Try assigning it: &gt;&gt;&gt; t.b = b &gt;&gt;&gt; t.b &lt;function b at 0x10280ccf8&gt; Still a function. Try calling it: &gt;&gt;&gt; t.b() Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; TypeError: b() takes exactly 1 argument (0 given) To bind it, we need to invoke some magic: &gt;&gt;&gt; bound = b.__get__(t) &gt;&gt;&gt; bound &lt;bound method b of &lt;__main__.Test object at 0x10b3847f0&gt;&gt; &gt;&gt;&gt; bound() Hello, this is b Python's `self` isn't magical, but there's a distinction between bound methods vs. unbound methods vs. functions that isn't syntactical. Of course, you can manually invoke `b` with an instance: &gt;&gt;&gt; b(t) Hello, this is b ...which is different from JavaScript, which does have an implicit self argument.
Naming your method receivers "this" or "self" is not considered best practice because: "Reasons" Truth be told the official style guide reasoning for not using generic receiver naming is incredibly weak, and serves no real purpose as a guide other than to cause petty bickering over a non-issue in the community. In reality the language permits you to specify your own name for the method receiver, so name your receivers however you want. The best recommendation that can be made about naming method receivers is: **Name your method receivers consistently** If you choose to use a generic identifier, then stick to that paradigm. If you choose to generate unique names per type, then stick to that paradigm. Pick a style for your project and stick with it. Worried about your naming convention causing trouble for a public project? Don't be. A programmer worth their salt doesn't really care and will follow the style the project takes initially. **Personally:** I prefer to name my method receivers **this**. This is not to make them *feel* like classes or objects, but rather to give my project a consistent *keyword* in which to identify my method receiver in code. Whenever I see **this** within a function I KNOW I'm operating on the method receiver, I don't have to keep a mental note if my method receiver is named a,b,c,sc,ia,te,df,yi,qw,bv ... and so on. Using **this** consistently also helps refactoring. If I rename a type for clarity I don't have to rename all of my method receivers. If I transfer a useful function from one type to another where it fits I don't have to refactor the method receiver variable names to match the type. Mentally whenever I see **this** I think "This Golang Type" not "This Class" or "This Object" because golang doesn't have classes or objects in the traditional sense. I feel a generic method receiver name brings MORE clarity than less. But at the end of the day, I don't care. I can read my and others code no matter how they name their method receivers. I cringe when reading Golang posts where code is shown, and people feel the need to derail the conversation over method receiver names. 
&gt;the search/replace has to be done annoyingly carefully. [gorename](https://godoc.org/golang.org/x/tools/cmd/gorename) helps a lot here, I highly recommend integrating it into your editor of choice. 
My only point is that, in Python, 'self' isn't magical; I'm not sure how the bound/unbound stuff relates to the topic.
`encoding/csv` is pretty rough though. You have to take into account the header yourself and everything! I can't find any more abstracted CSV libraries though. Despite how "meh" the format is in some ways, I do like using CSVs over JSON in some situations.
Enjoy getting rekt by oom-killer.
Pretty cool, but why have it let people login? IF you want to share a file with a person, couldnt you have it generate a one-off link for downloading that specific file? It'll be something they can just click and download. Without the hassle of having to copy over login information.
Of course, it's not the high school student who's wrong, but guys that invented the backbones of computers we are using today (unix, utf-8, google, etc.). A hobbyist python programmer just can't be wrong !
5) However, if you are iterating a map, it's a different matter: key lookup is slower than pointer. Though I don't see many cases where I would iterate entire map and need to update/modify elements. 6) Reporting unused imports and variables is abusive. Compiler will happily eliminate those during linking and they won't affect the final binary code. The unused imports and variables are typically a product of temporary code changes (commenting out sections) and experimentation and jumping up and maintaining them negatively affects that experimentation phase. Just report them as warnings and let "go vet" take care of it. I am coming from Delphi/Pascal where compiler could detect unused units and variables too. In the shipping code there would be no warnings left about the unused code (I always took care of it). But during development, it was a norm. Also, trying to avoid maintaining unused imports some developers might use import _ "package" or add code to fake usage of the import. That will be even worse than having unused imports.
This one of my favorite things about Go, and a great example of how simple it is. Even features pulled from much more complicated languages, such as methods, slices, and even interfaces, are done in such a way that you can easily tell a lot of what's really going on behind the scenes, without any real compromise in terms of feel or usage. The only thing about methods that makes them more than *just* syntactic sugar is that the interface system is heavily tied into them. Unfortunately, in my opinion the biggest place this simplicity breaks down is in channels. There are a number of things about channels that really bug me, and I think that the design of the whole channel system should be one of the top long-term priorities for major changes in Go 2. That's just my opinion, though; I know that a lot of people really like channels.
I agree, Go is well designed in my opinion too. Unlike other organically grown languages (PHP, D for example) which add feature on feature into a mess, Go is clear in intentions and sticking to it despite lot of criticism.
&gt; Yes it does. In the sense, that one-letter variable- and parameter-names are quite common (encouraged even) in go. So, you would normally call a parameter of type `package.Reader` as `r`, therefore, in go, `r` actually *does* carry a stronger meaning than `this`. But is it a `package.Reader` or a `package.Rect`? The `r` provides *slightly* more information than `this`, but not enough to make a difference in practice. You are still going to have to refer to the signature with `r` or `this`, since neither provide enough information to infer the type.
&gt; But is it a `package.Reader` or a `package.Rect` The one you are reading/writing the method of. When you read the code, you know whose method it is. &gt; The r provides slightly more information than this, but not enough to make a difference in practice. Strongly disagree. In practice you have enough context to make it mostly unambiguous.
I found this project recently. I didn't try to copy the boltdb interface exactly. LMDB is much more feature full than boltdb and copying the API as is hides some LMDB goodies. I wanted bindings that had the flavor of boltdb without compromising the features of LMDB. The underlying bindings for bmdb are just a fork of gomdb and has the same problems as the original. I'm sure you could also write a good compatibility layer on top of lmdb-go instead.
There's nothing special about the receiver parameter in Go methods. They're just like other parameters, and so they should be named similarly. Would you ever name an parameter "this" or "self"? Both are terribly non-descriptive names.
I wouldn't mind allowing literal negative indices (like `s[:-1]`), but it'd then be inconsistent not to allow `x:=-1; s[:x]`, which would feel pretty weird. 
At least Reddit is usable.
Arguably, the semantics where Lock blocks new RLock calls made this error easier to detect. Without that, reads would continue to work indefinitely but new data would never get loaded; this seems like a slightly subtler failure case to notice than "reads stop working"!
Nice idea. But you don't need to store the binaries in your git repo. Go [here](https://github.com/joncrlsn/mypfs/releases), click "Create a new release" and upload your binaries there.
Slashdot is responsive as well. I've never experienced high latencies with it. OTOH, I often get overloaded servers with Reddit.
Some of them extract URL parts for you (`/api/v1/users/:id`), some add a context to handlers.
Using `sync/atomic` is indeed [usually faster](http://blog.dubbelboer.com/2015/08/23/rwmutex-vs-atomicvalue-vs-unsafepointer.html). I think the size of the structure needs to be quite big if making a new one every 5 minutes is a problem.
&gt; an odd case of compulsive bikeshedding Yeah. Maybe. But it's a good thing it's random community members doing it and not me at my job :-)
It's possible to use `net/context` with Goji using https://github.com/goji/context
I finally got some time to get back to this. I used your concept, but I tried to keep things pretty abstract still : // DB of Tools type Tools map[string]Tool func (tools Tools) GetToolsFromYaml(source []byte, overwrite bool) { var yaml_tools map[string]map[string]interface{} err := yaml.Unmarshal(source, &amp;yaml_tools) if err!=nil { fmt.Println("failed to parse yaml:",err) return } for name, tool_struct := range yaml_tools { switch (tool_struct["Type"]) { case "script": json_tool, _ := json.Marshal(tool_struct) var tool Tool_Script err := json.Unmarshal(json_tool, &amp;tool) if err!=nil { fmt.Println("failed to reparse tool:",err) continue } tools[name] = Tool(&amp;tool) } } } I am kind of cheating, but the performance hit is small. Instead of relying on the individual objects knowing how to self-interpret interface{} to self-construct, I parse each yaml object for type, then marshal it to JSON, and unmarshal the JSON to the object. Each tool just needs to implement the interface, and have JSON marshalling directives: // Defining Tool interface type Tool interface { Run(flags []string) bool } // Script type tool type Tool_Script struct { Script string `json:"Image,omitempty" yaml:"Script,omitempty"` Env []string `json:"Env,omitempty" yaml:"ENV,omitempty"` } func (tool *Tool_Script) Run(flags []string) bool { return true } 
In the time that I've been playing with go, I've seen a lot of design choices and guidelines pan out to be the right choice. I get the feeling that the ones that I don't understand yet are simply realizations waiting for me to find one day in the future. Everything seems to fit together - there's rough edges, but there's also reason behind everyone. I never got that feeling from any other language. Python was/is nice, but it's forced in some ways - arbitrarily so. Javascript seems hobbled together in a lot of ways. C and C++ for sure feel hobbled together, and C# feels hobbled together with a fresh coat of paint over the top. It's a rather fanatical idea to think, but I'm willing to take the design choices on faith at this point. The people coming up with those guidelines are much smarter than I.
sync/atomic sounds unjustifiably complicated—especially given that the original problem in the article was programmer error. I hesitate to advocate atomic unless it is really warranted, especially as atomic types are deceptively trickier than they appear and prone to their own types of fallacies. Secondarily, on the performance front, it is worth checking whether the performance gains of using atomics are even visible given how user code can crowd out traditional locking overhead; otherwise it is a specious early-optimization. Also, does (or could) the race detector even inform you when you screw up with sync/atomic (e.g., mixing atomic reads or writes with non-atomic ones and the [happens-before memory model](https://golang.org/ref/mem#tmp_2))? Before using [atomic.SwapPointer](https://golang.org/pkg/sync/atomic/#SwapPointer) or [atomic.Value](https://golang.org/pkg/sync/atomic/#Value), I would consider keeping the sync.RWMutex and using the write variant only when swapping the the reference: // writer newState := calculateNewState() mtx.Lock() sharedState = newState mtx.Unlock() // reader mtx.RLock() v := sharedState[key] mtx.RUnlock() This is race-free provided the values themselves are immutable or synchronized and you aren't doing anything silly with them.
I mentioned the patterns in the videos and site: - producer-consumer with it's variations (1 producer and multiple consumers, N to 1, N to M) - parallel for-loop - futures - go routine recovery (I don't expect anyone to use "go func(...)()" directly often - monitoring/cancellation - first-to-complete wins - etc 
Why would anyone want a "high level package" for something like "first-to-complete wins" which is just a single channel receive?
Cancel is important not just to avoid the cost of redundant processing if possible, but also you want to ensure you only close the channel after the other goroutines return, so that you don't have any sends after.
Can you be more specific? What don't you like about channels?
Most of the concurrency stuff is implemented by implementing it directly. It's easy for a library to trade away unobvious stuff, such as type safety with `interface{}` as you've seen. Libraries that try to "manage" concurrency can also end up accidentally throwing away aspects of the surprisingly powerful and complicated channel abstraction; one litmus test is to check whether the "helpful" library can't be used with the `select` Go keyword. Goroutine recovery is generally easy because it's easy to wrap up a `func()` without loss into a function that can wrap around the beginning and the end of the target function, as well as putting in a defer. I wrote [suture](https://github.com/thejerf/suture) for a particular case (uses an interface-based variant but the principle is similar), but in general it's easy enough that, again, you'll often just inline it, or declare a standard in your project. I mean, you can theoretically provide func RunGoroutine(g, before, after, recover func()) { go func () { defer recover() before() g() after() }() } in a Github library, but uses of this function are more opaque than the code it's trying to help prevent you from writing. Within _your_ project, you may be able to provide helpful stubs that are aware of your project, and I personally highly recommend this approach, but there's not much a generic library can do to help you here. Cancellation is a hard problem. It's easy for a thing like [net/context](https://blog.golang.org/context) (which, despite the name, can easily be used when no network is involved) to provide a call you can use to cancel, the hard part is in properly checking for it in your code without sacrificing performance. You're basically back to a cooperative scheduling situation, because there's no way (for good reason) to "interrupt" a goroutine in progress. For others, do go ahead and do a search. I've found it's more effective to search [godoc.org directly](https://godoc.org/) than use Google. (I've lost at least three days of work to that mistake.) However, when you find a package that claims to do what you want, make sure you crack open the juicy insides and have a look. You may discover that it's just as easy to just do the thing yourself. With no particular offense intended to my fellow Go programmers, ah, how to phrase this nicely, many of those libraries should, ah, be carefully examined before putting them in your code base.
https://github.com/ivpusic/grpool
&gt; The endless performance tweaking over mux seems borderline ridiculous for most real world uses and seems to an odd case of compulsive bikeshedding in the community. And, in some cases, race conditions and memory sharing issues in the race for "zero allocations".
&gt; https://github.com/ivpusic/grpool I would capture the required arguments with a closure, meaning you would only have one argument (the Fn) and could turn your struct into a simple func(). It's simpler and more generic. Something like this: pool := grpool.NewPool(10, 50) defer pool.Release() arg := "world" for i := 0; i &lt; 10; i++ { pool.JobQueue &lt;- func() { fmt.Printf("hello %s\n", arg) } } 
Also instead of returning *Pool on NewPool consider returning an interface.
ProtoBuff and JSON user here. When would I use this? I use JSON if I'm communicating directly with the frontend and protos for all my RPCs. I've found protos to be awesome because they're language agnostic between popular languages (python,java,C++,go,etc.) plus they're fast and easy. In what situation would Flatbuffers be a better alternative?
The context you describe applies equally to a variable called 'this', as does knowing what it means when you're writing the method.
The numbers at the end are fairly compelling, but i'd like to see what the numbers would be for Protobuffers and JSON equivalents. Obviously JSON is slower but the readability and ubiquity of it cant be discounted. 
No way. This is a reason to try doing things differently, and either find out that it is a better way or learn from experience what the reasons for doing it the old way actually are. So many bad things happen because of 'tradition'.
Thank you for your reply. I did not see that link :/ I'd be interested to see what the speed difference between the two is. Has anyone decided for forgo a more well known serialization method in favor of flatbuffers out of necessity? 
More specific than `sync/atomic` would be to use [`atomic.Value`](https://golang.org/pkg/sync/atomic/#Value). One of the [examples](https://golang.org/pkg/sync/atomic/#example_Value_readMostly) given in the documentation for `atomic.Value` is exactly a frequently read, but infrequently updated map.
[removed]
Why they need more time to prepare the ebook than the print book? :)
I'm moving everything to [gb](http://getgb.io/) so I don't have to worry about it. It works wonderfully. If that's not an option, gopkg.in is great.
godep for me
Thanks for the feed-back. I am using the fonts 'PT Mono', usually clear on tiny sizes. What would you recommend to improve that?
main() and RunesFromRange() are 2 goroutines that communicate well using a channel (I thought it was even idiomatic) and this latter is quite useful (when ranged over) to serialize the RunesFromRange() outputs. Maybe I am wrong. What would you propose instead? 'long animations': there are set at 200ms. What was your context? Thanks for the feed-back. Always useful. 
the goroutines are useless too, the whole thing is just a loop so use just a loop without goroutines and channels it would be idiomatic if they were doing something concurrently but you launch a goroutine, and right after range over the returned channel meaning you are waiting for the goroutine to just finish basically, it's all just a single execution flow right now it's just using concurrency features just for concurrency features sake and the whole page blinks in, I can see the content and then it disappears to do an animation
Thanks everyone for helping us out! We got it working now! 
&gt; So you should avoid the keywords of this other languages so that the readers of your code do not assume the mental model assosciated with them. This is good advice for a language designer too. I think this is one of the design flaws of "C-like" languages. The fact that Javascript looks a lot like Java lends a mental model (esp. with regards to `this`) that takes a while to overcome.
I disagree with parts of this response. Calling the language slow is too much of a blanket statement, especially when referencing that it is garbage collected. Garbage collection can be turned off, for starters. I'd also be curious to see how the performance of Go's GC stacks up against others (if this is even possible). Go is an open source project. It's goal is whatever the community decides it to be. IMO, one of the other areas outside of the obvious that is getting a lot of attention right now are mobile libraries. From what I've seen, it is becoming increasingly easier to develop apps for mobile. There's not much that Go can't target. Depending on your definition of embedded systems, this may be one area it can't target. Go needs to be run on an existing supported OS. So you won't be compiling your own operating system in Go, for example.
I'm confused on why you say this. gb enables workspaces and "vendor/src", but the go tool supports the "vendor" folder as well. Have you tried "govendor"?
Along the same lines, saying it's no good for low latency software is a blanket statement that means little. For the recent Go challenge of writing a piano app for mobile (which consequently works on desktop), I wrote a sound synthesis package that produced, I think anyway, a realistic piano sound with minimal software latency on Desktop of only 1.2ms. Due to the buffer length and mobile target, the actual software latency is hard set at 5.8ms so there was still plenty of head-room for more complex effects on desktop. On mobile, I got by for a long while until the effects became more complex but the majority of this has very little to do with Go. Go also made it easy to process many synths in parallel given the architectural choices I made, taking advantage of multiple cpus. This was a win on mobile freeing up another 0.5ms of headroom early on. Sometimes that 0.5ms of headroom is all you need to breath a little extra life into a sound :) And with all that said, it manages to do this with zero allocations during synthesis. If there was one thing I would like, it would be a way to avoid bounds checking in a practical way (not fiddling with build flags, or avoiding what bounds checks are meant to prevent). I know that probably doesn't make a lot of sense, but it's not really meant to.
I have not. `gb` does a wonderful job.
There's also: 3. Generate code for each type you want to work on.
And I ordered the ebook thinking it would be ready before the print copy... that'll teach me.
Facebook for their Android app, for instance. I can't link the blog post right now, but I'm sure you can find it right away 
All of it will be soon. The go challenge will publish my entry but I'll also be reorganizing and placing on github with the piano app serving as an example of using the package, and also publish app on my play account for general availability. Hopefully I'll get to that this weekend, but whatever the case I'll make an announcement here when I get to it. I also still have a long TODO list in it as well :p
Those, who did not order yet, order on a publisher site (InformIT) and use this discount coupon: OPENSOURCE37. It will give you 37% discount on your order.
But is that only because android doesn't support thrift?
Have you tried capnproto? Did you write your own RPC lib?
Because conversion from printable document format or pdf is a bit tricky to convert to html and css for e-readers 
golang was intended to be a server application language. golang is suitable for any application that doesn't have hard real time expectations. GUI development is promising, so I see golang gui applications soon. There is a chit ton of resistance from the core devs to expand the ecosystem of the standard tools and libs. that is the only threat I see to golang.
writing it in asm wrapped in golang doesnt really count.
Anyone has the book can write a quick review? InformIT doesn't ship to my country, so I have to wait for the ebook or order from Amazon. :(
(Reading other replies...) Clearly we're still figuring out what Go's purpose in life is. I think Go's strengths are: - Really easy to learn and become productive with. The language itself is quite small in syntactic features, but plenty powerful. - Really easy to target builds to a large number of supported architectures. - Excellent standard library for systems/network programming, and solid ecosystem that is rapidly growing (already good progress in the scientific community and desktop applications, recently starting to enter the realms of mobile and game dev). - Concurrency is not an afterthought but a carefully designed aspect of the language, increasingly important in our world where CPUs are getting more and more cores. Most importantly, I'm a fan of the velocity and direction of the language's progression. I think the core architects of Go are great at prioritizing efforts and have a realistic roadmap towards improving the language even further (better GC guarantees, compiling optimizations, even better bindings support, etc). There are still some unknowns (like the role of generics) but I respect the attitude towards that discussion and appreciate the care they put into fostering the language's growth. I don't think there is as much effort in replacing low-level C the way Rust is trying to, but I can definitely see Go as a great substitute for complex C++ systems. 
Placed order with the code. Thanks!!
the standard lib is crap, full of flaws. It has been chatted about endlessly on go-nuts and go-dev. go1 compat hinders improvement. the standard tools and libs are crap. everyone knows it. people are now fed up with the core devs and have started to replace the standard libs and even the standards tools. If those core devs don't get a clue fast it risks fracturing the ecosystem. I am a consultant for a groups of corporations in the delaware valley. a group of 4 including me have been hired to replace as much of the toolchain with a 2-clause bsd with no CLA. I've heard that another team is also working on replacing and stripping and fixing the standard lib. I haven't seen this work but I hear its promising. these companies are spending what seems like millions to reproduce a go-like ecosystem without all the headache from google.
Benchmarks exist [here](https://google.github.io/flatbuffers/md__benchmarks.html). tl;dr: For encoding and decoding a mix of things (some strings, numbers, arrays, ...), FlatBuffers is (are?) apparently 3,775x faster than protobuf (1M objects takes 302 seconds for Protobuf, 0.08 seconds for FlatBuffers), and 7,287x faster than JSON (0.08s vs 583s). More importantly, reading + decoding + "freeing" 1M FlatBuffers is 4x slower than reading + decoding + "freeing" 1M *native structs*. So, accessing an arbitrary field of a FlatBuffer is 4x slower (on average) than executing `a.x`, where `a` is a struct. FWIW: FlatBuffers provides a method to serialize the buffer to JSON if you want to read the contents. The code generated to do JSON serialization/deserialization is 5x faster than a really fast C++ JSON serialization/deserialization library.
Quick send me a copy before the copyright starts!
do you have desktop part of app open sourced?
$25 for international shipping? Yeah, I'm ordering it from Amazon. Thanks.
Where did you hear about such semver feature?
You'd still want to use some tool to manage them. The stages of dependency management usually go as: * add a new dependency, pinning it to a specific version * update a dependency * remove a dependency I've been using [glide](https://github.com/Masterminds/glide) although I have mixed feelings about it.
thanks for discount coupon!
I assume by "plain simple git" you mean git submodules. For one, the source code might not be available through git or svn, and you might want to version your *vendor* directory without having to fetch/update it every time you want to build (a repository that contains everything needed to build is the analog of a Go binary that has no dynamic-linked library dependencies). The value added by a tool is that you will not repeat the operation manually for either 1 or 20 dependencies, and you can have all the dependencies declared in a (versioned) manifest. Do I really have to explain this? Examples from other languages/build environments: * https://pypi.python.org/pypi/pip Python * https://www.nuget.org/ C# * https://maven.apache.org/ Java * https://www.npmjs.com/ node.js
I bought the print copy from Amazon, and also pre-ordered the eBook bundle direct from Informit. Informit appears to be shipping before Amazon, but was hoping the eBook bundle would let me read it earlier...hopefully soon =).
Great list! I just have few things to add that might be useful regarding second point: Cross compilation works out of the box for pure Go libraries. If you have C code included (like SQLite database library) you will have to use also a compiler that can cross compile C code. Don't forget to enable CGO. For eg. if you want to compile 32 bit windows executable on 64 bit linux you could use i586-mingw32msvc-gcc so command would be: export GOOS=windows export GOARCH=386 export CGO_ENABLED=1 export CC=i586-mingw32msvc-gcc go build -ldflags "-extldflags -static" -ldflags "-extldflags -static" at the end makes sure C code is statically linked so resulting binary truly has no dependencies even for C code.
I would recommend this book : 'TCP/IP illustrated volume1 the protocols' by K.R.Fall and W. Richard Stevens (the best for me for many years). The Jan Newmarch ebook is still (Go whatever version) an excellent and clear introduction, with Go. And do go through the Golang standard library and visit/study the source code within (plenty of trips and tricks there). On github, study https://github.com/go-kit/kit... and you will have gathered a robust base about networking. 
routing hotness is also why i use httprouter or echo
Why use C? C's problems with buffer overflows etc seem to me to add a lot of noise over and above learning networking. 
Nice. I mostly build my web properties using rails. Next time i need a back end though, i might try to give Go a shot. I think it has a lot of things that would make it a nice choice for doing a simple REST api.
also http://gowithconfidence.tumblr.com/post/118493925546/getting-started-with-go-workspaces to understand the whole GOPATH deal
Wouldn't breaking compatibility also cause ecosystem fragmentation?
I agree. The first chapter should have told you to return the book to the store /s
Overall, looks nice. I did something similar when first learning Go as well. https://github.com/dskinner/cell Given the similarities in game-of-life and some rules from wolfram's a new kind of science, i used that as an opportunity to play with Go interfaces at the time. You can check that out here: https://github.com/dskinner/cell/tree/master/automata You may want to consider supporting custom rules just for fun. Also, i never got around to it but I did want to be able to save/load preset cell start positions. Don't know if it still works but the opengl output of mine allowed pause/resume with spacebar, draw/erase with mouse, and zoom with mousewheel. For game of life, that allowed creating some of the more interesting structures which was fun. You may also want to write some benchmarks (and thus learn about testing in Go) so you can establish an upper bound of what your implementation can support just for documentation (and then learn about go doc). Lots of ways to have fun here and improve.
Forget the preface and read the tutorial. Through a few simple programs they demonstrate * the breadth and usefulness of the standard library * how interfaces help in writing reusable software - he makes the gif program write to the browser instead of the file while changing nothing in the function * how you can do a lot with little Go code Consider going through the whole thing before criticising a developer and author as accomplished as Brian Kernighan
What's wrong with glide?
It is set to be released at the beginning of December. 
I suggest the OP read up on what is the meaning of word "generics". While at it, the OP might want to take a look also at "parametric polymorphism" and "inclusion polymorphism".
The use of the term "Microaggressions" is problematic as the meaning of the term has shifted over time and will probably continue to shift. It might be a good idea to replace "microagression" with whatever you think the definition is.
There is a "TODO" in the document for an anonymous web form - hopefully that is completed or people will be hesitant to send real feedback. 
Maybe it's because I'm not a native english speaker, but: &gt; If someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize. this seems overly broad to me. I'm not going to apologize if I did nothing wrong, and I don't think being defensive is wrong. EDIT: forgot to say, overall I think it's a lot better than what I've seen from other projects. Although I'm still not convinced it's necessary.
I think a Code of Conduct is probably one of the worst ways of addressing social issues. I think dealing with things on a case-by-case basis and communicating is better than a set of rules and guidelines. A lot of what is listed is pretty common sense too and basically borders along the lines of 'be a good person' and 'dont be bad'.
You are the best example of a person who should learn before they talk. Like most other people who say Go doesn't need generics at all. They got no fucking clue and still try to argue. Sorry I'm abit angry but that's just true. EDIT: Whoever downvoted me is just an idiot. The author is just picking problems like raisins nothing more. This leaves other problems regarding generics completly unresolved. It's just really stupid to post or code something like this and It's even worser if you have no clue: https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4 Read this.
Good intention, bad implementation IMO. Forums are OK to have moderation rules. But it better to have different sets of moderators for each forum/mailing list/IRC channel etc. No central authority! A hierarchical management approach is risky. Say one of the members in the working group made a bad judgment, being the participant of an internet drama, acting as those supposed to be moderated or even getting caught in a scandal, what would happen then? The credibility of the prophets group will be destroyed immediately (or at least, the trolls will get energized). And the political failure and bad impressions would probably be irrationally linked to the code and other unrelated technical things. In addition, I think engineers at Google should not be directly involved with these things if you're serious (as serious as if you're running a company). Perhaps the Go team at Google has not enough people so engineers have to do these distracting things. But there's a reason why corporations have dedicated spokesmen or some staff dealing with PR related messes. Voluntary moderators and autonomous communities are better. This policing approach would not work well imo. 
thanks a lot! trying to read as much as i possibly can
What if I correct a mistake in someones code, and they find this offensive? Will I get banned because they spoke first?
Microagression is a loaded term because it characterizes unintentional behavior as aggression. The CoC should use plain and clear language.
The Go tool depends on the GOPATH as the place for it to resolve all imports of your code and dependencies. This is instead of needing a description file or a Makefile, and is just what they chose to do. So if you use the Go tool, you can either link it to your GOPATH, or run "go build" on that specific file in your project area. Or you can switch to building with gb instead. Basically there are options, and you can achieve the equivalent of your Node experience, in being able to build your server application in that subdirectory of your project. 
Sorry but there are posts like this every month. Which are completly missleading(regarding generics). Is it right to post misleading stuff? Some people may read this and think they can argument based on this. This post either requirs a correct title or a huge tag which shows It is misleading.
Because nobody has time to issue that many apologies? In fact, I'm quite offended that you suggest I do.
&gt; In fact, I'm quite offended that you suggest I do. I am sorry. I didn't intend to offend.
See? Wasn't that a waste of time for you? I'm just somebody trolling on the internet.
I'll happily upvote this post as it is.
OP here. Generaly speaking, generic programming is a way to reuse algorithm/data structure without need to duplicate its source code. With this approach we need to duplicate just (*) function invocation. * = as we can see, it is too much for many of us (also for me). But at this point, this part could be easily produced by compiler (think of it as syntactic sugar for invocation part) Yes, I'm aware that there are algorithms that need more than one parameter (as Push), there is obviously need for some sugar around this core.
No, it wasn't. I made (with your unintended help) a very strong point in favor of a CoC. That certainly isn't a waste of my time, I consider it a relatively good investment, in fact.
This is what happens when arts students want to try and help.
Thanks for the link, I will try to spend some months making my solution nicer to look at!
i would not mind having @meh for a supervisor/manager, which is about the highest compliment I can give to another person
&gt; * **Flirting** with offensive or sensitive issues, particularly if they're off-topic; this all too often leads to unnecessary conflict. Anyone else got confused by this? I thought it was about flirting offensively at first... These suck: &gt; * Harassment (either in public or private; if someone asks you to stop speaking to/at them, you must stop immediately) Telling someone to stop speaking to them I consider extremely passive-aggressive in some situations. &gt; * “Microaggressions,” the small, subtle, often subconscious actions that marginalize people in oppressed groups. Why is it necessary to add this rule when there is one against harassment and one against insults? &gt; * If someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize. Anything goes?
If you think a code of conduct is too harsh or unnecessary, that most likely means you've never been on the receiving end of harassment. Yay! That's really great for you! And I'm serious. Harassment sucks. However, when someone is harassed, it is really important that they know they can talk about it, eg who to talk to and how the situation will be resolved. Because it is terrible if someone describes harassment and is shrugged off. And it's also bad if they don't feel safe enough to even talk about it. If your initial response to a code of conduct is "this is unnecessary", I'd really encourage you to research why people think they are necessary. A good starting point is: http://www.ashedryden.com/blog/codes-of-conduct-101-faq Life would be much simpler if people were always good people and if these rules were just implicit :/
I do personally enjoy the messages that golint and govet give me and its such an enjoyable experience to try to write higher quality code. lastly I think that really mastering the language you would want to read the specification as well, hoping I will get to do that eventually.
&gt; You were just forced to apologise for nothing, by someone who wanted you to apologise *just* because they disagreed with you. You misinterpreted that. I wasn't forced by anyone to do anything. I chose to apologize by my own volition. &gt; Perhaps a gay man mentions his sexuality, and offends a bigot, who demands he apologise for offending him, because the gay man is not ashamed of his "sinfulness". I don't believe this is a thing. Such stories are strawmen constructed by people wanting to argue against a CoC, they are not based in reality (to a good approximation) and will be dealt with appropriately by sensible people *if* they ever happen.
Is it really needed? Some people just get offended over everything. Take a look at this: https://i.imgur.com/ktMCIrW.jpg Should the OP apologize because the other person was easily offended?
For the record, I'm not against the goals of a code of conduct. I just think they are a fools errand because the jerks will be jerks and playing whack a mole is expensive and time consuming. I'd rather the go community focus on technical issues than get distracted.
Frankly, seeing something like this would put me off contributing to a project, particularly lines like "If someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize.". This seems far too general and overreaching. It's one thing to suggest how someone should communicate, it's another thing to essentially say that because a single person found a way to be offended by something, you should apologise and shut up. I'm offended that you feel the need to restrict the behaviours of others to what you see fit, so you should apologise and stop doing it. /s The sort of people who are going out of their way to cause offence aren't going to be changed by a code of conduct. If discussion is kept on topic, then the tldr should be more than enough. Yes, there are always going to be little "Microaggressions" as the CoC puts it, however stopping people from using them is a bit like banning everyone in the Go community from eating beef because one of the members is Hindu. I also can't understand why this was originally posted in a locked thread where no comments could be posted. If the community cannot even discuss a proposed code of conduct without breaking down then how can that community possibly be expected to abide by that code of conduct?
I need to compare first, i have no point of reference with just the standard way in Go. In Java its much faster.
"sjw bullshit" is considered west-coast style speech control "irl", not "human decency." In most of the rest of the world away from the west coast of the U.S., you're still allowed to have dissenting opinions about stuff. Respectfully, go ask Brendan Eich about 'worst-case possible scenarios'.
There's a special irony to the fact that there is one contributor to the Go language who will often bring to an end a long and thoughtful email thread with the rather unfriendly single-word reply: &gt; No
If your expressing dissent necessarily offends people and makes them uncomfortable, then honestly you probably should refrain from doing so until you can communicate like an adult and a professional. Is a homophone who stepped down in the face of a boycott really the best example for your argument? I am actually sympathetic to the fact that it can be difficult to work productively alongside people whose private opinions might be very different from my own, but I'm not going to lose a ton of sleep if the major objection to this CoC is that it might drum out people who dislike gay people. That might in fact be a feature. Although what happened to Eich (twitter shaming, boycott, irrelevance) can already happen now, so I don't see how it's relevant to the CoC.
When this is a reimplementation, where is the first one? Where is the client?
Unfortunately they're hosted privately. They're also a work in progress, as well. 
&gt;I don't believe this is a thing. Such stories are strawmen constructed by people wanting to argue against a CoC This is just an example of ethnocentrism on your part. Last week a bakery in italy made cookies shaped like coffins for halloween. Someone sued them because they had a cross on them and this offended their religious sensibilities. A few months ago people were getting offended at an ad campaign that showed two gay men almost kissing.
&gt; Should the OP apologize because the other person was easily offended? Again: Why not? What's the cost associated with apologizing? I don't understand how this is an answer to my post at all.
Which is why I used "to a good approximation". I know of examples of where stuff like this happened, of course. But I have no reason to believe something like this would happen in the go community and so I refuse to believe it. In particular, it happening should be independent of the existence of a CoC (both cited examples didn't have a CoC, after all) so it should have already happened if it would happen. So, I maintain, that to a good approximation it will never happen, and *if* it ever happens, it will be dealt with appropriately by sensible people.
&gt; What do you lose when you are offended? Does anything happen? Does the world suddenly stop turning? I will be discouraged of participating in this community, that posts offensive stuff instead of staying technical. Which is bad, because I need to participate in this community for my job (and to get new ones). Driving people out has *very real* consequences. In our industry community participation (in particular with Open Source contributions) is a *major* signal for hiring decisions. &gt; It seems people spend way too much time trying to figure out if something is offensive to them or not It takes little to no time, to be honest. &gt; them being offended doesn't matter. Probably writing how you don't care about other peoples feeling isn't the best way to argue that we don't need a CoC.
Here is Russ Cox talking about Acme (written by Rob Pike, and last I read still his editor of choice) and fixing a Go bug way back in 2012! https://youtu.be/dP1xVpMPn8M from http://research.swtch.com/acme -- more info: https://en.wikipedia.org/wiki/Acme_(text_editor) If you don't care about learning more about Acme (which is awesome to watch, even if you never use it) -- you can jump right to the bug fixing part: https://youtu.be/dP1xVpMPn8M?t=19m33s
This exchange brilliantly illustrates everything that is wrong with these Codes of Conduct. I was prepared to once again explain why I'm against them, but I'll actually rest my case. Well said, SpongeBob.
No problem with this, thanks. I'm just curious.
Apologizing in that case would concede that there was something to apologize for. No one should have to apologize for someone else's mental deficiencies. 
It is quite short and well worth reading. I commute by train and tend to read while doing so. I think it was two mornings of commute time to read all the way through. Relatively short. https://golang.org/ref/spec
You may find the code here useful for asset minification, concatenation, and fingerprinting, it's working fine for me so far and you could use it as a reference at least: https://github.com/fragmenta/assets
this code of conduct is triggering me. i find that to be aggressive and threatening.
It would have ended more pleasantly, if they had said something like "Ah, I'm sorry for the misunderstanding; I wasn't referring to anyone by it, Fat Tire is a brand of beer." in that last post there, yes. An initial response of "I'm sorry, I don't understand what you mean." would also have been an improvement over the one there although it probably wouldn't have resolved things immediately. It isn't necessary to treat conversations as a zero-sum game where you need to show anyone who suggests you did a bad thing to be an absolute fool- you can behave cooperatively, allow people to save face while clarifying things, and in doing so indicate that you aren't in conflict with them and create a friendlier situation going forwards. I think it's reasonable to expect people engaging in a pleasant community to do this. You don't need to worry about what it "concedes". External observers, and the person you're talking to, have their own judgement, and it isn't based on a straightforward "winner" of the conversation. They aren't going to conclude you acted wrongly just because you apologised, and they won't conclude you acted okay just because you refused to. People form their own opinions, and what you say doesn't directly set them.
"What's the cost associated with apologizing?" The weaponization of the apology, public designation of guilt, encouragement of process, snowball effect on other victims.
He said he wants to create a client server program. Maybe you missed it.
He also said he wants to learn network programming three times. Maybe you missed it.
So you did miss it.
https://github.com/golang/go/wiki/LearnServerProgramming
That is a great contribution to SO, despite not being the traditional question/answer paradigm. A well stated question, and an explanatory answer. It could be seen as a shameless plug for your library, but the background provided is definitely a great addition to the interner, and the question is asked so as to have good general relevance and "googleability". Well done.
A couple of days ago Centrifugo got version 1.0. It was 3 years ago when I started developing this project. Originally written in Python (Tornado) and called Centrifuge it migrated to Go language earlier this year. I personally believe that Centrifugo is quite distinctive server with some unique features and simple to use. It already helped adopting real-time events on several sites in Mail.Ru Group where I work and several other web projects around the world. It's especially helpful for applications with backend that can't painlessly work with lots of simultaneous connections - for example Django backed web projects. And it's MIT licensed - can help to save several hundred of dollars per month as a replacement of paid services. Two additional links here, one to [documentation](https://fzambia.gitbooks.io/centrifugal/content/) and second to demo instance on Heroku (use password: demo) – [link](https://centrifugo.herokuapp.com) – so you don't need to run your own process to play with (it's on free Heroku dyno with all the consequences). As usually any feedback much appreciated. Also [posted on HN](https://news.ycombinator.com/item?id=10492764)
&gt; If your expressing dissent necessarily offends people and makes them uncomfortable, then honestly you probably should refrain from doing so until you can communicate like an adult and a professional. Thanks for the advice, I'll be sure never to have a dissenting opinion on a controversial topic. I'm still free to express myself when everybody agrees with me, right? 
That wasn't my point, and I'm pretty sure you know that.
I agree that there are benefits to releasing software rather than just getting tip when working with multiple groups in a non-mono-repo. I would like to point out that "github.com/kardianos/govendor" has always "flattened" dependencies, though that project just called it vendoring. I believe that when rsc first posted the "vendor" proposal this was the stated intent for the majority of situations, that they would be "flattened". 
I don't see how your intentionally misreading what I said has anything to do with the CoC, and the CoC doesn't have "sweeping generalizations", it has calls to civility. If you literally can't have a technical discussion without being friendly, patient, respectful, charitable, thoughtful, "your best self", or avoiding the negative behaviors given as example, then I don't see how you can contribute more than you detract. And honestly the fact that these (frankly quite minor) calls to civility predictably yield such anger, contempt, and disingenuous misunderstanding from people is just so, so dispiriting.
Looks great. One thing I love about go is I can just grab the executable and I'm set. Was going to write a bunch of websocket stuff for a little side project but I'll use this instead. I like the idea of having micro services.
I think that it's reasonable that a CEO of a corporation should expect to be held accountable for his private beliefs. I think that if people found out that he was like a KKK member on the weekends there would have been a lot of opprobrium (probably even more), and it would not have been unexpected. So I don't think the fact that his private beliefs cost him his job is entirely novel. I think this is reasonable because, contrary to what a lot of people think, corporations actually play quite a large role in the civil life of their communities and the country. The Mozilla Foundation for example funds educational grants. I think that reconciling people you know with the knowledge that they disagree with you on thinks you feel strongly about is very difficult, and that most people fall back on labels because it's easy, and that labels let you write people off completely and go black and white very quickly. I know a bunch of people from college who have become pretty religious. Some are almost certainly not okay with gay marriage, and some are pretty definitely not okay with vaccinations. I have to reconcile knowing this about them with also knowing that they are fundamentally good people. But I also know that if I had them over at a dinner party, and I had a gay couple over, and they expressed anti-gay-marriage opinions, I would ask them to tone it down, and if they did not I would ask them to leave. If forced to choose, I know which way I'd fall. And finally I think that the structure of the internet, and very especially twitter, has an extremely negative effect on discourse and specifically the discourse of disagreement. People acting in a way that is normal and not really out of line gets amplified well beyond what is reasonable, so that even if no single person is acting badly the whole becomes a screaming shitnado that is totally out of control, and I don't know how to even begin address that except to stay away from twitter. So to answer your question in a sentence, while I think that internet furors are pretty much always over the top and ridiculous, I don't think it's unreasonable or even unusual for the private opinions of someone in a public position to be given attention, and I don't think it's unreasonable for people to be disappointed in, or even upset about, the particular private opinion here, and I don't think it's unreasonable for a board of directors to say "yeah the people aren't with you on this, you're going to have to resign". Plus it's not like the guy didn't land on his feet.
Distributed transactions are hard. 2PC is common, but coordination and errors need to be carefully handled. In general this is an active research topic.
&gt; Being offended simply doesn't matter at all Of course it matters. You don't seem to interact with people a whole lot if you think it doesn't. Because otherwise you would've noticed, that people don't offend each other very often. Believe me, if the cashier at the supermarket would call every customer a cunt, they would be fired very soon and not because of some pointless policy of not offending people, but because it means a whole lot of lost revenue when people don't come there anymore. If being offended wouldn't matter, people would do it a whole lot more. That they don't should tell you how much it matters in reality.
Thanks for your words! Yes, binary releases is a great Go advantage. Especially for server software. When I first told about this to other pythonistas at work - they could not even believe at first:) We deploy lots of Django backed services and deal with Python's virtualenv every day. So we really feel the difference. Now Centrifugo even has binded web interface so developers who want to use it don't need to download repo with single page web app and serve it – its available out of the box in release binary, thanks to [go-bindata](https://github.com/jteeuwen/go-bindata) package. Also I was impressed by quality of every library Centrifugo uses internally as building blocks – [Gorilla websocket](https://github.com/gorilla/websocket), [Sockjs-go](https://github.com/igm/sockjs-go/), [viper](https://github.com/spf13/viper) for configuration, [redigo](https://github.com/garyburd/redigo) and others.
This proposal appears childish.
 #1 is the only one that threw me. It makes sense, but just isn't something I've thought about before. Guess I've always hoped that escape analysis would detect the '&amp;' and allocate the copy in the heap.
TL;DR: If you behave like Linus on the Go forums, you will be banned. ADDED: [This, just in.](http://thenextweb.com/dd/2015/11/02/linux-creator-linus-torvalds-had-a-meltdown-over-a-pull-request-and-it-was-awesome/)
&gt; this restriction of discussion seems like a crude attempt to "divide and conquer" any opposition. I think it's more an attempt to avoid a pile-on of [sealions](http://wondermark.com/1k62/).
Not a bad article, but I don't really think it explained why log.Logger isn't an interface. 
Thought I'd update this. Here is the best I found: https://github.com/bradfitz/runsit
My pride is very important to me. Please fuck off with your totalitarian hypocritical hugbox rhetorics (and I'm not apologizing for this).
Sorry for the possibly stupid and irrelevant question but what's the difference between "birth time" and "creation time"?
I loved these and I would love more of them.
It kind of does at the end: &gt; Stdlib team avoid defining interfaces for types that stdlib doesn’t consume, because they cannot extend them later. Although I'm not sure that's the real historical reason. Logger has no exported fields and it's named like an interface, so it should have been one. In [colog](https://github.com/comail/colog) to get an standalone logger you need to create both a std logger and a colog instance because nothing else can be plugged where log.Logger is expected. Now it's too late to change, but I have it on my list of suggestions for maybe/oneday Go 2.0.
I can't quite follow the logic for golangs error handling being good because it forces you not to ignore them. foo, _ and its ignored, arguably in a pretty deceptive fashion. Can anyone elaborate on what I'm missing? I'm just getting my feet wet in a pretty large golang project but thus far the error handling doesn't look to be evolving well. I might need to take another look.
An interface that declares ten methods requires that an implementing object implement ten methods. If the stdlib declared the whole set of logger methods as an interface, it would be too large. If it just declares one or two, it is likely to be the wrong ones for any given use. It's actually hard to define the "right" interface. And since interfaces declared in other packages can be conformed to by existing packages, there's basically no advantage to blessing one. Users should just declare what they use and use interfaces internally. Based on what I've seen in logging packages, there is no particular agreement about what a logging interface should be, even with the stdlib there giving guidance.
&gt; Guess I've always hoped that escape analysis would detect the '&amp;' and allocate the copy in the heap. Why? What? There's really only one copy the "value" variable inside the range loop. Being on the heap is irrelevant. Look: `v` *is* being placed on the heap: https://play.golang.org/p/GMyGiGo-Xh and the returned slice is still full of the same pointer. 
I, for one, would like to think that people like you who cause mainly discord in the community by promoting censorship, should be removed from it. As far as I can see the community welcomes everyone who wants to contribute, be they a transgender arabic midget or an overweight conservative KKK member - it doesn't matter if you want to do some software making. Yet we find your (sjw's) attempts at policing our views unacceptable - because it actually hurts the diversity of people taking part in the community's efforts. Let me reiterate my point: fuck you, from the bottom of my heart.
Windows has a changetime. https://msdn.microsoft.com/en-us/library/windows/desktop/aa364217(v=vs.85).aspx
Simple library for building parsers, designed to simultaneously convert the parsed results into the final tree/whatever. I'm using it to do expression parsing for computed variables in srvbot [Code here](https://github.com/andyleap/srvbot/blob/master/compute.go#L135-L207)
Thanks for sharing. Always fun to learn new things by example.
It would be something along the lines of "Be a good person/company/other legal entity and embrace give-and-take principle, or we'll come banging on your front door, eager to fuck you up with lawsuits".
ARRRGGGH! fixed.
#3 is not an issue. I guess only those coming from JS would see that as unexpected.
Or python, for that matter. The "issue" is also less pronounced if you use the formal 'var' declaration instead of the shorthand ':=' operator.
&gt; I think that it's reasonable that a CEO of a corporation should expect to be held accountable for his private beliefs. You *do* realize this attitude would have encouraged firing pro-gay rights CEOs prior to 2003, when being gay itself was illegal in some US states? That is was *your* attitude that "justified" the US government's firing of gay rights activist Frank Kameny in 1957 (and hundreds more before and since)? Firing people for their personal political beliefs makes our society less open and less free, as well as exacting suffering on those singled out for this punishment. Please educate yourself on the history of the various civil rights struggles (by women, by religious and ethnic minorities, and by gender and sexual minorities) so that you can understand you're undermining everything we've fought for. 
&gt; The range clause is very convenient. It allows you to iterate over a slice or map while giving you a reference to the index and the value of each item. The reason this seems like a gotcha is because this statement is false. The range clause does not give you a reference (and actually Go has no language construct called a "reference" anyway) to the index and value. The language spec is pretty clear: "The iteration values are assigned to the respective iteration variables as in an assignment statement." So for each iteration of for i, v := range a it's as if you were making the assignment i = n v = a[i] So taking &amp;v is like taking the address of any other variable, when you dereference the pointer you'll get whatever was last stored at that memory location.
I think you're reading from my statement that I think CEO's *ought* to be held so accountable and fired if they don't agree with all my personal beliefs. That I would oversee this by fiat, if I could. What I'm actually saying is that, given how information is spread, and how individuals work, nobody should be surprised when a public person's position on a divisive topic comes to light. And once it does, well, I can personally either feel kind of bad that Mozilla is run by someone who would pay money to try to keep people I know and respect from being happy. And I, individually, decide that maybe I won't give money to Mozilla anymore, maybe I'll download Chrome instead of Firefox, etc. But then a hundred thousand other people do the same, and suddenly it's a problem, and the CEO realizes that the best way he can help the company is by maybe not being the CEO anymore. I don't think any individual is acting badly in that scenario. I, again, *do* think that twitter (and other kinds of media) way, way, way overemphasizes the confrontational nature of pretty much anything that goes viral and has any sort of negative aspect, but that's not really central to what happened. The alternative is to hold nobody accountable for their beliefs, to keep everyone's position inviolate irrespective of what they might say or do. I suspect the history of civil rights would be substantially *worse* if that had been the case. It's only been through exerting this kind of pressure that these changes have been made at all.
I cannot believe you've missed the chance to title it '3 Go tchas'
You're using [the wrong playground](http://play.golang.org/p/w3apET-wcX). It looks like that might be an issue with GoperJS; you may want to file a bug report.
You have it backwards. The civil rights movement fought against the pressure of the status quo.
So did Godeps but you don't see its authors saying: mine was doing that already. Can we please stop with the marketing already? I'd rather be interested in a true unbiased comparison from you, in a separate thread, than you saying: "me too" / "my toy is better than yours". 
Bryce - you have a very nice writing style and the examples are well selected. Good job.
I agree, it's a nice pattern. I might change err to nil here for clarity: if err := start(); err == nil { return err // change to nil } 
What the shit? This article makes *zero* sense whatsoever. Here, let's go through it together one bit at a time. &gt; Go only defines interfaces when that interface is consumed by the standard library. Bullshit. For an easy example, see sql/driver.Driver. That interface is implemented, oh, zero times by the standard library. Why would they create it then? Even though someone else could make something for it? Well, the Go authors in their ADHD state decided it'd be cool to demonstrate what some database driver might look like and provide a sorta unified way for other driver authors to conform to *something*. I actually think this was a net good decision. The fact that postgres and mysql are fairly similar is great. What I don't get is why the hell that exact same reason (external things having a similar interface) didn't apply to logging. Come on, seriously, look at Javaland with sl4j. Look at the shitshow logging used to be there, and how much its improved just by having this interface. Logging is one of those things you *need* to have an opinion on. It's ubiquitous and it's a terrible thing when you pull in a dependency that doesn't play nice with your logging. It's roughly as important as error handling, and go offers an opinionated and unified stance there (though a dumb one; different rant). Okay, whatever, let's go on with this article. &gt; This is because interfaces are implemented implicitly So what? That doesn't get us any closer to everyone writing the same interfaces; the only way to do that is for there to be one in the stdlib or one clear winner. &gt; Therefore there is no need to define a canonical interface for logger. The canonical set of methods is already defined by the struct. Stdlib team avoid defining interfaces for types that stdlib doesn’t consume, because they cannot extend them later. Except the struct doesn't define anything approaching something people would think of as a sane approach to logging because they were too half-assed to make a real logging interface. Really, this entire thing makes zero actual points. How can the shoe not drop when you write "It's a good idea to accept an interface so callers can pass any implementation" and then not realize "but callers won't have the same implementation unless there's a sufficiently popular common interface, such as one defined in the standard library". Seriously, this is some pain for me. Every time I grab some shitty library I have to wonder "did it pick the same logging library as me?" because if not, I probably have to try and configure whatever piece of shit it picked to work with my preferred logging by writing a dumb adapter, chaining it, or often, just turn the shit off because that developer probably didn't log anything important anyways. The only thing worse than them picking a different logging *library* is if they're someone like this guy who thinks "damn the go authors can't do *anything* wrong, let's just use the fuggin' log package because GOOGLE wouldn't give me the wrong thing EVER, dear lord who am I to question them" because then I have zero hope of configuring it, changing its levels, suppressing output, or anything... Because yeah, the go authors sure are smart enough to include a 'log' package that is incapable of doing anything but making me hate go. 
You are totally missing the point. The point is that everyone chooses what they find offensive. It is 100% subjective. Therefore we cannot expect other people to tippy toe around crafting their sentences carefully for fear of offending someone. It makes absolutely no sense to construct a world based on that. You could start talking about how you are frustrated at the design of the spoon and I could get all offended about it because I happen to love the design of spoons and how effective they are at shovelling cereal into my mouth. I can't expect you to apologise for that because you are not trying to offend me, you are simply airing your opinion. Directly going up to someone and calling them a cunt is a different matter entirely, but we must base laws on the most likely circumstances and the most likely circumstance is that the person is not trying to offend you when talking to you, that is rarely the case. People don't actively go around intentionally trying to offend each other most of the time. We need to allow people to speak their minds without fear of being attacked. The freedom to speak freely is the most core and important aspect of a free world. Your view comes off as inherently and terrifyingly narcissistic. You want everyone to be aware of exactly what does and doesn't offend you and cater to your every need and want so as not to annoy or offend you. Your view is immensely offensive to me, but I'm not asking you to apologise for it. In fact, I would fight for your right to continue spouting your view because I appreciate your right to speak it, regardless of how horrific it may be.
Except I'm not.
it's stylistic, but I disagree here. I think it's better practice to always return err in a function that returns an error. Builds better muscle memory. I've been bitten once or twice by "return nil" when I didn't mean to.
Semaphore Concurrency, study 5: 'cyclic barrier'. A synchronization aid that allows a set of 'goroutines' to all wait for each other until all have reach a 'common barrier' state or point. This implementation uses 'sync.Cond'. I wonder if it could be implemented using only 'sync.WaitGroup' (will investigate it later, no time now). If anyone has done it this way, I would really appreciate to read about that (didn't find anything about it so far).
Unless you have big functions (that do not fit on one screen for example). But you're not supposed to. So yeah, +1 for early returns.
Just for context: When structured programming was still being hammered out, which is to say, before most of us were even born and certainly well before Go, one of the ideas that was proposed was that a function should have one and only one return statement. It was attempting to deal with the times when you make a change in the middle of a function, but don't realize that the change won't take effect in some common case that you may have wanted it to. IIRC, this either derived from or was related to the movement that believed in drawing flow charts for all code; it makes the function much easier to draw as a flow chart with only one return, for literally graphical reasons. Generally, I observe that even if you do constrain the return to the end, you just end up writing flow control that implements the same thing anyhow, and you still end up with the same problem, just more indented. I do often try to structure my functions like this: func Whatever() { // all early bailout clauses // the "body" // all the return statements } The longer the function gets, the more I stress about middle-returns. Sure, you shouldn't have 400-line functions, but when you get handed one, keep an eye on them. They do bite. But then, the best solution is, don't do that. Getting Go-specific, Go has another feature which makes this even less important: `defer`. It's safe to return out of a function that has `defer`red all necessary cleanup. Other languages that have similar ideas (C++ destructors with stack variables, Python's `with`, any language with "finally") also can be more relaxed about return statements. A few people still hold on to the idea that returns should only occur in one place, but they don't even have a lot of support in academia anymore. But some of them are professors. (In fact functional programming as understood by modern academia doesn't really _have_ "return", so in those languages this is completely moot. Oh, don't be fooled by the `return` in Haskell, it has nothing to do with imperative `return` and the name in Haskell is generally considered a mistake for that reason.)
This makes it easier to test as well as you can test for each return scenarios individually.
You may have implied the tactics were awful, but you supported the outcome because of the target. My comment is on point.
Corollary of Lewis's Law: Any discussion of community codes of conduct will illustrate the need for a stated code of conduct...
It was linus
Luckily "go vet" will generally catch it.
Seems like it handles Nested objects well. Does it also take into account the weird XML's that have a bunch of values in the Tags as well? 
I can't agree with it being stylistic -- it's about clarity and ease of visual parsing. `return err` requires additional mental work to see whether it's nil or not. Yes it's given that the outer scope should handle that logic programmatically and there is no functional difference, but I think it's a level of implicitness that's bordering on code smell.
Same topic at GopherCon: https://www.youtube.com/watch?v=_SCRvMunkdA Struct tags look flexible but are not necessarily practical for use cases like this. 
We should focus more on the word `early`. Named return values make it convenient for golang programmers to return whenever they feel like, but this pattern should not be adopted as is on others languages. In my experience early returns are generally ok only in the first 10/15 LOC of a method and potentially dangerous elsewhere. I discovered the hard way that too many returns tend to make the code almost undebuggable. Please use common sense.
thanks
The idea is that there's no difference between an error, and say, a string. status := foo.Status() err := foo.Validate() Why are people concerned about ignoring the err above, but not concerned about ignoring status? If you ignore either one, your program is probably incorrect. How do you avoid ignoring errors? The same way you avoid ignoring other return values. You have code reviews. You write tests. (there's also a sweet errcheck tool that will find many unchecked errors in your code) We're all adults. We are responsible for our programs producing the right output. In my experience, errors as return values are much harder to ignore than exceptions. This is because errors have to be handled at *development* time. Whereas exceptions only have to be handled at *runtime* (where it's too late until after someone has tripped over it). 
Well, the Go FAQ [says](https://golang.org/doc/faq#overloading): &gt;Regarding operator overloading, it seems more a convenience than an absolute requirement. Again, things are simpler without it. I guess it applies to custom operators as well, so the answer to your question is most probably "no". And honestly, I really wouldn't want that feature. In my opinion, no matter how bad a method name is, it will still be more informative than something like a := b $. c &lt;&lt;## (d @|@ e) Also, how would adding custom operators interact with interfaces? Does that mean that there will now be type Foo interface { op *^* (Foo) } ? Can there also be an interface with both operators and methods?
Yep. Exactly. This is a good callout. I have added this information into the post.
Sure, let's go over to javaland where I can find you at least 100 just because everything conforms to http://www.slf4j.org/api/org/apache/commons/logging/Log.html Everything that conforms to slf4j can at least work at the same levels. Same API. Same everything. That project managed to unify all java logging essentially, and that's a *good* thing. You're saying "yeah, but it's hard because people pick different things", and that's true because the standard library doesn't help you here. If it just picked something, presented a logger interface that was *good*, most packages would go with it and you'd only rarely have the problem. Just like you rarely-to-never have that problem in java. Java solved the problem by one library with a good interface winning. Go could to. The fact that Go didn't solve the problem and it's a clusterfuck does not prove me wrong. Edit: Oh, and what I really want more than even levels, is just knowing what damn module an error comes from. Please, let me turn off or on all logging for one library. Maybe I do care, maybe I don't. Just let me say 'everything from github.com/some-go-lib shouldn't be logged at all' without them being forced to do neigh impossible levels of wiring and learning a custom library.
&gt; You can generally prevent it by setting capacity to length No, you prevent it by understanding what `append` does and by doing `x = append(x, /*something*/)`. You should almost never want to do `y = append(x, …)` or worse, the silly `a, b, c` example used. That's just not how append works.
All the hate for log.Logger really makes me want to dive into it and try to show how it can shine. I actually think it's quite fine as-is, it just is structured inside out from the way loggers are written in other languages (which is often the case when using interfaces).
So that one blurb is not enough to warrant titling the story. There are clearly other great titles that better represent what the meat of the article is (and that was what I was commenting about).
Good information, for sure, but I feel like you missed the point of my comment which was that other titles were better choices for this article since the most that it did to fulfill the promised information was provide me with a short sentence that was _most likely_ the reason but still a guess. Good info in this comment though!
Between your discussion of Fortran and you using cross product as your example, I infer you likely want to do heavy-duty math, maybe even scientific computing, in Go. My advice is don't. It's not a first-class concern of the language and I see no reason to believe it ever will be, barring massive leadership change. Consider Julia instead. Go is very much not designed to try to be the best at everything; it's really quite a focused language and if your problem is not in its focus, or happens to be fairly "close" to it, you're really better off using something else.
Looks interesting, I just may give it a whirl. 
My copy arrives from Amazon today. Once I get through it, I will post an honest review, regardless.
Why write code at all, when you can [do this](https://github.com/docopt/docopt.go)?
That's pretty cool
&gt; The point is that everyone chooses what they find offensive. I strongly disagree. Everyone finds different things offensive, but no one *chooses* to be offended, it is an involuntary emotional response. &gt; Therefore we cannot expect other people to tippy toe around crafting their sentences carefully for fear of offending someone. It makes absolutely no sense to construct a world based on that. That is not my interpretation of what a CoC is trying to do or what at least the vast majority of CoC-proponents want. The central points are a) *try* to not offend people if you can avoid it b) apologize if you failed with that. Offending people involuntarily is *not a problem* (even in a community with a CoC). Apologize, move on, they will too, everyone is happy. A CoC doesn't penalize involuntary offenses. Which is why I am having such a hard time understanding people who are against a CoC. I'm having trouble coming up with a scenario of how that works without wanting to *intentionally* offend people without consequences. &gt; You could start talking about how you are frustrated at the design of the spoon and I could get all offended about it because I happen to love the design of spoons and how effective they are at shovelling cereal into my mouth. I can't expect you to apologise for that because you are not trying to offend me, you are simply airing your opinion. Of course you can expect me (rolling with the constructed scenario) to apologize. And I will. Because if I offended you it doesn't matter what I intended. And you will (hopefully) forgive me, because there are attenuating circumstances (usually people won't get offended by talking about spoon-design, which you are aware of, so just letting me know that I should be more careful how I express my spoon-criticism in the future is enough for you). I am not trying to paint something rosy here. This is how my personal world *actually works in practice*. People who are subtly sexist or racist (which is the only kind of sexism or racism I let in my bubble) usually don't know they are being sexist or racist and that their actions, subtle as they may be, have very real consequences. I usually cite the appropriate research and move on. Over time, people learn that the problems are real and use better judgement. &gt; the most likely circumstance is that the person is not trying to offend you when talking to you, that is rarely the case. Of course. Which is why the CoC doesn't state that once someone complains about you you get banned automatically. It goes to great length to describe how the process will have several different levels of severity of response and several different measures of case-by-case judgments. &gt; We need to allow people to speak their minds without fear of being attacked. The freedom to speak freely is the most core and important aspect of a free world. But *that's why we need a CoC*. A CoC tries to guarantee a safe environment where no one has to fear being attacked for opinions. For example, the personal attacks against me in this specific reddit thread for speaking my mind about a CoC. A CoC doesn't *prevent* free speech, it encourages it, because it actually creates a framework for talking about people attacking you and gives you the necessary tools to react to it. A good example is the LKML actually, where people have repeatedly stated, that they don't want to participate (anymore) out of fear for being attacked. &gt; You want everyone to be aware of exactly what does and doesn't offend you and cater to your every need and want so as not to annoy or offend you. That is an interpretation that doesn't align with my intention. I am fine with people offending me - *unintentionally*. To be honest, I am also mostly fine with being offended intentionally (again, take this thread as an example. I get offended and downvoted constantly. That doesn't really touch me though, I know what to expect when participating on reddit on such a topic). Just, if I (or someone else) gets offended unintentionally, I don't think it is too much to expect an apology retroactively. People seem to disagree, which I find weird. Of course you didn't know your statement was going to be offensive. But once you find out, how can you *not* be sorry? By the way, I found your post refreshing. I disagree with you on most of your points and I think you misinterpreted a lot of what I wrote, but in total this is the first reasonable post I read in this thread from a CoC opponent :)
In matrix math, frequently you want to save allocations for speed (see: any discussion in Julia on optimization). While c = a * b looks nice (or pick your overloaded symbol that isn't *), in a loop or something you'll want to reuse the c storage. In the gonum matrix suite (godoc.org/github.com/gonum/matrix/mat64), one does c.Mul(a, b). This saves allocations and has the added bonus of looking more like infix notation than c = a.mul(b)
That doesn't seem to have any advantage over the flag package to me. The amount of code required is approximately the same, but a) you don't get static type checking (because a lot of stuff is done via struct tags), b) you are forced to put all your flags in one place (the flag package allows libraries to be customizable via flags too) and c) you need to pull in an extra dependency which offsets a) again.
There are trade-offs between the languages, as you might expect. Jerf and I have discussed this before. Jerf has the opinion expressed above, while I have been very happy doing scientific Go the last few years. It is definitely true that you can have all of the operators you want in Julia https://github.com/JuliaLang/julia/blob/master/src/julia-parser.scm . At least, I very much hope that's all the operators you could want. 
Looking forward to read it!
Copy will arrive tomorrow - stoked to get it. Same as the others, I'll happily post a review once I've read it.
Hi thanks for this contribution. I didn't do it, not to 'complexify' too much the fragment. In the C++ Boost lib. the barrier implementation actually specifies 'returns' as: "Exactly one of the N threads will receive a return value of true, the others will receive a value of false. Precisely which thread receives the return value of true will be implementation-defined. Applications can use this value to designate one thread as a leader that will take a certain action, and the other threads emerging from the barrier can wait for that action to take place". The JAVA jdk/openjdk/6-b14/java/util/concurrent/, for one await(long timeout, TimeUnit unit) 'returns' a bool: "true if one or more parties broke out of this barrier due to interruption or timeout since construction or the last reset, or a barrier action failed due to an exception; false otherwise". Since I did not present interruptions, broken situations or timeout in this gofragments, I did not introduce any return. But your remark and example can be a good introduction to a complementary presentation. So, I am ok to add your example in the comments of this gofragments.net, in preparation of a more detailed one. If it is ok with you. Ok?
It's only common sense if you are used to Go, it's not common sense for someone that comes from language X or Y and starting with Go. In some languages it would actually be an horrible peace of code.
How is that not an API?
Eh, you've got subcommands decently covered. All the subcommands I've seen require you to pass the subcommand unconditionally as the first parameter. It would be easy to write code to switch the struct passed to Parse based on the first value. I don't mean you need to include it in your code, I mean, your API is already easy to use that way.
[**@alex_zolotov**](https://twitter.com/alex_zolotov): &gt;[2015-11-03 18:08:11 UTC](https://twitter.com/alex_zolotov/status/661605810661949440) &gt;We’ve published Go plugin for JetBrains IDEs. Now it can be easily installed from official repo. [*plugins.jetbrains.com*](https://plugins.jetbrains.com/plugin/5047) [#golang](https://twitter.com/search?q=%23golang) ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3remc8%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Preordered a copy like two weeks ago from a mayor dutch retailer, it will ship this week and I'll get a chance to read the book 2 weeks from now. A review will be out in like 4 weeks from now. I'm quite excited for this book, I'll hand it down to a few of my non Go using friends afterwards.
Sent you an email, I'd definitely be interested.
Well, since I started this thread I might as well explain why I like go and would consider using it even for maths and science. Basically it boils down to go having a very nice combination of type safety, simple control flow constructs, memory management and easy tools for parsing text. Most other languages have harsh tradofs. C/C++ are absolute monsters with manual memory management and string handling is a nightmare. Java and derivatives require the runtime environment, which can easily result in incompatible dependencies between versions. Python, Perl and many other interpreted languages lack type safety. Haskell is nice, until you need some kind of control flow, or try to understand something written by another programmer, or even yourself from a while ago. There are lots of other examples, but it is the same theme. Go is somewhat unique in that it seems to only used tried and tested features that are known to work well together. Thus I can understand reluctance to support too much genericism and high level features. The last thing you want is something akin to the C++ macro and template system, which leys you redefine the entire language. Ironically infix function calls would be almost the polar opposite to C++ , since it is one of the few things it will NOT let you do. In C++ custom operators MUST be modified versions of the ones built into the language, which is the exact opposite of sensible, and I suspect it is part of why so many people are hostile to the very notion of custom operators. Contrast it to simple allowing binary functions to be called with an infix notation, which automatically forces custom operator names to be alphanumeric identifiers, and prevents shenanigans like redefining the meaning of assignments or pointer dereferencing. Like I said, I understand that it is not a priority and why one might wish to keep the language simple, but it sure is not a C++ feature. In fact, C++ wont allow you to do it unless you seriously abuse the macro and/or template system. 
Of course, it's OK.
&gt; With that said, people should be expected to be in control of their emotions to a large extent. This isn't a reasonable expectation, especially as most of these things happen subconsciously (I really suggest reading up on recent science regarding this. There are very simple experiments that conclusively find these subconscious biases and their significant effects). &gt; I think on topics of say, verbal harassment, it should simply be decided on the spot and the public are decent enough at handling such incidents through reacting negatively to a verbal aggressor. It has been empirically proven (time and time again) that this is not the case. People usually don't speak up and if they do, it will usually not lead to a change of behavior but to discussions and anger that makes everyone even more uncomfortable. A formal process is much more effective. &gt; I mention this because a core of Dutch culture you will notice is their directness Directness is not the same as offensiveness or insults. You can be very direct, without being insulting at all and you can be very insulting without being direct. The two are completely orthogonal concepts. These arguments have come up a lot of times already (examples are the discussion that lead to the decision that the go community needs a CoC and the always returning debates about insults on the LKML) and are unconvincing. I am very direct (as noted by a lot of my friends). But I still try not to be insulting. I wouldn't consider Linus Torvalds direct at all (his rants usually take quite a lot more space and time than a simple direct response) but he certainly is insulting. Directness vs. Politeness is a false dichotomy. &gt; saying something, anything, is not doing anything wrong. If that's your feeling, you are a very significant deviation from the median. For the vast majority of people (I'd claim ≫ 90%) it matters a *lot* what and how you speak to them in their everyday interactions. If they are treated rudely in a supermarket or a restaurant they will stop going there. If someone yells at them in the street they will make a harsh judgement. And it has been thoroughly proven, that there subconscious effects of far more subtle cues. You may really not care what and how people talk to you, but most people do and I strongly believe we should use the statistical majority to guide our decisions of what conduct is acceptable. &gt; That depends a lot on the CoC and how it's actually implemented. Well, we have a specific implementation for a specific community to talk about. I can state with confidence that my statements apply for this case, i.e. I am very sure about the intentions of the proponents and the abilities of the people in charge to handle this appropriately. Specifically, I talked to Andrew on various occasions and he has my utmost respect both on a technical and on a personal level. &gt; I do not consider people using insults as an attack. If they were screaming into your ear in person or if they were blocking your path or physically obstructing/hitting you, that would be an attack that I'm talking about. Insulting you is not resulting in an obstruction of your free speech or physical movement though, it's just resulting in well, some people's brains processing of something probably rather un-constructive to the topic as they read it. Your definition is *far* too narrow and disagrees with the definition of abuse of the laws of pretty much every country I know of. Violence isn't only physical in nature and indeed the more damaging kind of abuse is purely psychological. Wounds heal easier than the human psyche. Again, while you might not consider it violence when it happens to you and that is your good right and privilege, the vast majority of people in the world do consider verbal abuse as violence and I consider the 90th percentile a better gauge for guiding behavior. In Germany (I use this example, as I am familiar with it, not because it's special), safety from psychological harm is considered so important, that it is the most basic human right from which every other is derived. Article 1 of the German constitution states "Human dignity shall be inviolable. To respect and protect it shall be the duty of all state authority." And I believe *this* is the core of our disagreement: I consider the human psyche as a real thing with real implications, while a lot of people in this thread seem to reject the idea and consider human live as a purely mechanical act of logical derivations (and as a Mathematician I value logical derivations very much). But at the end of the day, my personal experience is all I have and am certain of, so rejecting that doesn't only go counter my definition of meaning of living, but also against empirical evidence, which has proven time and time again that humans are *not* purely rational, but indeed very messy, very illogical and that trying to assume differently and base your actions on it will lead to objectively bad outcomes (that's the reason why we don't have free markets nor communism anymore and it's the reason why you don't have to work 16 hours a day). &gt; I wouldn't say I'm an outright CoC opponent, I just think it's all rather unnecessary to take the time to implement one with a list of rules and guidelines etc which everyone must read and follow. I consider your actions incompatible with your views then. You have zero work with the CoC and could just have it happen, unnecessary or not. Instead you are spending your time arguing against it on the internet, which to me is rather strong evidence that you are indeed opposed to it. &gt; Why does an event need a specific CoC outlined to everyone, when for the vast majority of people, we walk around and interact on a daily basis in the world outside of the event with no CoC (besides laws which also affect the event you are in) and it's fine? Well, there are lots of reasons. I give you three: First, the go community for a lot of people, is a place of work, not a place of leisure, so they can't simply remove themselves from it (while at the supermarket or in the bus you are perfectly free to avoid nasty people and situations and won't suffer serious consequences). That's the reason why *any* sufficiently big company has a Code of Conduct and why you have special (legal) protections from harassment while at work. Secondly, the distribution of population differs very much. For example, in your everyday life you will interact pretty much exactly with 50% women (I chose this as it is the most universally true, independent of country and culture), while if you are in the IT community there is a very strong imbalance (I think around 20% women is considered very inclusive relatively to the IT industry as a whole. But don't quote me on that number). So the communities we are talking about have a much greater imbalance of power and representation for minorities than the society as a whole, so they also have a greater responsibility of protecting said minorities. And thirdly, the laws, as state-imposed rules, have a very high bar for necessity, effectiveness and commensurability because the state has the monopoly on power, so constitutional checks are in place to protect the population from abuse of such power (that is, why the state is not allowed to prevent you from speaking your opinion, while a radio station can refuse to let you on air). As a consequence, laws don't define an optimal situation, but instead only set the absolute lower bar necessary to guarantee a functioning society. So it makes perfect sense, as a community, to commit to *stronger* rules, than the absolute lower bar to make explicit that they want to be inclusive not because they have to, but because they chose to. As the go community has no monopoly on power, they also have more freedom to set the bar higher. That, by the way, is what's meant by the alt-text of the famous [free-speech xkcd](https://xkcd.com/1357/). "What I do isn't illegal" is a very low bar to set for yourself.
&gt; Do you mind expanding on what you mean by "workflow"? I mean your personal process, choice of libraries, how you like Go better than the alternatives you used before (if any) because X, Y, and Z, etc. waveswan's post resembles a lot what I mean, except you have experience. &gt; Why do you say Go is a bad language for parallelism? I agree it has problems with SIMD. [This happens to be the first response on Google](http://blog.golang.org/concurrency-is-not-parallelism), but the idea goes beyond the Go community. People draw a sharp distinction between "concurrency", doing many heterogeneous things at the same time, and "paralellism", doing the same thing to many different bits of data at the same time. I personally find the distinction somewhat overblown; the tools for concurrency often turn out to be easy to turn to parallelism, making the boundary less sharp than some people like to say. But it is true that Go is really good at concurrency and has basically _no_ support for parallelism. SIMD, as you mention, is basically the opening bid, but there's also GPUs, moving data across clusters, all sorts of other things. Having nice goroutines isn't unique enough, especially when a lot of scientific computing is perfectly happy with straight-up OS threads. Again, excepting perhaps massive agent-based systems, why do you need _millions_ of threads? If you're good with "one or two per CPU", a ton of other languages have you covered. (And to be clear, there's a lot of middle ground there; modern OSes are happier at much higher numbers of threads nowadays.) &gt; but I don't see how the fundamentals of Go are bad relative to other languages They aren't "bad" in the way that I wouldn't want to write this in Perl or Python without numpy bindings, in which you'd be stuck in a single-threaded world with terrible performance, but I don't see how they are _good_. You get no operator overloading, the libraries aren't there, etc. The fact that all these problems are solvable, IMHO, is beaten by the fact they are already solved (or, at least, _more_ solved) in other languages, which also have better communities and momentum. &gt; If someone could design an efficient "shared memory" cluster, Well, the wheel turns, but right now it's turning the other direction; NUMA means local computers work more like clusters. You can't dodge the fact that a different computer is probably at least 10 nanoseconds away at the absolute minimum, and can easily be hundreds of nanoseconds away, by sheer physics. That said, this is all just in reply to your questions. I'd still be interested in hearing what you do.
You should double-check Julia, but bear in mind I'm recommending it based on hear-say, not personal experience. At the moment Go's most likely big problem for you is that it only exposes a model of the computer with no SIMD, no great support for GPUs, etc. It'll outrun naive Python handily, but it'll get creamed by anything you can write that can use SIMD or GPUs (ironically, including numpy)... if your needs fit into those paradigms. If you for some reason really can't do better than a very 2000-ish model of what arithmetic a computer can do because of lots of branching or something, then Go is a good fit. (No sarcasm. I can imagine such tasks.)
I am a bit surprised that the first slice prints as "foo". Does append only modify the data in the underlying array, without updating the size of the slice? I guess it kinda makes sense since the slice is passed by value. Is that essentially a performance optimization? It would seem to make more sense to pass the slice by reference, but I guess that would result in a lot of pointer dereferencing in the implementation.
Okay yeah it's an api :). But it's only one function with one parameter, and compared to the flag package, or something like codegangsta CLI, most of the work is done by defining the struct.
I still don't understand the emphasis on " 'no' support for parallelism". Take your concurrent program. If you're running Go 1.4 or earlier set runtime.GOMAXPROCS(runtime.NumCPU()). If you're on Go 1.5 your program is already running parallel. Just today I took a Monte Carlo simulation and made in parallel in 30 seconds. Granted, I already knew how to do it, and my function was coded without shared state (good practice anyway), but still, I easily moved from 100% CPU usage to 800% CPU usage. GPU support doesn't exist at the moment, but I have called cudaBLAS from Go. I didn't turn it into a full interface that can be used with gonum/blas (partly because I don't have a GPU to test), but once done it can be swapped in as the BLAS library. For one task, you rarely need millions of cores. Monte Carlo can of course use them, but it's not necessary. Where this is important is the interaction of tasks. The proposed quadrature library for gonum allows parallel computation of the function at the quadrature points. Should you execute in parallel? In general it would be great, but what if the function is the norm of the gradient, estimated with finite difference? Gonum also allows finite difference to be executed concurrently. What if the finite-differenced function calls matrix multiplication, which is also coded to be parallel using goroutines. Since goroutines are cheap, this multiplicity is much less relevant than it is with threads. Library designers can use the parallism that is best for them without needing to worry about potential whole-program effects. I don't understand your comment about NUMA. To me the fact that computers are getting more like clusters means that we should be moving toward one programming paradigm (shared vs. not) rather than having competing models. Libraries not being there is fair, though a lot of the support is wrapping a set of C functions which Go makes easy. Obviously this depends on what you do. The reasons why Go is good are the general reasons to like Go. It's a simple composable language that makes writing reusable and readable code easy. A compiler not only catches bugs early, but additionally helps legibility and speed. It's got great tools for testing, profiling, benchmarking, race detecting, and documentation. 
A "required arg" shouldn't be a flag at all. It should be a positional argument (otherwise you are forcing your users to type it's name every time they use your program for no good reason at all). And it's much simpler to write foo := flag.String("foo", "default value", "help message") Tada :) 
It's more that I rarely do anything where raw performance even matters that much. Typical use case is things like grabbing data from a multi-channel detector, some random document, that XML file somebody else published their data in.. and then convert it into something which can be fed through the actual algorithm. Longest run time I've had so far was a few minutes, and given that it can easily take hours to fix some random bug, I care much more about being able to write comprehensible and somewhat reliable code. Go seems really nice in this regard. You can easily write imperative code. It is garbage collected. The standard string and regexp libraries make parsing simple, and the type system seems solid. Also, I can live without operators. Just seemed like a nice feature to have, but it is hardly a make or break thing. 
&gt; It would be better to pass in the task ID in explicitly (like the name). Similarly, the if cyBarrier.count == 1 condition is racy. As suggested by velco, it would be better for Awaiting to return a bool or the generation number or something. OK seen the race. Should have built with -race. I have modified the gofragment and no unsafe access to .count exist anymore. Thanks for the alert. **Building a 'concurrent' go program not using the '-race' option ... is criminal** :) 
Here is a similar one for JSON: https://godoc.org/github.com/str1ngs/jflect I like your approach better though, jflect makes nested anonymous structs which is very annoying sometimes ((&gt;_&lt;))
So how do I change my .go files into .exe?
Exactly my point. 
Hmmm, I venture you're not a programmer. (How did you get put into a situation where you need to run .go files?) You need to [install Go](https://golang.org/dl/) and then use cmd.exe with one of these: `go build` or `go run` or `go install`. This converts them to a .exe file.
Current master supports Google Cloud Storage as well, supports both signature v2 and signature v4. Known to work with all other S3 compatible object storage solutions. 
https://golang.org/doc/install
You might want to decide whether or not you want to be a programmer first. 
They aren't mutually exclusive. If you never want to do y = append(x, ...), then why would the authors have made it return a value rather than just having append(x, ...) modify x. Think about it.
Tons of questions here. Most of it relates to capacity, not length. And yes, capacity is a performance optimization of sorts. Capacity is automatically incremented on every append. If it weren't, every append would need to grab a new block of memory for the new array. In the example, []byte("foo") is created with 32 capacity. In real world scenarios, people often create a slice, then in a loop check for something and if true, append to the slice. Imagine a list of 10,000 domain names, and you only want the ones that end in .com. So you create a []string{}, and in a loop check that strings.HasSuffix(domain, ".com"), and if so, append it to your []string{}. If 9,000 of them have this suffix, then this would mean 9000 different array allocations underneath if you only increment the capacity by one each time. By autoincrementing capacity say, 2-fold, on each needed increase, you'd only have 14 allocations vs 9000. I can't be bothered to check the actual formula, but know that one exists that works something like that.
&gt; I really suggest reading up on recent science regarding this. Could you point me towards some papers? &gt; Directness is not the same as offensiveness or insults. I agree. I'm talking about not having to think about what I say for fear of offending someone. This is a direct infringement on my freedom of speech, is it not? I simply cannot comprehend how I can be involved in a discussion, then you say that you find what I said offensive and expect me to apologise? This concept literally does not make sense to me. You are in fact saying that I have committed a wrong act by speaking openly about a topic. This is a true attack on my right to speak freely, how can you not see that? &gt; Your definition is far too narrow and disagrees with the definition of abuse of the laws of pretty much every country I know of. I don't know of any 1st world country that punishes people for insulting or talking about something that some find offensive. &gt; "What I do isn't illegal" is a very low bar to set for yourself. Which is why laws have nothing to do with the bars I set myself. My bars are set based on rationality derived from evidence and logical thought.
build is "compiling" source code (.go files) are "compiled" by a compiler program into machine language (byte code .exe) so use compiler to build them, go has a go language compiler try asking irc, #go-nuts ... and just start at the beginning "i need to compile .go files". the guys from irc are really smart
Same here. Preordered it at the first day it was announced, and currently waiting for amazon germany to ship it
$9 to Sweden as well
How is it different to any other typical Go-related success story? Productivity, people picking up Go straight away, aaaaand that's it? How is their experience different to what I'd been reading for a last couple of months already? For some reason ppl think you must hype Go for hype. Well, you shouldn't. Instead, hype it for great things and how it's different.
These days,I'm working on the json parsing.But I found a terrible problem that json's Unmarshal() isn't supporting the "&gt;" style tags like xml.So if you are using json,you have to use nesting style.
A lot of written text but nothing really said. Would be cool if an engineer actually could rewrite it...
They're called methods. Instead of "A .myCustomOperator. B" you write "A.myCustomOperator(B)"
@bmatsuo - Thanks. please test and give us feedback at https://github.com/minio/mc :-) . Any pull requests are always welcome. 
An interface means 'anything that has x in it'. So, an interface with no elements (interface{}) means 'anything', because any type 'has nothing' in them. As for which one is better, it's always best practice to explicitly ask for the type you want (i.e. string), except for when you could accept anything, or several types that match conditions. Then you should use interface. [excuse bad formatting or poor explanation, typing quickly on my phone!]
It works because you can think of `interface{}` as the base type for all other types (from simple types such as `string` or `bool`, to complex ones that you create yourself). The fact that the method works in the example is because the author knows that they are passing in a string type, even if it's being transformed to it's most basic type, and therefore they know the equality check with `item.CodeHash` will work (as that's a `string`). The more complex your program gets, the more chances there are for functions like this to come back and bite you with various bugs. Swapping `interface{}` for `string` is much better, and much more explicit. That way, if you write code that sends in a bool or another type into the function, the compiler will refuse to compile the code and you'll be able to fix your mistake. While that function has `interface{}` as the param type, the chances are you could pass in a `bool` or other type and not know that it's always going to fail silently.
In his examples, it works with string because he's using it with strings. As an interface, it could also accept other types. Generally speaking, if you're only using it with strings, it's much more clear to replace the interface type with a string type. If you're trying to make it worth with multiple types, the interface starts to make sense.
name `mc` is already used by other popular binary https://www.midnight-commander.org/
*Microagression, sir!* Seriously, you ought to cool your ass off a little bit, mate. I can't see a single point of the article if it's not useful. We all already know that Go is amazing for production sort of stuff and people don't struggle while learning it. Sharing experience makes sense only for unique experience, otherwise it's all about copy-pasting the same old story, again again again.
Yeah its not useful... *for you*. Nor was it for me. But for others, who haven't come across such success stories or for people switching jobs, it would be. Is it a hard concept to understand that others can find value in something that you can't?
&gt; Fairy Careful, your bias is showing. Although wait, you're a ["go lover"](https://medium.com/@tucnak/why-go-is-a-poorly-designed-language-1cc04e5daf2) aren't you? Make up your mind on that one soon. I have already conceded there are articles similar to this one on the internet. Nevertheless, the CockroachDB people can write one if they so wish. They still need to attract Go devs, remember.
Excellent! I was really annoyed by the warning message with the locally built version I had installed.
I've read that article before, therefore the idea for static binaries. I could always automate something like that in production, but what about local development? More importantly, why single repo? I want to keep development of each service decoupled from the other. Since they are, in fact, decoupled. And working with many feature branches on a single repo is not a way to go.
Hi. The function containsCodeHash(items PlaygroundItems, elem interface{}) (bool, int) has 2 input parameters and returns 2 others. the 2nd input parameter 'elem' is of type: 'interface{}'. An interface is two things: it is a set of methods, but it is also a type. The interface{} type is the interface that has no methods. At runtime, since all values have exactly one type, the go runtime will do a conversion automatically. "Interface in Go are pure 'behaviour'..." dixit D.Cheney. Here elem will behave as a 'string'... :) Go specification indicates that bools, ints, floats, complex numbers, strings, pointers, channels, structs, and interfaces are comparable. See the 2 articles to read about interfaces: http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go and for detail about the implementation: http://research.swtch.com/interfaces 
Damn, I'm working on the exact same thing, maybe a little thiner: https://github.com/ory-am/hydra
&gt; I still don't understand the emphasis on " 'no' support for parallelism". Well, bear in mind I'm sort of explaining the opinion of others, because I'm actually mostly on your side. :) Personally I just see it all as a continuum, rather than black &amp; white. At the "most parallel", you have SIMD, which is parallel at the clock cycle scale. SIMD is useless if you can't feed the CPU 4/8/16 numbers per cycle with some frequency. GPUs are slightly coarser. They run programs, but ideally very small ones, and AFAIK it's normal for the programs to themselves be run in lockstep across all the cores, just operating on different data. The grain of parallelism is several clock cycles in your GPU (which is generally clocked much slower than a CPU). Then you start getting into "conventional" CPU-land, which can do "many things" at a time in multiple cores and they aren't particularly bound to finishing at the same time. You can do things like draw work off of a queue, which is basically meainingless for SIMD and not efficient for a GPU. And within CPU land, you have to distinguish between having lots of little tasks to do where context switching is a dominant expense if you're not careful, and whether you care deeply about L1 cache, finally ending up on the "most concurrent" side where you're firing threads to do work where the context switch is so small compared to your task that you no longer care about it and you're unconcerned about cache (i.e., IO bound tasks). Some people like to try to find sharp lines to draw in there. Personally I see at least two distinct sharp lines, between CPU &amp; not CPU and between "context switching is expensive" and "I don't care about context switching", but I'd still rather just see it as a continuum. Obviously, real life work will mix and match as needed, blurring the lines even more. Is an algorithm "parallel" or "concurrent" if you fire 16 threads doing mostly unrelated things, but 12% of their runtime is being accelerated by SIMD? Well... _who cares!_ The question is what's the best way to get the job done, right? Go's support at the parallel end is weak. (I don't consider binding to BLAS all that impressive, because anything can. That's not a "Go feature", that's a base state of all current languages.) Go's support at the concurrent end is very strong. Of course, if the concurrent end is what you really need, well, yes, Go's a good choice. By the way, just to be clear, I'm hashing this out with you because I think there's ground for making a clear and helpful blog post to others considering Go for scientific computation that is clear about its strengths and weaknesses, which I think is helpful for everybody. It makes me sad when I see somebody pick something up for the wrong reasons, and only discover months later they've made a mistake, and I don't mean "picking up Go" is a mistake... it's a mistake to pick up a heavily-math-optimized framework if what you really wanted is something Go is better at too, it works both ways! And I'm definitely developing more nuance here in my opinions as we discuss this; you are having an effect. &gt; I don't understand your comment about NUMA. To me the fact that computers are getting more like clusters means that we should be moving toward one programming paradigm (shared vs. not) rather than having competing models. Actually, I ___strongly___ agree. As a "conventional" programmer, it is one of my personal pet beliefs that our computing paradigms are unduly hobbled by a worldview in which the CPU must present a "C compatible" view of the world to us. I don't mean "imperative" vs. "functional" or something, I mean things like whether the memory space is uniform (it wasn't for a long time, then it was, now it isn't again), or the way you can't easily say "I want an array of structs, sliced column-wise instead of row-wise" (i.e., if you have a struct S with A, B, and C, and you want to add all the Bs, you'd rather have S[5] packed as AAAAABBBBBCCCCC instead of the current ABCABCABCABCABC, and there's just no reason you should have to do that by hand when it's _so easy_ for the compiler to do it!), and just all kinds of little things like that, where we've got this really quite powerful workhorse of a CPU, presenting itself as a glorified PDP-11 CPU. A lot of programming languages are designed not to run on CPUs, but to run on C. Go is, frankly, still one of them. Which doesn't make it especially bad, because almost everything else is too. Go is in fact being exotic just by having its N-of-M green threads.
It depends. If you are the only developer working on it, single repo is best. But if the project is large and has dedicated team for ui and server, its good idea to split them up into two repos and ui guys should compile and push updated go-bindata file to the server repo, whenever ui changes. While server team is totally focused on backend part. I usually use single repo with two folders - server and ui, for backend and frontend. I use react for frontend.
Thnx everyone
Do you have a repository somewhere? I am interested. I am the author of hero here.
Yeah looking at what you just wrote there, it is no surprise to me that no one wants to write Haskell. Isn't it better to have the code be nearly readable in english. Even if everyone knew haskell. Why would you choose to have to think about what you're reading every time you go through it.
Out of curiosity, what does that code do?
To which warning message are you referring to? I'm not aware of any but I might be mistaken. Thanks
But it does return a new value. A slice is more or less a struct with a length field and a sized array. When you append, a new 'struct' aka slice is returned. It's the inner array that doesn't always change.
Actually, I kinda disagree with most of the explanations here. This isn't about interfaces _qua_ interfaces. This is about how `==` works, which is [sort of complicated](https://golang.org/ref/spec#Comparison_operators). When `elem` is a string, you are comparing string to string, and thus you hit the * String values are comparable and ordered, lexically byte-wise. clause, which means that two strings are `==` if they are byte-wise identical. Normal stuff. When you set `elem` to `interface{}`, you are comparing a `string` to an `interface{}`. That means you hit this clause: * A value `x` of non-interface type `X` and a value `t` of interface type `T` are comparable when values of type `X` are comparable and `X` implements `T`. They are equal if `t`'s dynamic type is identical to `X` and `t`'s dynamic value is equal to `x`. That's a mouthful. Let's specialize the variables to this specific case: * A value `item.CodeHash` of non-interface type `string` and a value `elem` of interface type `interface{}` are comparable when values of type `string` are comparable and `string` implements `interface{}`. They are equal if `elem`'s dynamic type is identical to `string` and `elem`'s dynamic value is equal to `item.CodeHash`. So: * values of type `string` are comparable (see previous quoted clause) * `string` does indeed implement `interface{}`, since everything does * `elem`s type is indeed string, "behind" the `interface{}` * and the two strings are equal (or not as the case may be) Therefore it works either way. However there can be a runtime difference as the `string == interface{}` has more work to do, exactly as the additional text implies, if the compiler can't figure out to optimize it away. (Whether it does in this case I have no idea; you can check it yourself by [profiling](http://blog.golang.org/profiling-go-programs).) 
The author states that Go is "objectively poorly designed" and then goes on enumerating subjective reasons. Yet later he wonders that Go is popular and many serious project are written in Go. That is actually objective proof that Go is well enough designed to be practical and attractive to developers. Learning functional language is beneficial to anyone making a serious career in programming. Whether Haskell is "it" I do not know. Perhaps some hybrid language with functional elements would be easier to learn yet educational. Anyway, kudos to author of the article for persevering and getting to know Haskell well. 
&gt; Well, bear in mind I'm sort of explaining the opinion of others Please do. I'm all in favor of good discussion about the merits of the language. On a side note, do you have any theories of why reddit hates Go so much more than hacker news does? I would have thought the communities would be more similar than different. &gt; Discussion of parallel continuum First, I think we can both agree that SIMD is orthogonal to the rest of the continuum. It would be a huge boost were go to be able to add SIMD. The new SSA compiler should move in that direction, and the compiler now uses AVX2 in certain places (runtime and copy()). It's not clear what happens beyond that. As you say, scientific computing isn't a first class use case, but I also think the Go team is sympathetic to the concerns (based on things they've said). We'll see. In short, SIMD is always better if you can get it, and hopefully Go is going in that direction. A point in favor of Go is that async is a quite powerful concept, even in numeric parallelism. Even code that should take the same amount of time typically doesn't. If you're in strictly parallel (using MPI_BARRIER or whatever for communication), you have to wait for the slowest task to finish before getting the next batch. With async, each core can get started on the next task independent of the completion of others. I haven't done the benchmarks, but it seems to me like async clearly scales better as the number of cores grows. Go makes async coding very easy and clean with workers and channels. I can see it in my own Monte Carlo simulations -- the processors start off in lock step, but a couple iterations in and they are no longer aligned. Monte Carlo simulations are an obvious case, but matrix multiply also fits into this paradigm reasonably well. &gt; Some people like to try to find sharp lines to draw in there. People find the sharp line because there is a significant coding gap between CPUs and GPUs. It's been shifting in the last 5 years, but the people I know that use GPUs for scientific simulations structure their programs so they can make lots of BLAS calls on the GPU, and run the higher-level logic on a CPU. I imagine the google/baidu speech recognition algorithms do something much more elaborate, but there I would also imagine they spent a lot of time writing CUDA, and then created a c interface to those calls. I definitely agree with you that the lines should become more blurred. One of the things that has been continuously parroted to me about GPUs is the need to break into many small tasks. Goroutines seem well equipped for that. I don't see the Go team making that happen anytime soon, but I could see an outside vendor trying. With things like the Knights Landing chip the world is already blending, and goroutines should be able to capitalize. &gt; And within CPU land, you have to distinguish between having lots of little tasks to do where context switching is a dominant expense if you're not careful, and whether you care deeply about L1 cache A lot of this depends on how much effort you're willing to put in. Run our gonum benchmarks for dot product relative to OpenBLAS (or MKL or whatever). For small vector sizes, using the Go dot product is faster than calling into C because of the overhead. For medium vector sizes, C is significantly faster (2-4x) because of no bounds checks and the extra SIMD. For large vector sizes (&gt;10000 if I remember correctly), pure Go and C are the same speed again because of cache misses. The point being that even relative to highly optimized assembly implementations (called through C), Go is just as fast for many useful problems. It is possible to put in a lot of work to improve that, but without the extra 10x effort you get 90% of the speed in many cases. &gt; I don't consider binding to BLAS all that impressive, because anything can Yep, agreed. &gt; Go's support at the parallel end is weak. What do you consider to be good languages for parallelism that are also suitable for scientific programming? As mentioned above, C can call into GPUs, but largely through code implemented outside the language which Go can use just as easily through cgo. Matlab/python and I imagine R are not good with parallel computing. Julia seems to be taking the "do everything" approach, which is possibly useful but I am worried about the layers and layers of complexity they are adding to the language. &gt; Obviously, real life work will mix and match as needed, blurring the lines even more This is definitely the difficulty. If all you want to do is perform a matrix multiplication, buy a GPU and run CudaBLAS. Sadly, I want to do a variety of operations, half of which are lapack calls, and the other have which are not. I really like that it's easy to write fast Go code without effort to accomplish the other half of these tasks (unlike matlab/python where fast code takes much more effort than simple code). In addition, the simplicity and composibility of Go is a huge strength when seeking to mix and match different behaviors and concepts. This is a side issue to Go being strong or weak at parallelism, but it's a very important piece of the story, and worth sacrificing that last 10% of performance for in my opinion. &gt; By the way, just to be clear, I'm hashing this out with you because I think there's ground for making a clear and helpful blog post to others considering Go for scientific computation that is clear about its strengths and weaknesses, which I think is helpful for everybody. Agreed. Among the reasons I'm engaging is that I don't yet see your argument as to why Go isn't great at parallelism, assuming you mean relative to other extant options (if your argument is that an even better language could exist, that's interesting to think about to address your issues). You linked "Concurrency is not parallelism" earlier, and I agree with Rob Pike's quote in the actual talk, which was "concurrency is not parallelism, but it certainly enables it". You seem to disagree with this assertation (or at least think it's not sufficiently realistic). &gt; and there's just no reason you should have to do that by hand when it's so easy for the compiler to do it! It's actually not that simple. It is easy for the compiler to rearrange the memory, but it's not easy for the compiler to rearrange all the algorithms below it. If you look at matrix multiplication, the loops in gonum/blas/native are ordered differently than the netlib standard blas ones because of the row/column major difference. It feels nice to be able to have the orders be different, but really what this does is double the code size for everyone as they'll have to write two versions of their algorithm, one for row major and one for column major. This is the sort of thing where simplicity trumps ease. You make some unhappy because they need to transpose how they think of their data, but you make the ecosystem happy by fixing on a standard. 
I must be one of the few people who love both Haskell and Go (for completely different reasons). The author has a point about Haskell's massive learning curve, though.
I'm curious why you don't like list comprehensions. As a Haskell newbie, virtually *everything* I write is some form of a list comprehension.
That is long tradition of Haskell programmers
Trying to figure out how to do vendoring (place dependencies into "vendor" subfolder of the project). Tried to add vendor as a module or as a library and it would not resolve imports in either case. A-ha, it's not implemented yet: https://github.com/go-lang-plugin-org/go-lang-idea-plugin/issues/1820.
&gt; Learning functional language is beneficial to anyone making a serious career in programming. I disagree. I have a serious career in programing and I can say that learning OCaml and Haskell was nice research (hey, never thought you could do this this way). But at the end of the day benefits compared to procedural languages were non existent while many things simple to solve in Go, C, or Java are too complex to make in most functional languages. I don't think functional languages are made for real life problem solving but as an experiment by academia.
Why do you have resp as a global var? If you do any kind of concurrency, this is going to create issues (https://github.com/Marmeladenbrot/Crawler/blob/master/src/crawler/crawl.go#L9)
It was not my intent to come across as such. I hope godep, glide, and other vendoring tools can all work together to be generally useful and interoperable. If the author of the post had in the post, or historically pointed to other state of the art go tools (godep, others) and say, "hey, now we are doing this too". I would not make the above post. I wanted people to be aware that what glide is now doing is both good, but also not unique. I'm sorry I came across as snotty.
As far as I remember I had problems with re-declaring the variable in the loop without the global var. If I comment that out "resp" is undeclared?
And here's my take on the same thing: https://github.com/sourdoughlabs/bouncer :) 
after maxRetries unsuccessful requests, there is no body to close/parse. I thinks that's the reason because it is failing. You are doing links := collectLinks(link, resp.Body) but probably resp.Body is nil. 
But I return from the function = ending it if that happens? There shouldn't be any function call after the return? if i == maxRetries { Error.Printf("ERROR \t RESP Connection Error for workerID %d : %s : %s \n", workerID, link, err) AddErrCount() mutex.Lock() visited[link] = true mutex.Unlock() return
"I love that it makes you think. One does not simply open a text editor and start banging at the keyboard to write a Haskell program." And that right there is the opposite for me. I don't want to use languages that restrict how quickly I am able to be productive. Can't see this as a bonus. Maybe this is why it took 4 years for the OP to reach a level where they felt confident? With that said, it isn't hard to understand why Go is seeing success. Noticeable things must be built in it, for it to develop a story. 
All of those solutions look cool, really bummed out that I found them so late. it really shows the need for an open source alternative to auth0.com or oauth.io and golang is probably the best language to solve this with. i think we're all onto something here. do you guys use templates or similar or is it just restful apis?
Thanks for this answer :) I never knew you could actually compare interface-types with non-interface types :)
I found that, because they're so different, learning non-traditional languages exposes me to new techniques that I can carry over into more traditional/practical programming languages. 
Hello! Sent an email with the subject line: Go Programming Language Reddit Post. Definitely interested! 
What is gokit?
You spent four years learning a language, have nothing to show for it aside from social status and barely breaking the understanding barrier? Betting on a research language on a path that clearly does not lead to a lot of work getting done is fun, sure, I like to write me some Scheme every now and then with the same thinking behind it but I sure as hell don't lose out of the picture that when I actually want to get work done I switch to a normal language like Go / Java / C++. Haskell is sold here as if it were somehow superior, just because you add more dials and whistles and some exciting restrictions to use them in doesn't mean the much much simpler language is worse.
&gt; On a side note, do you have any theories of why reddit hates Go so much more than hacker news does? I would have thought the communities would be more similar than different. Well, not to put too fine a point on it, I think it's language snobbery. I believe it is true that there's a lot of things wrong our languages, and [I actually quite like Haskell](https://www.reddit.com/r/golang/comments/3rhlyc/language_choice_wrt_go_and_haskell/cwo6new). (I have joked that next time I go hunting for a job my resume should consist entirely of "I can make Haskell do real work." Resume mike drop.) But on the other hand, it does no good to pretend that no useful work gets done in languages that have flaws in them, and in the meantime, being aware of them means you can also combat them, which also shouldn't be ignored. Though it isn't free, either. &gt; People find the sharp line because there is a significant coding gap between CPUs and GPUs. Yes, I suppose that's true there's definitely one there, but people also try to draw lines in the pure-CPU space. Probably moreso in the "conventional programming" house. &gt; What do you consider to be good languages for parallelism that are also suitable for scientific programming? To the best of my knowledge, Haskell does not quite have all its ducks in a row, but it would actually be a great choice if it did. To the extent that you find that idea scary, it wouldn't require knowing all of Haskell; you'd carve out a subset where you learn how to load the data in, then write the manipulations you need. [They're working hard on this](http://repa.ouroborus.net/). The relevant subset of Haskell isn't necessarily that hard. It's worth keeping an eye on. The Haskell community has a history of having a really sucky solution, then a fairly sucky solution, then a sort of sucky solution, then suddenly everything just clicks and they have the best-of-breed solution that beats everything else. &gt; I really like that it's easy to write fast Go code without effort to accomplish the other half of these tasks (unlike matlab/python where fast code takes much more effort than simple code). This is where you're getting me around to changing my view; the more you're trying to do "scripting logic", the more appealing Go is. It's easier and safer than C++, and not that much slower. It's only slightly harder than Python, but _much_ faster. &gt; It is easy for the compiler to rearrange the memory, but it's not easy for the compiler to rearrange all the algorithms below it. As I'm assuming this requires a new language to implement, the algorithms would have been written with this layout in mind. I wouldn't try to retrofit it. Jonathon Blow has actually been approaching this from the games side; [he's had some demos](http://lambda-the-ultimate.org/node/5059) but I don't know what the current status is. Ironically, games and scientific programming are not entirely dissimilar, modulo the short deadlines for gaming.
"Go kit is a distributed programming toolkit for building microservices in large organizations." - http://gokit.io/
Why did he add os.Exit(0)?
the version I had built warned me that I was using a development version rather than an official build (which there wasn't) every time I started IJ
Just sent you an email. Excited to see this book!
&gt; while many things simple to solve in Go, C, or Java are too complex to make in most functional languages. I'd be interested to hear some examples! We can take it to PM if you don't want to sidetrack these comments.
It can return the empty interface{} which means it can return any type. You could then use the type switch to determine the type. https://github.com/golang/go/wiki/Switch#type-switch Alternative: type ItemInterface interface { GetItemValue() string } type Item struct { ID int CreatedAt time.Time } type URLItem struct { Item URL string } type TextItem struct { Item Text string } func (ui URLItem) GetItemValue(){ return ui.URL } func (ti TextItem) GetItemValue(){ return ti.Text } func FindItem(ID int) ItemInterface { // TODO }
&gt; Yet later he wonders that Go is popular and many serious project are written in Go. That is actually objective proof that Go is well enough designed to be practical and attractive to developers. Careful! By that logic PHP and JavaScript are well designed languages. In my opinion Go is very neat and well designed, but popularity is a very poor way to measure it.
This isn't limitation in specific area but difference between declarative and imperative programming. Functional languages try to avoid changing program state (eg. global variables) which limits program in its practicality. In simplest form, things like socket or file operations are far more complex and contra intuitive to use. In my opinion, most logical flow of program is when you follow instruction steps/statements that are executed in CPU. It doesn't matter if it is assembler, C, D, Java, Go or any other imperative language, principle is same, and that makes imperative paradigm. Functional / declarative paradigm completely changes and masks that flow. Maybe that is why it is so hard for me to follow what is going on. On the side note, that difference from statement flow may be the reason why functional languages have inferior performance to imperative ones (their execution model is different to how hardware works most efficient). 
The author listed objective Go deficiencies though.
'Learn Go the Wrong Way' ?! Interesting subtitle... 
I don't mind using lambdas here and there in my imperative programs where they can help but building purely functional programs is whole different line of thinking.
What i would like to see in Go 2 is any operator between interface and constant to be forbidden, unless constant is specified with type. So, this would be illegal var x interface{} = 10 fmt.Println(x == 10) While this will work var x interface{} = int(10) fmt.Println(x == int(10)) Of course you can always hold in mind the type defaults for constants, but this will make it more explicit IMO and will make you always remember to check the type correctness
While I do agree, I would argue that popularity is pretty good evidence that a language had what people were looking for at the time that it came out, whether that was good design or something else. In PHP's case, it billed itself as being a simple tool to do server-side scripting with, and, for all it's flaws, it *was* much easier to set up and use than many of the alternatives that were available at the time. For [JavaScript](https://www.w3.org/community/webed/wiki/A_Short_History_of_JavaScript), it was most likely because it had no real competitors if you wanted to do client-side scripting. A few million sites later, and suddenly JavaScript has quite a following. Go's case quite is a bit happier. A language which managed to take many of the most useful high-level features from a lot of other languages, such as garbage collection, maps, interfaces, variable-size arrays, and methods, without sacrificing a lot of the low-level feel and features of languages like C, while being easy enough to learn in a few hours, plus a really good standard library... Well, I think it's pretty obvious why Go is popular, actually. On a side note, all three languages have something in common: They became popular for purely practical reasons. Neat language features sound good. For example, I would really like to like Rust. But neat language features aren't enough by themselves to make a language worth using on a regular basis. Rust just doesn't have the practical features I'm looking for to back up the neat features. That and it's almost as ugly as C++. Almost. ^(Well, that was slightly more rambly than I intended.)
I'm not sure why someone would use this. What does it do that the standard library doesn't / can't do? Edit: I'm not criticising it, I'm genuinely curious.
Honestly don't see how
It looks like a bug somewhere in `net` or `net/http` - one of the readers down the chain returns `n` (number of bytes read) greater than the length of the passed slice, and that makes `bufio.Read` panic. What Go version are you using? I wasn't able to reproduce it with Go 1.5.1.
&gt; How do I attribute this port of mine to say it based on someone else's code which has a **LGPL** license? Read: https://tldrlegal.com/license/gnu-lesser-general-public-license-v3-(lgpl-3) and http://stackoverflow.com/a/481253/2967113 Basically, since it's LGPL you need to include the original, state what changes you made, disclose your source, include the LGPL, include the copyright, and include installing instructions. Some of this can be included in a README file (e.g., installation instructions and copyright notice). The license can be placed into a LICENSE file. For anything further, always consult a lawyer not random people on reddit. However, porting a game to learn a language shouldn't step on many toes provided you make an honest effort to follow the terms of the creator's license.
Depends, the Go standard library for example puts it in the file. https://golang.org/src/math/j0.go 
A good percentage of the effort (maybe 20% - 30% ) was related to getting the original QBASIC program running on my 64 bit Win10 PC for testing purposes. 
I'll be happy to write a review when Amazon eventually ships the book to me. One question though, is it necessary to request reviews at all? It makes sense for an up and coming author, but Kernighan is one of the biggest names in software. The book would have a ton of reviews up pretty soon I'm guessing.
I love reading the source for those math functions. It's amazing to see how much thought and care goes into them...
When can I give money to jetbrains for an officially supported IDE? :)
 func GetURLItems() []URLItem {} func GetTextItems() []TextItem {} resp := struct { URLItems []URLItem `json:"url_items"` TextItems []TextItem `json:"text_items"` }{ URLItems: GetURLItems(), TextItems: GetTextItems(), } jr, _ := json.Marshal(resp) w.Write(jr) 
Someone is using it or not?
i've never actually used camlistore but I stumbled upon a file called dockertest in some blog post and was quite disappointed that it didn't run on other platforms. That was the motivation behind the "fork"
I just cant agree with this statement at all. A lot of major, important IT projects are done using primarily functional programming languages - twitter being an obvious example. 
&gt; Could you point me towards some papers? I always recommend starting with [the unconscious bias at work](https://www.gv.com/lib/unconscious-bias-at-work) workshop at Google Ventures. They explain the issues quite well and the page also contains sources. &gt; I'm talking about not having to think about what I say for fear of offending someone. This is a direct infringement on my freedom of speech, is it not? There are two subtly different, but connected parts to this and I'm not sure, which one you are asking. One is the "I don't want to offend someone, so I don't say what I'm thinking" part. That clearly doesn't violate any of your rights, because it's fundamentally your choice. You are free to say what you want, you just don't. The other is the "I am forbidden to say things that I *want* to say" part. And that *also* doesn't violate your rights, because [xkcd](https://xkcd.com/1357/). You can say whatever you want, but you have to accept the consequences, that people might not like you afterwards and choose not to work with you anymore. That's a fundamental property of human nature. It is our right as a community to chose who can participate in it and profit from it and if we choose to only interact with people who we *don't* consider assholes, then you will just have to live outside of our community or choose not to be an asshole (I use "asshole" in a liberal interpretation here for simplification. Please note that there are nuances both to "levels of assholenes" and "levels of exclusion from the community"). I strongly suggest you come up with a better term instead of "free speech". I can accept that it is convenient and useful for your cause (because it is emotionally laden and a strong buzzword in the internet culture, because it is so much influenced by US culture). But it is also already reserved for scenarios that have the specific power imbalance between governments and their people. &gt; I simply cannot comprehend how I can be involved in a discussion, then you say that you find what I said offensive and expect me to apologise? This concept literally does not make sense to me. You are in fact saying that I have committed a wrong act by speaking openly about a topic. This is wrong on two parts: a) Just because I expect you to apologize doesn't mean, I necessarily think you have done something wrong, knowingly. As a crude analogue: If child A steals something from child B, it might not know that this was a wrong act. I still expect A to apologize to B, because I want it to learn that it was wrong indeed and to acknowledge the fact that it accepted that it was wrong. In that sense, I view an apology maybe as a way to admit to a *wrong*, but not necessarily as an admission of *malice*. I expect apologies for honest mistakes too. And the second axis where what you say is wrong is that you talk about a *topic*, while I talk about *what* you are saying and *how* you are saying stuff. You are free to talk about racism (the topic), but if you say that all Mexicans are rapists ("what" you say) or if you call me a cunt talking the finer points of geopolitics ("how" you say it) I do believe you did something wrong. &gt; I don't know of any 1st world country that punishes people for insulting or talking about something that some find offensive. Again, you are ever so subtly and unintentionally twisting what I'm saying :) You gave a definition of "attack" that purely involved *physical acts*. I countered by pointing out that this definition is too narrow and that indeed most countries have laws that also punish non-physical violence. Think about mobbing for example, or (some forms of) stalking. If you are unhappy with the usage of the term "violence" or "attack" for these, I am happy to substitute them. But the fact is, that most countries recognize by law, that you can cause harm to other people *without physically interacting with them*. &gt; Which is why laws have nothing to do with the bars I set myself. My bars are set based on rationality derived from evidence and logical thought. But then you are agreeing, that the laws are not enough and not a justification not to have a CoC? Because, again, the context in which I said what you responded too was you claiming, that conferences don't need a CoC, because there are already the laws which also apply to this conference.
[Image](http://imgs.xkcd.com/comics/free_speech.png) **Title:** Free Speech **Title-text:** I can't remember where I heard this, but someone once said that defending a position by citing free speech is sort of the ultimate concession; you're saying that the most compelling thing you can say for your position is that it's not literally illegal to express. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1357#Explanation) **Stats:** This comic has been referenced 2491 times, representing 2.8617% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cwp7t8r)
Sure as a developer I don't need warnings. As a data analyst I do group and count warnings and promote them to critical if the there is a spike as big as the base level, normalized to total log volume.
No argue with that. But number of projects done in imperative languages dwarfs them. 
That doesn't really prove an awful lot though does it? The explosion of OOP many years ago brought in large popularity for imperative coding Now the growth in functional language adoption is growing very fast. Apart from Go a lot of major languages, C#, Java are adopting functional aspects to their languages too
1. I suspect imperative model is easier for the most people to understand. 2. Time will tell. 3. Like I said, using functional elements in imperative language is whole different thing than building in purely functional language. 
tl;dr we need the `net/http.Handler` of logging Trying to dictate what developers should or should not do is fraught with peril. Business requirements, compliance or compatibility with existing infrastructure means that logging needs to be customized per-business and sometimes per-project. The 'smallest possible interface' for logging is a *composable interface*. We need the `net/http.Handler` / `WSGI` of logging. An interface guarantees developers can compose solutions from many compatible handlers written by different developers. This was the idea when designing `log15` (https://godoc.org/gopkg.in/inconshreveable/log15.v2#pkg-index) and it's worked pretty well. Sure, the package provides lots of different convenience handlers (just like net/http), but at its core, it's only the `log15.Handler` abstraction that needs to be in the core package and agreed upon. I (and others) have built very complex logging strategies entirely by composing around that interface.
The correct answer (IMO) lies in understanding who reads log files, in my experience that answer doesn't normally end with "a person". but usually "another program" or at the lowest level "a person using grep". This never really requires a log package that is any more complicated than http://play.golang.org/p/yTOA0eaNCH To this end it's useful to be able to send the log file through some simple rules to filter out various parts of the log as you "zoom up/down" to find the problem you're looking for. Logging errors is useful to a person who wants to see where the problem first arrived - and see breadcrumbs through the call stack if they want to, warnings are useful because the programmer has normally inserted them in parts of the code where they don't know if they should commit to an error or not - and that's normally a tell tale sign in itself
This is probably the toughest part for me, getting those concepts out of my head and writing Go code that works like Go code should work. I've spent way more time than I should trying to work out a good way to share data in a way that's concurrently safe, when the Go answer [(and they tell you this, over and over, you just have to listen and accept it)](https://blog.golang.org/share-memory-by-communicating) is to share through communication rather than sharing memory. Old habits die hard, and these habits are very very old.
One pattern that you should learn as quickly as possible is that you should put your runnable code to play.golang.org. Your code is http://play.golang.org/p/7IRDl3rmrH. Now to the code: * [Getters don't start with `Get`](https://golang.org/doc/effective_go.html#Getters). * `CreateFile(fileName string) (bool, error)` - the bool is redundant. `nil` error is enough to signify success. * Your code mostly branches off when operations are successful (ok == true), while it's more idiomatic in Go to branch when something bad happened (ok == false) since there are usually more than one thing that can go wrong. This also prevents massive `if a { if b { if c { ... }}}` kinds of situations. * I don't quite get what this code is supposed to do, but I guess it's just an exercise, so it doesn't matter. This is not how we usually go in Go however.
1: True. It should be called more sensible than GetX.. 2: Again, true. I'll ammend it. Thanks! 3: Finger exercise. :) Thank you! I adjusted accordingly. Thanks for the review!! Much appreciated.
It's still surprising to me that people seem to hate the errors in Go so much. Don't tell me they check for every possible type of exception in try-catch languages.
I've been using pointers and interfaces as infrequently as possible. They're both powerful constructs, but then so is (void *). Where Go really comes into its own for me is concurrency. Channels aren't perfect, but they're by far my favorite method for moving data between threads.
Yes, there are organizations using it in production in various capacities. No, unfortunately I cannot give more information. Read the documentation and the code and determine for yourself if it solves a problem you have.
I thought about that but haven't had the time to give better control over which images to start. Might come in the future.
If you think about traditional OO, it's really about keeping your data and the functions that operate on them together. As soon as you add "concurrently" to that statement, channels turn it on its ear. A simple example is if you have some shared state in the form of a slice. You can use a bunch of pointers and eventually add in mutexes for safe handling, but that get really complex really quickly. Alternatively, you can fire off a goroutine that receives a struct {command, data, response channel} through a channel, that owns and operates on that data, and you can freely pass around that channel wherever it needs to go with the knowledge that it will always be handled safely.
That sounds pretty damn awesome man. I'm almost at the point in effective go where concurency comes along. I eagerly await that chapter. :)
Don't learn or write GoF Patterns -- read Alexander's "Timeless Way of Building" first... GoF missed the point with regards to patterns. Otherwise, get rid of `Factory` and `GetFactory` and `Databases` and `FileSystems`, they aren't that useful.
Dave - Mad respect but this is entirely unaligned with the reality I experience with logs. First "bubble up and terminate" is not always appropriate. Bad things happen AND THEN YOU SOLDIER ON. The operation you were working on might not be performed, but the program still has other things to do. Second, warnings being "someone else's problem" is bunk. When something really goes wrong, the first thing I do is scan back from the point in the log where I KNOW something is bad, and look for warnings. Info logs are the things that are most commonly useful "mile markers". Debug logs on their own are not even sufficient. We use multiple levels of verbosity. V(2) is "normal but somewhat chatty". V(3) is "that's odd, tell me more". V(4) is "ok let's get serious about dumping state". We even have some instances of V(9) meaning "basically trace the execution of this tricky logic". Please don't get me wrong - I HATE thinking about what log-level to use. It makes code-reviews tedious and it's NEVER consistent across the codebase. But rules of thumb are often good enough. I could maybe buy that the distinction between Info and Warn is artificial. I could MAYBE even accept that the taxonomy of Info/Warn/Error/Debug is just noise, but I still think we need something like V levels. Logs are our NUMBER ONE debug tool. They need to be expressive enough.
I know it's not ideal, but can't we get rid of err handling verbosity just by using convenience fictions like "errLog(v,err) v" and "errExit(v,err) v" etc? Then the code will become: f := errLog(os.Open("somefile.txt"))
Interesting. Any plans for supporting SOAP faults? I wrote a transport for this awhile ago and have been waiting to finish my own SOAP implementation to include it into. https://github.com/kylewolfe/soaptrip
&gt; I'm started learning go not long ago and have a Java background, can someone clarify why is pointer such a good thing? Or link some articles? Go has strong support for [Value Types](https://en.wikipedia.org/wiki/Value_type). Value types are typically (but not always) allocated on the stack (or in CPU registers). Sometimes you want to manipulate the value of a variable in another function, sometimes you want a copy of it. Pointers allow you to make that distinction on your terms instead of having it forced upon you. Less values allocated on the heap means less pressure on the Garbage Collector which frequently (but not always) means more performant software that uses less memory. Pointers put more control in your hands.
There's somebody out there who will complain about everything. Personally, while I find a lot of fault with Go and I do think the error handling could be improved in some ways, after using Go fairly heavily I don't ever want to work in a language that uses exceptions for error handling again. :) Give me the error monad or give me tuples. Save exceptions for truly exceptional circumstances (i.e. stack overflow or out of memory).
Java objects are basically pointers - when you pass them to functions, you're basically passing a note that says "the data you want lives at this address" and then the callee needs to trudge over there and get it before she can use it. In contrast, Java ints and other primitives are passed by-value, which is just "not pointer" in other C-style languages - it's just a note containing "4", and the callee can use it right away. But if she changes the 4 on the note, the message sender isn't gonna notice it. Basically - Java papers over the distinction and tries to use sensible defaults. Go doesn't pretend that objects (structs) are special, and lets you pass them by value or by reference, same as any other type.
Yes, you can do that but you'll have to write a lot of special case functions. Because Go lacks generics you'll have to write a larger set of functions to handle all the possible return cases (or use runtime casting, which I strongly advise against in this case). Personally, I'd just stick with the if statements. They aren't that bad. Your brain is good at picking out repeat patterns and eventually they will melt into the background as "just something you have to do in Golang." Your brain will adjust and you won't have to spend a lot of brainpower on them when reading code.
&gt; There's still racy access to .count in the if statement: if cyBarrier.count == 1. Remember that the -race option doesn't guarantee that it catches all races, but instead that the races it catches are real races. &gt; &gt; While the access to .count for the task ID is now a memory-safe operation, it's still a race to get the correct value of .count. There's no reason why all the goroutines couldn't start up and reach the start of the for loop (and therefore all get taskID = 0) before calling .Awaiting(). What would be your implementation? And what Go tool could be used to control/prevent this type of situation (race conditions) except 'manual code/design review' ? Thanks anyway for the comment. I correct the risk of defect you pinpoint. About 'race conditions' just read this useful article by Ian Lance Taylor: here, http://www.airs.com/blog/archives/482.
&gt; But the thing is, you're equating my intellect to that of a learning child so you are being condescending. I am sorry, I didn't intend to be condescending. I tried signifying my intentions by calling it a *crude* analogy, but apparently I should have rather come up with a better one. &gt; If my opinion is that all Mexicans are racist then how can you say I'm doing something wrong by telling you that's my opinion? The opinion may be wrong but the sharing of it is not. I don't get your point. If this is your opinion (I wouldn't even call it an opinion, that gives it to much credit. If you are believing in this obviously wrong thing?), then you are a racist and I want nothing to do with you. If you are not believing in this obviously wrong thing and still claim you are, you are a troll and I want nothing to do with you. Yes, the sharing is not the wrong thing, but it implies a wrong thing. &gt; It is in fact the sharing of it that allows you to debate it and change the person's mind. I have, whilst I am browsing /r/golang/ or golang-nuts, exactly zero intention of changing a racists mind. I want to talk about programming. If I want to change a racists mind, I will visit a racist subreddit (of which there are enough). So I suggest, the racist goes to an appropriate forum to spew obviously wrong things to be dissuaded there. This is what's meant, when people say, that the golang community is not a free-speech platform. It is a programming forum. &gt; Like we already established, you believe they are child-like in their thoughts and you are superior, therefore you condescendingly wish to teach them how to behave and in this case it's to shut off their opinion. I completely disagree with that statement. You may have concluded, but we haven't established. In fact, you didn't even give me an opportunity to agree or disagree with anything before claiming that we have established it. &gt; There was a time when I may have been killed for saying I don't believe in Jesus, you are coming from the perspective of being in the camp that supports that. You may not agree with being killed for it, but you, at the time, would have agreed that what I was saying is wrong and I should apologise, as according to popular belief, not believing in Jesus was absolutely unimaginable. Which is essentially the same mindset as the people who take the punishment further. Both of you don't like my opinion so you want me to be punished for it and both of you feel superior in intellect and knowledge so you believe you should have precedence over the situation. &gt; Do you see my point here? The popular opinion now is that racism is bad, which is good (in my opinion). However, I don't feel superior in intellect and/or knowledge of others who decide to voice their opinion in a discussion. If they literally say "all mexicans are rapists", I'm not going to ask them to apologise. I'll be happy that they voiced their opinion openly, regardless of how idiotic it may sound to me. Now if I am involved in the discussion I can actually discuss a core part of what's going through their mind. The way you're talking about addressing it, you are shutting off any discussion of it, which is dangerous. Shutting off discussion of it is not going to lead to progress in that person's mind. &gt; A controversial view I hold at the moment is that all drugs should be legalised and regulated. There are an awful lot of people who may come from your style of thinking who would not want me to say something like that openly because it's absolutely unthinkable and could I imagine the damage it would cause. Do you not see that? I'm not talking about your stance on that topic by the way, just the example I'm portraying. All of these only work as arguments, if /r/golang, golang-nuts and go conferences where the only platform in the world to voice your opinion. In other words, they only apply to free speech as a law and right. This is **not** what this is about. This is about a CoC for the go community, a community that is about programming. People coming here want to talk about programming in general and the go language in an environment safe from harm and harassment and their needs are a priority for this community and in particular the people hosting and managing it. If you want to prioritize free speech, you are more than welcome to open a community for politically motivated gophers where everything goes and host it yourself. There are more than enough (in particular online-) communities already where you can spew arbitrarily offensive bullshit without repercussions. Claiming free speech is in danger because we adopt a CoC for this one is completely removed from the reality of the internet.
Another major downside is even if you toogle logging off(by a boolean flag or level based -&gt; const) all stuff to actually write the log is still generated. It will just ignore logging. So if you want good performance you have to remove all logs some time later even if they could be helpful for another one at a later point. Additional point is if you make an application like an online game or some stuff which should not be reversed at all Logging will guide those people so nicely. However I guess reflection already allows this.
I disagree. The same logic could be used to argue that we don't need an `http.Handler` interface either, we should just use an `io.ReadWriter`. After all, an http request is just a stream of bytes read and written! A lower-level interface is certainly more universal, but if you go too low, you lose all structure and your interface no longer adds any value. `io.Writer` is just too low level to do any meaningful transformations in a general-purpose way.
My guess is it uses gocode for autocompletion. I experience the same problems in Vim now and then, usually with sub packages that I've modified. You can run gocode in server mode from the terminal `gocode -s -debug` before you start your editor. Gocode will log when it tries to make suggestions including when it can't. Usually, you need to recompile a (sub) package manually if autocompletion isn't working. I suggest deleting the built package in `$GOPATH/pkg/&lt;architecture&gt;...` sub directory as well.
Why so many Go related articles have "Go, also known as Golang"? 
I certainly know which things are lazy and which aren't, and I can be sure that my-list will not be copied. Those are language-level guarantees. For count, I know that it maintains the performance characteristics of the thing its counting: counting a set, vector, hash-map is O(1) and counting a singly linked list is O(n). That said, of course your point is valid. The higher level code is, the less we can be sure about the implementation. But as someone who spent years working on a codebase of 20 million lines of C, there's no question in my mind about which side I'd prefer to worry about.
As I mentioned, this falls out of two facts: (1) nearly everyone learns imperative first, and (2) humans tend to think the way they learned first is "intuitive." (Of course here I'm talking about logic, not syntax, since anyone can learn any syntax eventually.)
Not going to lie, I shut down the tab when it took longer than two seconds for me to see anything but a loading screen. Perhaps you should fix that to avoid others who do the same.
Both of the points under "The bad" seem a bit silly and for both the author provides the reason. The second one though is not even a bad thing. if you wanted arrays instead of slices which that example seemed to illustrate you should have used arrays, the copy builtin is also a really good idea if you are going to subslice and then edit those subslices.
[removed]
You could take a look at https://github.com/minio/mc. We use the new vendoring style from Golang 1.5.x releases. Earlier we used Godeps but we moved to vendoring style after Go 1.5 was released. 
No this specifically uses gorilla/session. It's an example of how to use this stuff.
 f, err := os.Open("somefile.txt") if err != nil { log.Fatal(err) } &gt; Now imagine having this 10 times in one file Gah, no!
That's kinda funny actually :) Dynamically typed languages with exceptions like JavaScript or PHP rarely throw exceptions for signaling errors, they return false or null if something went wrong. So you don't check for err, but if the expected string is actually false, that's more or less the same thing as in Go, you just don't get an error message, which really sucks.
You know you could have just called the binary [minio](https://packages.debian.org/search?searchon=contents&amp;keywords=minio&amp;mode=path&amp;suite=unstable&amp;arch=any)
now I won't miss any important github notifications. Thanks!
Because a lot of people have it in their head that Golang is not a real thing and that it should only be called Go, but if you try to google for "Go" you're going to have a bad time. Plus it helps any people that are brand new to Go know that it's also sometimes referred to as Golang 
I wonder what sucks about Godep?
Java Applets never died. They've dropped the "-let-", added the "-Script", and became JavaScript Apps. Feels good to make progress, doesn't it?
There are languages like Lisp where the checks for some conditions can be offloaded to somewhere else.
Javascript is so bad in this respect (implicit conversions!) that it doesn't really need to be discussed further, no amount of good library exceptions can fix it. However, I've always considered Go's error handling model as good not because exceptions have to be always bad but because no current exception model is suitable for a language like Go where programs are supposed to work very differently compared to pre-existing mainstream environments. Lots of shallow stacks instead of a few deeper ones (or just one stack) and explicit pathways of communication mean that implicitly propagated exceptions would have vastly lower levels of utility to a Go programmer.
Any plans for this to also be on projects hosted on app engine and not compute engine? Java seems to be the only option.
First result for "Go" search in Google is Go programing language. And if you search for specific things in Go like using Go file reading. You get very relevant results.
This wasn't always the case, but the second part of my statement still stands 
I think your last point is just more debug level logging. 
[removed]
Is GopherJS battle ready?
Didn't realize someone had posted this to reddit :) sharptierce: Thanks for the tip, I'll admit I'm not intimately familiar with godep.
Mate, this is a really bad exercise to learn Go because these design patterns are work arounds a limited type system. I recall that one of the Go or Haskell language designers correctly pointed this out. It's great that you are learning another language but don't try to code these OO design patterns. I would recommend to develop a game because then you get a great opportunity to use interfaces, channels, structs, learn all the go tools and how to ship a product with Go.
terminal-notifier will always send out a "terminal icon" which is for me a bit annoying. :(
I wanted to say that channel semantics allowing for simpler implementation. Also, explicit protection with go sync.Mutex of all the mutable fields helps avoiding data races that are subtle with sync.Cond implementation. &gt; If you are ok, I will create another gofragments... Absolutely :)
I use PopHub: https://github.com/questbeat/PopHub
Thanks :)
It allows you to convert a function to the type you defined, which has methods on it like other types can. So that way your new type implements an interface, in this case http.Handler. Its a really neat thing to use for single method interfaces. So now instead of defining another handler type you can use your existing type, like this func main() { http.ListenAndServe(":6060", appHandler(func(rw http.ResponseWriter, r *http.Request) (int, error) { // do something return 200, nil })) } 
just out of curiosity, in which tutorial did you find that code?
Yea. I agree. I think there are patches, but also adding additional support is trivial and will help with cross platform support also. 
Why/how do they even know the ethnicity/gender of the presenters at proposal time?
I have a ton of respect for Dave and the lack of involvement from certain minority groups in the tech community saddens me, but this is *not* the way to go about it. It's just asking to cause controversy and make people feel unwanted.
the worst is that some white men are so brainwashed that they are both sexist and racist to white men
this is a tech conference. we should talk about involvement of tech PEOPLE, not minorities. programming has nothing to do with being a minority.
Ah, it's fine to discriminate so long as it's against white men. This could have been worded "considering proposals of equal merit it was my policy to pick the more diverse option", but no, single out white men as a negative force.
Hahahahahahahahahahahahahahahahahahahah.
Yes. Everyone should be treated the same way. Put all balls into a bag and pick them randomly. The race, color should not play a roll at all. But I have the feeling that dave cheney didnt mean it and *I hope* he has just chosen the wrong words.
Don't you love accidental honesty? It's the best kind of honesty.
why would you ENFORCE diversity on a tech conference. it's not a charity event, people go there to see the BEST talks, not to see the most diverse community.
Yes, he's clearly being facetious (at least I hope so), but it doesn't make it any less true.
So uh, how long do white men get to be biased against? How long should white men let themselves be mistreated to make up for things done ~~before they were born~~? That's the problem with 'slight bias in the opposite direction'. Personally, I haven't mistreated minorities. I was in charge of hiring co-ops previously and of the four years I did it, I hired 3 minorities and one white man. Why should I have less of a chance then anyone else? Why should I be punished for something that someone else did? Diversity should be dealt with through the government and through non-profits. I absolutely think minorities should receive help to get back to a level playing field but choosing a minority over a white man for a conference based only on race is entirely the wrong way to handle this. 
I don't think that's the issue here. Assuming Dave really does only apply this to talks of "equal merit", the quality itself shouldn't be affected. I understand the desire for a diverse set of speakers, the issue (to me) is the wording and the negative connotations that white men are undesirable as speakers because they are white men.
a tougher barrier? where to you see any of these in learning Go, becoming a master and giving a speech about it? minority Go guru - great! I am fat, can I enter the olympic games JUST because I am part of the fatso-minority?
I would warmly welcome an _invitation_ to the minorities to give talks at this conference. But here it is clearly stated that they are given preferrence.
The only way to successfully combat racism/sexism in a field that is heavily affected by it is to come up with alternative conventions. If you're so upset by the fact that they preferred diverse speakers over non-diverse speakers when their merits were considered equal, then I'd like to see you up in arms about the fact that non-white people are proven to be hired less frequently than their white counterparts because of trivial racial indicators (name, appearance, etc). This is a two way street. The primary goal for GopherCon was to pick qualified candidates based on their meirt and then a secondary measure was the diversity of the candidates. There is a huge problem with the lack of diversity in tech, and ignoring it is not taking steps to correct the issue. If this isn't your idea of a good solution, then don't just cry about how the world is anti-white/anti-men come up with a more appropriate solution. If not, then clearly you are a part of the problem or you're glad the problem exists. Picking randomly after merit (considered to be the highest priority) has already been established when the pool of women and non-white speakers is already so small does nothing to help increase diversity. Plenty of research (http://eric.ed.gov/?id=EJ622741) has already shown that diverse teams lead to better bottom lines and more cohesive teams. The tech industry is lacking diversity and it needs to be addressed. So, if this isn't the ideal solution: then what is? 
Hence the "equal merit" portion. I was at Gophercon and, make no mistake, the majority of the talks were still men, and white men at that. I understand that people tend to get their jimmies rustled if they think that the selection criteria for a speaker don't fit their definition of "the best choice" for whatever they think the goals of a conference are, but that's not really up to anyone other than the conference organizers. It's their conference, they can feel free to select whomever they please. I'd venture to say that a lot of conferences make these kinds of decisions when planning their schedule, they just probably don't state it directly.
Man, I'm a pale man from Costa Rica (born and rise). I don't know if "white man" is a category that fits with my appearance, if I ever achieve some level of technical knowledge and have something worth speaking about Go in a Go conference, I feel that I may be rejected because the pigmentation of my skin. That really sucks. This is surreal, seems like taken from /r/TumblrInAction 
tech PEOPLE make stupid mistakes and without diverse backgrounds different experiences are missed http://techcrunch.com/2015/06/09/apple-stops-ignoring-womens-health-with-ios-9-healthkit-update-now-featuring-period-tracking/ http://www.sfgate.com/business/article/How-tech-s-lack-of-diversity-leads-to-racist-6398224.php
it really bums me out to see this as the top post on /r/golang. 
I think it's *exactly* the way to go about it at this particular time in history. I just think that having it said outright has rankled folks. Who knows, maybe he could have elided it or phrased it in such a way as to cause less offense, but I don't know. I would encourage anyone who feels unwanted to attend the conference and continue to participate in the community, both of which I have found to be very welcoming as a white male. Studies continue to indicate that racial and sexual bias are still alive and well, though are much more subtle and easy to miss than they may once have been, and if the price to reverse that trend is a few people feeling uncomfortable or discriminated against, so be it. Controversy, in this case, is a good thing, and it moves the dialog forward.
I think you're coming at this from the wrong place. Try not to think about it as a block of time where "being a white dude sucks". Think of it more instead as a gentle push on the pendulum to secure a more inclusive future. It might skew towards the opposite extreme in just the tiniest amount for just the tiniest moment, but the overall course is (hopefully) to swing back to a slightly better middle. And, if you're being cynical, that's an optimistic interpretation. Sure, you might lose out on a speaking gig here and there, but it's hardly a systemic problem that's going to blow out of proportion until there are no more white dudes left in tech. Let's be reasonable here. You're falling victim to the classic fallacy of assuming implicit persecution and bad faith by zeroing in on your own circumstances and emotional response. I believe you when you say you've never mistreated minorities. I'm sure you're a great person, and I'm sure you've hired the best folks as you saw fit. But these are speaking gigs, not jobs. They are opportunities to deliberately send a public message to people who have otherwise not felt involved or included that their voices matter and to chip away at that (perhaps subconscious) aversion they might have to getting involved. It's really not that big of a deal, and we should stop allowing it to be one.
&gt; The only way to successfully combat racism/sexism in a field that is heavily affected by it is to come up with alternative conventions. How about treating everyone by their merits and not discriminating against the people? I can only think of white supremacists and misogynists who would call this unfair because they believe whites and/or men to be inherently superior to others.
I agree, this is very selective
If you have something of great interest and merit to talk about, I feel pretty safe in saying you'd find a prominent place to speak about it. Let's not make putative mountains out of speculative molehills here.
It is the current year (!)
You go back far enough and every culture has done things they aren't proud enough. 
I disagree. A lot meaningful change starts small by addressing biases writ both small and large in yourself and your interaction with the world. As my mother once said to me: "sometimes the greatest gift you can give the future is by being a good parent to your children and a good friend to as many people as you can." For some people, their interaction with the world is how they select who they choose to speak at their conference.
Yes, but how often are two things really of "equal" value? It's like saying, if I have two job applicants who are "equal", the decider will be "x". It's very rare two job applications will every truly be equal - it's a subjective thing in your mind.
As a "minority" (Asian), I see negatives to this approach. If I was good enough to speak at a conference, do I really want to know that I was selected because I was a minority? Perhaps it's just me, but that just cheapens any accomplishment I make - to know that some white guy picked me over another equally accomplished white guy, just because I'm Asian and he felt bad for me. I'm sure his intentions were good, but it doesn't change the fact it feels a bit like a pity date. I mean, Ok, I suppose I could be Asian and homosexual - does that mean I'm even more likely to get picked? It just...I don't know if this is going to end well.
exactly - we are back at "selected minorities". does being Asian gives you "tougher barrier to entry", as someone stated here?
If your ethnicity was the sole selection criterion (which it's not), you might have a point, but, honestly, it's still merit-driven first and foremost, and if you attend the conference or watch the talks, you will see that. I agree that stating it directly is probably more trouble than it's worth, but, honestly, this is probably happening everywhere. :shrug:
Yes, my point is now we have three: info for user facing logging, debug for logs like the one I mentioned in the last paragraph, and error logs for bad states that shouldn't happen
As a straight, white, cis-gendered male I don't feel threatened by this. I've had the world handed to me and there's no reason to trifle over something so small. I would hope this gives an opportunity to other races and genders to find role models and add strength to the community of which I am a part. If diversity wasn't an issue we should expect a representation similar to that of the population at large, but we don't have that in tech.
&gt; 100% behind getting a more inclusive future though. &gt; after we get to 100% fairness (if ever) it'll probably be better. It's still pretty great now. This one post from this one person makes all of the slogging and downvotes worth it to me, so thanks. I'm in your corner, toelint, and you can count on me if you ever need to collaborate on something.
It's not overreaching, you're just being overly sensitive and whining.
I was a bit confused when you said: &gt;First, when I say “taring” what I’m really referring too is gziping files and then taring them to create whats called a “tarball”. My first thought was "Why aren't you gzipping after tarring" (for compatibility with existing conventions), but when reading the code, it looks like that's what you did after all.
The barrier gets tougher because people like you alienate people from underrepresented groups.
Give over. It's not like you'll suddenly get homeless because previously underrepresented groups are starting to receive better representation. This whole "but it's racism!" argument may be technically true, but it's the one with the least consequences. In this case, at worst you don't get to speak in front of people at a conference. Boo-hoo! Why would I even care. Just submit it to another conference, and get on with life. In the end, white men will still retain equal representation.
related - &gt; Reporter: Why do you choose to make your cabinet gender equal? &gt; Canadian PM: Because it's 2015.
are you saying that if, for instance, the reason is lack of interest, we should artificially manufacture interest? 
I have to agree, and you hit on a vital point. Real diversity is not skin deep. It's about wealth, opportunity, nationality, environment, social group, family, upbringing, personal experience, and a thousand other factors. Judging diversity based first-and-foremost on gender and skin color just makes a farce out of the whole diversity movement. These people don't want diversity, they want to imitate stock photo footage.
Well there is a Special Olympics and Paralympics.
&gt; let's see more fat people in sports, the other guy is thin, so he is privileged Precisely that. If you are overweight and equally qualified you should be preferred to offset your higher barrier to entry. Yes, there is such a thing as thin privilege. There is an [implicit association test](https://implicit.harvard.edu/implicit/), that scientifically measures subconscious associations between categories and one of the categories is weight and it found that the majority of people have an unconscious bias against overweight people. I encourage you to do it (and similar tests), it's a very interesting self-assessment :)
&gt; There's no reason for conference selectors to know the race or gender of the author of a proposed talk. Except that to adequately assess the quality of the talk they need to know if that person gives good talks which means they have to watch talks of that person. An abstract can be arbitrarily misleading to assess the quality of a talk. &gt; I'm not sure why conscious discrimination with known parameters against group X as inherently preferable to potential unconscious discrimination of unknown extent against group Y. Because by discriminating in favor of Y, you offset the existing discrimination against Y to a certain extend to create a more level playing filed. The field of applicants is already pre-selected in a biased-against-Y matter, it is not only about preventing *further* anti-Y bias. &gt; Exactly. One has a hard time imagining how middle school students would decide to get into programming as a result of the composition of talks at a conference they've never heard of for a language they've also never heard of. If there is to be progress on this front, it's in outreach to people (and mostly kids) outside of the community, not open discrimination inside of it. There's no amount of discrimination against male programmers that will change the realities of the current demographics of people applying for programming jobs. One company's discrimination to achieve local over-representation just results in under-representation elsewhere. The only solution lies in education and outreach. Blaming the pipeline is popular to justify not facilitating change. But it rarely changes anything. Modern gender studies acknowledges the pipeline-problem, but it also pushes the responsibility for change to every step of the pipeline. i.e. "we already get a non-representative sample of applicants" is not an excuse to not do your best to offset that lack of representation.
Thanks for standing up for the science of diversity :) Too many redditers are unaware of it and making people aware that this is an actual scientific field with actual scientific research underpinning its conclusions is probably the best way to get the flamewars to stop :)
&gt; things done before they were born? I suggest you read up on current research and news. Institutional and subconscious racism is alive and kicking, it's not a thing of the past. &gt; Personally, I haven't mistreated minorities. The [geek feminism wiki](http://geekfeminism.wikia.com/wiki/Privilege) has a great introduction to privilege and how it works. In particular, that a) active racism on your part isn't necessary for you to benefit from a racially biased system and b) that even if you personally may be the exception to the rule, this still doesn't change the fact that, on average, there is such a thing as white and male privilege.
Thanks! Same to you!
You realize that a non-negligible of the people pushing for diversity in tech are white males who simply acknowledge their privilege and trying their best to remedy it?
You are irrelevant. Leisel Jones is quite fat to be an olympic swimmer but she is a great swimmer. She is being bashed about her fat ratio even though she has merit as a world-class swimmer. Merit is often undervalued because of people like you.
I don't really trust social science studies. The group of "scientists" have a strong political agenda, and their findings are rarely reproduced. Meanwhile, obvious questions don't get asked if they challenge certain assumed conclusions. More to the point, equality of opportunity should be protected; outcomes shouldn't be guaranteed, full stop. No complicated social theories that attempt to link outcomes to opportunities.
It is certainly *easier* to find 20 white males who can give great talks at Gophercon than it is to find 20 people from diverse backgrounds who can give great talks at Gophercon, from a pure numbers perspective. But that doesn't mean the latter don't exist, and shouldn't be found. Assuming the talks are roughly equivalent in quality: * Do you think someone who proposes a talk on their own is more worthy than someone who is asked to propose a talk? * Do you think someone who has given a lot of talks before is more worthy than someone who has not? Why should the Gophercon organizers not spend their own time and dollars searching for high quality talks from diverse speakers? That is, unless you think it's impossible to find 20 non white-males in the entire world who could possibly give good talks about Go. 
&gt; Why is diversity worse than randomness Randomness is fair. Always discriminating against white males as a policy officially and systematically denies them opportunities. One could argue that social systems make it easier for white men to be represented in these events, but I don't think it's appropriate to make official policies because social systems don't result in equal representation (this is ultimately equality for equality's sake).
I reviewed the proposals for GopherCon and there were many proposals that I thought more or less the same. It is *very* hard to assess a proposal for a conference, so the ratings tend to be pretty coarse.
&gt; "The real racists aren't the racists. The real racists are people who notice racists being racist." For as clever and logical as many programmers imagine themselves to be, they sure parrot some hilariously facile arguments. 
Like the guy who wrote the article linked to this thread.
Are you sure you don't want to lock this thread so it's easier to cram this piece of shit down the community's throat?
What evidence is there that racism and sexism are prevalent in the Go community? The community's demographics don't constitute racism or sexism. If free people choose to participate or not participate along ethnic or gender lines, they should be supported in doing so. If there is evidence of discrimination, let's address it. FWIW, I'm equally upset when anyone is discriminated against. But discrimination is worse when it's official and when it's implemented in the name of equality.
However, the IDEA Go plugin doesn't use gocode.
I feel like labeling certain groups "privileged" in this way is begging the question, at least when you account for the fact that all the work going into demonstrating this privilege comes from an ideologically homogeneous and actively biased body of social scientists.
I do keep up with social science. The bits I find most interesting are the meta studies that find social scientists are actively biased in favor of preserving the ideological consistency of their field, or the bits that highlight some of the more blatant methodological errors (e.g., a study finding that conservatives are ethical which effectively defines "ethical" as having liberal values). All of this is to say that ideological sources should be taken with a large grain of salt.
That's pretty messed up. Pick the most skilled person for the job, not the most skilled minority you can find. 
Which rules did they add?
These two additions in particular received the most criticism: &gt; [Avoid destructive behavior, for example:] &gt; ... &gt; If someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize. &gt; ... &gt; “Microaggressions,” the small, subtle, often subconscious actions that marginalize people in oppressed groups. The example given from microaggressions suggests that we should never use "so simple even my grandma could understand it." as it marginalises woman and the elderly. Personally, I find that the whole document comes across as rather condescending and the tone reminds me of something that might be handed out to small children. To quote further: &gt; While a major goal of this proposal is to make the community more inclusive, this does by definition exclude people that cannot abide by the goals and principles of the code. I see this as a regrettable but necessary and inescapable design tradeoff. The proposition seems to literally be that you should be excluded from the community for saying something which could be taken as offensive by even the tiniest fraction of the community if you do not apologise and shut up. I'm all for a Code of Conduct, but not this one. The Django and Rust Code of Conducts are both great examples of good Codes of Conduct, and are incidentally both very similar. The proposed code of conduct would leave me in a position where I would feel unable to participate in the Go community because of it. 
We can't improve without some sacrifice, and we all stand to gain from a stronger, more diverse community. The most direct way we gain from it: by having a *bigger* community. Other than to just amplify the message to today's non-white-male coders that all are welcome, we need to build a legacy of content that reflects the world we want to see. We've got to think about who young coders will learn from as they search for videos and other materials on Go. Opting for the non-white-male applicant when all else is equal seems just about the *least* we can do. Dave Cheney, Brian Ketelsen, and Erik St. Martin are all white (appearing) men[1]. It's a positive impact they're making, but they do it using their privilege. If they sound a little off key, well, I'd say it's tough to get a great harmony with just one kind of voice. Personally, I applaud their efforts. [1] It's unclear if any others are leaders (or members?) of gopher academy. The about page is vague.
I'm reading through the [Rust one](https://www.rust-lang.org/conduct.html) now and it seems mostly similar. What makes it better than the Go one?
ah k thanks guys, just curious.
&gt; "Romantic or sexual commentary, remarks, or questions." This is funny. As if Go is a male only boarding school.
Having a deep knowledge of the language and great topic isn't enough. I think they should select people who know how to give presentations. I'm not a native English speaker myself, but I prefer watching someone whose native language is English or is very competent in speaking the language. I really like Rob Pike's style of presentation. His sense of humor and constant use of the word *subtle* makes his speeches very pleasant to watch. 
The [geek feminism wiki](http://geekfeminism.wikia.com/wiki/Privilege) has a good introduction to the term privilege and how it's applied and should be used. :) In particular, it explains that not every white or male person had it easy in every respect in their lives and that "privilege" isn't a pejorative. But yes, white and male privilege are real things that can be measured (see, e.g. [project implicit](https://implicit.harvard.edu/implicit/) which IMHO is a very good example of a measurement of this).
&gt; You will fail by misidentifying the privilege some people do or do not have. Why do you presume we necessarily fail? I don't get it, you should underpin this point with arguments. Also, both white and male privilege (which are the specific examples mentioned by Dave) are not speculation. That's not poking in the dark. These are real things that have been scientifically researched and proven to exist for like fifty years, in the form of unconscious biases.
If you totally ignore the feedback from the community, then it's not a community code of conduct in my book.
&gt; Randomness is fair. Flipping a coin in this instance wouldn't even be random. It would be exactly as biased as your preselection, so it would be, in technical terms, *hugely* biased. &gt; Always discriminating against white males as a policy officially and systematically denies them opportunities. I acknowledge that this is the case and that it feels unfair to many white males. But I still believe that the systematic unofficial discrimination against non-whites and non-males which has been going on for quite a while now and creates much worse outcomes, take precedence. In other words, I acknowledge [the distress of the privileged](http://weeklysift.com/2012/09/10/the-distress-of-the-privileged/), I just don't think it has any real weight against the distress of the underprivileged. &gt; this is ultimately equality for equality's sake You claimed above randomness is fair and seemed to regard fairness as a good thing. Well, a random sampling process should come out with a relatively representative choice of the general population. So, no, striving for representativeness isn't "equality for equality's sake", it's "equality for fairness".
Oops, my reading comprehension wasn't quite at 100%. The top 1/3 (roughly) of papers were de-anonymized (54, give or take); this means that I can't assume they're hidebound to bump white men for URMs *only* within bands that encompass 1/5 of all the proposals submitted (33-proposal bands). Still, I'm willing to take Cheney at his word when he says "of equal merit" (keeping in mind that predicting talk quality given only speaker proposals is difficult and prone to unavoidable error).
That's *why* they outperform.
go-plus author here. As others have mentioned, gocode is used for autocompletion. You should first make sure you have run `go get -u &lt;package name here&gt;`. If the package you are getting requires a build step (because it is not go get compatible), perform that step. Then, if you're still having problems (particularly with code you are writing yourself that is in separate packages), you might want to check your gocode settings (run `gocode set`). In particular, you want to make sure you have autobuild set to true (`gocode set autobuild true`). Let me know if there is anything else I can do to help.
In general the Rust CoC, despite having a sentence or two that I personally would disagree with, is a lot more friendly, welcoming and encouraging. It's a guide HOW to be part of the community. The Go CoC is a guide on how to get yourself excluded unless you are entirely non-offensive (even in "small, subconscious" ways). For example, from the Rust CoC: &gt; Please be kind and courteous. There's no need to be mean or rude. &gt; Please keep unstructured critique to a minimum. If you have solid ideas you want to experiment with, make a fork and see how it works. These are both really welcoming statements, what to do, how to be part of the community. "Please" is a nice touch, and it comes across as friendly - the CoC is being used as an example of how to write something for the Rust community. I see it, and I feel like I can be a functioning part of the community. Then I look at the proposed Go one and see: &gt; Remember that sometimes it is best to refrain from commenting entirely. &gt; Avoid destructive behavior, for example: “Microaggressions,” the small, subtle, often subconscious actions that marginalize people in oppressed groups. It just comes across as unfriendly, unwelcoming, and puts me off being part of the community. I fee like the CoC is there to put people off joining the community rather than to welcome them. Words like "enforcement", "refrain" and phrases such as "This section states" are unfriendly, whilst the Rust CoC used "Moderation" and "These are the policies for upholding our community's standards" are much more friendly. This should be a guide for dealing with people - it should be written as such. Instead, it's written like a technical document as if people are machines. The Rust CoC contains one of the same lines that got a lot of complaints in the Go CoC: &gt; If someone takes issue with something you said or did, resist the urge to be defensive. Just stop doing what it was they complained about and apologize. However, the Rust CoC goes on to explain the policy: &gt; Even if you feel you were misinterpreted or unfairly accused, chances are good there was something you could've communicated better — remember that it's your responsibility to make your fellow Rustaceans comfortable. It changes the statement from "if someone complains, you are wrong and should apologise and shut up" to "perhaps there was a communication issue which could be worked on". Again, a small thing, but it makes the CoC a lot more friendly. The Rust CoC is also a good example of taking a (in my opinion) a terrible starting point (it's based on the [Node.js Policy on Trolling](http://blog.izs.me/post/30036893703/policy-on-trolling)) and turning it into something which is welcoming. I'm not sure what's going on with the people who "run" the Go community at the moment. There's clearly a push for diversity, which is a very good thing, however diversity through exclusion is exactly the worst type of diversity.
Thanks, I get that now. Good explanation. But I don't really feel that I get my second question answered. Maybe I missed something in your description or you maybe didn't answer that fully. Would you mind elaborating on the second question as well? To clarify, what happens with the types and possibilities after the declaration of `ServeHTTP` with a `appHandler` as context? Thanks!
I googled it for you: http://www.bbc.com/news/magazine-14679657 The gist of the article is that a majority of 100m runners come from a small small region, in other words the samples are bunched and vastly localized. &gt; This evidence demonstrates how absurd it is to engage in racial generalisations - how crazy it is to witness a tiny group of black people winning at, say, the 10,000m and to infer that all people who share the same skin colour share an aptitude for 10,000m running. To say that because 100m olympic runners are mostly black and therefore diversity in software engineering isn't an issue is absurd. We need to remove our ego and racist views and start looking for ways to attract diversity because it increases our sample size and in turn the number of good engineers we get to work with.
&gt; variables can only be assigned to once. [Are you sure?](http://play.golang.org/p/t93vLHG7Rh)
Ah, but those are different variables with the same name ;)
That's exactly what I came up with first, but then I noticed that it's not goroutine safe.
 Creation Date: 2015-11-04T23:28:00.00Z Registrant Name: WHOISGUARD PROTECTED Any chance it's your domain? :-)
Thanks for your input.
For those who care and since I don't have a blog or anything, I'll just use this moment and post a quick update note here as well. This rewrite plan of mine, doesn't mean I stopped working on gocode until it happens. It's just a food for thought. Something I may consider in near future. Here is a little portion of improvements for you all I just did in gocode: https://github.com/nsf/gocode/issues/308
Thanks for all the work you put into gocode, it's an amazing tool!
Whoever doubted that Rust is not taking the world by storm!
There's [a link there to one with better sound](https://www.youtube.com/watch?v=ulfriuZjGDk).
"You're just being" are three words that never belong together in that particular sequence.
&gt; If a train is rushing towards an abyss, do you "carefully gauge how much counterforce is needed", or do you just throw everything at it until it at least decelerates to a manageable speed? We only need "careful gauging" once we are near the unstable equilibrium that is complete equality in opportunities. But as this inverse pendulum is currently pretty far from equilibrium, it's okay to just throw stuff at it until it sticks. And yes, maybe we will overshoot someday. I am fine with reversing our efforts then. But currently, we know that we are nowhere near this point. When the things you're throwing in front of the train to slow it down are living humans, yes, one should be sure the costs outweigh the harm. It might still be worth it. But I'd really, really like it if you'd stop pretending there weren't costs. (There's another problem here too, but I'll get to that at the very bottom.) &gt; Well, "the go-using population is deviating from the global one" is certainly an explanation for a sampling bias. I don't think it's really an excuse though. Of course less minorities are using go, go is part of the tech culture and the tech culture is already pre-sampling in a way heavily biased against minorities. As a corollary of above, yes, the sampling process should be adjusted to be more representative (and thus fair) of the global population. &gt; ... only offsetting the unfair advantage that 80% of men already got to get there. So I think this is the crux of the disagreement. Unbiased sampling of the biased sample (i.e. 80, 34) doesn't cause harm to the people who in a better world would have pursued tech, it just doesn't solve a different problem that occurs elsewhere—nor does it have that ability: another level of discrimination that only applies against the pool of people who did pursue tech doesn't help the people who didn't. (In certain circumstances, there are secondary effects as you note that can meaningfully help the next generation. I still have a hard time seeing how a Go conference, whose talks will be seen essentially exclusively by existing Go users, is one of those. And even in cases where that's clearly a consideration, one again needs to weigh the benefits against the quite real costs.) My being in programming didn't come at the expense of a woman being excluded from programming. Balance comes from greater inclusion; further discrimination might nominally result in something that looks like balance, but it isn't the same thing. &gt; Why? Why is it counterproductive. I agree that efforts at lower stages of the pipeline might be more effective (though, really, meh. Not that much). I could even accept you claiming that this is unproductive. I completely don't see how this could possibly be counterproductive. Several issues (note: these are objections to the general principle, some don't apply in this particular case): 1. Masks underlying problems: since it can't directly change the underlying candidate pool, it makes the situation look more representative then it is. This hides the underlying problems (and even partial bandaids hide their extent) that gives rise to the skewed pool. (The not-super-invested majority of) one side congratulates itself on a job well done and concludes with a different side that further intervention is unwarranted. 2. Misallocation of scarce resources incurs opportunity costs: the time, political capital and good will (see next) being wasted fighting for a less effective intervention necessarily comes at the costs of pursuing more effective interventions. A Go community group dedicated to teaching underprivileged young people how to code would be a much better use of collective effort. 3. Most people rather understandably don't like open discrimination against them. It breeds hostility and contempt. This is horribly caustic to the good will that people would otherwise have toward fixing the underlying issue. *At best* you might be able to browbeat half the country into 'silent consent', but it's more likely that you're going to lose a lot of would-be allies to politics that don't throw them in front of the proverbial locomotive. 4. Can result in worse outcomes for those nominally being helped if they wouldn't have otherwise made it into the sample (this one definitely doesn't apply to the talk selection, but it's worth bringing up anyway) because the sample criterion being adjusted for them might have been meaningfully predictive of outcomes. &gt; I do indeed think that if your sample deviates significantly from the global population does mean your sample is biased and does at least the very least requires a good explanation and yes, very probably an adjustment of your sampling process to be more representative. So, another problem with trying to force the distribution to where it should be is that we have little idea where the distribution should be. It's entirely possible that the patriarchy-less distribution of programmers is 30/70 and (depending on which is which) that could mean the problem is much, much worse than we thought or much closer to being solved than widely believed. It's hard to avoid under- and overshooting when you don't even know what the target is and the consequences of either are harmful to *every* party involved.
If you're going to talk about a talk's quality, I think there is definitely space for that. But please try and avoid false equivalencies and hyperbole. &gt; by treating minorities differently you're basically saying they're not capable of producing a presentation that is as good as what a white man can do. This is disingenuous, and a false equivalency. &gt; and not on the basis of merit is immoral. This is hyperbole. 
Yeah, I don't think I will use that frequently either to be honest. There are, however, some cases where it could be useful. It was basically a project to learn about code generation in Go. Will remove all occurrences of "array" in the readme, they are actually slices, thanks for the heads up. You're right, it will be cool to be able to use them with channels. Sadly, they can't be used with channels right now. I might implement that feature in the future.
&gt; But I'd really, really like it if you'd stop pretending there weren't costs. But I'm not. That's why I'm linking to the [distress of the privileged](http://weeklysift.com/2012/09/10/the-distress-of-the-privileged/) all over the place. I acknowledge that there are costs and I acknowledge that the feeling of unfair persecution of privileged people are real. I just don't think that it compares to the problems the underprivileged experience in this world and that it is frankly a bit whiny. The cost of achieving diverse representation and a fair world is, that the privileged now have to deal with the fact that their privilege carries them a tiny bit (and this bit, in this case, is *really* tiny) less further. I'm okay with that, if it means we can even partly remedy the fact that for underprivileged it is *50%+ harder* ([that is how many more resumes you have to send out on average if you have a black sounding name](http://www.nber.org/papers/w9873.pdf)) currently to even get a job in the field. I simply find it difficult to care about some very hypothetical dude that is taken his coin flip chance of presenting at this particular conference by a less privileged but equally qualified applicant. It just doesn't compare in order of magnitudes. &gt; since it can't directly change the underlying candidate pool, it makes the situation look more representative then it is. But that's pretty much my point. The situation is pretty bad, so bad indeed, that it is no wonder that some groups are discouraged from entering. I don't think it masks the problem significantly for deciders, because the numbers still exists and can be consulted to inform decisions. &gt; Misallocation of scarce resources incurs opportunity costs: the time, political capital and good will (see next) being wasted fighting for a less effective intervention necessarily comes at the costs of pursuing more effective interventions. A Go community group dedicated to teaching underprivileged young people how to code would be a much better use of collective effort. I disagree. The effort needed for this is *very* close to zero. You could even argue, that it it negative, as it absolves you from doing an additional flip of a coin. Again, diversity efforts in this case are an extracurricular activity for me and IIUC Dave too. Our primary occupation is being engineers and (and that we can have this attitude shows our privilege) we can afford to not spent the huge efforts needed to have impact at other stages of the pipeline. This is where we can, with very minimal effort, have a positive impact, so this is where we choose to put our resources. More qualified and specialized people can spend their time on other stages and they will have, with much less effort, a much greater impact, than I could ever have even with a very significant investment of effort. This is the basis of division of labor, everyone does, where their particular skill set creates the best effort/benefit ratio. &gt; Most people rather understandably don't like open discrimination against them. Unsurprisingly (though also understandably), most people are also rather uncomfortable with losing their privilege or at least most of its effects. This is a normal part of the route to a more fair and equal society. When Slavery was abolished, people in the US complained, because the government took away their freedom (to own other people, that is). Turns out, you don't have to discriminate against them for them to feel discriminated. People can develop persecution complexes fine on their own, no matter if you actually persecute them. So I'm going to be fine with them complaining and I'm going to accept that I have to actively fight the privileged to abolish the effects of said privilege. It's unavoidable anyway. &gt; Can result in worse outcomes for those nominally being helped if they wouldn't have otherwise made it into the sample (this one definitely doesn't apply to the talk selection, but it's worth bringing up anyway) because the sample criterion being adjusted for them might have been meaningfully predictive of outcomes. I don't see, how that is relevant in *any* case. I have yet to see an initiative to allow unqualified people access, because they are of a minority group. &gt; So, another problem with trying to force the distribution to where it should be is that we have little idea where the distribution should be. I'm still going with "statistically representative of the general population unless you get conclusive evidence that it should deviate from it". I have yet to see a good explanation for why women are systematically less qualified then men (it turns out, even the studies that find gender-based qualification differences are [probably wrong due to unconscious biases](http://mitadmissions.org/blogs/entry/picture-yourself-as-a-stereotypical-male)). So I do believe we have a fairly good answer to the question of what the distribution should be. Even the (possibly questionable) studies we have that find differences, usually place them to be so subtly, that they certainly can't explain a 70/30 ratio. It definitely isn't something that we can just answer in a Stammtisch-discussion of unqualified brogrammers that think they know all about everything because they are knowledgeable in their field. I believe we, as amateurs, should definitely go with the scientific consensus in the field and the overall consensus in sociology is AFAIK that there is systematic discrimination against women, people of color, overweight people,……
That is not what is happening. What is happening is "under all the most skilled people for the job, choose someone from a minority group if available". This is clearly a strawman that could have been prevented by reading what the text actually said.
So you didn't provide constructive feedback. That's a shame.
Hey, if it's a great talk, that's great :) I am afraid, this won't help with a bad talk though (if you intended to imply that), as it only applies to talks of either merit, so applying with a good talk is a necessary requirement. 
Go 1.5 fixed that problem for me.
What's the typical use case for GopherJS? 
i'm pretty sure they didn't pick THE most qualified people but instead they decided to pick a minority from a range of qualified people, which is still totally bullshit.
He speaks for the majority of the people on Reddit. Just look at the previous 2 threads, one of which was locked *and* this thread. Perhaps he's not the one who needs to get over himself.
Thanks. That was it. I forgot that part.
In the Readme it referenced pushbullet. I think the idea is to use pushbullet to send a notification to an Android phone via the notification API. 
I see. I completely overlooked that part. Thanks!
Great questions. I've updated the readme. There are currently two types, OS X desktop notifications and Pushbullet notifications. Currently, this is OS X only. I've thought about supporting Ubuntu through notify-send, but I'm not sure how to support all of Linux.
*Of course* the reports are secret. This is personal stuff. How would you feel if the police would release your personal details to anyone who asks, when you report a crime? Complaining that abuse-reports are dealt with in secret is completely stupid, sorry.
Hey, cool idea. I definitely go walking around while something is uploading/copying/scanning in a terminal, and it would be nice to get dinged on my phone. Only thing is, often these processes run on any of hundreds of remote servers. Would be cool to figure out some way to do it "over" an SSH session for example. Edit: also, attach existing PID - if you start a process, then realize its gonna take forever, but dont want to start it again with noti. And finally: https://github.com/variadico/noti/blob/master/noti.go#L161 fragile, possibly unsafe
It's funny seems like every time I make a readme I make that mistake but when I'm actually programming I never do. Thanks!
That got asked several times on StackOverflow already (example: http://stackoverflow.com/q/33027070/1685538) The idea is that this logic does not belong in a template. That's sometimes a bit frustrating, but in the same time understandable...
1. why insert.py because it is a one time entry script, (I could do it in a few lines of Python, I know it could be better in go, an integrated approach) , but the thing is there can't be more than one main file in golang, I just now had an idea as to how to do it, will update it 2. insert.py is used to populate the database entries, which will serve images via web server for the person to add in tags 3. The app doesn't use AI to tag photos, we have to manually tag them, this is a manual process
Ahhh ok
Regardless of humor, not saying one positive or one informative thing about a person is a horrible introduction.
I understand the notion of privilege, but I have yet to hear proof that one group has privilege over another that doesn't either depend on selecting a narrow set of criteria (e.g., men are privileged because gender pay gap) without considering other criteria (e.g., male workplace fatalities are 12 times female fatalities). I don't know what the use is in talking about privilege either. It seems to be used as a stand in for something that is real or measurable, and if we can't measure it then we can't know if it exists or when we've sufficiently oppressed the "privileged" group that they're no longer privileged. There's a lot of hate that is directed at "privileged" groups on the unfounded basis that they are privileged. I don't know what the right answer is, but the form the whole social justice movement leaves me very depressed for the future.
The pushbullet notifications should work over ssh. I have my own notifier I wrote that does this for the same reason. 
As per https://github.com/go-sql-driver/mysql#usage, https://golang.org/pkg/database/sql/#Open states that the returned *DB is safe for concurrent use. For applications which do not need to be tested thoroughly, a global should be fine. Otherwise, I tend to favor dependency injection. If you provide more context about what you are working on (preferably using http://play.golang.org/), I or someone else may provide code for you to review. Edit to add, based on /u/coussej's reply: The second example of DI is how I approach this need - http://www.alexedwards.net/blog/organising-database-access#using-an-interface
From https://golang.org/pkg/database/sql/#DB "DB is a database handle representing a pool of zero or more underlying connections. It's safe for concurrent use by multiple goroutines." A clean way would be to bind it together with registering the network handlers. Alternatively, build something around the context pattern, see [x/net/context](https://godoc.org/golang.org/x/net/context). (Unfortunately the standard `net/http` package doesn't support context objects in their handlers. Some third-party network libraries do.) Edit: Discard the context idea as per /u/daveddev's comment.
clever and useful. Nice! 
Having read http://blog.golang.org/context, I'll have to stand corrected. Thanks.
Nice work! This will be extremely helpful to those implementing backup/sync solutions.
Had that bookmarked long ago :)
@calebdoxsey I want to pretend I did not read this but I can't. Calling out anyone personally to make a point is absolutely wrong, unethical and immoral. No one has a right to judge others and in the end Veronica did nothing wrong. We are incredibly lucky to have Veronica and all she is doing to support the community. We should be lifting her up, not throwing her under a bus to make a point. I am very disappointed. If you have problems with her talk, why not reach out to her and teach. You are a prominent member of the Go community because of your book, your teaching and the talks you have given. When people read your post they see it from a person of authority in the Go community. I shudder to think what others in underrepresented groups think when they read your post. A post being shared throughout the community. No one outside of @alaskacodes is stepping up to say this is wrong, Caleb your post crossed the line. I believe an apology to Veronica is in order. I hope anyone reading your post today or in the future does not think for one second they are not welcome in the Go community, because they are and I am here to help them if they need it.
I made [tnse](https://github.com/cryptix/cmd/blob/master/tnse/README.md) to show test errors a while back. On Linux it uses notify-send. I'd be happy to flesh this out and open a pr sometime next week.
Yep. I remember that now. Thanks.
Thanks for putting this together! I'm a vim neophyte and whenever I get the urge to get better, I find that the lack of auto-completion and function signatures showing for reference always drives me back to Sublime with Go-Sublime and goimports. When I went to set up vim for Go, I ran into all the things you mentioned, and I decided it was not worth the time. Your solution is great! I just tried it out and it was super easy. I think I'll be working in vim next week :)
Does this work for Windows &amp; linux?
I usually do most of my coding using [go-plus](https://atom.io/packages/go-plus) an atom plugin for go that supports all the standard stuff. But I still find myself editing and coding here and there using vim, I should probably try out these plugin to see if I could make the switch to pure vim.
 go install 
Thanks
Rather than generate it from the database schema, why not generate if from struct tags and also generate the db schema from the struct tags too? Anyhow, not sure if it exists yet, but would be useful. 
How else could he present the point without specifying the speaker. His argument needed context. Although, it is unfortunate that he singled out a speaker, it was necessary. You are being overly sensitive and portray as if he attacked Veronica. Political correctness has its limits too. And your argument on under-represented groups make me laugh. He was making a point about merit based selection. All the speakers (I don't care if they are under-represented or over-represented) are going to be better prepared next time. Nothing else. You are making a big issue out of nothing.
I built something similar a few months ago. [github.com/paked/configure](https://github.com/paked/configure). It does the same sort of thing (Configuration through multiple sources), except follows the same API as the standard libraries `flag` package.
It's not code generation (it uses reflection), but the [sqlx package](https://github.com/jmoiron/sqlx) lets you scan directly into structs (see ScanStruct), although I'm not a huge fan of its "add x to stuff" naming pattern.
I'm not very creative.
&gt; http://blog.golang.org/context I "abuse" x/net/context to hold database connections. If you have a complex app with multiple databases, you can use middleware or other techniques to associate the correct database with incoming requests. I set up a base context including the default DB connections, logger, etc. at startup and replace them on a per-request basis as needed. I think it's a useful technique when you have lots of internal packages you need to tie together. It makes testing really easy, you simply set up a "testing mode" context and throw it at your handler. However, it's arguably against the spirit of what x/net/context is intended for. Personally I think it is preferable compared to globals or complex `InitThingy(...)` sequences. There was another thread about this in the past. You can check out the arguments [for](https://www.reddit.com/r/golang/comments/38hkor/go_best_practice_for_accessing_database_in/crv41ps) and [against](https://www.reddit.com/r/golang/comments/38hkor/go_best_practice_for_accessing_database_in/crvi6re) using x/net/context. FWIW, ultimately I think a hybrid approach is the best. Use [interfaces like this](http://www.alexedwards.net/blog/organising-database-access#using-an-interface) and pass context.Context to them. If you can come up with a clean way to initialize and test these without storing the database connection itself in your context, great! You can use request-scoped info stored in your context like the current User ID and such in your error reports when your database access fails. 
No ill will intended! For what it's worth, I can't think of any better names :)
TIL: I can use "&lt;" in struct names.
&gt; `docker --rm -ti saturnism/go-ide` should be `docker run --rm -ti saturnism/go-ide`, I presume. EDIT: I mounted my whole GOPATH inside the container so I didn't lose _anything_ after the container exited, and didn't realise I needed to run `:GoInstallBinaries` to set everything up before stuff would work. Thanks for this! It's a great idea.
Note that it's not a regular less-than character, it's a unicode character that looks similarly. http://unicode.org/cldr/utility/character.jsp?a=1438
Well, so those are two opposite ends of the spectrum - code first and database first. I think that since code is a lot more flexible than a database, it's probably a lot easier to start database first... plus then there's absolutely no ambiguity about how to define the code. In fact, you don't even need struct tags, because all the code is generated for you and guaranteed to match the DB.
I'd certainly love to see it, even with caveats about it being not a general purpose solution.
No, it shouldn't. Docker is **NOT** virtualisation, this will require a Linux host.
well that explains why it only worked with copy pasting :D thx
Heh! Thanks for link collection, I'll sort through it and perhaps tear down my repository in shame :)
No need for that. Maybe it does something different from the others. I'm planning on taking a closer look at all of them soon.
Regarding ServeHTTPContext vs ServeHTTPC... This will be resolved as per the results of this topic - https://groups.google.com/forum/#!topic/golang-dev/cQs1z9LrJDU - In summary, net/context will likely be moved into the Request struct. Chain offers a couple of experimental branches in anticipation of stdlib changes and an upgrade script will be provided (if possible) to ease the process of correcting client code. One of the experimental branch approaches will be moved into main as soon as there is some sort of surety about what which path will be taken.
&gt; [Police departments will routinely provide the reports but with sensitive information edited out][1]. Given the obviousness of this, it's pretty audacious that you're calling his [implied] idea "completely stupid". I'm very unimpressed. [1]: http://multimedia.journalism.berkeley.edu/tutorials/police-records/
Why do you assume the talks would be substandard? (nevermind, I missed the parent comment)
Sounds like a great way to run a text editor! :) Then again, I'm running IntelliJ IDEA which comes bundled with its own JRE, so who am I to judge.
Sure, but what I was getting at are there are currently ways to run docker directly on Windows (a TP release of Server I believe) and that still won't run a Linux container because it doesn't virtualise. Sure you can use Docker Machine to get a Linux host running but it's important that nobody gets confused as to why that's needed. It's not because the docker application isn't shipped for windows yet, it's because of the way containers work and a Linux container requires a Linux host to run. Maybe I'm splitting hairs here, but I see a lot of people mistaking containerisation for virtualisation and not making the connection that the host kernel is shared.
There is a circular dependency checker: https://github.com/fgrosse/goldi/blob/master/validation/type_references_constraint.go#L75
Haha, I asked myself while reading the source code why gotools.org used a different font for code vs comments after seeing the '&gt;' in the source was different than in the comments.
That's some world-class trolling right there.
&gt; I'm not sure I understand the coin flip analogy, if you mean "given a tie in quality between two candidates' submissions, we flip a coin to determine which submission is accepted.", then I would argue that it's the least biased since it's not factoring applicants' race into the outcome. I do, and it's not. With a coin-flip, you still have `P(A can give a talk at gophercon | A is female) &lt; P(B can give a talk at gophercon | B is male)`, even, if A and B are equally qualified. By replacing the coin-toss with a biased tie-breaker, we still get this inequality, but at least we reduce the difference somewhat. &gt; First of all, you've created a false dichotomy; we don't need to oppress whites or males in order to "liberate" non-whites or non-males. I agree. But we have to make whites and males worse off, to "liberate" non-whites and non-males. Because now they have privilege and we need to remove that privilege for a fair world. So, yes, that's a very true dichotomy, privilege is pretty much a zero-sum game. &gt; Of course, there is little unambiguous evidence (at least as far as I am aware) that many groups are underprivileged (for any sane definition of the word); most of the frequently-cited data I've come across is either erroneously collected or interpreted and disseminated through an ideological lens (or both). Whereas, there apparently is a whole lot unambiguous evidence that privilege does not exist? I agree that empirical sciences (in particular the one that deal with such messy things as the human brain) are hard. But it's still the best way we have to make decisions and to the best of my knowledge the science pretty much unambiguously proves this fact (though one *might* still argue about quantitative differences, if one has too much time. I don't). &gt; If it's real, then quantify it; come up with a privilege unit with a clear metric so we can talk in concrete terms. No, I really don't. By your logic, unless you can give me a unit with a clear objective metric of how much pain you feel, your pain isn't real and I can do to you whatever physical harm I want. That requirement is *clearly* nonsense. &gt; I'm not sure how your sampling analogy applies here since we're talking about selecting one of N presentations of equal quality. I think a better fairness test is: "Does a given selection process favor one race over another relative to the overall demographics of the population of candidates?" Yeah, that's what I'm doing. You just seem inclined to ignore 99% of the selection process. And you're not even doing it in a good way. &gt; In other words, if the candidates are 50% white, 25% hispanic, and 25% black, any process that selects the white candidate more or less than 50% of trials is racially biased (and thus unfair). Yeah, and the candidates are 50% male and 50% female, so the fact that the lineup was about 83% male and 17% female should say a lot. &gt; Whether or not the candidate pool should have the same demographics as the broader (global) population is a different matter Why? What is the underlying reason why this is inherently independent? What good reason can you give, that we should ignore the complete selection process, other that it confirms your views? I can give you a reason, why I want to include it (namely the fact that I want to promote equal opportunities, which means that we should strive for representational visibility), can you give me a good reason not to? &gt; However, I think we can objectively say that coupling this ideology to a programming language community unnecessarily disenfranchises people with conflicting ideologies No, I think it totally necessarily disenfranchises people with conflicting ideologies. I don't think you can have a fair and welcoming community that *doesn't* disenfranchise people who think that we shouldn't have that. &gt; it's objectively unjust and subjectively something that any proponent of social justice should oppose. Well, now you are making claims about objectivity when one sentence earlier you said that science is not equipped to answer. So, I strongly challenge that view. I think it's very much objectively just.
Can someone dumb this down for me on why I would want to use it? It seems to me that dependency injection in Go is just using interfaces. Nothing more needed. You're done. In your tests, you want a no-op logger? No worries, have one that matches your logger interface. Why use this library over plane interfaces? 
If you miss the PHP or Java world ... ;-)
I really liked this one. He walks you through his codebase and explains whats going on. http://www.alexedwards.net/blog/practical-persistence-sql
It's possible for simple CRUD operations , but for more complex queries you'd need some kind of DSL first. I think the best compromise would be an ORM with a query builder that can cache SQL queries. But it's a lot of work. In practice, code generation becomes yet another dependency to manage in a project.
Porting everything from these worlds to Go is clearly the wrong way to go, as early Go project have shown us. I'm thinking of abominations like log4go. And that's the beauty of Go: need to inject dependencies? Just add interface arguments to your constructor function. Need a factory? That's a function for you. It's that easy, and flexible enough. Just without the XML configuration files.
Just saw this on Google Tech Talks channel: Writing JSON REST APIs in Go (Go from A to Z — Zürich Gophers Meetup) - https://www.youtube.com/watch?v=2rHgpx2gClk
Iowa's great, but I don't live there. EDIT: Lol. The guy above (/u/photonsbefree74656) deleted his comment then created a fake Twitter account to harass me on Twitter. Because I don't share his politically correct views. What does the code of conduct say about that?
This is my current project, using Mongo so not sure if that's database-y enough http://github.com/chasinglogic/cardinal
We bit the bullet and started using [gorp](https://github.com/go-gorp/gorp), which turned out to be OK so far and cut down some SQL boilerplate. You can still write raw SQL with it. One thing to be aware of is that it doesn't like if you return columns that aren't in your target struct, so `select *` is frowned upon.
This looks awesome, thanks for sharing.
I must use the DB first approach because the DB Schema of ~300 tables is given by another system. Struct, Slice + general method receivers on each struct or slice type are all generated. Some functions are still missing. For special queries (for an very advanced [EAV model](https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model)) I have a SQL query to struct generator.
Minio Go library is a simple client library for S3 compatible cloud storage servers. Supports AWS Signature Version 4 and 2. AWS Signature Version 4 is chosen as default. List of supported cloud storage providers. * AWS Signature Version 4 * Amazon S3 * Minio * AWS Signature Version 2 * Google Cloud Storage (Compatibility Mode) * Openstack Swift + Swift3 middleware * Ceph Object Gateway * Riak CS 
I'd be happy to help with this. I'm experienced with Go, but I don't know much JavaScript. Here's [my github](http://github.com/nindalf), feel free to send me a PM.
Wait... encrypted passwords? EDIT: saw later that they are being hashed
There can be only one main package, there's no limit on files. 
Well, after perusing the links to packages i've come to conclusion that my little library is not so much different than others, but has one redeeming feature: it does not store context in some global variable or struct member, however tempting this may be. I'm deeply convinced that context flow should be in one direction -- from parent to children, and context-bound variables should never bubble upstream. All is ever needed to flow up from handlers is error return value. That's the second redeeming feature of my library IMO: error return values from the handlers.
I myself just recently started learning Go and found this tutorial on making APIs very interesting http://thenewstack.io/make-a-restful-json-api-go
Imagine you have a big application build out of a lot of distinct components. Goldi can be used to define how everything is wired up and makes it easy to plugin to that (think third party integrations or plugin systems) In the integration tests that go through the whole stack you may want to configure part of the stack without having to build it all up manually. In unit tests however you would still inject your dependencies as you would already.
Do you mean uni directional in the sense that you can only extend contexts as you pass them into nested handlers if it's through the interface, where as if context is exposed in the Request struct it can be modified without chaining handlers? 
Very sad to have missed the festivities at dotGo. Looks like a great time was had by all.
Exactly! 
A couple of links: http://thenewstack.io/make-a-restful-json-api-go/ https://www.nicolasmerouze.com/build-web-framework-golang/ http://modocache.io/restful-go
As a huge Go fan, I think that's a pretty reasonable analysis. Andrei's one of the good ones.
My friend just wrote this library for one of our projects at work. https://github.com/waterlink/rebecca It has some basic read and write functions. It looks like it's at the right level of simplicity to match golang.
Please, voice your concerns. This is still early enough that, given sufficiently clear code/argument, your opinion may affect the outcome. I did provide examples which might serve as a basis for additional criticism.
Yeah I agree. Seems like the Author regarded the "cutting edge" ones a little more, even though tries and tested is a better argument in this case IMO.
Is :GoInstallBinaries still supposed to install every tool vim-go supports ? For example, impl is not installed (with the latest version of vim-go).
i think its all about the recent move the authors did, golang was sold as a system programming language, but, the presence of gc and cost of abstractions (interface) put go out of this fight. but ppl still compares it with c, rust, etc.. go have amazing performace? sure better than c? i really doubt but for services, apis, network apps, etc.. did't found anything better it has a very good mix of performance, maintainability and produtivity
Wonder if one can host HTTP/2 Go application behind nginx with proxy_pass and have server push working. Will have to experiment, I guess. echo library has HTTP/2 support integrated from golang.org/x/net/http2 package. 
I think this particular point with regard to Rust is made because unlike Go Rust is attempting safety without garbage collection which I've only ever seen in academia before (such as Cyclone). Because of this novelty, Rust needs more theory than languages on well-trodden paths (or risks sinking...). I don't think that it was in any way attempting to diminish any of the other contributors; after all, he does not cite Walter Bright's achievements and the guy may have written more compilers on its own than all the other main contributors for those 3 languages combined.
I have no evidence for this, but I don't believe so. Firstly, I don't *think* nginx does HTTP/2 passthrough to the back-end, secondly I don't *think* golang.org/x/net/http2 has support for server push yet.
Both D and Rust aim for latest and fanciest things, Go is conservative and minimalistic. Completely opposite schools.
KT and RP have experience but they aren't exactly masters on the finer points of more modern type research like the people Rust has. Practically speaking, you can talk about their pedigree all you want, but the type system they managed to create is about as stupidly simple as you can get. That's a good or bad thing depending on the angle you're looking from, but what isn't arguable is that Go is missing genuinely useful things like algebraic/variant typing or a hindley-milner type system and less "idiomatic" things like polymorphism or inheritance. The reason why these were omitted could be because KT and RP lack the pedigree of more modern PL researchers, or it could be the more obvious option: Go is political as fuck. Pick your poison, Andrei covered both of them. 
I think this is dependent on what version of nginx you have. I don't think the latest on ubuntu apt-get has http2 support yet.
Agree. My example is contrived and canonical URL is better propagated up through headers in response. I gave it more thought and really don't see any serious reason to send context upstream.
No server push in x/net/http2 but I've found https://github.com/manucorporat/sse interesting. A lot of things are yet to be put together to complete the picture. But individual elements can already be used and tested in practice. 
Ummm this looks amazing
&gt; because we think that's how the world should be Great. I'm glad we agree on that much. I just wish we could agree that there's no need to couple a programming language community with an ideology at the exclusion of other perspectives. It's a very exclusive approach for a community that couples itself to an ideology of inclusivity. &gt; For all I know, no one has ever really tried falsifying it. Privilege is unfalsifiable because it has no testable definition, not because no one has tried to test it yet. &gt; Uhm, no, it doesn't. So you're telling me that 50% of the candidates were female, the quality evaluation process wasn't flawed, all ties were awarded to female candidates over male candidates, and the outcome was still overwhelmingly male? I really can't see how that's possible. I'm guessing you're using a faulty input (e.g., 50% of submissions were probably not authored by women). The only other variables are the quality assessment and the actual quality of female submissions relative to male submissions. There are no more variables. &gt; Not really. It carries with it the notion that this is what we as a community decided to be our values. "We as a community" didn't decide shit :). It was decided for us from on high, and we were told to like it or GTFO. Hardly an inclusive attitude. &gt; Frankly, I'm sick of defending our view that it's a bad thing that our industry and community is such a bad place for minorities and women and we should finally start doing something against that. Problem is no one has proven it's bad. &gt; But by that you are making an ideological choice. You just seem to ignore it, because it's your ideology. Whether or not to couple the community to an ideology is an "ideology" but it's the ideology of loose coupling, which is entirely relevant in a programming community, unlike tight coupling to a particular social agenda. &gt; There is nothing true about the fact, that a flip of a coin is fairer Sure it is. Each participant receives a 50% chance of winning the flip. No criteria about the individuals are required. As I said in one of my original comments, I'm not interested in complex, immeasurable, or infinitely-variable definitions of fairness.
Great tool, and this is even faster than grep! Thanks for sharing!
I would say Rust is not really taking from the 'latest and fanciest', and more taking from the decades of academic type system research, and combining it together in a novel way, with a keen understanding of the practicalities of day-to-day programming. It just seems fancy because it's the first time many programmers have heard of these things. It's this bridging between the academic and the practical that makes Rust's design interesting - this is less present in D and Go.
&gt; I should reinforce here that this is solely my opinion, worth what you pay for it. Copying that. Go draws me by its organization scaling promises backed by Google and third party real world use of the language. Any thoughts on C, D, and Rust in comparison?
&gt;there will be cases where sift is not the perfect tool for the job. Could you be specific - this is just as important. I see your limitations/restrictions section but that's not the same as poor-performance cases.
&gt; I just wish we could agree that there's no need to couple a programming language community with an ideology at the exclusion of other perspectives. But we can't. We as a programming language community are part of the problem, so we as a programming language community want to become part of the solution too. &gt; It's a very exclusive approach for a community that couples itself to an ideology of inclusivity. [Paradox of tolerance](https://en.wikipedia.org/wiki/Paradox_of_tolerance) -- I'm fine not tolerating the intolerant. &gt; Privilege is unfalsifiable because it has no testable definition I disagree. You could falsify privilege, because it bases upon very real, measurable effects. You could at least try to *start* there, by disproving these effects. &gt; So you're telling me that 50% of the candidates were female, the quality evaluation process wasn't flawed, all ties were awarded to female candidates over male candidates, and the outcome was still overwhelmingly male? I really can't see how that's possible. I'm guessing you're using a faulty input (e.g., 50% of submissions were probably not authored by women). The only other variables are the quality assessment and the actual quality of female submissions relative to male submissions. There are no more variables. I am (I thought you'd have noticed by now?) understanding the selection process more broadly than you. &gt; "We as a community" didn't decide shit :) Yes, we as a community did. You personally may have not. &gt; It was decided for us from on high, and we were told to like it or GTFO. This is objectively untrue. The CoC has been discussed openly on golang-nuts and everything chimed in, even more of enough of the people I wish that haven't. There just weren't very strong arguments against it. I don't know if you've noticed, but the go community doesn't have a democratic governance model. It has a very much a meritocratic one. The people who do, decide what gets done. Well, the people who do, have decided. Funny how meritocracy can play out if you suddenly are not part of the people who do, right? You may *wish* that go had a democratic governance model (which would then, by the way, bring us generics too). But hey, democracy is an ideology. Let's not mix ideologies into this, right? &gt; Problem is no one has proven it's bad. False. &gt; Whether or not to couple the community to an ideology is an "ideology" but it's the ideology of loose coupling, which is entirely relevant in a programming community What a convenient and complete BS defense. Saying "we must limit our efforts to the circle of decisions we need to do and we need to do it 100% based on merit and randomly on equal merit" *is an ideology*. It is, very much, tight coupling your ideology with how we run our community. It is very much *not different* in that sense from "we must strive for equality and representativenes of the broader population". &gt; I'm not interested in complex, immeasurable, or infinitely-variable definitions of fairness. Yeah, fine, that is your ideological privilege. We, as a community, are very much interested in fairness (leaving aside that it is not "complex", or "immeasurable", that's not the point). You are, again, very much welcome to run your own community on whatever ideology you prefer.
One day late, but happy birthday! Go is the first language I'm actually passionet about. And I REALLY mean passionet. It's wonderful to write code in Go and I will continue to preach about it anywhere and everywhere I can. Thank you for a lovely Language!
Unfortunately keynote didn't export them. Sorry for that. The talk will be released soon which shows the interactive pieces.
I'd be interested in helping as well. I can spare a few hours every night.
Very impressive. Want help adding tests and getting it to pass golint? I might quibble with it doing more than it needs to (in the Unix spirit of do one thing and do it well) but it would be a quibble - this is an awesome tool. 
Then why does even Algol 68 feel more modern than Go?
I created this library after doing longpolling notifications in a few side projects since it seemed useful. One such project is: https://github.com/jcuga/proxyblock Which is an interactive, configurable content-blocking proxy. I use longpolling to show what requests originated from the current webpage, and I show them in an injected iframe within the page. Think firebug network tab but driven by a proxy.
I actually started out using SSE, and it was great! ...but it had issues :( IE doesn't support SSE--but there are polyfills. But there are bugs in IE and the way it recycles xhr connections (by never aborting them) that cause zombied tcp connections for as long as the IE process is running. Meaning even if you close that tab or even the browser window, the TCP connection keeps getting ACKs indefinitely and you have to kill the background ie process. Part of the issue is that my server will heartbeat the SSE connection for reasons, but this is fine for any browser except IE. I asked about it on SO a while back but haven't gotten any real answers: http://stackoverflow.com/questions/30462850/ie11-sse-via-polyfill-never-terminate-connections The SSE prototype I was playing with was: https://github.com/jcuga/learning-go/blob/master/sse/sse.go I think the reason why IE won't support SSE is because it would require them to change how they do some xhr. And the way they're doing some of it is kinda weird but it's to try and squeeze out better performance. 
That’s only one example; it doesn’t mean anything. You have to test on a lot of different examples with different settings in order to see which tool is the fastest.
No, you just have to give up on the idea of a tool being the 'fastest' and nail down your actual use-case so you can determine what tool is fastest at it. It's like trying to claim a car is the fastest.. plenty of cars are the fastest, it really depends on if you're talking about 0-60 speeds, time it takes to drive from New York to California and back, towing 20 tons of weight, driving through a muddy field... Depending on what you want to do, different cars will be faster. Search tools are no different. 
not a framework, but the Gorilla toolkit is useful for composing elements of what you want [Gorilla Toolkit](http://www.gorillatoolkit.org). Used it myself when starting out and implemented the session management, logins etc in less than 20 lines of code.
Or maybe they are just incredibly arrogant schmucks like the rest of Google and felt their 40-year-out-of-date wisdom was just good enough for their peasants. :-)
Disclaimer: I work with SendGrid. While the video focuses on sending email though AppEngine, you can also send email with the [SendGrid Go Library](https://github.com/sendgrid/sendgrid-go) package main import ( "fmt" "github.com/sendgrid/sendgrid-go" ) func main() { sg := sendgrid.NewSendGridClient("sendgrid_user", "sendgrid_key") message := sendgrid.NewMail() message.AddTo("yamil@sendgrid.com") message.AddToName("Yamil Asusta") message.SetSubject("SendGrid Testing") message.SetText("WIN") message.SetFrom("yamil@sendgrid.com") if r := sg.Send(message); r == nil { fmt.Println("Email sent!") } else { fmt.Println(r) } }
The very first realistic use case I tried, had sift faster than grep. Good enough for me! If the standard use cases in my day to day are greatly improved, then it's a win. I don't have to be convinced of every possible case being fastest. 
Go's error handling is basically this: Instead of representing failure with `Failure e | Success a`, it represents failure with `Option e &amp; Option a` where exactly one of those Options is (by convention only -- this is not statically checked) `Some` and the other is `None`. This is what the convention of `func f() (a, error)` equates to. That's not elegant. That's just ignoring that tagged unions exist and are proven powerful abstractions that are strictly more useful that jerry-rigging a product type to act kind of like a sum.
While I really like error handling alot. I mean java and co are definitely not funny anymore thousands of exceptions and they throw for every fucking bullshit an exception. Ofcourse you can say this and that is exceptional also but I dislike It as It completly throws you out of context in most cases. However what I definitely dislike about errors i they dont store any info where the error happened. You could rewrap errors or create an error message for every code line where an error could appear but that would be stupid. For example a parser error is a parser error it may carry some info after how much bytes it happened and so on but this can be not enough somtimes. Often you would prefer if the error would have some info where it happened file + linenumber. This shouldnt be always enabled as reflection is slow but I think It would be cool if we could enable that errors would be created with some reflectional context. I know the correct concept how errors are implented would kinda disallow this as an error is just an interface.
There's nothing elegant in Go error handling, because it's non-existent. Errors, as correctly pointed out, are just values, which propagate through program just like every other value - via parameters and returns, unlike, for example, languages which provide an exceptional way of moving values. Error handling in Go is a pure matter of convention, with the only support from the language being the predeclared "error" interface. No matter how you gonna twist and spin it, in Go you experience extra time and space overhead even when errors in fact do not occur.
isn't this in line with the whole "no generics in Go" thing? you can easily create your own tagged union if you really need it
I agree that the Go convention isn't as bad as it seems at first, but more powerful languages have better methods like optional types that are preferable.
&gt; I definitely dislike about errors i they dont store any info where the error happened. Since `error` is an interface, wouldn't returning a custom struct implementing `Error()` help in these situations? 
That's already achievable by asserting the error to a concrete type or more specific interface. 
You can't get exhaustivity checking though. It's actually worse than that: You have to do the equivalent of if option.isDefined { x := option.get // technically unsafe/partial function call, but we 'know' it's safe due to the if check. Compiler doesn't know though and can't protect us from messing up // do stuff with x }
&gt; 1) enumerates all possible failure modes and 2) provides well-typed (aka not a fat string -_-) and customizable information about the error. Your suggestion only gives you (2), but you basically end up doing your error handling is a dynamically-typed world. You don't get (1) that way, and actually cannot properly get (1) in Go. Maybe you could go generate something that comes close.
&gt; Go you experience extra time and space overhead even when errors in fact do not occur. What kind of overhead are you talking about? Exceptions have some overhead too.
True. Maybe in Go 2 who knows. Zero values are also a pretty conceptually wrong. Not all types conceptually have a zero value (for instance, what is the zero value for a non-nillable NonEmptyList of ints? `{0}`?) And what does zero value even mean? That the bits somewhere are all set to 0? Push come to shove though, you could probably make zero values for sum types by creating a recursively-zero'd instance of the first case in the sum type. It's nutty but implicit zero types are nutty so it's a perfect fit. ---------------------------------------------------- A Go 2 with sum types that are as nice to work with as its interfaces/structs along with eradication of implicit zero values would be pretty nice. Maybe some sugar for structurally typed structs/unions would be nice too (currently you can get a properly row-typed struct-like structure by creating an interface of functions that look like this: `thing() a` and then back it with a struct, but it's a bit of boilerplate. Automating that away would be really useful). Actually, just anonymous interface values would be really cool. 
I build the core services of bestfoodnearme.com with gin. I would recommend looking at the examples and then the middleware examples. Start out small and build just one thing. use the standard template library. I would be more than happy to answer any specific questions you have
Is there a 'standard' way to wrap errors in other errors so that you can get a useful traceback? func Something(msg string) (string, error) { response, err := ETPhoneHome("I can't fly this bike forever!") if err != nil { // handle the error, often: return err } Would be nice to have something like func Something(msg string) (string, error) { response, err := ETPhoneHome("I can't fly this bike forever!") if err != nil { // handle the error, often: return error.From(err, "Something") } So what when you get an `ETPhoneHomeError` at some point and want to log it you know it came from a call to `Something`
sift is not untested - I just don't use unit tests. I think sift is good example for a software where End-to-End tests are good fit - I do not care whether a matching or output function works correctly (with test data that I as developer came up with, likely with false assumptions) - I want to know whether searching for a pattern over given data yields the correct result (program output). Every release undergoes a long fuzz testing run and regression tests, and while developing early pre-release versions of sift that found bugs that unit tests would not have found. The tests use large data collections and also random data - I hope to release that code too some day. The long functions are a price you sometimes have to pay in performance critical code as you cannot control everything (e.g. function inlining) in go. I had cases where changing unrelated code led to a 50% drop in performance. Forcing everything in one function solved the problem. 
&gt; You're conflating separate issues. No, I simply don't view them as separate. &gt; If I were pushing my own rival political agenda *But you are*. You just don't call it that because that would be admitting that your arguments are weak. You are having specific views on how these things should go and you are pushing them. It is *very much* an agenda and it's *very much* rival. &gt; Frankly, it frightens me how much liberty you and your political fellows take in defining who is "intolerant" and how we ought to be punished. What's the appropriate consequence for disagreeing with you? Should I have abuse shouted at me in public? Should I be forced from my job? Should I be arrested? Well, I would probably send you down a [slippery slope](https://yourlogicalfallacyis.com/slippery-slope), if not even make you into a [strawman](https://yourlogicalfallacyis.com/strawman). Look, again, you can have whatever views you have, that is your freedom and your privilege. You can create a community and you can run it however you see fit *and we won't care at all*. But this community has a certain governance model and that governance model is primarily meritocratic. And through it's meritocratic model it's been decided what the views of this community on equality and diversity are. And you don't like that. That is understandable. I understand you. I just find it difficult to relate to that. And I don't understand why you are so set on bending this community, instead of going forth and molding your own after your own image. If you think that such a community is better, create one. And let the models compete on their own merit. I am no longer willing to spend my time going in circles on this argument. I have far better things to do.
The only reason exception unwinding is expensive is because there's usually a stack trace involved. If you want to compare apples to apples, you'd have to compare stack trace-less exception to returning an error as a value (which never have stack traces). I'd imagine returning errors is still technically quicker, but not by nearly as much.
This is the best contribution I have read in all those performance discussions - could not have said it better.
Or any other modern variant of pushing server events to the client. But this looks like sockjs/socket.io but with only the most error prone transport implemented. 
Sorry but this is wrong. The reason why try/catch is more elegant is because exceptions *bubble* up through the stack trace. You can wrap a shitload of logic in one try/catch and handle all of your exception cases in one spot. Contrast that to checking `if err != nil` after every. single. frickin. library call. Go has many great features, the error handling situation is not one of them. As an example, grepping for "if err != nil" in the docker repo yields *5495* results. That's insanity. docker|master ⇒ grep -r "if err != nil" . | wc -l 5495
'I think It would be cool if we could enable that errors would be created with some reflectional context. I know the correct concept how errors are implented would kinda disallow this as an error is just an interface.' I'm speaking here about a toogle here. Maybe a debug mode or soemthing similar. It could be easily enforced through the command line.
The overhead of the *numerous* conditional statement for checking for error, which are executed multiple times when there isn't an error and multiple times for a single error, if there is an error. And, no, exceptions impose no overhead for the normal case of exceptions not happening. (If properly implemented, as it has been in the mainstream C++ and Java implementation for the last decade.)
&gt; But you are No, I'm choosing to decouple the programming language community from a particular social agenda that is completely orthogonal to the purpose of the community itself (unless we're talking about the "Go programming language and social progressivism community" as opposed to the "Go programming language" community). &gt; Slippery slope That only applies to hypothetical examples. As it is, numerous people have had abuse shouted at them in public and lost jobs for their politically incorrect views (most recently the Yale prof and his wife and the Mizzou president, but other high-profile examples include Eich's departure from Mozilla, Summers' resignation from Harvard, or even the owners of Memories Pizza). Indeed, someone from this reddit thread went so far as to create a fake Twitter account just to harass me there for my "intolerant views". Speaking of Summers, [here's a very relevant article about sexism in STEM fields from Psychology Today.][1] &gt; And I don't understand why you are so set on bending this community, instead of going forth and molding your own after your own image. This "community's choice" reflects a symptom of a broader problem. Increasingly, the ability to decide who is "privileged" and who is "intolerant" is collecting in the hands of one group, and they're proving themselves unfit stewards of the power. In other communities (universities, for example) things are more extreme, but it seems worth opposing here if only to keep it from growing too extreme. [1]: https://www.psychologytoday.com/blog/the-nature-nurture-nietzsche-blog/201402/the-sticking-point-why-men-still-outnumber-women-in
I think that would be possible by instrumenting the code at compile time. Using static analysis you could find all locations where error values are created and then wrap them in additional code that adds the context.
Something I commonly do is: if err != nil { return fmt.Errorf("could not foo: %v", err) }
Blog author here. Wow, I was planning on submitting the article to this subreddit tomorrow morning. I'm an avid blog consumer and check this subreddit almost everyday. But I'm new to blog writing and pushing it to the masses. Guess someone picked it up off Twitter. Well, lesson learned. Lots of great discussion and counter-arguments.
In case of multiple return values, I don't think tagged union is more elegant. It even becomes hard to reason.
 func checkErr(err error) { if err != nil { fmt.Println("ERROR:", err) os.Exit(1) } } can be reduced to: func checkErr(err error) { if err != nil { log.Fatal(err) } } 
I dislike seeing this style of "checking" every time it comes up. At a glance he error isn't being checked at all, it's being handled. Inspecting something shouldn't have side effects :/
It doesn't matter if it's an interface, it's possible to determine whether or not a value satisfies the error interface, and is used as the return value of a function returning an error value, using static analysis.
It probably always is, as values are normal flow and exceptions are.. well, exceptional cases. Go's multiple return values are very handy indeed, lot of flexibility. Trying to accomplish something similar with exceptions is even more complex and slow.
There are other ways to enforce this without the extra indirection.
How do you nicely enforce at compile-time this without sum types?
typestate checking would be one way.
How is this 'elegant'? 20 years ago, the same arguments were discussed between try-catch blocks vs handling return values to detect errors. Now that people are used to the try-catch blocks, handling return values is elegant now? Java is now the 'ye olde'? I swear programming is like following fashion trends sometimes.
OK, I'm a newbie and maybe I'm missing some subtleties, but this whole point about errors being "values" seems orthogonal to the question of exceptions. In any language with traditional `throw..catch` semantics, you can still make your errors (exceptions) represent some kind of "value" if you want: // Java, for example public class ParseError extends Exception { int lineNumber; int column; Token token; // ... } This is what confused me about the Rob Pike [blog post](https://blog.golang.org/errors-are-values) that everyone keeps citing. You want to make your errors into value objects containing useful data? Go ahead. You want to avoid cluttering your primary API methods — like in Pike's `errWriter` example — and put error-handling off the main path in a field/function that the caller can opt to ignore? Fine. But this alone doesn't imply that Go's approach is better than having additional control flow built into the language to deal with errors. A lot of the people I hear talking about this are not arguing for Go's approach per se; they're arguing for meaningful errors and clean APIs. I like those too, but that alone doesn't imply that "errors-as-return-values-*only* plus panics-that-can't-cross-package-boundaries" is superior. Jeez, if it's a design choice based on the authors' preferences, just say so!
Every day at work I see good, honest, God fearing programmers write, without a twinge of regret, `json = requests.get(url).json()` in Python without wrapping it in try/except. Go's way is better. 
Point still stands. With exceptions(assuming jvm-style) you know exactly where they came from. That's not true w/ Go errors unless you encode file/line #s in the error message which no one actually does. Code readability is great for Go error handling, as long as you just love reading `if err != nil` a few hundred times per day.
http://tip.golang.org/pkg/text/template/ Ctrl-F for "block"
We are going into micro-optimization here, which I think is a moot discussion. Anyway, if statements are quick, I mean, it has existed since the dawn of programming, and is represented by a single ASM instruction. Throwing an exception, at least last time I took CPU architecture class in college, involves rewinding the stack trace to find the frame that 'catches' it. This is a more involved operation than an if statement. Not saying try-catch is bad. For readability purposes, I think try-catch is better. Losing one micron of execution speed to capture an error is totally okay IMO. Checking return values for each function call is also not expensive, but code tends to get very long.
It's always like this.
None of the PL incorporated in Rust is cutting-edge. Algebraic types, the Hindley-Milner type system, and Rust's particular form of automatic partial proof of correctness have been around for decades.
No, I don't mean having an ORM built in. Personally, I think ORM has no place in a framework at all. Go look at something like codeigniter for PHP. You are right about MVC, so codeigniter is a framework built around that MVC pattern. It has a file for routes. You put your controllers in a certain directory, same for models, same for views. You can even have business code in a libraries folder. You don't have to do much work to develop applications VERY FAST. This is the key for an MVC framework, you don't have to put too much thought in how everything is wired up. It just works. I don't have time to pontificate and write boilerplate code over and over and over again with my go projects and using the standard net/http package. I've must have written 30 micro-services in golang now. A lot of it is duplicated functionality. I would love to see something where I can jump in and write things much quicker than I am currently writing on golang. Honestly, until you write stuff in a high level language (think rails or php) and start to knock things out in a matter of hours. I think some people won't get the problem here. Maybe I may just end up writing something for myself. I've shelved a previous effort so far. Too busy with other things that actually are making money. Thats the problem I have. Other things make money, time spend developing an mvc for golang does not.
Nothing is being discounted as it is a fact that none of Go's core team are PL theorists. Ken Thompson is probably the closes to that field, having co-developed B and C, but that is not (formal) PL research, especially because the development of C was driven more by a concrete engineering need. By a PL theorist you'd be looking more at someone like Robin Milner.
Table-based exceptions (which are used in x86-64) have zero overhead on normal execution path.
Not a good idea as the possible errors can and will change in the future.
No, totally not. I want to be able to write a quick prototype that doesn't care about error handling. Being forced to handle every failure mode is a bad thing, especially when the number of possible failure modes isn't known in advance or can change in a future language revision.
And this is the right approach because an error return is just one of the many possible values a function could return. Trying to make this case invisible by means of exceptions or such yields programs that don't adequately handle such conditions.
This is a one year old post. Also http://blog.gopheracademy.com/post/ =&gt; 404 Not Found Well, at least I can see it's running on Go. ;) But, I have to sin the fact, that you don't have a default 404 page handler defined. :)
First, error "handling" in Go requires [a lot of boilerplate](https://github.com/docker/docker/blob/release/v1.9/daemon/daemon.go#L707). But wait, that's not actual error *handling* - it's only error *propagation* - something you get for free with exceptions, but let's forget about exceptions and focus only on errors. In C++ people sometimes disable exceptions, so they also have to stick to error codes or error objects. How do they deal with that? - 7-zip uses [a macro "return-if-not-ok"](https://github.com/rdp/7zip-clone/blob/7z920.unmodified/CPP/7zip/Archive/Zip/ZipHandler.cpp#L519). Macros are considered bad, but at least the code looks pretty. - LLVM uses [`if (error err = f()) return err;`](https://github.com/llvm-mirror/llvm/blob/release_37/lib/Bitcode/Reader/BitcodeReader.cpp#L2793) which is quite similar to what we use in Go. Rust has [the `try!` macro](https://doc.rust-lang.org/std/result/#the-try!-macro). It rewrites `try!(f())` into `if let Err(e) = f() { return Err(e) }`. Unlike macros in C and C++ such macros are type-safe and friendly to tools. Functional languages have some monadic magic, which rewrites code adding all the additional checks and branching without the need to mark those places with macros. Basically compiler can add that `if { return }` if it sees that functions returns an `Error` type. --- The second concern about error handling in Go is that nothing checks that error was handled (Although some third-party static analysis tools exist). You can easily write `a, err := f(); g(a)`, or `a, err := f(); if err == nil { return; }; g(a)` and compiler won't say anything. There are no run-time checks as well. In C++ you can add a check in destructor of your error type, so that you'd get a run-time error if error wasn't checked. Things like `std::future&lt;T&gt;` don't allow you go get its value if there is an error. Same happens in Rust with its `Result&lt;T, E&gt;`. So nope, error handling in Go is not elegant at all.
So can you tell me, by looking at this pseudo code below, when exception happens, is it foo() or bar() or something down the stack? func main(){ try { foo(); } catch {....} } func foo(){ .... bar() ... } func bar(){ .... } This is why exception readability on big projects is problem and that is why there are try{} catch{} blocks around every single function call - because people can't know WTF can crash below. Instead of if err != nil you have try/catch blocks. Big improvement (sarcasm). You have similar amount of code only you lose readability + you kill performance with all those exception blocks. In Go errors are values so there is no extra penalty for err != nil calls. Unless you do just one try/catch at top level to save lines, in which case your coding skills are not for production. PS. -1 because you are still talking about handling runtime exceptions even though I clarified we are talking about source code readability.
We're not discussing individual belief systems. 
Nothing mind blowing, hacked together very fast. Though I thought anyone curious might want to see the bad go code :P
It is not. It is a concrete, independent of the individual technical solution and as such can be compared with alternative technical solutions based on objective criteria.
&gt; It screams bad coding practices everywhere. Your business logic should be decoupled from the I/O . You don't need to test if I/O works, you didn't write any of Go I/O feature. I never said I test Go I/O, and I don't see where I coupled business logic with I/O. The point was that I care most about the output of sift being correct - displaying all valid matches and not showing false positives, as that is what users care about. Your posting history shows that you are just here for ranting anyway, so feel free to carry on...
I made a pull request. https://github.com/rs/xid/pull/2 The library probably works well and there is no reason to scare people off over a simple language choice. 
I've always felt "the go way" should only involve the standard library. 
Both camel case and underscores in identifiers? Blasphemy!
I keep telling everyone Go provides all of the packages you need to develop your own framework / library / architecture... It seems like newcomers are used to having their hand held by massive frameworks like Djano, Rails, Laravel... etc.
that's practically the same as the example I gave but written in another way
Thank you for not assuming my post was rhetorical. I suppose that I can see the point being made, but due to my own preference for pragmatism I don't agree that such wisdom is rightly displaced by "good on paper" theorists. The Go authors are aiming to create a productive language which takes into consideration human conduct. Other languages tout their implementation of new hotness. So far, adoption rates are looking good for Go. There is space for every language, but market share will not tend to go to academically "neat" languages based on that principle alone. More so, as the Go compiler is improved and produces faster binaries, the foothold of non-gc languages will diminish in favor of manageable code-bases. Novel and fastest is not Go. Simple and as fast as possible is Go, and that will likely prove to be a better theory for the majority of applications.
They don't implement them for a reason. I think Rust is a great example. There's just too much going on. I like some of the ideas in the language but it comes with so many other things that make you have to think about the language. With Go you do far less thinking about the language and much more thinking about the problem. That's by design. Different strokes though. They each have their place.
Use a pointer to bool in your struct and then check accordingly for nil, true or false.
It seems I've done just about everything except database work in Go. I haven't looked at ORMs like Gorm, but I know I'd have the knee-jerk initial reaction to avoid them, as I've seen them go wrong. Would you use Gorm on a new project? Any tips for using "just enough" ORM to help, but too much to cause great pain? Also, how painful would this have been with the standard library?
Not all code is equal. Code, which solves domain problems is good. Boilerplate, repetetetetive code is bad. Code, which executes no matter if it's needed or not is bad. Code, which executes to check something already checked a zillion times is bad. 
&gt; a, err := f(); g(a) http://play.golang.org/p/AMTIOKkfYt &gt; prog.go:6: err declared and not used Now, granted, this can be tripped up if you're reusing a previous error value, but still, it's non-zero help. Not to mention muscle memory for always typing if err != nil after a line that returns an error. It sounds like a slim thing to ride on, but seriously, I've only seen unchecked errors a few times in my 3 years of writing Go.
But then you don't know if A or B failed. Very often, they can throw the same exceptions... so now oyu don't know if you need to do cleanup for B, because you don't know if it was executed or not. In practice, this should be public void xzy() { try { doA(); } catch (ExceptionFromA ex) { //handle } try { doB(); } catch (ExceptionFromB ex2) { //handle } } Which is just as "bad" as Go's errors, except you can do it this way with go's errors: function xyz() { if err := doA(); err != nil { //handle error } if err := doB(); err != nil { //handle error } } 
The thing is, my version of `xyz` is very close to your java code. That function's code is not anymore littered with `if err != nil`. Granted, those checks migrated to `doA` and `doB`, but even that can be factored out.
This is what we do. There are also NullBoolean and similar data types that slightly abstract this for you
How your code handles errors is domain logic. I don't understand what you mean about checking things a zillion times and code that checks things unnecessarily. You'll have to give examples, because that doesn't make any sense. Calling a function that might fail is necessarily a branch in your logic. Just because you don't see the branch in languages with exceptions doesn't mean it's not being performed. 
I realize this is about go, but on the subject of Postgres + Elasticsearch, y'all should look at https://github.com/zombodb/zombodb It's an actual index type for Postgres that uses ES as the index store, and it does automatic mapping generation, among many other things such as guaranteeing transactional correctness for the underlying ES index.
Brad Fitzpatrick announced in dotGo, this last weekend, that HTTP2 support is slated for Go 1.6.
You can (or awk) but sed can get ugly, and awk is a little two much for simple substitutions
is the video available yet?
goto stackoverflow.com
The article probably typo'd Shape. "is-a" is jargon in Java OOP without a clear analog in Go.
Considering panics, this applies to Go as well.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/emberjs] [X-post: JSON API Specification Made Easy : golang](https://np.reddit.com/r/emberjs/comments/3sl1l8/xpost_json_api_specification_made_easy_golang/) - [/r/javascript] [X-post: JSON API Specification Made Easy : golang (Great for Ember.js, or supporting your SPA)](https://np.reddit.com/r/javascript/comments/3sl42r/xpost_json_api_specification_made_easy_golang/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Hm, the fact that you have multiple of these of course makes it far less… good. Another thing you could do (off the top of my head and using your stuff as a starting point) would be to do: type Preparer interface { Prepare(query string) (*sql.Stmt, error) } func InsertItems(db Preparer) (insert func(*Item) (int, error), close func() error, err error) { stmt, err = db.Prepare("INSERT INTO...") return func(item *Item) (int, error) { res, err := stmt.Exec(&amp;item.Field1, &amp;item.Field2) return res.LastInsertId(), err }, stmt.Close, err } The consumer of your API would then do (error checking elided, as in your example code): insert, close, _ := model.InsertItems(env.db) for _, item range items { insert(item) } close() Several thinks are to note: a) I replaced the *sql.DB as a parameter with a custom interface that is fulfilled both by *sql.DB and *sql.Tx. This makes this function interact well with transactions too, while at the same time being a drop-in replacement :) b) I returned the closing function as an additional closure. I think this should solve most of the problems with the code. I am still not entirely convinced I like the pattern, though :)
It was accepted. Carry on folks. Lets talk about the actual implementation now :)
IMHO it would be easier to read a JSON file and marshal it to a config object.
That’s interesting; how do you find where is the issue when you find a bug without unit tests? Say e.g. the program outputs “`bar`” instead of “`foo`” how can you know which part of the code is responsible if you don’t have specific tests for each one?
This example just sent shivers down the spine... It brings memories from 15 years ago when I had to handle errors in C, where the error code was put in some global state. Why go to all this trouble when the /u/kairos version was more simpler, readable, safer... in overall better.
&gt; It makes perfect sense for anyone with competence in the domain of programming languages design and implementation. LOL, ok, whatever.
That is what it's saying, but I actually think it's bad advice. It just complicates things. You don't need a separate GOPATH for your own projects. They'll be accessible under the default GOPATH in their usual place (i.e., for me, $GOPATH/src/github.com/natefinch). I actually think it's confusing to have two gopaths, because then you have to think about whether or not code is "your" project, or someone else's and look in different spots to find them... and if you happen to have the same package in both places, one will override the other, which could be confusing. Since all packages by definition have unique addresses according to their repo URL, there's really no reason not to have a single gopath for everything.
*Heresy*
Note, after posting [an issue](https://github.com/golang/go/issues/13225) on this, Andrew Gerrand agreed with my assessment and indicated I should update the wiki to remove the advice, so I have done so: https://github.com/golang/go/wiki/GOPATH#use-a-single-gopath 
Have you seen [Hugo](http://gohugo.io)? It doesn't meet your "no metadata in posts" goal, but it's pretty awesome, and might be open to adding that as an option.
`GOPATH = ~/.golang` ? why on earth would you hide the directory where all your code goes?
SO, while I think it is great to have system level tests, like the ones you describe, it's also very useful to have unit level tests, which can be much much faster, and cover a much wider variety of test cases. Programmatically throwing data at functions is a lot easier and faster than running a binary across real files on disk. 
But you still don't know because anyone can say foo() without grabbing the error. And then what? Where is it handled? The handling can also be woven in all over the place. "Oh," says your coworker, "that's just where I logged the error. I do an additional alternate flow over here... And plus over here." You can't trust any line of code just because it starts with a variable that starts with e (e, err, e1, er, eread). 
I've done a bunch of network coding in Go, and totally agree that the code loses a lot of its beauty from all of the error checking. However, since switching to Go, I'm writing the most robust code I've ever written. Handling every single error makes me realize how much can go wrong, and with the 'defer' block, I'm cleaning up appropriately when anything does. There's no right/wrong answer here. When I explicitly handle every error, I feel more confident in what I'm shipping. 
This seems like the equivalent of Virtualenv with Python. 
What about https://github.com/manyminds/api2go ?
The hairiness points towards this pattern not being very elegant after all, tbh. You should probably replace it with a `function InsertItems(db Preparer, items []*Item) (ids []int, err error)` and similar.
If your project may not be go get'able, i use [wgo](https://github.com/skelterjohn/wgo). It sets up a new gopath and the ability to vendor your dependencies. If the project is small or has no dependencies working in your primary GOPATH is the best option/
I prefer Kairo's version too, but he pointed to the fact the Java version had advantages over go's. Just wanted to show you can separate a block of calls that can fail from error management if you really want to. The global var is not the best way to achieve this, though, and Pike's articles offers better examples. 
I didn't define any more function than kairo's original code (there's still `doA`, `doB` and `xyz`, they're just a little modified). As for the `if` statement I added, it was just there to generalize code. If `xyz` is the only function calling `doA` and `doB`, of course that's silly, but as soon as you call these functions two or three times over your package, you begin to have less if-statements (if that's a criterion at all). Anyway, this is just an illustrative toy example, but we can hardly discuss big code samples here on reddit. As for the global var, if it makes you more comfortable imagine `doA` and `doB` are methods and the underlying struct has an `error` field, or even better a `state` field (because here we're talking automaton, anyway) that has more possible states than just "ok" or "error". This is the very same idea, but then again I can't post such a code on reddit (not the right place, not enough time). 
Yes, I know about Hugo, but it can do much more than I need.
Maybe I'm misunderstanding but you made a meaningful exception there. You did not however make a value. When your method call "returns" (throws) that exception its going to stop all execution and run for the nearest catch. You can't look at the exception and decide whether you want to continue on or not unless you wrap every call in its own try/catch block. When the Go call returns an error its just a value like any other value and doesn't automatically cause any change in program flow. You must look at the value and decide on any flow change yourself. That's really the difference.
This is fancy to implement on the database side, but not interesting to use in the logic side, I was doing this at the very beginning. Here is a new pattern: type ItemOp struct { stmt *sql.Stmt Exec func(*Item) error End func() } func InsertItems(db Preparer) (*ItemOp, error) { stmt, _ := db.Prepare("INSERT INTO...") return &amp;ItemOp{ stmt: stmt, Exec: func(item *Item) error { res, err := stmt.Exec(item.Field1, item.Field2) item.Id = res.LastInsertId() return err }, End: func() { stmt.Close() }, } insertItem, _ := InsertItems(env.db) for _, item range := items { insertItem.Exec(item) } insertItem.End() Please let me know what you think about it, and thanks for the good ideas ;) 
Sure, I'm not referring to the initial learning curve, but to the full breadth of features implemented.
Because p is an integer *pointer*. The hex value you see is the memory address it points to. To get the pointed value you need to dereference it. fmt.Println(*p);
http://play.golang.org/p/-4rk8JcaMH
So you don't want to work with people who do proper and careful error handling?
This works when you are sure that the exceptions `doA()` and `doB()` can throw are disjoint, but more often than not they aren't and often you can't even say in advance what exceptions a function may throw, in Java this is less of a problem because you have to declare what exceptions a function throws, so people start to cram unrelated things into one exception instead to avoid breaking APIs in case new error cases pop up. Thus in practice when done properly, it's rather try { doA(); } catch (ExceptionFromA ex) { // handle } try { doB(); } catch (ExceptionFromB ex2) { // handle } and all of the sudden the Java approach has more boilerplate than the Go approach.
Wrapping every line with a try...catch block isn't proper error handling. It demonstrates a lack of understanding of fundamentals. Let's say we're talking about io errors. In a block of code, I don't really care which read or write failed, just that suddenly my input or output failed in some way. I can handle that in a common catch where I log the error, stage a retry, or whatever. I don't have a separate flow for every call that might fail. That's overly complicated. Code written that way is missing the point and that developer is either leaking their debug code into the repository (and practically useless debug code at that) or they are not qualified to do the job. An analogy to what you are saying: wood frame construction. The carpenter, instead of framing walls with studs spaced, say, 16" on center, makes a wall of sandwiched studs, each pressed against the other, a block of solid wood. As he is kicked off the job, he says, "I guess you don't want people building proper walls." It's not proper.
&gt; I started with Go but quickly had to go back to Ruby because Go wouldn't let me express myself the way I wanted quickly. To me, that sounds more like an unwillingness to utilize the strengths of the language. Properly structuring your code and abstracting concepts out into interfaces when appropriate makes it incredibly easy to swap out implementations or express an API succinctly.
You need to change your perspective when trying out a system programming language for the first time. (go? kinda..) Here in India students first start programming in C then C++ so on and so forth. So when he/she gets into say python they'll know all the nuts and bolts.
Well, except that the English word "is" has at least three meanings: - Existence v. non-existence: "There is a dog." "There is no Santa Claus." - Identity: "Superman is Clark Kent." "He is the criminal." - Predication: "The dog is large." "The sun is a star." Java's "is-a" relation really only encompasses predication. In contrast, Go programmers tend to think of concrete types in terms of identity, and interface types in terms of behavior. If you have two interface types, you might say that a `ReadCloser` "is a" `Reader`, but you'd never say about two concrete types that an `int` "is a" `bool` even though they fulfill all the same interfaces.
Thanks, this is quite useful xD
I don't see it as weird at all. Everybody does not have the same problems. I think that this can be seen in an opposite light as well, don't let internal issues drive the release management of large open source projects.. Before 1.5.1 I (as a not Google employee) had my own 1.5.0+patches version for a project. Since all fixes are available on github you can pick a patched version together if you really need it.
I like gb (https://getgb.io/). Project-based go development. I'm not a huge fan of $GOPATH
Personally I think that's a bit of a contrived argument. There's a pretty limited set of things that your *code* can actually do when it encounters an exception/error that doesn't involve logging it and notifying the user that something bad happened. err, res := A() if err != nil { // handle? } err2, res2 := B() if err != nil { // handle? } err3, res3 := C() if err != nil { // handle? } Ok, we have slightly better granularity into which of the 3 methods failed(at the cost of barely legible code). We still don't know if it was something deep inside any of those functions. And we STILL don't know if our *code* can do anything about it without looking into the implementation of those functions and checking for specific error message strings(god forbid they have any dynamic information in them) it may return and inspecting the resulting Error. The reality is that production systems almost always will show the user an error message and log the exception unless it falls into one of the few recoverable cases(something like retrying on a timeout). Here's a case study on influxdb: https://github.com/influxdb/influxdb/search?utf8=%E2%9C%93&amp;q=if+err+%21%3D+nil For effectively every error check, we do some combination of these 3 things: log it, panic, or return it to the callee which is then responsible for handling it. 
No Go 1.5 support, though...
I thought PHP would be similar to it, but I guess I was wrong
If you need per-project dependencies, don't use multiple `GOPATH`s, just vendor everything. `GO15VENDOREXPERIMENT` is more than capable of providing you with that isolation, and you can use git submodules (or subtrees or whatever you like) to pin exact versions of the libraries you're using.
api2go looks okay if you're starting from scratch, and are okay with their opinions on how to structure your data and their framework. If you're trying to migrate an existing library, then mine is much easier to drop into place and get the same benefits. Out of the box, as of now(since I put a bunch of work into the library today) mine includes much better error handling for Input Validation and ISEs.
I just pushed up a big commit. Check it out and let me know what you think. Need feedback. Also, I'm looking for idea's and suggestions for implementing XPath functionality not just on XML strings, but for XML-tagged structs as well. The groundwork is set up, but I'm not sure how to go about implementing it.
I'd be more than glad to help out if it weren't for my busy work schedule! You might have more luck trying to help out with a project written in Go on github. Find one you like, implement a feature or fix a bug, and request that it be pulled by the project owner. Open source contribution can be really rewarding!
It's hard to tell where you could be having a problem so I'll give you a working example instead: http://play.golang.org/p/Pym_eaDa_r
I'm down! I just started learning Go and would love to do some projects with someone to learn more. 
FYI - "young and lots to learn" will get you amazingly far in life as a programmer. I'm assuming you're a teen, or early college student? Starting early and contributing to an open source project, or creating your own things (even if not a huge hit) shows so much initiative, and you'd be surprised how many college graduates are lacking any projects outside of class. Good on you. Keep at it, even if it gets hard. 
Seems odd that Marshal can create data (using the "string" tag) that Unmarshal cannot parse. Especially for a trivial thing like this. I'd file a GitHub issue.
hey Im the author of [hero](https://github.com/gernest/hero) it is a fun project and I can help you out whenever I get the time.
Google sponsors the project, but is no owner of it. If they have a problem, they solve it on their own instead trying to influence the open source communities. As everyone should.
Theoretically they don't own it but practically they do.
You're not wrong. PHP and golang both have similarities with C/C++, but that can be said for most modern languages like java, and javascript. There are a few things that differ, but from a syntax perspective golang is pretty similar to the other languages you've written in. The biggest new concept is the idea of a pointer. It can be a tough topic to wrap your head around if it's the first time you see it, but don't let it discourage you. It's the difference between passing the data itself, and the location of where the data is stored. To help you understand your code a bit: var p *int // a pointer. This can hold the address of an int i := 42 // i is an int that exists somewhere in memory p = &amp;i // &amp;i specifies that you want to take the address of i // that address is then assigned to p. // p = the location of i fmt.Println(p) // print the value of p (the location of i) *p = 32; // * dereferences p, meaning you're saying that you // want to assign the value to what p points to, // not p. You are actually changing the value that is // stored in i. you could do a fmt.Println(*p) at // this point and see 32. fmt.Println(p) // print the value of p again, at this // point it is still the address of i. I hope this helps.
Go 1.5.1 x64 Linux Mint Sorry was sick and stayed in bed.
On DotGo last Monday there was very interesting closing presentation of Rob Pike on the simplicity of Go. I probably understood it all wrong, but I think he said other languages keep adding features resulting in more complexity. Where as Go tries to keep the language simple, although that means a lot of behind the curtain complexity. Because apparent simplicity is very difficult. I think that is very much underestimated 'out there'. To me its like Apple vs others, especially 'back in the time'. Its very hard to focus on usability. The first iphone had no keyboard, like the blackberries. And iOS lacked many other 'features' of, for example, the MS phone os. But most people did not use these features anyway. And implementing a touchscreen was actually very, very hard. It might explain why people like to use Go: its simple to learn and use. Whatever the opinion of the 'blackberry'-addicts is. 
Any reason this package is specific to Let's Encrypt or does it work with any ACME-based CA? (Also, have you seen [lego](https://github.com/xenolf/lego)?)
Thanks, this did help a bunch. I am confused on why pointers exist however, it seems rather unnecessary. When would I ever need to use this feature? 
I have already contributed to quite a few but I wan't to make my own now. But I'll try contributing to more!
cool PM me your Skype.
Yea I'm 15. I've got quite a few of my own things already (some of the code behind them kinda sucks). It's just that it gets boring to always be working alone. https://github.com/nhooyr
Pointers are used so often that it's hard to give an answer to your question. But let my try to answer on two tracks. First, you can think about what pointers are used for in Go. Basically two things: telling the compiler to reuse memory instead of copying a variable, and allowing nullable types. In the first case, you can pretty substantially lower memory costs if you don't make unnecessary copies. The second is not as important, since you could always just make a struct like { value, ok } instead, but it's still convenient sometime when you don't want to return a value to return `nil` instead as a signal that the operation failed. The second way of looking at it is according to how languages ask you to look at programming. In C, you look at it from the perspective of the layout of memory in RAM in almost exhaustive depth (not quite because you don't deal with virtual memory issues, but almost exhaustive): is this value a global or on the stack or in the heap? How many bytes does it take up? Are the bytes aligned? How will we know when the memory can be reused? PHP is at the other extreme. You can use `&amp;` in PHP to tell it to reuse references sometimes, but other than that you're not really expected to think too much about what's going on in memory. Memory is garbage collected automatically, and basically every request gets a fresh environment to do things in. Go is sort of in between. You don't need to worry about stack vs. heap or alignment, and it has garbage collection, but other than that you're expected to think through the implications of memory decisions yourself. This makes it much faster and more efficient, but it can take more work, especially when you get started.
Pointers let you modify the pointed-to value. Example: http://play.golang.org/p/pN5Ag_X7zg Languages like Python and Java (and maybe PHP, but I'm not familiar with it) just use pointers all the time under the covers; other languages like Go and C expose the distinction to the user. Using pointers all the time works fine, but has performance implications -- it's useful to be able to choose between pointer and non-pointer in your datastructures so that you can control the memory layout of your data.
Adding one more thing: In C, you can only return one value from a function, so traditionally if you wanted to return multiple values, you'd use pointers instead. Don't do this in Go! We don't need to waste time on that crap anymore. But if you wanted to do this for some reason, it [would look like this](http://play.golang.org/p/1iLtCbfweK).
So what you're saying is that "enterprise" means you're swamped with so much crap code that you're no longer able to discern what shit ends up being compiled into your binary? Sounds about right. I'm not so sure about your proposed solution, though. How is anyone able to understand the mess if you add even more code (different library versions, one per project) to it?
What is it that you want to say with this? The Go website has a nice document that tells you how to compile from source. You can have your own custom build, too!
I'm no fan of Google/NSA's but this doesn't raise alarms for me. Google may simply use hardware-optimised ASM for their farms that wouldn't be generic enough for the main project, or likewise they may patch internal network code to take advantage of datacentre networking hax they have going on which would likewise be meaningless outside Google. Frankly, does it matter? Google ships plenty of secret-source code that spies on you. It really doesn't matter whether it was written in Go, brainfuck or turtle by the time you choose to run orbinstall it, so why worry? ;)
Nothing, was asking for opinions.
The one feature I seriously miss in Go is const qualifier. I'm an expert in C++, but I understand the lack of other features. But const correctness should belong to any strongly typed language. 
Super!! Many thanks for clear this up for us (newbies)
Thanks for the answer but it looks like your code is just making the 'list' an array of strings. I'm trying to read that in as an array of integers instead. 
Thanks, I'll have to read up about that and see if it'll work.
Ah, I could've sworn encoding using json:",string" worked for slices as well. If both encode and decode ignore "string" for int slices, at least it's symmetrical. My bad.
lego seems to be more elegant and easier.
No control over input :( Definitely checking out json.Number. Just hoping there was a syntax to allow me to use normal int like the `json:",string"` does for a single item.
What did you switch to golang from? I think that's the point the parent poster is trying to make. You can have both elegance and robustness. As a matter of fact, there is nothing preventing you from ignoring errors in golang, so even the robustness argument is not strong. 
As sift is not too complicated regarding the provided functionality, most of the time it is quite obvious which part is the problem. Even if that should not be the case, it is easy to debug the saved problematic test case.
I am going to play with it and see if it matches. I don't like this kind of tools that hide how things work normally but.. I will give it a try anyway. thanks
And next time the designer hems and haws about how it'll take a few weeks and a bunch of man-hours to produce the perfect logo, then quotes a price.
Finally met an answer that accurately reflects my opinion.
Well, but he points out a difference between Go and PHP: &gt; Go was not forced upon people. It did not gain a critical mass [despite its failings](http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/) on a new platform being homsteaded by primarily amateur and hobbyist developers.
a better way might to be find a windows library (.dll) that does screenshots and then load that with gos C Pkg: `import "C"`
cool. we love agar.io Nice to see a go version.
you should allow unicode for the player name :-)
One for the server list (the master server tell you about new/dropped nodes), One for each node for ping and health checks.
Was the talk recorded and can we find it online?
the talk is in Chinese.
Is the mvc with gin available anywhere?
As far as I know golang till now, we can have only one main package and one file containing the main function!
This is cool and makes me want to dig up some of my old code to find tidbits like this. I will note that the package isn't safe for concurrent use because of the globals. I'm guessing it's related to the port, but that's a fundamental difference from QB to Go that would require a slight design change to make it more Go-ish. 
The RHS is evaluated before any assignments are done. https://golang.org/ref/spec#Assignments
Hey again everyone! Two new screencasts since I last posted: - [Building Full Stack Web Applications with Go](http://www.goin5minutes.com/screencast/episode_5_building_full_stack_webapps/) (this has been a very popular one, with over 2000 views) - [Writing Unit Tests Against HTTP Handlers](http://www.goin5minutes.com/screencast/episode_6_unit_testing_http_handlers/) Also note that these are links to the new site. You can subscribe to the email newsletter at http://www.goin5minutes.com/subscribe/index.html if you want. Enjoy!
But thats still using external library, I want it to be a single standalone .exe
This looks awesome. Is it your project? I love functional programming but have been attracted to Go lately.
I built a library (closed source, a large company owns the source code) to do just that in native go. Long story short, Find an example of how to do this in C, then translate to Go. Use the syscall library to import system DLLs and call functions.
Looking forward to your pull request. :) It's certainly an easy one.
could you give the most effective features you used in both? and tell why you switched?
Sure, if I can figure it out, will do.
I worry that Go provides a false sense of usability by making it really easy to get started. I mean, in what other language can I set two environment variables and instantly deploy my code to a Raspberry Pi? It's fantastic! But will Go have my back when I need to refactor that code in three years? Worries aside, for me it's definitely the tooling that makes the language a success. (I include the design of the module system and `go get` in the broad category of tooling.)
Yep. Same reason this prints different output: https://play.golang.org/p/BL6wDtguSF
Nope, not my project. Saw it in /r/programming and thought it should at least've been shared here :)
2016 year. It's time to write new programming language.
Objects (one object, whatever) on the left and values of objects on the right. First you take (calculate) values, then do the assignment. 
I think for a cross platform GUI more than anything we need a good plan and a good design. I think we would get the most using a design similar to database/sql: a simple UI system with drivers, so we can e.g. start designing commandline/curses and then deploy as web or GUI. The problem there is of course that SQL is a relatively well-defined language you can use on most databases, and we don't really have something like that for UI, so creating something similar, e.g. using the template system, would be a great help :). Maybe use the Glade file format for that, so we plug right in with existing external tools?
there's an awful lot of hobbyist ad tech stuff popping up in Go, but a lot of the industry is built on systems with a lot of technical debt. i think we'll start to see the industry shift slowly over the next few years.
He knows that. He wonders why the compiler doesn't provide a warning (error) when you modify the copy. Because in 90% of the times it is a bug that the receiver is a copy and you modify it (you thought it was a pointer receiver and wonder why the hell it doesn't work!).
Maybe not a compiler error, but it should definitely be a `go vet` diagnostic. Especially if the copy is not used or returned afterwards.
Can you be more specific? I'm not sure I understand what you're trying to accomplish. Are you trying to split the slice into sections of 500 each? If so, you could do something like for i := 0; i &lt; len(a); i += 500 { batch := a[i:min(i+500, len(a))] // Do something with batch } where `min` would be something like func min(a, b int) int { if a &lt;= b { return a } return b } The last `batch` might contain less than 500 elements, which sounds like it's okay given your description. EDIT: As /u/miko5054 points out, the upper slice bound is exclusive, so it should be `min(i+500, len(a))`. Sorry for the error; I haven't done slice stuff in a while!
It seems to me that there's a wing of programming that has branched off into art. Whenever I see someone say Go's not "expressive" enough or they can't "express" something the way they would like I think of art. I think of someone trying to write "elegant looking" code. I mean its compact and may do a lot with a few lines. But often to me its not readable and a lot of thought has to go into using the language to pull off these feats of expressiveness. And this is where I think Go ticks the artistic folks off. Its not about that as its designed to let you think about problems and spit out code just as you'd speak in your native tongue. You don't think about talking but do it. I think Go is popular with folks that don't want a language in their way. Its unpopular with those that want to think about the language itself and paint with it.
Is go-gtk being maintained? Would you consider this the most complete out of all the gui libs?
slicetricks says `b = append(a[:500], a[500:]...)` my guess would be skipping the append is faster (slices are just pointers to arrays so this should be fast). lena := len(a) lenb := lena/500+1 b := make([][]int,lenb) // for example ill use int for i,_ := range b { start := i*500 end := start+500 if end &gt; lena { end=lena } b[i] = a[start:end] } for i,v := range b { fmt.Println(i,":",v) } //print 
https://github.com/go-qml/qml is probably your best bet.
A pretty solid one exists in https://github.com/go-qml/qml.
I agree -- this should probably be in go vet (maybe not a compiler error, though). I'd also like to see an option in go vet to check for totally ignored function returns (ie, without an underbar).
I'm well aware of that, which is why I pointed it out. Why re-invent the wheel?
With every commit being over a year old, it doesn't look like it's being maintained...
Yeah -- you could be returning the modified copy though. Seems like a job for go vet as well
Out of curiosity - *why* do you need a native GUI framework in Go? I don't think it's a problem that many people are bent on solving. It might help to take the web app approach here. I write my web GUI's exclusively in HTML/Javascript/CSS. *That's* the language of the Web, period. That thin GUI talks REST api's to my backend, which is Go. I use Go where Go is appropriate, not everywhere for the sake of "everywhere". Sure, someone's basement project might be "Go-&gt;Javascript" generator, but: 1. It will be abandoned, guaranteed - just like the ones mentioned here 2. You're swimming against the tide Same here. Yeah, it's more *pleasant* to keep your stack Go from top-to-bottom, but that's becoming more and more a pipe dream. Write the *thin* GUI in Qt, or GTK, or Cocoa, or WPF or whatever, and if you insist on using Go, follow the web app model - make a Go RPC server and let the GUI be the client. You could still keep the majority of important code in Go. In fact, that's probably better design anyway - if you separate your layers well enough, you could then port the GUI portion to a whole different GUI toolkit down the road with less effort. 
Same here. Everything new we build, we do so in Go. Our old shit, much of which is developed in C#, is steadily being replaced by Go code. The bidder was our first component fully done in Go.
Or maybe it's stable?
The concurrency primitives and the autoscaling made Go a real pleasure for this kind of server. 
Those are already out there, and tbh I really want cross-platform above native in most cases.
Agreed, I'd rather have a consistent GUI look and behaviour of my application across all platforms than doing a 'emulation' of each platform's native GUI. I also think mobile/consoles etc have shown that users don't really have a big problem jumping between different looking GUI's as long as the core principles remain consistent, so I don't think a non-native look/feel is a barrier. And from a pure Go perspective, it would certainly be interesting to see a whole GUI framework implemented natively.
Last commit was about a month ago, but I imagine it's quite stable since it's more or less just bindings. edit - there's this for GTK3 as well, which seems more active: https://github.com/gotk3/gotk3
Yes, you want to slice to `len(a)` because it's an exclusive bound, and you want to include the last element at `len(a)-1`. `i + stride` should already give you the element *after* the batch, so that's fine.
Thank you. You can wrap the text with in all rows by setting `table.Wrap=true` and `table.MaxColWidth=n`. Or per cell too `table.Rows[x].Cells[y].Width=n` and `table.Rows[x].Cells[y].Wrap=true`. The use case i had in mind is to really improve terminal outputs and simpler API, didn't really see a reason for delineating headers/footers.
Its worth justifying why this is happening (which is definitely correct behavior). I imagine that you are prototyping that a "DeepEquals" method should return True if, at every recursive "level" of the data structure, all of its elements are equivalent. You are missing two key things: What is an element, and what happens at the _first_ level of the call? What is an "element"? Well, its the combined Type and Value of an entity in the data structure. At the first level, DeepEquals checks to see if the two arrays are equal. We can't check the Value of the array at this level _yet_ because that's a recursive call saved for the next level. But we can check the Type: `v1` has type `[]interface{}`, `v2` has type `[]string`. Already they are different, so DeepEqual doesn't even check the elements. This is related to the fact that Go does not support a covariant type system. It it fundamentally incapable of recognizing the fact that an array of _anything_ is just a composite of the type of its component elements, and instead simply gives arrays their own type. This obviously causes confusing behavior with reflection. 
After looking at the source code, it seems to be using [go.wde](https://github.com/skelterjohn/go.wde), so it might be possible to run on windows or mac.
Looks great, I wanted to buy (bitcoin) but do you really need all my info according to EU? I have bought at different places (humble bundle) with just email?
Thank you for the interest. From January 2015 EU laws require that information. Nitpick: I don't collect any information http://itch.io does :) so then they pay VAT for me.
Nope, it's "[in an alpha stage, and still in heavy development.](https://godoc.org/gopkg.in/qml.v1)"
I agree with the overall sentiment, but giving preference to everyone except white males was, by definition, discrimination. &gt; Discrimination is treatment or consideration of, or making a distinction in favor of or against, a person or thing based on the group, class, or category to which that person or thing is perceived to belong to rather than on individual merit. Whatever way you look at it, what Dave did was discrimination. &gt; Any white male programmer who thinks they're being discriminated against needs to get their head checked. The argument is literally "everyone must be treated the same", unless it's a white male, in which case, nah. You're surprised that white males get upset at that? And then suggest that maybe they have mental problems? Maybe you should have a read of the proposed Go Code of Conduct. Diversity is a great thing, but it should be done by encouraging people, not by beating others down. 
Someone's got to ask the dumb question... What's the best way of versioning my package on Github? Where should I write down the version, what tags should I make, how do I automate it?
~~I was looking at the source but go get won't work because it seems like "gitlab.com/xojoc/util" is behind a login wall.~~ Looks really cool otherwise, I was just looking for a 2D renderer.
Tags are typically used on GitHub. Take a look at the way projects like [Browserify](https://github.com/substack/node-browserify) do it. While this isn't in Go it's pretty typical. I love wouldn't necessarily automate tag creation. You can just use the `git tag` command to create them.
I find your arguments slightly flawed. I said it before, I say it again: [Semantic versions don't make sense for go](http://blog.merovius.de/2015/07/29/backwards-compatibility-in-go.html), unless you say that every API-change is a new major version. And you could do that. But that means also that what in other languages is a minor version has to be a major version for you and thus an incompatible break and a manual upgrade of your reverse-dependencies. I find your argument relating to other languages weak. "Everyone does it" is never a good argument. It means that may be the best solution discovered so far, but go never was big on settling for the best solution anyone else has found. go does things, because they make sense. I find your argument regarding incompatible version to be a *counter*argument of your point. What version are you supposed to chose, in a diamond-dependency conflict? Semantic versioning doesn't help solve this problem at all. It just amplifies it, because now you add an additional check that could prevent otherwise healthy situations from working. I find the whole section "the state of go versioning" pretty useless. You show that only half of them have semantic versioning, but you are ignoring whether or not the rest would *benefit* from them. If only the people who do API changes version their packages, that would be consistent with your observation, but also not a problem. Your point, that the versions are often out of date is just a further indication of the uselessness of versioning - it only makes sense when used rigorously and experience shows that people are *very* bad at doing stuff rigorously. &gt; It's time for the Go community to have semantically versioned releases of all packages. It's what all the mature language communities do. We should join them. I disagree.
Sorry. git pushed https://gitlab.com/xojoc/util Could you please try again? In the following weeks I'll improve the code/add documentation/stabilize the API. For now I just needed to code some games to see what's needed. Please note that http://gitlab.com/xojoc/loop right now wants colors in the BGRA format for performance reasons. I have to implement a super fast BGRA-&gt;RGBA converter (like https://godoc.org/golang.org/x/exp/shiny/driver/internal/swizzle) which is harder than what it seems or to better document this hack (its a performance hack since Xorg wants pixmaps in bgra format).
Forgot to push a file. Now fixed. Sorry for the confusion :)
4snakes is actually unmaintained and outdated (I copied it to games2d and continued there the development). I made it to compile, if you still want to try it out.
A few of my recent Go apps have been designed for pipeline processing with os.Stdin lines scanned into a string channel and fanned out to worker goroutines, with output lines fanned in via another string channel to an os.Stdout writer. I decided to move the input/output behavior into a reusable library with convenience functions for common use-cases. Reader code is pretty basic, leaning on bufio.Scanner for string tokenization, but there are some output optimizations which I think are worthwhile and after many refactoring passes I'm quite happy with the method signatures. I named this package "drain" because it's entirely designed around piping strings from a source to a destination until the source is drained (EOF is reached, or channel is closed and empty). I'd love to get some feedback on its utility and design, especially around File handling which I haven't exercised as much as Stdin/Stdout. I intend to add comprehensive test and benchmark functions in the near future.
Compile the program (before I changed "changed "var resp *http.Response = nil" from global variable to local") and let it run on http://www.baldur-garten.de/. 100% crash garantee, I let it run for 100+ times and it crashed everytime. But not after the global to local patch (but I was sick the last 3 weeks, couldn't really test it but 2-3 times).
The package managers for every major language support pinning or locking. You can have your semantic versions and lock to specifics versions so you don't break builds. If you make API breaking changes it's a major change. Lots of projects in lots of languages handle this cleanly. This isn't a new thing for the Go community to work out. It's a "me too" that everyone else has nailed.
you guys should take a look at https://github.com/oskca/sciter the gui is made of HTML/CSS so it will look the same on all platforms, its really small compared to webkit theres also Qt bindings in go https://github.com/therecipe/qt
What's happening is that both arguments are always converted to "interface{}" when passed to DeepEqual, so whether one was already wrapped in an interface before it was passed in doesn't distinguish them to the function. However, if the dynamic types of the contained values are different, then DeepEqual will say they aren't equal rather than trying to see if they have the same leaf values.
I specifically stated to think of it as a value parameter to the method. Do you want warnings for any modifications to value parameters? It might be logical to treat all value parameters in function as immutable. But that would be a different language altogether. One may want to alter something in the receiver and then pass it to another method or chain-call a method on a modified copy. That is a fully legitimate use case.
NPM has done a great job of this, semver dependencies are declared in a plain package.json file, which can reference git branches, commits, etc. I would like this in golang's standard go get functionality.
I wouldn't even vet it to be fair. It's useful for immutable APIs. Go allows immutability by construction thanks to value types.
ST2's symlink handing is totally broken on OS X, which is aggravating. Also, setting up GoSublime involved mucking around with settings to get it to recognize GOPATH. With Atom, you just have to install language-go (I can't remember if it was pre-installed) and go-plus and you're done. Everything just works and goimports, go vet and golint support are built in. The snippets like "iferr" are useful.
Those are quite the commit messages. :p
We can generate a metadata for the exported interfaces to ensure the compile-time compatibility without downloading and building all the dependent packages. Something similar to how Linux kernel modules dealing with the kernel version compatibility issue (Module symvers IIRC) may be worth considering. It's not perfect but actually needs no human intervention.
Honestly, most Gophers use the standard library for things other languages need external frameworks and libraries for. text/template for example and it's html counterpart work great right out of the box. I know several companies that just use net/http. Go's simple syntax and interfaces make external libraries overkill in a lot of areas where other languages require a custom dsl to solve the same problem.
I'm not sure I agree that the thesis is sound. Vendoring is implicit versioning and more reliable.
I know you.
Latest episode: vendoring your dependencies in Go 1.5 http://www.goin5minutes.com/screencast/episode_7_vendoring_your_dependencies_in_go/
"Frameworks" are not idiomatic in Go. Use libraries. 90% of the time the standard library (net/http in this case) is sufficient.
I did this stuff too. Scale up from 17k requests per second to 500k and add in &gt;1000 campaigns to check against each request and you start to approach what I worked on. I also pushed for open source and failed, couldn't even get a single library open sourced. Article had some pretty basic info, but having channels for requests is unnecessary as they come in via http. You can use atomics for throttling much more efficiently.
I'd suggest that you start with echo, then as you get familiar with go (both the language and the standard lib) you can work your way back to just using the standard lib (if required).
You can think of it like that, yes. Not just array indexing, but the value of every expression on the right hand side of the "=".
https://github.com/momokatte/go-drain/blob/aa3ff403f8eca650c9da983c2814c97af7798ecd/drain.go#L40-L42 Don't try so hard to be clever. You can accomplish the same thing with an if statement.
Nice simple framework. Why use this over something like gocraft/web?
The fundamental problem is, that semantic versions see compatibility as a total ordering on the set of APIs, whereas in *reality* compatibility is a partial ordering on the set of tuples (API, user of that API). This property is what I see as the death-sentence of semantic versioning for go, because if you just look at the API of a package instead of it's users, the result is that *every* API change breaks compatibility and is thus a major version, which is *far* too coarse an identifier. Just saying "every API version has a generation and if any two packages want different generations of that API they can't be used in the same project" is completely bonkers. Yet, it is the simple consequence of semantic versioning for go.
Here you can find a compiled list of web frameworks for Go, along with other tool https://github.com/avelino/awesome-go
Without having analysed your code: What kind of replication are you using? What where your goals while implementing your clustering/replication solution?
If you vendor, that is store an outside package in your repo, and there is a security update to that package or a bugfix how do you track a difference in versions? How does someone who uses your package do that? How do you audit the 3rd party packages for security releases? If you store the package in your repo and someone else depends on your package and also uses the same 3rd package how do you avoid compiling it in twice or having version conflicts? These have been seen with the new GO15VENDOREXPERIMENT. Putting packages in your repo doesn't solve the version problem. It avoids it. Imagine if people vendored OpenSSL in their projects by commit id. It would be painful and hard to tell if a vendored version was open to Heartbleed or one of the other vulnerabilities. Vendoring isn't the same as dealing with versions.
Many of the tools generate lock files by default which is what I would, personally, hope for.
If there is a good alternative for Go please point me to it. People tell me they exist but no one points me to anything in detail. Got a link? Got a pointer? The best I've heard is to do vendoring, that is store the outside package in your repo. That, unfortunately, doesn't solve the version number issue. For example, if there's a security fix how do you know you have a version with it and easily audit that? You say there's alternatives but no one talks about them or promotes them. What people do tell me doesn't address the use cases that need to be solved for which version numbers are a solution. If you're going to argue there are other ways go show how those ways can be used to handle the points brought up in my post. Otherwise you're talking around the issue without addressing the points or showing how the direction problems are being solved. I challenge people to do this because I want to know. Generics are a great and relevant example. Someone can talk about the generics use case and an alternative way to solve the same problem. When it comes to the problems version numbers solve no one is doing that for Go. When I press people to give this they can't. So, please do.
Are you running Go from the tip of master? Let's be practical for a moment. If you're against versions than why run Go from a version like 1.5? And, when they add or modify Go for a new release why don't you see that whole situation as a problem? You're arguing against it right now. Or, maybe you do run from the tip of master which is important context to know. I get the impression you're interested in the theory of SemVer rather than the practical elements of using it and the benefits you get. Basically, what happens in practice. What languages and tools have you used it in?
&gt; its not compatible with the standard handlers Then that's a reason **not** to check it out.
I think that when people say "stick with the standard library", they mean "use the packages in the standard library directly instead of wrapping them in a framework". I don't think they mean to suggest you can't use any third-party packages, because, like you say, a lot of them implement functionality that doesn't exist in the standard library.
This. I currently have a few postgres servers replicated to a read-only hot standby instance, and something like this would be interesting.
By no means popular, but my favorites because I built them: [Flotilla](https://github.com/thrisp/flotilla) -- flask like library on top of net/http [Djinn](https://github.com/thrisp/djinn) -- jinja like templating on top of html/template
You might have better luck converting the string to a []rune before indexing. http://play.golang.org/p/ORgImtR5Y2
show your fucking code
The requirements mention rsync (or some other sync command) and a password-less ssh connection between the primary and secondary. Not sure how I feel about that, personally. It's probably much easier to manage programmatically than postgres' built in replication, but I feel like it could be less reliable than WAL playback. Maybe that's all they're syncing though...
&gt; Is doing this simple thing with strings really so painful? No. 
Have a look at xHandler and the related blog post from Dailymotion which does what you need.
Yeah, thanks for confirming. I tried the following experiment to test if it was a facet of array indexing or any expression: a := 0 b := 1 a, b = b, a 
Your comment is nothing at all like the one you quoted. All you do is imply that he doesn't know how to program and doesn't even want to learn. This is rather insulting (and probably wrong) as he's likely asking the question because he wants to learn. So, unless you're saying that "You should probably stick to PHP." was your genuine, no irony suggestion, you should probably apologize for your backhanded reply, and if you can, try to answer his question.