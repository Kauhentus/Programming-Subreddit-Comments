At one point it was far faster... It also used a thread per go routine, though I don't know if that's still true.
Why is this posted here? I don't see this being about Go.
Will Hugo ever be 1.0?
Having to generate the mocks is still a drag to me. I often hope the reflection package will be extended to allow mocks to be created at runtime. 
There are a lot of major features that we would like to implement before calling Hugo to be ready for a 1.0 release. For further information you should have a look at [this](https://discourse.gohugo.io/t/roadmap-to-hugo-v1-0/2278) forum thread that discusses the roadmap towards Hugo v1.0. 
I'll take a look.
Because no one has gotten carried away with Java generics...
To me, it's the simplicity, elegance, and intuitiveness of the language. There are certainly some burrs and snags here and there, but overall, it's just easy to work with, easy to follow, easy to write good software, and easy to see how the standard library works. When it clicked for me that a net.Conn gets wrapped in a tls.Conn gets wrapped in a http.Request and a http.ResponseWriter by a http.Server... the way it all fits together is simple, clear, and fits the actual model of how these things work in practice. Talked to a guy who wanted to intercept the TCP traffic to count bytes, but couldn't get it to work with SSL. Spent about 15 minutes looking at the stdlib source (just having it available is a big advantage over C# or Java) and figured it out. Where so many languages want you to treat the standard library as a black box, Go *wants you to open the box and look inside*. I also love that the entire language spec is &lt;100 pages if you were to print it. C#'s is over 500, Java's is nearly a thousand. I read and comprehended the entire Go spec in a couple hours, and it gave me a solid understanding of how everything works; that allows me to reason about code intelligently. Other languages feel like they're made of edge cases and rarely-used features, and while you may understand the parts you use, there could always be code you look and and can't even figure out the *syntax*, let alone the actual program flow. *Ohhh, you're using this syntax that was deprecated three versions ago that I don't recognize* or *Oh I get it, you're using this brand-new syntax that was just introduced that I don't recognize* or whatever. Go has no surprises.
Last year there was an Ardan Labs workshop the day before, does anyone know if that i going to happen again?
GCC (and LLVM for that matter) is in an entirely different league of compilers than the GC toolchain (the official compiler). GC is meant to compile *very* fast, have okay-ish optimisations and a good runtime. GCC (and LLVM) is meant to knock your socks off in the optimisation department at the cost of compilation speed, but due to gccgo not being a big project, the runtime and frontend are a bit lacking, which might give some performance issues.
I resisted it for a while, but, damn if they didn't fork an open-source project and actually make it drastically better and not all... you know... Microsoft-y.
Honestly, I think Go is *great* for new programmers. It's simple, it's straightforward, it has no surprises, most simple errors are caught immediately at compile time, there is exactly one way to do most things, the standard library is very well-equipped and well-documented, and there's plenty of sample code out there. I'd highly recommend it as a first language. It might even be easier for new developers than someone coming from an object-oriented language because there's less to unlearn.
Is there a list of suggested topics anywhere? I would like to submit a CFP to speak, but want to make sure I am *pointing in the right direction.
For Python there is https://github.com/xonsh/xonsh
Excellent point, a dev team that doesn't take testability into account, and write tests from day one, is one destined to amass a megaton of technical debt. FWIW, this is still pretty common based on what I've seen with my full time work and side consulting.
This is excellent advice, however some level of contract/system testing is also good and augments a solid unit test environment. You want to make sure that Team A never breaks an API contract for Team B and vice versa.
&gt; The majority of the page load is for waiting on the server to process the request, render and send the HTML. And I’m sure you’re not surprised to hear that our back end is also almost entirely vanilla and frameworkless; built with Go, it’s got an average median response time of 8.7 milliseconds. It might not be about Go per se but it is very relevant in my opinion.
&gt; In fact, having full error traces and no frameworks to dig through makes debugging much easier, and less code overall means less problems. Another “fun” benefit is that when anything goes wrong, we immediately know it is our own fault. We don’t have to troubleshoot to determine where the bug is. It is definitely our code. And we fix it fast because we are quite familiar with our code. Also this specific part. Sure it talks about vanilla JavaScript but it could very well be talking about Go.
But it's not about Go. I believe your more proposing the fact that golang doesn't have many frameworks is a mentality that article discussed... However it isn't about Go.
&gt; I either did, or didn't -- what it seems like I did is irrelevant. Don't agree, whether you like it or not perception is a part of communication. Chatting online has loads of ambiguity. This was my way of saying that although you may not have intended to "Never say anything close to that" it came across that way to more than one person. And, I still sincerely don't see how this detail about microprocessors strengthens your point. Microprocessors know nothing about dynamic interface{} pointers nor goroutines and channels neither, and yet a large contingent go crowd won't shutup like they invented the damn things and how great they are.
When i began to read the article i thought, i bet they use Go for the backend. And finally in the end of the article : "And I’m sure you’re not surprised to hear that our back end is also almost entirely vanilla and frameworkless; built with Go," I thought it's interesting that we found the same principle in different langs.
Also I'm every time surprise when gophers who don't use framework for backend still use a framework for frontend... I don't and i'm happy to see i'm not alone !
Try asking in a cryptocurrency subreddit.
Try asking in a cryptocurrency subreddit.
Store changes (events), derive the DB state from the changes.
Sorry, my fault. You are right, it is of course an M-1 relationship between Person and Location. 
Can you still use C libraries with the gc?
Oh damn this looks interesting, thanks!
I'm still confused about what Hugo is. Is it something you can write along side your Go web app or is it like Jekyll 
its a static site generator - it uses a template and markdown files to spit out the html+css for a website, similar to Jekyll
It's like Jekyll
here is a nice intro to the technical side of bitcoin: https://www.youtube.com/watch?v=bBC-nXj3Ng4 But yeah r/golang is not really the appropriate place try r/bitcoin or r/ethereum
Haven't used it in quite a while, I think the main reason to maintain a Go frontend for GCC is that it supports more platforms than gc. Another potential benefit is that GCC supports a wider range of optmizations, despite this GCC mostly did worse than gc when I benchmarked it (quite some time ago), from what I read this was likely due to gccgo lacking escape analysis. However, in GCC 7 there is experimental support for this optimization enabled with '-fgo-optimize-allocs' , so there's a good chance that it will generate faster code than gc in more cases now, I have yet to give it a try myself, perhaps someone else has ?
While I agree that communication is key, I think you read **way** too much into what I said. As far as the Go community being excited about channels and goroutines (to hell with interface{} !) your reasoning is pretty superficial. There's a difference between a concept, an implementation, and a sustainable language ecosystem. To whatever extent goroutines and channels are not new, having them in a mainstream language that is growing in popularity is an entirely separate thing. Go is making these things mainstream for a huge group of developers, some of which know the history, some of which don't, but all of which appreciate this particular implementation and the growing ecosystem around it.
ez
that would be awesome 
It is a reasonable beginner project. If you have decent sized logs, it would be a lot more efficient to pass the search parameter to the server that has the logs and just return the matching lines vs return all the data in the logs across the network and grepping locally, although you could add that and features after your initial criteria are met. good luck! 
There tricky part is dealing with log rotation. Other then that pretty simple
Yes, through something called cgo.
Yes, the id would be correctly set on the `Location` struct.. I don't know of anyother way around ths.
Thanks for the correction.
Thanks for the correction.
Thanks for the correction.
Learning a programming language is very different than learning anything else, however there are general milestones one has to accomplish. as a disclaimer, I learn best through doing. **( An Optional first step )** learn HTML, its not really a programming language but it is extremely helpful, especially for go but stay away from web programming languages like javascript and php (explained later) ** first step** The first step before you can even begin to program would be to learn your environment. regardless of OS mac windows linux all have command line interfaces and programming requires knowledge of how to navigate them. You dont need to be able to manage your entire system from the command line but you should at least be proficient with navigating filesystems and manipulating files. Most IDEs assume since youre programming youre going to know these things (for configuration, learning file io, and troubleshooting) In order to read any programming language, you need to know how to write code, in order to write code you need to be able to read it. If you were to start with a compiled language, you could write a million lines but be missing a ; in the first variable declaration. Thats where scripting languages come in. **Second Step** The next step is to learn a scripting language. IMO Python is the best. Yes, python abstracts some things more so than other languages. However, as I mentioned Earlier, Learning to program is different than learning to write in your own language. Python is great because the biggest challenge to it is learning whitespace and proper indentation. This is also where you learn vocabulary, if you have an error in your class declaration but dont know thats what its called, you wont be able to google it. This stage you should be more concerned with being able to read through errors and your code to find your errors. (learning to count from 0 was a big challenge for me.) Although compiled languages don't care about whitespace and indentation, coworkers and people reading your code do and python will force you to use a consistent style. You should not be looking at multi-threading, or anything lower level than just manipulating variables and files as scripting languages have interpreter locks, and abstract things too much. **Optional Step** If you have any interest about storing data, or anything that would use a database, you Should learn SQL (you can do this on the days where you want to keep learning but just want to take a step back from whatever programming project you're working on ). Although there is a growing popularity for NOSQL databases, much of the learning process for that assumes SQL knowledge, and NOSQL still has trouble with general acceptance and IMO is not as powerful. Dont worry about learning the subtle differences between PostgreSQL, SQL, MySQL, MSSQL they all use SQL with a different interface. and as long as you can write SQL queries you'll be fine. **Third Step** Once you are comfortable (Easily able to do: complex functions, multiple file io, classes, loops, data structures) with python Then you can move onto a compiled language (if golang is the ultimate goal i suggest C Otherwise you can also pick C++ Java) I would stick to one of the bigger established languages as resources are easier to find and stack overflow has your answer. Here is where you get to learn the really fun stuff like pointer arithmetic, multithreading, shared memory, semaphores, linkedlists and whatnot. This stage is all about learning the finer details of programming, you could spend an entire lifetime on this step and most hobbyists do, theres not really a what to learn for this section. What you should know by the time you're ready to move on is where you want to go from here, and you'll also know how and what is best for you to be able to continue. **Things to avoid When learning** *Dead / smaller languages* There are a couple reasons for this. The first is just resources. Its hard to find answers to problems if the language isn't well known or is outdated. The other reason is pure self motivation. I wouldn't be able to get myself excited about being able to write BASIC because thats not a language you hear about all the time. mention Java to anyone and you know they've heard of it *javascript "Theres more than one way to skin a cat" javascript has found all of them, and then minor variations on each. Although javascript is a useful language, it is way too confusing as a beginner language, if you're using it for client side scripting on a webpage it gets even more confusing when dealing with extensions like jquery and Ajax) It is definitely a language to learn and you should circle back to it. When you do circle back to it you'll learn my reasons for it being a bad beginner language are exactly what make it a powerful one. *System Dependance* Both for languages as a whole and libraries for the language you're using. This may just be an issue for me, but its difficult to explain to a friend "I wrote this program but it only works on my machine on my windows vista install" There is probably a way to do whatever you're trying to figure out that doesn't depend on a system library. This doesn't apply to things like compilers, or your IDE configuration. its just the resulting code. **How to learn** When starting programming everyone eventually has the same problem. They want to program something but they don't want a huge complex project, nor do they know enough to just get on and start writing code. What I found to be the best way to learn is to find an old math textbook for $5 generally around your level of understanding (being able to read through problems you dont actually have to work through the problems, the answers are in the back) and write programs that solve the problems. First following the explanations in the book ( specifying what datapoints to find), but then going a step further and try to use as little input as possible (setting certain datapoints and the program figures out what data it has and whats missing). and you can do this with any kind of problem That doesn't involve creative thinking(like writing a non-generic letter). Sure it may look a little silly to run a whole computer program to figure out how much to tip the delivery guy accounting for time taken for delivery and traffic patterns ( API's are fun too) but its about learning and it would probably be silly to sit down and write your multiplication tables 100 times in a row but you did it at some point. TLDR; Scripted language, compiled language, look silly
Who the hell are you and are you single? Marry me! This all being said, BASIC is still the best language to get started with. One of the major flaws with Python (a scripting language, as stated in your screed, item #2) is that it does not teach new programmers about data type safety. While duck-typing could be seen as a feature in some circles, in others it tends to allow you to cause yourself problems down the line: things become unpredictable in the mental model of the Rube Goldberg contraption you are trying to put together in your head. FreeBASIC, as a representative of BASIC that I would be OK with, provides for plenty of practice regarding data type safety/constraints/manipulation, which is a very important area to understand in my not so humble opinion, even before you get into basic scripting through glue languages or actual scripting languages. I disagree with you about the things to avoid when learning, in that I ended up exploring and falling completely in love with Erlang. Once you go down into the rabbithole, you do you. This is not a trip but a journey. My first question still stands: are you single? HMU PS. I hope you are not a dude.
At heart still, yes. Depends on what we are talking about, though. Telescopes, burritos, socket wrenches?
I'm talkin poop rockets, here.
I do not understand why you would assert that 'BASIC is kind of questionable.' I believe that a bit of knowledge about the history and intended goals of the language would help understand its place in the universe: https://en.wikipedia.org/wiki/BASIC BASIC is not exactly the language to write your apps with (VB has made terrible but expansive inroads out there) yet it is a great educational language to get new programmers started before they move on to something else.
**BASIC** BASIC (an acronym for Beginner's All-purpose Symbolic Instruction Code) is a family of general-purpose, high-level programming languages whose design philosophy emphasizes ease of use. In 1964, John G. Kemeny and Thomas E. Kurtz designed the original BASIC language at Dartmouth College in the U.S. state of New Hampshire. They wanted to enable students in fields other than science and mathematics to use computers. At the time, nearly all use of computers required writing custom software, which was something only scientists and mathematicians tended to learn. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Is poop the fuel or the structural component?
Yes.
[removed]
You must be using python.
the problem lies within the license and CLA. What needs to be done is for someone to create a new Go frontend for gcc.
What problem with the license ?
google-style 3 clause bsd paired with the CLA is open source suicide. The CLA stripes all rights from its contributors. There is a reason google projects have very little contributions outside of google. EXAMPLE:The closed source version of Go for app engine benefits from EVERYONES hard work, yet google exploits the CLA, and hides this code to itsself, practically robbing the open source community. Sure anyone could take the bsd source and fork it, but then when you try to sell it, you can only copyright your changes. Google uses the CLA to get around that problem, so now all contributions can be re-licensed and sold to the highest bidder. The use of the bsd paired with the CLA grants google rights not extended to all.
I was under the impression that we had some `godoc`(?) command that could print the TODOs in our go code.
This `godoc` flag perhaps? -notes="BUG" regular expression matching note markers to show (e.g., "BUG|TODO", ".*") And there is also a feature for including known bugs in the docs (described [in the Go blog](https://blog.golang.org/godoc-documenting-go-code)) by adding a top-level comment of the form // BUG(&lt;who&gt;) &lt;description&gt; to the code that contains this bug. (Edit: formatting)
&gt; It also used a thread per go routine That's not an advantage if you ask me...
Just a few notes about making it a bit more idiomatic: - You could rename your `tests` directory to `testdata`. That way it will be ignored by `go test ./...` for example, since you don't want to actually compile, test or run those .go files. &gt; Directory and file names that begin with "." or "_" are ignored by the go tool, as are directories named "testdata". [Source](https://golang.org/cmd/go/#hdr-Description_of_package_lists) - Put `astitodo` in a subfolder `cmd`: `github.com/asticode/go-astitodo/cmd/astitodo`. That way everybody can see that it's a command that can be built. AFAIK godoc also supports this. - In the readme you can reduce the install command to just `go install github.com/asticode/go-astitodo/cmd/astitodo`. It will `get` the required packages if needed. - Rename `readme.md` to `README.md`. That way all documents are listed right next to each other. - Perhaps implement the [Stringer interface](https://golang.org/pkg/fmt/#Stringer) on type TODO. That way you can reuse it (like in your main.go).
It's ironic, but your example code is buggy :) You never close the channel in parsed, if there isn't an error in the header (leading to the range to never end). I tend to agree, that there are cases, where you wouldn't want a select, but "it looks terrible" isn't a really good argument; if you have the choice between a DoS-able server or ugly code, choose ugly code. The distinction rather comes down to whether or not the operation is likely to take significant time. If you read or write to a network connection, *definitely* use a select (and a context). If you read or write a local file, it's probably not necessary (though even then, you might think it's local, but it actually is on the network). 
Hmm yes, I think that's it. Though to be honest I tried it just before with: godoc -notes="TODO" github.com/xxx/yyy and it doesn't seem to be working.
[]string{"-host", site} will fix your problem 
That worked, thanks!
I've read it as `-O` and was about to agree with you.
[Found it.](https://golang.org/pkg/go/doc/#Note) The "note marker" needs to follow this syntax: MARKER(uid): note body Then godoc -notes="MARKER" includes this note into the doc. Tested with this local package: // Package tododoc tests the -notes feature of the godoc command. package tododoc // TODO add a colon // TODO: add an "uid" // TODO(chb): now this works and with this command in the tododoc dir: godoc -note="TODO" . which produces this output: PACKAGE DOCUMENTATION package tododoc import "." Package tododoc tests the -notes feature of the godoc command. TODOS now this works
Not surprising but a pleasing growth. But still this company's data is absolutely unreliable. For example: JavaScript... 2.606% (tiobe:rank: 7 redmonk rank: 1) Dart........... 1.330% (tiobe:rank: 24 redmonk rank: &gt; 30) Typescript.... 0.00.. % (tiobe:rank: 137 redmonk rank: 17) 
graph: https://www.tiobe.com/tiobe-index/go/
I just gotta love this line &gt; The hipster programming languages Kotlin, Elixir and Hack...
Splendid! Indeed with the "TODO(blah)" syntax it works. It seems they also keep the position of the TODO. type Note struct { Pos, End token.Pos // position range of the comment containing the marker UID string // uid found with the marker Body string // note body text } I wonder if the value contained on `Pos` and `End` are useful and if we can pretty print them somehow. I also wonder if any editor plugin uses this to print the TODOs. But even as it is, doing a `godoc -notes="TODO" .` is simple enough.
What. The. Fuck. Their data must be absolute nonsense.
You can create a buffered channel to act as a "token bucket". Create the channel and "fill" it before scraping; pass the channel to each download() goroutine and start the func with a blocking read on the channel. If a token is available, the read will unblock and the download can continue. Defer putting a token back into the channel, so the next download can commence on completion or failure of this one.
Tons of ways to go about this, but I personally would use [errgroup](https://godoc.org/golang.org/x/sync/errgroup#ex-Group--Parallel) to create N sized worker list and a single goroutine to feed them urls, pages, however you divide your work then close the channel it sends on once it's done. Have your main collect from that channel via a range loop.
Maybe I'm missing something here, but how does comparing TIOBE's ranking with Redmonk's mean TIOBE'S data is unreliable? Why isn't Redmonk's data unreliable instead?
And Go was 55 last year. I don't think Go has seen that much growth 
Eh, I should have used a defer... I guess it really comes down to the repercussions of blocking indefinitely. I personally think that having a bunch of unnecessary select blocks can actually be harmful and hide errors since it clutters the code, but they're definitely useful sometimes (I typically have a select with a timeout). I just don't think they're so important as to be recommended in nearly every case.
https://golang.org/pkg/encoding/json/#example_Decoder_Decode_stream
Wow, someone is actually programming with the standard library's handlers instead of using the X middleware/router library! Is this real life or just fanta-sea?
According to this company, Typescript is very popular in the commercial industry, but at position 137. The Dart that is unpopuler according to google trends is 17th place in this index. (From the analysis report 6 months ago) This company says that they get half of the data needed for the index from the google search engine. https://www.google.com/trends/explore?q=%2Fm%2F0n50hxv,%2Fm%2F0h52xr1 
Haha, I think the std library is sufficient enough for all the use cases I have. No reason to go fancy when it is not needed right ?
The Typescript issue stems from many translation files also ending in ".ts" file extensions. Yeah, the tiobe index is a joke. 
I agree but it has become a rare sight these days.
&gt;I also wonder if any editor plugin uses this to print the TODOs. I don't know of any Go-specific TODO plugin but VSCode has language-independent plugins to highlight and/or list TODO's (I am using the "TODO Highlight" plugin that fits my needs).
Anecdotal I know, but as a devops / sysadmin guy in the UK adding golang to my CV has made a measurable increase in bites from recruiters. I was a programmer from the age of 10 til I was 34, then I got bored and moved into Linux sysadmin stuff. Golang is the first language that has interested me since in programming again. It's not the cure for cancer that some people say, but for server-side stuff it's a league above writing 200 line bash scripts.
Had a recruiter send me a job lead that mentioned go. It's all the excuse I needed to learn go
Oh boy...
Yeh I agree. I see a lot of frameworks popping up everywhere. But they all do things different, I prefer the standard library for its nice abstractions and because code sharing is easier this way. 
Yup. I've actually got 3 golang projects ongoing, but none finished. All will be open-source but the golang community is... 'opinionated' about the way it should be written so i'm worried people will think it's crap. I'm just starting a new contract that means i'll be on a train for 2 hours a day on Monday, so i'll spend that time cleaning the code, adding more tests, which will hopefully get it to a point where I open source at least one of them.
Hah, this is really clever use of the types. It is very simple and concise, thanks! Is there a reason for `Response.Message` being a byte-slice and not a `io.Reader` (or `ReadCloser` if you will)? I also think it's questionable to return `nil` here. 1. There is an opportunity to enforce giving a response in all code paths, I think it would be useful to take this opportunity and get the help of the compiler with enforcing always giving a response. 2. To the callee, it is unclear what the end-user will see if we return nil. This adds to the mental overhead. 3. What should happens to the `http.ResponseWriter` when we return nil? 
Those sites measure different things. TIOBE measures search engine and wiki activity, whereas Redmonk measures usage via Stack Overflow and Github. This is akin to measuring interest (popularity) vs usage. If you want to know something like commercial companies spending time in one language or another, then you simply aren't going to get that because there isn't a way to gather the data. Even job postings are problematic because my company posts for C# developers but a quarter of everyone winds up using some Go and about a quarter wind up working with Python with me being in all three groupings. I think *it makes sense that trends on Redmonk would trail trends on TIOBE based upon what they measure*. In some cases, they might not fully follow through to Redmonk at all. For example, even though Go is my favorite for a lot of things and I read a lot about it, I still wind up spending a lot of my development time in C# which is where the bulk of my previous work lies. As someone else said, TypeScript itself is probably thrown off with things like translations using a .ts extension. There are probably some ways to correct that and perhaps Redmonk will be able to improve the statistic. Overall, none of our measures are going to be perfectly reliable, but **if we understand what the measures are composed of, then they can all wind up being useful**.
I'm still a little worried that it's going to be a Jack of all master of none type language because it's not as fast as C or as easy to write with as Python. However, with Google's backing, concurrency support, and the love the community gives it I feel like it's future has great potential.
I personally see it as a server-side language for anything where the equivalent bash script would be too unwieldy, or where the only alternative software is pretty old and unmaintained/unsafe. The really nice network library in stdlib really opens up possibilities. 
Go is not faster than C but it's easier to scale when you use goroutine. Compare to Python it's also not as easy to write as is, but with tooling it can become easier than Python. But most important it's easier to maintain because of simplicity of the code and static typing. It's what i saw after decades of Python+C and only few years in Go !
Certainly. I'm excited to see what happens with the language
Good suggestions! There is no particular reason why I took the byte slice instead of the io.Reader interface. I think the byte slice shows the example more clearer than using an interface. I agree with the fact that the Reader is way more flexible, i'm currently trying some things with making the `Response.Message` field a io.Reader and using io.Copy on the response writer. - I agree. Returning nil should return the same response as the standard library when you do nothing in a function which handles the http request. ```http.HandleFunc("/test1", func(w http.ResponseWriter, r *http.Request) {})``` gives 200 OK to the caller of the request. Where as returning nil in the function doesn't. (Looking into this) - It is possible to convert the pointer to a value type. This way we ensure that there is always a default value for the response returned. Even though the value is empty. I'm currently experimenting with this. If you have any more thoughts let me know, the ones given are really good.
If I change the `ServeHTTP` method on the Action type to write header 200 when the response is nil then we ensure that there always is a response written to the caller of the route. 200 OK is the same as how the standard library does it
"Hello world"[1] returns a byte. The byte representing 'e' is 101
when indexing strings, you get a single byte which can be converted back to a string https://play.golang.org/p/JQhAl7mI2V https://golang.org/ref/spec#String_types
Returned the value for the whole of the string which equal to 101?
This might be a stupid question, I don't get where the 101 came. Can you explain a lil bit more I can understand it. I'm very new to this.
Have a look at my reply on your Twitter. Hope this helps! https://twitter.com/mrxinu/status/883730005691322368
Shouldn't the signature be `type Action func(r *http.Request) *Response` If you're making the Action be an http.Handler the ResponseWriter shouldn't be needed. And the OP is not using it in any example code.
Go source code (and thus string literals) is defined to be UTF-8 encoded. Each code point (character) is represented by a sequence of 1-4 bytes. The code point for "e" is represented by a single byte with the value "01100101". When you interpret that byte as decimal you get the number "101". You will often find the specific byte patterns represented as hexidecimal numbers rather than a decimals, so you may also see places that refer to "e" as "65". https://en.m.wikipedia.org/wiki/UTF-8 https://blog.golang.org/strings 
Non-Mobile link: https://en.wikipedia.org/wiki/UTF-8 *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^89060
Sounds like you want a semaphore. There are several implementations on Github and a trivial channel based implementation is given as an example in Effective Go. https://golang.org/doc/effective_go.html#channels
Hate to be that guy, and maybe I'm just old and this is what passes for a systems administrator these days. How do you have no knowledge writing system software being a sys admin? Well that rant out of the way I'm glad you are getting your feet wet and looking to expand your skill set that will without a doubt make your life better and increase the value and opportunities within your organization. I would suggest reading thru the excellent go primers on the net. Here is some explicit suggestions. https://gobyexample.com https://golang.org/doc/articles/wiki https://dave.cheney.net https://golang.org/doc/effective_go.html https://tour.golang.org/welcome/1 Good gophering and have fun!
Indeed I found a great tutorial on how to implement here: http://skarlso.github.io/2016/06/12/google-signin-with-go/
Ah the one I linked you some days ago right? Glad you managed to make it work.
There are Two basic client-server connection options, the first being http connections (website) the other being sockets. You mention specific port so Im guessing you want socket connections. You also mention security, on sockets the key/pub method is called TLS. This is NOT the place to start, it is the place to END the basic concept before you start adding features. To start look at [golang packages](https://golang.org/pkg/). I suggest only starting out with Go vanilla packages to get used to the way Go does things. I also think that starting with domain sockets may be a little too big of a challenge to start with, first try building a couple input/output functions. then when youre ready you can redirect them into sockets. If you're dead set on starting with sockets then look at [golang net package](https://golang.org/pkg/net/)
TypeScript only seems popular because microsoft pays people to shill it. 
&gt; All will be open-source but the golang community is... 'opinionated' about the way it should be written so i'm worried people will think it's crap. I know what you mean. I wonder is this "opinionation" a thing only in the Go community? How can this issue be solved?
You can do it all in Go code, using https://godoc.org/golang.org/x/crypto/acme/autocert library. See https://blog.kowalczyk.info/article/Jl3G/https-for-free-in-go-with-little-help-of-lets-encrypt.html for a full explanation 
Excellent - even better :) Think I'll use the example in that blog as a template for my next little backend. Thanks.
Losers, I write my programs directly in bytes /s
&gt; {-0.49999999999999994, negZero}, // -0.5+epsilon What does negzero mean in the code?
The string is stored as a sequence of numbers in an array. The numbers are [ASCII](http://www.asciitable.com/) (in this case) or utf-8 (more generally). So the array that is that string contains: 72 101 108 108 111 32 119 111 114 108 100 As you can see, the 1th element (the second, because the 0th element is the first) is 101.
Convincing someone to hire you and annoint you with that title.
So, in one year July 2016 to July 2017, Golang gained 2.20 absolute percentage points, for a total of 2.363%, moving from #55 to #10. Currently, the last individually itemised language is #50, Groovy, having 0.300%. ***SEEMS LEGIT!!!***
I don't feel the answer is specific to a particular language. At my studio, my department hires junior level developers, and we look for people who have been studying in the industry and show a great capacity for learning. They may have had related programing experience but may not know our particular field very well. A junior is someone who is expected to need a lot of oversight and help when solving problems. We would usually not assign juniors full ownership of projects, but rather assign them to teams and have them work on tasks. I would say a junior should have a basic working knowledge of fundamentals in at least one language, and show they are capable of learning quickly. 
I mean, I read,package, edit one here and there but never wrote one from ground up.
It's because all the big js frameworks use it now. https://github.com/trending/typescript Nobody uses it on its own.
Negative zero. You can't do `-0` (Go changes it to just `0`), so we use `negZero := math.Copysign(0, -1)`.
Looks cool. One piece of feedback: Avoid using strings as input when the user could benefit from type safety. Specifically, things like addresses and currency pairs ideally should be types and constants to avoid (potentially catastrophic) mistakes due to a typo that a compiler could catch.
So, if yoy really want simple, just read the godoc for the net package. Specifically the net.Listener example shows a basic socket server. However, this will not be secure. Then you need to wrap the connection with TLS, and figure out how certificates should work. Then you are going to have to figure out what you want your protocol to look like, how you are going to serialize data, how to handle broken connections, etc. If you actually want to get something done that will work and be secure, save yourself the trouble and use GRPC. If you just want to learn, start with reading the "net" godoc and work your way down the rabbit hole from there.
Hey Sebastian great post! After reading your article I feel like I need to get started with vim. You just got yourself a new follower 👍
When I hire junior devs I'm strictly looking at personality (company culture), desire to learn, and work ethic.
It honestly depends on what the business the company you want to enter has. If they make API's then knowledge of how to write one, even a very simple, basic one would be appreciated for sure. Beyond that, demonstrate your ability to learn and respond positively to feedback. Those are probably the two biggest selling points for a junior profile!
I would love more llvm support for go
Thanks shazow, I'm using strings for inputs and outputs because this package shouldn't be dealing with big numbers in go. Plus... shapeshift is adding new coins nonstop. I really didn't want to update the package every time they add a new coin. 
I hire the ones who can admit they don't know the answer to a question then try to guess, especially for Jr's., but really in that regard just look to see if they have drive know basics of software development / design patterns and get on well with everyone. 
The issue with a shared counter is that you have to manage it and it's not efficient to wait for the count to drop, you either have to busy-poll the counter in a loop until it's drops low enough for your thread to start, chewing up cpu cycles that could be used by the other download workers. With the blocking nature of channels, you turn this: for count &gt;= limit { } count++ // risky race condition here ... //do work count-- into this: &lt;-tokens defer func(){ tokens &lt;- struct{}{} } //do work No busy polling on the cpu, and no race. 
A basic grasp of the language and an eager attitude. You can find lots of entry-level positions on craigslist for startups or small shops. This will help you build your CV up and also your wisdom about programming. I would recommend only joining a company that has at least one other person already doing software development in golang.
If microsoft pays people for typescript, google gets big slice of cake :) Typescript is now an official language at Google Source: http://angularjs.blogspot.de/2017/04/official-languages-at-google.html 
I don't see how being a general "good language" for a broad set of problems is really a bad thing. Go is popular right now because of this very thing.
Yeah, agreed. Channel semantics are a great way to avoid busy polling for a contended resource.
Only two examples: 1) https://redditblog.com/2017/06/30/why-we-chose-typescript/ 2) https://www.reddit.com/r/programming/comments/64e6x7/typescript_got_approved_as_internal_development/ In my opinion, typescript implements a similarity on the client side of GO's happiness on the server side. 
Thanks, steffen25! Happy to hear that! 
Developers tend to use the best tool for the job so if you are a generally good language you're not guaranteed to be used like a more narrow language that is really good at one thing. Put another way, every language has a niche. Go is awesome at concurrency but it being used elsewhere is less certain. 
I respectfully disagree about your first point. My experience shows that programmers tend to use the most familiar tool for the job (or whatever the company is using) as long as it isn't wildly inappropriate (e.g. using awk to create a webservice). However, with a set of N familiar tools, he/she would definitely use the one with the least friction for the task at hand.
Another reason to use an io.Reader especially in a net/http handler is because with extremely large payloads, if your handler can operate in a streaming fashion, it prevents one from having to load the entire request payload into memory.
Familiarity is certainly a reason people choose the tool they do, but if there's a better tool wouldn't it eventually gain enough market saturation that it edges the other language out? There can be multiple trends to language choices.
I hire junior devs based on their passion and technical potential. Being humble and transparent in what you know is paramount. But you should also show that you are willing and interested in learning everything you do not know.
Yes, definitely, but you go to war with the developers you have, etc. Given a team of expert Java developers, if they were tasked with building a highly concurrent system, they'd probably choose Java with Netty as a backing IO library instead of spending the time to get well up to speed with golang for example.
I feel like we're quibbling over details now. Can't we just agree to agree?
sure thing bud! have an upboat.
Great article! Thanks for sharing.
Thanks, Mike! 
Even someone with near zero coding experience?
&gt; A receive from a closed channel returns the zero value immediately. Not accurate, need an additional condition: if all the values sent to the closed channel before it was closed have already been received.
Helps if you know things like BigO, loops and boolean expressions, so the employer is not actually starting from zero. Willingness to learn, try and actually produce something (even if sub-par) is worth it already. You'll have teammates which should be your mentors and code reviewers, which will improve your output over time. Of course, relying on them on basic google-able shit will fuck up your karma. Edit: To revise my previous statements: junior devs usually get shit work that doesn't need senior time. If they perform this shit work well, more important tasks will be delegated and they will eventually level up. It's a learning position, but what makes it valuable is improvement over time. What makes it feasible is that your seniors see benefit from your work. Taking tasks seriously and elevating your knowledge is a good stepping stone.
I'd argue that at least basic functionality of an app/service should be created by a junior. Create a todo app, a twitter app or a guest book or something - it can be trivial, but it shows thought and design patterns and data structures knowledge. If you add unit tests you might already be hirable for a junior position without many follow up questions.
Sounds like a good way to hire. What does your hiring/interview process involve, if you can go into more detail how you estimate passion/potential fit?
I upvoted this and then upon reflection downvoted this because it's unusable advice for anyone who hasn't had experience with getting them hired. It's like "just be yourself" of platitudes. I feel like there's some ingredients required so a venn diagram between your skills and your employers skill requirements have a significant overlap so that you become hireable. A better advice would be to find out what employers are looking from and then try to get that knowledge/demonstrate that knowledge when the person is applying for the job. There's also significant overlap between employers so a little knowledge might get the OP closer to hired.
Downvoted! Please stop legitimizing TIOBE.
"as these servers can easily be used for various nefarious purposes" The concern for such AWS hostnames isn't about nefarious purposes but the fact that the certificates last 90 days while those names are extremely transient, AWS doesn't even promise they'll point to the same customer for hours, let alone days. So the problem is that the certificates would too often be misleading.
I have a number of pointed technical questions from low level stuff related to protocols, transportation etc to programming concepts, data structures and similar. And also high level database and architecture questions. The idea is not that the candidate should know it all, but it helps me placing their general skills on some kind of scale. The above is usually an online session. Following that I have two white boarding questions. The idea in those is for the candidate to, together with myself, find solutions and discuss trade offs. Through this I'm interested in their knowledge, but also in how we are working together on finding solutions and their willingness / ability to absorb my suggestions and thoughts. This together is basing the candidate on a scale between 6-12 (don't ask), where 9 and above means that he / she is good enough to hire. 
Software dev in London: I get a lot of people reaching out to me because of my Go experience. Seems like there's a bunch of Go startups in London, or nearby.
The ErrorJson implementation is unsafe. The error string must be encoded in a JSON compatible string. According to http://www.json.org/ every characters below ' ' or unicode characters above 127 must be escaped (e.g. 0x0A -&gt; "\n"). The given code looks more efficient, but if the error string contains unicode characters or newlines the resulting json string is invalid. 
&gt; how to shorting code in 50-94 lines take a look at https://github.com/jmoiron/sqlx With it you can "scan" the DB values directly into your LogInfo struct without the helper vars
Great post, but I would suggest using [neomake](https://github.com/neomake/neomake/) (or maybe [ale](https://github.com/w0rp/ale)) to handle the linting in a non blocking way.
That's a very good suggestion. I have just replaced my neomake setup I had for Ruby code to enable ALE for all file types. Here's the latest commit that enables ALE. https://github.com/sebdah/dotfiles/commit/0561d29589da8ddd36836a0e5e6f8e7b755a6652 Thanks!
Yes, thank you
Thank you, I'll try it. I hope it support reader)
There is a lot of good info in this talk. https://m.youtube.com/watch?v=MeOK1UzGHYw
- The suggestion to use an `io.Reader` is for handling large payloads without duplicating the memory allocated (efficiency). - I would suggest the `Action` type to be something like this: `type Action func(req *http.Request) Response` First this eliminates the possibility for users to both write to the `ResponseWriter` themselves and returning a Response value, resulting in subtle bugs. Second you force the caller to at least return a value, though it is still possible to return an empty value, `Response{}`.
Good question. I'd say there isn't much idiom here, but I would probably put the `io.Writer` first.
I think this is an interesting approach, thanks for writing it up. One concern I would have though is that the actual handling methods such as ```Index ``` have access to the ```http.ResponseWriter``` but really can never use it without breaking the paradigm right? So it begs the question of whether it should be passed a ResponseWriter at all as it never going to write a response, instead it is returning a response for something else to write.
Although this playlist was decent, his videos are just way too slow... Sometimes I feel like I'm just watching 5 minutes of promotion for his website only to get 25 second of pertinent information. He also always has like 10 video that are oddly repetitive for the same topic. Plus there's stuff like [that](https://www.youtube.com/watch?v=ba1v0-9fcTc&amp;feature=youtu.be&amp;t=3m33s) which makes me feel weird on the inside.
The only rule I know is that context always goes first.
I agree. It could be easily left out and there could be an optional parameter in the response object for the headers. That way we don't need the response writer as parameter anymore because everything can be done with the returning Response object. I've actually implemented this outside the blog. see https://github.com/barthr/web/blob/master/action.go There is no particular reason why I left it in. Thanks!
Updated the blog post! to reflect the things you mentioned!
Personally, I prefer input first. It makes more sense imo given you first get input and then make output.
The "idiomatic" way is to follow the variable assignment mnemonic: b := a copy(b, a) foo(b, a) In all those cases you "move" the contents of `a`to `b`. So in short, yes, put `io.Writer` first.
I'm just a pool boy... ...ok I'll stop.
Unfortunately, given [how TIOBE calculates rankings](https://www.tiobe.com/tiobe-index/programming-languages-definition/), the whole thing is a bit of a joke. They are literally counting Google search results, only for volume, with no care for actual content or activity. Their primary competitor for language rankings, Redmonk, is not much better, either. The [Redmonk rules for calculating rankings](http://redmonk.com/sogrady/2017/03/17/language-rankings-1-17/) are somewhat more complex, but at the core based on the same core flaw of trying to aggregate purely by volume with no regard for signal.
not related to your question, but line 13 ex := exec.Command("whatweb", "--color=never", fmt.Sprintf("%s", site)) doesn't need the fmt.Sprintf ex := exec.Command("whatweb", "--color=never", site)
&gt; I've decided to delete the vendor folder and go back to the simplicity of "go get" for now which seems to be getting the job done just fine. I expect this not to be a popular preference, but I've been doing that and really enjoying it. I use latest versions of the vast majority of my dependencies (I update them regularly with [Go Package Store](https://github.com/shurcooL/Go-Package-Store#readme)) without vendoring. However, most of my dependencies are: - my own packages or packages I help maintain (have push rights to) - are created by people I trust to maintain them well - are mature and don't change APIs often, and when they do, it's for the better and easy to update In the end, without vendoring, if you pick your dependencies with care, it's very easy to have 95%+ uptime. But if you want 100% uptime, then you have no choice but to vendor. Vendoring feels like a very expensive solution that makes sense to use when it's unavoidable. In all other cases, it's so much simpler and more lightweight to skip it, since it really only buys you at most 5%~ uptime.
Fixed, updated blog post! Thanks for your feedback
I'd suggest taking a look at glide (https://github.com/Masterminds/glide) You can pin versions, or pull latest. No need to keep a vendor dir committed, just a yaml defining your deps. There is also the emerging standard (https://github.com/golang/dep) which takes a similar approach
&gt; The only point I was trying to make -- and I know this is frustrating from your perspective -- is that CPU operations are typically mismatched -vs- high-level language concepts, particularly with respect to OOP, some aspects of functional languages, and semantically rich languages like Rust. This is somewhat true, but only to a certain degree. Especially when it comes to languages like C++ or Rust, many of the complexities stem from the language targeting lower level than Go where, for example, a GC cannot be used, and that's where C++ RAII or Rust ownerships come in. Ie. a lot of the complexity of these languages isn't some ad-hoc complexity designed by people being mesmerized, but arise directly from the nature of modern CPUs and memory architectures. Of course, many languages suffer from people getting carried away with abstractions too... The reasons for Go's simplicity aren't that Go is somehow closer to the simple nature of computing or CPUs. Usually Go's simplicity in the language itself moves the complexity somewhere else. Go's runtime and GC sacrifice (some) performance and low-level control over threads, ie. the complexity is moved to the runtime. Go's lack of generics sacrifices type safety and delegates complexity onto the programmer, code generators, tests, etc. Go permits shared mutability (and by consequence race conditions), delegating the complexity onto the programmer, tests, etc. Go's ducktyped interfaces and lack of classes delegate some of the complexity on correct program design. Etc. Go's mechanical environment is largely a virtual simplified world simulated by Go's runtime, rather than being some kind of a computing truth. 
I am already using `dep` for some projects. I find "go get" more convenient for the case I've described above (small projects with few and stable dependencies).
you have given a perfectly rational explanation of how you develop safely with vendoring. you didn't insult or misquote anyone. yet you are still downvoted in this sub because you are apparently violating some zeitgeist /r/golang is really becoming terrible
Relying on the GOPATH and go get is basically how Go at Google works. The GOPATH is modeled after the way Google does source control as a massive monorepo. In that world the GOPATH is the root of your repo so everything is checked in and essentially vendored already. This works really well if you have a bunch of closed source projects that share the same dependencies and you don't mind checking out the entire world or doing fun git tricks to select subtrees. I've found the most successful cases of this tend to be with multiple teams/projects with shared dependencies like auth, logging, API clients, etc. Version skew sucks, but so does having to "update the whole world", so it's a trade-off. :) Vendoring on a per project basis tends to work really well for self-contained code bases, like most open source projects whose output are executables, that you intend for others to checkout and build. It is generally not recommended to vendor inside of packages that are intended to be used as libraries by others.
if you aren't careful, vendoring can be far more misguided than just using `go get` most people don't bother rationalizing the version they fixate on, for all they know they are fixating on a version the author regretted and changed ten minutes later you need to have the discipline to regularly check your dependencies for version changes and bugfixes, no different than if you used `go get`, otherwise you may be just fixating on obsolete garbage
If it would be interesting to a room full of go devs you should submit it. 
Which trouble do you have using dep (specially for small project) ?
Yeah I always have thought this as well, but traditionally in computering the destination goes before the input.
There's no reason to use apache to host a Go webapp. The standard library server will do just fine. If you _do_ want another webserver in front of it for some reason the easiest thing to do is use it as a proxy, but I wouldn't bother unless I had specific requirements (e.g. serving it embedded at a path within an existing website or something like that). You'll find that the standard library http server and html/template give you most everything you'd want in a web development language, and there are a lot of decent third party libraries to fill in the gaps should you need them.
He seems eccentric but, fuck it, I'm going to watch it. I've been looking for a good video tutorial for go. Anyone else have any suggestions?
[removed]
IANAL, but I'm pretty sure you still own copyright on your changes. It's a license agreement not a transfer of ownership. As someone who actually worked on Go on App Engine I can assure you the changes to the toolchain aren't released mostly because they're changes that tie the runtime into the rest of the prod and App Engine infrastructure and wouldn't be useful in isolation.
https://github.com/golang/dep
How did people install dependencies before this? Seems like one of the first things you'd think off when designing a language **edit:** I'm getting this error: gh-polls is not within a known GOPATH Tried: dep ensure dep ensure --update 
What does a language design have to do with dependency management for it?
Lmfao I'm firin' it up capn'
I don't know which IDE you use, but most of the mainstream ones can wire up https://github.com/alecthomas/gometalinter and assist you in catching a lot of the smaller idiomatic problems with your code (like not checking errors, variable naming/capitalization, etc.)
Great answer, I'll give it a shot- thanks! 
I don't think you can use := in the one that doesn't work, because you've already defined signal.
Never saw it this way, makes sense!
According to "The Go Programming Language," &gt; a short variable declaration does not necessarily *declare* all the variables on its left-hand side. If some of them were already declared in the *same* lexical block, then the short variable declaration acts like an *assignment* to those variables. (page 31)
...and reading that I'm thinking, since this is in a for loop, and signal exists outside of the for loop, that's my problem. (but imo that's unintuitive... signal *exists* in this lexical block, it's just declared outside of the for loop. Based on all the other behavior of closures in Go, it seems like signal should be assigned to in this case)
I tried his Udemy course and had to stop midway through because of the eccentricities and that sometimes he was basically begging for money. 
I think you really need to rethink your entire concept of the software stack. I feel like PHP has poisoned the minds of many developers who don't realize there are MUCH better ways to do things. No need to use Apache anymore, go can handle tons of requests without the need for an intermediary proxy. 
I'm doing his web one, and I'm a bit confused about how he gets so many positive reviews. The information density is super low, and Whenever he laughs I just get the impression that he's incredibly stoned.
I don't think it's that either. [Here's an example](https://play.golang.org/p/RoTuiEk3uz). The `:=` should be working if at least 1 of the variables on the left hand side is new. This also works if they're new in the local scope. If all variables on the left hand side are declared, just use `=`
I agree with you. I think it has to do with him trying to get very personal with the crowd and make them feel "connected". A twitch-like/celebrity experience is not what I am looking for when I'm searching for study materials or courses.
Sounds like you didn't clone gh-poll into $GOPATH/src If your GOPATH and GOROOT environment variables are setup properly, you should be able to clone gh-poll like this: go get github.com/tj/gh-polls It will place it in $GOPATH/src/github.com/tj/gh-polls If you don't place things in $GOPATH/src they generally won't compile.
Interestingly we had a work on any opensource project day last Friday at work and I decided to take on teaching a few people Go and doing a small project in Go. This had to be the number one thing people complained the loudest about, they didn't really agree with having to clone projects into this special path structure. The other thing that came up was people getting go1.6 from apt, rather than downloading go1.8 from golang.org. Off course 1.6 wasn't going to work when we planned to use chi.
It only declares left hand variables. Hence, signal needs to be declared somewhere since all you are doing here is assigning to a variable with no declared scope
Todd mccloud really helped me "get" programming and golang in particular. I highly highly suggest his web programming with golang course, obviously if thats your interest in programming
Thank you! Now i use visual studio code with a few extensions. Enough for learning) 
There's no trouble. I just find "go get" more convenient for the case I've described above (small projects with few and stable dependencies).
Do you mean it does not work when you comment it out or when you replace the above lines with the commented out line?
The first example works because `foo` is undeclared even whilst `lost` is. You are allowed to use `:=` when at least one of the left hand side is undeclared - it acts as a short hand declaration for undeclared variables and an assignment for declared variables. You then simply assign the value of the already-declared variable `signal` to `foo`. The second does not work because both `signal` and `lost` are already declared. You may not use `:=` when all of the left hand side has already been declared, you must use `=`.
The answer of your question is your first sentence. Why loose the ability to know which revision of your dependencies you used when it's so easy ? It's a kind of thing that it's too late when you find out you needed it...
Good point. There's no error message (the program compiles) but generates incorrect output (because signal is being redeclared/shadowed within the block of the for loop).
signal is declared. Otherwise `signal = foo` wouldn't work.
Then do last line as a tuple and it will work. Short variable declaration fails when the variables have been declared and have scope
You say don't ask but, I feel obliged. Would you care to walk us over some example questions? ;)
Keep in mind that Glide is horribly, _horribly_ buggy. I've been using it for more than a year, and when it works, it's fine, but mostly it just craps out or does the wrong thing. In fact, the released version (0.12.3) doesn't even work on most of our repos; we have to use the development version, otherwise it randomly fails with inexplicable errors such as "could not detect VCS" or HTTP 404 (on packages that do exist). These issues have persisted across a number of releases, and even the authors seem to agree about how awful it is. If you look through the Github issues, many of them seem to be waiting for some kind of new "versioning engine" that will clean everything up. But this seems to be a long-running project that isn't ready yet. I'm really looking forward to replacing it with Dep.
You can easily serve your static files with Go: https://godoc.org/net/http#example-FileServer Or just have your Go app run on a random port and then do a reverse proxy to it from Apache/Nginx if you feel like putting something in front of Go for rate limiting.
As I said, I find it inconvenient for the case I described above. Sure without `dep` I am going to lose the ability to know which revision of my dependencies I used. But that's the thing. I never had to think about this before. By default with "go get" I have to always be on a working version. There's nothing extra to think about. It either works or it doesn't. Also with `dep` or another tool, unless you vendor your dependencies, then people have to do an extra command to build the project. And if the dependencies are vendored then you end up with big vendor folders. For example just the 2 dependencies I described above (mysql + boltdb) make a vendor folder of around 5.5MB. None of this is especially troublesome but for a small project with few and stable dependencies I find that the simplicity of "go get" goes away with those little problems and extra overhead. Anyways, based on the current answers it seems that I am not the only one that does this. I hope to see more answers and opinions but the current answers have encouraged me to keep doing it.
Thank you.
Thank you.
Thank you.
What is the signature of signal.Destroy? Unless it returns the same type as signal, you're assigning to an incompatible type in the second.
[robvdl](https://www.reddit.com/r/golang/comments/6m8kzw/what_am_i_supposed_to_do_with_a_gopkgtoml_file/djzueqe/)'s suggestion is correct Make sure you have everything [setup](https://golang.org/doc/code.html#GOPATH)
It's easier to get up votes for causing a riot... It's not just here
I think his issue is the fact he's trying to use signal after, I.e. Outside the for loops block calling fmt.Println(j) here would print "test". 
No it should, this would have wide spread consequences that would ultimately make writing programs harder. When you ask for a new variable it should do one thing, make a new variable. Not recursively search parent scopes in hopes to find a helpful landing place. It would also make concurrency harder and programs more prone to race conditions, specially for variables like "err". If you write err := in a for loop that launched a goroutine (which also uses the behavior to capture for loop variables, I.e: i := i you may have seen) you have to now use differentErr := or all goroutines will be trying to access the same address from the outer scopes defined "err" variable.
Downvoted? It's the highest-rated comment..
There's a potential middle ground - using dep or glide or similar to write a vendor.json or similar file with the "last known good" dependency version, but not requiring the use of those tools to populate the vendor/ dir after fetching the repo.
But Apache Groovy moved from #18 to #50 in one year (July 2016 to July 2017). Perhaps Golang's ranking now is no more legit than Groovy's ranking then. 
It's also kind of messy to use a variable of the same name as a package. 
Go can 1,000% be used for web development. I'm not sure where you got the information that it wasn't a web development language. In fact, Go is the easiest language I've ever come across when it comes to web development. The standard library has tools for marshalling JSON and XML, spinning up performant web servers, incorporating SSL/TLS, implementing APIs, hosting static pages, and there's even text and HTML templating built right in. I'd suggest the book called Web Development with Go by Shiju Varghese for a hands on guide to web development in Go. There are plenty of resources on the Go website about getting a basic web app setup. Also, if you're into frameworks check out Buffalo or Gin. I'd suggest not using a framework though, but the option is there. Edit: fix typos
Eh they are highly watchable at 1.5-2x speed, which fortunately udemy supports
* don't store plain text passwords in your DB and don't use SHA for your hashing function. Use scrypt or bcrypt * Use a constant-time comparison when you are checking for password hash matches * Check all your err returns and don't panic on an error, deal with it * Use standard go fmt to format your code. Most editors can be configured to do this automatically on save
I just spent my afternoon watching it. It is very basic. Good for a complete beginner in development but if you have any coding experience you can skip it. 
* don't seed random every time you generate a salt * use the x/crypto/bcrypt package * if you want to keep util.CheckError, it needs to have a signature like CheckError(err error, onError func(error)) you shouldn't just panic * don't use math/rand for crypto * don't parse your template on every render call 
Thanks for the info. Everything is pretty straight forward except I don't understand the comments on the seed random or parsing template. Are these for optimization/performance?
Thanks for the feedback. I will be implementing these.
Use `go fmt`
yep, this still bites me from time to time as well. :|
1. has completed the entire golang tour, 2. knows enough SQL to write CRUD operations 3. knows a rough time-complexity/baseline knowledge of the algorithms he or she is writing and what they are doing (for example, knows writing triple for-loops with large data sets is bad) 4. intellectual curiosity. 
ignore #1, it's irrelevant if you switch to crypto/rand which you 10000000% need to do if you're writing secure code. wrt parsing, you can cache the parsed template once so you're not redoing that work every time.
And for return parameters, `error`always comes last.
&gt; but not requiring the use of those tools to populate the vendor/ dir after fetching the repo How can this be done?
There is always someone who downvotes posts or comments for no good reason. As I am writing this, /u/sh41's comment has 19 upvotes, and this clearly shows that knee-jerk downvotes are not a typical behavior in /r/golang.
So basically, what you suggest is always using the latest dependencies via simple `go get` (i.e., no vendoring of any kind) but at the same time keep track of the last known good version of each dependency, to be able to revert to that version in case building or testing wit the latest version fails. This is indeed an interesting idea. Do the current dependency tools support this kind of "version bookkeeping without vendoring" out of the box?
&gt; (...) without installing it from Github. `go get -d` may be what you are looking for. With the `-d` switch, go get downloads a project into your GOPATH but does not install it. `go dep` should then work fine and fetch the required dependencies.
It's not quite as cut-and-dry as this if you're going to be exposing a go service directly to the big, bad Internet. I recommend reading [Filippo's post](https://blog.gopheracademy.com/advent-2016/exposing-go-on-the-internet/) on the subject. I'm working on a [little library](https://github.com/alaska/shttp) to make these best practices as easy as possible to spin up, but I haven't had time to work on it in months. As soon as I've caught up and had the time to integrate autocert, it should be a good shortcut.
Basically, `go get` doesn't know about any of the vendoring helper tools. It only knows that, if a package is in `vendor/`, to use that instead of `$GOPATH/src` for that package. The tools can usually work in one of two ways. 1. You commit the `vendor/` directory to source control. In this case, the tools just assist with figuring out what packages to get, and getting the right version of them into `vendor/`. During build time, the tool itself is unnecessary; `go get` will "just work." 2. You DON'T commit the `vendor/` directory. Instead, you just commit the `package.json` or `gopkg.toml` or equivalent file; that file just says "we want to build this using the dependencies in this file at the versions listed in the file." In this case, you're instructed _NOT_ to `go get` the package or command; instead, you fetch the source "normally" (or use `go get -d` to download, but not build). Then, you run `glide` or `dep` or `govendor` or whatever to locally create (but again, not commit) the `vendor/` directory, fetching all appropriate packages. My suggestion - and I haven't tried it myself - would be to go with option 2. Don't commit the `vendor/` directory. Then just tell people that `go get` *should* work. What should happen is that `go get` - ignorant of the `gopkg.toml` (or whatever file) goes through the normal process of fetching dependencies into `$GOPATH/src`. Anyone who encounters issues can use `glide` (or `dep` or `govendor`) to try rebuilding with the "last known good" dependencies.
&gt; This is indeed an interesting idea. Do the current dependency tools support this kind of "version bookkeeping without vendoring" out of the box? I wrote more about it as a reply to the other comment: https://www.reddit.com/r/golang/comments/6m7vic/anyone_else_find_vendoring_inconvenient_for_small/dk0kbov/?context=3 I'm only speculating based on how I've seen the tools work. I _think_ they'll all work this way out of the box. Since `go get` is completely oblivious to the tools, if you don't commit `vendor/`, just the package manifest, and never run the 3rd party tool, `go get` should use `$GOPATH/src` (including fetching any missing dependencies, at their latest commit).
&gt; and never run the 3rd party tool (...except for updating the last known good version after all tests succeed) That's the step (or rather, non-step) that was missing in my mental model of your approach. Thanks. 
1. You're connecting to MongoDB on every request, which is very slow. Instead, create one connection at start-up (the slow bit) and .Copy() that where you're currently connecting in the handlers. 2. Be clear about what HTTP verbs your handlers are to support. Currently, they can be called with any. 3. Configure a DB user for MongoDB and make your server use those credentials to login (use DialWithInfo instead of Dial to surface this) 4. Change the port MongoDB is listening on. MongoDB's default port is well-known and people scan the internet for it. Without a username and password, your database is completely open. See here: http://www.information-age.com/major-security-alert-40000-mongodb-databases-left-unsecured-internet-123459001/ 5. Use hmac.New(sha512.New512_256...) for hashing instead of the SHA algo by itself. 6. Consider reading the following (I found them very helpful when writing public-facing Go code): https://github.com/unrolled/secure https://blog.gopheracademy.com/advent-2016/exposing-go-on-the-internet/ 7. Make sure you only accept HTTPS connections and redirect HTTP traffic to HTTPS because your username and password (and obviously all user data) would otherwise be sent in plaintext. (Let's Encrypt make this free and easy, use something like autocert to generate secure certificates that auto-renew)
Hey, not sure why the current working path is getting concatenated to the clone path here? Doesn't make much sense to me.
I think he over-explains things for people who are already in the field. Lots of other courses seem to assume you're already aware of many topics. My college background was non-tech for the most part so having him thoroughly explain things in more than one way was really helpful. I haven't seen these though, just the udemy course ($40). Plus I really liked all the positive reinforcement, I have ADHD and learning new complex ideas can be quite frustrating at times. 
Design/tooling
1. Don't use `checkErr`. I explain my reasoning in [Why You Should Not Use `checkErr`](https://pocketgophers.com/checkErr/) 2. Scan directly into a struct: for rows.Next() { var item LogInfo err = rows.Scan( &amp;item.Id, &amp;item.Module, &amp;item.Message, &amp;item.Exception, &amp;item.Level, &amp;item.Timestamp, &amp;item.UserId, &amp;item.CompanyId, &amp;item.BusMessage, &amp;item.BusMessageType, &amp;item.TicketId, &amp;item.Tree, &amp;item.MachineName, ) if err != nil { panic(err) } logsChannel &lt;- item } 
Does the guy developing the package also have to work from `$GOPATH`?
Looks like your shell is appending it. I don't know what your setup is, so really I can't say. I *can* say that pulling up a PowerShell instance and running it in there will probably work, if your GOPATH is set up properly in Windows env vars. Edit: If you want a linux-like shell that plays nice with Windows, I would [suggest Cmder](http://cmder.net/).
Thanks, I'll read your article. 
Looks like you're mixing cygwin with Windows Go/Git. Does it still do this if you use go get from command prompt?
What about directly using dto structure: because i use null string type — i should paste anywhere code, for convert it to base string, for storage field as a string in RavenDb, and not as a structure with two fields
Yes
That's because the author decided to git ignore the vendor dir.
I had the same experience. I found the course unorganized and fluffy. In contrast, there are a few video courses on Pluralsight that are well worth the time and money.
Indeed, as can be seen by the absence of a vendor directory in the repository.
What you're looking for is master slave thread pooling, in most other languages, in go I think they might be called factories or something, there should be a default pooling utility in there somewhere.
Or gorilla, which is a more library like alternative!
I haven't read your code in detail, but seems like a problem concerning when your append allocates a new array, and how you handle your pointer to it. The append function realocates an array when it's size runs out, it seems like in your recursive function the caller holds the slice poiting to a different array than callee. I highly doubt this is a bug in go. But who knows, maybe you've struck gold :P It might also be the type conversion you do in the bytes for loop int(i) &lt; len(list) ; i++ Curious though. I'll see if i can dig a little deeper when I get off work.
It has something to do with the re-use of the `result` slice indeed: https://play.golang.org/p/11f4UFsPF6 works (I only added line 25) Not sure why the `int` implementation works though
In go sharing state by communication is preferred by many, but that does not mean that it is always the best solution. If the state is Big it could make sense to share a Pointer to this state and then relying on Mutex for locking. Look at what the sync and sync.Atomic Packages provides. It could be helpful. For your second idea (keeping the go routines open and communicating moves): That is easily doable. Just have your go routines read the moves from a Channel (one channel for each routine) and write the results to a different channel (only one channel). func routine(initialState WorldState, moves chan MoveType, results chan ResultType) { for _, v := range moves { // Evaluate move here results &lt;- result } } You would also need a Go Routine that reads the results channel and supplies the Moves to the moves channels on each iteration. It could also be helpful to have a WaitGroup to signal that all the results of this iteration are written to the results channel and that the next iteration could start.
A lot of the use-cases I've seen for using Go at the moment have either been for CLI tools, or web services (i.e. not web applications). I think Go is perfectly capable at making web applications, but many people choose to use it as a web service backend, and then use a JavaScript client-side front-end. With regards to things like `mod_go`, that's not how Go works. Go _is_ the server, unlike with a language like PHP. It's not necessarily recommended to expose a plain, unconfigured Go server out at the internet though. You can either learn about the options you'd need to set to make Go able to do that, or you can whack something like Nginx or HAProxy in front of it. Many people deploy Go web services/apps as Docker images because it's incredibly easy to package them up, they run quickly, and the image size is tiny.
Answer: size classes. When Go allocates objects it tries as hard as possible to allocate using a [size class](https://golang.org/src/runtime/sizeclasses.go) So, let's look at what happens in the `int` version: 1. Loop 0: result is size 0. Allocate 8 bytes (int is 4 bytes in the playground). This means the underlying array is of length 2. 2. Loop 1: result is size 2. Append simply adds to index 0. No reallocation necessary 3. Loop 2: result is size 2. Append simply adds to [1]. No reallocation necessary 4. Loop 3: result is size 2. Need to add one more, so reallocate array - 16 bytes this time. This makes the length 4. And so on and so forth. Now look at the `byte` version: 1. Loop 0: result is size 0. Allocate 8 bytes. This means the underlying array is of length 8. 2. Loop 1: result is size 8. No need to allocate, just add to the result. ... never needs to allocate, hence only 7 is added to it. I had originally written a slightly nastier comment earlier, because the algorithm is wrong. The `byte` example is the technically correct answer. If instead of passing in an empty slice, pass in a `make([]T, 0, 4)` and you can quite easily see where the algorithm goes wrong.
other programs might want to specify a port using an environment variable too ;) if you're returning a value, maybe, and then checking for it, either use the nil value to represent "no return", or use an "ok" value to indicate whether it was successful. so your account.AuthenticatedUser func should probably either return nil for "no such user" or return result, ok It's been mentioned before, but *really* don't store passwords in the databse in plaintext. There's literally no point encrypting passwords if you also store them in plaintext in the database. The separation of concerns between util and account seems really weird. GetUserFromSession feels like it should definitely be in account not util. Maybe provide a GetCookieValue func in util and then call that from account to get the user name? consider using named blocks to reduce the amount of boilerplate and repetition in your templates - defining a standard header block and a standard footer block will save you hassle later. otherwise, a good start :)
Yep, that's it. I was debugging step-by-step and had just noticed the `cap` difference when I saw your answer.
also check out https://www.jetbrains.com/go/ I really like it and find it super useful.
I did try it, but something goes wrong and returned to vs code 😁
Just a side note, the inner loop is unnecessary and can be removed, and then the "used" slice is never used, so it can be removed as well.
Wow, size classes, nasty pitfall. Thanks for pointing it out, it's clear and logical, now.
Yes, you're right, thanks.
I am new to programming, have done scripting with BASH and Python, and find his videos very helpful. However, I hate how he chuckles at every fucking thing.
He also re-explains things... a lot. I'm new to Go and programming in general, but I still think he goes over the same concepts and examples over and over again, which is unnecessary in a video that you can just replay if you need to. I like the content, it's very helpful to me, I just wish it was a little more streamlined. 
Some minor thoughts: * Please, define your fields and functions bound to the Machine object. Now you basically have an entire class + methods declared inside func New(..) * Machine. * '&lt;-time.After(50*time.Millisecond) // small pause to let things react', this is not a proper way to prevent a race condition. When your CPU is at its limit, waiting 50ms is not going to prevent much. * Be consistent in catching errors. 'conn.SetWriteDeadline(time.Time{})', in your write function you handle the error on the first write deadline set, but ignore it in the second. AFAIK you can ignore both, as this method always returns nil. Correct me if I'm wrong. * On a write error, your connection is broken but not yet closed I believe. I don't think you're closing it correctly (or at all) in this scenario. General thought: I've created a similar WS connection service like this before, and found that async writing and use of channels made it hard for me to correctly handle write errors. You allow 8 messages to be pushed on the write channel, meaning up to 7 messages stand in between a possibly send-retry attempt if something goes wrong. Having a function like: func Write(msg []byte, msgType int) err { .. } makes this easier. Just my 2 cents.
Thanks, your example with `err` helped me understand why Go chose to do it this way.
Notice, on any write error the writing goroutine shuts down and the error gets passed to the main control goroutine, where the connection gets closed explicitly: https://github.com/aglyzov/ws-machine/blob/master/machine.go#L307 Which in turn also shuts down the reading goroutine. The error finally gets passed to the user via the Status channel. Anyway, if you find a mistake a pull requst with a broken test case would be a productive help/feedback. Thanks. 
If your strings are nullable in one place but not the other, you will lose data. Carefully consider what you have (e.g, in Postgres) and what you want (e.g., in RavenDB). Only after you have figured these out can you begin working on a method that takes what you have and turns it into what you want.
and that is correct.
Looks like Kataras is hiding behind an alter ego now. https://github.com/kataras/iris/issues/664
Ultimately it's your choice. I would add codegangsta/inject as a more hated lib, and "dependency injection" as a principle that doesn't translate well to Go, and people will shoot you down if you try. The argument about idiomatic code is valid and makes your code better. If the objections against Iris are similar, you should probably listen.
The objections against Iris aren't primarily about idiomatic Go. These two links are a good start to why. http://www.florinpatan.ro/2016/10/why-you-should-not-use-iris-for-your-go.html https://github.com/avelino/awesome-go/pull/1137
And he closed the issues, nothing weird there...
There's also some performance issues with TLS (https) - citation needed as I'm replying on phone, and having a nginx proxy is generally a good idea anyway, because you can easier handle vhosts, CORS headers, caching, etc.
I'd recommend goreportcard for automatic and simple score of your code. https://goreportcard.com/report/github.com/brianhodges/golang-mongodb-users
You are wrong. Simple as that. When you sign the CLA you are signing over the right for google to rebrand that code with a different license. Then with the changed license, google now has the ability to do what they please with that code, even sell that code, or further edit that code under the new license, effectively removing all their new contributions from open source arena. And to further compound problems, the new license may not be compatible with the open source agenda, effectively making this new codebase useless to the open source agenda. Sure you still have a claim to the old code under the bsd license but google also now has a new claim to the code that you signed over to them. They could at any time decide to drop support for the bsd branded code and use the new in house code that was rebranded, effectively leaving the open source community high and dry. This is what is happening with app engine code, even though you deny it. And regarding app engine, if that is the case then release the sources. Google won't, and the reason are stated in the above comment.
[removed]
I would pick a package that has better support and less drama. In the long haul it is the only true option.
Good to see that we all agree
I wonder if the maintainer of Ion (advertised on Iris' github page - https://github.com/get-ion/ion) is kataras in disguise. So many suspicious aspects. Could all be coincidence though.
I tried out Cmder, as mentioned above, which worked. I'm going to look for a cygwin-based workaround, though, as I don't like having to have two separate terminal emulators/environments installed.
Thanks for the suggestion. It seems like the problem lies with cygwin, as it works in Cmder. I have tried bash, ksh, fish, etc. and the problem seems to arise in all (under cygwin). Kind of strange.
Very interesting, thanks!
&gt; func F() (info objectInfo) { // lots of code if condition { return // what am I returning? what state does it have? // the only way to know: parse the entire function! } } This argument is loathing drivel. You are returning the value set during the flow of execution.
a) You seem to be asking a question, but you already seem to know an answer. b) I don't think there is any "hate" for the technical package. Socially the main package developer seemed to do many things with his "open source" package that to many are unacceptable for an open source project, or most any project for that matter. If you think that people saying "how this project is run looks really bad and here is why" is "hate", then we probably lack a common vocabulary to talk. 
So you never heard about the [NPM left-pad debacle](https://arstechnica.com/information-technology/2016/03/rage-quit-coder-unpublished-17-lines-of-javascript-and-broke-the-internet/)?
Can you please provide a source for this statement: &gt; The irony is that story indirectly led to this sub being disavowed publicly by go maintainers. As you can see here, https://golang.org/help/#reddit, reddit is still an official space for Go. As far as I remember, the Go maintainers withdrew their active leadership from here since none of them had the time for it and they were mostly inactive. But I would be happy to read anything else that also made them to take this decision.
&gt; not even a little bit of hate on a package no matter what... It's not the package, it's the author. &gt; Comming from node js and have to say that have never seen drama like this Right. Apart from when Azer threw a hissy fit and *broke the entire `npm` ecosystem* because no snippet is too small for a Node dev to package it up and declare it as a dependency? &gt; Go in a nutshell. Wut? I can see you're here to make friends. 
So it's hard to give suggestions without knowing exactly what you're doing, but I would think that you could design your state such that all of your goroutines could read from that shared state as long as they send messages to a single writer goroutines to update it. If you used an event source like model where your shared state is an initial state and a slice of actions that have happened in order, then your goroutines can find and apply new actions on each iteration. This assumes that the writing goroutine can figure out which order actions should ultimately be applied in.
You seem to mix a programming language design with a tooling design. They have nothing in common (as a proof we have go-gradle which allows you to use Gradle to handle Go dependencies). 
"It's not the package, it's the author." Judge the code, not the man.
I think it proves that their whole rating is rather BS. Go wasn't as popular a year ago, but it surely wasn't quite 0.163.
It's impossible to because the issue with the man is that he squashes everyone else's commits so they look like they came from him.
Does this affect quality that could not make the frameworck into production??
Frankly, yes. What if there turns out to be a serious security hole? The author has demonstrated that his likely course of action would be to cover it up.
Oh damn it, that's the only comment that helped me so far. Thanks!
"When you're ignoring data it's not a software engineering anymore. It's DevOps (with all respect)." I'm really not sure what this is trying to convey, but it might not be respectful.
Nice, confirms that I made the right choice picking restic :-) (Can't use duplicacy because of the license, don't need compression because my backup drive is plenty big enough.)
&gt; Comming from node js and have to say that have never seen drama like this If you think Go has drama, you should try the Ruby community.
I write code for work. I can't just ignore license violations; that could get my employer in legal hot water, and get me fired. If I can't trust the author not to rip off someone else's code in violation of copyright, then I can't risk using any package he releases. So the author's trustworthiness is an important issue.
Another great code review. I wonder if 35:20 is an intended pun
Some of us are old enough that we really did.
It actually was the opposite. The point was that devops currently can and do write pretty decent software to proxy/connect frontend and storage/queues etc. And that "software engineering" is much more than just connecting frameworks to general purpose solutions - it's analyzing and undestanding the data you work with in the first place.
why every programmer needs to be a data scientist... why every programmer needs to learn project management... why every programmer needs to be a good writer... why every programmer needs to learn empathy... why every programmer needs to learn stats... these never end
it was at -1 when I found it at the bottom of the page, about to be hidden...
Indeed, the idea to remove Reddit from official spaces was unrelated. Source: https://groups.google.com/forum/#!msg/golang-nuts/XoOhzUClDPs/jgSWxng7CAAJ However, the original drama had serious consequences https://groups.google.com/forum/#!msg/golang-nuts/XoOhzUClDPs/jgSWxng7CAAJ That thread was partially copied to dev list as well. You'll also see mentioning about some code in Iris being "stolen" from other projects (copied and authorship information deleted). Source: https://groups.google.com/d/msg/golang-nuts/MHoI64RyRdY/oXy3SFDaBwAJ True, the licensing allowed copying and altering the code and, I believe, some of it has been rewritten/replaced later on. Use your own judgment. My stance on it is that the framework was pretty good in its early days. It had original router, if I remember correctly. It did not have any tests, which was one of complains at that time, and the author stated that he did not intend to add any. Later it kept growing by including everything conceivable and constantly changed API. Although, a book accompanying it was pretty good. So, it's a mix of good and bad. YMMV. 
I'd like to see the bench on network. For example with minio as backend. Also it could fine to compare with rsync --link-dest
Great. Thank you very much for your blog post. It's the first time I see a clear explanation of the difference between a http.Handler and a http.HandlerFunc and their respective use. It's now obvious but the stdlib documentation is too terce. 
Yeah, I also didn't quite catch it, but would think so …
“A human being should be able to change a diaper, plan an invasion, butcher a hog, conn a ship, design a building, write a sonnet, balance accounts, build a wall, set a bone, comfort the dying, take orders, give orders, cooperate, act alone, solve equations, analyze a new problem, pitch manure, program a computer, cook a tasty meal, fight efficiently, die gallantly. Specialization is for insects.” (c) Robert A. Heinlein
The spec says unicode letters. https://golang.org/pkg/unicode/#IsLetter says that is category L. So on this list https://www.compart.com/en/unicode/category any of the categories starting with L are allowed.
Unfortunately. I do think the author got the point about idiomatic code, as I remember some (polite) footnote in the GitHub repo about it. Or maybe it was the Gin project I'm thinking of? Whichever uses codegangsta/inject is what I'm thinking of. And yeah, people in the Go community can be very conflictive and don't really see non-idiomatic code as a learning opportunity. It sucks if this was a reason that some people turned away from Go, especially with projects that demonstrated some traction.
Yeah, that's an insulting assumption and misunderstanding of devops. I'm not sure why you think it's a good thing to kick a whole bunch of engineers while telling everyone they don't see the big picture like you do.
Any idea what the differences are between ale and neomake? I've been using neomake for a while now, but can't quite tell what are ale's advantages.
It's obviously him.
Guess you took some inspiration from this blog post? https://elithrar.github.io/article/custom-handlers-avoiding-globals/
No actually. I write a lot of api's for work and the verbose error handling is something I wanted to improve. After experimenting with it I came to this solution. The suggested blog looks interesting aswell, the author takes a slightly different approach but I think it explains the same thing very clear. Good suggestion! 
Glad you liked it!! I agree that the stdlibrary documentation could've explained this topic better. It is really powerful. 
well, turns out I'm writing it today :)
not a pun, just a fail haha I had to modify a lot on this video once edited to match YouTube size etc Apparently, at some point, I failed [shame-shame-shame.gif]
It's really hard to keep as a dependency. Since the author squashes all the commits, a few commit hashes disappear in the process, rendering the dependency reference useless.
X-Post referenced from [/r/programming](http://np.reddit.com/r/programming) by /u/alanbernstein [Adding Run Length Encoding Support to Pilosa](http://np.reddit.com/r/programming/comments/6mhakm/adding_run_length_encoding_support_to_pilosa/) ***** ^^I ^^am ^^a ^^bot. ^^I ^^delete ^^my ^^negative ^^comments. ^^[Contact](https://www.reddit.com/message/compose/?to=OriginalPostSearcher) ^^| ^^[Code](https://github.com/papernotes/Reddit-OriginalPostSearcher) ^^| ^^[FAQ](https://github.com/papernotes/Reddit-OriginalPostSearcher#faq)
&gt; die gallantly Damn, I'm screwed on this one. When it comes time for me to die I'm gonna sound like a baby back bitch.
You want to benchmark the network?
Instead of this article, read https://golang.org/pkg/bufio/#Scanner docs. You'll be a lot better off.
&gt; There is a Renderer interface (apologize the bad naming) Renderer is the [idiomatic name](https://golang.org/doc/effective_go.html#interface-names) in this case. &gt; In my opinion the handler displaying the search results is not responsible for anything other than the results. I agree and that's why [context](https://golang.org/pkg/context/) exists. The current user should be passed down in the handler request context from the middlewhere that is responsible for that. Also If you want to inject dependencies to your handlers it is a good pattern to do something like this: type MyApp struct { // dependencies go here } func (app *MyApp) search(w http.ResponseWriter, r *http.Request) { // Grab user from context // app.SearchService.Search(query) // Render search results and other stuff based on the current user context. } Other than that, the Renderer interface seems like a good idea to me which can complement the above techniques.
The author of martini receivced some critical comments about the use of reflection that made the code harder to understand than necessary. He listened to the critics and built another Web framework called negroni that is basically martini but without the reflection "magic". That's what I remember from that story. What I definitely do not remember is the "humiliated by a few trolls" part. Did Jeremy say that?
That's literally one of the examples in the article.
Exactly my thoughts. Duplicacy might be good tool but is completely unusable due to its license.
You could run the tests locally to test different storage backends - not the network
There are gradually more and more golang stickers appearing on the back of his laptop each episode.
love your vids u/campoy!! would you mind sharing your vs code setup? can't seem to get all that nice autocomplete etc you got there
There are not too much difference from what I've seen. Also check this Ale discussion out https://github.com/w0rp/ale/issues/47. 
looks like great minds think alike, eh? https://github.com/zpatrick/fireball
You should follow the intro of github.com/campoy/go-tooling-workshop
Do you could use C++ library, wraps class with C code and, through cgo use it https://github.com/apache/parquet-cpp
Sounds weird to me, I can understand why you'd prefer it to be totally free, but I've never been in a company where anything you have to pay a license for is completely unusable.
This is the correct answer for anyone wondering.
I find that I don't reach for creating things that iterate in go like I do in other languages. It doesn't feel quite like a first class pattern as much. Other languages have several functions built around the idea of iterating across a sequence and therefore it's to your benefit to force things into that pattern. Go doesn't really offer that, so I don't often bother.
func convert(f float64) float64 { return (f - 32) * (5/9) } 
IANAL, this is not legal advice, etc, etc. Most of your concerns also apply to most permissive software licenses, regardless of the CLA. Is it the sublicensing clause that bothers you? The MIT license also includes one. Maybe the patent license clause? Apache also has one. I'm also not sure what you mean by the "open source agenda". You don't have to publish your modifications if you don't invoke distribution for any OSS license that I'm aware of. For permissive licenses such as the BSD and MIT you don't have to publish them even if you invoke distribution, you just have to ensure the full license accompanies the binaries.
I wonder about the validity of a thread pool with coroutines. It seems redundant.
Constantly changing the API is a no-no for production too.
It's not just the network, but how latency affects the performance. For example I'd expect Borg, written in python, to be slower than restic.
The product is complete. There are no outstanding bugs and no need to add new features, ergo there's no reason for new commits.
Good deal. That is what I was expecting/hoping.
Awesome! Congrats on the popularity also!
I found completely different results with restic on network. I mean if i compare to rsync, locally there is no difference but on network differences are huge. There is an issue filled for this, i wonder how duplicacy handle that. A more scientific test will be to measure the data transferred up and down for each backups. (I should do it alone of course !)
Why network latency should be slower in Python ?
Fasthttp really isn't that fast. If you put it with real world loads (something more useful than hello world tests), stdlib outperforms it.
Yeah I have it in prod and it's rock solid
Congratulations with posting it 10 times in same subreddit! Seriously, this is annoying. 
Wow, nice API!
That looks great! I'll be sure to play around with that soon :)
Better title: things you could learn from looking at aggregated data when your company is the size of Twitter. That, or "data scientist" is one of the most hollow function descriptions around.
I did something similar as a proof of concept a while back, but I didn't develop it into IFTTT levels. The structure was something similar to yours, but also allowing for bidirectional communication, for example: 1. a web ssh terminal to a remote server (via websockets), 2. a github/bitbucket push endpoint which would trigger some GPIO lights on again a private-lan RPi Both those things were implemented actually, but I didn't have any good way to develop these into something similar to a SaaS which would develop some income from day 0. There's some screenshots on my Twitter account: https://twitter.com/TitPetric/status/768092747312009216 This tweet actually shows some javascript logic implemented with otto on the Go-server side, that communicates with agents that allow remote code execution (listing a folder). https://twitter.com/TitPetric/status/821735534611591169 Here is where I packaged that into some sort of deployment dashboard. It's used in production daily. The service runs whatever set of pre-defined commands you declare. It's not really much about channels or goroutines, but more about handling all the various types of payloads (scrape command, email command, etc.) and how you can achieve this, while at the same time perhaps avoiding nearly constant trigger/workers restarts. Workers need to avoid unrecognized payloads (you should enumerate them), and servers need to produce new payloads hopefully without restarts. This is in part why I chose to use a JS interpreter to provide some of this functionality "on the fly". A simple API can be exposed to the javascript logic, and you can pretty much code anything in JS to provide any kind of payload for specific (tagged) clients. If there's some interest in this, I may be persuaded to throw some of this on GitHub, just as a POC, as it's not really much more than that.
You can already safely replace it with `dep`, its manifest file has been pinned. We've switched from `glide` to `dep` about a month ago and it has been a much much better experience. I haven't really found any bugs in `dep`, but with `glide` there were ones I had to work around with a Makefile to solve. Also, I built `vg` around `dep` to use project specific `GOPATH`s with ease instead of the vendor directory. This solves some issues that we were having with the `vendor` approach (mainly having version pinned executables). https://github.com/GetStream/vg
TL;DR for some people: This is a three parter: 1. Escape analysis (return value allocation on heap/stack, return by reference), 2. Cost of defer (defer allocates and is thus slower) 3. Cost of timers/sleep (goroutines and scheduling) Feedback welcome :)
Important (and unfortunate) caveat of the "channel as iterator" pattern, which is why they're not used in stdlib, not listed again. Probably should be added to some Go FAQ. To [recall](https://www.reddit.com/r/golang/comments/6gvq2j/custom_range_iterators_in_go/diub08h/): &gt; memory/resource leaks in case of `break` or `return` in the loop before the channel is exhausted (see also [issue 19702](https://golang.org/issue/19702))
Sometimes there are multiple Inputs for one Output. $ copy all.txt a.txt b.txt c.txt or, as a variadic function copy(all, a) resp. copy(all, a, b, c) Now, from the spec: &gt; The final incoming parameter in a function signature may have a type prefixed with .... A function with such a parameter is called variadic and may be invoked with zero or more arguments for that parameter. Therefore, Writer first, rest last.
How does performance compare against something like [gorilla/websocket](https://github.com/gorilla/websocket/)?
You can also use https://golang.org/pkg/html/template/#Template.Funcs to return common types.
Package main Import("fmt) Function convert (f float64) float64{ Return (f - 32) * (5/9) FmtPrintf( I'm stuck here } 
But is it more minimal than the flag package?
non-free would not be a problem but this fair5-license-derivate is a legal nightmare. e.g. https://www.reddit.com/r/golang/comments/6imj26/duplicacy_a_network_and_cloud_backup_tool_based/dj8m2ck/
Even without any direct benchmarks with `gorilla` or `x/net`, the obvious benefit of `ws` is the ability to fully control memory consumption and even cpu use (with some additional system programming). For example, you could reuse output `bufio.Writer` between thousands of connections without hacking the library API. The second performance issue that was solved in `ws` concerns WebSocket handshake – so-called *zero-copy upgrade*. It allows you, again, control the memory consumption, but now in place of WebSocket handshake – instead of using `net/http` server which copies headers and allocates structures and buffers for `http.ResponseWriter` and `http.Request` – you could use `net.Listener` and `ws.Upgrader` to handle incoming WebSocket connection efficiently, copying only what you really need (for example Cookie header). I will soon publish an article about how we handle 3M WebSocket connections at mail.ru with Go. There I will try explain benefits more detailed =)
One further restriction: The first letter of an identifier must exist in uppercase and lowercase variants, to be able to determine visibility.
I understand that https://github.com/centrifugal/centrifugo is also a mail.ru project. Are there any plans to switch Centrifugo from `gorilla` to this library?
Hey, thanks for this feedback. I definitely should have been more cautious on using word devops or, better, avoid using it at all in this context. I apologize if I may have insulted anyone.
I do not know really, but it would be a great support from `centrifugo` developers :D
I wonder why mods don't start deleting this stuff? @dgryski @kris-nova @peterbourgon @natefinch? Edit: well, at least we could report it if it's continuously breaking some anti-spam sensibilities. I just did.
Hi, Centrifugo author here:) Currently there are no plans to switch - but maybe one day... We've already seen in Centrifugo profiles how Upgrade affects allocations - so zero-copy upgrade is a great benefit here. Also this ws library provides a way to reuse read buffers and can help to drastically reduce memory usage which is pretty high in Centrifugo now. But regarding to this I am waiting for https://github.com/golang/go/issues/15735 - as far as I understand it can help to reduce memory usage staying with Gorilla Websocket lib. In general the the only feature which is missing in github.com/gobwas/ws at moment is websocket compression (and maybe alternative implementations of some functions that use `unsafe` package). Btw Centrifugo is not a mail.ru project - just historically associated:)
[No, it doesn't](https://play.golang.org/p/pHvnpZUtpc). The spec says, that an [identifier is exported](https://golang.org/ref/spec#Exported_identifiers), if it's first letter is uppercase. If the first letter doesn't have an upper case variant it is, by definition, not upper case and thus not exported.
I see, that does seem rather 'muddy'
Lack of compression is the one gripe I have with restic, but thankfully it is to be added once they overhaul the repository format.
The affect will be greater, because it's much harder to write the python code to do N things at once.
Came here to say the channel example could be enhanced with a context, to allow the inner func to stop iteration, as the other examples do. If done properly, would that not plug the potential leak?
Haha indeed! 
Good catch, thanks, This shall teach me to revisit the specs before hitting reply. :) (edit: wording)
Good point. Looked into that back then and from what I gather it'd almost be easier to do a native impl
You need to go with Go Tour first. https://tour.golang.org
Yes, the good one. Iterators using channels are a bad idea.
&gt; Channel-based iterator is easy to implent and use by the caller but most expensive. Again, you're not arguing with the article. 
The article thinks channel iterators are a good idea, just costly. They're bad for more reasons than that.
It's not about having to pay. There are two main problems: 1. I'm not allowed to agree to random licenses. I'd have to get the corporate legal team to review this license in detail, since as far as I can tell it's not one that they've ever reviewed. That, in return, would require justification. Given that there are alternative solutions which don't have the weird license and are almost as good, I doubt I'd be able to justify the cost of engaging corporate legal for the time required. 2. Agreeing to the license would apparently commit the company to buying per-user licenses for every employee who was going to use the software. That would mean committing to company-wide management and approval of license allocation. We have enough trouble negotiating the ability to do that for things like VMWare, and that's just for my department. Initiating a project for a company-wide license tracking system so I can use a piece of backup software? Not gonna happen. Software which has a license from the internal pre-approved list, I can just use. That list includes GPLv2, GPLv3, MIT, Apache, and so on. Restic's license is BSD 2-clause, which is on the preapproved list, so I can just download the software and use it. Similarly, software which has a single-user commercial license can be purchased and tied to the individual user through the standard expense management processes. Mandatory volume licensing is a deal-killer, though.
KEANO_ gave me a link which described the problem with the license, I see what you mean.
Developer of Duplicacy here. Thank you for your explanation. Now I have a better understanding of why you don't like the license. All I wished for is a 'free for personal use but pay for commercial use" license. Not wanting to come up with my own, this Fair Source license was the closest I could find. Moreover, the definition of the user in the Fair Source license is kind of ambiguous, so I redefined it as the computer account that owns the files to be backed up. Perhaps not a good choice as it obviously alienates potential users like you, but I don't see any better alternatives.
Added it to the article as well, thanks for the heads up!
Developer of Duplicacy here. I can understand why you don't like Duplicacy, but what about restic vs Attic? Sure, restic's backup speeds were faster that Attic's, but that was probably because 1) restic didn't do compression and 2) restic used much more CPU times. In addition, the restore performance of restic was horrible, even worse than that of duplicity (which in my view is a generation older than the other 3).
Please submit to this subreddit when you publish that article! I'm sure people will be interested!
I'm just waiting for someone to make a reddit bot that keeps track of this guy or something :D
There is some decent replies here, but I disagree with any that have the sentiment you need no experience but a desire to learn. Sure, there is a junior in front of the word developer, but it still has the word developer in it. Any given junior dev position will have plenty of applicants, if you want to set yourself apart from them you only need to do one thing: Write software. Pick a interesting problem, make a github repo and start working on it. It will help your confidence as well which will really show in a interview setting.
looking forward to read this article :)
Is there any public app using this library actually I could give a look at ?
Thank you for the insight, and for building that project.
&gt; How do I write this in go programming wut
https://play.golang.org/p/DaKDivWGkK The basic gist is that you want to create a custom type to hold your response. Create an instance of that type, populate it with your data, and then use json.Marshal to convert it into a JSON string which can be returned to your front end.
Thanks a lot I will try that. I guess I was hoping there was an easy method I could just call on my array to turn it into a json array, but this seems doable.
You can just Marshal ro.Response and you'll get an array directly (no enclosing object). Is that what you wanted?
Here is a full program: https://play.golang.org/p/L6T-cnMbB6
Do you think it's Gogland support sub?
Cmon, man you can figure it out
I tried kept giving error I know it's easy but I'm very new to go
No, there is no subreddit for gogland. But Gogland is directly tied to Go. And it is the only fully fledged Go IDE.
I'm not sure if that would (should?) work. I remember there being security issues with un-contained arrays.
&gt; it is the only fully fledged Go IDE There's always LiteIDE.
&gt; And it is the only fully fledged Go IDE Lol (c)(r)(tm)
Not very nice, if still correct
What ?
Just guessing, never used gogland. But there is Maybe a Button called 'build'. Go programs can be run without the binary beeing build to a non-temporary place. 
I think the "Run" option uses the `go run` command, which isn't meant to leave a binary behind. Do you see a "build" option? Here is a screenshot (but it's from my Ubuntu) : https://i.imgur.com/nFBqhLk.png
No, there is no opened sources of an app. But you could look at `example/autobahn` folder in repo. There are 4 different implementations of WebSocket echo server. By the way, I could implement some simple example app that shows benefits of `ws` usage and little bit closer to the real world.
Hm, maybe, that's some idea! Though, I suppose the disadvantage is that it again adds some more ceremony and complexity, making the use pattern more noisy. As of now, how I'd imagine it could look: ctx, cancel := context.WithCancel(context.TODO()) defer cancel() for val := range generateEvenNumbers(ctx, max) { ... if some_condition { break } else if other_condition { return } ... } cancel() // optional here - to free the resources earlier, especially in case of a break Certainly an interesting pattern, especially for cases where it's much easier to express something as a goroutine/coroutine, versus the "Next()" pattern + storing state explicitly. Cool!
&gt; What method of communication from Js -&gt; Go would be a good medium? Would I literally have to spin up a http server? Or perhaps call everything via subpoc? Thoughts? Websockets.
use the terminal to run "go build" or "go install". I set the default terminal stuff in gogland to handle it all. I'm sure you could make a run configuration, but I personally don't really run my applications locally, I just verify them against goconvey.
The "Build main.go and run" is just the name of the configuration. Also, it does not create an exe. Here's the output I get when I run. &gt; GOROOT=C:\Go &gt; GOPATH=C:/Users/Emil/GoglandProjects;C:/Go/src &gt; C:\Go\bin\go.exe build -i -o "C:\Users\Emil\GoglandProjects\untitled\Build main.exe" C:\Users\Emil\GoglandProjects\untitled\main.go &gt; "C:\Program Files\JetBrains\Gogland 171.4694.61\bin\runnerw.exe" "C:\Users\Emil\GoglandProjects\untitled\Build main.exe" &gt; hello world &gt; Process finished with exit code 0 Edit: according to this it does build it. Edit2: But still no exe.
Ah yeah indeed. Sorry, I was sure it was there because I used to do it, but I can't find the option anymore.
One of my reasons was the static linked binary. I can download a restic binary and store it alongside my backup and pretty much don't have any dependencies. With attic I'll need a python environment and maybe 10 years down the road ubuntu won't ship with python anymore. Sure, there will be ways to handle this problem, but it will definitely be much easier to just execute my still working binary and retrieve the needed file from my archive.
https://github.com/currantlabs/ble is pretty solid
I believe there are other IDEs people use.
Right, but all of them(?) rely on plugins.
Is it? I've been trying to use paypal/gatt package, but still got an weird issue..Thank's for the link, I'll play with it right now!
It does if just to modify the go playground example :)
Thank you
Hey Tit you are doing a great job with these posts - keep them coming. 💪👍
Just wait till dlsniper discovers this and you'll have an answer soon.
This was a bug in the latest EAP, EAP 10, and is fixed in the nightly plugin. You can find the information on how to install the latest nightly at the end of theis article https://blog.jetbrains.com/go/2017/05/12/gogland-eap-8-is-available/
Then what is this? It's a reddit dedicated to Go, tools around Go and so on. Gogland is one such tool. Your trolling needs some massive overhaul.
How's this any different than when asking similar questions about any other Go related tool? Just wait for 1.9 to be released so that everyone can start asking why did their vim / vscode stopped working with the completion support (as seen in each Go release).
Very anxiously awaiting a mature, thread-safe alternative to Matplotlib in pure Go.
Done :D it's hard to keep up to date when changing continents (apparently). 
The improved version is still basically a race. Localize your variables to a loop and have it handle closing/cancellations. E.g. https://blog.carlmjohnson.net/post/share-memory-by-communicating/
I am adding this to my project, but I hit an error in the Usage example in README.md The import is incorrect. actual "github.com/gobwas/wsutil" expected "github.com/gobwas/ws/wsutil"
Your example here https://github.com/dmulholland/clio/blob/master/go/example/main.go has indentation all over the place and makes it look somewhat ugly. Any chance you could run it through gofmt
makes sense. Thanks.
Thanks for the idea! I updated the article with a variant that allows cancellation. 
Every channel is an iterator. To say "channel iterators are bad" is to say "channels are bad". You certainly shouldn't use over-use channels but my article is about "how". Discussing "why" and "when" is a good topic as well, but for a different article. 
why not https://play.golang.org/p/JiZkOpHkgK ? 
https://play.golang.org/p/00rFcDLHP- Functioning example :)
take a look at [minio](https://github.com/minio/minio), they ship a [file browser ui](https://github.com/minio/minio/tree/master/browser) with their binary. 
I was just saying, he could have been more polite, not that his message was wrong. Of course you should tell him this isnt the right place to ask this, but theres no need for passive aggressiv questions. 
LiteIDE is good, but it's nothing like a Jetbrains IDE.
Thanks!!! Always open to suggestions as well :) usually they occur because I'm asking dumb questions (there's no such thing as a dumb question if you are curious about the answer) 🙃
I don't disagree, I just mentioned it as another IDE option. Personally I never understood why people would need an IDE for a simple language like Go but to each their own.
But it's really not that wrong of a place. Much like it wouldn't be for any other Go / Go related tool question. That's the point. Ignore the rudeness of the reply. 
Maybe I am drawing the wrong conclusions from looking at the simplified demo code, but... The demo code implies that the order of closing the channels is determined and therefore the select statement should be able to know that the number channel was closed before the done channel. This assumption does not hold if each channel is closed in different go routines that execute on different CPU cores. Now `select` has no way of determining which of the two channels was closed first. Hence it seems only logical that the select statement assumes no order of events, as it cannot guarantee such an order in every scenario. Nesting two select statements is a valid solution to this, especially, if you cannot modify the goroutines that close the channels. (I assume this was the case in the real-world example.) If modifying the sending goroutines is an option, then another solution is to never close both channels at the same time. That is, the sender should close only one of the channels at a time: the number channel on success, and the done channel in the error/cancel/timeout case.
Well that is a matter of opinions where none of us is right i think. Id say that this is too specific a question about the usage of a tool, and not really a question about the language itself. Not that we shouldnt talk about tools in general, as they tribute to the ecosystem, but i dont think this in particular is a relevant question for the go language . 
This looks awesome!
THANK YOU!
Hi, thanks! Fixed all examples from README.md :)
I had the chat example of gorilla/websocket in mind when I asked the question. I am interested to see the practical differences in a 'real world' mini application. This could greatly helps devs to start with your API. Anyway, I'll be sure to use it at some point, so thanks and keep up the good work. Can't wait for a first stable version with a fixed API and more performances improvements.
I did a quick and not scientific test with Go repository backed on minio, it's what i thought, restic is a lot slower on network than duplicacy because of the lack of cache and compression. Initial backup is 3m16 with restic, 2m30 with duplicacy and rsync -z, but second backup without any change is 14s with restic, 0s with duplicacy, 5s with rsync. third backup with HEAD~1000 36s with restic, 8s with duplicacy, 5s with rsync. But it's a known issue of restic, maybe it will be resolved before the licence issue of duplicacy ;-)
This looks excellent for simple charting baked into a web app backed to show metrics and stuff to customers, good job.
Got this. Will implement some app at the weekend. Thanks!
Looks pretty good, cheers!
Find previous discussions here: https://www.reddit.com/r/golang/search?q=react+native&amp;restrict_sr=on 
Just out of curiosity, how would you use this in a webapp for continuously changing data sets? It makes more sense to me to send the data to the client so that so that you can plot it with JS! 
In fact, I don't find 'config' structs elegant. The 'functional options' solution looks better. Please take a look on Francesc's video: https://youtu.be/nhElL62BSn0
I get impatient watching coding videos, but I've seen the blog post that content comes from: - https://commandcenter.blogspot.com.au/2014/01/self-referential-functions-and-design.html To each their own, but I dislike the verbosity, magic, and non-atomicity of functional options. My favorite part about Go is its lack of magic.
The api is super nice I must say, good job!
As somebody who has been going back and forth between config structs and functional options, I think I generally prefer config structs at this point as well. They keep all the options together in godoc, require less boilerplate, and are simpler to understand when reading somebody else's code. That being said, I don't feel strongly enough about it that I'd force a co-worker to chose one style over the other in a code review, as long as things are done consistently on a package level.
I've moved a few of my projects and libraries to dep and will continue to migrate the rest of them from glide to dep over the next few weeks. In my opinion, while dep is not production ready, it should be stable enough for most use-cases other than a few quirks (mostly on Windows in my experience).
You mean things that other programmers choose? Names for variables and functions for example? If that's the case, it _may_ be that you're working with people who aren't very good at naming. Could you give us an example? Sometimes there'll be things that are simply conventions that you don't know yet, and as you gain more experience you'll be able to make more assumptions, etc. Day-to-day, I don't think I've ever really had a big problem with this, ever.
I love the idea of this, and was thinking of doing something similar myself. Do you think there's the chance of browser extensions in the future? I'd love a linux, open source password manager that doesn't suck and is just simple. I really miss 1Password now I've moved to Linux, and although Enpass looks awesome, I just am finding it more difficult to trust than something open source (depsite 1Password not being, AFAIK, I had heard of 1Password a _lot_ beforehand, and hadn't heard of Enpass beforehand).
There are two main issues with real world examples of code. Firstly, many experiences programmers like to take shortcuts, which means that what you see doesn't look like what you saw in the tutorials. Secondly, when you read someone else's code, you don't know what was in the programmer's head, so you don't necessarily know how they intended for the data to flow. This latter point is the killer because there are so many ways to do the same thing, and you have to figure it all out.
Just render a PNG or something static over the wire. Chatting streaming stuff to the browser is overkill in this regard, and in a backend guy so preferred to leave stuff like d3 to younger, more patient guys
Um, after reading the doc, still not really clear to me what's the difference vs. GitHub's "squash" button. I admit I never used it, so I don't know what are its warts, but I'd expect it to do roughly what the bots aims to do - except not needing a complex protocol of commit prefixes (which must be followed precisely by the PR sender), nor a bot setup step (on repo owner's side). Does GitHub's "squash" button somehow destroy/mangle commit messages?
I guess that it's because if you are used with a certain set of functionality then it's hard to migrate to something simpler. Plus the convenience of just install the IDE and get going, no other things needed. Or familiarity with a certain tool, like using IDEA for a long time and then having Go support for it or a dedicated IDE which is similar to it. I do consider vim, emacs and pretty much everything else as being an IDE since they basically support plugins to get all the functionality you need on top of them. 
https://stackoverflow.com/questions/3503102/what-are-top-level-json-arrays-and-why-are-they-a-security-risk Not entirely sure if still relevant, but worth being aware of?
Only odd part of your approach is that one can pass multiple config structs. An interesting alternative approach I've seen is to use the default of the struct regardless and then lazily initialize it. This is what the new autocert package does with its manager. https://github.com/golang/crypto/blob/master/acme/autocert/autocert.go#L88
This gains you nothing at the expense of making the code non-obvious. NewFoo(3, 4) vs NewFoo(3, 4, nil) There's a reason Go doesn't have optional parameters.
Have you peek to see how Keybase handles it? - https://github.com/keybase/client/tree/master/shared/react-native
I disagree; I believe Dave Cheney is correct when he says, "...we, as Go programmers, should work hard to ensure that nil is never a parameter that needs to be passed to any public function." * https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis
Why? What's wrong with passing nil?
I think this is actually shipped as a pure Golang binary ? https://github.com/robpike/ivy React Native is a js based solution. So I do not think there is a way to make it Golang focussed instead and build it into a Golang binary ? But maybe I misunderstand your question ?
I completely forgot about this even though I had useful feedback last week, your other post today reminded me. I see very commonly that people underuse the power of interfaces in Go and instead copy data back and forth. It happens often in I/O where people read all data into large buffers before writing it into other instead of just chaining io.Reader. In your case, you do it with the image. You don't need to convert the pixels into a large buffer, just return something that implements `image.Image`. Either make Renderer implement image.Image or replace Renderer.Rgb() with something like this (tested, works): // img implements image.Image wrapping Renderer type img struct { r *Renderer } func (im img) ColorModel() color.Model { return color.RGBAModel } func (im img) Bounds() image.Rectangle { return image.Rect(0, 0, im.r.Width, im.r.Height) } func (im img) At(x, y int) color.Color { o := (y*im.r.Width + x) * Elements count := im.r.pixels[o+Count] return color.RGBA{ im.r.color(im.r.pixels[o+Red] / count), im.r.color(im.r.pixels[o+Green] / count), im.r.color(im.r.pixels[o+Blue] / count), 255, } } func (r *Renderer) Rgb() image.Image { return &amp;img{r} } A good reason for it being a separate struct is because you might want to do the same thing for Heat, so it will need a separate struct (with pre-computed max). This can be a hair slower, but it's a good habit to get used to composing interfaces to avoid copying data back an forth all the time. And if you want to, you can even gain color quality if someone decides to save it as something that uses more advanced colors than PNG. Just replace At in the bit above with something like this (also tested): type col struct { px []float64 exposure float64 } func (c col) color(n float64) uint32 { return uint32(gamma(math.Min(n*c.exposure, 255), 2.2) * 255) } func (c col) RGBA() (r, g, b, a uint32) { count := c.px[Count] r = c.color(c.px[Red] / count) g = c.color(c.px[Green] / count) b = c.color(c.px[Blue] / count) a = 0xffff return } func (im img) At(x, y int) color.Color { o := (y*im.r.Width + x) * Elements return col{im.r.pixels[o : o+Elements], im.r.Exposure} } Unfortunately exposure kind of ruins it because without it a col could be just `type col []float64` returning a slice of the original pixels, now we need to allocate a struct. Could be solved by pre-multiplying the exposure some time earlier. Worth considering. Another thing worth looking at is if you need to export everything. I've noticed that pretty much every struct and most fields are exported. Do they have to be?
It (literally) carries no value, so it's just cognitive overhead - a required value implies that you must pass something. &gt; "What's this third parameter I'm required to pass? A pointer to something? Do I need to make a thing and pass it? Let me check the docs... google... stack overflow... oh apparently the default usage is just nil. Why do they make me pass it then? What was I doing again?"
That was my first iteration of what I ultimately posted, but it seemed bad form to not return a proper JSON object contained in { }. Not sure if it makes any difference depending on what front end library he is using.
I think there is more cognitive overhead with what you are doing because it hides the fact that you can send a config unless you check the docs. In addition, I feel like the reasoning you've quoted is highly exaggerated. I doubt it would be a surprise to anyone. I'm sure they have already been exposed to such an idiom. For example in the standard library, http.NewRequest takes an optional body that is nil if not set.
&gt;Secondly, when you read someone else's code, you don't know what was in the programmer's head, so you don't necessarily know how they intended for the data to flow. After six months that some one else is you and "you don't know what was in the programmer's head, so you don't necessarily know how they intended for the data to flow."
One thing I like about the functional options solution is that they handle defaults better. With functional options, I can just create the struct with all my default configuration and then iterate over the functional options to modify the struct. Whereas with a config struct, I have to check if a configuration option is set and if it is, then modify the struct and so on for every single field. There ends up being a lot of boilerplate and it becomes annoying to know when an option is set. E.g. say a user wants to change the default of a string field of the struct to the empty string and they want to signal this with a field in the config struct. How would I know when they have explicitly set the empty string versus when they do not want to change the default? I'd have to turn the string config field into a pointer to a string or create a constructor for the config that contains all the defaults. It's not bad, but its worse than functional options in that regard. However, I still feel like the config struct (or just exporting the fields in the actual struct which is what I prefer) is more clear in general and I would prefer to use it over functional options most of the time.
&gt; I think there is more cognitive overhead with what you are doing because it hides the fact that you can send a config unless you check the docs. There's literally a config type, listed right in the args; it's anything but hidden. &gt; In addition, I feel like the reasoning you've quoted is highly exaggerated. I doubt it would be a surprise to anyone. I'm sure they have already been exposed to such an idiom. This may be true. I'm new to Go and it would be surprising to me to have to pass nil somewhere, but maybe to experienced gophers this is fine. From what I've been reading, the original designers tried to get the stdlib right but would revise some design choices in hindsight. 
Yeah there's certainly a tradeoff there. It encourages you to choose config properties that lend themselves to natural zero values, but of course that's not always possible.
&gt; There's literally a config type, listed right in the args; it's anything but hidden. Its hidden when I'm reading the code is what I mean. When there is nil, it is explicitly clear that there is another argument to the function. And since you are using a variadic argument, it's not clear whether one can pass one more configs since this isn't a popular idiom. It would be confusing to me as a consumer of your library.
&gt; And since you are using a variadic argument, it's not clear whether one can pass one more configs since this isn't a popular idiom. Agreed, this is the largest downside to the pattern. That said, it's quite easy to check for, and I prefer it over passing nil (myself).
We have a lot of customers that have very low resource systems (thin clients). Rendering clientside is very painful for a lot of them. Server rendering would help a lot.
I'm loving govendor
Agreed. My lazy approach is just to check for len(config) and provide a nice error if someone decides to pass multiple (though I suspect that's unlikely).
How does it compare to gonum/plot ?
Probably pretty unlikely on the first usage, but I wouldn't be shocked to see it happen over time with edits and merges. For my money, I'd think I'd be happier just doing NewFoo(3, 4, FooConfig{}) I don't mind a little extra verbosity to be explicit about what's going on and avoid edge cases. (Actually really in practice I'd usually end up just having everything in the struct, document the two required parameters, and lazy-initialize as needed. Not sure if this is really good practice or not.)
Generally speaking, this is a far more complicated and wider issue than befits the Golang subreddit. You'd be better off asking on specialist forums what the best way of doing it overall is, and then consider what the best way of getting to that information in Go is. My vague memory from a few years ago: Vram used to be very difficult to determine, as it wasn't reliably reported. You used to have to use the graphics APIs to force allocations that had to live in dedicated memory till it failed, iirc. Name was also dodgy, as various drivers override it in certain sources. DeviceIDs were better for identification, but vendors weren't good at updating their references.
I would love something like that to work together with golang's jupyter kernel. Does it?
Also perfect for information displays running some arm cpu 
don't cop out, d3 isn't more challenging than systems architecture. If you are too lazy to learn d3, there are easier alternatives. Sending static images shows your age as a product or business
Function options are the way to go, imo. There are situations where you want to be able to change things under testing, that should never need to in normal practice. So the ability to split those functional options into the _test.go, and so exclude those functions from the normal api. Common example is the need to replace using rand.Reader to something deterministic whilst testing. Far nicer than having to use package level variable. type Options struct { rand io.Reader ... } func Option func(*Options) func New(opts ...Option) { options := &amp;Options{ rand: rand.Reader } for _, opt := range opts { opt(options) } .... io.ReadFull(options.rand, b) .... } And in _test.go func WithTestRand(r io.Reader) Option { return func(opt *Options) { opt.rand = r } } 
Why don't you write your own then and submit publicly. Should solve your problem.
I could see this being very useful for email graphics where JS might not work well in all email clients
With a config struct, why wouldn't you just hide these test-only options (by lowercasing them), which would accomplish the same level of hiding? One of the reasons I dislike function options is that they aren't atomic - so the struct can enter an invalid state, which makes things like automatic checks for invalid states much more complex to write.
I don't mind this either.
Even you know that this is not racist.Indians are not well known for contracting programming related jobs to them. Search for the British Airline delay cause by an Indian. This post was supposed to be funny rather than racist
Your method creates config structs in an invalid state to begin with. And then have to test, and set to default values if don't like them. Atleast the config struct starts out with valid default values in the function option method. Function options should return an error which omitted from pseudo code above.
The lazy initialization thing is exactly what the new acme autocert package does with its Manager struct. I've been wondering whether its a good practice too. Not sure yet.
I've had to do something similar for a project and I'm using cgo and opencl but I'm also using opencl for other things besides getting GPU info :) https://www.khronos.org/registry/OpenCL/sdk/2.1/docs/man/xhtml/clGetDeviceInfo.html
Same could be said of python too, but I do so adore Go much, much more
&gt; Even you know that this is not racist No, I know that it is. &gt; Indians are not well known for contracting programming related jobs to them. Search for the British Airline delay cause by an Indian. Seriously? You are trying to defend your racism with *more racism*? &gt; This post was supposed to be funny rather than racist Intention does not matter. You might not have intended it to be racist (though I would find that weird, given how blatantly and openly racist it is), but it certainly ended up that way.
Should try Python, Python also doesn't have generics
I wonder why they chose to do authentication manually with an HMAC instead of just using AES-GCM or ChaCha20-Poly1305.
Hey, thanks! Let me be sure I understand the above: in `Rgb()`, instead of instantiating a new `image.Image` and then computing the value of each of its pixels, and then returning it whole - you're proposing that I implement the interface for `image.Image` somewhere in/around `Renderer`, so that downstream things that use `Rgb()`'s returned image can just interface directly with methods like `At()`?
Yes, but the difference is the config struct method puts the onus for understanding property invariants on the package author, while the function method puts more work on the consumer.
It really depends on how people approach things. Personally I learnt how to use most commands from the official go tooling system first and I was even working with a plain editor (no plugins). When I heard about `vim-go` I thought I'd give it a try but even then I had to set up each command and hotkey combination myself. If that system stops working for any reason I can simply go back to the core commands. The key difference of just installing the IDE and get going is that if I had just done that from the start then I wouldn't know any commands or how things really work. Therefore when something stopped working I would have to fight against a "magical blackbox" and do google searches like "gogland does not build exe". I think this thread is a good indication of that.
I have found this pattern to be very useful and powerful. Instead of creating some thing by copying data, just provide the standard interface for accessing that kind of data. It is most powerful and useful with io.Reader, but it also works with images and tons of other things. It doesn't really change that much in this case, at best you might get 64 bit colors in some image format instead of 32, but it's a nice principle to stick to in code you write. And after a while not creating large buffers and copying data actually starts helping performance (it probably won't in this case). You can try how it works with the code I pasted there. Just replace Renderer.Rgb() with that first chunk of code. It worked with whatever was on github a few hours ago.
At that point it does seem to be a matter of preference with no correct answers just strong opinions. I personally like full objects myself as they are a bit more explicit and if APIs I write ever get consumed by 3rd party code bases it provides an implicit contract of functionality. But if I got a design doc requesting a return in this manner I would not really think twice about it. Happy coding!
Thanks again, this is exactly the sort of design advice I was hoping to learn from /golang. I'm in a refactor right now so I'll try to finagle this in as well.
Don't agree, certainly not true for non-trivial options imo. For instance configuring TLS... // Modern configuration func WithTLS12() Option { return Option(func(cfg *tls.Config) error { cfg.MinVersion = tls.VersionTLS12 cfg.PreferServerCipherSuites = true cfg.CurvePreferences = []tls.CurveID{tls.X25519, tls.CurveP256} cfg.CipherSuites = []uint16{ tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305, tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305, tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, } return nil }) } func WithKeyPair(certFile, keyFile string) Option { return Option(func(cfg *tls.Config) error { cer, err := tls.LoadX509KeyPair(certFile, keyFile) if err != nil { return errors.Wrap(err, "failed to load keypair") } cfg.Certificates = append(cfg.Certificates, cer) return nil }) } NewFoo(1, 2, WithTLS12(), WithKeyPair("cert.pem", "key.pem")) 
[removed]
wow that looks really nice actually. You should propose an API like that for TLS in Go 2.
You are missing the point, it is not the license that is the issue, it is the CLA. When you sign the CLA you sign away rights. The CLA gives google the sole discretion over the source. READ MY PREVIOUS COMMENT THOROUGHLY. Now, I am all for Google being steward of the project, but the language within the CLA gives them rights to rebrand the code under another license at their sole discretion. Basically the CLA gives Google the ability fork the codebase and then to closed source license this new fork, effectively cutting all ties with the open source community. This language is unnecessary for their stated reasons for the CLA. so ask yourself, why is this language there? 
I generally always utilize a constructor rather than a lazy init of a struct. My reasoning is simply for consistency/readability in my code.
KeepassXC
You can now use brew to install Zeus! Happy Coding!
Low priority, but the websocket header names aren't exactly the right case Actual Sec-Websocket- Expected Sec-WebSocket-
Ohh, I can do d3, I have even used it with websocket to render an HTML *page* for log streaming, since in-data can render any tags, it was a good fit. But making it pretty isn't my strong suit. Anyway short aside, I don't think that rendering ain image server side is an issue, depends on why you select a given trade-off. I prefer to avoid sending work to a client, and most of what i write is "functional" and infinitely cachable unless a new "event" shows up.
Sure, it depends on your approach / experience / desire to learn things. I've reported the issue as soon as I've noticed it: https://youtrack.jetbrains.com/issue/GO-4063 but that didn't stopped me from building the exec my own when I needed it. And I wouldn't rely on using a black box without understanding on what it does regardless of the name of the box :)
Generics doesn't even make sense in Python, it being a scripting language and all.
I like lazy initialization. At the initialization site, I find that filling a couple of struct fields makes for much more readable code than passing a potentially long list of arguments to a `NewSomething`. It makes for much nicer usage, at the expense of a couple of extra branches in the implementation. Imagine if you had to construct every `http.Server` with a `NewServer` function.
Part of the demo code illustrates the trap, as you say, you can get any ordering in the select, if both channels become ready to be read from at a similar time. In a typical real life example closing of those two channels will happen from independent goroutines. You are suggesting not closing the doneChan on success, but the common pattern with the context package is that the done will be closed in all the scenarios mentioned by you scenarios (success/error/cancel/timeout), example from the context.go package: func slowOperationWithTimeout(ctx context.Context) (Result, error) { // ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond) // defer cancel() // releases resources if slowOperation completes before timeout elapses // return slowOperation(ctx) // } cancel() closes the underlying channel (very similar to the doneChan).
You don't have to pass the arguments to NewSomething, NewSomething just returns the default struct and then you modify its fields is what I meant.
Thanks for encouraging words:)
This is pretty cool. How would you compare your goals with alternatives like [Goa](https://goa.design/)?
Thanks! Goa seems a bit verbose to template out? I mean, maybe at the end of the day, you get the same (similar) server code--but protobuf is such a nice way to create contracts. I initially started with YAML (https://github.com/rms1000watt/rupaul) but YAML a bit verbose also. Another alternative is https://swagger.io/. But, again I believe protobuf is still cleaner.
Goa can generate Swagger, and I believe Goa v2 is planning to support Protobuf / gRPC.
Nice. Yeah, I don't imagine Degeneres is going to last forever. gRPC is working on gRPC-Web--then more systems will be able to work with gRPC servers (Protobuf). So, Degeneres just solves an immediate need.
Goa looks really clean actually--I truthfully haven't seen it until now. The big motivation is that I could use Protobufs for gRPC and for Degeneres.
HTTP spec says that [header names are case-insensitive](https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2), so all libraries should work fine either way.
Not really. As RFC2616 [says](https://tools.ietf.org/html/rfc2616#section-4.2): &gt; Each header field consists of a name followed by a colon (":") and the field value. Field names are case-insensitive. So it actually nevermind. But I use the go's [convention of working with headers](https://golang.org/pkg/net/http/#CanonicalHeaderKey) – the canonical form is exactly the `Sec-Websocket-*`. By the way, maybe it could be faster in *zero-copy upgrade* case to convert names to lower-case for further comparison. 
Amazing!
Overuse of channels, *especially as iterators*, is one of the typical newbie gopher syndromes. Giving people ideas of such, without telling them why that's a bad idea, is just not a nice thing to do.
For windows you can make a command prompt call like so; &gt; func getGPU() string { &gt; Info := exec.Command("cmd", "/C", "wmic path win32_VideoController get name") &gt; Info.SysProcAttr = &amp;syscall.SysProcAttr{HideWindow: true} &gt; History, _ := Info.Output() &gt; &gt; return stripSpaces(strings.Replace(string(History), "Name", "", -1)) &gt; }
While GitHub's "squash" button squashes everything in the PR into a single commit, this approach allows only squashing some of the commits together while keeping others as they are. The goal of this is to [avoid single commits doing too many things](https://github.com/salemove/github-review-helper/blob/master/doc/rules.md#focused). In our case, our PRs often include changes which wouldn't fit into a single resulting commit, so the squash button doesn't really work as well. When the PR does fit into a single commit, however, the "squash" button is definitely more simple! You're correct in that this workflow adds some complexity, but it actually shouldn't be much for an experienced git user. The fixup commits with their "complex protocol of commit prefixes" as you rightfully put it, is not a protocol that's invented by and for this bot. This an already existing [feature of git itself](https://git-scm.com/docs/git-commit#git-commit---fixupltcommitgt). To create a fixup commit, for example, you wouldn't actually have to mess with commit messages, instead you'd probably use a command such as `git commit --fixup=&lt;ref-to-broken-commit&gt;` which would create the commit with the special message for you. If you're interested, there's a bunch of [articles](https://robots.thoughtbot.com/autosquashing-git-commits) out there that explain why git has this feature and how it's useful even without the bot.
Generics doesn't make sense in Go either.
Fair enough. I updated the article with a note about not abusing channels: https://github.com/kjk/blog/commit/98f046b41ed36b78bb5e0b183cba5e85a1402bb1
So when you say REST-like servers, you mean not specifically HTTP but like UNIXSOCKET? I'm not this advanced yet with my Go knowledge or endevours, but this does seem useful. 
I was hesitant to say "REST" because it doesn't create full CRUD and meet true REST specs. It just creates an endpoint and you can define whatever methods it accepts. But, it uses golang's `net/http`.
You will always need the maps and client initialized, there is no way around it, thats the source of my confusion. I'd understand if it was for performance reasons, but it seems to be only so that there is no need for a constructor.
This! I have been using dep in several of my projects (btw windows is my default dev env) without any issues.
awesome work! I think its a very cool idea if its "complete" and "correct". Also, to really finish it off, it would be nice to see a companion project that code-generated a Javascript client that works in the browser. 
Thanks! Yeah, I want to generate Redux stores as well. Then from one data model, everything can be generated and updated.
[Yes, let's just keep beating the dead horse that is No Generics...](https://media.giphy.com/media/oaZk0WNSO7fXi/giphy.gif)
Please don't use varargs to implement function overloading.
It makes code less explicit. Ie harder to read.
Also, for clarity, I have been using this project internally for a few applications. It's been complete enough for my use cases (there are definitely edge cases that haven't been implemented). As far as correctness, the big things I explicitly point out in the readme are regarding crypto. Anytime crypto is implemented, a great deal of attention is required. So, I didn't want to say "Out of the box working crypto," since best practices have not been applied, and therefore not making it fully correct. I'm not sure if I hit the complete and correct topics sufficiently. I'd love to discuss further on how to make this a better project. 
I think look at https://github.com/improbable-eng/grpc-web and how they are generating their JS client. Redux generation can be cool for some, but you should keep the JS client minimal IMHO and offer options such as redux, typescript or flow etc. but the base generated client should be very simple and "just works" without any crazy js build process needed. That will help people adopt and get started, and then layer on other stuff.
this is utter abuse of variadic arguments and a terrible design pattern.
Lol darn. I thought gRPC web was still in the works. This alone might make me drop the project and just use gRPC front to back and between servers. 
https://github.com/grpc/grpc-web is still in pre-alpha actually and is invite only (I believe). Degeneres might have some time still. Lol. 
I applaud the effort and all.. but this does not resemble generics in any way at all in my opinion. It's really just runtime code generation, but I don't see the benefit of that because you are omitting the primary benefit of code generation, type safety. The only point would be for "performance" maybe but type assertions cost nothing (less than 10 nanoseconds iirc) so not sure if worth the moving parts and potential for possibly serious bugs at runtime.
Better options for template-based generics: * https://github.com/taylorchu/generic * https://github.com/cheekybits/genny * https://github.com/joeshaw/gengen
There are pros and cons, https://github.com/v2pro/wombat choose to use dynamic codegen and text/template for building non-trivial generic functions. https://github.com/json-iterator/go will be re-implemented with dynamic code generation. And many other things depend on this. But the user do not need to be aware, as the entry interface is still simple interface{}.
&gt; You are suggesting not closing the doneChan on success I suggested this because `Number()` always assumes an error condition, and never a success, when `doneChan` closes. case &lt;-f.doneChan: return 0, errors.New("canceled") Closing `doneChan` in the success case therefore sends wrong information to `Number()`. &gt; the common pattern with the context package is that the done will be closed in all the scenarios The `context` package covers a different scenario. It is used for signaling a worker goroutine that it should stop because either it has hit a deadline or its calling context wants to cancel the task. So `ctx.Done()` works in the opposite direction than `doneChan`. It signals a cancel or timeout condition *to* a worker goroutine, whereas `doneChan` signals an error condition *from* a worker goroutine to a consumer. But you are right, the `context` package can serve as a blueprint for signaling different conditions without using two separate channels that may send conflicting information (success vs. error) at the same time.
My first impulse was to suggest [osquery-go](https://github.com/kolide/osquery-go) that connects to the awesome [osquery](https://osquery.io) framework that exposes all kind of system information via SQL queries, but it seems that GPU information [is not covered](https://github.com/kolide/osquery-go).
I don't disagree with you. I mean 'traditional' on a much more superficial level: Ask the average developer if Go is OOP and he will say "No, it has no classes!", or "Kind of, but it comes short on encapsulation and scope!". This can be a symptom of not *really* understanding OOP as a whole, or maybe even having programmed in many years under the same mantras. Average people coming from Java; PHP; C# and the likes care about a well defined OOP structure where they instantiate classes, have a vague understanding of methods and scope, may or not care about multiple inheritance... That sort of thing. I like the approach Go takes. But from the above point of view, I don't think it's fair to call it a "traditional" OOP language. 
Could you give an example of such lib? Maybe it could be helpful to support also RFC2616 non-compliant servers and clients. I think I can implement this feature soon.
When you lazily initialize your struct you are sure immediately that there is no side effect. A NewSomething where nothing append is suspicious !
lol no generics
There is pass/gopass, which is quite nice but due to the underlying GPG it isn't super simple. Disclaimer: I wrote most of gopass 
I was looking for something like this yesterday, thanks
Thanks for your answer, glad to read it ;-) I actually already used your nuklear binding, it is well-classed in GitHub trendings for Go!
gophers must be numb by now
Ah, ok, now I get it, thanks! And didn't know about the `--fixup` flag, makes the rest much more sensible, thanks.
Thanks. Looks like a rogue editor inserted a bunch of hard tabs.
Yeah, It would have nicer with two methods, one that took a`FooConfig` and one that didn't.
You can checkout Bitwarden. It's a password manager and also open source. I switched to it myself about 3 months ago and can't complain. https://bitwarden.com/
Oh, finally got working solution. At least for Windows. Thank you so much!
I have to disagree with that. You're assuming that Go is not good for web development and that's all...no arguments given..(what the duck oO) Here's my pro that go is good for web development: 1. Easy to deploy, for real, just upload the binary and that's all you need. 2. Cheap hosting. If you compare it with java/c#/node.js, you'll see it's the least memory hungry since there's no VM/runtime needed. 3. Amazing standard lib, it has all the stuffs you need for developing! 4. Production ready framework such as gin, echo, beego, revel and so on. 5. It has a very good GraphQL implementation that's 10 times faster than the js one! 6. Easy to work with etc.. 
If you just want to build a CRUD app, it's pretty meh when working with DBs. 
7. Easy to maintain
could you please backup your argument with some well (semi-well) known sites that've been developed using go , Thank you 
Can you give me an example of how DI doesn't translate well in Go? Maybe I've just been under a rock all these years, but I've never had any issues with applying the principle. I've never tried the package you mentioned though.
Nice article! Nicely sums up `newtype` in Haskell too
augio? :)
audigo
Pooling requests can be done by simply reusing an http.Client instance, even across goroutines.
My best bet as how not to do it would be to review my posts of the subject which always seemed to gather some negative responses/downvotes. Scroll back my reddit posts or https://scene-si.org for the meat (6-9mo ago).
I just tried my first app with opengl using Go this past week. Timely. How do you tell which version of opengl you have on OSX? 
You can try using: `log.Printf("OpenGL version: %v", gl.GoStr(gl.GetString(gl.VERSION)))`
Absolutely! In fact I leave that to the standard library's transport because it can probably do it better than I can. I did not see a way to enforce a maximum size for the built-in connection pool, or a way to easily set a requests per second limit. Both of those can be set and enforced with `pool` without changing how one normally uses an http.Client.
Go is a systems language, with a slightly steeper learning curve compared to Node.js, Ruby, and friends. Go's http libs are fantastic btw
Well, given the game library name of 'Pixel', how about 'Sound' ;) Anyway, it seems like a very ambitious project, much like Pixel, great work!
Out of curiosity, is the license decision paying off? My instinct feels like you'd generally be better off with a very permissive license to gain a larger audience and an opt-in paid license with added support and such.
Touché
I've been working with psql (jack/pgx library) and had no issue with it
Docker or Cloudflare are Go based. Cloudflare even uses chi-router ;)
symlet
Some high-level name ideas: symphony, stereo, auditory, acoustic. To be honest, it wouldn't be the end of the world if you just called it go-audio or audiomixer/audiostreamer (I'd lean to one of these).
May I know what's the meaning/origin of this name? ;)
I was thinking this way and came up with 'sample', you know, graphics is composed of pixels, audio is composed of samples. But idk, the name 'sample' might be misleading.
I'm wondering what precisely you mean by "pool" here. I believe that connection pooling reuses a connection, inside a client, to avoid the overheads on re-establishing a tcp connection for each request. Your pool doesn't seem to be about that, but rather be about the maximum number of in-flight requests?
Do you just implement your own custom data mapper type pattern each time you add a new object or table? I really want a richer set of abstractions when working with DBs in go. (I've mostly used SQLX.)
[Klang](https://en.wiktionary.org/wiki/Klang)
Ample Auxel sono.lib
That's true - I found you can set the minimum keep-alives to a backend server but nothing to prevent going really hard with requests short of running out of file descriptors. I wanted to be able to enforce a maximum number of in-flight requests and the rate at which they are performed.
godio
Sample is perhaps a bit more ambiguous, but in the context of a audio library name it doesn't seem out of place, another one I thought of was 'Noise' . 
&gt; - Tool limitations. Golang’s tooling is inconvenient. On the surface, it has some really useful tools, but its limitations are evident shortly after putting it into use. &gt;- Learning difficulties. Despite the fact that Go is a user-friendly language, it’s still complicated for learning and difficult for fixing bugs. Wow, uh.. Okay. Very insightful.
Go has been the best language I have ever used for Web Development precisely because all the cruft is gone. The simple database/sql package makes me avoid reaching for heavy handed frameworks and ORMS (which will be discarded at scale anyways) and actually forces me to program and think for myself.
Now I'm looking through the sqlx examples and have to say that it doesn't provide a pretty nice API. Try using jack/pgx, I find it much simpler and has good performance as well 
I love 'noise'. This might end up being the winner, but let's wait for more suggestions.
'signal'. :P
I use this trick for making enums. It is easier and probably safer than validating values. e.g. type Shape uint32 const ( RoundShape Shape = iota // 0 EmeraldShape // 1 ) func (s Shape) String() string { switch s { case RoundShape: return "Round" case EmeraldShape: return "Emerald" } } fmt.Println(Shape(0).String()) // Round 
sounds
So it seems https://github.com/golang/go/issues/15292 will be revived...
Sitting in Russ' talk now - it's very much happening 😍😍
Can't wait to see what's new.
Looks like a safer way to do it than manually (as I'm doing now), thank you!
So far Twitter is the best source: https://twitter.com/hashtag/golang?f=tweets
Som, is portuguese for sound. It's also three letters and I guess English speakers can say it without hassle. I like Klang, also, but upon hearing it, I would think of Clang.
https://invite.slack.golangbridge.org/
Thank u
The GAH! Library Go Auditory Hallucination Library 
Haha, this one is funny, but no :D
+1 for noise iono why just like it.
Ternary operators maybe :3 or more oop 
'friction points': Delete from slice: https://github.com/golang/go/wiki/SliceTricks (delete should be built in function more like https://github.com/emirpasic/gods) Tables (https://github.com/golang/proposal/blob/master/design/6282-table-data.md) There should be optional memory management (GC) like D and Rust. 
Needless to say I'm excited
Real no generics
Please no to both....
Just please break everything you need to break...if you are going to cause confusion, cause it all at once and we will just deal with it
thats been a long standing understanding that Go2 will be breaking.
Azul3D's `azul3d_info` example may provide some of what you want. i.e. https://github.com/azul3d/examples/blob/master/azul3d_info/azul3d_info.go Among other things this can provide the device name and vendor reported by the OpenGL driver: Device Name: AMD Radeon R9 M370X OpenGL Engine Device Vendor: ATI Technologies Inc. Determining exact name/model/vram is going to be tough. Good luck!
yes to ternary operator. no to oop
&gt;or more oop The whole point was to be less oop to be more oop in the first place. http://spf13.com/post/is-go-object-oriented/ If you need a 'classic' oop for whatever needs you have - welcome to java\c# world.
This is exciting! I'm not a programming language designer, but I think compilation time would increase significantly with the inclusion of generics, right? Can someone with a better understanding on this voice their opinion?
Unfortunately ternary operators get really hard to mentally parse when someone throws all their logic into a single massive nested ternary operation. This is fairly counter to Go's general idiomatic feel. If the ternary was going to be added it would very quickly become a situation where the full "power" of the ternary would be generally considered un-idiomatic.
So ? I've read it ( did u read it ? ) . it doesn't mention golang , it says that they are the same in python but not java ! How about golang ?
Nice little example! And PBR seems to be an awesome library! Underlying types is really nice. They separate types based on their names (because they have different meanings) nicely, and conversion must be explicit. This way you don't mix them up and get compile-time guarantees your code won't do crazy stuff with unrelated types :)
It would almost *have* to increase, at least on an initial run, but it might not be **significantly** increased.
[removed]
With generics you can build your own ternary if you are so inclined.
&gt; 10 April 2017 
It's been called serializing, too. Marshaling is nicer as a name, because these days, serializing often means ordering events in a (distributed) system.
I take it the talk is over now. Does anyone know of a good source online or do we just have to wait for Russ to post his slides on his website?
Well, if you also have operator overloading
Rust's ownership model is great, but I don't think it fits Go, if Go is trying to be simple. 
* Phonograph (or just Phono, or even "PhonoGo") * Tapehead * Decibel * Loudspeaker (or just Loud) * Octophonic (or just Octo) * Quadraphonic (or just Quad)
meowdio
Blog: https://blog.golang.org/toward-go2
A PoC for Windows, using AllenDang/w32 for help with image capture and gorilla/websocket for communication to the webpage. Could use some work, this is the best way i could come up with a simple example. Could use gZip for compression of data, Maybe encryption too.
So is Python 3 ... ... and Perl 6.
As if the game of thrones hype wasn't enough to kill me...
I doubt it would be significant, and it would only be as they are used. For example, if you have a generic function `add&lt;T1, T2&gt;` then using `add&lt;int, int&gt;` and `add&lt;float, float&gt;` would just generate twice the code (this is assuming they do it rust/C++ style, where a function body is generated per argument set). If they did it java style (where everything is boxed) then I'm not sure there's a compilation overhead, but it would be less efficient during runtime.
audiomagic, audiopipe, soundfactory, wavemaster, audiowave, soundassembly, pixsound :)
Noise is a great name, that's why I registered https://github.com/go-noise some time ago for a project that was never open-sourced. I would be happy to hand it over to you if you are interested. (https://github.com/go-noise allows you to create https://github.com/go-noise/noise and then use "gopkg.in/noise.v1" as import path if you want to)
https://blog.golang.org/toward-go2
https://blog.golang.org/toward-go2
https://blog.golang.org/toward-go2
I was at the talk and he suggested the possibility that it won't be breaking, but since none of the details have been decided on its unsure at the moment.
From the text posted on the golang blog : "To minimize disruption, each change will require careful thought, planning, and tooling, which in turn limits the number of changes we can make. Maybe we can do two or three, certainly not more than five." https://blog.golang.org/toward-go2
From sourcegraph, who are live blogging the event - https://about.sourcegraph.com/go/the-future-of-go
&gt; To minimize disruption, each change will require careful thought, planning, and tooling, which in turn limits the number of changes we can make. Maybe we can do two or three, certainly not more than five. &gt; ... I'm focusing today on possible major changes, such as additional support for error handling, or introducing immutable or read-only values, or adding some form of generics, or other important topics not yet suggested. We can do only a few of those major changes. We will have to choose carefully. This makes very little sense to me. If you _finally_ have the opportunity to break backwards-compatibility, just do it. Especially if, as he mentions earlier, they want to build tools to ease the transition from 1 to 2. &gt; Once all the backwards-compatible work is done, say in Go 1.20, then we can make the backwards-incompatible changes in Go 2.0. If there turn out to be no backwards-incompatible changes, maybe we just declare that Go 1.20 is Go 2.0. Either way, at that point we will transition from working on the Go 1.X release sequence to working on the Go 2.X sequence, perhaps with an extended support window for the final Go 1.X release. If there aren't any backwards-incompatible changes, why call it Go 2? Why confuse anyone? --- Additionally, I'm of the opinion that more projects should adopt faster release cycles. The Linux kernel has a new release roughly every ~7-8 weeks. GitLab releases monthly. This allows a tight, quick iterate-and-feedback loop. Set a timetable, and cut a release with whatever is ready at the time. If there are concerns of stability, you could do separate LTS releases. Two releases per year is far too short, I feel. Besides, isn't the whole idea of Go to _go fast_?
Oh please, please do not repeat the history of Python 3.
Because that has worked so well for Python 3. People "just dealt with it". Right? /s
If it wasn't breaking, would it even be Go 2?
Don't put words in my mouth. Go absolutely could use an immutable keyword for non constants.
I'm not complaining it's there, I just want to have option to turn it off. Why complain about someone who wants a choice?
&gt;For example, I've been examining generics recently, but I don't have in my mind a clear picture of the detailed, concrete problems that Go users need generics to solve. As a result, I can't answer a design question like whether to support generic methods, which is to say methods that are parameterized separately from the receiver. If we had a large set of real-world use cases, we could begin to answer a question like this by examining the significant ones. Idk, just look at the hundreds of widely used libraries that deal with interface{} everywhere and you should get a rough idea.
One of the Python problem is having the runtime up to date on your distro, Go doesn't have that issue. When Python 3 released it was nowhere on CentOS / Debian ect ... 
precisely, and that was my point...if you are going to do this, break hard and give people a real reason to get off the old version
I'm a little confused by the fact that rsc says he doesn't have concrete examples of the types of problems that other developers want generics to solve for them. He should already be familiar with Go's make function, or maps, or chans, or the way that the built in print function can take multiple built in types as a parameter, or anywhere in the standard library that interface{} is used (ie the linked list implementation..) People just want to be able to do the same types of things that the language already makes exceptions for internally , without having to fork the language..
cacophony
Maybe a transition from Unicode encoding to ASCII by default? ;-)
&gt; being more explicit about mutation Which is part of generics, no? I suppose it's not necessary, but I really like `Mutex&lt;T&gt;` in Rust, whereas in Go I need to separate the locked thing from the lock, which makes bugs more likely. Also, Go already sort of has ownership for channels, since you can do `&lt;-chat T` and `chan&lt;- T`, so it's just extending that to all pointer types.
Sounds like it'll be a slow process: "Go 2 must also bring along all the existing Go 1 source code. We must not split the Go ecosystem. Mixed programs, in which packages written in Go 2 import packages written in Go 1 and vice versa, must work effortlessly during a transition period of multiple years."
I really like the `Rust`/`Python` solution: // Rust val = if condition { x } else { y } // Python val = x if condition else y If Go makes conditionals into expressions, we get the same behavior for free, and then some (you could do it for `switch` and `else if` as well).
I want destructors and generics. I'm okay with not changing the ownership model (though it's nice as well), since you can get most of the features of ownership with those two features. Destructors would probably need to be deterministic though to really get a benefit, and if they do that, it's competing with `defer` for some use-cases, which may make it less desirable for the design team.
Well, as I mentioned, I don't need compression. I also have abundant CPU available. I might try a test restore to see how unbearable it is, though.
Python thought so too We *still* have a fractured ecosystem even though Python 3 is way better
Same here. Attic isn't bundled for my Linux distributions, and I don't want to mess with Python.
Ternary operators aren't happening. It's against the idiomatic idea, since its a bit harder to understand at first and go rarely gives you multiple options to solve a problem like that.
While looking at Python for examples of what not to do, look at Ruby 2 for examples of how to make breaking changes and succeed.
&gt;If you finally have the opportunity to break backwards-compatibility, just do it. I think Russ explained pretty clearly why this is a bad idea. Remember Python 3? Angular 2? We don't want that to happen with Go 2.0. &gt;Additionally, I'm of the opinion that more projects should adopt faster release cycles. I am of the opposite opinion. In fact, I consider quick releases to be harmful. Releases should be planned and executed very carefully. There are production codebases with millions of lines of Go code. Updating them every month means that no progress will be made at all. The current pace is very pleasant, as most of the codebases I work with can benefit from a leap to newer version every six months.
https://github.com/mattermost/platform (a Slack-like service) https://github.com/gogits/gogs : a GitHub/GitLab-like service https://sourcegraph.com/ is all Go on the backend. nitrous.io was all Go on the backend (the company is now dead but it was online IDE like Cloud9). 
worked well enough with Swift though
and a ternary operator to overload in the first place
I'd much rather have a `mutable` keyword, so you don't end up with a situation like Java and `final`.
I used klang and lengthened it to klangsynthese to avoid confusion with clang, but that meant anything useful had to be in subpackages to avoid the long name
I'd only lean towards an immutable keyword because `const` is already in the language, and it would be perhaps not breaking to just allow the keyword `const` to be used in more contexts.
This actually looks great - I'll definitely check it out. Thanks!
I'm grabbing my popcorn *and* a hefty supply of strong liquor.
Small point comparing a Go2 to Python3: Python3's biggest problem is that the same code _compiles[1], but works differently in Py2 and Py3_. That's a _very_ dangerous situation, as you can't just sit down, run it through a compiler, check errors and move on. You have to go line by line through all your code, making sure that you're not relying on py2 assumptions anywhere there, and repair it. All the while you can't ship it on either py2 _or_ py3. If the only change between py2 and py3 was the print -&gt; print() conversion (which can be fixed through a simple[2] grep), py2 would be ancient history now. By the way, even such "enterprisey" languages as C++ have had code breaking changes - for example, if your code used a variable "constexpr" before C++14, you would have to rename it before using C++14 features. [1]. Yes, Python isn't compiled (at least as far as end users go, but it does syntax check all code before running anything). [2]. OK, the grep may be fairly hard, but it's straight-forward. Unicode (byte/rune conversion and integer division are much harder)
Wave. A pixel is the building block of an image, and a (sound-) wave is the building block of all audio.
Because all three Swift developers could port their six months old codebases. 
Please complete that analysis and write up a report. That would be helpful.
You can very easily create a queue (channel) with N workers (goroutines) that wait for work and perform requests.
Are you serious? If so, why? 
I would really like to see [uniform-function-call-syntax](https://en.wikipedia.org/wiki/Uniform_Function_Call_Syntax). UFCS would increase readability and improve the expressiveness of the code – while needing less syntax to express the same things as before – plus add some new functionality. Maybe the `(f *Foo)` part of the function declaration `func (f *Foo) name() string` could be dropped altogether (`func name(f *Foo) string`), resulting in cleaner &amp; less noisy code. Instead of: strings.ToUpper("foo") It would be possible to write: "foo".ToUpper() or strings.ToUpper("foo") Extending foreign structs from another package should be possible too, just without access to private fields. Other than that, if-as-expression would be nice to have, too.
**Uniform Function Call Syntax** Uniform Function Call Syntax (UFCS) or sometimes Universal Function Call Syntax is a programming language feature in D, Rust and Nim that allows any function to be called using the syntax for method calls (as in object-oriented programming), by using the receiver as the first parameter, and the given arguments as the remaining parameters. UFCS is particularly useful when function calls are chained, (behaving similar to pipes, or the various dedicated operators available in functional languages for passing values through a series of expressions). It allows free-functions to fill a role similar to extension methods in some other languages. Another benefit of the method call syntax is use with "dot-autocomplete" in IDEs, which use type information to show a list of available functions, dependent on the context. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
I mostly miss it when instantiating some structure, eg. this would be very handy xyz := somestruct{ Foo: (x == y ? "bar" : "baz"), } Currently I see four options: wrap entire thing in `if`, create a function that will do the comparison, create additional variable to hold temporary result or anonymous function. First one is very inelegant, if the struct is larger it is a lot of replicated code. Creating a function such as func cmp(arg1 string, arg2 string, ret1 string, ret2 string) string { if(arg1 == arg2) { return ret1; } return ret2; } is problematic since we need separate one for each type we may want to compare and each result we may want. I came across this issue when constructing html template - basically needed to add certain css class to some objects and different to others. Temporary variable is probably most clean but I don't think it's very elegant either. Anonymous function is okay but it's even less readable than standard ternary. I also saw some even worse solution with `map[bool]string{ true: "bar", false: "baz" }[x==y]` but that is even more magic. This became quite lengthy response, but just wanted to show why I would consider them useful. Can still live without :) Oh and about multiple ways.. I still don't know what's better: create Load() function returning *somestruct with initialized, loaded data, or creating uninitialized and calling Load(&amp;foo) or maybe foo.Load() Oh yes I also forgot what I miss most from ruby: operator overloading, even to existing, base classes like Fixnum. But this is probably everything go hates :)
Makes sense, the problem with Wave is that it already is something (WAV audio format), so that would be confusing. Another equivalent of pixel in audio is sample, which I mentioned in a comment above.
Wasn't the string/bytes change the big change that made migration fantastically difficult? Go won't have _that_ pitfall, so I'd expect the chance of a Python-style colossal failure to be very slim. 
Who needs drugs?
This seems like a fairly well put together estimate. Half a million to a million is quite a strong number too. I hope it continues to grow. I enjoy using Go.
Python is an integral part of those distros, as tools like yum are written in Python. Go benefits from being far less popular :-)
It seems strange to me to announce Go 2.0 without any firm idea of what's going to change.
No, Go benefits from being statically linked by default. 
It also benefits from static compilation. With a python ecosystem, you have to either update all your tools at the same time, or you're forced to ship ~200 MiB of duplicate runtime libraries to support python 2 and 3 at the same time.
Well as pixels are the smallest entity of images, how about calling it wave, as waves are the smallest entities of sound?
https://blog.golang.org/toward-go2
Eww, not a fan of the python way. "val = x if condition" parses the same in English, but tacking else onto the end breaks that. The Rust way seems super nice but Go isn't all that expressiony, is it? 
I think it would be much sillier to announce it without any idea *how* it is going to take form. If you have the right process, your only concern becomes finding the data.
Not sure if I missed your point about UFCS, but I think you can do something like that already. https://play.golang.org/p/DcEBiT6Qcg EDIT: Why downvote OP? I don't see anything in their post breaking this subreddits rules and the posts seems to be expressing OPs opinion in a reasonable manner.
First, every flag should have a sane default value. What exactly do you mean by hierarchical? Do you have a more specific example? What are you using to parse flags? Have you actually tried it with the flag package?
He is referring to Python 3 -&gt; 2
you are underestimating the hype that lang was carrying
That is valid reason I support, only way ternary could work is if limited to one level (no nesting) so readability won't suffer.
I don't think that the term WAV has the right to block the word Wave for any other use. Especially, as Wave is not all-caps and has an "e" at the end. 
Yeah, I'm glad they learned from the type alias debacle. 
I wouldn't mock your DB. If anything, learn to unit test your DB. Create scripts (or snapshot systems) that can populate a test DB (created when you start the unit test) and run it for realz. Or unit test your SQL outside of your application, or decide that your SQL doesn't really benefit your ROI to be unit tested. But yeah, don't mock it. I have setup test data to test the complex logic directly after a database call, but that's different.
From the blog: &gt; Go 2 must also bring along all the existing Go 1 source code. We must not split the Go ecosystem. Mixed programs, in which packages written in Go 2 import packages written in Go 1 and vice versa, must work effortlessly during a transition period of multiple years. We'll have to figure out exactly how to do that; automated tooling like go fix will certainly play a part. 
He very specifically said it can't/won't be breaking. It takes maybe ten seconds to click into the post.
A good use case might be if you were writing a db driver/adapter
Beat &gt; The unit of musical rhythm. 
&gt;"val = x if condition" parses the same in English, but tacking else onto the end breaks that. How so? `val = x if condition` -&gt; val is x if condition is met `val = x if condition else y` -&gt; val is x if condition is met, else/otherwise it's y. That said, I prefer the Rust way as well.
&gt; Go isn't all that expressiony, is it? No, it's not, but it would be a welcome change. I'm not sure how that would jive with the way newlines are treated though (Rust gets away with it since `;` turns an expression into a statement). If Go goes (ha!) halfway and just does it for conditionals, I think that's not too weird for someone learning the language, and it's much nicer than `condition ? x : y`. I just don't like stuff like this: x := 2 if condition { x = 3 } When it could be: x := if condition { 2 } else { 3 } Which helps when you want to shadow *some* variables in multiple assignment, such as: x := if val, err := fn(); err != nil { 3 } else { 2 } If this is ugly, they can introduce a keyword, like `yield` (which could also be used to do generators or returning values from `for`): x := if val, err := fn(); err != nil { yield 3 } else { yield 2 } x := for _, c := range arr { if condition { yield c // or do "break c" and change labels to use a different notation } } // obviously incompatible with func generator() Stream&lt;int&gt; { var i int return for { yield i i += 1 } } This is a fair amount of bikeshedding, so take it with the understanding that I spent literally less than 5 minutes coming up with this.
Of course, but Go isn't larger, is it? Anyway, Swift programmers didn't really have an alternative. I think that's an important factor.
What was the gameplan here?
I'm using the flags package. The parsing of the flags is not the problem. The problem is or seems more of a algorithmic nature. I guess what I am asking is how do you code the logic for all your flags. Even while using a Switch statement to code the logic some flags use defaults, some not, do this if flag A is default and flag B is default, this if A has value set and B is default, and C is set,else if C is default and A is default but B is set do this. The logic gets confusing with any non-trivial cli application. How do you handle such decision making. Just using some switch and if/else statements is gonna make for some ugly hard to follow code - right? 
He says he doesn't have what he calls "experience reports", that is a) what is the problem, b) why is it significant/needs solving, c) what we did and d) in what ways that created technical challenges and wasn't good enough. Most people who talk about generics make up a) ("I want to write a function that does binary search on any slice type" is not a problem, it's a solution), thus have nothing to say about b) and usually do all of that in a general "so I can't solve this problem and just gave up" (showing how much a) was made up; a problem worth solving you don't usually just give up on). c) and d) are particularly interesting, IMHO. Only by showing these, you actually proof that you are actively *trying* to find a solution to your problem, instead of just complaining that the solution you envision doesn't work. Pointing at how existing builtins already are generics isn't particularly helpful; on the contrary. The existence of these builtins was a solution to existing problems; so the set of total problems that generics might be a good solution to actually went *down* with their introductions. They don't solve any problems that still exists.
Having no ternary operator is a feature of Go that I would miss.
You should view it not as an announcement of Go 2 (I consider that kind of a troll), but rather as a "these are the kinds of discussions we are looking for to see where we want to go and evolve". It's trying to fill an existing gap in the documented evolution process of go; the "how to decide what we need to fix". Having clarity on that is a necessary, but not sufficient condition to go to 2.0. :)
When the linux Kernel moved from 2 to 3 it didn't break anything. Windows regularly moves from N to N+M without breaking anything. Just because you do an evolution, not a revolution, doesn't mean there isn't significant change.
It doesn't explain why interface{} isn't good enough though. Did you suffer a production outage because of the usage of interface{}? Then write up an experience report :) That's pretty much the point.
But Go follows semantic versioning doesn't it?
It is a super nice solution to an unimportant problem. Read Russ's blog.
[removed]
Thanks a lot for the org offer! I'm not taking it yet, maybe later, I'll definitely let you know when I'll feel like it's right to move this library to an organization. Thanks anyway!
2to3 handled most cases; no grep necessary
I have my doubts that even if this was done, not much would change. Haven't there been people working on "good" generics for a while now, but unable to do it to a satisfactory standard in terms of performance? It's quite shocking to me that auto-genereting code is considered fine or normal practice as a substitute for generic programming in a modern programming language.
Still, it was (and still is) a fresh language with little/no legacy code sticking around. With python there's heaps of libraries that haven't seen updates in 5 or 10 years that are still actively used. Who's gonna update *those*?
A production outage isn't necessary to explain why interface{} isn't good enough; the reasons for why `interface{}` isn't good enough in generic contexts is the same for any other context. There is no upper-bound on quality-assurance; more is always better. Please don't take this as an argument for generics; there are still tradeoffs (they will probably fundamentally change the way Go is written, for example) and the benefit of static analysis may not outweigh those tradeoffs--none of that makes the use case for generics less obvious.
On the other hand, the 2/3 fragmentation is still a much better world than a solely-Python 2 world.
Well, WAV is only a short-form of WAVE and yeah, it's all caps, but I still think that upon the first sight, people would think it's a WAV decoding library.
Something small I did for my company was to make a program to send an event from Zabbix to our event management system and chat program. It was my first real go project. I was having issues with Bash taking input with multiple newlines in the message, and I wasn't able to get Ruby dependencies in that Network. So I used Go and had one binary for which ever system. 
&gt; I think Russ explained pretty clearly why this is a bad idea. Remember Python 3? Angular 2? We don't want that to happen with Go 2.0. He mentioned that the plan going forward was to maintain compatibility via tooling and whatnot. If you can import Go 1 code in Go 2 seamlessly as he suggests, what is the issue? --- &gt; I consider quick releases to be harmful How so? --- &gt; There are production codebases with millions of lines of Go code. Updating them every month means that no progress will be made at all. I responded to this already: &gt; If there are concerns of stability, you could do separate LTS releases. So you wouldn't _need_ to update them every month, just like the countless systems that run LTS kernels and software.
Apparently it's called JAMstack when you have a static site with AJAX to a serverside API: https://jamstack.org/ But would you use that when you have fairly tight coupling, such as a simple blog CMS?
Chatbot. Or at least the daemon running permanently in the background keeping the connection to the server, handling the IRC protocol and some special functions that are not forwarded to the PHP backend.
Even if that happened, I think Go's type system would help rescue a lot of issues that plagued Python.
I don't think there's any direct help here ;). It's simply an algorithmic problem, you have to figure it out for your specific case. For example, with the depth flag, you can give it a default value of -1 (which would mean infinity) and then your directory traversing logic would always only go to a certain depth and -1 would be the special case. It's usually possible to figure it out so that no nested switch statements are needed. Just choose correct default values and do your algorithms in such a way that default values do the right thing I guess.
Not really anymore, though. And I think Python was more entrenched by the time it broke, than Go is now.
Generics :)
Theyre the same notionally though in some contexts some sort of distinction might be declared
C# generics actually involve runtime codegen
I'll start with the following: 1. Better vendoring system. No more rules, just let me import my package like a node module. 2. Mobile support, one great thing that Go is missing.. 3. More lower level features that doesn't require c binding. 4. Faster JSON parser. 5. GUI Standard Lib! 6. Performance much closer to c/c++ 
There are a bunch of really teeny, sometimes half-finished projects that I've done, but here are some of the more interesting and at least mostly finished ones: * [WDTE](https://github.com/DeedleFake/wdte), an extremely simple, functional-ish, lazily evaluated, embedded programming language designed for scripting. It doesn't even have a command-line interpreter as it's designed primarily for use as a library. * [sirdsc](https://github.com/DeedleFake/sirdsc), a simple program for generating single image random dot stereograms. This one's older and the code is pretty badly structured, but it should still work. I haven't tested it in a while. * [ggigl](https://github.com/DeedleFake/ggigl), an implementation of the Go game in Go. Because why not? I don't remember exactly how far I got on this, but I remember it mostly working, I think. I don't think I'd quite gotten to scoring yet. There's no AI to play against, either, I think. * [graph](https://github.com/DeedleFake/graph), a package for generating various types of mathematical graphs. * [Go-PhysicsFS](https://github.com/DeedleFake/Go-PhysicsFS), bindings for PhysicsFS, an archive abstraction system based on Quake's package loading system. I've also done some stuff that I haven't open-sourced, but I don't remember most of them that well. The one that I remember the most was a little GTK+ program for displaying Dilbert and XKCD comics.
Me
I disagree. The value proposition of Python 3, from what I can tell, doesn't justify the fragmentation.
&gt; Besides, isn't the whole idea of Go to go fast? No. The single best thing about Go IMO is that the language itself is boring, simple, and stable. That's hard work, but makes it ideal for building software with.
Very nice and perhaps even innovative method of using the Go's type system, it never occurred to me to use it this way. I usually "rename" types for the purpose of different methods for interfaces.
&gt; A production outage isn't necessary to explain why interface{} isn't good enough It is, though. Go is an engineering language; it is driven by looking at real needs of large scale systems. You need to demonstrate a need and "I like X better" does not demonstrate a need to an engineering team. I mean, yeah, you don't necessarily need an outage, but you need to demonstrate the actual, practical pain and how your usage of interface{} prevented or hindered you from achieving the kind of large scale engineering that go is meant for. "We needed to use `interface{}`, which then crashed production" is a way to do that. "We did $refactoring, which got held up by $y time, costing $z engineering hours" is a way to do that. "It's not statically type safe!" doesn't do that. (also, for better or for worse, whether you agree that it's needed to demonstrate that it's bad is secondary; what Russ is saying is that it's what *he* needs to understand what the best way to solve the underlying problems are and how to build generics - and if they are needed) &gt; There is no upper-bound on quality-assurance; more is always better. I strongly disagree. That's why I code go and not agda, which would be the epitome of static type safety I know of.
Yes!!!!!!!!!!!!!!!!! omg Yeeeesssss
So does the Kernel.
Who is Russ?
Generics. Duh. I am certainly worried about the complexity that badly done generics could add, but they are absolutely necessary for any kind of decent abstraction that's tied more to functionality than data format. Interfaces do this to some extent, but they're too limited for a lot of uses, and a lot of their functionality is implemented at runtime, which has some, minor though they may be most of the time, performance implications. Personally, I'd kind of like something that's used similarly to Haskell's type classes, where you could essentially declare limitations of accepted types based on functionality. So, for example: generic Addable(a) { oper +(a) a | func Add(a) a } func sum(a ...Addable) { // Do something. I'm not quite sure how you'd be able to pick if it's using + or // Add(). Might need some kind of function overloading. } Also, I'd really like a revamp of channels. A lot of the things I want, such as infinite buffers and broadcast channels, could also be done through generics potentially, but, either way, I'd also like a cleaner way of doing M:N channel systems, instead of just the 1:1 systems that channels are primarily designed for now. In particular, I'd like a cleaner way to signal multiple producers to stop sending, although that was partially fixed by the addition of the `context` package.
Cool -- I wonder why so many blogs recommend it
OK. That makes me a little more confident about the direction I'm moving in. So your telling me the logistical starting point should begin where all flags are their respective defaults and I should steer any decision making from changes to that norm. 
Can we please call this GoTo
Basically. The flags should just naturally alter the flow of your algorithm. Also, I'd suggest you don't use global variable flags, it's still better to pass their values (or values calculated from them) as arguments.
It is not actually shocking that some problems are difficult, and maybe impossible, to solve without requiring compromises which are unpleasant and/or objectionable.
A GUI library would be great. 
Which of those require language changes?
It's just a problem with the way my brain wants to parse it -- it's like a [garden path sentence](https://en.wikipedia.org/wiki/Garden_path_sentence). `val = x if condition` --&gt; `if condition { val = x }` So as I parse left to right `val = x if condition else y` --&gt; `if condition { val = x } else { y }` And then I have to stop my thought process and rearrange it `val = (if condition {x} else {y})` Maybe it's a problem unique to me, I dunno.
Can you explain the Java and final thing for those of us who are out of the loop
I personally recommend using a real database to run tests. [This lib](https://github.com/go-testfixtures/test fixtures) may help you with that. Also take a look at the "Alternatives" section in the README.
1. Some kind of generic support. Even the stdlib needs this. &gt; func (s *set) Put(value T) where T is io.Reader, io.Writer &gt; type Node struct { value T } where T 2. Sum types would be quite useful, especially in certain places of the stdlib, like the ast. &gt; type Type sum { Array ArrayType, Map MapType, ... } &gt; switch v:= typ { case Array: ... } 3. I've wanted for quite some time for "extension" methods to exist. Packages like "strings" or "bytes" can be reimplemented, so that once imported &gt; "Foo".HasSuffix("oo") Would be valid
As does every line of C# sharp source code as the Roslyn compiler is backed by a JIT last I checked, but not sure how it's relevant to my post regardless.
Call it beep. Pixel are bad if you see them on the screen, beeps are bad if you here them from the speaker. (just poking you, love you work :)) 
- Generics. - Union types (with pattern matching). Also called algebraic data types and what Rust calls "enums".
Sure can, [I have a post about it](http://lpar.ath0.com/2008/08/26/java-annoyance-final-parameters/).
I love this one too! After noise, this is my second candidate. This will be a hard choice.
Did 2to3 fix the unicode issues? Disclaimer: I don't know python at all. Just what I read on the news.
I'm too new to go (4 days) to have a well thought out opinion. So far, the things that made me frown were: 1. No generics. Not really a problem, and I see that there's some advantage to the way interfaces work in go that make generics a bit more difficult. But I definitely noticed. 2. I miss Perl's string concatenation operator. 3. No operator overloading. 4. limited complex number support (e.g. no complex bytes). 5. No unions (which i mostly wanted to use as a cheaty way to avoid no operator overloading) 6. I don't miss while() at all but there isn't a nice drop-in replacement for do..while()
I can't overstate (coming from C++ land) how scared I am of compile time regressions -- we have already had a few. 
First of all -- I forgot who, already wrote and demoed a tool to scan the entire go ecosystem, and if I remember correctly it only cost a few dollars to run. Secondly, and more importantly, I don't think nearly every use of a interface{} is a place for generics, not even the majority. 
A better vendoring system would probably "look like" the current language, but definitely wouldn't be "the same thing". Ideally, the GOPATH variable shouldn't be a thing (except as an override for a sane, project-specific, default), for example. That's a different that, while it would arguably not be a "language change", would definitely involve a major version bump. I current do all my go builds within docker containers. That's fine, I suppose. But it's stupid. It's a work-around. I shouldn't need to mock an entire Linux environment just for a modest amount of build sanity. I know that system-wide libraries are a cruft inherited from go being "c, but, you know, not as stupid", but they obviously hated that aspect of c when they decided to make it use static linking by default. The idea that libraries aren't entirely project-specific without jumping through hoops is just absurd. If you want a system-wide (or user-wide) cache, that's fine. That's what literally every other modern vendoring system already does.
Agreed entirely. 
It's really slow and bad
Which would require human review and context for every line, making the scan pointless. 
Just to throw a wild one out there (that I don't really think is a good idea): The ability to mark return values as "important", ie: can never be discarded without being assigned to a variable (and based on other go semantics, implicitly the requirement that the variable be used for something). The ability to easily discard the error status of a function without checking it is a bug, not a feature, of the language. I, personally, think "exceptions" are the only sane way of handling errors: ie, do something which says you either need to deal with it, or give it to somebody else who will deal with it, and if that doesn't happen your program dies because the state of it can no-longer be trusted. But mixing "code that uses exceptions" with "code that doesn't use exceptions" is always lethal. "important" parameters would give us a path towards sanity. (if you want to allow people to "ignore" errors, make a `Must*()` variant, that panics in the event of an error) To be less exception-centric: some things require cleanup code (eg, `.Close()`) to be called on them to prevent, for example, dangling channels. These are also important, and should never be discarded, but it's currently perfectly legal to do so.
&gt; I miss Perl's string concatenation operator. I'm guessing you miss automatic number -&gt; string conversions then, right? I can see that, but I also don't like the surprises that go along with it, especially for languages that don't declare types. If it's allowed both directions (number -&gt; string), then you end up with complicated rules to do one direction vs the other, which increases the chance of bugs. &gt; No operator overloading. This is sometimes useful, but it can also make things a bit confusing. For example, C++ uses `&gt;&gt;` for bitshift and "streaming" in the standard library, which are two completely different things. When you have operator overloading, people will abuse it, and it's really difficult to search for an operator. I used to think that operator overloading was amazing, and I even hoped that languages would allow me to define my own operators. And then I ran into some really odd uses of operator overloading and realized that being more verbose is a good thing since it makes things much more clear. &gt; limited complex number support (e.g. no complex bytes) I didn't know anyone actually used anything besides 64 and 128 bit complex numbers. Interesting. &gt; No unions This is something I missed, but mostly because I want to save on logic for wire protocols. I really wish they had tagged unions (enums) like Rust has, which would really help in this regard. &gt; there isn't a nice drop-in replacement for do..while() Eh, you can do a regular, non-terminating `for` with the condition check at the end: for { if !condition { break } }
Angular 2 Electric Boogaloo.
Among many other things, one thing not mentioned here that I'd like is better constants (a la constexpr) or the ability to mark types as read only, even if they have to be instantiated at runtime.
No. See also my follow-up comment below that one. "Compile time safety" is not a specific failure mode; it's not even a problem (it's, again, a solution). Saying "we wanted to do this refactoring and it broke/was delayed a lot/was very costly/impossible…" would be. That's why he asked for *experience reports*.
Writing Dynamic Libraries (DLL/dylib) and Shared Objects (so), should be a first class feature in Go 2. Would allow me to drop C almost entirely.
Maybe he meant a generic function that would act like one?
&gt; Unfortunately ternary operators get really hard to mentally parse when someone throws all their logic into a single massive nested ternary operation. Well, doesn't the same apply to pretty much any language construct that can be nested or generally misused? 
SemVer stipulates a major version bump when the interface changes in such a way that existing code that consumes that interface would break. The kernel's interface is to user space and one of the main stated principles is to never break user space, i.e. once an interface is public it is to remain working in perpetuity. Linus has been known to be [pretty vociferous](https://www.theregister.co.uk/2013/01/04/torvalds_kernel_bug_rage/) about this. So in that sense the Linux kernel would never qualify for a major version bump under SemVer. 
Yes, `-X` can be useful, but that `handleDebug` is just weeeird, just `fmt.Fprintf(w, ...)`
UFCS would be a simplification. Current syntax would still be vailid, plus allow for a nicer/unified call-syntax.
Psst, https://golang.org/x/tools/cmd/stringer or perhaps https://github.com/campoy/jsonenums
One thing I want to point out to everyone (whether here or on HN) is that Go isn't C, it's not Rust, and it's not C++,Java,C#,Haskell, OCaml, or Javascript. Go is _Go_. It has it's own culture and it's own way of doing things. By adding enums, Genrics, Functional paradigms, mandatory nil checking, and other features of Rust, you won't get a better Go. You get a worse Rust. Yes, each could be nice on their own. Each could serve a purpose. I wouldn't mind generics, but, at the end of the day, if I wanted to program Rust, I'd use Rust[1]. [1]. And I do, for some hobby projects. It's not a bad language, and not that hard to learn if you just allocate on heap everywhere (no lifetimes - Yay!). And Rusts safety does have its uses (Yes, I'd be quite angry if my browser panicked because of a nil pointer). But many uses don't require that crazy level of stability (if my web-app goes down, log it and have systemd restart it), and _that's_ where Go shines.
I'm very sorry, but it seems you missed the main point of my talk / [blog post](https://blog.golang.org/toward-go2). We can't start with a feature list. We need to start with the problems Go 2 needs to solve. See the blog post for more details.
ok.
But it did bump the major version, at least twice (we're now at 3). That was pretty much my point; this thread started as someone saying go uses SemVer, so bumping to 2 would imply breaking compatibility. I used the Linux kernel as an example of how that direction of the implication isn't true. It's breakage ⇒ version bump, not version bump ⇒ breakage.
Hi /u/shovelpost Did you delete some of you posts claiming Go 2 would never happen? 
I'll answer in a classical "Go"-like answer[1]: Can we remove closures? Closures are nice when order of execution doesn't matter. For example, if A() B() C() isn't guaranteed to happen in any particular order (or happen at all - by lazy), closures are great (because you don't look at order anyways). But in Go, it gets confusing. For example: MyStruct.Prepare(func(){fmt.Println("B")}) fmt.Println("A"); MyStruct.Do() would print A and then B, opposite of what the simple reading would show. This seems like a strangely "functional" feature in imperative-land. [1]. Yes. I know it ain't happening for many reasons. But let's put the idea out there
It did bump the major version (currently at 4) but has never claimed to follow SemVer afaik.
I think Russ was asking for: `2. Identify and explain a problem.` As in, "I was building a large system for running economic simulations and I found that the various and I found it difficult to share code between X and Y models. Here are some examples of what I was trying to do and why it was time consuming or error prone."
Py3 didn't really break everything it could. It kind of broke stuff but was still not radical enough. IMO they missed a good opportunity to really break stuff.
https://robustirc.net is an IRC network implemented as a distributed system on top of the Raft consensus library. https://gokrazy.org is a Raspberry Pi 3 application platform, implemented purely in Go.
Actually if you read to the end, he specifically says &gt;Once all the backwards-compatible work is done, say in Go 1.20, then we can make the backwards-incompatible changes in Go 2.0. If there turn out to be no backwards-incompatible changes, maybe we just declare that Go 1.20 is Go 2.0. So there's definitely a possibility of backwards incompatible changes. If you don't consider a backwards incompatible change to be "breaking", then you use that word differently than most developers. 
They don't solve the existing problems, though, they just hide it with hacks that were introduced early on in the language at the expense of a more generic solution (pun not intended.) The problem exists for anyone who wants to use any data structure, while the built in ones only solve it for the first class data structures. If they robustly solved it I wouldn't have been hearing people complain about it for the last 600 years. 
How would you implement printf using generics?
A few months ago I wrote [photobak](https://github.com/mholt/photobak) to download my content from Google Photos so I can have local copies of all my pictures and back them up in my own home. It performs downloads in parallel.
To answer your title question, you may want to have more complex error handling logic than just returning the error. In that situation, mocking the db lets you test that logic.
Re: types -- I enjoy the ease that comes with automatic type conversion in very short scripts, but I *much* prefer typed languages for anything longer. I'm very glad that Go is typed. :-) But I still miss the ability to append a unit to a number like val .= " KiB" or whatever. Sprintf works, just takes a smidge longer for me to parse it in my brain. Perl is an ugly language, but regex built into the language and lots of built in string manipulation is fantastic for quick and dirty scripts. Eh, maybe it's just hammer vs screwdriver. :-D Re: operator overloading, I get the problems with it, but like I mentioned, there's no complex bytes. One could make one easily enough, but then one can't define those operators, which makes it cumbersome to write. The &gt;&gt; overloading stuff in C++ is one of my big annoyances with it, so I get the downside. The lack just made me frown a bit. :-) Complex uint8 is definitely used -- for instance, those USB software defined radios are sending high data rate complex bytes -- I/Q data. Which means things like fourier transforms will be taking in complex byte data as well, and so on... I know there's ways to make a fake do..while loop, but it looks less clean to me. I'll get over it. I like that they've sort of smooshed together while, for, and foreach, but it just happens to leave do..while out. 
&gt; We need to start with the problems Go 2 needs to solve I'd like to avoid the need to create getters and setters, avoiding a **ton** of boilerplate. Of course, without getters and setters, I cannot define an interface to create polymorphic functions. A solution would be a type that allows the definition of exported fields and types that would allow any structure with said exported fields to be received and/or returned by a function.
I don't really understand why generating a static site if you need anything more than a landing page. 
&gt; Python 3.0 final was released on December 3rd, 2008 It's 8.5 years later, and the python3 migration is still a dumpster fire. Anything that looks remotely like it would be a complete failure, IMNSHO.
IMO the biggest problem was that they decided once there was a big migration problem it was open season on tons of small migration problems that would never have been approved otherwise. That and the fact that every single piece of code **STILL NEEDS** to be in either python2 or python3.
Why? Just don't use closures if you can't understand them
Having used python and not ruby I would disagree with this, it's **much** easier to see what you did that caused large amounts of pain (or, at least, come up with a viable list) than it is to see what you did that didn't cause any pain.
not work on no fpu arm need standard gui can not build bundle work as iphone lib
Yeah, that's a good point -- there's that uncomfortable time where you need to support both if you're going to switch, and you largely avoid that with statically linked stuff. 
You are getting downvotes, but it's been 8.5 **years** since python3 was released and most (all?) of the major python programs I use are still python2. Python3 was a huge failure, IMNSHO. The fact that upstream has decided to stop backporting features to python2 is just another signal of their stupidity and inability to learn.
obviously generics edit: lol why the downvotes? i mean, whats the point of Go2 if generics will not be included. 
yup, so that we dont have to use `interface{}`
&gt; Not really anymore, though Ansible is still python2 only, yum on CentOS-7 is python 2 and will be for another 5+ years (python3 might be old enough to drink before it's gone). Then again python3 isn't significantly better.
Yes, that's why 8.5 years later major applications still haven't been converted.
[UCP] (https://wiki.wireshark.org/UCP), [CIMD](https://en.wikipedia.org/wiki/CIMD), [SMPP](https://en.wikipedia.org/wiki/Short_Message_Peer-to-Peer) protocol implementations. 
I wrote some code to splice mp3s: https://godoc.org/github.com/badgerodon/mp3. Using this you could inject one mp3 into another on the fly. At work I built an application which schedules the evaluation of monitors. Each monitor has a scheduling goroutine that speaks to a pool of evaluation goroutines, who speak to various backend systems, and, if successful, the result is also passed to a writer which hands it to another system. All the communication goes through channels. The stages are pretty easy to understand and test and they actually perform well at scale without any special code. One not-too-big machine easily handles 200k monitors without breaking a sweat. In fact it worked so well I accidentally broke the exp backoff algorithm once so that it basically retried infinitely with no delays (integer overflow :) ), and it barely affected the other monitors. (Yay for random scheduling!) Having worked with a few python apps like this, the default behavior is for an outlier to come in and bring the whole program to its knees, leading the developer to try and introduce some sort of parallelism, only to realize that python doesn't actually do that well because of the GIL, so they turn to gevent, which proceeds to monkey patch everything, but invariably there's something somewhere that doesn't work with gevent (I'm looking at you gRPC), and you're left scratching your head for a week trying to figure out what the heck is going on, and finally you get something kinda working, only to then discover it still only really uses one core of the machine, and basic operations are way slower than they ought to be, so then you start rewriting chunks of the code in cython, till half your code is this bizarre impossible to understand hybrid-C-Python thing. And then you give up and write some boring Go code.
My hope is that Go 2 is developed with the same care as Go 1 was. I know generics are one of the things that many, many people complain about, but one of the most beautiful things about Go is its simplicity and that you can honestly learn the whole API in an afternoon, and that many simple programs use most of the syntax. While generics could be useful, that's an example of something that might get used infrequently enough that you have to go back to documentation every time you intend to write a generic type.
For audit and compliance data, this is what we're doing (big box company) Since most of this is viewed at a later time (by auditors etc), we haven't bothered with a cached view. We calculate every record based on its history ala redux. A single instance can churn through hundreds of thousands of events and output current state in far less than a second. Every minor modification is also there clear as day if anyone needs to inspect how a record went from A to B We don't plan on optimizing (caching) until the dataset gets large enough to have a noticeable latency. And the audit teams don't care as much about real-time state as they do the event log so it may never be necessary
On the generics front, Typescript really does this so well and seems to make sense in the overall Go view of simplicity. Interfaces can be used both for data and for functions. Most of the time when using it for data you greatly remove the overhead of converting and just say "I need a struct with an string named A and a array of ints named B". Any struct that has that matches and greatly simplifies readability.
This is a terrible, out of context, thread. Russ was very clear in his talk, the community has a voice, but the voice has to be coherent, it has to show why those changes are needed, what are the use cases, pain points they currently present. Some of the changes will be accepted, others won't. Some will have to wait a while until a clear case made for the request. Some of the changes will be language changes, some will be tooling (either existing or new tooling). Go 2.0 will not happen any time soon. It will be a gradual process, with the desire to keep the compatibility with the current code as much as possible. When that won't be possible anymore or when those changes will bw in a stable state, maybe a Go 2.0 release will be cut. The changes won't also be too many, just a few of them, important ones, for which clear cases are made. Currently this thread and the replies to it are so far off it shows the disconnect between simple users and those that actually can present a case for a problem and have the Go team recognize it as an issue. Please wait for rhe video of the talk before you jumping in head first, without putting any thoughts into your requests and why you need them. The more details, clearly described, the better.
I think it's important to draw a distinction between mocking your db, which is to provide a stand-in for how your DB works, and creating an interface, which is an abstraction that isolates the rest of your application from being coupled to a DB. Do abstract your data source, don't mock your DB. You're creating an interface that expresses intent, which means you know the boundary of the testing - if your application tests fail, the problem is in there. You can even write some slow tests that check that the db implementation works as intended, and know that you only need to run those when you change the details inside the box. Provisioning databases is slow, testing application logic against it is hard to set up and also slow. Testing with a real database can make your tests run so slowly that they aren't run and become useless. I think a project I looked at had a DB provisioning process in containers that took upwards of 5 minutes. Unit testing should be fast (sub-second), and it should be constrained to small volumes of code to better indicate where the issue is. 
There's nothing to attack or defend, it caches exceedingly well, you don't need to pay for instances.
You also can't do searches, can't give your client a backend (that I know of) can't have user interaction outside third party services and have to deploy every time you want to update the site. Again, can't see that much advantages over a simple CMS. Unless you're a Dev, and it's your personal site, then fuck user experience
Go needs a good dependency manager to be part of the standard toolset. *cross fingers for dep*
We saved thousands of dollars (more if you consider the sysadmin, update and other costs). There are a large number of sites that are largely static, except when a admin/dev posts new content to them. You don't need databases, nginx or instances for all of that - you can use S3 and Cloudfront, or your favourite alternative. Then you consolidate the things you actually need to be dynamic based on user input down to an API.
Oh for fucks sake
Can you point me to an experience report saying differently? I would appreciate if you'd actually reply to what I am saying. Namely, that neither your personal preference nor your opinion of general CS concepts signifies a problem. The question is about showing an example of where go fails to meet its [Design Goals](https://talks.golang.org/2012/splash.article). Unless you can demonstrate how `sync.Map` made Software Engineering at and for scale hard in some way (e.g. by leading to an outage, or to unnecessary bugs or made some refactoring harder…), then no, it is not a problem in the sense we are talking about. It might not be to your taste; you might be even be right to dislike it. But neither is the question.
56k is good enough.
I "understand" closures. It just doesn't "read" well
&gt; USB software defined radios are sending high data rate complex bytes But to be fair, you probably won't be writing such software with Go, since it probably won't run on those small devices. If you do, then you probably want specialized hardware, like a GPU or DSP. Even so, I get the point, and it seems pretty simple for them to add, so it's a little odd it hasn't happened yet, though it's probably the same reason `float16` isn't a thing. Anyway, you're right that Go leaves a bit to be desired. I mostly want deterministic destructors and generics, but I guess we can't all have what we want :)
If you say so. I'm still skeptical, the use case is really important, are you developing a site for someone or you have a team behind the site?
These were frequently web sites where customer relations people would periodically post new content. We had a CMS on the backend, but pretty much just ended up baking out a static version of the site from staging and uploading it. Previously there were maybe 6 machines which were spending a large amount of their time doing nothing much interesting at all - checking databases for content that wasn't changed. The traffic to our origin servers was massively offloaded, and we didn't need to worry about DDOS attacks or most other things that previously would also have affected our websites. QA was simplified, because if you checked what you baked, you'd get exactly that in prod. Something like gohugo.io could get you a very long way, very cheaply.
I got to say, expvar is kind of cool. However, I'm a bit annoyed that not only it automatically register both memstats and cmdline but there's no way can unregister any metrics. If you don't want to expose those metrics there's nothing you can do. *edited grammar*
Nope
This are my dream, would make Go just, perfect. Some kind of immutable would be nice too, it can help eliminate data races and help constructors (referential integrity). 
Lots of backend services. Message is read from the message queue, stuff gets processed, response is written to the message queue. Go feels like a natural fit for this type of workflow.
Your example has nothing to do with closures, Eg. MyStruct.Prepare(fmt.Println, "B") fmt.Println("A"); MyStruct.Do() 
2to3 renames str to unicode, but fails in quite a few common cases. Honestly, I hate the way python 3 does unicode...
1. Evolutionary computation library: [link](https://bitbucket.org/StephenPatrick/goevo). This is sort of parallel. 2. Game engine: (no link, closed source until this weekendish). This is very parallel. 3. Audio engine: [link](https://github.com/200sc/klangsynthese). It's a little too in its infancy to do parallelization optimizing tricks, and it really just wants vectorized SIMD functions for what it'd be doing anyway (this applies to everything here) 4. Computational geometry library: [link](https://github.com/200sc/go-compgeo)
It's remarkable to me that most of the things people want added are already in Crystal.
i think Brian Ketelsen does but in the wsl setup.
Please, please, please, with sugar on top: make debugger/debugging a first class citzen!!!
This is my favourite sofar, ties perfectly with 'pixel' !
Man, and that's what I'm starting to lean towards. Of course I lose linting in my editor, which is what I'm more curious about. I'm not 100% on how Windows interprets paths for WSL, or if it even does (could be Git GNU tools). Wondering if I just install what I can for Go in Windows for lint and ignore missing packages.
No, you should assume that nobody develops on Windows. Nor should you think that by having a vague thread with nothing in it would get you more that useless replies like this.
"Nobody develops on Windows" that's a naive assumption. Not everyone can chose their dev box, plus all the .net shops. I don't see how my post is vague. The tool chain is confusing despite Go docs promoting using mingw, it doesn't seem to work. I don't see how asking if anyone has gotten it to work is vague or meaningless. Bitchy maybe, but would you be happy if your OS got polluted from bad instructions?
mv to gnu/linux and be happy
That was sarcasm. I develop on Windows, not cywin, mingw, WsL or other gimmicks. And it works fine. Post some error messages, steps you took to get to the said error message and so on. You just complain about it not working bit you expect magically we know why. It works for me and it works quite well. See how that is equally useless for your problem? 
&gt; I don't see how my post is vague. The way you word the title and the paragraph is vague. It makes it seem as if the question is "does anyone actualy dev golang on windows" which the obvious answer is yes. You seem to have a secondary question of getting libvirt to work on windows. You should have gotten to that point a lot quicker. And yes, I've written a number of libraries compatible with windows. I use msys2 to give me a 64 bit mingw chain. Make sure to install the 'mingw-w64-x86_64-*' versions of gcc or pkg-config or whatever else you need. And make sure to install the amd64 version of Go as well.
Generics is an answer you need to bring the question 
I develop on windows in cmd/powershell and do fine, but I specifically avoid packages that require gcc. What I've found is a lot of specific projects have windows bugs because the people developing the project didn't sufficiently test their windows code.
That is true, my thought train was how are people to code Golang when anything needing GCC doesn't seem to work. Didn't try msys2, but it looks really promising. I'm going to give that a try tomorrow. Looks a lot more polished than what it aims to replace. Thanks. Edit: yep, finds pkg-config. Not sure if libvirt is going to work but it is at least finding GCC and pkg-config, and sees *a* libvirt.pc but it's the wrong arch, either way if I can get this far at least compilation works. Thanks again, really wish msys2 was better known. Pacman makes everything a lot less painful to deal with than random msis on the internet.
I develop on Windows (both 7 and 10) and have done so for years without any problems. I use chocolatey to install all cli dependencies (like git, hg), write code in Atom and use mingw 64 for anything that requires tools outside of the go toolchain. I have never come across any errors related to pkg-config. Then again, I don't really use CGO a lot (either in my code or in third party libraries), except for maybe sqlite3, but that one compiles just fine on my systems. EDIT: I also think the git package from chocolatey comes with a bash shell that I use for most of my shell needs (especially on Windows 7 the native command prompt just sucks).
I think too much time has passed and too much code has been written to add generics to Golang, even if everyone did agree that they were necessary. The idioms and implementations in the stl and in packages all over the ecosystem are written with interfaces as the only means of polymorphism in mind. The whole philosophy of Go to me is that Go focuses on the 90% use case. 90% of the time, a built in map type is fine. 90% of the time, interfaces are fine. 90% of the time, the built in channel implementation is fine. For that other 10%, use another language. There is a huge tradeoff in that last 10% that separates Golang from Java and its ilk. I for one hope that generics are not added. Golang is perfect as is for the 90%, and if we starting piling on the features, Golang will quickly become something other than Go. We'll probably end up getting generics anyway though. People can't deal with good. They have to shoot for perfect and land on awful.
For sqlite, have you tried https://github.com/mattn/go-sqlite3 yet? From Matz and says it doesn't require GCC at all. Yeah mingw was the main problem, but it didn't seem to install right from their sourceforge link. Msys2 works great though.
That is the library I use for sqlite3.
Thanks all for checking out and supporting Paperboy. We're looking for contributors and ideas from the community. Please post it here or as a Github issue.
How do I create a set as a library, so that arbitrary people can use it?
Well, if the do include generics, they will give a lot of boost to people to upgrade their codebases from Go 1 to Go 2.
Might be worth mentioning the database Datomic, they have a temporal parameter in their log based DB.
It works fine in languages like Lua and JavaScript, and Go isn't that different in syntax.
This.
Printf in go atm is already generic as provided by the runtime. There's nothing about printf that makes it somehow impossible to type in a language with generics. If the language supports dependent types you can even statically check that the format string matches the varargs used. Look at the Idris printf example if you want to see how that works. Personally I think dependent types would be a step too far for golang, but again that's only needed if you want to type check the *content* of the format string. If you just want to be sure the printf implementation can handle whatever type you're using at a specific call site, this can be done without them. Printf is not an example of something that makes generics impossible or invalid.
I am pretty sure the millions of Crystal developers will be delighted.
I'm writing distributed systems in Go and often find the need for immutable data structures. That is all I really need.
I doubt I have ever posted that Go 2 will *never* happen. I can not predict the future after all. :) I might have posted that [it is unlikely to happen anytime soon](https://docs.google.com/presentation/d/1JsCKdK_AvDdn8EkummMNvpo7ntqteWQfynq9hFTCkhQ/view?slide=id.p#slide=id.g118cf9b85c_0_263) though (which even after this announcement the statement remains true).
He wants it the other way around, using functions with a method syntax. It's similar to extension methods in other languages, which I think is a nice idea
I had "fun" bugs from the fact that py3 started to auto convert integer divisions into floats when the result are not even. As long as Go's changes breaks the build I would personally not worry about it too much. I'm a bit worried that the suggestion that Go might start to auto convert int to some kind of bigint type could produce errors as well, although the likenesses of bugs is much lower there.
If they can add generics in a way that does not harm the readability and the simplicity of the language *too much* then it might be a worthy trade-off.
Almost nothing I use doesn't support py3 at this point, it's not unusual that new libraries are py3 only. A bunch of libs are removing py2 support now.. the migration is happening
A deep learning/graph computation library (https://github.com/chewxy/gorgonia)
Closures are this way : https://medium.com/capital-one-developers/closures-are-the-generics-for-go-cb32021fb5b5 I'm afraid that with generics it will just add one more solution to resolve the same problem.
Why not taking something out of the language? What are the problems "goto" was supposed to solve?
Why not join forces with github.com/go-audio to make it *the* golang audio library?
I sorely miss this. I don't want to use Qt or Gtk or whatnot to make desktop UI's. It's not very "batteries included", IMO.
What make the simplicity of Go, what we have or what we don't have ?
Yup, it's pretty rad stuff. A re-sizable terminal to boot!
I don't think so..
Never ask Reddit to get creativ, we are too good ;) 
Agree with this. It's really hard to see a GUI Application which is written in Go
The caching actually is quite a good point!
&gt;Additionally, I'm of the opinion that more projects should adopt faster release cycles. The Linux kernel has a new release roughly every ~7-8 weeks. GitLab releases monthly. This allows a tight, quick iterate-and-feedback loop. &gt; &gt;Set a timetable, and cut a release with whatever is ready at the time. If there are concerns of stability, you could do separate LTS releases. Two releases per year is far too short, I feel. Besides, isn't the whole idea of Go to _go fast_? Linux and go is comparing apples to oranges. Linux has a massive workforce and every 8 weeks a huge set of bug fixes/features is ready to go. Go does not have as many developers and those releases would be smaller. I've seen this happen in workplaces too, small teams will want to adopt a constant release schedule cause that's what "xyz giant corporation" did and what ends up happening is a rush right before release to button up some changes so they can release "on time". In small teams with limited resources these schedules are a self imposed stresser and why a team would want to stress itself I don't understand. In my experience deciding the feature set you want and working towards it for the next release works better in small teams. Critical bugs can be fixed in patches to the released branch between features. At large scales everything changes, continuous integration and scheduled releases far outshine feature based releases because there's so many changes going out who cares if one doesn't finish on time. 
More low-level stuff in runtime and unsafe. I.e. bit backing. The problem it would solve: it would allow creation of more low-level libraries for Go easily. I.e. implementing some old network protocol requires messing with bits. Bit backing would ease the process. Generics. Problem: various places - containers, linked lists, more accurate type (de-)serialization. DLLs (plugins). Seriously, c-shared build mode only works on Linux and Mac. Problem to solve: get rid of C/C++ for more use cases. Easier to create graphics applications. Better error handling. I don't think that Go needs and std GUI library, at least now.
The py2/py3 transition convinced me to migrate... to Go...
You don't need anything extra to make Go work on windows. - Download the [latest version](https://golang.org/dl/) - Run the installer - (Latest versions automatically set your `GOPATH` to `C:\go` so you don't need to do that) - Add `%GOPATH%\bin` to your `PATH` - Open `cmd`, enter `go`, verify that it is installed. - enter `go get github.com/rjeczalik/pkgconfig/cmd/pkg-config` - enjoy
How do I remove the vector of error where I have to manually change 10 methods when I want to make a change to all my type-specific implementations, that I copy-pasted to begin with but are beginning to become cumbersome to edit?
Why does the language contain generics to begin with (map)? Should we remove map?
How can we reduce code duplication and increase robustness and ease of testing? 
How can we increase type safety?
How can I write code that is easily applicable to many types?
*Edit* I replied from my reddit inbox, and was in another thread discussing a CQRS/ES functional approach to replacing a traditional RDBMS, in that context the reply below made a lot more sense, but I'll leave it here as evidence of my carelessness, and as homage to the sanctity of "published" history. --- I really prefer not to think of it as caching... I've an article on my site that talks about the logic of why to do this, and once you reach a certain scale it's not OK anymore to need to look at 100 times at 10¹⁸ messages (where say, you need to render 100 user profiles, and need to look at each one to find out what their current profile pic is) But bottom line, if you start with that transitions in state, you can always derive the state for any _t_ (time) in the past, or present. FWIW we sometimes "cache" in PostgreSQL, MongoDB, Memcached directly, files on disk, etc, the fact is, it simply doesn't matter, and you can get response times down INCREDIBLY low. We've a service in production where the "view profile" command is simply a check for whether you see "none", "non-contact" or "contact" version of the profile, and then we `X-Send-File` a file from disk, eventually the backend workers will update hit counts and stuff and regenerate the JSON files (you can also generate HTML, we don't as it's an SPA, but you could), and update the caches, but we rely on the fact that if I change my profile name, or get a new "visit" or similar, that it's ok for a few (milli–?) seconds to render the old "out dated" document to clients. The response time here has never been above single digit milliseconds and is usually under 3. - http://www.wacku.de/article/2017/05/cqrchess-learn-about-our-unique-approach-to-building-software/ 
Of course you can, do an AJAX request with the search terms, send back the results in JSON and render them using HTML templates using JS. This way the search functionality is completely modularized and could be reused in multiple spots. I wouldn't mind a backend that has dynamic pages, but it's the frontend that could be completely decoupled using an API.
you have a good point but as far i know Crystal has no real parallelism
I do not completely agree that closures can replace the functionality of generics but despite that I am still not terribly excited to see generics added in Go (and I guess I am one of the few).
One thing that you need to understand when working with the `flags` package, is that it was not meant to replicate the GNU flags and it was coded after an existing google library (I believe [this](https://gflags.github.io/gflags/) is it). Therefore if you try to emulate some GNU flags functionality like short flag aliases then you will need extra effort and start wondering why flags doesn't give you an easy way to do it. My advice is to use only the absolutely required flags, avoid subcommands and do not try to emulate GNU flags functionality. In general, keep it simple. If your problem domain really requires complex flags then you have to deal with it and program a solution. Also you can can always have a look at how the Go team has created the commands of the go tooling to get some inspiration.
Based on their pre-1.0 model they will have 100% computer aided updating. Going from weekly to weekly release you just ran gofix and it just worked.
They mean breaking in that Go 1 code won't run without running it through gofix first. 
&gt; It seems that writing APIs involves writing a wholelot of boilerplate, which I hate to write. You might have chosen the wrong tool for the job then. Have you considered Ruby?
Can you explain that statement to someone who started using Python after v3?
I develop most of my private stuff on windows and use linux at work
Indeed. I didn't say printf would make generics unwanted or invalid. Didn't even imply that. Printf uses interface{} and runtime reflection. How do you mean it's generic? I meant, `interface{}` has it's place in places like printf. Even C# uses `object` in `string.Format`. Interface is bad when it's used in places where other features like generics would be better.
Python3 brought some libs/semantic changes that rendered some "old" packages incompatible with Python 3.x. There were some tooling to help conversion from 2.x to 3.x but still in some cases some parts needed to be rewritten. Since there was no clear incentive to move to Python 3.x some developers opted to stay with 2.x because work needed to port to 3.x was substantial and didn't bring major benefits and/or they were forced to use 2.x due to some packages lacking support for 3.x. Now situation is much better but it took a lot of effort. To be honest Python wasn't the first, there was Perl before that and PHP also had similar issues with PHP6 (although it was after Py3.x IIRC).
&gt; GoLang: Features, Pros and Cons You know right away it is going to be a great article when they call the language GoLang.
he not wrong though
Ah, apologies if my post read as argumentative. What I mean by saying printf is generic is that has parametric polymorphism. I think in c# the use of object for string.Format is largely historical, and it's also instructive for golang. The longer golang takes to find a solution, the more code will pile up that uses interface{}, code generation, etc. I'm pretty sure a couple years from now we'll look at that code with the same kind of "geh" as object in C#.
&gt; &gt; &gt; *"Today when we interview people fresh out of school, for jobs, they tend to be very good at Java programming and they think that the way that those languages make them think is really the right way to think about software. And I disagree with that."* Rob Pike [OSCON 2010](https://youtu.be/5kj5ApnhPAE?t=4m8s) 