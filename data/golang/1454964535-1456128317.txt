&gt; cgo still produces binaries. What I was trying to say was that it makes cross-compilation painful (see problems here for example - https://github.com/mattn/go-sqlite3/issues/106). I'm targeting linux servers from OS X and prefer to compile locally. &gt; This is not true since sqlite 3.0 anymore. Great thanks, I didn't know that, it is a wonderful db. 
So, [Go is popular in China](https://www.google.com/trends/explore#q=golang&amp;geo=CN)
It's just a data point. It's not intended be conclusive.
Yeah, and useful things like IDEs, generics, debuggers, monitoring tools, versioning, GUI libraries, so on...
Feeling the same pain, have been heavy powershell coding for the last few years, python before that. Powershell is one of the most readable languages I have seen.
Indeed this can be confusing for newcomers. There is a [blog post by Francesc Campoy explaining the procedure](http://blog.campoy.cat/2014/03/github-and-go-forking-pull-requests-and.html) but I think it should be made more clear somehow. Maybe it should be added in the official documentation or something along those lines.
Each language is designed with certain goals in mind. Go was designed as a server language. If the problem you are trying to solve requires good GUI then use the appropriate language for that.
does it handle relationships ? 
Have you tried running more go routines than you have cores? One routine per row in your matrix, for example? From what I've learned in a parallel computing class, this is the "standard" way to parallelize a problem. From my experience, it performs a little bit better as well. If anyone disagrees, feel free to comment. I love these discussions! 
You can also consider just doing insertionSort([]int{1,2,3,6,5,3,9,3,1,30}) \+ possibly separate test for best and worst case scenario
I haven't tested it, but I don't know what advantage this would give since the amount of work your machine can do in parallel is limited by the core count. I would think that dispatching more goroutines would increase the scheduling overhead. Of course, I linked to the source code. Clone it, tweak it, and let me know what you find out!
The theory is that you can't predict that the pieces you divide the problem into its equal in computing time. Thus, one core night get too much work, and the others can't help it. If you divide it in even smaller pieces (but not too small, as the overhead will be too big, as you said) the cores will be scheduled new pieces until they're all done, maximizing the spread of the load. In theory at least. I might take your advice and tweak it myself. Sounds fun! 
I skipped a bit through your code and noticed a couple of things, in no particular order: * What is variant? * Why are you exporting all those constants and variables (without any explanation what they're doing, no less)? I don't think they should be exported. * If you need to export them, use var/const blocks like this . var ( Foo = "x" Bar = 42 ) * There's no need for two files here. It's less than 200 lines in total, that's completely manageable * `uint32(seed[0])%uint32(len(templates))` is biased, it generates more small numbers than large numbers. Especially as `len(templates)` is probably small and probably doesn't divide 256. The correct way to create random numbers in a range is [rejection sampling](https://en.wikipedia.org/wiki/Rejection_sampling). It's non-trivial to implement here, but possible. Also, why converting to uint32? * [this line](https://github.com/ionDynamics/statelessPassword/blob/master/algorithm.go#L63) is unreadable. Split it up (and probably use a byte.Buffer or something). * The salt you add is relatively useless (from what I know). Salts need to be random strings to have the desired effect. * Also, why the conversion to uint32 again? * Make the whole passchars logic a `map[rune]string` or something, instead of exported variables and the humongous switch statement * `uint32(seed[i+1])%uint32(len(passchars))` is also biased and doesn't need the `uint32` conversion. * Also, I would remove all that customization and variant stuff. Just choose the correct parameters and tick to them. People are in general idiots and given several choices will always take the worst possible one. That is especially true for cryptography. * It seems flawed to me, that I apparently need to remember the template I used to generate my password too. * In your [main.go](https://github.com/ionDynamics/statelessPassword/blob/master/cmd/slpw/main.go) you seem keen to put the type of a variable into it's name. That's very unidiomatic. * No need for defVar, defVarUsed and devVarStr. Also, you shouldn't silently ignore invalid values, that will lead to strange errors for users. And no global variables that you only use in one place. I would rewrite the variant logic as: . variant := uint8(3) if s := os.Getenv("ID_SLPW_DEFAULTVARIANT"); s != "" { var err error if variant, err = strconv.Atoi(s); err != nil { log.Fatal("Illegal value for ID_SLPW_DEFAULTVARIANT") } } * Implementing a ["legacy mode"](https://github.com/ionDynamics/statelessPassword/blob/master/cmd/slpw/main.go#L48) inside the first released version of your software seems illogical to me. There is no legacy yet. This goes hand-in-hand with what I wrote above: Make the correct choice and stick to it. * You use Environment variables before you parse the flags (including the noEnv-flag). You also use the environment variable for the name of the user before using that flag. Also, you use Camelcase in flags, they should probably be dash-separated * You mix global flag variables with local ones. Pick a style, stick with it. * The documentation of [bufio.Reader.ReadString](https://godoc.org/bufio#Reader.ReadString) tells you that a Scanner is probably more convenient. I agree. * `fmt.Println("Found User:", fullname)` smells like debug-logging that has nothing to do in released code. * Don't use `syscall` for something like this. Rather use `os.Stdin.Fd()`. * I think your code has a subtle bug, namely that you use `bufio` to wrap stdin, but then continue to use it. This will blow up, when you do, e.g. `echo "foo\nbar\nbaz\nspam\neggs" | ./slpw` (i.e. don't use a terminal as an input). Also, you then use the wrapping Reader again afterwards. `*bufio.Reader` consumes input and buffers it, that's where the name comes from -- in particular, it will read more than you intend, given the chance. * Also, using the terminal package will blow up when not using a terminal as input. It's getting late here, so I'm going to bed for now :) [edit] reddit code formatting sucks ballz. It doesn't format stuff as code, even though I use the four spaces *and* leave an extra line between the surrounding stuff -.- [edit2] for now, this works. But blerghs, I would've expected more.
Why do you need it to run at the very beginning of the minute? You can just manually run your first tick; put a `ticker &lt;- time.Now()` right after you create your ticker.
The presenter had a few chances to really educate the audience on Go during the Q&amp;A but he struck out. Refactoring (gorename), common database API (database/sql), runtime analysis (reflection). He also kept repeating that nobody uses Go for UIs which is simply wrong; the standard library has HTML templates and many people use them.
How would you use this to refer to your own fork in your code? e.g. you have another project that references the library, you just fixed a bug/added a feature, and you want to use your fork until it gets merged.
&gt;I’m not at all familiar with parallelism in Python, so I didn’t attempt it https://docs.python.org/3/library/multiprocessing.html
&gt;&gt; It requires a global lock on the db for writes, fine for small sites with very low usage I guess, but it wasn't really designed with concurrency in mind. &gt; This is not true since sqlite 3.0 anymore. It is. Pre-WAL logging you can either have many readers or exactly one writer. in &gt; 3.7.x you can switch SQLite to WAL mode to get multiple readers/one writer at same time
But it makes it more comparable with the python code that he is benchmarking it against. He isn't pre-compiling the python, which is totally an option. 
I can't think of any cleaner ways. Its a strange problem, and thus is likely to have a strange solution. 
&gt;What I was trying to say was that it makes cross-compilation painful (see problems here for example - https://github.com/mattn/go-sqlite3/issues/106). I'm targeting linux servers from OS X and prefer to compile locally. I'd advise to at least have a linux VM tu run `go test` on, small differences might bite you (like HFS being case-insensitive as opposed to linux) &gt; Great thanks, I didn't know that, it is a wonderful db. He's incorrect. The best you can get (sqlite &gt; 3.7, WAL turned on) is concurrent readers + one writer. Which is fine if you are careful but can be sometimes limiting.
I guess it does not have to be the start of a minute, but with the systems I am dealing with I would like to define the times and Intervals at least to the specific seconds. If I can schedule a call every Minute at the start of the Minute, then I can also easily schedule other times and Intervals which would help immensely. Sending a Time down the Chanel of the Ticker does seem like a clever solution, but unfortunately I can not send something to the chanel. I can only Receive from it. invalid operation: ticker &lt;- time.Now() (send to receive-only type &lt;-chan time.Time) The Documentation defines the Ticker Chanel like this: C &lt;-chan Time But thank you for this Idea. I would not have thought about just sending something to the Chanel.
Whether you use `go run` or `go build` should not affect the results of the benchmark. The compile time is not factored into the benchmark in either case, since compilation happens before runtime, and the Go and Python *programs* start measuring time only after they've built their respective 2D array representations. &gt; He isn't pre-compiling the python, which is totally an option. I don't think compiled Python is typical in most production environments (certainly not ours, which is what motivated the benchmark initially), so it doesn't seem like a very practical comparison. I'd be curious about what results you see from performing an ahead of time compilation for this benchmark suite.
Import paths are about project identity. If you "Github fork", you're just developing on a branch, not changing the project identity. So `go get` the upstream repo and use git from there.
The article is about a vim plugin.
That looks overly complex, and what others said about `select` is a good idea. My $0.02: https://github.com/tv42/topic
Nothing about Go here (apart from what libraries are available &amp; convenient).
What happens if the code in the fork references it's own package/subpackage? Won't that be referring to the original version due to the fully-qualified package name?
China dev related things are not popular anywhere outside China.
who cares? the first paragraph of part 1 was him basically saying he was doing it for fun as a learning experience. have you not even intentionally reimplemented something just to learn? 
Of course, we all have. But there's a serious case of diminishing returns. An init system in particular is a large case of diminishing returns given the complexity involved in all the options and corner cases, and given the number of existing init systems. Writing an application that launches programs, reads configuration files, sets up environments, monitors processes it launches, handles the wonky cases of forks and forks of forks with abandoning parent processes, and on and on and on has actually very little practical use in these days. I say this as someone that has been in the game for a while, and consider myself well familiarized with deep internals of Linux systems.
you're not wrong, but that may just be something he's interested in. if written tons of application servers and web frameworks for fun and learned a ton. you could use the same argument there. 
This is great! Thanks for pinging me on it. This is exactly what I was looking for. 
I'm sorry, I don't follow. Did you do my proposal or yours? And what's the purpose of the mutex in your code? Edit: I think I understand what you meant by that mutex now. That seems unnecessarily complex to write, but still a pretty cool idea. I'll try to do my implementation later and post it here! Edit 2: This is the version I ended up running. My conclusions are the same as yours, it varies in the 10ms interval, hardly worth a mention. It seems as if the runtime of every row is very similar (which isn't very surprising) and I believe that's why the performance isn't affected by the number of parts the problem is split into. func validateParallel(rows [][]string, coreCount int) { wg := sync.WaitGroup{} parts := len(rows) // compare with len(rows) or coreCount or 1000 etc. wg.Add(parts) for _, block := range subslice(rows, parts) { block := block go func() { validateRows(block, len(rows[0])) wg.Done() // signal that this goroutine has finished execution }() } wg.Wait() // block until `wg.Done()` has been called `coreCount` times }
Docker generally still needs an init if your process dies. At least on older versions of the docker daemon they didn't reap certain cases zombie processes.
+1 on this. In fact, I fixed one of my projects the other day coincidentally. https://twitter.com/quii/status/695624259616579585 Since then someone has made a PR to bring it down to ~11mb, even better! 
[**@quii**](https://twitter.com/quii/) &gt; [2016-02-05 15:05 UTC](https://twitter.com/quii/status/695624259616579585) &gt; Made the docker image for mockingjay a \*little\* smaller this lunch https://imagelayers.io/?images=quii%2Fmockingjay-server:1.5.1,quii%2Fmockingjay-server:1.5.2 &gt;[[Attached pic]](http://pbs.twimg.com/media/Cadak-lXEAIgxzG.png) [[Imgur rehost]](http://i.imgur.com/RkyjnQd.png) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
So the way I do it, which is pretty wonky I admittedly.. 1) Travis builds binaries when it is a "release" in GitHub. See https://travis-ci.org/quii/mockingjay-server/builds/107250601 . They get published here: https://github.com/quii/mockingjay-server/releases 2) From there, I have a Dockerfile, I think reading it probably describes it best. FROM alpine:3.3 RUN apk add --update wget bash &amp;&amp; \ wget -O mockingjay-server https://github.com/quii/mockingjay-server/releases/download/1.5.2/linux_amd64_mockingjay-server --no-check-certificate &amp;&amp; \ chmod +x mockingjay-server &amp;&amp; \ apk del wget bash &amp;&amp; \ rm -rf /var/cache/apk/* ENTRYPOINT ["./mockingjay-server"] I'm not sure if this is the *best* way, but it works for me. 
Another approach is to just implement your own ticker https://play.golang.org/p/3VL2_jK46j It can even be simplified by getting rid of the channels and just call the target code directly.
The thing is that if I use the settings.go, every time I change one thing, I would have to recompile all my project, instead of just stop and start the execution, and this is what all my teachers said it was better in case you have a project that the compile process takes too much time. But, then again, they were only using java and when creating the jar in eclipse selecting those files to be included, so maybe in Go I cannot achieve that same behaviour and I have to choose between those two. Thanks for the quick answer.
now days you can have dynamic settings (hot reload) easily using env vars or having a go routine looking for changes in the file to reload your settings.
[12 factor apps](http://12factor.net/) recommend that all external settings be set via environment variables. I've personally relied on command line flags. If you're not a fan of the built in `flags` package, there are a bunch of third party libraries that implement a variety of different behavior.
That's really good. Thank You :) Okay starting from the top: * A variant is a preset of parameters for the scrypt key generation. I maybe should have named this "scrypt preset" * The constants don't need to be exported and shouldn't be but the original algorithm differentiates uppercased-only character sets by naming them uppercased. But this is a derivate of this algorithm. So I might change this * Going to change this one in the next commit/push (context: var/const blocks) * Same here (context: Two files) * uint32(seed[0])%uint32(len(templates)) is a direct translation from the original algorithm. The uint32 is inforced in Billemont's algo as well as the way of choosing the template. But again: This is a derivate * At the risk of repeating myself: Going to change this one in the next commit/push (context: unreadable line) * The salt doesn't has to be necessarily random. It should increase the increase the input data to prevent dictionary attacks. [Billemont's website](http://masterpasswordapp.com/algorithm.html) states that the full name of the user provides "sufficiently high entropy while being (hopefully) impossible to forget by the user" * As mentioned above: Billemont explicitly wants unsigned 32bit integer * That's another very good point. Going to change this according to your feedback. (context: map[rune]string) * Again: This one is taken directly from Billemont... but slpw is still a derivate * Sadly to say but you are probably right about the people being idiots. I'm going to remove these custimization options from the cli tool. I'll keep them in the library for future hardware generations. * Yup. That you have to remember your template is annoying. But imagine a website that doesn't accept special characters in the password. So you have to tell the password generator that you don't want special characters. Therefore the templates * You mean naming a Pointer fooPtr? * This is going to be removed as I'm following your previous suggestion to stick to one variant. But still good to know for future projects. * The "legacy mode" should be named "Billemont mode". It sets the scrypt parameters to Billemont's original * Ack. Going to change this (context: env vars) * Same here (context: global vs local style. pick one) * I already stepped down from using ReadLine because the docs say "use ReadString/Byte instead" :D (Not to mention that in the very same paragraph they refer to some mysterious thing called Scanner) * Nope. Not a debug log. Just bad wording again :D I might change this to: "Generating passwords for {bla bla bla}". If slpw is used by more than one person on the same computer that could be handy. * Ack. (context: os.Stdin.Fd() instead of syscall) * I'll look into this and definitely change the order of using stdin and bufio.Reader(stdin). So I'll first get the master password from stdin via terminal package and than stuff stdin into bufio.Reader. (or Scanner :D) * The slpw command isn't really intended to be used with anything else than a terminal. I've used the terminal package because it can hide the master password input. Is there a better way to do this? That was a really good feedback. Thank you again. TIL a couple of things :) Edit: Struggling with the formatting, too Edit2: Added context to some replies
Going to change this to an interface with Init(fullname, masterpassword []byte, variant uint8) Password(site string, version string, templates []string) (string, error) Thanks for your feedback :)
Not sure if I fully understand your question, but can't you just add a specific "handler" for each message type and move common functionality into a common handler? For example, in my codebase all messages have a "type" field: enum MessageTypes { PING_MSG = 1; } message PingMessage { required MessageTypes type = 1; optional string whatever = 2; } On the Go side, I have a map of handlers for each message type. Every handler embeds `baseHandler` where I collect common functionality. `GenericMessageHandler` is just an interface with a `Handle` method. func (h *RequestHandler) init() { h.handlers = make(map[mpm.MessageTypes]GenericMessageHandler, 10) h.handlers[mpm.MessageTypes_PING_MSG] = handlers.PingHandler{&amp;handlers.baseHandler{}} } which I later use with: handler, ok := h.handlers[*msg.Type] if ok { response := handler.Handle(msg) } Would something like that work for you?
So what about rust? No gc with memory safety.
No Go/Tk? Count that as a plus, I guess.
&gt; All the baggage you leave behind (and you do not have to think about) once you enter the Go world is fascinating. Sounds like New Age stuff, lol.
I'm also a C programmer and abhor Python, so I'm picking up Go as my choice for tasks that a lot of folks are using Python/Ruby/Node.js for. I also don't see Go as a replacement for C, just a better choice when the intricacy of C isn't really needed.
Most popular name on this planet is Cheng. Most popular programming language is Go. Cheng Does Go.
This is crucial point. C/C++ (game) devs will never move to garbage collected languages. But a lot of dynamic language users tend to move to static compiled languages to benefit from compile time checks and performance, here Go shines.
Nice, though it doesn't treat COPYING files as licenses.
That's an argument for a script or a process supervisor, not an init process.
In many cases you don't even need alpine. You could compile a complete static binary and use `scratch` as the base image (is an empty tar): http://blog.xebia.com/create-the-smallest-possible-docker-container/ This makes your docker image as large as your binary.
There's an open issue for the embarrassing one: https://github.com/client9/misspell/issues/26
Hi, could you check again and/or give us a sample repo with a License file? Thanks
&gt; In Python, threading is usually better at IO bound tasks That was my suspicion as well, but the guys at /r/python got into a tizzy that my post suggested that Python wasn't known for its parallelism capabilities. &gt; However, if the tasks are too fast then the overhead of forking processes and serializing communication back and forth can out weigh the benefit. That seems to be my experience.
Is there any way to get this to work with private repos?
&gt; I think I understand what you meant by that mutex now. That seems unnecessarily complex to write It's not particularly complex. It's just a series of worker processes, each grabbing the next row off of the stack. The mutex is just there to make sure two workers don't process the same row. This eliminates the problem where one worker finishes before the others because they're all taking from the same pool; however, now we have a lock which could degrade performance (though one can't conclude that from this test). Your implementation is interesting; I'm surprised there isn't more of an overhead difference. I wonder what happens if you change from `subslice(rows, len(rows))` to `subslice(rows, len(rows) / 2)` or `len(rows) / 4` or etc. (Basically I'm curious if your theory about one goroutine finishing before the others is correct, but perhaps you're spawning *too many* goroutines such that the scheduling/dispatching overhead is eating any performance you might have otherwise gained?) I doubt this will have much performance impact, but your call to subslice is pointless since you're just creating slices of size 1. You may as well just range over the original `rows` slice and change the `validateRows()` function to `validateRow()` (remove the outermost `for` loop in `validateRows()`).
Thanks for the clarification!
If I understand your question (which is: "how can I bundle a config file with my executable like I do when I make a jar file" - but... I could only guess that after your response to /u/nsd433 ) then the answer is to use tar or zip to create a compressed file with the files you would like to distribute in it. https://en.wikipedia.org/wiki/Tar_(computing) https://en.wikipedia.org/wiki/Zip_(file_format) Jar files are the same kind of thing: https://en.wikipedia.org/wiki/JAR_(file_format) 
Now it works. https://goreportcard.com/report/github.com/TheHippo/abp
I think you can replace this: cmd := exec.Command(filepath) sout, _ := cmd.StdoutPipe() serr, _ := cmd.StderrPipe() // Start and get the output err := cmd.Start() if err != nil { log.Println("Error starting the program", err) } go io.Copy(os.Stdout, sout) go io.Copy(os.Stdout, serr) err = cmd.Wait() if err != nil { log.Println("Error waiting program") } cmd := exec.Command(filepath) sout, _ := cmd.StdoutPipe() serr, _ := cmd.StderrPipe() // Start and get the output err := cmd.Start() if err != nil { log.Println("Error starting the program", err) } go io.Copy(os.Stdout, sout) go io.Copy(os.Stdout, serr) err = cmd.Wait() if err != nil { log.Println("Error waiting program") } With this: cmd := exec.Command(filepath) cmd.Stdout = os.Stdout cmd.Stderr = os.Stdout if err := cmd.Run(); err != nil { log.Println("Error running program:", filepath) }
&gt; I don't want to use a lot of memory I don't think you understand how `archive/zip` works. It doesn't unzip the full contents of anything into memory. Other than the tiny size of the header the zip file is streamed, if your reader is at all sane it will just look at the file line by line (or chunk by chunk) and will consume hardly any memory at all, no matter what the size of zip file.
Feeling the shame of not running golint on my code...great site to expand horizons.
Sure, I have a Jenkins job that pulls down source from Github, builds a Docker container and then runs tests which need to access various cloud services. Right now what I have is a YAML secrets file containing my cloud API keys and passwords. I've encrypted the secrets file with ansible-vault. At runtime (build/test), I decrypt the secrets file (in memory only) using the ansible password which I store encrypted in Jenkins using its built-in credentials manager. The weak point is that if someone hacked into my CI system, they could simply follow the logic in my build scripts and decrypt the secrets file by running my build. Maybe I'm an idealist but I feel like I can do better than that. 
Yeah, ignore the guy who thinks that learning is a "terrible idea". I think what you're doing is great.
Nice read. I love it how these kinds of practical libraries seem to popup around Go, mainly from the Go team. They always seem so well thought out, efficient and pragmatic. For example the NewMatcher function (like the Regexp.Compile) can implement a lot of optimizations under the hood that would normally not be possible if you were to pass the preferences and available language arrays together. Any subsequent matching will benefit from any work done in NewMatcher. Maybe this is used in other libraries too, but I really enjoy the quality of libraries I see!
Woah, this got quite the upgrade! Very nice +1 would use again. :)
If you statically link your go binary you do not need a libc. You do not need anything. But you are right: Alpine does use the more or less uncommon musl as libc.
&gt;&gt; In Python, threading is usually better at IO bound tasks &gt;That was my suspicion as well, but the guys at /r/python got into a tizzy that my post suggested that Python wasn't known for its parallelism capabilities. Yea I wouldn't say the language in general can't do it well. You would want to speak specifically about implementations, such as CPython which has the GIL, preventing true parallelism of pure python code unless you fork processes. Whereas other implementations may be able to do it without forking. But you could say Python handles concurrency better than it handles parallelism. &gt;&gt; However, if the tasks are too fast then the overhead of forking processes and serializing communication back and forth can out weigh the benefit. &gt;That seems to be my experience. 
&gt; Yea I wouldn't say the language in general can't do it well. You would want to speak specifically about implementations, such as CPython which has the GIL, preventing true parallelism of pure python code unless you fork processes. Whereas other implementations may be able to do it without forking. The context was CPython as we were all using the `python3` command in our examples. No one thought we were talking about (for example) IronPython. &gt; But you could say Python handles concurrency better than it handles parallelism. I'm not sure Python has concurrency semantics either (I'm not sure if laziness--a la generators--counts as concurrency). But anyway, I don't see how concurrency is related.
the golint part seems arbitrary....i'll put an underscore in a variable name if i bloody well feel like it
I have the same error. I don't see Go 1.6 on their website. The project only works with rc's?
&gt; The constants don't need to be exported and shouldn't be but the original algorithm differentiates uppercased-only character sets by naming them uppercased. But this is a derivate of this algorithm. So I might change this I very strongly urge you :) &gt; uint32(seed[0])%uint32(len(templates)) is a direct translation from the original algorithm. Then the original is broken as well and needs to be fixed. And you might be suspicious of the skills of the original implementer when it comes to cryptography, as that is a very basic thing that they should have learned early on. It's so broken that you shouldn't even use it in code that *isn't* supposed to be secure in any way (say, a virtual dice-game). You can convince yourself of the basic reasoning here with the following thought-experiment: Try to emulate an unbiased 6-sided die using only a coin-flip as a source of randomness. That's essentially what you are trying to do here (with every bit of the input/seed being one coin-flip and the number of sides of the die being `len(templates)`). &gt; The uint32 is inforced in Billemont's algo as well as the way of choosing the template I assume they do it because of some quirk of their implementation language. It has no effect whatsoever in go's case (except, of course, where they are needed to soothe the compiler). Use int (and don't convert the len-output). &gt; The salt doesn't has to be necessarily random. It should increase the increase the input data to prevent dictionary attacks. Billemont's website states that the full name of the user provides "sufficiently high entropy while being (hopefully) impossible to forget by the user" This is some shoddy reasoning right there. Names have next to no entropy at all. And salts don't make dictionary attacks any harder, really. They make reverse lookups harder, but not pure dictionary attacks. I don't know, it *probably* doesn't matter a lot, but when it comes to crypto implementation details, I wouldn't trust "probably" or "a lot". I would just generate, for example, a random 6-character string (only letters) and expect the user to remember that too, which should give you a comparable amount of entropy but without the bias and actually secure. Or just generate a random string and publish that somewhere memorable. But ¯\_(ツ)_/¯, as I said, it's probably fine. Btw, an IMHO good introduction into password hashing and the like is [this](https://crackstation.net/hashing-security.htm) &gt; You mean naming a Pointer fooPtr? Yes, that :) Also, Str and stuff. In practice, it turns out, you don't normally forget this stuff and if you do your compiler will point it out. It's not a huge problem and readability benefits from having simple/short names. &gt; Not to mention that in the very same paragraph they refer to some mysterious thing called Scanner [bufio.Scanner](https://godoc.org/bufio#Scanner). It's usefull. It handles all kinds of nastiness with the ReadString stuff for you :) &gt; Nope. Not a debug log. Just bad wording again :D I might change this to: "Generating passwords for {bla bla bla}". If slpw is used by more than one person on the same computer that could be handy. Hm. I disagree (I didn't say "smells like debug log" purely because of the wording, but also because that information seems unnecessarily verbose to me). But ¯\_(ツ)_/¯, that's up to opinion. &gt; The slpw command isn't really intended to be used with anything else than a terminal. I've used the terminal package because it can hide the master password input. Is there a better way to do this? In that case I would make that explicit: Error out if it isn't used with a terminal. However, be advised that if your program is widely used, [there *will* be someone who wants to use it without a terminal and they *will* get angry at you](https://xkcd.com/1172/) ;) Not that you necessarily need to care. In regards to better ways: That's a science in and off itself. There's a reason why gpg and ssh and stuff these days use separate agents with pluggable password-dialog software. For example it is very hard to prevent keylogging from linux and impossible from a terminal. But it's probably fine to use a terminal, yes. Just don't create mysterious error conditions when people are trying to pipe stuff in.
[Image](http://imgs.xkcd.com/comics/workflow.png) [Mobile](http://m.xkcd.com/1172/) **Title:** Workflow **Title-text:** There are probably children out there holding down spacebar to stay warm in the winter! YOUR UPDATE MURDERS CHILDREN. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1172#Explanation) **Stats:** This comic has been referenced 616 times, representing 0.6217% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_cztw05p)
Thanks for clarifying. That's what I assumed you meant, after reading through your response anther time. Yeah I know that is unnecessary to call subslice when using len(rows). I wanted to change as little as possible to emphasize the concept of my change, not shave of microseconds. I guess the main take from this is that go routines are dispatched in a very efficient way, and you shouldn't be scared of spawning some extra ones. However, when the runtime of every element is close to constant, like in this case, we neither win nor lose much by spawning more routines. Or what would you say? 
This looks really cool. Very interested in using it in a couple projects, but a must-have for me would be the ability to bind response data to variables for use in subsequent requests. I see someone else has opened an issue for exactly this. 
Go 1.6 will be released in the next couple weeks. Currently go1.6rc2 is the latest release candidate.
Looks very readable, though the examples are pretty simple. Are there other distinguishing features compared to API blueprint https://apiblueprint.org/tools.html# or swagger http://swagger.io ?
+1 Shouldn't exclude any repo/code
You're right, some code could be skipped. I shortened it. Here is the code so you can test: https://gist.github.com/josephspurrier/ec57821bc4a3442a74ca 2016/02/09 18:41:17 Started ticker 2016/02/09 18:42:00 Tick 2016/02/09 18:43:00 Tick
I wrote a spell checker that can ignore function and variable names. It also has a regular dictionary / word suggestions instead of checking for common misspellings. You may find it useful: http://github.com/chzchzchz/goword
It's unfortunate that misspell assumes American English. &gt; found "recognise," a misspelling of "recognize," (misspell)
&gt; I guess the main take from this is that go routines are dispatched in a very efficient way, and you shouldn't be scared of spawning some extra ones. However, when the runtime of every element is close to constant, like in this case, we neither win nor lose much by spawning more routines. Or what would you say I agree that goroutines are very cheap, but I didn't expect them to be *negligibly* cheap. I'm still a little suspicious since it seems to go against what I recall having read. I want to do more experiments, though I agree that our experiment certainly supports your position. :)
"you won’t have to recompile all the project" -- and save all of 5 seconds? Do the simplest thing.
Thanks! Any way to bypass having to enable SSL on the db yet? Messing in dev. I just get "error: pq: SSL is not enabled on the server"
&gt; Maybe any files starting with "Code generated by go-bindata." should be excluded? Are you not compiling that source into your binary? Spewing errors when run through a linter should be concerning to you.
Awesome idea. Just one minor point here - the article is about HTTP REST API's only but always just says 'API' as if there was no other type of API. A bit confusing on the first read.
Most likely not! I've posted higher emptiness! This is a hermetic poetry in gif format, storytelling about a rubist and his little discoveries ... :)
Yes the Mutex has better performance, but the use of the channel allows to serialize the operations even when they have to return a result.
It is, which is why I think such files should be excluded. It's not uncommon that procedural generation is going to break a few style rules. In this case for example the linter is complaining that the internal names contain `Html` rather than `HTML`. While this makes sense for human-written code, in this case these names are automatically generated from directory names it'd be unreasonable to expect the generator to always have an up to date list of what the linter thinks are acronyms.
Yeah... It was a bit complicated to express my question, but that was sort of it. The example that is more correct is that, during my degree we made a JSF web page with an sql and REST, but we used JBoss as the server, and when we run/compile it with eclipse (they wanted us to use eclipse u.u), all the settings, properties, sql and two different languages for the i18n (all of that were externalized in .xml, .properties and .sql) were inside a .WAR and that .WAR was automatically deployed inside the JBoss. So… now I wanted to replicate that behaviour, but I do not need anything like JBoss to serve my page, so I cannot deploy the files inside, but I wanted to know about externalization in general and not only in particular for my case. I now see that I did not express myself very well, although I can use the answers I received for my project I hope this explanation does not confuse more.
I've never used the flags package, my project is in its early stages so I don't know if it will need them, but I am trying to use as few as possible third party libraries, so in case I would need anything, I would opt for the flags package. The things that I have externalized are some URIs that I have to call because I am using a REST API, so flags cannot be used in this context. I wanted to know about externalization in general, so now I know that I can use flags for some settings (which I would love to try on a future project) 
Really nice, but no downloadable vector/image files? :/
I definitely feel this in Python land. Python makes bad things *easy*. You can't even depend on testing to drive people towards good coding practices because mock.patch can subvert any coupling.
I believe it is already there. [This article](https://www.phoronix.com/scan.php?page=news_item&amp;px=PlayStation-4-LLVM-Landing) claims that LLVM 3.7 added PS4 support and rust can use anything from LLVM 3.5 up. (I believe the blessed builds are bundled with 3.7). As for SDK support, rust has pretty good FFI support. It is pretty easy to link to C libraries in rust.
Fair enough. Rust does have more features, but I don't think it hits C++ level of complexity. However, it would interfere with your programming style as you can't really escape rust's borrow checker.
Modern mainstream operating systems have a lot of things running in the background — hardware interrupts, DPCs, APCs, timer hooks, schedulers, kernel threads and the alike. If the GC pauses can be reduced to the level of hardware interrupts, I guess the advantage of no GC will be eliminated for user space applications.
In what way does a mutex not give the same guarantees?
One little nitpick... You have gopher with GNU. Nothing wrong with that except Go uses the BSD license. Maybe there should be Jedi Gopher vs Darth Beastie. (EDIT: I do think the images are great.)
STAR WARS!! And Go. In the same picture. I think I'm gonna cry. 😂
https://github.com/Unknwon/bra is one of such tools
thanks, i'll check it out
Can we buy the T-shirts?
Point well taken. But... Go was designed with networking, concurrent applications in mind. So, it's not surprising at all that Go excels in that types of applications. But, the universe of software goes beyond this type of applications; this is something that people who bury themselves in a certain domain tends to forget.
Very cool. It would be great to see more Go in the Linux distro scene.
Nice. A little bit more documentation would be good though.
Go has influenced how I write code in other languages so much. I'm a much more boring programmer now.
This is exactly what I've been looking for!
inotifywait in a loop in a script
The Queen once tweeted "There is no such thing as American English, there is the English language and there are mistakes"
Many are on Github, such as Docker, Hugo, and all CoreOS projects. https://github.com/search?utf8=✓&amp;q=language%3AGo&amp;type=Repositories&amp;ref=advsearch&amp;l=Go&amp;l= You can make a documentation pull request by making a fork, updating the documentation, and then making a standard pull request as you normally would.
In Python, I now hate requests because it throws exceptions instead of returning error codes, which other programmers always forget to catch until I nag them in code review.
These are awesome, I would totally buy some stickers
Go demand is increasing, in many markets. The parameter I get is the job offers I receive, 2014 was really low, 2015 improved from the half of the year. And 2016 has been hot enough to get few interview invitations every month. The profile of these openings have changed a bit too. In 2014, Go was used as a bait to attract talented people into companies where Go was not the main piece of their technology stack. 2015 I started getting call from companies that wanted migrate to Go. 2016 I have received pretty much the same profile as much as companies who now already have some established code base. My personal experience has been that legacy code written in Go tends to be much more organized and easier to catch on than its equivalents in PHP. What I mean is that a 2 year code base in Go, from what I observed, look better than a PHP code base 2 years old. We cannot place blame or praise on the language, but the trend is definitely there. I wouldn't put all my eggs on Go, but it is not a risky bet either. Just that whole flow of opportunities goes by at different speed. 
https://groups.google.com/d/msg/golang-nuts/3fOIZ1VLn1o/GeE1z5qUA6YJ &gt; As has been said, that book is about solving certain classic problems in Java, a language with a particular, restrictive programming model and type system. Go isn't much like Java. &gt; A concrete example: The Visitor Pattern. &gt; This is a clever, subtle pattern that uses subtype inheritance to implement a type switch. &gt; Go has type switches, and therefore no need for the Visitor Pattern. &gt; I leave the Singleton Pattern as an exercise. &gt; So you're right, it is educational to try to implement those problems in Go, but for the most part those *patterns* don't really apply. Java code doesn't work well in Go, nor Go in Java. &gt; -rob
[citation needed]
you might have to cut and paste that in if the referrer is reddit, GH might block like it just did when I tested it. Not only is that Go projects, but "recently updated" ones too.
There are very little "Go jobs" where I live like there are PHP jobs or Java jobs or Javascript jobs. Most offers I have seen in Europe list Go as a bonus language to get hired. Most of them also implied either C/C++ or Java were the main language used in the shop. You may have more luck in freelancing on punctual projects though. I might change but right now I wouldn't choose Go as a career language, like people do with Java or PHP. It will change when Go becomes a dependency or projects need to be maintained on the long run.
Keep it simple
How about something simple like this? http://play.golang.org/p/mDYvMTcZjR
https://github.com/trending/go
PHP code bases are usually spaghetti like due to the developers. Should same developers "learn" and I use that term losely Go. I shudder to think what their code will be in 2 months time lol. Edit: I've been a PHP dev for 8 years. I've seen my fair share of projects go from concept to production. I've worked with poorly skilled [php] devs, to some really good ones. Great PHP devs are rare! Oh and stick around in #go-nuts on freenode and see some PHP devs who are new to Go try and learn it. Don't know about lack of OOP, can't deal with strongly typed, don't know interfaces. It's such a culture shock, they try to PHPize Go LOL. So yeah, bad practice all round. I now only develop in Go, now done 50k lines of Go since mid Oct and pushed into prod. Here is one of the reasons why: https://www.reddit.com/r/PHP/comments/44kivl/i_feel_like_my_machine_can_handle_more_than_4000/ It sure is a real nice feeling no longer needing to deal with all that crap!
I'm not sure Go is appropriate in February 2016 to retool a large organization. My guess is the best Go jobs are in small targeted web/network services within a larger multi-language shop, or in a small number of competent startups. Go is paid for Google first, the public second. Anyway, generally your languages are less important than your competency as a problem solver. If you can write good Go/C/JavaScript/Java/Swift/Rust/C++/Python for your domain then you should be able to figure out how to write good code in any language for that domain.
Just load it into your registry if you only have an online tool.
Not sure whether or not this has been done before, but something I've been meaning to do in my non existent spare time was to find sources for rap lyrics since the dawn of time and run some sentiment analysis against them, and then classify the results based on year, geographic location and stage of career (i.e. how long they've been around for). And then, of course, write a blog post with some pretty visualizations. Not something that /requires/ concurrency, but it would definitely speed up the process. A completely useless but fun exercise (IMHO are any rate) :)
Great PHP devs usually quickly turn into Python/Ruby/Go/etc. devs and don't look back.
Gopher and GNU can still be friends though :)
You know channels use mutex under the hood, correct?
Hey I'm looking to get into some more freelance work in the UK - how do you find most of your jobs? How would you recommend a newcomer gets started? Cheers.
Here in the UK some big names have started using it, notably Hailo, Sainsbury's... a few others as well. I'm starting to get almost as many Golang job specs from recruiters as Ruby (which is at about 25% of all the PHP jobs that come through...). But it's growing fast. So if you're a beginner, keep it up, you'll be well ahead of the game knowing Go! 
People still fuck it up.
Well as I mentioned I'm having real trouble branching out on my own. I mostly pick up Python work through a friend but I'm aiming at in-office contracts for ~6 months now as they're much more lucrative.
A beastie one would be great. Side note. GNU people are fine with BSD, if I understand it correctly. https://www.gnu.org/licenses/license-list#ModifiedBSD Though maybe the BSD people consider the GPL as too restrictive, sometimes. Even though the BSD license allows software to become a lot more restricted, license wise.
Sounds like a good plan. Where do you look for these contracts?
TOML and JSON suffer from the overhead of escaping all strings with quotes. I have similar needs, and decided to stick to YAML. TOML offers the most consistent format (YAML &amp; JSON support inline structs, YAML string interpretation can be tricky, e.g unescaped yes/no/true/false are interpreted as boolean by default), so to compensate I borrowed the "go fmt" concept and implemented my own YAML formatter (some structs are better maintained inline, others as verbose-tab-separated blocks).
http://contractoruk.com/ has a search engine that searches lots of other job sites and amalgamates them. I also like JobServe which seems to find jobs that are nowhere else.
I'm looking at Viper ([https://github.com/spf13/viper](https://github.com/spf13/viper)) for a project I'm currently working on. It handles YAML, TOML, JSON, and a number of other formats. I like it for that, and because it can read from a remote (a la etcd) configuration source, and basically appears to take care of a lot of config-related plumbing that I would otherwise have to sink a bunch of time into. Caveat: I'm still evaluating it myself, so I don't have much in the way of real-world experience with it yet.
I'm currently using viper in my main project and it's been excellent. Would recommend.
Why do you dislike YAML? I do not understand why there is dislike for YAML. Given xml, json, or yaml, yaml is the most human writeable of the three, and once encoded you can put it into the most readable format needed by situation. 
Würdet ihr auch Masterarbeiten betreuen - Remote? Ich bin aktuell auf der Suche nach einer Firma die Masterarbeiten betreut und ich würde gern was mit golang machen. Ich bin allerdings wohnhaft in Bayern.
yeah that's true. I'm sorry I'm just biased there. 
Fair enough, I will add that into the readme today. To answer your question though you would just add something like this: deb http://my-hostname:listenPort/ stable main You can set the listenPort in the config. By default the app puts everything into the "stable" distro and the "main" section (hard-coded for now). You can also enable SSL in the config in which case you'd swap http for https.
Definitely agree with your sentiment on this aspect of Yaml. I really like it personally, but when I introduce it into a team project I end up having to write a git hook to try parsing any commits to the Yaml files because unfamiliar devs have their IDEs set to tabs instead of spaces.
Why do you need those? "Async" programming is builtin in Go using goroutines and channels. "io" library is actually abstracting some of it for you. "net" lib abstracts almost everything. So I really curios why do you need it.
https://github.com/esell/deb-simple/commit/9a0f2fee1e06bd45a5f24eb9de101a044d5e3190 :) Feel free to open up an issue (or PR) for any other things you feel might be missing.
Yep. We hire new grads. A github portfolio helps, too, but isn't particularly required. I personally use it when I'm on the fence and need to see code samples.
I forgot to add. I am not a new grad. I work in IT with some years of experience in the desktop and Adm area.
Thanks, yes I will check the company when I feel comfortable and have a good profile. I want to move away from IT.
Honestly, the best advice I could give is to have a repo of solutions to koans or that popular repo of interesting programming questions (can't remember the name off the top of my head). It shouldn't take too long, as you're just trying to create a sample. Good luck! 
You can say that again. I was hired as a go developer about a year ago to work on a webapp riddled with copy pasted 200 line http handlers with inline anonymous structs everywhere and functions that took ~10 arguments. It ended up being impossible to follow or maintain, so we finally rewrote the whole thing a few months later.
Currently we have a home grown system based on apt-ftparchive. We are in the process of retooling basing it on aptly https://github.com/smira/aptly but I'll look at deb-simple and see if it will work for us.
Yaml's fine until it gets really nesty. JSON's fine, but its easy to screw up the syntax, and as others have pointed out strings have to be escaped. TOML is pretty nice, although it still suffers from string escaping issues. I used TOML for https://github.com/mowings/scylla and was pretty happy with it, but nested quotes can still be a hassle.
hcl is cool too
Hi guys! Thanks for the comments! Who want can buy GO T-shirts and other interesting things with GO from Star Wars here: https://society6.com/agudova
I've used this one and I like it, although I feel it is a little too strict sometimes as I end up spending lots of time hunting down syntax errors in my yaml that I can rarely see easily. It might just be me and my use case. 
yes, here https://society6.com/agudova
I would certainly encourage you to check it out but I will tell you right now that deb-simple has nowhere near the amount of features aptly does, which was done on purpose. We actually looked at aptly before I created deb-simple but it just didn't fit into our setup and was way too much for what we wanted.
Cool. Thanks. The presentation graph says everything about Go and its future.
Great, order placed!
Here's a really naughty solution: use Gopher-lua as a massively overpowered configuration language, like I did with [listless](https://github.com/cathalgarvey/listless). :)
I agree. I'm just pointing out that beastie wasn't invited to the party.
damn 20$ for shipping :( would love those. Is there any way you could open a shop at maybe spreadshirt.de? ;P Or can I use them and maybe paypal you a donation? 
http://projects.sentinelchicken.org/reglookup/ has a C API you could write some simple bindings for? e: The other one I was going to link is hosted on Sourceforge and Reddit blocks it, it seams. 
This link has a funny file extension. 
From the comments below this is the perfect time to learn and master Go.
As someone living in Leipzig it looks so appealing to me. Too bad I'm not that good in Go. And have a job, but daym.. Some day I'll apply :D 
I was looking a tool like this one, thank you
It might just be yaml and its invisible syntax.
I'm author. I no longer found a future in it.
Why not just use the standard library? https://golang.org/pkg/bytes/#Index
No worries man, it happens. The std. lib one is a little bit faster because it implements bytes.IndexByte with assembly. bytes.Index: BenchmarkShortByteSearch-8 100000 20755 ns/op BenchmarkLongByteSearch-8 50000 28766 ns/op bytesearch: BenchmarkShortByteSearch-8 20000 63485 ns/op BenchmarkLongByteSearch-8 50000 35580 ns/op
- database access: https://golang.org/pkg/database/sql/ - standard library - HTTP: https://golang.org/pkg/net/http/ - standard library - static file serving: https://golang.org/pkg/net/http/#ServeFile - standard library - templates: https://golang.org/pkg/html/template/ - standard library I think by now you've noticed a pattern here :P Also you don't need nginx/apache in front of go program - net/http is secure and highly performant
&gt;Also you don't need nginx/apache in front of go program - net/http is secure and highly performant That is, unless you have a cluster of app servers and you're using nginx's load balancing
I got a pretty great Go job offer this week of a Zurich based company. Full of microservices and other cool stuff.
true, but in that case you're better off with HAProxy, Traffic Server or even Tengine (nginx fork with upstream health checks + a lot of other nice stuff)
I agree in general but I'd say for a REST API a proper routing lib like gorilla mux is worthwhile. Having nice "/resource/{id}/subresource/{id2}" type routes definitions makes things cleaner IMO.
Look like a nice project. One question, though: It looks like you went with GPL2 (without the '+'). Is there a reason? Also, you copy pasted the application tutorial at the end of /LICENSE ;-)
This group is a good one. http://www.meetup.com/Go-London-User-Group/
no inotify on windows
Cool stuff! I'll check that out
There are several http router libraries that would definitely help, LARS - https://github.com/go-playground/lars Echo - https://github.com/labstack/echo httptreemux - https://github.com/dimfeld/httptreemux A data validation library, prior to saving data to database: validator - https://github.com/go-playground/validator A CORS library https://github.com/rs/cors A word of caution about httprouter and other based on it's algorithm, they are fast but currently lack support for some pretty common URL patterns https://github.com/julienschmidt/httprouter/issues/73 the ones I listed all handle those patterns 
A couple of things: - The race detector finds unsynchronized memory access, not goroutine scheduling problems. - You need to call wg.Done() somewhere. If you can't modify the function you're waiting on, wrap it in a closure and call it there. - Research done channels. I'm on my phone but I can add a link later. 
You picked the smallest problem there lol.
I think you're right. I will test to measure how an implementation that uses the Mutext is more performant than an implementation that relies only to gorutines and channels. As soon I will get the results I will publish them.
Tut mir Leid aber nein. Remote bei uns nur begrenzt, zum Beispiel um Zuhause zu sein fuer Kinder. Und wir haben keine Zeit / Kapazitaeten um jemanden Auszubilden.
PHP stands for [Philippine Peso](https://www.google.com/search?q=google+1php+to+USD&amp;ie=utf-8&amp;oe=utf-8&amp;gws_rd=cr&amp;ei=nNm9VsCCNIejsAHK_LLgDQ#q=1+php+to+USD), didn't you know?
That's awesome, the wrapping is what I was thinking, but my test is in another castle. I mean, another file. :) So I can't access the wg that its using internaly. So, calling wg.Done() in a wrapper function would not work, no? That sounds like something I would like to do, but how do you suppose I could do it? Wg is declared inside the function which is executing the routine. Not outside. And yes, the race occurs, because that go routine inside is still running after the test is finished and it's using a map which then the next test is trying to use. I could go on and use a lock on the map in the test, but that wouldn't help to other routine which is using it without shielding. That's another poor implementation in there. 
Care to read my comment again.
Sorry, but nope. That's not what I'm looking for. :) But thanks. I know how to cancel, close, discrad routines when you have control over them. But this is testing a foreign code where there is a routine which does not finish. Ever. And on top of that, you don't have access to the Wait Group it uses, so you can't call done arbiterarly unless you do some reflection magic, which I do not want to fall back on. :) Though I'm starting to think that's plainly not possible to do so, and that I should wonder on.
I edited the question to clarify this. I do NOT control the wg unfortunately. Yeah, I came to the same concolusion. :( I can't test this without creating a race condition. :(
If the blocking routine really doesn't have a plan for how to call `Done`, it's poorly written and you should probably just fork the code and rewrite it. Don't fix the test; fix the code! :-)
Is this a collaborative coding effort? The person who created the code that runs in the goroutine needs to provide some way for it to exit cleanly. If the inability to modify the goroutine code is due to it being in a 3rd party package, can you give us some details of which package so we can perhaps provide better advice? If you don't have access to the `wg`, you can't call `Done` on it and the goroutine will always block.
Yepp. I agree with you on this. :) Thanks. :)
+/-
This issue still blows my mind. Someone put it pretty well why I just don't get it. They said something to the effect that 'modern' programming languages aren't tools, they are systems that will manage everything for them. I don't like that approach, I don't want everything handled for me. Maybe I'm just crazy. That's not to say that I don't like the ability to go get. When I'm testing out packages it's awesome. When it comes time to actually put something together though I pull locally and package it all together.
The tests I've done show that the mutex much more performative. I updated my blog post. Thanks!
Congrats. I'm nowhere near zurich =)
Thank you for your advice.
&gt; That's not to say that I don't like the ability to go get. When I'm testing out packages it's awesome. Indeed, it has its uses - as an LPM (in my article's terms). &gt; that will manage everything for them. I don't like that approach, I don't want everything handled for me. Maybe I'm just crazy. I don't think a package manager (and in particular the narrow domain that a PDM governs) is about managing "everything." It's about managing a specific relationship between your code, and your dependencies. That's part of what I was trying to suggest at the beginning - try to do too much, and you'll fail. Because... &gt; When it comes time to actually put something together though I pull locally and package it all together. Organizing and marshaling this well-definable process is all a PDM does.
I've been using this lately and have been pretty happy with it: http://ant0ine.github.io/go-json-rest/
Awww yisss, been wanting to try vim with Go. But no succinct guide until now! \o/
Holy crap did I just spend an hour reading through a well thought out article about package management? I did. I also liked the off the beaten tracks idea of your PDM. +1
Thanks!!
If the test never returns it must be working. Lol
Aha! Solved it.. I have to append directly to the slice, not within the for loop. for i, event := range events { //Get all the items for this event. items, err := getBidItemsForEvent(event.Event.Event_ID) fmt.Printf("%#v\n\n", items) if err != nil { fmt.Println("Error at getting item events in GetEventsByUserId", err.Error()) } //Append them to the events items array. for _, item := range items { events[i].Items = append(events[i].Items, item) } }
`e` is a copy of the event. Compare: https://play.golang.org/p/OMdDdz1K32 (similar to yours) vs https://play.golang.org/p/ireemFw2Xi
I'm a fan of [spf13-vim](https://github.com/spf13/spf13-vim) for Go development specifically and vim in general. Admittedly, it's my first introduction to using vim full time.
&gt; Package everything into the repo that you are going to build with. that's not a viable solution for opensource libraries that have dependencies. A dependency needs to be managed. You can do that manually but programming isn't about doing the computer's job. 
Yeah I never wanted this to be a note against what you are purposing I like the article. It just always seems like these situations are one that I avoid so I don't have to deal with them.
Thanks to share this thorough work. As Go user, i like this : &gt; At the same time, we can pursue a simplest-possible case — defining a lock file, for the repository root only, that `go get` can read and transparently use, if it’s available. I hope you will continue with a new clean issue with the shortest common proposal. (easy to say !) Please, don't forget why we all use Go, because it's simple, not because it has the best feature from other language. I know, simplicity is complicate... Thanks again !
&gt; Any ideas on how to proceed with this? I would much appreciate it!! The correct answer is: Change the code. Fork it, if you must, but you have read-access to it, so you *can* definitely create a testable version of it. The ugly answer is: Use process-isolation. Set an environment variable that indicates which test you want to run and use [os/exec](http://godoc.org/os/exec) to execute the test-binary. Something like this (untested): func TestFrobnicate(t *testing.T) { switch os.GetEnv("TEST_FROBNICATE") { case "": cmd := exec.Command(os.Args[0], os.Args[1:]...) cmd.Env = append(os.Environ(), "TEST_FROBNICATE=1") cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr if _, err := cmd.Run(); err != nil { t.FailNow(); } return case "1": break default: return } // do your tests here } There is probably quite a bit of ugliness around here, that you need to work around. But, as I said, the correct solution is to *change that code and make it testable*. [edit] meh, that obviously doesn't work like that. You can't properly decide between tests like this. Lemme try again: func TestFrobnicate(t *testing.T) { switch os.GetEnv("TEST_FUNCTION") { case "": cmd := exec.Command(os.Args[0], os.Args[1:]...) cmd.Env = append(os.Environ(), "TEST_FUNCTION=Frobnicate") cmd.Stdin = os.Stdin cmd.Stdout = os.Stdout cmd.Stderr = os.Stderr if _, err := cmd.Run(); err != nil { t.FailNow(); } return case "Frobnicate": break default: return } // do your tests here }
ahhh, ok, sorry - i misunderstood. thought i had some points to refute :)
Is this retroactive or for new purchases? I purchased the MEAP a while back.
You're right, of course. Perhaps a better person than I can figure out how to compress the full scope of the package management problem into a &lt;10 min read. But that was the purpose of the article: lay out the full scope of the problem, because it is my sense that so, so many discussions of it have ultimately failed because the participants don't see the whole picture. Basically, my bet is that it's worth reading one person's 13000 words if it can prevent many people feeling the need to write many, MANY more disjointed words about it later, and provide a lot less coherent information. (Hey look - harm reduction again!)
This might help you: https://github.com/gonum
Really glad someone responded with this information. Sure third party libraries are great but they can do a lot you don't care about. I think it's best to start with the standard library and then if you really need a feature from a third party, only then should you invest. Also I'd say avoid any routing or HTTP wrapper library that breaks the standard libraries method signatures. Gorilla is broken into chunks that allow you to do things without buying into library specific types you'll never be able to use elsewhere. 
damn web developers. manage your workspace yourself. there are tools to help you do that. use wgo.
DNS is the thing that tells you where to get that information, not the thing that stores it.
After diving into Go, I'm a true believer at this point. As a long time C# / C++ developer, it finally clicked with me when I understood that with go your function just has to adhere to an interface instead of actually implemented it and create a dependency like I'm C#. Fuckin fantastic. For me, 2016 will be the year of Go, Swift and more C# (7 is looking promising).
`strings.Split` on a shell command line in a very bad idea.
Indeed it is. So why are you asserting that it's the central registry?
As I said on the other thread, start a python per core, communicate over ZMQ and you will easily max out your CPUs. Go and Erlang are uniquely NOT suited for numeric computing, I would think you should be looking at R and Julia. Maybe Roger (http://www.senseye.io/announcing-roger-a-library-providing-simple-access-to-r-from-go/).
What's the correct use?
I get your point but I think he means that go binaries don't have any more dependencies than a comparable shell script. Edit. And yes, he should be using `ReadDir` from `io/ioutil`. Parsing `ls -l` is a bad practice anyway.
Except that if I need to view a page that was written in 1999, I can't query DNS for what the internet looked like back then, such that my hyperlinks still work. The time axis (versioning) is indeed very important for anyone, or any organization, that wishes to invest in Go code for the long haul.
Wow dude! That's some amazing stuff right there! :-D I shall save this for later research, however I absolutely agree with you that I should rather change the code. 
I know your question is with respect to Go &amp; Erlang but have you considered [Julia](http://julialang.org)? From what you have written I would have thought it merited consideration.
It's not a definitive list, but there's quite a few uk go jobs here: https://golangnews.com/stories?q=Hiring: And there are also a few sites now specialising go jobs: http://golangprojects.com http://www.welovegolang.com Are the ones I've seen most. Also see the HN who is hiring threads. I've definitely seen an uptick in jobs in the last year, mostly in London. 
I changed it to "echo hi" to avoid confusion there. Obviously, I would use ReadDir as well. I also would prefer to use go's tar package rather than extract a thing with the tar command line tool.
Normally I would use something like Python's shlex for this, but there doesn't seem to be an equivalent in the go standard library.
Seconded. If you run services inside an environment that has log aggregation and analysis, K/V style logging is a *must-have* feature. The ramifications extend well beyond debugging, like intrusion detection, catching a DDOS as it happens, documenting/discovering network probes, alerting on errors and failures, incident investigation and reconstruction, etc. The gist is that if your log output isn't structured, it's not easily searchable, which makes it incredibly hard to use at scale. Basically the default Go logging implementation is minimal at best, and should be considered harmful for real-world applications that aren't small client apps.
You could try using [Flags] (https://golang.org/pkg/flag/) and then you could concatenate the variables in whatever order you want them. Unless you are not dealing with runtime arguments. Oh wait. You are using an external go file for confirmation? That's not right. You should use a json file for that! Are you restricted to a go file? If so, have the arguments in separate variables which you could then move around. Also, if you don't want to use append you could try using slice indexes, like args[1:] and copy, but essentially it would leaf to the same conclusion. Without restructuring the way you are handling input right now there are limited options at your disposal. 
gofmt could be optional also, but it's great to have common way to do the same things with other or with oneself some times after.
You have 90% of a benchmark right there. Now, just execute it. Benchmarking go code is *really* easy. Read the Benchmark section of the [testing package](http://godoc.org/testing). Benchmarking both will give you a definitive answer, for your specific usecase and data. Instead of just guessing :)
As /u/srbufi says, you should take a look at gonum. Specifically, there is a pull request in the works for concurrent global optimization, which paves the way for evolutionary algorithms. Simd is useful as /u/bunnyslopist says, though the things you mention (i.e. dot product) are implemented in gonum with simd
That being said: My bet is on [something like this](https://play.golang.org/p/rKyNNqP3jh). Because it's the minimum number of allocations and copies possible and ultimately those will dominate.
This is gross due to "invocation" being a slice. Could you give "screenname" as an argument *after* your invocation? That would make the code: args := append(invocation, "-dmS", screenname, rootdir+servername+"/server.jar") You could also consider if you could use the result as a string: args := fmt.Sprintf("-dmS %s %s %s%s/server.jar", screenname, strings.Join(invocation, " "), rootdir, servername) As for using a go file for configuration, it depends on the purpose. You could have a go file with compile-time constants if these options are not meant to change for *any* reason after delivery. Server configuration, however, should be in an external file of some sort, although I would *really* suggest that you didn't use JSON.
I agree structured is the way to go. Can you recommend any good kv loggers in go? Preferably one that can integrate with logstash. 
ahh thats pretty cool. good solution.
I forgot to push my changes to the proc package to GitHub. I'll go do so 😉 thanks
&gt;Could you give "screenname" as an argument after your invocation? I don't think I have that option. I'm using this as a server management tool for a Minecraft server, and I'm running it in a screen. I'm using codegangsta's cli library and receiving the servername on c.Args().First(). Then I build out the full body of exec.Command(cmd, args...), where args ends up being something along the lines of "-dmS msct-servername java -jar /full/path/to/servername/server.jar", and cmd obviously contains the actual "screen" command. So I'm really just bumbling around trying to learn what defines "good form" for me. I did actually try fmt.Sprintf for the full invocation at one point, but exec.Command() didn't seem to like it. &gt;You could have a go file with compile-time constants if these options are not meant to change for any reason after delivery. Server configuration, however, should be in an external file of some sort, although I would really suggest that you didn't use JSON. Yeah, I may look into toml or yaml. Eventually this will be code up on github for people to use. Until then, recompiling to change options doesn't matter to me.
at the very least you can switch to [strings.Fields](https://golang.org/pkg/strings/#Fields) to avoid stuff like two consecutive whitespace character breaking a program.
I still like JavaScript. ;p
in my experience, multiprocessing is a nice hack and generally serviceable, but it's not very reliable, even when working on the same machine: workers get stuck, workers don't report back to the master when stuck, signals are ignored, etc... it's great for a quick one-off parallelism job. not -again, in my experience- for a reliable job.
what do you mean by "fine-grained threading"? Go certainly has a very lightweight threading model (channels+goroutines) with access to low-level threading primitives (mutexes, locks). no NUMA awareness. yet. (see: https://docs.google.com/document/d/1d3iI2QWURgDIsSR6G2275vMeQ_X7w-qxM2Vp7iGwwuM/pub)
royalties pay on strange and long cycles. We haven't received any yet, so it's retroactive and will include all book sales ever :)
Okay, I just pushed uncomitted changes :)
For starters, you're interested in parallelism, not concurrency. Seconds, Erlang is realy bad for computation. There's HiPE, but it's really a huge a joke. Unless you want to spend time profiling BEAM, stay away from Erlang for raw computation. Erlang can do great in soft real-time ang gets really efficient with overhead of a single processes and their scheduling. Believe me or not, but I'm actually slowly working on an article comparing soft real-time Elarng vs. Go. Unfortunately Go fares really bad in soft real-time, the 2 biggest hurdles being GC (`GOGC=off` was a must, otherwise tweaking the gc memory step, just to get killed by 120s enforced collection) and scheduling. With the Go's current execution model it is just impossible to achieve the same efficiency as Erlang, mainly because the scheduling if enforced by BEAM (Erlang's VM) for every couple of hundrded instructions. For comparison in Go, the scheduling points were normally places where you'd wait for I/O, or recently, the additional point at the function stack change (eventually you need to fall back to `runtime.Gosched()`). If that is not enough, the GC is per process in Erlang, hence there's very little distracion enforced by GC when you run. This in start cotrast to Go with the stop the world model. Finally, the Erlang process vs. goroutine size leans toward Erlang. In Go, the goroutine stack is at least 2kB (since 1.4?), in Erlang is a couple of hundred bytes (IIRC 128-256B). To translated that into numbers, Raspberry Pi could handle ~136000 goroutines at once, with Erlang we could get up to ~280000 processes. But wait, the issue was about HPC. Summing up Erlang sucks, executed by VM, HiPE being a joke. Go sucks, the compiler is not as good as gcc or clang, I'm not sure if it's aware of SIMD intrinsics yet. It certainly was not 2 years back. Your only hope in Go is interfacing with C libraries. Just stick to Python + NumPy. Try explore the avaialble parallelism in NumPy by making sure you're operating on matrices/vectors always. If that fails, take a look at Numba or Cython. From experience, Numba is easier to use. If you want more, look into Julia, or C++ with OpenMP.
This isn't preferred because strings are immutable, so you end up allocating a lot of space for the different substring combinations. Just use strings.Join. 
thanks
Well, one simple way to limit CPU use would be to set [GOMAXPROCS](https://golang.org/pkg/runtime/#GOMAXPROCS) to less than the actual count of CPU cores, thereby leaving the remaining cores free for other programs.
Or you could use https://godoc.org/golang.org/x/net/context/ctxhttp to set timeouts from a context.
Nice, I didn't know about that. Thanks!
Thx
Show us the whole code. What you show us has no parallelism and thus no race conditions.
By array of pairs do you mean array of structs? Which data type should I be using that allows int and string pairs?
Yeah, an array of structs. Make your own struct type for that.
minor nitpick: use streams! // from the article: buf, _ := ioutil.ReadAll(response.Body) json.Unmarshal(buf, &amp;sprockets) // should be: json.NewDecoder(response.Body).Decode(&amp;sprockets)
&gt;you're interested in parallelism, not concurrency That's totally right &gt;Believe me or not, but I'm actually slowly working on an article comparing soft real-time Elarng vs. Go I would really like to read it! &gt;Just stick to Python + NumPy. Try explore the available parallelism in NumPy by making sure you're operating on matrices/vectors always. I will take this advice into account and keep my legacy code 
&gt; I'm not sure if it's aware of SIMD intrinsics yet Just an FYI: Go will vectorize up to SSE2 level. Beyond that, the binaries become machine-specific. So, it's a trade-off in the compiler between cross-compilation capability and machine-specific efficiency. 
Now includes HTTPS :)
120 seconds for garbage collection?
Since Timeout is a public field you could also just set the timeout for it when you need to. Maybe this isn't a good idea if you only want a custom timeouting client in one place. But unless im mistaken, there's no need to disparage the DefaultClient for not having a timeout because it is publically writable.
&gt; Manual package management has an additional benefit I can't believe people are advocating for MANUAL package management. Why are you a programmer at first place ? because it helps you automate tasks.
Yes, by "default HTTP client" he means using `http.Get` or `http.Post`. If you define your own client _using the standard library_ that has a timeout, that is safe.
Others have already pointed out the actual issue - that map iteration order is explicitly randomized and cannot be relied upon. But I wanted to point out, if you're not using goroutines, you shouldn't see any race conditions. If you are using goroutines and suspect you have a race, you can use the `-race` flag to `go test` or `go build`, which will do a very good job of pointing out any data races you might have.
Excellent thank you for that. 
I started to read about dlang and i have to say it seems great.
For people looking for sending SMS over to an SMSC, using the SMPP protocol (as opposed to using a modem) check out https://github.com/fiorix/go-smpp
By manual package management I mean resolving versions of dependencies manually. This is something that can only be automated to a certain extent and in non-trivial cases a human decision is always required. E.g. when a package that you want to use doesn't follow semver rules or you need to include two incompatible versions of the same package or you cannot upgrade to the latest version because of a bug, etc. I agree that downloading dependencies should be automated. But it is a much simpler task. As I mentioned even a simple bash script can be used. There are tools like glide, godeps, etc to help with it as well.
gofmt is optional. Obviously it is quite useful and this is the reason most developers use it. There is a common way to download and build go applications as well - go get. With vendor directory it even supports reproducible builds. It is also very convenient. To start working on a project the only thing you need to do is to "go get" it. You don't need to figure out what package manager the project uses and download all the dependencies in a separate step. The part that is missing is some sort of standard package metadata file with the list of compatible dependencies. I agree that it would be nice to have common way to specify them. My point was that even without this common standard it is not terribly difficult to manage dependencies of a Go project. 
Oh pretty cool! I'm currently wrapping my head around everything that has been said in this thread, and then I'll post some benchmarks.
I am not quite sure what exactly you disagree with. I didn't argue against package managers. I agree that it makes life easier in most common cases. However from my experience lack of package manager doesn't make developing Go applications and packages more difficult. As you pointed in your article writing a good package manager is very hard. You did a great job describing various use cases that a package manager should provide solutions for. But there are probably at least as many use cases that you didn't even mention. "go get" with a checked-in vendor directory already supports all of them. 
I disagree with the idea that Go doesn't stand to benefit significantly from package management; that "Go's simplicity" makes unnecessary what is so direly needed elsewhere. Go's URI-like package identifiers mean you *can* avoid having a package manager, but it doesn't make it a good idea. I'm too tired to re-craft the argument for you here and now, so, quickly: The two necessary components of a package are its identifier and its version - and `go get` only deals with one of those. Versions are a signaling system for communication between people about their software. They let us do more, easily, while knowing less about our dependencies (but do not preclude us from diving in deep on them), which lets us reduce uncertainty with greater facility. Development is inherently mired in uncertainty, and anything we can do to reduce that is highly beneficial. &gt; However from my experience lack of package manager doesn't make developing Go applications and packages more difficult. This is an impossible comparison to make, but OK &gt; You did a great job describing various use cases that a package manager should provide solutions for. Actually, I pretty much didn't do this. I even explicitly said I didn't think it was a good approach to the problem. What I *did* do was describe the necessary constraints under which a PDM operates. &gt; But there are probably at least as many use cases that you didn't even mention. Can you give examples? &gt; "go get" with a checked-in vendor directory already supports all of them. No, it does not. This is addressed, directly, in the article. It may work fine for you, but it doesn't work fine for anyone who may want to pull in your project as a dependency. Consequently, this strategy is directly antithetical to sharing, which in aggregate, makes for a less healthy public code ecosystem. And, even if it's just for you, obliterating upstream's chronology - which is what you're doing if you check in vendor - is a short-sighted practice that requires work from you (and every other consumer of a lib) that could be significantly reduced if the upstream author were to provide well-ordered versions.
Given that the example is expecting a json response in full, is initializing a stream really necessary? I could see if you wanted to act on a partial response, but given that the writer is just using the full response as an example, I see the code as acceptable and very readable in a way that conveys the intent perfectly.
There was a nice comparison of C, Python and Julia for scientific computation: https://www.ibm.com/developerworks/community/blogs/jfp/entry/A_Comparison_Of_C_Julia_Python_Numba_Cython_Scipy_and_BLAS_on_LU_Factorization?lang=en
Does it do auto vectorisation like GCC does? Besides, SSE2 is pretty modest, nowhere near what I would expect. There's always an option to use `gccgo`, almost the best of both worlds (though usually a relase behind)
It's more code that requires more copies to be made over more time since you can't start incrementally parsing. Why would you advocate for this?
&gt; This is pretty clickbaity! Could be worse, could be one of: 1. Everything you know about Go's default HTTP client is wrong 2. Go's default HTTP client considered harmful 3. Why [our startup's name] stopped using Go's default HTTP client, and you should too
This is absolutely amazing, thank you!
Your solution is officialy the most efficient for this specific example: BenchmarkConcatBytesBuffer-4 3000000 552 ns/op 224 B/op 2 allocs/op BenchmarkConcatBufIO-4 1000000 1362 ns/op 4208 B/op 2 allocs/op BenchmarkConcatStringsJoin-4 3000000 519 ns/op 320 B/op 4 allocs/op BenchmarkConcatWriter-4 1000000 1655 ns/op 544 B/op 28 allocs/op BenchmarkConcatCopy-4 5000000 294 ns/op 176 B/op 2 allocs/op [Link to playground](https://play.golang.org/p/Y2tFczM5Nj)
4. 5 Reasons why Go's default HTTP library is dangerous 5. We used Go's default HTTP client. What happened next will shock you. 6. Go's HTTP library tries Japanese food.
An unnecessary dependency for most people considering the functionality for timeout is in the standard library already. A good suggestion nonetheless. 
Just trying to live up to the name. I'd say he's doing pretty well.
 func main() { http.DefaultClient.Timeout = 10 * time.Second ... } Ta-da! Now you can use the default client. (I've had a problem with a third-party library making calls using the default client.)
if go programmers cared about conveying intent, they might not use single character variable names as a standard :p
Why would having no default make sense? Seems like this should be a bug honestly. 
If I could describe this article with a picture then it would be [this](http://i.imgur.com/zV0r9V9.jpg?1).
Like gofmt ;-) ?
In a related vein, I would argue don't use the default server mux, particularly in libraries. Inject it. The app author can inject the default mux themselves if they want, but I often have more than one port serving http and it is quite irritating when a library only works on the default mux. The built in expvar is guilty of this, which is particularly irritating because I'd prefer to always run that on a different mux/port that isn't available outside the network.
YouCompleteMe + vim-go is pretty sweet.
To reduce noise, I would suggest benchmarking against [ioutil.Discard](http://godoc.org/io/ioutil#Discard). It doesn't change a lot, though. Before: BenchmarkConcatBytesBuffer-4 3000000 557 ns/op 224 B/op 2 allocs/op BenchmarkConcatBufIO-4 1000000 1495 ns/op 4208 B/op 2 allocs/op BenchmarkConcatStringsJoin-4 3000000 511 ns/op 320 B/op 4 allocs/op BenchmarkConcatWriter-4 1000000 1659 ns/op 544 B/op 28 allocs/op BenchmarkConcatCopy-4 5000000 291 ns/op 176 B/op 2 allocs/op After: BenchmarkConcatBytesBuffer-4 3000000 476 ns/op 112 B/op 1 allocs/op BenchmarkConcatBufIO-4 1000000 1366 ns/op 4096 B/op 1 allocs/op BenchmarkConcatStringsJoin-4 3000000 425 ns/op 208 B/op 3 allocs/op BenchmarkConcatWriter-4 1000000 1342 ns/op 432 B/op 27 allocs/op BenchmarkConcatCopy-4 10000000 195 ns/op 64 B/op 1 allocs/op
Someone did something similar a while ago: http://bouk.co/blog/monkey-patching-in-go/. Neat excercise in any case!
TL;DR: Someone had false assumption about the timeout on an HTTP request. Go's HTTP client is blamed. The title says "_Don't use_ Go's default HTTP client" But the recommended solution is: "Use Go's default HTTP client _with a timeout_" 
It reduces complexity (there's only one error to handle, and one package involved) and propagates good patterns for those who copy and paste code. It's bad code, it's unnecessary, and will be copied and pasted. Examples should be better, especially when there's no justification for adding complexity and overhead just to make it use more lines (and then make excuses for not handling errors since there are more of them to handle).
Perhaps consider doing more requests and using Keepalive (-k). Raspberry Pi 2 yields 8226/s over localhost and using a recent 1.6 branch Go. 
Yes, and wrk is better than ab.
If I were building a GUI frontend in Go, I'd probably use one of: - [QML](https://github.com/go-qml/qml) (web-inspired syntax for building native GUIs) - Straight-up [QT bindings](https://github.com/visualfc/goqt) - [andlabs/ui](https://github.com/andlabs/ui) which is a custom native GUI library, a fairly ambitious project. Some more options here: https://github.com/avelino/awesome-go#gui
Here is stickers: http://www.zazzle.com/agudova/products P.S. Latest will be another things too;)
Although it would be cool if someone used Electron bindings to create a UI framework in Go...
https://github.com/oskca/sciter
I like [atom](https://atom.io). 
The IntelliJ family of IDEs (IDEA, RubyMine, etc.) have great Go support now. They've pushed it out into their main plugin repository so it's ridiculously easy to install. They don't have direct support for the vendor extension yet but you can trick it by adding a 'src' symlink to ./ inside the vendor subdirectory and then adding that as an additional GOPATH in the project preferences.
Contrary to the original poster's comment, both examples are using streams - They just are using streams differently. In the example provided, the only stream is the response.Body. **ReadAll Method** * [ioutil.ReadAll](https://golang.org/pkg/io/ioutil/#ReadAll) reads the entire stream to the EOF (End Of File) then returns the full buffer ([]byte), or potentially an error along the way. * [json.Unmarshal](https://golang.org/pkg/encoding/json/#Unmarshal) attempts to parse the []byte array and if successful pushes the data into the &amp;sprockets object. If parsing fails, an error is returned. **Decoder Method** * [json.NewDecoder](https://golang.org/pkg/encoding/json/#NewDecoder) creates a new json.Decoder struct, which provides methods to more directly work with the input stream for the purposes of reading json. * [json.Decoder.Decode](https://golang.org/pkg/encoding/json/#Decoder.Decode) will read the input stream (response.Body) until it has a perceived "complete" json object (almost always the full stream) and then uses json.Unmarshal to push the data into the &amp;sprockets object. If parsing fails, an error is returned. The ioutil.ReadAll method is very straightforward shotgun approach which can sometimes be useful if you don't care about the individual pieces of data, and just want it all at once, used when troubleshooting very often. The only difference is that with the decoder, you can continue to feed the stream with additional json objects, and make multiple Decode calls. In this example, it's pretty unlikely your HTTP server would ever respond like this, but if it was a custom stream it could be setup this way. *In the end, they function almost identically* - read the stream till the end (either EOF or end of perceived JSON object) then Unmarshal. In this case, where the article's subject doesn't revolve around how one should parse a response, the author chose to use the methods (ReadAll, Unmarshal) that are most commonly known to beginners and veterans, that way the example woudn't contain unnecessary complexity.
We obviously have different ideas of what complexity means, so we'll just have to agree to disagree.
Vim works great! vim-go plugin is extremely helpful.
https://github.com/visualfc/liteide
Thanks for all the replies. I started using Visual Studio Code with the go plugin. Seems to work pretty well but wanted to see what other people are using. 
I'm not convinced. This still suffers from the main issue of writing "cross platform" code on mobile devices, whether it's C, C++, or Go. You're introducing yet another language to the mobile client that is more difficult to debug. It makes sense if you're writing code for 6 different mobile platforms, as was the thought 6 years ago. Now there are 2, maybe 3 platforms you will develop for, and its simply easier to write it in the platforms native language. It's easier to develop, debug, and test. I've developed for both iOS and android, as well as been QA for a major communication app. Cross platform bugs are the hardest to isolate, hardest to debug, and take a long time to fix. While this is really cool, its simply easier and faster to duplicate the business logic in the manor that was designed for by the specific platform.
VS code is a good one. I started with Sublime3.. but VS Code now has debugger support which makes much more attractive than alternatives. 
OH man I am really sorry. 
I deleted because it had my personal github on there. 
Be sure to configure it to use goimports.
The is also React Native .
Most of the Go tools (such as go install, go test, etc) work only with the source code inside GOPATH. In certain cases you can get away with putting your Go source code outside of GOPATH but instead of fighting with GOPATH I would recommend to learn how to use it. 
https://wiredcraft.com/blog/high-security-electron-js-application/ They used electron with a Go backend (locally.) Can't read easily on my phone nor have I tried it but... If you are already comfortable with electron gives you just that with compiled go to call into (via http/rest interface I imagine)
What are the results with Go 1.6? I've [seen some benchmarks](https://gist.github.com/captncraig/09d9dc5dbf70688bd521) that seem to indicate things will be faster with Go 1.6, despite not being able to explain it... Also, if the tests were run for ~10m and used wrk I'd be more convinced of the results. (But can somebody explain to me why ab is frowned upon? I've just never gotten useful/working results from it, but am not sure why, maybe I used it wrong...)
Learn vim. Bitch!
Well done, dude. ;)
Cargo is pretty great. Not a position I started out from when writing this, but something I discovered through the research. At the same time, there's a lot of differences between the extent of what Cargo expresses and what I'm actually suggesting we work on for Go right away. We've gotta get the PDM part right, first.
This maybe true for a communication app but for an app with more platform independent business logic (e.g. chess game) using a single implementation in one language could be a better choice than re-implementing the same logic 2 or 3 times.
The auto-vectorization is similar to GCC (obviously they're different algorithms, so it won't be exact). I agree that SSE2 is pretty modest, but that's as much as can be guaranteed on an amd64 architecture. The compiler is designed around building on a dev machine for deployment to a server, so I can understand why they didn't get too machine-specific with it. Once the byte-code goes beyond the guaranteed instruction-set, deployment becomes a roulette game. The assembler allows you to roll vectorization with higher-level instructions, if you're willing to hand-tune some assembly code. Concurrency/Parallelism gains can be applied to more situations, so those are usually the best goal for server-side code. Higher-tier vectorization in the compiler is probably a couple years off and will probably require a compiler flag.
Wow you reinvent the wheel with Go instead of Ansi-C/C++. But practically this way of mobile app development - is most hardest and painful. Is usable only for projects which solve the complex CS tasks, like computer-vision, video compression, etc. 
IMHO you should use http.StatusBadRequest instead of magic number (400).
No offence, but the behavior of developers that you described is very childish ;) If two developers on a team work on the same project and encounter a problem they should fix it instead of blaming each other. Back to my example the chess game rules have been very well defined for thousands years (clear understandable project documentation!). Yet writing chess engine 3 times in different languages is not the best way to spend developers' time.
I use Spacemacs, makes things a lot easier :D
Thanks!! yesterday for the whole day I was wondering how might I add comments. I'd have a comments table, then I was wondering how I'd keep the context struct to handle the struct. Then it struck me, fetch all comment objects in memory, fetch all tasks in memory, parse through the tasks context object and assign the respective comment object to that task object's comment field :P 
...a JavaScript+JSX framework then. The performance point still stands. Also, on a more personal note and trying to be as nice as possible, I believe I have enough JavaScript in my life with frontend development for web browsers.
React native is actually really well thought out, you should look into it. the UI is running on native code, in another thread javascript is run to handle UI events which are pushed from the native code into your javascript runtime. Its crazy fast for a cross platform framework.
I made a repo awhile back with an early implementation of Go with Electron. It uses the main node process to spawn a Go executable. The backend communicates with the frontend react app using gRPC. Here's the [link](https://github.com/nii236/graviton)!
Na na na na na na
soon
Atom has come a long way since it's early drafts. For me, it has replaced sublime.
&gt; This give a lot of hope that a Go 2 There will be no Go 2 from the Google team. 
Was there a statement made of this? Or is this speculation&gt;?
Everything you want to know about generics in Go: https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/edit
I had tried that, but a lot of tools seem to end up getting confused anyway.
Agreed, but it didn't fit in the width of the post 
In more words, sure.
neovim + vim-go
I'm happy that in the spirit of Go this utility has a name that's not clashing with anything generic, like say the name of a country... :D
Yeah, just because there's no such label in the Go repository yet... Oh wait! There is! https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+label%3AGo2 Now please stop trolling and Go :)
Good thing we dodged that bullet, huh?
Your recommendation is counterintuitive imho. If you want to start with a new language then an IDE makes the most sense as it helps you out doing the things that you want to do. And the editors you've suggested, while they might be good, when added with all the other functionality from plugins (or .rc files, yaaay!) you get a half-baked IDE. To me a half-baked solution is worst than a proper solution.
If you are already using a IDE from JetBrains, you might want to look into that + the Go plugin for IntelliJ platform https://github.com/go-lang-plugin-org/go-lang-idea-plugin#pre-release-builds (it also works with Android Studio). Have fun!
&gt; Since the Go release numbers are getting larger, people pretend that Go 2 could happen in the next two years. There's no correlation between the magnitude of minor version numbers and the likelihood of a version 2.
Gotta ask about pushing code of conduct on the community, since it's Gerrand who created the thread.
any sane person wanting performance would still choose java over go. All the talk of go having more power is over shadowed by dismal performance. It might take at maximum a few tens of hours to learn go, while go is years behind java in performance. Also, all the talk about go being concise, and less verbose is just hyperbole. I'm a consultant and I have tried to push go many times. I was removed from a team on a project, and they went forward with porting the codebase that was in perl, python, java to just java. The project was mostly perl and very little java, there was really no benefit other than performance, and that was enough. Despite the perceived performance benefits given by the language it just doesnt seem to materialize in production. 
Ive built many spa webs apps with restful backends. just go as the backend and js, and a few js frameworks as a frontend.
As I've mentioned, I personally think that using an IDE when someone starts learning Go creates a need for it and does not allow the developer to learn some internals and tooling of the language. Maybe I didn't make it clear enough but I believe that it's best to start as simple as possible, (say a text editor, git and console) and slowly add stuff as experience is gained. (Did you watch the videos I linked?) This will allow the new gopher to develop an in-depth knowledge (and appreciation) of the language and it's tooling whereas the IDE will hide all that. As the goal of the new gopher is to learn, I believe it's a clear win for the editor. I could even argue that starting with an IDE is counter-intuitive (Go is not Java). Of course that's just my opinion and we don't have to agree.
Personally I wish that *os.File didn't have a finalizer that closed the handle. I feel that it hides buggy code (i.e. code that forgot a Close) and harms code like this.
&gt; soon™
&gt; Go 2 could happen in the next two years. Definitely not.
Where is Go heading with the future releases 1.7... 3.X? With previous versions, the GC has approved a lot but is it a priority also in next versions?
I'm updated test: ab -&gt; wrk Go: 1.5 -&gt; 1.6rc2, and updated fasthttp node.js -&gt; 0.10.2 -&gt; 5.6.0 size of http response did the same test length: ~10sec -&gt; 60 sec nginx is old - 1.2.1 (debian wheezy)
I've been on a few teams where I tried to push go. Most ended badly for go, but I do get to code in go from time to time. I gave an example where I was actually removed from a team for trying to push go over java. I was the lead... I am saying there was resistance to the hyperbole surrounding the concise and minimalist approach of the syntax of go, the power gained through design decisions(pointers, receivers, deeply integrated concurrency like gorountines and channels), and advantages of compile vs interpreted. In the project I gave as my worst experience pushing go most of the code written in go to compete with the java parts already in production were vetted by various go communities as 'idiomatic go' and failed miserably. Maybe things have changed for go since then, even if it did I don't have access to the codebase, so I will never know. I just know at that time I shouldn't have pushed go as much as I did. My experience is that go is more known than what most would believe-just very few get to use it professionally. Go will get its day to bask in glory. 
ok, node.js updated
ok, im install Go 1.6rc2 and use wrk
I don't blame your team; I resist hyperbole as well. I don't find it to be a very good tactic for persuading people. It doesn't sound Go-specific. Perhaps you're a poor salesman (like me), or your team was biased toward the tools they knew? It's really hard to conclude anything about Go (or its performance, in particular) based on this one data point...
 4 Why we switched from net/http client to [fasthttp client](https://godoc.org/github.com/valyala/fasthttp#Client) - https://medium.com/@valyala/net-http-client-has-the-following-additional-limitations-318ac870ce9d :)
I do have a question and it's not about generics. :)
Very cool!
Ruby was the one I knew off the top of my head that won't collect the object until it goes out of scope. Also any language that uses reference counting instead of a garbage collector.
It came up before [in the context of Fd() and a bug similar to OP's](https://github.com/golang/go/issues/9046). The current behaviour isn't going to change, though.
hehe Yeah I know I discard all errors :P First of all i want to implement all the pending stuff, we'll discuss error handling strategy later when you get time :) I already have a popup text by the notifications which I already show, I have one problem though, I want to first implement AJAX in everything
Does Ruby guarantee this behavior? Even a reference counting implementation can be (theoretically) smart enough and free variables earlier. The Go spec https://golang.org/ref/spec only mentions that Go is garbage collected language however GC implementation and behavior are completely unspecified.
It can happen very reliably when you restart parts of data centers. Here is how to reproduce it: Start a server S on on computer A and connect to it from client C on computer B. Turn off networking on A. S gets error on connection and close it. There is no network to send the tcp close pocket so C still thinks the connection is open. When you turn networking back on A, S forgot C is still connected. Alternatively, you can restart S when a router in between is down, there for also losing a close pocket that C does not expect. If C is waiting for a read, then you have a hang connection until tcp keepalive tells C otherwise. This can be hours on system default settings.
VS code + Go plugin is amazing, you have gofmt|golint|goimports on save, ctrl+P let's you jump to functions/files without having to scroll down and search functions in some file, go through each file and find the function
I'd like to ask about compilation times. I read on multiple places that the C compiler was partially transposed to Go by an automatic translator and that, though it works, it is not really efficient. Where does fixing this stands on the roadmap? I'd like to see if I can help. What are the parts which needs to be rewritten manually?
Are package management in the competence of the core team or more the community ?
good job
Avoiding finalizers whenever possible is good practice. If a finalizer can't be avoid then limiting what they do is the next best option. As this example shows finalizers can introduce non-deterministic asynchronous behavior. The idiomatic solution of always pairing an open with a close seems bang on. This pairing leaves the finalizer with nothing to do. 
Today I started to jump up and down when I saw this from linter, short.go:36:6: type name will be used as short.ShortSite by other packages, and that stutters; consider calling this Site I had picked ShortSite for my "struct" and it was telling me it is not a nice name! 
A Newsletter on the Go Programming Language packed full of useful golang tutorials and tips!
I would just run `screen` by hand, and not in your program. screen #start screen session ./mygoprogram #start your program (Close the window or ctrl-A D to disconnect) screen -r #reconnect
Well the program doesn't need to run in the screen. The program is for starting a jar file in a screen. It kind of need to be this way. I have been looking at tmux however, and it looks like other go programs have been built for attaching to a tmux session. If that's the case, that may be my solution. I'll be experimenting with it tonight.
Thanks, I'm glad. I was like you, written my own mappers/marshaller for struct manipulation. Then I thought to create a reusable methods as library to meet Go development possible scenarios. I hope you had a chance to have a look 'go-model' library. Could you please share your expertise, so we can improve go-model library? 
Thank you for the blog post, it was a great read and it helped me better understand the problem.
Thank you, I will look into that. 
&gt; I do not see a central immutable registry of versioned snapshots of Go code happening. Maybe, maybe not. Dismissing possibilities out of hand because of... &gt; It is antithetical to the Go ethos. ...rather difficult to qualify assertions isn't really conducive to solution-finding, though. My point here was that &gt; Nor do I believe the vast majority of developers will adopt sane version management any time soon. Certainly not without help and coordination - hence my action plan. And maybe that will fail, too, but there is literally no way to know but to try. &gt; CF Dave Cheney's tilt at a just RECOMMENDING versioning. I think we have different takes on why that didn't go through. &gt; Until and unless..., yeah, I'll keep a copy. Even if it is gone upstream and I am "on my own", my build doesn't break and I know that the version I tested against is still available. By all means. But it seems like you're missing a core point: **At no point did my article suggest taking away your capability to commit deps.** All it argues is that committing vendor dirs is harmful to *sharing*, and that a proper PDM will need to work around that. Maybe you're already clear on that, and just trying to emphasize how important it is that you retain this ability. Sure, I get it, and I hear you. But, for me at least, it would be helpful to know if you have issues with anything the piece says is a *requirement*.
It's certainly true that if the minor version numbers were getting smaller, Go 2 would be less likely. :-) 
Doesn't vim/emacs/gedit/atom/sublime already do remote editing natively. I do admit this is a nice exercise on remote handling and not all editors support this so it may be very useful(or you could remote edit files using ed)
Any day now. 
The site looks neat, but there's already [GolangWeekly](golangweekly.com). This seems redundant, but maybe you had something different in mind?
Both. It's definitely a topic we can talk about.
great linter, isn't it? :)
Why do you md5 sum the URL? It seems it'd be much more effective to generate a random token. var buf [32]byte _, err := rand.Read(buf[:]) if err != nil { ... } return base64.URLEncoding.EncodeToString(buf[:]) Something like that would nullify the risk of collisions.
Gorilla's context package is excellent. You might start there. Also, check out http://go-bootstrap.io/ Cool tool that lets you generate some code for your project. Whether you use any of the generated code doesn't matter. You'll learn a lot just from reading through the approaches used there.
I agree with the points made by the article, but Doer is IMHO a bad name for the proposed interface. `Do` method is clearly HTTP specific, so having it mentioned by the name of the interface or the package makes its purpose clearer. `http.Doer` is ok, however a better name for `foobar.Doer` could be `foobar.HttpClient`.
md5 is reproducible so I won't save the same link twice. I am indexing md5s give are saved. :68 :86 I can use random and index URLs but, normally URls are longer than md5. Besides, for save I didn't care about performance much as it is a rare event. get must be fast.
Of course! Working on large projects makes you appreciate: Go's interestingly opinionated linter, gofmt (one for all), godocs! (my favourite), standard unit tests (specially Example and Benchmark), just 25 keyword for such a powerful language. For code maintenance these are fantastic. Of course it is plenty fast, have a simple concurrency model, compiles fast, and in practice is one of most portable codes: GOOS=linux GOARCH=amd64 go build main.go done :), ... 
as long as it helps me learn Golang, I'm all for it. I'll take any free resource I can get to learn Go. 
Isn't the retry angle obsolete, given https://github.com/golang/go/issues/4677 ?
This is the best tl;dr I could make, [original](http://thenextweb.com/apps/2016/02/16/ibm-has-just-open-sourced-44000-lines-of-blockchain-code-on-github/) reduced by 83%. (I'm a bot) ***** &gt; Whether transparent, decentralized database technologies like blockchain become a tool for the masses or the few is still yet to be decided. &gt; IBM&amp;#039;s clearly got a bit of a head start on this and is now also offering &amp;#039;blockchain as a service&amp;#039; for developers to use within the IBM Cloud via a service called Bluemix, with API infrastructure for plugging in outside data. &gt; Perhaps legitimacy starts with big brand technology companies getting involved, but &amp;#039;blockchain as a service&amp;#039; doesn&amp;#039;t exactly fit with the potential that others see, as Scott explains, for &amp;quot;Large-scale egalitarian self-organization." ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/466aan/ibm_has_just_opensourced_44000_lines_of/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 1.6, ~37042 tl;drs so far.") | [Theory](http://np.reddit.com/r/autotldr/comments/31bfht/theory_autotldr_concept/) | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PMs and comment replies are read by the bot admin, constructive feedback is welcome.") | *Top* *keywords*: **blockchain**^#1 **IBM**^#2 **technology**^#3 **contract**^#4 **Bitcoin**^#5 
&gt; Currently shells out to mv for moving files because mv handles cross-partition moves unlike os.Rename. This is downright scary code. Not atomic -&gt; not safe.
It seems there's a predictable filename in `/tmp` if you can trick it to retry. This is not code friends let friends run as root.
Adding Caddy to the mix would be interesting. http://caddyserver.com 
Practically speaking it's only one remaining, as one of them is a trivial change (remove the "DRAFT" word from the doc) and says it should only be done immediately before release. In fact, the only remaining change is fairly trivial in and of itself, form my understanding.
&gt; absolutely no examples of anything I myself wrote several examples so there *really* *are* examples. Ranting is not helpful.
I like the idea. The interface also sort of exists in the `http` package. It's called [`http.RoundTripper`](https://godoc.org/net/http#RoundTripper)
I really hope the go devs are not adherents to [valve time](https://developer.valvesoftware.com/wiki/Valve_Time) 
Cant' understand what the other one is. Something related to gerrit code review tool.
https://golang.org/pkg/os/exec/#Cmd.CombinedOutput will report better
Can you paste your code, I probably have an idea how to fix it.
That is not the same thing, that's the lower-level interface (implemented by http.Transport) that I mention in the article, it is not meant to modify the request in any way (except for consuming the body), and it is called by `Do` eventually. But yeah, other than the method name, the signature is the same (which may be why you say "sort of exists").
&gt; methods that are some of the first things you learn diving into golang (Unmarshal, readall). I never learned that things and never needed them? If you don't work with JSON stuff do you even need Unmarshal?
Eclipse with Goclipse-Plugin.
I did cmd.stdin = os.stdin for a while, along with err and out, but I didn't seem to notice it DOING anything.
You can omit unimportant code from the slide using a regex pattern along with ".play" directive. // START OMIT package main import ( "fmt" "time" ) // END OMIT In the slide: .play map_unsafe.go /START OMIT/,/END OMIT/ 
Hey, fwiw Go conventions prefer CamelCase over UGLY_CASE for exported symbols, including constants. 
The interface mandates that all embedded interfaces and methods must be present in each implementation. A sum type can basically be only one: https://en.wikipedia.org/wiki/Tagged_union Your very example is rather unusable, because any type you create would have to implement both interfaces (in your case), and each one would be virtually identical, save for the type signature of its one method.
Awesome. Thank you!
0 open. :)
&gt; I desperately WANT progress here (the state of the art is kind of a joke), but I am not hopefully that "the community" will be keen on much of what I (and you, it seems) think of as forward progress. FWIW, I hear a lot, lot of this in response to the piece. That is, desire for something better, but disbelief and disempowerment wrt implementation. Part of my goal in writing it was to give us something meaty to rally around. My hunch is, if we can make even a bit of unified, sane-seeming progress, we might suddenly find ourselves with a whole lot more momentum than anyone expected possible.
There is still stuff they're working on I believe https://groups.google.com/forum/m/#!topic/golang-dev/sk0mQmc2q1I
Thanks for the link. Those ( [14337](https://github.com/golang/go/issues/14337), [14331](https://github.com/golang/go/issues/14331) ) were on the GitHub issue tracker originally referenced and closed. 
Thanks. I was afraid someone would comment on that. I've never been a fan of that official project layout, makes things feel too cluttered in the root directory for me. But I'll go fix it just for you :D
Think of it this way: shell is a programming language, the syntax for calling a function is `funcname arg1 arg2 arg3` and if you need spaces in one of your arguments you need to either quote them (with \\) or quote them (which is similar to a raw string literal in go, i.e. it ignores shell meta-characters like spaces). Functions are then programs and above function call translates into the syscall (roughly) `execl(funcname, funcname, arg1, arg2, arg3)` (the first funcname is the program to execute and the second one is argv[0], which usually contains the name of the program). Thus, your line of shell code creates the call `execl("tmux", "tmux", "new", "-s", "tmux-session-name", "java -jar server.jar)`. Go is a translation of that. This is the general difference between using a shell-like process creation (like with `system` in C) and an exec-like process creation. You never want to use the former and always the latter, as it is a) simpler (because you don't have to worry about escaping stuff) and b) safer and more secure (because it is pretty darn hard to safely escape arbitrary strings).
I followed all the way up to tmux tmux. Where is the second one coming from?
The process gets passed an array of arguments (in C usually called argv, in go it's in os.Args). By convention, the first one (index 0) is the name of the binary being called (though that's just a convention, it's not actually enforced. Both the shell and go's exec package follow it, though). That is why you pass it twice: The first one is the binary to be executed (this *must* be the binary name, because the syscall needs to find it to execute it). The following arguments are the arguments passed in argv, so you start it with the binary name (following convention). In go, if you do `exec.Command`, it will [automatically populate argv appropriately](https://golang.org/src/os/exec/exec.go#L125). All of this becomes much clearer once you actually did some systems programming :)
It's about time! I've only been visiting the site, the github repo, and every developer's blog, every few hours, for the last two and half weeks for some kind of hint. Still wish they'd have releases with xz compression instead of or in addition to gzip (kernel.org moved to xz and never looked back) 
Good news)
What problem would that solve? 
You need to go with that layout if you're writing a library (meaning no `main` function). If you're writing an app, you can do whatever you want. 
Yet the code calls `/bin/mv` purely to get a cross-filesystem copy+delete.
Congrats on the release! Repost from [here](https://news.ycombinator.com/item?id=11122023) I've really enjoyed the time I've spent with Go but feel like the state of dependency management has kept me away. Am I being stubborn in my longing for an npm, Ruby Gems, or pip? Is there a reason why one of these hasn't emerged/been adopted by the community? (I'm aware of the 1.5 experiment with vendoring.) Semver and pinning versions has always just made sense to me. I can easily adopt new features and fixes automatically without worrying about things breaking. How does the community feel this far along?
I don't use cgo very often (if ever), although I can see why it's useful/necessary. Still, is there a reason CGO_ENABLED=0 isn't the default value? Or, in other words, what are the disadvantages of a truly static Go binary?
what is mock pkg?
What's the plan around improving crypto/ssl performance in Go? There was the [interesting blog post from Cloudflare](https://blog.cloudflare.com/go-crypto-bridging-the-performance-gap/) in May last year, and a bunch of discussion about the conflicting licenses involved in the code. I fully understand why you can't import it as is. From the email thread associated with that blog post it looks like some improvements have been added, is there a specific plan or resources around adding further improvements? The performance bottlenecks as-is, even on 1.6rc2, are certainly something I keep running in to, in ways that are non-trivial to use, say [SpaceMonkey's openssl wrapper](https://godoc.org/github.com/spacemonkeygo/openssl).
This is issue 6853: https://github.com/golang/go/issues/6853
Thanks for all the work on Go 1.6. What do you think are the most helpful areas external contributors could help with on upcoming versions of Go, for different levels of contributor (beginner, intermediate, advanced)? Are there any areas which are neglected at present and would benefit from external help?
I wonder why the gopher has those two big teeth ;)
Idea + Go-plugin (nightly version)
What is the benefit of the SSA compiler that golang-dev is always talking about for a future release?
[Go by Example](https://gobyexample.com/) awesome resource for learning go
Although I am used to write `printf` debugged code and unit tests for most functions, a proper debugger and some first class IDE love would attract more people. In my work, the people who wants to play safe avoids using Go even if it suits the job better than most other viable alternatives. Are there any plans for "official" debugging tools and IDEs? I know neither Java/C/Python has official IDEs, but even when we transition in to go1.5-&gt;go1.6, you have to manually configure the gocode to include vendored packages for better code completion etc, so there becomes a delay. 
Congrats on the release! The move to rewrite the compiler in Go itself initially led to an increase in compile times in Go 1.5. The expectation was that this would be gradually reclaimed as the Go codebase would be optimized. Can you comment on how far along this reclaiming effort is as of 1.6 and are there any big wins on the horizon for the 1.7 roadmap?
I'm interested in networking and networking stacks as a whole. I like to look at how various languages implement things to develop a holistic understanding for what it takes to make a massive endeavor like building a networking stack turn into usable and efficient code. I've enjoyed looking over a lot of the source in net/http, and it's been a real pleasure to see the approach taken here. I have to ask ... what's the rationale for [this](https://github.com/golang/go/blob/master/src/net/http/client.go#L427) function? I gotta say, it's pretty unintuitive that [the line of code that actually does the request](https://github.com/golang/go/blob/master/src/net/http/client.go#L475) is in the middle of a `for redirect := 0; ; redirect++ ` loop. Is it related to efficiency?
Complex name resolution environments like nis or ldap won't work. No os/user. Pretty minor things in my book. 
An xz archive of Go takes about 2 seconds to decompress and you can untar it with the exact same command as a tar.gz file. Modern versions of tar don't require the filter on the command line to decompress, therefore it's still just: tar -xf somefile.tar.xz
It really increases my compilation times and would be frustrating to have a slow compilation while developing. 
Tools like Delve and goimports aren't tied to the Go release cycle, so there improvements can be made even before 1.7.
No misunderstanding, I was just trying to explain why you need to pass the java string as a single string if you want the equivalent invocation to your shell-line. Your problem is [here](https://github.com/nathanpaulyoung/msct/blob/master/msct.go#L142). As I explained, the quotation marks in your shell-line aren't part of the exec-call, but they are part of the shell programming language syntax. You need to pass that as one argument, approximately like this: args = append(args, fmt.Sprintf("java -server -ms%dM -Xmx%dM %s -jar %s", ram, ram, strings.Join(javaParamsArray, " "), fullpath)) (untested, of course. And you probably want that more readable). I tried to explain that your shell-line `tmux new -s tmux-session-name 'java -jar server.jar'` is pretty much doing exec call: execl("tmux", "tmux", "new", "-s", "tmux-session-name", "java -jar server.jar") Note how there are no single-quotes in that last argument. They are part of the shell language. The go-equivalent would be exec.Command("tmux", "new", "-s", "tmux-session-name", "java -jar server.jar") Your code boils down to exec.Command("tmux", "new", "-s", "tmux-session-name", "'java -jar server.jar'") (just with more arguments to java), which will try to execute `'java` instead of `java`.
One benefit would be that SSA is much easier to optimize in theory. 
yay!
[gopkg.in](http://labix.org/gopkg.in) is commonly used for libraries. There are plenty of tools to manage vendoring (which is now enabled by default in 1.6) such as [glide](https://github.com/Masterminds/glide). Edit, as for npm/gems/pip, there are plenty of problems with those systems which I'm sure plenty of people will go into detail about.
Better run-time performance.
There's a Go plugin for IntelliJ Platform (every IDE from JetBrains) which is getting better and better each day. Just try it out. https://github.com/go-lang-plugin-org/go-lang-idea-plugin It has everything you are looking for in terms of debugging and IDE (even if it's not official from the Go team, which I don't think it should be anyway)
They have said time and time again, this isn't happening.
I'm sure the gopher wonders too!
What is something you'd love to see in Go, but know is impossible until Go 2?
Congrats on the release! In your [6 years post](http://blog.golang.org/6years) you mentioned: &gt; Early next year we will release more improvements in Go 1.6, including ... an official package vendoring mechanism ... I was hoping that this went beyond the `GO15VENDOREXPERIMENT` and actually included an official package management tool. Are there any future plans to work towards this?
Dave Cheney put together a lot of good resources: http://dave.cheney.net/resources-for-new-go-programmers
If you don't use cgo, it shouldn't significantly increase your build time. What does `go build -x` say?
Any chance someone will fix https://github.com/golang/go/issues/9869 ? the resulting heap fragmentation is an issue when you have a model similar to the golang http server which forks a goroutine per request. if you subsequently create a bunch of goroutines eventually the heap can become quite fragmented. There are other ways to model the code but this seems like an obvious candidate for fixing in 1.7 (or at least mitigating - prevent fragmentation by using a dedicated allocator for the structures). btw, thank you for Go. if you're in mountain view there are a number of people who would be happy to buy you guys a beer.
Several of CloudFlare's crypto optimizations have landed for Go 1.6, but based on this issue, there is one that still has an outstanding licensing issue. https://github.com/cloudflare/go/issues/8
There are a lot of open issues at https://golang.org/issue. Fixing those, or determining that they can be closed, would be very helpful. The documentation is good and steadily improving, but where you see problems please send fixes or open issues. At the more advanced level, there is plenty of room for improvement in the compiler, and this is an area where many people can usefully contribute. For example, somebody asked about debug info above--this is mostly a compiler and linker issue.
I have loved reading the sleuthing &amp; design analyses written in emails and CL summaries by rsc, khr, dvyukov, bradfitz, et al, over the years. It's been a real education. I remember the "simpler, faster GC" cycle was a particularly interesting and intense session. Any especially interesting design/debugging stories, recent or old, you might share? I figure some never made it to the mailing lists but perhaps circulated in smaller groups. 
Hey Go Team, Gophers Congrats on the 1.6 release! One of Go developers said sometime ago on Twitter [0] you're developing some tooling for context.Context - is this still the case? Will it be publicly available? [0] https://twitter.com/Sajma/status/494161985219465217
[removed]
Whats wrong with using interface{} in all your specialized containers? /s
when will reduced binary size be a priority? can the team set an explicit goal for sample programs and try to work towards it? this prevents Go from being used in smaller ARM-based systems
If I may add to this, bundling musl statically is a good way to have a fully static binary without all the bloat that glibc adds. It also prepares your binary for running in a bare Alpine Linux docker container.
Too many ways to declare a variable. I don't like the shadowing rules, too subtle. 
Yup.
Yes, see the "[Passing target language objects to Go](https://godoc.org/golang.org/x/mobile/cmd/gobind#hdr-Passing_target_language_objects_to_Go)" section in the docs for gobind. Location would be a nice addition to x/mobile/exp/sensor (or perhaps in a separate package).
I think it could be very cool if codewalks could be read from somewhere else but GOROOT (so that I can write codewalks on how to use my library and people can use them easily). Though I agree that they are underutilized :)
What do you think of Gomobile? Will there be some focus on it? It feels like Hannah and David are most of the time on their own. Thank you for Go
Musl can't handle complex network resolution scenarios, like nis and ldap, just like Go. 
https://golang.org/doc/faq#generics
In addition to the built in coverage tool, https://github.com/smartystreets/goconvey is good for testing, especially with the way their UI is set up. You can easily see what lines have been tested or not.
Great to know -- wasn't aware of those quirks on darwin. Thanks for the detailed answer!
These are fair questions, and we don't have good answers for them. Most people working in Go seem to only encounter these problems in a very small form (e.g., the sort.Sort interface) where the code copying, while slightly annoying, is no big deal. That is, the copied code is small, trivial to write, and clearly correct. A few people do encounter issues where code copying is larger scale and is not clearly correct, meaning that bugs may have to be fixed in multiple places. We don't have a good solution for these cases. it's a complicated space. If we can figure it out, we will. Many people have proposed solutions, but none have been wholly satisfactory. There is an official code generation tool: `go generate`. There are code generation tools that do what you suggest, but I don't know how widely they are used. At this point we aren't planning to bring any into the official repository, though it's possible that will change in the future.
How small? 
One way to help triage Go issues is to sign up for the third-party tool CodeTriage. You can get one issue via email each day to take a look at. http://www.codetriage.com/golang/go
Done: https://github.com/golang/go/issues/14369 :)
[Go can find CPU bugs](https://github.com/golang/go/issues/13854) (ok, this bug was know by the manufacturer, so it wasn't _discovered_ by Go, but still, it can find them!).
Is there a pure Go version for those? And if so, can they be enabled when linking musl?
[Visual Studio Code](https://code.visualstudio.com/) is cross-platform and has a very good Go plugin with many IDE-like features.
Looks like delve recently added Windows support! https://github.com/derekparker/delve/wiki/Building#windows Sorry if I shouldn't have distracted from the discussion, but this is good news for people using windows!
The debugging issues on the compiler side will be affected by the new SSA compiler that may become part of 1.7. I don't know that anything will be noticeably better in 1.7, but I think we will be in a better position for improvements in 1.8. As you know this has not been a priority of the core Go team. We are very much aware of the issue, but the fast compilation time in Go means that we have mostly gotten accustomed to a build/log/run cycle while working, rather than a build/debug/run cycle. So while I would certainly like to see this get better, and I'd be happy to support anybody doing the work via code reviews and the like, I can't promise that it will get better.
How involved are the original creators of Go today? If absent, do you feel the original philosophy is still being well-guarded in practice?
Are you referring to alternative routers such as https://github.com/julienschmidt/httprouter?
Howdy Golang team! Thanks for 1.6. When I was debugging the http2 library back when it was homed on github, it was hard to test because the httptest.NewRecorder() was unable to record http2. Has this changed? What is the canonical way to record http2 for play back in tests? edit: https://github.com/golang/net/blob/master/http2/server_test.go Thanks again!
What editors do the Go team use when writing Go? I used to be staunchly anti-IDE, but I've come around to the idea nowadays as I've gotten older, haven't seemed to be able to find a decent Go IDE though. 
Hi I'm very happy to see 1.6 out of the door, especially since its support for mips64 teases a future mips32 port in the works (hopefully). As a user of the language, I've wanted to ask, what's your opinions, and technical considerations regarding adding support for sum types. Strictly speaking as a user, and please correct me if I'm wrong, this seems like one of these fruit that are sort-of hanging low. It sort of looks like the implementation would have something in common with interfaces, since in usage they might have similar points, and be useful in lots of places. For example, in another thread I was thinking that such an addition would allow adding support for net/context to the http.Handler in a backwards compatible way: type handler sum { Handler, ContextHandler, } func Handle(pattern string, h handler) { switch hs := h.(type) { case Handler: handleHandler(hs) case ContextHandler: handleContextHandler(hs) } } // Or even, similar to anon structs func Handle(pattern string, h sum { Handler, ContextHandler }) { .... } To me it seems similar to the empty interfaces, in that you have to type assert it in order to do anything really useful, but unlike it, the compiler will know, much like other interfaces, what other types can be used in its place and fail if you pass something which your are not supposed to. Again, since I'm just a user, I might have totally misjudged this, so I'd love to hear your thoughts. 
That redirect loop has been there since the first version of the net/http client in https://github.com/golang/go/commit/f315fb3d56746ddd14dbfeeea106564349bb5ce9 . I think it's just developed from there as features have been added.
(1) Citation needed. (2) Check the improvements made to the linker in Go 1.5: https://golang.org/doc/go1.5#link
Shell script, because it's easy to compose things out of smaller things.
I wish that in for x := range v { wg.Add(1) go func() { defer wg.Done() foo(x) }() } `x` would be scoped to the block, rather than to the whole `for` statement, so it would Just Work. This is the most common mistake I still regularly make in quick one-off programs.
The [Summary of Go Generics](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/edit#) document contains many helpful insights into why Generics are not in Go. Russ' comment: "The Go team is not against generics per se, only against doing things that are not well understood and/or don't work well with Go." pretty much summarizes the current situation. I, for one, would love to see generics be in Go, but personally I'm not terribly bothered by the lack of generics. I would much rather see a potentially far better implementation in the future, than one today that has many of the problems with C++ or Java generics (they make for great difficult exam questions, but terrible developer experience).
&gt; I'm very happy to see 1.6 out of the door, especially since its support for mips64 teases a future mips32 port in the works (hopefully). In fact the low-level support for mips, including the compiler, already supports mips32. It would be easy enough to add runtime support for mips32. 
Congrats on the release. Is there any chance to create AndroidGo without Java? Thank you all.
If you have repeatedly to write the same algorithm against different types check whether the commonality of the types can be expressed in an interface and then write your algorithm against this interface. Work hard to reduce the number of functions in the interface. The smaller the interface the more types can support it.
The cgo pointer passing proposal, at https://github.com/golang/proposal/blob/master/design/12416-cgo-pointers.md , is intended to be as reliable as the Go 1 compatibility promise (see the Compatibility section). I'm not sure quite how to add the cgo tool itself to the Go 1 promise, as anything that uses cgo obviously depends on things that are not written in Go. I would encourage you to open an issue about this so that we can try to figure it out at some point.
I recently finished Antony Beevor's Stalingrad and found it changed my view about a number of things. I'm currently reading Andrea Wulf's biography of Alexander von Humboldt and thoroughly enjoying it.
That would be quick and useful. I don't disagree. Although I don't think the hacky way of: http://play.golang.org/p/ix7ZctBWdv (fulfilling an interface with blanks and wrapping non-local types) is unusable if it's important. Passing tests as part of your builds is also a good form of safety. One way or another, the type needs to be checked to use it if you want one thing capable of representing any of multiple things.
I think most people on the Go team use pretty no-frills editors. I use vim, and you can see my [vimrc here](https://github.com/broady/dotfiles/blob/master/vimrc). For work in the Google codebase, we have excellent tools available for code search, which is a large part of why IDEs are useful.
Some people on the Go team have sunk considerable time in producing generics proposals, but they've all had serious drawbacks. I'm hoping those proposals will be published at some point so people can see the depth of complexity that generics bring; it's almost always underestimated.
There have been a few more recent statements by Russ on the topic that I've found insightful and helpful to understand the issues: http://www.pl-enthusiast.net/2015/03/25/interview-with-gos-russ-cox-and-sameer-ajmani/ https://news.ycombinator.com/item?id=9622417
Yea I found this a bit confusing when I first started using Go. Although I see the design decisions around the two main ways to declare a variable. I'm in favor of just having the term 'var' since it makes it more clear, but it could be an issue with the way go does tuples.
Thanks! I don't follow development very closely and I've been wondering about this.
You might be interested in poking around inside https://go.googlesource.com/debug/.
Here is a set of common code review comments that have come up inside Google over the years: http://golang.org/wiki/CodeReviewComments
I'd prefer 100 gopher sized horses. They'll get in each other's way, so you'd really only be facing around 10-20 at a time.
I'm just going to comment that go/types itself is mainly Robert Griesemer's work, though Alan has written many tools around it, notably guru (formerly called Oracle).
Why do you say that? How would you write that loop instead, and why do you think analyzing its memory usage is more obvious / easier?
To me that feels like premature abstraction. But I find it hard to meaningfully talk about this stuff without concrete examples.
It's a known problem (obviously) but it hasn't seemed high priority, at least not to me. it's only a problem for a long-running program that has a one-time spike in the number of goroutines. If you regularly spike the number of goroutines, that memory is being used. I mean, I'd be happy to see it fixed, but is it really causing you trouble?
Unless you care about HTTP/2, this doesn't seem like a big release. I recompiled my go programs with no trouble. The binaries are marginally smaller, and run at pretty much the same speed. I'm looking forward to--hopefully--some improved code generation in 1.7 when they move to SSA. So, to me, the best thing about 1.6 is they can focus on 1.7 now!
If you'd want a different x for each iteration, in the most general case you'd need to heap-allocate new space for x for each iteration. In theory, for many cases like the simple one above, a sufficiently smart compiler might recognise the pattern and do without the extra allocations. But a sufficiently smart compiler is a synonym for no compiler. Plus even if it could do it sometimes, it would be hard for the programmer to instantly "see" what the compiler would do. A minor edit of the code might tip the compiler into allocating from the heap, etc. Better not to rely on compiler optimisations for judging the general memory and time characteristics of your program. 
Seconded. Go and shell are what I use most these days.
It's not necessary to give me credit for this :) If you really want to, my github account is Merovius.
The current scoping is consistent with scoping elsewhere. if x, err := func(); err != nil { // do something with err } else { // do something with x } But maybe range could behave differently in Go 2?
You can't run it on the very smallest embedded devices. Thermostats, sensor boards, keypads, etc.
I think the next step is to nail down the [vendor spec](https://github.com/kardianos/vendor-spec), a file format for describing dependencies. I'm personally thinking about tools that can help with the greater vendoring story, but I don't have anything specific to discuss about it at this time.
The GC has gotten even better too in this release
Feel free to file an issue for us to consider supporting xz downloads in the next release.
Hi I have another question for you guys, something which I have wondered for a while. How come built in types such as strings don't have methods, but instead there are functions for them in specialized packages such as 'strings'? Is this related to the 'type foo string' feature, and if so, how come the new types don't get these methods automatically, like an embedding type would?
[Rick Hudson gave a talk at GopherCon](https://www.youtube.com/watch?v=aiv1JOfMjm0) with details of how the GC works. At a high-level, Go's GC tries to do as much of the mark-and-sweep work concurrently while the Go program is running and only needs to stop-the-world at the end of the mark phase. Of course, there is no free lunch, so while Go 1.5+ has lower GC latency, it does so by trading a little of throughput. I highly recommend watching the video; it's a interesting talk.
Not yet, no.
It will never run on those devices, at least not until those devices start being at least 32bit, with MMUs, and with enough physical memory. It has little to do with binary size, and more with what Go expects from the environment. On the other hand, binary size is a concern on larger, ARM+Linux based embedded computers with little flash. 
Go is an imperative language. Yes, it has first-class functions, but many imperative languages do (Objective-C blocks, Java 8 lambdas). That doesn't make them functional languages. The style of code is quite different, and I don't expect Go will ever appeal to someone who prefers Haskell's style. Here is an example of implementing an algorithm in Go and Elixir. They are very different languages that work best for very different styles of programming: https://gist.github.com/nathany/723e6057e5c7c70e5772
What is Google3?
Sure, we just try to minimize such incompatibilities.
He also gave another talk back in early December that goes into a little more detail and also has Go 1.6 numbers: http://www.infoq.com/presentations/go-gc-performance. 
I want to clarify that I don't think we've said that this isn't happening ever. We've said that it's hard. We've seen many proposals that were inadequate. If there is a good solution, we're willing to adopt it. But that is not a promise that a good solution exists or will be found.
As anecdotal evidence: I was tutoring an introductory algorithm class which was held in python. People using `in` on lists and accidentally making a linear algorithm quadratic (or similar) easily made up 80% of the mistakes I had to correct.
I though you were talking about a hypothetical Go 2 here. In Go 1, I usually use the first idiom `x := x`, I think it's more visible (visually) than a function parameter. The memory used either in the explicit Go 1, or in the implicit Go 2 is indeed the same. However, that's not the point. The point is that in Go 1 the cost is *explicit*, but in Go 2 it would be implicit (and very easy to be ignored). &gt; The compiler could easily reuse the same stack memory for each iteration in that case. It can, and it's a good thing, but it's a bad idea to *rely* on compiler optimisation for these kind of things. And while this example is trivial, for a more contrived example it's harder both for the compiler to optimise, and for the user to predict whether it will optimise or not. In fact it's easy for the user to forget that memory might need to be allocated at all. 
Helluw! I really like go, but i have wonder why you don't borrow more from exisiting syntax sugar, like decorators from Python. I think they would be a pretty nice addition to the current language. 
Before the migration to Github, I used to actually have a label on the issue tracker for cases where Go exposed OS bugs. There were a number of them, which surprised me for a while.
Thanks for the reply. Would be awesome to read those proposals. I'm sure there are a lot of people like me who have an interest in programming language design but don't have the opportunity to get our hands dirty with it very often or in much depth.
I would like to piggy back off this question. Are there any good examples of Code Reviews that someone looking to contribute to Go could look at and learn from?
Inside Google, most engineers work in one large shared source tree. There are more details in this post and its followups: http://google-engtools.blogspot.com/2011/06/build-in-cloud-accessing-source-code.html. The top-level directory of that shared source tree is named "google3/". It replaced the google2/ tree, which replaced the google/ tree. In general we try not to use Google-internal terminology like that outside Google, since people wouldn't know what we mean. But if you did hear one of us say google3, that's what we meant. 
I am not from the Go team but I will try to answer this question. One of the problems with this approach is that if you import "my/package#1.0" multiple times in your source code you will have to keep these imports in sync.
[removed]
I don't think that the distinction between `x := range` allocating and `x := x` allocating is significant enough to support your "mysterious allocation" argument. People already expect heap allocation when passing values into a goroutine, and clearly the author of such a loop would be expecting each goroutine to have its own `x`. FWIW, range *would* behave the way mdempsky describes, but we couldn't think of a way to migrate existing programs while proving they were correct. (This was before the release of Go 1.) With the benefit of hindsight, I think we should have invested more effort in cleaning up the design of range. 
Yes, that's what the decorators does. It's just sugar for the actual wrapper. But in my mind it's not as clean as the `@` syntax from Python.
Why does package log format the date with slashes rather than hyphens? Seems such an odd choice for a modern design. And makes it tedious when searching, e.g. in less(1) with /2016\\/02\\/18.
My grandfather taught me to code when I was a little kid, starting with BASIC on a TRS-80. In primary school, one of my friends gave me a copy of Turbo Pascal and showed me how to use it, which is how I learned to code properly. That friend now works a few desks away from me at Google. :-)
Let me modify the question a bit: &gt; If hypothetically you could only use programs written in 2 languages, which other language do you think would complement Go better and why? I would pick Rust and Go. Rust can replace all the buggy C code out there (looking at you, CVE-2015-7547, and so many similar ones) and I can then only write in Go, and stop worrying about buggy C code on my computers.
We saw some pretty good GC perf improvement during the last releases, what are the plans about GC for the future?
What plans on security in the language? Also will it at some point have more libraries to help with security tasks like python or ruby has?(yes I know they are scripting languages) but you can in C and is also compiled.
[removed]
&gt; How come built in types such as strings don't have methods, but instead there are functions for them in specialized packages such as 'strings'? If strings had built-in methods then those methods would need to be specified by the language spec. I think this was a smart move to keep the language spec small. It seems unnecessary to conflate built-in types with functionality that operates on those types. Programs can use the the `string` type without depending on the `strings` package. &gt; Is this related to the 'type foo string' feature, and if so, how come the new types don't get these methods automatically, like an embedding type would? I think you're saying that `S` in `type S T` doesn't get the methods of `T`, while the `Q` in `type Q struct { T }` does get `T`'s methods. One reason for this is that the `T` in `type S T` is really just an alias for the underlying concrete type of `T`, while in `type Q struct { T }` the `T` is actually part of the struct `Q`. The methods of `T` in the latter case are still operating on a type `T`, not some alias of that type.
What security tasks specifically are you thinking about?
I really wait for this for a while now. I would replace Qt with that and write even more Go. I think a lot of people are waiting for a proper cross-platform GUI solution.
Thanks Brad, yeah I helped track down why the demo server was leaking memory. I remember trying to replay frames and messing with streams and their states. I was trying my best to record the order of operation at certain points. At the time the codebase was in such a state of flux that there wasn't a clear way to do this. Keep in mind this was May 2015? What I was hoping was to dive into the tests for 1.6 and potentially see new tooling for this. Kind of like your h2i package that you shipped later. My perspective is that I'm sure there will be many a http2 client that is created that will break the spec. So having a way to record the entire state of the http2 client and server is where I am headed. Maybe you have already solved this? I've been out of the loop for a while because of a giant work project. Thanks for the response. 
I second the mention for [Delve](https://github.com/derekparker/delve). It's great work and is not widely enough known.
This is cool, thanks.
That doesn't help if you are trying to write something like `max()` 
In the release notes, it says &gt; Internally, the most significant change is that the parser is now hand-written instead of generated from yacc. Could you share the reasoning behind moving to a hand-written parser from yacc? Was it for better error messages? Performance? I have a soft spot for yacc :)
Yeah if I remember the requirements for it correctly yes. So optional depending on your use case, but I would still say GOPATH is important to set.
My first program was written with a friend, entirely on paper, based on a description of BASIC that we read somewhere. My first actual program was written in BASIC on a DECsystem-20 in 1977. Edited to add: my first experience with computers was when I was younger, when my mother would bring home stacks of punch cards from programs she wrote while getting her Ph.D. (in nutrition--why she had to write programs for that I don't know). She did not like to program, but I liked playing with the punch cards.
Right on! Thanks for clarifying.
[Issue 1242](https://github.com/golang/go/issues/1242) claims to be fixed. If you find that stripping a Go binary causes it to crash, you should certainly file an issue.
The fundamental change in Go 1.5 was that we replaced the stop-the-world garbage collector with a collector that does almost all of its work concurrently while the program runs. Rick's talks give a great overview of how that works. Go 1.6 is still using the same basic algorithm; the wins come from lots of smaller improvements. The garbage collector still pauses the program briefly at the beginning and end of each GC cycle for "sweep termination" and "mark termination," but we improved the behavior of these pauses. We improved the pause times for large heaps by fixing some tasks during these phases that were O(n) in the heap size (~5ms/GB). Some we eliminated entirely, while others we figured out how to do during the concurrent phase, so now there's nothing really proportional to the heap size happening during the pauses. We moved a few other less common sources of latency out of the pauses as well, and we're aware of a few others that we're planning to address in Go 1.7 (I got concurrent stack shrinking working just today :). We also "decentralized" the GC algorithm in Go 1.6. In 1.5, GC was coordinated by a single (internal) goroutine, though most of the work was done on worker goroutines. As a result, phase changes had to go through that coordinator, which meant they had to wait for the goroutine to get scheduled, which introduced delays. In Go 1.6, we've eliminated this coordinator; instead, any goroutine can perform a phase change the moment it detects that it's necessary. There were lots of other improvements, too. Take a look at my [Go 1.6 GC plan](https://docs.google.com/document/d/1kBx98ulj5V5M9Zdeamy7v6ofZXX3yPziAf0V27A64Mo/edit?usp=sharing) if you want more details. A lot of these algorithmic choices are possible because Go has a non-moving garbage collector. This is quite different from Java, which uses a moving collector. The trouble with a moving collector is that it's *really hard* to move objects while the program is running (though not impossible, see [Sapphire](http://dl.acm.org/citation.cfm?id=376810) and Azul). Since Go doesn't move objects, it can do much less during the stop-the-world phases (and doesn't need read barriers). For the next few releases, we're planning to focus on GC throughput to reduce the total CPU time spent in the garbage collector. We're attacking this on both the "microoptimization" level, by improving how quickly the garbage collector can scan memory, and the "macrooptimization" level, by reducing the amount of memory the garbage collector has to scan by focusing on areas of the heap that are more likely to be fruitful.
&gt; I gotta say, it's pretty unintuitive that the line of code that actually does the request is in the middle of a for redirect := 0; ; redirect++ loop. Why? Should it be at the beginning of the loop, in your opinion?
Got everything working! Thanks again so much for your help! Now I can move on to more features.
After months without smoke detectors (too lazy to put up the old ones, some of which I'd already gotten rid of), I bought the 2nd Gen models (https://nest.com/support/article/How-can-I-tell-which-Nest-Protect-I-have) because I'm ... an optimist? So far so good. It has a new sensor(s) apparently. This has nothing to do with Go, but we did say it was an AMAnything I guess. :)
How is the Go team organized inside Google? Can you talk a bit about how the team is structured? (There seem to be some clear divides between those working on GC, SSA, CGO, Mobile, etc.) How many paid Google employees are working on Google full-time? Part-time? 
Is pause-less GC a long term plan? 
There is a lot of code in the math package that looks to be based on the Cephes math library. Did you have to get special permission to include them? (Debian seemed to have written permission via email here: https://lists.debian.org/debian-legal/2004/12/msg00295.html) 
In addition to what /u/4ad said, there was some discussion of this in [issue #11801](https://github.com/golang/go/issues/11801). We did consider removing it, but were concerned about compatibility.
Congrats on the 1.6 release! * Even without generics, I feel like Go could use a few builtin "generic functions", that is general basic function algorithms operating on builtin generics (slices and maps). Common examples that I happen to rewrite often are: sum(), min(), max(), any(), all(), index() (aka search()), plus keys() and values() for maps. Many of these would actually make code significantly more easy to read and reason about (even for people watching Go code for the first time). Without necessarily discussing any of my examples, what is the stance of the Go maintainers on adding builtin functions like these to the language? It doesn't sound like they would make the language itself bigger (they don't affect the syntax), nor they can be said to hide complexity (I don't think people will assume that a function call is expected to necessarily be O(1)). * Has there ever been any significant discuss on adding operator overloading to Go, even just for math operations and just between instances of the same struct? The Go FAQ basically says "they're syntactic sugar so we can go without them". While this is true, they're a basic need for any kind of serious scientific work. Just a few days I had to write this monstrosity: `mirror.SubFixed(vtx.cy.AddFixed(vtx.cw)).MulFixed(dy).AddFixed(vy0)` which would be `(mirror - (vtx.cy + vtx.cw)) * dy + vy0` with operator overloading. 
A major missing piece here is good assembly language support for math/big and other crypto components on architectures other than x86. The ARM ecosystem on Go doesn't have enough assembly love, and significant performance improvements are possible. With the growing list of supported architectures (POWER, IBM z Systems, MIPS, etc.) this is ever more important. Legally unencumbered contributions welcome. And thanks to Cloudflare for their contributions so far. 
In addition to what Russ said, newer references since then: * google3 is defined by its build system. That build system is now open source: http://bazel.io/ * Video: "Why Google Stores Billions of Lines of Code in a Single Repository" https://www.youtube.com/watch?v=W71BTkUbdqE 
There is an FAQ entry on this topic: https://golang.org/doc/faq#variant_types The answer hasn't been touched in years, and is still accurate.
The roadmap for Go is largely in the open. You can see the milestones (https://github.com/golang/go/milestones). Generally we're only planning for the next release or two. There aren't any concrete plans for a "Go 2".
It is not. We think that for the vast majority of systems (though certainly not all), pauses in the millisecond range are quite acceptable, while pause-less GC would likely harm the throughput of the systems that don't need it and would certainly dramatically increase the complexity of the runtime.
The Go Blog "Go 1.6 is released" https://blog.golang.org/go1.6
The Go team is working with engineers at both Cloudflare and Intel to improve the performance of any of Go's tight loops that could benefit from more careful coding (often in assembly), including but not limited to the crypto packages. In fact on one microbenchmark recently we found that Go's for i := range x { x[i] = 0 } ran faster on at least one modern x86-64 Linux workstation than a C program calling glibc's memset. The Go compiler recognizes that pattern and calls its own memset, so really it's just a comparison of Go's memset assembly vs glibc's. And in this specific setup, Go's was faster, I suspect because machines change, and Intel engineers had tuned Go's more recently than they'd tuned glibc's. The point isn't that Go is always faster than glibc, which is certainly untrue, but rather that Go is moving toward the kind of optimization coverage you'd expect from a mature standard library. I'm not as confident as /u/dgryski that all Cloudflares optimization work is in, but we'll get there.
Would be awesome if someone with `brew`-fu could update https://github.com/Homebrew/homebrew/blob/master/Library/Formula/go.rb
Awesome. Thanks for all your work Austin!
My dad taught me to program when I was 5 or 6 (so 1985/1986). I'd always watched him program and was curious. He sat me down with a piece of paper at the dining room table and wrote a program on paper: 10 PRINT "HELLO" 20 GOTO 10 "What do you think that does?", he asked. "Print hello to the printer, forever?" "Well, no, it prints to the screen, not the printer. That would be LPRINT." "Why?" etc The computer was a homemade, bootleg Apple ][, with the ROM burned onto faulty memory chips with bits stuck high or low that my dad had got from a company's trash. If you have enough faulty chips, eventually you'll find one where the faulty bits are stuck high or low in the right places. Still amuses me. We later got a 386 and a family friend &amp; neighbor gave me Turbo C a few years later and I enjoyed being able to control the mouse and do better graphics than I could in BASIC. 
You still shouldn't be able to panic the kernel from userspace, stable ABI or not. :)
That still bothers me even without it triggering the race detector. I don't like passing things into a goroutine that aren't via argument or channel. It is entirely possible that I am nitpicking, though. edit: I also realize I am talking at right angles to the actual subject of this thread - making a copy for range. The per-iteration scoping would be counterintuitive to me because of the declaration appearing outside of the block. I'd also be worried about people writing for loops instead when trying to bum a few cycles. Though that might be mitigated by escape analysis... I think my thoughts on this is that it's weird, at least in my head. I don't know which case is weirder by default in most people's heads.
I seem to recall /u/robpike toying with idea of "operator methods" back in the day. But I don't think it was ever seriously designed (and thus never seriously considered). Rob might recall more.
Does it have Intellisense?
My wish list: - No bare `return`s - No `new` - `error` with `Source() error` method added for chaining - Various library clean ups: more consistency between archive and compress packages and their methods, various io.Reader/Writer helpers in one easy to find place instead of ioutil plus bufio plus bytes, various depreciations removed 
&gt; Why? Should it be at the beginning of the loop, in your opinion? I don't have a strong opinion about where it *should* be, at least not right now. At first glance the problem being solved is more nuanced than something that can just be broken into a simple set of steps like this: 1. Use the default, cached client 2. Build info needed for request 3. Call request and wait for response 4. Handle any redirects if necessary But perhaps it can be solved with a set of steps like that, and the current implementation simply uses a different approach that could be modified? Ultimately, I don't think I can make a call there. I'd have to dive into the code, talk with people who originally wrote it, and get all the context I can get before judging where something should be. That being said: I think that in terms of conceptual cleanliness, it's messy to have the *intial* request made inside of a loop that deals with making redirects, and short-circuit returning out of the enclosing function when there *isn't* a redirect. I think that my particular "use case", reading the code to see how things are done, is poorly addressed by the code as-is. Who knows, maybe I'll get excited enough about making an OSS contribution here.
Cool, thanks Andrew.
Thanks for your time. Exciting stuff coming for sure.
Probably never. That would be a fundamentally different language. https://golang.org/doc/faq#Is_Go_an_object-oriented_language
Looks like you added an editable link to that doc. You might want to change it to view only. 
I got a chemistry book for my seventh birthday (1991) that had a BASIC program in the back for classifying chemicals. It was my first window in to how a computer worked. I asked my dad to type it in for me, then I started asking lots of questions about how it worked (luckily he's a software engineer, so he could answer them), then I started writing my own little programs in BASIC, and then I was hooked. :) In fifth grade I read "Moving From QBasic To C." My teacher thought that was a very strange book report.
Internally, how do you advertise Go? I've heard Dart is gaining traction; and I'm sure some groups still reach for Java as a first choice. Do you go give talks? Is it completely organic? Are there standard internal wiki pages "Why you should choose Go."?
nice! ^_^
Are there any concrete plans to merge any of them into Go's stdlib? 
See my reply to [abcded1234234's question](https://www.reddit.com/r/golang/comments/46bd5h/ama_we_are_the_go_contributors_ask_us_anything/d03v5x2)
http://blog.golang.org/profiling-go-programs said "The goroutine blocking profile will be explained in a future post. Stay tuned." any news on this? every time i try to use the blocking profiler I get stuck. The original profiling article was great and I'ld love a followup. is the blocking profiler ready for widespread use?
Ooh! Are you going to have goroutines start picking up after themselves? Then they'll be convenient AND conscientious.
I more or less object on principle. I think that the only functions that should be builtin are those that can take special advantage of the runtime. That is true of all the current functions except, arguably, copy. (The append function uses its knowledge of the memory allocation routines to decide how large the make the slice when it needs to grow.)
I would like to see this but I'm not aware of anybody actively working on it. We have all the pieces but it's a bit tricky in that it requires some careful thought to make sure that everything works if the same package appears in both the main executable and the plugin.
/u/bradfitz may have more to say about database/sql. I know the driver story in particular is a bit of a weakness. It would be nice if it was clearer what the standard set is and if they were more clearly consistent. 
Pretty much. :) The idea is related to the existing idea of "thread-local heaps" (goroutine-local heaps in this case). Objects are initially allocated in a local heap and if they ever become reachable from another goroutine you reassign them to the global heap (which in some systems requires moving them, but doesn't in our design). Since pointers in the global heap can never point to objects in a local heap, you can collect a local heap without even thinking about the rest of the heap and---even better in a goroutine-per-request server---you can simply discard the local heap in bulk when a goroutine exits.
That's what I figured. Seems like that would be a small but helpful addition.
As I understand it Golang support for Chrome's NaCl was largely unchanged from v1.3 to v1.5, basically a compiled cli that Javascript would communicate without a "true" API integration. Has that changed in v1.6
Cool. I had a hunch that it would end up looking something like Pony's actor heaps.
Issue 13400 is meant as a meta-issue for all the known xml problems. I'd like to try to address them in the Go 1.7 cycle but it may get preempted. There are some deep problems, especially around name spaces, that do not have obvious fixes. (One of the root causes is that I saw there was a spec for name spaces and implemented it, naively assuming that real world usage respected the spec.) I hope that not every issue listed in #13400 is causing you problems. If one of them in particular is, please add details in a comment on the specific issue. If your problem isn't listed, please file a new issue against encoding/xml with details. More data is always helpful. Thanks. 
- What is the roadmap for [golang.org/x/mobile](https://golang.org/x/mobile)? There are a lot of great things in that package, and I have several experiments I've prototyped against it but I'm reluctant to commit until there is some clear future for the module. Will it ever be an officially supported module with some stability guarantees any time soon, or is it going to remain a testbed for experimental ideas for the foreseeable future? Any guidance on timeline and its intended future? - Any plans to go beyond just GL ES, when support is available? - Any plans to add windowing control when available (size, full screen, etc)? Possibly through some composition with x/exp/shiny? - Any plans for Vulkan? :D ([Some mentions here](https://github.com/golang/go/issues/11818#issuecomment-123697333), but I wonder if further planning materialized yet)
[This](https://github.com/thermokarst/jwt/blob/9d3638db601e499627271fe06273aab0aa67e7b3/jwt.go#L110) will panic in case of a malformed Authorization header that contains no spaces.
Releasenotes?
I dunno, with the right solution, this could be solved without waiting for Go 2. Some thinking in this vein: https://twitter.com/jbeda/status/698591536368345088
[removed]
In addition to shiny for GUI apps, you may also be interested in termbox for TUI apps like the termui graphs. https://github.com/nsf/termbox-go
Young programmer here, not even in College. As a programmer, how come I never feel like I know *enough*? More specifically, how can I improve my quick thinking skills and expand my knowledge of programming? 
my gc times were measurably better. Significantly lower, and very *very* consistent now.
sort works on slices of any type by operating on indices into the slice. maybe max() could do something similar?
with get stuck i mean i can't get it to work and people trying to help me are not sure what the problem could be. I've also received inconsistent advice on which frontends to use to analyze/view the results. recently i tried it again and the block profile just contained two lines: `--- contention: cycles/second=2300001382 ` any recommendations for a good howto/documentation? last time i'm pretty sure i followed the docs and still couldn't get it to work, admittedly that was a while ago, hopefully i'll have more luck this time. thanks. BTW agreed on "good" blocking vs "bad blocking" but even for channels it seems useful, i can usually find out quickly which channel blocks are okay and which are bad. thanks!
Two basic options are: - Use Angular/React/etc to develop a single-page app that communicates via JSON/XML with the back-end. - Use the templating engine to generate the page from the user query. There's a range construct that will loop over a slice of results to display each item. {{_,v:= range slice}} use the slice element {{end}} If there's not a lot of interaction on the page, a JS framework can be overkill. 
Could we get a little insight as to what to expect here?
Indeed: https://github.com/cloudflare/go/issues/5
I just want to thank all Go contributors, especially the people who designed the language. The only downside of Go, as I see it, is that now I hate every other language.
Will crypto/tls eventually support chacha20-poly1305?
Hi guys, Congratulations on achieving your milestone. Is there a plan for more integration with Android API and replace Java? (such as supports for Android Studio and anything Android related really)
https://www.reddit.com/r/golang/comments/46bd5h/ama_we_are_the_go_contributors_ask_us_anything/d049kqr
This is totally doable, and quite easily. In the server simply construct a list of results, and in your template range over the list you constructed. This will let your template handle any number of results. No JS or web sockets necessary. 
Most of the time when I was needing generics was for data structures . But I see that we will not need that if you provide a library or builtin to handle them nicely. 
Congrats on the release! Since this is ask me Anything... what music do you like to listen to? Do you listen to music during development?
https://golang.org/doc/go1.6
Are you playing Go (the game) ?
By that logic, you might as well get rid of compression altogether and just release uncompressed .tar files. But, I admit that this does not seem like a huge priority compared to improvements to go itself unless it's used as a chance to dogfood xz support in the standard library.
I understand the advantages of a non-moving garbage collector, but what are the drawbacks? Memory fragmentation for example? And how do you work around those drawbacks?
How many contributors are employed by Google ? And how many aren't ? (are you hiring ?)
Thank you for the reply. &gt; An alternative way to address the "I don't want to run those tests every time" question would be for the go command to do a better job caching test results, so that if you haven't modified any code that might affect the tests, a second "go test ./..." will not re-test them. Makes sense but then there's the question on how do I make caching for tests happen in build environments which I can't control (CircleCI, TravisCI, etc). That's why I think that before 1.7, positive, constructive feedback taken into account even if it means adding a flag for a really special case. While `go test $(go list ./... | grep -v /vendor/)` might be a workaround, I would still prefer `go test -no-vendor ./...` (or `go test --with-vendor ./...` to it.
I'm interested in this one too. Especially since it cuts directly at the latency-vs-throughput and interfacing with native code issues. Other than resolving memory fragmentation improved spatial locality of allocated objects and making allocations of new objects dirt-cheap are the big wins moving collectors can offer. 
wrt `os/user`, there are (probably not completely production-ready) pure-go packages that parse `/etc/passwd` and `/etc/group` files to provide the same kind of informations that `os/user` does. _e.g._ the one extracted from `docker`: https://github.com/dnephin/go-os-user
I am using `vim-go` but can't wait for this `Acme`-like editor written in Go and using `shiny` to land: https://github.com/jnjackins/graphics/blob/master/cmd/edit/main.go or this one, `T`: https://github.com/eaburns/T
We need to set GOPATH but that depends on your projects. I didn't want to set something that will end up confusing others. If someone doesn't know I hope they check the links at the end of article and it will tell them they need GOPATH and why.
[removed]
&gt; I don't know if the OS X kernel is still that brittle. I hope not. There is only one way to check, dig that old Go tree and try ;)
sadly no answer to this, I came to ask the same. It would be nice to have a way to call C without incurring in thread creations, we'll still paying for the stack reconfiguration but it could get much better than now and open the gates to a different use of Go (games).
Completely understandable.
Thank you for linking to that, it's very relevant and helpful.
There was a brief discussion in the past about letting users opt in to it with an explicit keyword ("become"). func f(n int) { if f == 0 { ... } become f(n-1) } You can search the golang-dev list for "become tail call" to find discussions of it.
Note that they suffer from the same problem as the pure Go name resolver. LDAP is not supported! 
Because it uses tsan and tsan doesn't support things other than 64-bit: http://clang.llvm.org/docs/ThreadSanitizer.html &gt; ThreadSanitizer is supported on Linux x86_64 (tested on Ubuntu 12.04). Support for other 64-bit architectures is possible, contributions are welcome. Support for 32-bit platforms is problematic and is not planned. 
Any plans on creating an intermediate representation for code (something like JVM bytecode) so that there is a ecosystem of languages which target the Go runtime? Think of what Elixir is to Erlang?
Rob wrote a small Go game in Go as a test of the experimental shiny work, so yes: https://github.com/golang/exp/tree/master/shiny/example/goban
That is https://github.com/golang/go/issues/6914 http://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-01 was written by /u/agl who's written pretty much 100% of Go's crypto code, so my guess is it'll happen eventually, unless Adam no longer thinks it's a good idea. 
What do you mean exactly? Improve the compiler so that it does automatic parallelization, or support for compiler intrinsics? I am not aware of any concrete plans for either, but note that this has nothing to do with cross-compiling. Both could be added while keeping cross-compiling working. And generally we don't like compiler flags and tunable knobs. 
True, I just think by not telling new gophers that they also need a GOPATH it could confuse them as well. My suggestion would be to at least bring it up, or use the same convention the go docs use when taking about vendoring in which GOPATH="$HOME/gocode".
Very poorly, but yes. 
[removed]
To use a library, you include it by path and call functions with library name as prefix. And your library isn't called src.
I have only dabbled a bit with gopherjs, but I believe it would gain tremendous traction if this kind of work would be integrated or at least on the roadmap: https://github.com/gophergala2016/cmd-go-js _ie:_ have `GOARCH=js` be a regular target like the other `amd,386` and whatnot :)
I wrote the fmt package for Go and this is news to me. The name, if it comes from anywhere, comes from printf in the C library for Plan 9. Have a look at https://github.com/brho/plan9/blob/master/sys/src/libsunrpc/fmt.c for instance. You'll find not only the file name but the type is spelled that way. I don't think there's a noticeable influence on Go from Modula-3, but I will say that Modula-3 was a very well designed, consistent language. Sadly, I think its keyword heavy, capitalized syntax turned off more people than it should have.
Yes, I worked through a fairly complete design but it was just too messy. The operator space for Go was more intricate than I realized when I started and my simple plan to make it just work turned into a hideous mess. I now agree with Ian that it's not a good fit, and there are many reasons why not. Most of those involve complexity disproportionate to value.
Hi! Thanks for doing this AMA. I'm a self taught PHP developer working for a small web shop, I only have a few years experience, no CS degree or anything like that. Do you feel that learning Go could help me become a better developer / programmer or will I struggle with the concepts? Thank you.
holy shit that would be incredible, and would rocket the ability to write front-end code in go into the mainstream.
Google3 was an attempt to fix Google2, the second official software development environment at Google. (Can you guess what the first one was called?) Google3 was a huge improvement. Not good enough to fix everything, but good enough that Google4 has never happened. As is often true in engineering, good enough blocks better. A lot of Go's package design was informed by what was learned from designing and using Google3. (I was one of the initial group designing Google3, although it has changed dramatically since then.) Some of the Go-relevant background is sketched out in http://talks.golang.org/2012/splash.article. 
I really think that you do not address the real need for a debugger. No one needs debugger during development cycle. Nice thing to have, but as you said, if you don't have insane compilation speed you should be OK. Everyone needs debug desperately for production apps that fail in unusual ways, and one want to take a look a the coredump, grab a critical piece of data from a process that can't be restarted, etc. Have a look at Joyent's blog for their usage of mdb in production. I'm not having an opinion of what the Go roadmap should be, ~~but~~ and I personally don't mind this for my Go hobby usage, but if I'll use that in production I'd better have debugger at the hand.
You can't hate C if you love Go.
When I was a child, I loved reading old FORTRAN manuals for Eastern Europe clones of western mainframe computers. I think they were System/360 clones, or maybe stolen designs, but with ferrite memory. The first language that I wrote a program that actually ran on a computer was Pascal. However, I quickly came to my senses and learned C and assembly. My first real program was an operating system like thing that let me run multiple DOS programs at the same time. In fact I started doing programming to solve this practical problem that I had. This continues to this day, when I have a problem, I try to solve it, rather than find an awful library that "solves" it for me. I am a programmer, I can program. 
Sometimes I listen to music, sometimes I don't. I used to lack the ability to listen to music while I was working on something, but in the past couple of years I seem to have gained this ability. Right now I am listening to [Anton Bruckner's 8th Symphony conducted by Sergiu Celibidache (Münchner Philharmoniker)](https://www.youtube.com/watch?v=elVHvTrEM34). I find that late romantic classical music, goa trance, psybient, and some doom metal pieces work well while programming. But when I am not working I listen to much more than that. It would be pointless to list everything I listen here, I have a library of about 50,000 tracks which span every musical genre, and yes, I do and did listen to it all at least once. In a way, I am doing music research and I hope to write at some point a book after what I have learned. Music is the most important thing that I *do* right now, followed by physics. Computer stuff is far pretty down the list, to be honest. 
There are rule of thumbs that could be used as a general guideline for such proposals and to avoid the slippery slope; the first that crosses my mind is that the proposal can be submitted only if there is a patch showing at least N usages of the new builtin function in the standard library corpus, proving its ubiquity. &gt; I don't find writing the loops particularly onerous either. It's true that they're not *onerous*, but they are repetitive and make more difficult reading the code, which is what concerns me most.
What is the rationale for your position? A programming language, however minimal, isn't about providing a minimal turing-complete-like set of functionalities to build upon, but also provide good fundamentals. I would agree those functions don't *need* to be builtins, they would be perfectly fine as part of a standard library package, but unfortunately it is not possible to write those functions in normal Go (which is exactly the reason why the only solution is that the language should provide them). It looks like you're post-projecting a rationale into the current builtin set, that wasn't decided in advance. 
Is there an official, supported Go stronghold in Tokyo or maybe a recognized group? As a long time gopher, itd be cool to join Google and promote Go in Japan! It definitely seems to be gaining steam here.
It could actually work with quite the same interface as `Sort` : type Interface interface { Less(i, j int) bool Len() int } func Max(m Interface) (idx int) { for i := 1; i &lt; m.Len(); i++ { if m.Less(idx, i) { idx = i } } return idx } Now `Max()` can be used on anything that implements the `Interface` interface. Interestingly, anything that can be sorted can also be maxed. This is heavier and slower than what other languages might provide, though.
Thanks! That was silly of me to skip any kind of check there. I have pushed out [a change](https://github.com/thermokarst/jwt/blob/master/jwt.go#L110-L114), with an additional test.
You are right, I will add a note that points to GOPATH.
GoDebug is all I need. https://github.com/mailgun/godebug
I added a section but didn't explain too much as this was mainly about compiling go. Hopefully new comer will following the link. thanks 
Are there any plans to support multiple result sets in the SQL package? I regularly build stored procedures that return multiple result sets and I cannot use them from Go
You could probably even key redis by mocking out a RDBMS. You could autoinc a counter and insert the counter as the key and the value would of course be the long URL.
FWIW, there is an encouraging amount of agreement and sharing of goals between many of the authors and/or maintainers of the various packaging tools. #vendor on the [golang slack](https://gophersinvite.herokuapp.com/) is hosting lots of interesting discussions.
&gt; that unpopular-irrelevant-to-job same interview process That is an opinion usually expressed by people not passing it. I always find it weird that people think an interview where you have to solve an under-specified technical problem in cooperation with an engineer would be "not relevant to your job". That is the definition of your job.
As Dave Cheney said in "simplicity and collaboration" : &gt; Why do so many language, launched with sincere, idealistic goals, fall afoul of their own self inflicted complexity ?" “less is exponentially more” from Rob and so on... Is it possible that Go will be the first language to remove some features on version 2 ? (like no shadowing, range return always 2 values, less way to init variable...) Specialy that theses kind of things could be easy to migrate and maybe give speed. If yes, which one (even if i know that it's totally not in the scope of todays work !) ?
We're talking about different things. What I mean is that infamous CS puzzle based interviews (aka competitive-programming tasks) - which even Peter Norvig confessed that is not relevant to job (performance on the job). These interviews assume that candidate should *prepare* for it (instead of testing people AS IS), allocate several weeks/months. Many can't afford so much time, especially mid-career professionals. Also for many, competitive-programming is not interesting at all, and it's perfectly fine. Anyway, I asked if there is a shortcut to bypass this broken process. 
BTW, https://github.com/nsf/godit works very well (even on Windows!) and its well written Go code IMO. 
&gt; Any type might accidentally or not implement such a method, and can then be accepted by your theoretical handler. You are completely justified in panic'ing in such a situation. &gt; The user won't get a warning during compile time when that happens It hasn't been a huge problem so far for the go/ast package. Of course the case for compile-time checking is an easy case to make. But because it's so easy, you'll just end up with Haskell (and we already have a Haskell, why would we need another?). Why are closed typesets more worthy of being expressed in the type-system than side-effects? Or concurrency issues? Or ownership? No one really doubt's the benefits of ADT. It's just that the benefits are small compared to the complexity involved in actually including them and that they are very much non-orthogonal with interfaces.
It's certainly possible that Go 2 might remove some features (or bugs), but there are no concrete plans for Go 2 so it's little more than idle speculation at this point. I'm sure it wouldn't be the first to do so, though. 
Congrats again, I've been a watcher since (public) day 1. I've always wanted to know: did the "origin myth" Google program with the 45 minute compile ever get rewritten in Go? -- or any other such follow-up to build on the legend?
At some point there may be, but perhaps not for a while. We have so many things we'd like to do that we have to prioritize, and for most uses the regexp performance is not a bottleneck. I understand that in some programs it absolutely is, but there are fewer of those than there are, say, programs in which the garbage collector is the bottleneck, so it makes sense to prioritize the garbage collector. Honestly, I don't know precisely what produces the slowness in Go either. One experiment I've meant to run but haven't gotten around to is to take [RE2](https://github.com/google/re2) and force it never to use the DFA execution engine and then compare that execution speed against the Go package. That's still not quite a fair comparison, because RE2 works on bytes and Go works on runes, but it wouldn't be too far off, and the results might illuminate whether it's algorithmic (if they are both roughly the same speed) or some detail of compilation (if RE2 is noticeably faster). Another possibility is that Go could add a DFA execution engine. I've talked to a few people about how that might work (doing it in a language with typed memory requires a different design than doing it in C++), but no one has actually done it. Part of the reason that internals like the regexp syntax are exposed (unlike most libraries) is so that it's possible to reuse the (highly non-trivial) parsing with other execution engines. If all you need is to know whether there's a match or not, like in grep, you could try the [execution engine](https://godoc.org/github.com/google/codesearch/regexp) I wrote for the Go version of [Code Search](https://github.com/google/codesearch). It uses unbounded memory so it's not really appropriate for the standard library as is. There are also some algorithmic optimizations possible in the existing NFA engine that I'd like to explore at some point. In particular there are some nice new techniques in Howard Chivers's [jsre](http://pythonhosted.org/jsre/) library that might help reduce the NFA cost significantly in real examples. But again, there are currently higher priorities.
No need for a book for that sort of thing. Do the [tour](https://tour.golang.org/welcome/1), and read [How to Write Go Code](https://golang.org/doc/code.html), then read [Effective Go](https://golang.org/doc/effective_go.html).
Good to know, thanks.
I agree, but I will say that I hate C less than I used to, and I would even say that my C has improved quite a bit thanks to Go. I do constantly run into 'If this was Go then I could just ___...' situations, though. ^(Rust, on the other hand...)
Oh, I missed the presentation. Do you know what it was under 1.5?
That's an interesting point. It's likely the pauses are already under 3ms for many workloads. The 10ms/50ms was never intended to be enforced by the system—there's no timer keeping track of that and changing the behavior of anything—rather, it was a design goal. And there are certainly things an application can do that increase or decrease that pause time. For example, the pause time is currently linear in the number of stacks that have to be shrunk, so if you have goroutines that are constantly growing and shrinking their stacks by significant margins, that will drive up pause time. We are, however, still working to improve these things (for example, I have a fix to move stack shrinking out of STW prototyped). So, while I'm not sure we'll make 3ms/16ms a design goal, especially while GC throughput seems to be a more pressing issue, it's entirely possible we'll get there anyway.
Yes, but they're doing so by sharing memory.
Hey! Is there any chance we will see another episode of "Hacking with Andrew and Brad" anytime soon? I really enjoyed the two episodes that you've published so far.
I'm very interested
If the choice is between inconsitency and intuitiveness, I think the answer is neither, but perhaps changes to the syntax. Or a configuration option. But we hate those, so here we are.
Do you have any suggestions for a Go application in a severely memory constrained environment? (Apple kills NetworkExtensions if they exceed 5MB. I have tried fooling around with malloc.go, io.copyBuffer, buffer recycling, memory profiling, but no gain large enough to come close.)
I also got a bigger binary. They said the compile time doubled with 1.6.
doubled? No way, it took 4-5 sec to compile my small app earlier, http://github.com/thewhitetulip/Tasks now it takes 40-50sec, it is 10 times as much!!
Well, I'm coming directly from C, so I hate it a *lot* more :)
Let me explain. C and Go are same kind - no OO, composition over inheritance, pragmatism and minimalism. I could even say Go's philosophy is more similar to C than any other language it is compared to (C++, Rust, D etc.). Ironed out C with auto. memory management and kick-ass library is definition of Go. Now, I do get frustrated with C a lot. But hate it? No. Go and C are same beasts in two different worlds.
&gt; We're talking about different things. I don't think we do. I just think I characterized it differently from you. &gt; aka competitive-programming tasks What makes them competitive? It was a very cooperative experience for me, every time. &gt; These interviews assume that candidate should prepare for it instead of testing people AS IS), allocate several weeks/months. I did essentially zero training for those interviews. It seems to me, that these interviews test for a certain skill. If you lack that skill you might resent that and you might feel like you have to acquire it for the interview. You might also disagree that it is a skill you need. I would disagree on both. I think it's an important skill to have and thus an important skill to test for. &gt; Anyway, I asked if there is a shortcut to bypass this broken process. As far as I know, the only thing you can hope for with a referral is to skip the phone screen (which are basic, low-cost computer questions) and to sway a hiring commitee that is undecided. Everything else would go contrary to the goal of the hiring process, which is to find the best people for the job. But admittedly I'm not a hiring manager or anything, so I don't know definitively.
Thank you for the great explanation. This is exactly what I wanted to know. Comments in the allocator source code (https://github.com/golang/go/blob/master/src/runtime/malloc.go) explain how small objects are grouped by size classes, to avoid fragmentation. Go's FAQ says "advances in garbage collection technology in the last few years give us confidence that we can implement it with low enough overhead and no significant latency". The more I read about garbage collection in Go, the more it looks like betting on garbage collection was the right choice.
I just saw that you proposed that a function should only be added if there are at least N uses in the standard library. I find that to be a bit vague--what really counts as a use?--and somewhat artificial, in that the standard library is a highly selected kind of Go code. There are functions that I think would be natural for a generic implementation, like channel merging or fanout, that are probably not used in the standard library.
I'm ok with C, but I just think go is prettier, which is why I've been using it for something traditionally done in C: [OSDev](https://github.com/boomshroom/goose).
Hello, I'm interested in the go toolchain and am wondering how easy it is to port to new targets. I've been working on-and-off on my own kernel over the past year and would like to try and port go to it (and make sure it has what go needs). In addition, I've heard that the RISC-V processor might be supported in the future and I'm currious how that's coming along. Thank you.
They did not say compile time would double with 1.6. That was c to Go (1.4-&gt;1.5) and the initial measurement of [current to SSA](https://www.reddit.com/r/golang/comments/43dhhw/a_week_of_lowhangingfruit_fixes_and_ssa_has/), which is speculatively targeted to 1.7 cycle if they can get the speed back to at least break-even. The only big change to the [compiler](https://golang.org/doc/go1.6#compiler) is supposed to be faster.
You actually will want something that delves into OOP in Go. Go is actually quite different in how you abstract code than most other OOP languages I've worked with. The two big points are that there is no inheritance and that interfaces are automatically satisfied as long as the object has the appropriate methods. These two differences will be a huge pain when you start working in Go, but once you adjust to it, you'll wish other languages were the same. Go is more than syntax - there are major philosophical differences as well. (Not as extreme as, say, a functional programming language vs object language, but significant nonetheless). "The Go Programming Language" is your most comprehensive bet. Also, take some time to read over the standard library when you understand the principles to see some best practices in action. 
I'm not sure what you mean by escape analysis annotations for cgo functions, but I assume that it has something to do with passing pointers between Go and C. For 1.6 we pinned down rules that we can live with for pointer passing, which basically puts severe restrictions on passing Go pointers to C. This isn't because we think it's evil, it's because we want to be able to write the garbage collector to maximize performance of pure Go programs. This is an area where we have to make choices, and we've chosen to optimize for pure Go. This doesn't mean that you can't do what you want. The solution is to allocate memory in C. Then there are no escape analysis problems, though of course you lose most of the advantages of the Go garbage collector. That aside, I would certainly like to speed up calls between Go and C. It's tricky because of the stack issues, but I think we can do better than we do today. Sorry this probably isn't much help.
Thank you for your reply, but what I'm aiming for is a little different. I am aiming to have a search box on a page, where as you enter your search term, the results below update. Here, your strategy works for populating the results before we begin, but my problem is with updating this list once we start typing.
Why Java is not replaced by Go in Android despite the advantages of Go and despite the problems with Oracle? Thank you for golang.
That's really a question for the Android team, and we can't speak for them. But as far as our idea of how our own Go work fits in, see [Brad's response on a related question](https://www.reddit.com/r/golang/comments/46bd5h/ama_we_are_the_go_contributors_ask_us_anything/d049oky).
My music is the hum of the fan, the high pitched song of the video monitor, and the drum beat of disk drives (slowly being replaced by silent flash memory, alas).
Thanks! I tried using the writer, but it seems to want to overwrite the whole document rather than append to a new line whenever I use it... Any further direction would be much appreciated!
Porting to a new OS is not too hard, at least not compared to the effort of writing your own OS in the first place. Look at the os*, sys*, and rt* files in the runtime package. You'll have to write versions of those. My understanding is that there are people working on a RISC-V port but I don't know how far along they are.
Can you post a code snippet on the playground?
What are the most important packages to get acquainted with during a "mental upload" of the golang API?
Can Google, or some other company, be persuaded to fund an alternative Go compiler? (alternative == supposedly_better)
It seems like gccgo is falling further behind while the gc compiler gets all the runtime improvements. Will gccgo ever be able to incorporate all that cool stuff (especially the garbage collector)? Is Ian the only one maintaining it?
http://play.golang.org/p/CzFNG1eDec appears to work for me.
Architecture-wise I've ported Go to arm64 (integrated) and sparc64 (not integrated yet). OS-wise I've ported Go to bare-metal (experiment, not integrated), Solaris (integrated), plus I re-ported it to Plan 9/amd64 (integrated, I didn't use any of the old, not working implementation previously done for the nix kernel). It is extremely easy to port Go to new operating systems. The port to Solaris took about three weeks of work, but then I was just learning what I was doing, the Plan 9/amd64 port took one day (although it still doesn't work perfectly, but that's Plan 9's fault). Porting to a new architecture is obviously harder. I've worked with some people who port a nameless, extremely popular compiler written in C++ to a nameless architecture that ends with 64, and I can say in good faith, that from the numbers I gathered, the current Go version is 10x easier to port in terms of man-hours than the other compiler. However, Go is harder to port than it used to be, for reasons I don't have time to get into right now. For comparison, the Plan 9 toolchain can be retargeted in about two weeks. This is a fact, since I've seen Charles do it. Go is much harder than that, probably the geometrical mean between kencc and the C++ compiler. As popular, production ready toolchains go, you won't find anything easier to port than the gc implementation. 
&gt; Have a look at Joyent's blog for their usage of mdb in production. There are plans for better mdb support for Go. 
From watching the repo, they are very active and will reach 1.0 release candidate very soon. Also, [Visual Studio code](https://code.visualstudio.com/) has a great environment for Go with its [Go Pluging](https://marketplace.visualstudio.com/items?itemName=lukehoban.Go) They both integrate with Delve to some extent.
They don't provide internet access?
[This](https://github.com/mailgun/godebug/issues/65) is the only drawback. But should be fairly easy to implement.
&gt; Please advise, I would like to use Go instead of Javascript for client side web development. How? Client-side IS javascript/css/html. Unfortunately.
No, I think https://golang.org/doc/faq#assertions is still accurate. 
/u/enneff and /u/bradfitz will be on the same continent in a little while, so maybe. ;-)
Well, here's a discussion with myself on the subject: https://github.com/pciet/assert/issues/1 I've been having good luck with them for rapid app development (&lt; 20% test coverage). The one key thought I had for the language is a spec feature for debug APIs, as automated true function call removal today requires custom parsing pain or dependence on implementation details. Guess this is outside the scope of this thread. Thanks, I'm writing Go concurrently with this comment.
What's the story behind keywords? There's not many of them: https://golang.org/ref/spec#Keywords
I didn't notice any long build times when rebuilding with 1.6, but once 'go fmt' seemed to hang on me for like 5 seconds. Not sure what that was about, since the machine wasn't busy, but it hasn't happened again. 
http://s9.postimg.org/3v35bgnlr/go1_6_gc.png
C'mon, you know what I mean. :) https://golang.org/src/cmd/compile/internal/gc/lex.go#L2213
Sorry, all I see is: http://imgur.com/seYlKrT
Is it a weird thing to say that 5MB is just huge? Why isn't this a few hundred kilobytes? One MB is really a LOT of data. What is causing these sizes to get so big anyways?
I'm curious about the veracity of this post. Would some experienced contributors please comment? Also, please acknowledge any biases. Thanks!
What are some of the most interesting go code reviews?
I don't expect SSA to make much difference there. The bulk of the binary is metadata such as type information, not the code itself, and the metadata will be the same regardless of the compiler. Remember, the biggest piece of the binary is, ironically, DWARF.
Hi! Sorry if I'm wrong - I'm somewhat unfamiliar with Go itself. Go 1.4.3 is the last version that does not require Go itself to build. To reduce the risk of the famous [trusting trust](https://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf) problem of bootstrapping compilers, we like to build the latest Go by first building 1.4.3. Recent binutils upgrade [broke this](https://github.com/golang/go/commit/914db9f060b1fd3eb1f74d48f3bd46a73d4ae9c7) and it was already fixed in the latest version. Can I send a patch that backports this to 1.4.3 anywhere, so others can continue to enjoy the same ability?
Ah yeah I didn't really explain what I was after in regards to advice. But I'm basically looking at how to deal with graceful cancellations for API requests, should contexts be always used or not in certain requests, tracking users with contexts across apis, and I guess best practices when using contexts? 
wow, didn't expect this to be recognized, I really appreciate your comment, thanks so much.
Here's some data (I won't comment on it). There are 1733 commits between the "go1.5" and the "go1.6" git tags $ git log go1.5..go1.6 --oneline | wc 1733 14027 105855 made by 154 authors $ git log go1.5..go1.6 | grep "Author:" | sort | uniq | wc 154 618 6939 (actually a little fewer, there are a few duplicates). How many of them are googlers? I don't know, but we can try to filter for people submitting with a @google.com or @golang.org mail address. $ git log go1.5..go1.6 | grep "Author:" | sort | uniq | grep "@google\|@golang" | wc 37 150 1546 It's actually 35 (Dmitry Vyukov is in the list twice and we got a "@googlemail.com" false positive). Here's the list: Author: Aaron Jacobs &lt;jacobsa@google.com&gt; Author: Adam Langley &lt;agl@golang.org&gt; Author: Alan Donovan &lt;adonovan@google.com&gt; Author: Andrew Gerrand &lt;adg@golang.org&gt; Author: Austin Clements &lt;austin@google.com&gt; Author: Benjamin Prosnitz &lt;bprosnitz@google.com&gt; Author: Brad Fitzpatrick &lt;bradfitz@golang.org&gt; Author: Brian Gitonga Marete &lt;bgm@google.com&gt; Author: Burcu Dogan &lt;jbd@google.com&gt; Author: Charles Weill &lt;weill@google.com&gt; Author: Chris Broadfoot &lt;cbro@golang.org&gt; Author: David Benjamin &lt;davidben@google.com&gt; Author: David Chase &lt;drchase@google.com&gt; Author: David Crawshaw &lt;crawshaw@golang.org&gt; Author: David Symonds &lt;dsymonds@golang.org&gt; Author: Dmitry Vyukov &lt;dvyukov@google.com&gt; Author: dvyukov &lt;dvyukov@google.com&gt; Author: Ian Lance Taylor &lt;iant@golang.org&gt; Author: Ingo Oeser &lt;nightlyone@googlemail.com&gt; Author: Joel Sing &lt;jsing@google.com&gt; Author: Keith Randall &lt;khr@golang.org&gt; Author: Marcel van Lohuizen &lt;mpvl@golang.org&gt; Author: Matthew Dempsky &lt;mdempsky@google.com&gt; Author: Michael Matloob &lt;matloob@golang.org&gt; Author: Michael McGreevy &lt;mcgreevy@golang.org&gt; Author: Nigel Tao &lt;nigeltao@golang.org&gt; Author: Nodir Turakulov &lt;nodir@google.com&gt; Author: Paul Marks &lt;pmarks@google.com&gt; Author: Paul Wankadia &lt;junyer@google.com&gt; Author: Raul Silvera &lt;rsilvera@google.com&gt; Author: Rick Hudson &lt;rlh@golang.org&gt; Author: Robert Griesemer &lt;gri@golang.org&gt; Author: Rob Pike &lt;r@golang.org&gt; Author: Russ Cox &lt;rsc@golang.org&gt; Author: Ryan Brown &lt;ribrdb@google.com&gt; Author: Sameer Ajmani &lt;sameer@golang.org&gt; Author: Shenghou Ma &lt;minux@golang.org&gt; This leave us with 117 (again, ignoring a few duplicates) authors that **probably** are not google programmers, just for the *6 months long* go1.6 development cycle. 
It's been discussed a lot. This usually happens when a package has a lot of transitive dependencies. [`net/http`](https://godoc.org/net/http?import-graph) is the culprit in this case (it doesn't make sense to account for `log` separately, because `net/http` imports it transitively). In the example program, a lot of that code is going to be unsused. It's possible the linker could be made smarter and eliminate most of that. I'd imagine it should be possible for a more advanced one to get rid of all the crypto code when only serving unencrypted HTTP.
I like a lot of different stuff. Lately I've been listening to (looking at my Spotify history) Bill Evans Trio, Tipper, Daphni, Drake, Luke Vibert, Young Thug, James Blake, Portico Quartet, Strapping Young Lad, ISIS, Glenn Gould, Esbjorn Svensson Trio, Miles Davis, Slipknot, Herbie Hancock, Ricardo Villalobos, Kendrick Lamar, Jon Hopkins, Venetian Snares, Herbert, Gary Numan, Ametsub, Prince, and Frank Zappa. I like to listen to music without lyrics when I'm working. Drum and bass can be particularly good work music. Some dnb producers that I like a lot: Seba, Paradox, ASC, Commix, and Mav.
Everything in https://golang.org/doc/ in order. If you want a book, http://www.gopl.io/ is excellent.
[Link](http://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440/) to said book.
It should work to build Go 1.4.3 with CGO_ENABLED=0. I marked https://golang.org/issue/13114 for Go 1.4.4, so that if we ever go a Go 1.4.4 release we can decide whether to include it. However, I don't think this problem by itself is enough to justify a Go 1.4.4 release. Thanks for bringing it up. I think that GNU binutils change was installed without thinking through all the issues. There are various circumstances where the assembler and linker are separated. I think there should have been an option to not generate the new relocations.
Any plans on optimizing (writing ASM) crypto for arch's other than amd64? 
While many people contribute patches, Chris Manghane and I are the only ones maintaining gccgo. It is indeed my plan to incorporate the new garbage collector. it's a matter of finding time to do it.
Author here. It is generally considered bad to strip Go binaries as the `strip` utility does not target Go programs and _could_ cause problems. The general advice is just to accept a larger size and not have to deal with said problems. While I only use strip here for experimentation purposes, my testing is not extensive so it should be used with caution. I will add a note to the post with the same warning.
There is, of course, [Etherpad](https://en.wikipedia.org/wiki/Etherpad). I also know of [Gobby](https://en.wikipedia.org/wiki/Gobby), never tried it though. It seems to have some facility to record whatever happens, however I haven't seen a way to replay. But Gobby relies on a specified protocol, which means it "should" be easier to introduce inside other softwares. 
`new` pisses me off for some reason. And every time I see a bare `return` I assume someone is just showing off how much state they can keep in their head.
Well, e.g. the`net/http` package supports accessing both HTTP and HTTPS URLs. While your program may only access HTTP resources, how is the compiler supposed to know this? It would have to analyze all the strings of the URLs that could potentially be used by `net/http`, and so on. (And it becomes even worse/more impossible if you accept URLs as input or from a config..) With regard to binary size, it would be nice if you had to e.g. manually specify which transports should be support by the `net/http` package, which crypto algorithms should be supported by `crypto/tls`, et cetera. But somehow I don't see that happening anytime soon.
Do you know what requirements the go runtime would have from the kernel/os?
Oh, yeah I see now that's explained in the readme (which I swear I read, but obviously not carefully). Beautifully done.
&gt;An alternative would be to make the zero value be the zero of the first type in the sum, but that has its own odd implications. I'd like to understand this better. Can you give an example?
Hmm. 5 Mb might be big or even huge. But the real question is: when would that be a problem ? Most disks are 100s of Gb. For $5 a month you can have a 512MB/20Gb (ssd) machine which runs easily several of those applications. Binary size is probably the last problem you would have for scaling... So I think for 99% of the use-cases this is not a problem ? I for one appreciate the Go-team focuses on other things then limiting the binary size ;-) 
`goimports` breaks if the package's name is not the same as the last segment of the import path, and it's annoying. Renaming a package import (e.g., `foo "github.com/user/bar`) is annoying as well. 
Why not model types like in Haskell, with sum/algebraic types and interfaces as just types, not values that can be inspected at runtime for the real type? Those are orthogonal ideas, and they reduce errors by keeping you from breaking the interface abstraction.
I understand because they are many more things in the standard library or the runtime that can be optimised first that take allot of effort to do it right before putting energy in does ideas. Still I feel like does ideas are so fundamental they need to be explored and should be on somebody's blackboard :)
That's good to hear, thanks for all the hard work!
I hope you will take a serious look at [Glide](https://github.com/Masterminds/glide). From my perspective, it does everything a Go package manager should do.
I love you. That's so simple and perfect. Appears to work well in my testing too. I'll update the OP with this link. THANKS!!
You might want to read a bit how godoc and templates work. You can do neat tricks with it, like code template that gets compiled and checked with normal tests (and included in relevant docs section), so if you accidentally break it `go test` will catch it
I also use https://github.com/golang/mobile to write simple desktop app.support android, ios by natural.
This seems like an argument against implicit interfaces, not in favor of sum types. If you're really concerned about another type implementing your interface, make the identity method really obscure. type handler interface { iAmAHandlerButProbablyNotTheOneYoureThinkingOf() } In all seriousness, I've never heard of this being a real problem. It must be the rarest of bugs.
I'm sorry, I don't understand what that means in the context of the Go language as it exists today. It sounds like you are talking about a different language--like, say, Haskell. Apologies if I'm missing what you are saying.
Thanks everyone for all the great questions. The response has been overwhelming, in a very good way. I'm going to unsticky this post since it's been well over 24 hours at this point. I'm also going to make sure that all the questions older than this comment do get answered in the next few days. I know I personally have a bunch that I intend to reply to but haven't had time yet today. **Thanks again!**
I don't know if it's possible or not, but your scenario isn't valid. If the linker strips out a crypto lib that *could* be used at runtime, please file a bug against the linker.
I've been developing in Go since 2014 and today was the first time I saw a good moment for generics...but then I refactored it out for a superior solution.
Yes, getting that done one way or another is part of completing those ports. 
The first step in any security issue is to define your attack model. Who are you defending against and what can they do? If you are reading untrusted JSON, my main concern would be the size of the input and the size of the data structure that will create (strictly linear in the size of the input but maybe 10x bigger if done right). I'm not worried about some carefully crafted JSON value causing json.Unmarshal to overwrite memory in some interesting way that enables a more devastating attack, though: Go isn't C. :-)
https://golang.org/pkg/runtime/#GOMAXPROCS shows the tradeoff you need to beat between endurance and hitting power. Also, no tricks: &gt; GOMAXPROCS sets the maximum number of CPUs that can be executing simultaneously and returns the previous setting. **If n &lt; 1, it does not change the current setting.** The number of logical CPUs on the local machine can be queried with NumCPU. This call will go away when the scheduler improves.
Vodka martini. Shaken, not stirred.
That was exactly my point.
The statically-linked binary is smaller than the dynamically linked binary?
Go doesn't permit this to improve readability. When you see a `foo.Bar` value you just know what it is. You don't need to go and check that it wasn't adulterated in some way by another package.
Have any sources on this. I see it mentioned occasionally, but have never seen it from a good source. Googling, it seems like the only 'official' place it is mentioned is in a bug report that is closed with the issue fixed back in 2011. https://github.com/golang/go/issues/1242
I see. Calling it "fully automated" confused me in that it seems to imply that stripping out unreachable code is somehow incomplete, and that the linker *should also* strip out *reachable* code.
Is it really free, though? xz is not ubiquitous like gzip.
Was answered in the AMA: https://www.reddit.com/r/golang/comments/46bd5h/ama_we_are_the_go_contributors_ask_us_anything/d03rn14
This post doesn't match my experience. It is obvious that for the project like Go the quality of your contribution must be high, but all contributions are certainly welcome.
I'd like to understand this more, since I have little experience with these CI systems. If your build environment can run `go test -no-vendor ./...` why can't it run `go test $(go list ./... | grep -v /vendor/)` or `bash -c 'go test $(go list ./... | grep -v /vendor/)'`? Thanks. 
If you file an issue at golang.org/issue with a program and a command-line you are using, so that we can reproduce what you're seeing, we'll definitely look into it. Thanks. 
&gt; articles Especially this, and just about anyone with any skillset can do it with a free Medium or WordPress account. Go is still a long way off from being uber-googlable like some older languages. We need more articles and tutorials, and not just for the core of the language. A lot of high profile Go libs/apps/frameworks are really light on tutorials and guides.
What you need is likely different from what someone else needs. There's no one right answer here. You might never need to use go/ast, for example, but someone else might find it indispensable. For using the standard library to learn Go, I think the most instructive one to read would be [io](https://godoc.org/io) and mentions of that package scattered through the rest of the library, because it's a good demonstration of the power of interfaces. Also, as a way to find your way around, the tools described in [this dotGo talk](http://www.thedotpost.com/2015/11/alan-shreve-conceptualizing-large-software-systems) sound interesting.
I liked [Brad's comments about Rust](https://www.reddit.com/r/golang/comments/46bd5h/ama_we_are_the_go_contributors_ask_us_anything/d03wav1). I would like to understand Rust better, but I haven't had the time to dive in and do something.
Everything is constantly changing in computing. You never know enough. If you ever feel like you know enough, _that's_ when you need to worry: it means you're disconnected from what's changing. 
That sounds really fascinating Andrew, I'm looking forward to seeing it. Glad you discovered `net/rpc` over WebSockets too. I'm curious about your implementation of that, did you use https://godoc.org/github.com/gopherjs/websocket bindings for websocket or something else? I've done it at https://github.com/shurcooL/play/commit/e7e89367c071462ed0d150663bba54a78c06deed#commitcomment-9977203. :)
I am not sure what field you are referring to, unless it is languages for systems programming. And the statement we made with Go is pretty loud and clear. If you haven't already, I think you might enjoy reading http://talks.golang.org/2012/splash.article, whose very title (Go at Google: Language Design in the Service of Software Engineering) hits all your points. In other words, while I agree that there has been little advancement in many of the areas, Go is an attempt to push against at least some of the walls. I also think the recent work on containers, in which Go plays a big part, is a powerful way to think about system administration, which I called out like this in 2000: "System administration remains a deeply difficult problem. Unglamorous, sure, but there’s plenty of room to make a huge, even commercial, contribution."
I hadn't heard about the Plan 9 (movie) remake. It looks awful, and not good awful. 
Hey broady, I am doing that, http://github.com/thewhitetulip/web-dev-golang-anti-textbook Writing a book to teach web dev using Go. But you are probably mistaking my point, I want to contribute to the _language_, I am already doing all I can to advance the language, learning material, it'll take a few months until my book is ready and I am taking a *lot* of efforts to teach web dev in easiest language with practical examples. Also it sounds a little bit condescending and insulting to get this statement from a Go contributor, it is as if you don't want people outside of Google to contribute to the language. If it is an open source project then you should I was under the impression that you'd be welcome for a new contributor to join in to help you out to advance the _language_ and not _content_ surrounding the language. I might have taken your comment in an incorrect light altogether, apologies should that have happened! I really want to contribute to the _language_ since I am already writing a short simple intro book so I guess I have done all in my power to advance the content and frankly I am not that advance a Go programmer to develop libraries, I'll do that some day eventually. Also the funny thing, when I posted about my book on the official go nuts channel I got feedback that the language is Go and not Golang so don't call the book as webapps in Golang an anti text book :D I stopped using the google group after that since reddit gave me some real good feedback as to the _content_, even this factor makes me feel as if Go isn't a project which is that newbie (as per the language and not programming in general) friendly
TIL that `tar` on OS X supports xz compression! I assumed that since the `xz` command wasn't available on my OS X system, it wouldn't be available in the system `tar` command either.
Well, I was looking for something more concrete rather than just a link :-) When I was going to do a contribution to spyder, I talked with the devs and came up with a PR which isn't still merged, after six months. That was my first PR ever to any open source project, and it is disheartening when such things happens, anyways I'll start commenting on issues and see the gerrit link
The thing is yes, as of now I may not be an uber go programmer, but eventually when I start contributing small bits and pieces, I read and see the dev process then surely I will become an Uber programmer and contribute to the language.
Google [stopped using puzzle questions](https://www.google.com/search?q=laszlo+bock+google+puzzle+questions) many years ago, before Andrew was interviewing. The Google interview today is most commonly three to five 45-minute interviews in which you talk through the solution to some technical problem and usually code some part of it. I agree with TheMerovius's characterization of this as both "have to solve an under-specified technical problem in cooperation with an engineer" and "the definition of your job". Obviously there are unrealistic aspects too, like writing on a whiteboard or having only a relatively short amount of time, but those are at least somewhat forced by constraints of the interview format. 
You can find a presentation and Q&amp;A on GC here: http://www.infoq.com/author/Rick-Hudson Testing on a machine with 96 cores and 250 GB of heap space. Wowzers.
This is a very important point. Also key is that methods can be attached to any (user-defined) type, not just structures. That includes integers, strings, even maps and arrays. Go isn't like languages that provide every feature of existing languages. It's a minimal language in the style of C. To enjoy Go, it's necessary to throw out preconceptions of "how it's done". For anyone wanting a taste of OOP in Go, I wrote an article three years ago, but I believe it's still relevant: https://nathany.com/good/
The slashes are there because that is a fairly standard way to write a date, for example 2/18/2016 in the US. The reordering to big-endian yyyy/mm/dd makes it sort better. In retrospect matching ISO 8601 with yyyy-mm-dd would have been nicer and possibly clearer. Live and learn. Maybe for Go 2. Actually, for Go 2 I would change the defaults in the log package too, so every program I write doesn't need to start with: log.SetFlags(0) log.SetPrefix("progname: ") 
What do you mean exactly? Maybe my colleague /u/ytmongpoo can help you out (same username on Twitter). He is heavily involved in Go in Tokyo.
Short answer: no. It did get retired from production, though that had nothing to do with how long it took to build.
I personally want sum types and generics to get rid of empty interface and type assertion hell.
&gt;I am not sure what field you are referring to Yes it wasn't very clear, sorry for that. How about operating system research, maybe a Plan 9 inspired work or a new OS that hits all today's pain points? (Not sure if it's really needed but I wanted to ask anyways.) And yes about languages for systems programming, Go has made a huge impact and I want to thank the Go team and all the gophers for that! &gt; And the statement we made with Go is pretty loud and clear. If you haven't already, I think you might enjoy reading http://talks.golang.org/2012/splash.article, whose very title (Go at Google: Language Design in the Service of Software Engineering) hits all your points. You are right! I've watched that talk a few times already and I love it but it's been a while. I will watch it again on the first chance. Thank you very much. &gt; Go is an attempt to push against at least some of the walls. I also think the recent work on containers, in which Go plays a big part, is a powerful way to think about system administration That precisely answers the "where does Go fit in the whole picture". Thank you. Edit: I was under the impression I had watched that talk but I can't find it anymore, maybe I had watched something similar.
Yes, I'll start it now as soon as I have sometime to spare
No, the thing is when people are asking how to contribute to the _language_ then telling that write articles and tutorials is not that great advice
&gt; triage issues by reproducing them or submitting fixes is great Yep, I'll start ASAP and keep in touch with you all the while :)
I'm familiar with godoc and have used templates a lot for my web apps. Didn't know you could test the code examples in the docs though, thanks! Also, is that a friendly wink at me to get started on the tests sooner? ;)
More accurately a minimal Scala program depends on scala-library (5.5Mb jar file) *and* Java Runtime Environment. To be fair it is usually not a concern in the applications where Scala is being used. Performance obviously depends on your application. In some cases JVM is faster, in some case Go is faster.
Well, the poster highlighted only this part, so I didn't go through the link. I'd rather comment on issues and try to contribute.
It sounds like you ended up with the "\n" in the string (2 characters) accidentally becoming an actual newline. Look at your own file and make sure that the string inside Printf is all on the same line.
Looks like the "\n" is interpreted as an actual new line character instead of '\' and 'n' characters.
This is incredibly cool! Thanks! This might differ by country but isn't windspeed usually measured in meters per second? 
"I think you'd have to define "alternative" a bit more clearly." I am sorry, I am unable to do that. It is impossible to travel to the future and send the answer from there. All I can say is that I am constantly working on it, and that I am getting closer to the final result as time passes on. I could write about the goals of the alternative compiler, but I fear that it would be rejected as crazy.
&gt; but interviewer assumes you know (studied beforehand and remember, prepared) some particular algorithm (e.g. Knuth-morris-pratt efficient substring search or KD-trees). I don't believe this is true. If this algorithm (I don't know it) is a solution to the problem presented it will make the interview easier if you know it (which I find legitimate. If you have broader knowledge about this stuff you will perform better at your job). If you don't know it, you have an hour to come up with an alternative and it is the job of the interviewer to get you to a solution. That last part is important: The interviewers job is not to find out if you know that algorithm. Their job is to help you show what you *do* know. If what you know instantly solves the problem, that's great. If not, they'll talk you through the process of coming up with a viable solution from first principles. As a datapoint: I definitely did *not* come up with a good solution to one of the questions in my interviews. However, after half an hour of talking and questioning and arguing with my interviewer there was *something* on the board (about half of it was written by them) that might work and during that process I demonstrated enough ability that they were comfortable to let me pass. Even though I demonstrably did not know the answer to the question, I demonstrated the skill to talk about code, programming problems and their solutions and to cooperate with other people in finding them. And that's ultimately my job. I sympathize with people who get rejected. But ultimately that can be both a false negative and a true negative. People routinely dismiss the second possibility and they also discount the explicit goal of the Google hiring process to minimize false positive even at the cost of false negatives. So what they are left with is blaming the process or Googles requirements. And I'm sure sometimes those are the problems. But I'd claim in the majority of cases it's one of the instantly rejected possibilities.
Yes, but not online yet. The talk was only a few hours ago.
&gt; If you're really concerned about another type implementing your interface, make the identity method really obscure. The problem is not someone creating a method ~~of the same type~~ with the same name. There is a weird implication from the way exporting and method sets work which mean that the unexported method `foo` on a type in `package a` isn't considered for an interface with method `foo` on a type in `package b`. However, you can never make implementation of an interface impossible or even difficult. If `I` is an interface type, then `type S struct { I }` will always implement it. No matter what you do.
sorry for answering so late (1) http://andreasgal.com/2016/01/05/oracle-sinks-its-claws-into-android/ not a formal article, but every bit is true. (2) as mwhudsondouyle said, it's the -buildmode=plugin that I'm looking for. Not implemented (yet) Thanks.
read this https://golang.org/s/go15vendor &gt; If there is a source directory d/vendor, then, when compiling a source file within the subtree rooted at d, import "p" is interpreted as import "d/vendor/p" if that path names a directory containing at least one file with a name ending in “.go”. &gt; &gt; When there are multiple possible resolutions, the most specific (longest) path wins. &gt; &gt; The short form must always be used: no import path can contain “/vendor/” explicitly. &gt; &gt; Import comments are ignored in vendored packages. 
Note to all: if you just need the user's home directory, you can use https://github.com/mitchellh/go-homedir so you don't have to import `os/user`.
I've assumed the program in the article wouldn't ever call crypto code because it wouldn't be reachable from `http.ListenAndServe` through the call graph. Then, if the linker had access to the call graph information that could make it possible to only link in relevant parts of a package and it's transitive dependencies -- in this case ommiting all crypto code. I'm not sure if the assumption holds though, especially with the HTTP2 support added in 1.6. And yes, in general, removing all code that won't be run would be impossible, for several reasons.
Vendoring is using a local package (lib) instead of the online one when importing. This is mainly done to use a specific version instead of the latest one and especially to use a locally modified/patched version. 
I'd recommend against the JSON powered SPA architecture that's all the rage these days. Instead, I'd recommend getting a good grip of the templating system and doing full round trips to the server.
I've sketched out how I imagine it working in https://www.reddit.com/r/golang/comments/46gbdz/binary_sizes_in_go/d05p8d7 .
Have a look at [Harvey-OS](http://harvey-os.org/). It's still early days, but I like the idea of it.
I just want to let you know my personal practical experience upgrading from go1.5.3 to go1.6 runtime. The upgrade went smooth on win7 os by replacing the old go1.5 directory with the zipped contents found on the Go project site. Windows users may call this xcopy deployment. Now for the bad part: I was working lately with go1.5.3 on some internal tool loading CSV datafiles into a local "ql" database (https://github.com/cznic/ql) and generating reports from the database as Excel sheets. On my current hardware (win7 os, 386, SSD) compilation time took a bit longer using go1.6 than using go1.5. The same effect was found when doing reports. The go1.5 binary took 8 seconds to query the filebased database and write the Excel file, go1.6 binary took 17 seconds for the same task. Using in-memory database go1.5 binary took 1.7 seconds whereas go1.6 binary took 2,8 seconds. Somehow i/o operations where the filebased database is r/w real often causes a 100% slowdown of the application. I know that arguing between 8 and 17 seconds is a bit crazy, but performance-wise go1.6 is a step backwards in my case. I am sorry that I can't share the source or binaries from that tool, but a testcase should be created using the ql database package and to compare database performance for go1.5 vs. go1.6. As always dear Go team, keep up your good work! Cheers, Nek 
I have a package that I _ import in every program just to set the log prefix like that. 
That's in our backlog and will be coming soon. It's now one of the most highly desired features.
Look at http://goconvey.co/ especially if you use 2 monitors. You just run it and it automatically runs test whenever any file on disk changes. It has also few nice builtins to make writing tests easier, like a bunch of asserts for various data types. 
Hoping the go rewrite of the compiler tools finally caches up with the apparent speed of C in 1.7.
It is km/h here in Brazil.
I agree that the underscore import solution would be nice to have. Backwards compatibility would indeed be a hard requirement, but it wouldn't be impossible if you e.g. make `net/http` and `crypto/tls` metapackages that pull in "everything". And then create new, more modular packages using the underscore import style. (Also not a fan of compile time switches myself, so not sure why that was the conclusion that was jumped to.)
&gt;But is it really significant enough to justify the cost? Can you elaborate on what the costs of adding sum types would be? To partially answer your question though, I would pay quite a bit to be able to model my problem with a closed set of ADT's rather than the open set that empty interface and told assertions provide.
I'm not sure whether you're talking about build times or the speed of generated binaries, but we expect improvements in both.
build times
&gt; Can you elaborate on what the costs of adding sum types would be? It needs to be added to the spec, it needs to be implemented and maintained, people need to learn about it, people need to keep it in their head, you add overhead to decisions when it comes to modeling problems… Every addition to the language adds some cost and go prides itself in having high regards for simplicity and minimizing those costs. It is simplest to think about it in orthogonality. High orthogonality means a very good cost/benefit tradeoff. ADT aren't very orthogonal to the current design elements (mainly to interfaces), which is a good signal that the cost/benefit tradeoff probably isn't good enough. &gt; To partially answer your question though, I would pay quite a bit to be able to model my problem with a closed set of ADT's rather than the open set that empty interface and told assertions provide. You are entitled to your opinion. I, personally, think it's value is grossly overrated for go. Especially as you'd need a zero value for ADT's, so you'd need to add a nil-case to your variant-switch anyway, so you might just as well add a default-case to your type-switch and just live with interfaces. But that's really the core of the issue: Every individual has their pet feature that they'd like to add (my current pet-feature is dynamic scoping) because it would make their particular use-case simpler. You can't add them all (or rather: You end up with python if you add them all and we already have a python), so you need to choose. Just naming the benefits won't make this decision easier.
Yep, I've used it in the past. It's pretty sweet, but I remember having had troubles getting a coverage report from it. It's probably easier to use now a days.
&gt;You are entitled to your opinion. I, personally, think it's value is grossly overrated for go. Especially as you'd need a zero value for ADT's, so you'd need to add a nil-case to your variant-switch anyway, so you might just as well add a default-case to your type-switch and just live with interfaces. I'd prefer optionals and sum types. That would maintain the closed set I'm looking for here.
Good presentation, "Go 1.x, Solid foundation to build upon, Excitement can be found upstairs"
This is a great book, I've been working through it over the past month and have learned a ton.
it was 1963 in a electrical engineering course. it was a lecture or two on introduction to programming. the computer was a bendix g-15. magnetic drum memory - 20 tracks of 100 words of 29 bits. an instruction had a next-instruction-address field. optimization was to space instructions such that the next instruction was under the read head just as the last instruction finished execution. now isnt that a total waste of neurons? my first language was intercom, an interpreter for mere mortals on the G-15. i started coming in nights and soon progressed to assembly on the machine. next weeks in the e.e. course was analog computing. i cheated and used the G-15 to time-scale the analog problems. that was the first "real" program that i wrote. rather simultaneously, i sought out most available computers on campus. ibm 1620, ibm 1401, dec pdp-5, dec pdp-6, ibm 7090 and xds/sds 940. languages were assembly, fortran, algol, smalgol and neliac. i knew cobol enough to consult, but never programmed in it. the magic words: mea culpa. a prank in a time of weakness. my only excuse - boredom. 
I'd love to have a great library for building local user interfaces (like desktop apps or mobile apps). Right now basically all Go programs are either text-based or make you type into a web browser. That gets old.
Is there any policy regarding orthogonality between the stdlib packages and 'x' packages? I wonder if things like VFS could be eventually accomplished by having an alternative and official-ish supported 'x/os' implementation, maybe even simply wrapping the standard library code.
Also, if what you know instantly solves the problem, you know what happens? The interviewer learns very little about how you approach solving "an under-specified technical problem in cooperation with an engineer" and adjusts the constraints to exclude that solution or moves on to a backup problem. The instant solution may be a tiny plus in your favor, but only a tiny one.
I had some time and added "Segmented Sieve" as the calculation method. 
I followed the Readme and get this after executing wego: 016/02/19 13:39:13 Malformed response
This entirely depends what your data looks like and what you're using it for.
Depends on your data. CSV can usually by parsed and processed incrementally, so your memory footprint stays relatively constant. For a JSON file, you usually parse it as a whole (like you'd do with a DOM parser for XML). I had a case where I wanted to load JSON 100MB JSON files and the memory usage exploded in my face (in PHP and Node.js). You *can* incrementally parse JSON (like with a SAX parser for XML), but then you have to keep track of your state and such. What you gain from using JSON is stricter string handling, so if you data contains "bad" characters for CSV (line breaks, commas, quotes), JSON can help you handle that. Some people went with the best of both words: A file with one JSON document per line, so you can still incrementally walk through the file, but also have the niceness of JSON parsing. There's a dedicated name for these JSON-line files, but I forgot it. {"id":1,"foo":2} {"id":1,"foo":2} {"id":1,"foo":2} You can also be a bit more strict and create a valid JSON *file* like this: [ {"id":1,"foo":2}, {"id":1,"foo":2}, {"id":1,"foo":2} ] Just skip the first and last line and trim the trailing commas. Or read the file as a whole. If you are the only producer and consumer of the JSON files, this might be a choice; otherwise I'd stay away from this, as it leads to weird "we output JSON, but we promise to format it in a special way so you can read it line by line and do this magic." statements in documentations.
JSON.... More control.
Perfect!
You may be able to find opportunities for remote work on [we love golang](http://www.welovegolang.com/) and the [Go Forum "Jobs" tag](https://forum.golangbridge.org/c/jobs). The community is also very active on [Slack](https://gophers.slack.com).
It seems unlikely that the speed of reading CSV files is meaningfully slower than JSON in your application. Have you profiled your code and seen that a lot of time is taken in the CSV reader? If so, create a benchmark with CSV and JSON readers, and compare. If JSON comes out a ways ahead, then you can consider switching to it for speed reasons. But if you haven't done that, this really smells like a very premature optimization.
Instead of serialising a list of objects, one JSON-object per line gives you the best of both worlds: incremental encoding/decoding and the cleanliness of JSON.
My first real program was a function to calculate the solution to any 4x3 Simplex method problem on my TI 81 calculator in middle school Pre-Algebra. The 45 minute exam had 3 simplex method questions. My teacher permitted me to use my program, so I was done in a few minutes.
Filippo Valsorda (CloudFlare) just left the following comment: &gt;All patches on this tree as of go1.5.3-cloudflare1 landed in 1.6. https://github.com/cloudflare/go/issues/8
My father taught me Clipper, a dBase III clone on DOS that he was using to write software for his medical center in his spare time. It was a great language to learn because it made it extremely easy to write to arbitrary positions in the terminal: SET COLOR TO B+/W CLS // clear the screen SET COLOR TO W+/N @ 10,10 TO 20, 20 DOUBLE // draw a box SET COLOR TO B+/W @ 11,11 SAY 'Hello' Coupled with the file-based database the language was designed around and few-second compile times, it was really fun. Since then, every GUI system I have used has seemed too complex and tedious to bother with, so I have ended up doing ever more abstract kinds of programming. I really want to see easy programming made easy again.
Like Brad, I first started programming in BASIC when I was 5 or 6 years old. My brother had a ZX81, which was the first mass-market computer in the UK. It came with only 1KB of RAM, but it had a great introductory manual (http://zxnext.narod.ru/manuals/ZX81_Manual.pdf). The next year we got a ZX Spectrum. Later I used an Acorn machine and learned ARM assembly. From a high school friend I learned about fractals and isometric plotting; Brian and I used Go versions of these programs in our book (gopl.io). The UK micro boom of the 1980s was a great time for young children to learn about computers because the machines of the time were affordable, simple enough to understand, basically indestructible, and not connected to a network. And they booted into BASIC interpreters, so even if you just wanted to play a game, you had to write a one-line program to load it.
It's worth pointing out that CSV is a lot less standardized than JSON. While there's [RFC 4180](https://tools.ietf.org/html/rfc4180), in the real world you'll find a lot of variations from that. I've dealt with reading and writing files containing millions of records of data as CSV, and I very much doubt speed of CSV vs JSON parsing will be a bottleneck for anything you're doing.
I think your API key is wrong.
Tried to find info on "LAX framework". No luck. Links?
You are missing the entire point. I echoed the exact selling points toted by the core community, and it was resisted as hyperbole. Only two things mattered- performance and portability. At that time, java was supreme ruler of both in regards to the choices of languages. Real world tests mattered. I argued java was on the way out and go was on the way in, and soon go will have the performance and portability of java. The rebuttal was that it may take tens of weeks to learn go but java is tens of years ahead of go in regards to performance and portability. I was managed by a team of management chosen by a consortium to lead various shared endeavors. I answered to them, my team answered to me. I was removed by management, they scrapped the go parts and went with java - so apparently the project that was in java,python,perl will be just java. This is exactly that- one data point. I have a few more where java was chosen over go from the start simply for the same two reasons:performance and portability. I'm sure others have similar experiences. Various benchmarks exist where go is in the back of the pack that are lead by c and java - I haven't seen many benchmarks where this isn't the case.
you can see the solution posted in the OP now; originally I was using os.create and os.open, which it seems don't provide the same options as os.OpenFile which allows you to set the append parameter. All the examples I was seeing used os.create and os.open; maybe my lack of experience is the cause of me not realizing what I needed to look up was more along the lines of "how to open files in append mode" rather than "how to append a slice to csv" which really didn't provide useful results. I'm betting if I had more experience in other languages this idea would have been more obvious to me... Thanks for checking in :)
&gt; for a superior solution Details? 
The 2.0 thing was really mean /u/bradfitz :c ^^^^obligatory ^^^^muh ^^^^generics ^^^^comment
Considering it strays off the path of the standard library, how is this better than Gin?
I don't follow what sum { X; Y } means. Is that a set of types? If so, how is it different than struct {X, Y} or interface {X, Y} (depending on what X and Y are)? The C equivalent of algebraic types is tagged unions, so for Go they would be something like: type Door { case Open struct{} default Closed struct { Locked bool } } Both Open and Closed would have type Door, so you'd use them like: func f(d Door) { switch d { case Open{}: case Closed{locked}: if locked [...] } } One of the advantages of this is that the built-in types can be defined in these terms, where type int { default 0 struct{} case 1 struct{} case 2 struct{} [...] } (You wouldn't have to literally write all that somewhere; the declaration would be pre-defined and built-in.) So the tag part of the int representation under the hood that identifies the case would be the size needed to identify all the int cases, which is an int/word; and since none of the int cases have fields, the total size of an int is just the size of an int/word. Edit: Continuing: So int as an algebraic type is effectively an enum.
It was suggested in another thread so I came to take a look. Thanks, I'll check that out. I forgot to mention that it's a mobile app, does that change things? 
I don't doubt your data point. It just seems like you're discounting Go because your particular org chose Java over Go in this one instance. I believe there are other instances as well, but I imagine there are lots of data points that go the other way as well. To put it simply, I don't expect Java programmers to make unbiased decisions when Java is an option (this goes for any language community, not just Java). Perhaps that's not what you meant to convey, but that's the sentiment to which I was responding.
https://golang.org/doc/go1compat specifically allows adding new struct fields. 
MySQL HTTP API if it's really that simply. :)
Did Alan share any details about TCP tunnels he built? I'm interested if he implemented IP-based routing or only port-base one?
A boring compiler and language spec is a good compiler and language spec!
This book is really boring. Who want to read through boring babble about one feature after another. This book is nothing like the 'The C programming language' , totally misleading book title. Just read [effective go](https://golang.org/doc/effective_go.html) and fill in the holes in your knowledge as you go.
Both Rob and Ken were interviewed, just like I was, but the company was a *lot* smaller then, so I imagine they were more informal about it.
Thanks for the explanation. At the time we considered algebraic types, we had had interface types for a couple of years and we were happy with them. We weren't going to tear that apart and start over.
Yes, that's pretty much what our discussions of sum types in Go looked like: an interface type with an additional constraint. We decided that allowing people to describe that additional constraint was not a big enough benefit for the additional language complexity.
I would be interested in a windows version. I have an arcade machine and want to sniff keyboard input and then use it to control 4 virtual joysticks via https://gowalker.org/github.com/tajtiattila/vjoy
If anything you had it harder compared to most new grads, given they were looking for very specific expert roles at the time. But then again you are an expert..
I added Segmented Sieve mainly to reduce memory usage. 
&gt; The pattern `./...` matches `./foo/x` and `./bar/x`. Why should `./vendor/x` be a special case? For the same reason `./testdata/x` is a special case. A `vendor` folder is not the same as a normal folder (where a "normal" folder is one that is not named `testdata` and doesn't begin with `.` nor `_`). &gt; The most compelling answer given is "because I don't want to run those tests every time," I think that's a less compelling reason. I'm more affected by the fact that when I try to regenerate all packages inside a big repository, and I type `go generate ./...` as I've done in Go 1.5, it will potentially try to modify files inside /vendor/ folder, which is not what I want. So now I'd have to do `go generate $(go list ./... | grep -v /vendor/)` too, which makes me pretty sad. Not because I'm lazy and can't do it, but because I have to tell everyone else that this is what you need to do in Go as of 1.6... I really hoped it wouldn't come to this by the time 1.6 actually came out.
This. The whole question sounds like premature optimization.
The Linux specific problem with Go binaries and upx [was fixed just in time for the Go 1.6 release](https://github.com/golang/go/commit/5e7110b92b959d22eba421953beaf1de8580f8f5).
In general Go is a simple language in design and tooling and fast to learn. [Rob Pike, Simplicity](https://www.youtube.com/watch?v=rFejpH_tAHM) It is highly readable and considerably fast. Overhead of creating a website in Go is not much more than other languages. Its static typing is kinda subtle and won't be in your way but will help a lot as project grows. Go in general is a very good pick and for some developers pleasing to use.
Do you know about llgcode/draw2d vector graphics library? 
For your first project in Go, you surprisingly understand quite a bit. The structure of your code is pretty good, everything has pretty good, descriptive names, data structures make sense. One thing that kinda irked me was the way the filenames in gructl/commands/ had _command.go after every file. That's unnecessary and slightly confused me at first. Other than that, great project and kudos. 
Yes, I tried it. But it doesn't support line cap / join styles, which was something I needed. Also draw2d has a lot of other stuff I'll never need, and I felt the API could be a little nicer. So I ended up doing this!
This seems like a good idea. Every time I work with Bolt, I end up writing some code like this that allows me to experiment with different codecs, and not have []byte(...) conversions littered all over the place. Still, not sure I'm willing to add an external dependency for that... Edit: also, obligatory link to goreportcard - quite a few golint problems that can be fixed: https://goreportcard.com/report/github.com/omeid/thunder
Makes sense! I'll give it a shot next time I'm starting a new project with Bolt :)
Nice article, I can strongly recommend the [talk](https://www.youtube.com/watch?v=F_xNOVY96Ng) that Alan gave at the Twilio Signal conference. It includes insight into ngrok itself, product development, getting user feedback, microservice deployment strategies and a bunch more. Really enjoyable talk. 
Have a look at the tests for now. I will add more examples soon. :)
It's got something to do with the permissions that the Apps Script needs. When you copy-pasted stuff into the function, you most likely added some additional permission dependencies that haven't been authorized. If you run the script from your Google Drive directly (pressing the play button in the Apps Script Project instead of executing it through the API), does it give you an authorization dialog? Also, you can check what permissions it needs by going to File -&gt; Project Properties -&gt; Scopes. I'm not 100% as to how to enable these scopes when you request get the access token for the execution API. I'm sort of struggling with it as well... edit: I think I fixed my issue - I had to add the following scope to my web-application when requesting the access + refresh token: https://www.googleapis.com/auth/spreadsheets because I was creating a spreadsheet from the Apps Script project that was being called by the Google Apps Script Execution API.
i think i was confused, sorry i thought there is a best practice for other languages that is not mentioned
There's no reason you should use csv. Write a json object per each line, and you will save your life. It's not about being fast, it's about being robust. By the time you really need a csv because your tool doesn't support json, then convert json to csv. Two main reasons compared to csv: **You can store one JSON object in one text line** That means reading and parsing json is a lot easier to parallelize (as long as your final algorithm is parallelizable, of course). While for a csv, if strings are encoded within quotes, a single csv record may span multiple lines, which makes it harder to parallelize. **JSON has data types: null, bool, number, strings** Csv has just strings without null, unless you have some kind of protocol (like the first row in the csv describes the types). That means you are losing information when exporting to csv: when importing you may need to interpret a "true" string as true boolean, a "number" string as a number, and an empty "" string as null, which may or may not be correct unless you have a clear schema of your csv. 
What's wrong with reopening each time? If it's an issue of performance hit, it's fine for my application... Any bigger issues to be worried about?
What version of Go? 1.6? Can you update with 1.6 and make it visible in the notes, if it's 1.5? Thanks Also 1.7 should be 10% faster? Thus edging nodejs out even after warmup. Still the results look great. Many thanks for doing this.
Ah, gotcha.
Last test not correct. Haskell dont use sparc in it.
Thanks for sharing. That was a great listen!
haha I'll agree that Thunder is a much better name. Stow is intended to be super simple. I see Thunder as a more flexible, but also slightly more complicated alternative. Good job though /u/gopherdiesthrowaway, I'd be interested in seeing some more examples on how to use it. 
Side note: you should always use the T, bool form of type assertions if you don't like panics 😉 Even if you're confident you'll only receive a specific type, it's still a good idea. For example, I've gone and changed my database schema before—forgetting to update my Scan method—which caused the type returned from the DB to differ from the one I wanted. Had I not checked, I'd have panics instead of pretty error messages telling me that I'm a terrible programmer. 
You have to admit, showing an image on the screen being outside the scope of a "graphics library" is a bit unusual.
The easiest thing to do is to use your code you have but instantiate the channel with a size of 1 http://play.golang.org/p/cBDXtett8N
It's not a windowing toolkit. It's more like cairo. The core of OpenGL doesn't do windowing either.
Create the code as: func doStuff(stuff int) error {
This might be useless but I seem to have problems ```go getting``` some private repos. This little utility performs a git clone into GOPATH, so it also contains the .git folder, let me know if its useful or not... Also if anyone knows how I can make this work with ```go install``` I would like to know!
Rule of thumb: Write synchronous APIs, let the caller be in charge of concurrency. You can use concurrency inside the API, but don't expose details in the API unnecessarily. (Necessary exception: when you know caller will want to integrate the call into a `select{}`.)
I'd like to point out folks that this isn't my work. 
What's wrong with using this in`~/.gitconfig`? [url "git@github.com:"] insteadOf = https://github.com/ That's been working great for me.
it won't be Go exclusive
We get a primary csv file which we need to work on. I've been doing just fine with the csvs, but someone from the team(2guys working in python) said we could read the csv and write the same thing to a new JSON file so they could work "faster".
I haven't done that, but i'm doing fine with the csv file. We get a primary csv file which we need to work on, but someone from the team(2guys working in python) said we could read the csv and write the same thing to a new JSON file so they could work "faster". 
I won't be the only one working with this, we are a team of 4 people, 2 in go and 2 in python. We get a primary csv file which we need to work on. I've been doing just fine with the csvs, but someone from the team(the 2 guys from python) said we could read the csv and write the same thing to a new JSON file so they could work "faster". 
Awesome! :)
Oh, like faster for coding time, easier for them to work with? That's definitely a valid reason, I thought you meant execution time of the program.
Wait does that combined with go get also pull down the .git directory? I've never checked haha
Can someone make a pr to make that a buffered channel please.
Mm am I alone in thinking the structure of go-bootstrap is kind-of... too package-y? I feel like it goes against the "Go way" of doing things and adopts a lot of MVC patterns from Rails or Django. An excerpt from [Organizing Go Code](http://blog.golang.org/organizing-go-code#TOC_5.): &gt; On the other hand, it is also easy to go overboard in splitting your code into small packages, in which case you will likely become bogged down in interface design, rather than just getting the job done. The best way I've found to structure projects is by having a package for each service (auth service, post service, etc). Each service would have `middleware.go`/`models.go`/`handlers.go`, etc. Then I would create a package for utilities (so like, response handling, logging, whatever functionality that gets repeated between services). Then each package can stand by itself, and can be included in other packages as needed. A good rule of thumb for Go is to try to keep everything as simple and obvious as possible. Don't try to get clever with project structure, it's not Node.js after all ;).
Hey Guys, I can follow up with Alan and get more on his experience building it in Go. I'll get another piece out next week. 
I co sign on this. I included the video in the blog post as well. 
Valid, educated points. As a quick way to get started, however, this tool saved me a whole bunch of time. It really helped me get over analysis-paralysis. You must admit, there are a million best ways to do things in go.
The Go Tour should teach you about all you need to get started: https://tour.golang.org/welcome/1
Yep, this was posted last week and everyone agreed that this benchmark is rubbish. [/r/programming](https://www.reddit.com/r/programming/comments/45qvwm/scala_erlang_and_go_compared_on_1111111_threads/) [hacker news](https://news.ycombinator.com/item?id=11098304)
&gt; In 1.6, they broke Cgo, and they do not plan to fix it. You link to a bug that's only 14 hours old, created on a weekend, and does not yet have any replies to it. How can you claim that "they do not plan to fix it"? Do you think we intentionally broke cgo just to spite you? Did it work in the release candidates and regress in Go 1.6 final, or did you not try the release candidates? I assure you we did not intentionally break your problem. By all means, if we introduced a bug and you can't upgrade, continue to use Go 1.5.3 for now. Hopefully we'll fix any issues that are reported in Go 1.6. 
I see. Thank you.
I had a lot of fun working through the small example problems on [exercism.io](http://exercism.io/)
Quick example: package main import "fmt" func f() (int, error) { return 1, fmt.Errorf("This is an error") } func main() { // As a normal function i, err := f() fmt.Println(i, err) // As a goroutine ic := make(chan int) ec := make(chan error) go func() { i, err := f() ic &lt;- i ec &lt;- err }() fmt.Println(&lt;-ic, &lt;-ec) } [playground](http://play.golang.org/p/BO_qF2qELh)
Very nice! I'll add support soon, but for now you can integrate it with: gometalinter --linter='unconvert:unconvert .:PATH:LINE:COL:MESSAGE' \ --message-overrides'=unconvert:redundant type conversion' Edit: [added](https://github.com/alecthomas/gometalinter/commit/494118e679c0b23182e4b076e9a935e10064f82e).
Thank you!
Appreciate it, it's been a while but I've written some vb/c# and a good amount of powershell so think I am good. That said I do plan on learning Python as well and have been toying with doing it first just due to resource availability. This is mostly for devops type stuff so I think either will serve me well.
I can't help but think that some of those things like "uint32(*(*uint32)(unsafe.Pointer(&amp;c.info._reason[0])))" are hacks that are there for a reason. (I just have no idea what that reason may be..)
Neat. Applying this to the go source, do you think it will increase compiler performance slightly?
Is this a single page application? Are there multiple services you may be authenticating with? How complex are your permissions and roles? What you suggest seems reasonable. Another method I've used quite successfully is to generate a JWT token (good info at jwt.io) that contains a list of specific grants that can easily be verified via HMAC, or public/private key signing. (The cool thing about using public/private keys is that only your auth service needs to know the private key so if a minor service is compromised somebody cannot generate keys...but this has CPU overhead on each request.) Then the only problem is short-lived token revocation and sharing these revocations between each service (or making I/O call to look up to see if a token been revoked). 
Last time I had to handle authentication in a Go webapp, I used pretty much your approach, but with the added note of all stored passwords was of course salted and hashed. For storage, I used Bolt since I needed something simple and preferable single-file. Your use-case might differ. Now, to be fair, this was a non-critical application for use in a semi-closed group (me, friends, friends of friends) but it serves its purpose. Preferably, you don't store passwords or hashes at all and instead dump the problem on Google/Facebook/Twitter/Github/Whatever using OAuth, but this might not be applicable depending on what you are doing.
I am sorry, I am utterly naive when it comes to context packages, Can't I work without them for my app? yes that was my plan, instead of holding session info in a global map like the gorilla/session does, we can store it in redis/boltdb and read the cookie for each request.
Define a third interface that implements A and B. type C interface { A B }
In Go, unexported methods in an interface are implicitly qualified to the package defining the interface type, so you can never "accidentally" implement that interface outside of that package. In that sense, it's not error prone at all. The compiler error you get will look something like: ./main.go:10: cannot use hopeful literal (type hopeful) as type b.Interface in argument to b.F: hopeful does not implement b.Interface (missing b.unexported method) have unexported() want b.unexported() As TheMerovius pointed out, you can still externally implement the interface by using struct field embedding, but as long as you're programming by behavior (not type-asserting to concrete types), and keeping your do-not-override methods unexported, the technique remains safe. In most cases, the better approach is to make no assumptions about the concrete type and just program against small behavioral interfaces (e.g. as the language is intended to be used).
fyi: [RobustIRC](http://robustirc.net/) is written in go too (and also contains an IRC demon) :)
I saw you closed the ssl PR... what a pity :(
looks awesome.
ah sorry ;)
So, what about Apache Thrift? It's also useful and have good features: maps in data types, exceptions. The library is similar to grpc but more mature.
I probably won't explain this the best way. But context package is used to pass information between functions that call each other. The description in that link offers a much better explanation.
Not really. Unnecessary type conversions have no effect on run-time performance. Theoretically removing them could speed up compiling the Go libraries themselves as there would be less code to parse and analyze, but I expect it to be negligible. My main motivation is just to make the runtime and toolchain code more idiomatic and remove all the ugly unnecessary type conversions that have accumulated from their origin as C code.
Your example requires the answer channel to send before the error channel can. I'd probably change it a little so you can receive in any order. Or maybe don't send a value if the error is non-nil. 
I used gorilla sessions and securecookie so I definitely recommend them. Something I did not mention was that my sessions "DB" was a gorilla sessions Store. I only used Bolt to store user credentials and other information gathered. But nothing stops you from using the Bolt DB as you described. You could probably even integrate it into gorilla if you choose to by implementing Store interface or find a exiting somewhere online. I did not really need Context or anything like it (the only point of the project was adding authentication by reverse proxy to a existing site) Never needed it personally, so I can not help you there. With BoltDB, you probably want to treat it like what it is, a bucket-based single file DB. So primarily read operations since they can execute concurrently. Have a clear heirachy in the data you do not have relations in the same way as a SQL DB. Since I only had the occational writes during logins, registrations and password changes, this was not a problem. On the other hand, I have heard of lots of people use Bolt for some pretty big projects, so I would not worry about performance of it in the first hand for this project.
I am thinking Python is the smartest move given all of the info I've received, the ease of availability around support and libraries, and the fact that so many tools and APIs offer up Python support. Thank you!
There's been two libraries that do this (plus a little more) posted here in the past week or so. Perhaps you can check them out to get some insight, or just use one of them: https://github.com/djherbis/stow https://github.com/omeid/thunder
https://www.youtube.com/watch?v=G2y8Sx4B2Sk :)
I've used this. Has many issues and author doesn't accept pull requests. Not very active.
Never saw this before! Looks interesting. Have you been using it?
I was referring to this loop: for i := 0; i &lt; cores; i++ { next &lt;- true } Can you explain why is it needed? Also try to avoid unnecessary arithmetic operations in `fillSegments` (e.g. you can calcualate `segSize*segNum` once)
Named interface types represent a reusable abstraction - we want to express some well defined notion by giving a name to a set of logically related methods. But you don't have to name everything, every possible combination of your named interfaces just because at some places you need that particular combination - otherwise you'll end up with an exponential explosion of names that you have to remember (and come up with in the first place) whereas it is pretty clear what 'interface {Stack; Serializable}' is for example (if you already know what Stack and Serializable are)
Most writer who criticize Go simply don't know why Go exists. This is just another one who missed the point: &gt; A noble successor to C indeed. But if there is something that C is not, is opinionated: it adapts to your style and is flexible enough to accomodate everyone. Alas, that is something that the creators of Go deemed unworthy of their time. 
True, it would be better to only send the error if it was non-nil, then have a select statement to receive.
Thanks, About the loop, next is a buffered channel, how else can I wait until all routines end after the loop? You are right about less calculations I tried precalculating many things. specially segSize*segNum and also tried to reduce the call time for slices like cseg, using globally defines slices to avoid recreating them. None of them worked. So I end asking here is I am missing any tricks in Go 
I just saw that! Yeah it looks quite simple to change how the counter is incremented. What's the "go way" to create a custom "ctr-prefix" version of this one? Should I get the whole "cipher" package and then compile it with my custom code?
This solution seems to be the best in my opinion. And, I can check for the capacity of the errchan to ensure one with size 1 is passed in. Thank you again!
Please stop linking posts like this. They serve no purpose other than shame the authors for their ignorance and desire to learn. Also, the blogs without a way to comment or with a moderation queue are bad as well as they don't encourage participation. And, again, pointless article is pointless. 
&gt; About the loop, next is a buffered channel, how else can I wait until all routines end after the loop? Oh, I see now. That is a bit hard to understand though unless you've seen this trick before. That is why I suggested to use `sync.WaitGroup` (https://golang.org/pkg/sync/#example_WaitGroup) that is more standard way of waiting for multiple goroutines to finish. &gt; So I end asking here is I am missing any tricks in Go There is almost nothing Go specific in your code. You should think how to optimize your program to perform less operations yourself. E.g.: - try removing division (by `basePrimes[i]`) as it is relatively expensive operation - maybe use `uint32` instead of `uint64` if you do not need prime numbers &gt;= 2^32 - use 8192 segment size so the whole segment fits L1 CPU cache - experiment with number of basePrimes, a smaller number might work faster The Go compiler doesn't optimize low level code as well as GCC at the moment. You can try compiling your program with gccgo and see if it makes any difference.
Using a mutex, particularly for read operations negates another important feature of Bolt: multiple concurrent reads.
2 Questions: - Why don't you actually close the Receiver in CloseReceiver? Like this it's more a RemoveReceiver, or? - Do you actually use this implementation somewhere? I ask because i found it (well, not your imeplementation, but similar ones) always not sufficient for any real projects. The major reason being that it totally blocks if one receiver does.
"Ending one of the joys of programming, the ease of copy-paste. Or you can define the variable ahead of time with this clumsy wart:" ... LMAO
That's an unfortunate name.
Right, or send a struct that acts a value, error type. http://play.golang.org/p/OcV6ROurjk
Just create your own type and define a XORKeyStream func that takes your type as a pointer receiver. In other words, you just have to implement the Stream interface. That's all the cipher.ctr type does. Notice that NewCTR even returns a Stream. Does that make sense?
True, I'll use Bolt to store the user credentials + session information everything else is SQL DB, I do not think I'll require context, But I do not understand where gorilla/sessions comes into picture, can't I write a custom session manager using boltDB? Using SecureCookie I totally agree because there is no other option on the browser side to store the sessionID
I'm currently trying /u/alexwhoizzle 's method, is there a cleaner way to do it? Thank you for your help.
That's what I'm doing right now, thanks for your input :)
Author here, thanks for your comment. It's a very good point you brought up. I admit it was my first time delving into reflect and it's dark magic. Do you know of a better way to handle unknown functions? I've been thinking if I could implement an interface like the sort library instead.
You're absolutely right. Never assume. I've updated the post so it uses the T, bool form for both assertions. Thanks for the tip :-) 
Yes, one of the nodes of robustirc.net runs on my server and I co-authored it (in the beginning. Haven't been active for a long while).