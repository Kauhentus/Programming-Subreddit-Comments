You are not long in the Go community, are you? ;-) I guess most have given up arguing and moved to a different language because they were told that Go2 (=breaking changes) would never happen. So while there is now some possibility to get needed features into Go2, the post of Russ makes it clear that the core team will not go through the hundreds of proposals (for e.g. generics) of the last seven years that went to the toilet because they would have introduced breaking changes (no matter how minimal). And I guess the people that did invest in the discussions are not motivated any longer or moved along. So without fresh blood there won't happen any needed change. It's kind of the same story as with package management where the core team did not want a solution and now it's kind of too late (yeah I know about 'dep' but frankly it is just a band-aid around misconceptions in the go tooling - like the mess of GOPATH, vendor directory and import paths). And it won't make package sharing less complex. That are kind of a social problems - not technical. 
Thank you for pointing out all these very interesting stuff to me! `foldr` still traverses the list from head to tail though. I think your explanation about why it shortcuts is wrong. It is true that it works thanks to non-strict evaluation, but it has nothing to do with the expression "making sense" (it type checks, so as far as the compiler is concerned, it makes sense).
nvm I found out how: classPtr := syscall.StringToUTF16Ptr("MediaPlayerClassicW") handle := w32.FindWindowW(classPtr, nil)
Also, you could simply do the following : func alter(a *int) { *a++ } Basically deferences the pointer to its value and increments it.
&gt; foldr still traverses the list from head to tail though. Yeah, but it's about *folding* and *not traversing* - that's why it's called `foldRight` in most FP languages because you fold from the right and with a single-linked list you need to get to the end first. &gt; but it has nothing to do with the expression "making sense" (it type checks, so as far as the compiler is concerned, it makes sense). False, for lazy evaluation to work the compiler needs to *build an expression graph* where it can remove the branches which don't make sense. Check out [this](https://hackhands.com/lazy-evaluation-works-haskell/) simple tutorial.
The obvious question would be: Is this a good way to do language design? Maybe they should have waited for a proper idea about how to solve the generic abstraction problem (with generics or alternatives). Maybe Go1 wasn't ready yet? This pattern repeated with complexity in package handling like GOPATH, 'internal' and 'vendor' directories, canonical paths, special file names etc.
appending is only cheap when the capacity is sufficient. From experience, pre-allocating a buffer in memory instead of allocating til max capacity is a factor of 1.5 to 2 times in performance until the cache is fully warmed. The reason is that if the capacity is not sufficient, you will most likely have to hit the runtime or even worse, malloc. In a tight loop, going into runtime or doing a syscall can shit all over the cache and worsen performance.
C'mon: you can do better than that.
Instead of crying and talking bullshit start to study the [state monad](https://wiki.haskell.org/State_Monad), the [ST monad](https://wiki.haskell.org/Monad/ST) and the [effect monad](https://hackage.haskell.org/package/extensible-effects).
&gt; False, for lazy evaluation to work the compiler needs to build an expression graph where it can remove the branches which don't make sense. Please read again that tutorial. That is not at all what happens, and this tutorial never talk about pruning "branches which don't make sense". The tutorial might be confusing, because the author shows the expressions completely "unfolded", but the runtime only "unfolds" what is necessary for computation.
no, you just compile it into the binary brah
&gt; Win32 API with Go why not just write it in c then, man.
The "what makes sense" question is answered by a heuristic expression reduction algorithm - the expression tree is represented as a graph and the compiler tries to *remove* the "nonsense" branches or *delay* them heuristically.
Please read that tutorial again.
Btw., this could be interesting to you: https://github.com/wbhart/bsdnt
Dude, the very first paragraph's title is "Basics: Graph Reduction" and it shows how it literally reduces the graph - by heuristically removing, transforming or delaying certain expression branches. &gt; ...we know that the two expressions (1+2) are actually the same, because they correspond to the same function argument x. To avoid this unnecessary duplication, we use a method called *graph reduction*. Every expression can be represented as a graph... Every block corresponds to a function application. The function name is written in the white part, and the grey parts point to the function arguments. This graphical notation resembles the way that the compiler actually represents expressions with pointers in memory. Every function defined by the programmer corresponds to a *reduction rule*... *Any subgraph that matches a rule is called a reducible expression*, or redex for short. Whenever we have a *redex*, we can reduce it, that is update the highlighted box according to the *rule*.
Yes but people still find it hard to get rid of their old thread pools that they know and love. :)) It will take time until they get used to having only one thread pool. People feel uncomfortable having less threads with less control over them. I like the FJP :P
The `append` function is a beautiful example of solving [more than a dozen different problems](https://github.com/golang/go/wiki/SliceTricks) without adding major complexity (generics) to the language and without suffering the performance problems associated with interface{}.
&gt; That's what I have done now. Rather than this: &lt;r&gt; eq .types.Person.Designation (.R.Get "currRole") | ge .types.Person.PerfScore (.R.Get "promoteScore") | .result.Put (promoteEmployee (.R.Get "promotedRole") .types.Person.ID) &lt;/r&gt; I'm refering to something like this: &lt;or&gt; &lt;eq&gt; &lt;types:Person field="Designation"/&gt; &lt;R:Get&gt;currRole&lt;/R:Get&gt; &lt;/eq&gt; &lt;ge&gt; &lt;types:Person field="Perfscore"/&gt; &lt;R:Get&gt;promoteScore&lt;/R:Get&gt; &lt;/ge&gt; &lt;result:Put&gt; &lt;promoteEmployee&gt; &lt;R:Get&gt;promotedRole&lt;/R:Get&gt; &lt;types:Person field="ID"/&gt; &lt;/promoteEmployee&gt; &lt;/result:Put&gt; &lt;/or&gt; which is **just** XML. Obviously I'm improvising here because I'm unfamiliar with the semantics. But you could take the approach of considering tags as functions which your automaton can execute and their children as arguments. You can build an expression tree like that.
It's pretty trivial, to write your own [protoc-plugin](https://developers.google.com/protocol-buffers/docs/reference/other), FWIW. If your conversion is sufficiently automatic, it might be worth giving that a try.
Weird reasoning. Maybe he doesn't want to touch C
Ask him why he hates generics and progress.
Oh that's a reallly neat idea! Will try this out with some complex use cases. Thank you!!
Hello, I come from PHP and what's this bitcoin thing? It says if I don't pay they won't give me back my MySQL server. Also, why do I have to restart Apache every hour? Hi I come from Haskell and why is my monoid in the category of endofunctors slow? Howdy I'm a corporate enteprise vice executive Java development engineer and do I really need my IntCreatorFactoryServiceProviderInterface?
have a look at https://github.com/metakeule/fmtdate its tiny and should do what you want 
&gt; Dude, the very first paragraph's title is "Basics: Graph Reduction" and it shows how it literally reduces the graph - by heuristically removing, transforming or delaying certain expression branches. &gt; Here is a better [visualisation](http://felsin9.de/nnis/ghc-vis/#more_examples). of how this works. There is no pruning taking place ever. Only thunks being forced when necessary.
Have a look at Authboss (https://github.com/go-authboss/authboss). It includes email verification and password reset functionality and also provides OAuth2 login. Future v2 will also support JWT if that floats your boat. And you are right, implementing it on your own is risky and is best example of reinventing the wheel.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/hackernews] [Microsoft is Hiring Go engineers to work on Kubernetes](https://np.reddit.com/r/hackernews/comments/6o9jh5/microsoft_is_hiring_go_engineers_to_work_on/) - [/r/sidj2025blog] [Hacker News: Microsoft is Hiring Go engineers to work on Kubernetes](https://np.reddit.com/r/sidj2025blog/comments/6o81nu/hacker_news_microsoft_is_hiring_go_engineers_to/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
That's a pretty terrible visualization. But what do you expect to happen when evaluating a fibonacci function?
You didn't read my post. I'm not using Haskell. I also didn't say it was bad,I like Haskell, I just said it was more complicated.
Yes, but why not have more built-in generic funcs, like `keys(myMap)` and whatnot? ISTM that they covered a lot of ground with `append` and `copy`, but didn't take things far enough.
This is awesome. I work with Kubernetes (OpenShift) a lot now and I love the platform and really like seeing the community that has been built around it.
&gt; You didn't read my post. Yes, I did and you're arguing about how contemporary pure FP languages manage state. You say "side-effects" are disallowed which is not true in any way - you can do side effects AND track them on the type-level which is the recommended way. &gt; I'm not using Haskell...I like Haskell... Seems legit. &gt; I also didn't say it was bad... You've also used the term "nightmare" and you were raging about functions which can be easily googled. &gt; I just said it was more complicated... to google what certain functions do? You haven't shown any proof to support your claim.
I was introduced to the Kubernetes source code by an Redhat Kubernetes Core Contributor. He showed me the nasty parts how they solved the lack of generics. Actually they use strings to concat valid go source code based on reflections. A little tedious but given the constraints for language choice they had (fast, compiled binary, close to the metal) I think Go is still a decent choice for Kubernetes.
I like this job, would fit me well. Probably can't apply from Europe right?
Wait, you think I'm using Haskell and that's why you are upset with me? Also, why did you make a new account just to keep attacking me about you not reading my posts? 
Last time I looked at Azure openings, they were mostly in the US. Job posting says the following so I assume not: &gt; Locations &gt; &gt; United States, Boulder (CO)
&gt; He showed me the nasty parts how they solved the lack of generics. Actually they use strings to concat valid go source code based on reflections. i guess that would be the kind of stuff RSC is interested in with respect to Go2... 
&gt; Wait, you think I'm using Haskell and that's why you are upset with me? Nope, I see that you're not using hs and you've said it too - you've used sml and a haskell-like language. Also, I'm not upset - we're laughing our asses off on gophers' "wisdom". &gt; Also, why did you make a new account just to keep attacking me about you not reading my posts? I'm at work and I don't know my password :P
Hi arschles, please check your DMs :)
So, the short answer is "yes".
Hey thanks for the reply, I reran with the modifications you suggested and this is what I come across: Step 1/10 : FROM golang:windowsservercore ---&gt; 1b648944b381 Step 2/10 : RUN powershell iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) ---&gt; Running in 569422c65e8f failed to create endpoint mystifying_darwin on network nat: hnsCall failed in Win32: The remote procedure call failed. (0x6be) The "failed to create endpoint " error was actually the same error I get on the **RUN go get .** line. So it might be a network issue after all...
Maybe he doesn't write C. I have a 10 year career with of C#, Python, Go, JavaScript, TypeScript, VBA, VBScript, SQL and never have I written C. Could I? Probably... do I want to? Yeah, I enjoy learning. Do I have time? Not right now.
I think the short answer is "no". The replacement evaluation criteria mentioned is EXTREMELY common industry wide for peer review processes.
If you want to learn the language, take a look at these two very simple tutorials: - [Go Tour](https://tour.golang.org/welcome/1) - [Go by Example](https://gobyexample.com/)
Thanks for the reply. 
&gt; without adding major complexity (generics) to the language It *is* using generics, just generics that you can't use for your own functions. &gt; solving more than a dozen different problems You know what's nicer than a dozen? a hundred, or a thousand. User-level generics could be used to solve *many* problems, rather than just a dozen.
For easier comparison I processed your results with `benchcmp` (with a small modification) gives: benchmark old ns/op new ns/op delta BenchmarkAdd/{big,gmp}_1000+1000_bits-4 40.1 165 +311.47% BenchmarkAdd/{big,gmp}_10000+10000_bits-4 174 932 +435.63% BenchmarkAdd/{big,gmp}_100000+100000_bits-4 1904 8888 +366.81% BenchmarkAdd/{big,gmp}_1000000+1000000_bits-4 19112 86743 +353.87% BenchmarkSub/{big,gmp}_1000-1000_bits-4 46.2 177 +283.12% BenchmarkSub/{big,gmp}_10000-10000_bits-4 180 936 +420.00% BenchmarkSub/{big,gmp}_100000-100000_bits-4 1915 8576 +347.83% BenchmarkSub/{big,gmp}_1000000-1000000_bits-4 19131 83854 +338.31% BenchmarkMul/{big,gmp}_1000*1000_bits-4 752 2992 +297.87% BenchmarkMul/{big,gmp}_10000*10000_bits-4 38969 229189 +488.13% BenchmarkMul/{big,gmp}_100000*100000_bits-4 1569143 22437345 +1329.91% BenchmarkMul/{big,gmp}_1000000*1000000_bits-4 63995349 2241657949 +3402.85% BenchmarkDiv/{big,gmp}_1000/500_bits-4 1027 1397 +36.03% BenchmarkDiv/{big,gmp}_10000/5000_bits-4 21175 58539 +176.45% BenchmarkDiv/{big,gmp}_100000/50000_bits-4 1636243 5544318 +238.84% BenchmarkDiv/{big,gmp}_1000000/500000_bits-4 163576948 558114619 +241.19% BenchmarkRem/{big,gmp}_1000%500_bits-4 975 1252 +28.41% BenchmarkRem/{big,gmp}_10000%5000_bits-4 20844 59146 +183.76% BenchmarkRem/{big,gmp}_100000%50000_bits-4 1642758 5541698 +237.34% BenchmarkRem/{big,gmp}_1000000%500000_bits-4 162648875 556512561 +242.16% benchmark old allocs new allocs delta BenchmarkAdd/{big,gmp}_1000+1000_bits-4 0 1 +Inf% BenchmarkAdd/{big,gmp}_10000+10000_bits-4 0 1 +Inf% BenchmarkAdd/{big,gmp}_100000+100000_bits-4 0 1 +Inf% BenchmarkAdd/{big,gmp}_1000000+1000000_bits-4 0 1 +Inf% BenchmarkSub/{big,gmp}_1000-1000_bits-4 0 1 +Inf% BenchmarkSub/{big,gmp}_10000-10000_bits-4 0 1 +Inf% BenchmarkSub/{big,gmp}_100000-100000_bits-4 0 1 +Inf% BenchmarkSub/{big,gmp}_1000000-1000000_bits-4 0 1 +Inf% BenchmarkMul/{big,gmp}_1000*1000_bits-4 0 1 +Inf% BenchmarkMul/{big,gmp}_10000*10000_bits-4 1 1 +0.00% BenchmarkMul/{big,gmp}_100000*100000_bits-4 1 1 +0.00% BenchmarkMul/{big,gmp}_1000000*1000000_bits-4 8 1 -87.50% BenchmarkDiv/{big,gmp}_1000/500_bits-4 1 0 -100.00% BenchmarkDiv/{big,gmp}_10000/5000_bits-4 1 0 -100.00% BenchmarkDiv/{big,gmp}_100000/50000_bits-4 1 0 -100.00% BenchmarkDiv/{big,gmp}_1000000/500000_bits-4 2 0 -100.00% BenchmarkRem/{big,gmp}_1000%500_bits-4 1 0 -100.00% BenchmarkRem/{big,gmp}_10000%5000_bits-4 1 0 -100.00% BenchmarkRem/{big,gmp}_100000%50000_bits-4 1 0 -100.00% BenchmarkRem/{big,gmp}_1000000%500000_bits-4 1 0 -100.00% benchmark old bytes new bytes delta BenchmarkAdd/{big,gmp}_1000+1000_bits-4 0 8 +Inf% BenchmarkAdd/{big,gmp}_10000+10000_bits-4 0 8 +Inf% BenchmarkAdd/{big,gmp}_100000+100000_bits-4 0 8 +Inf% BenchmarkAdd/{big,gmp}_1000000+1000000_bits-4 1 8 +700.00% BenchmarkSub/{big,gmp}_1000-1000_bits-4 0 8 +Inf% BenchmarkSub/{big,gmp}_10000-10000_bits-4 0 8 +Inf% BenchmarkSub/{big,gmp}_100000-100000_bits-4 0 8 +Inf% BenchmarkSub/{big,gmp}_1000000-1000000_bits-4 1 8 +700.00% BenchmarkMul/{big,gmp}_1000*1000_bits-4 0 8 +Inf% BenchmarkMul/{big,gmp}_10000*10000_bits-4 1408 8 -99.43% BenchmarkMul/{big,gmp}_100000*100000_bits-4 13649 8 -99.94% BenchmarkMul/{big,gmp}_1000000*1000000_bits-4 207769 8 -100.00% BenchmarkDiv/{big,gmp}_1000/500_bits-4 176 0 -100.00% BenchmarkDiv/{big,gmp}_10000/5000_bits-4 1408 0 -100.00% BenchmarkDiv/{big,gmp}_100000/50000_bits-4 13617 0 -100.00% BenchmarkDiv/{big,gmp}_1000000/500000_bits-4 157441 0 -100.00% BenchmarkRem/{big,gmp}_1000%500_bits-4 112 0 -100.00% BenchmarkRem/{big,gmp}_10000%5000_bits-4 704 0 -100.00% BenchmarkRem/{big,gmp}_100000%50000_bits-4 6583 0 -100.00% BenchmarkRem/{big,gmp}_1000000%500000_bits-4 91829 0 -100.00%
Except that append is generic. Avoiding generalized generics resulted in some functions that are snowflakes, which provide features that cannot be replicated by users for other purposes. It's a very practical solution to a hard question, but it means that slice and map are special in a way that no other container type can be, and not all problems are efficiently solved with those data structures. This is fine while your alternatives are relatively simple, but it leaves things like LLRB trees (which probably take hundreds of lines of code and tests) out in the cold unless you accept those performance issues. For me, this is the most irritating part of the "I don't have in my mind a clear picture of the detailed, concrete problems that Go users need generics to solve", when the Go team solved some of their own issues with generics.
That shouldn't be possible. edit: Oh, possibly their careers page might have lower capacity.
LUL I wouldn't delete the subreddit even if the content isn't the best. Reddit is where I get a ton of news on stuff I'm interested in, plus this place has cool articles sometimes. I get the hate for spez though.
Interfaces are the way to go.. I don't see anything really complicated there.. You could have an `App` struct that takes in the `Wrapper`, then inject it into your handlers like [1] func createPost(a *app) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { defer r.Body.Close() } //app could look like this app struct { Cache CacheInterface DB WhateverInterface } //Then on initialization of this struct, you do `wrapper.GetXX` for the corresponding properties. [1] https://github.com/adelowo/mockdemo/blob/master/main.go#L92-L96 Shameless plug https://lanreadelowo.com/blog/2017/07/06/mocking-go/ (talks about isolation of the database)
I'm using something like this type Store interface { GetFollowers(userID string) ([]models.User, error) } type DatabaseStore struct { // wrap sql connection // or any other driver that your database needs } func (s *DatabaseStore) GetFollowers(userID string) ([]models.User, error) { // get users from db // can be any db, e.g. PostgreSQL, CouchDB, MongoDB return users, nil } type CacheStore struct { // embed any other store // this also makes unimplemented store methods just pass through Store // cache internals } func (s *CacheStore) GetFollowers(userID string) ([]models.User, error) { // return user from cache if it's there // if not, get from underlying store user, err = s.Store.GetFollowers(userID) // error check // add user to cache return users, nil } // easily instantiate any configuration you need store := CacheStore{DatabaseStore{DB: db}} This configuration also makes testing and mocking a lot easier
&gt; If they are buffered, closing them before the reader is done reading will destroy any values in the channel. Closing a buffered channel that has values in it yet to be read does not destroy them. The reader will read out the buffered values before seeing the channel close. Or do you mean something else?
&gt; For easier comparison I processed your results with benchcmp (with a small modification) gives: Thanks! I didn't even know `benchcmp` can work on a single result set (?). The results nicely show minigmp's multiplication lacks the Karatsuba multiplication that math/big has.
Why not to use `&lt;&gt;` instead of `[]` when people already used to it from other languages (java, c++, rust)? type List&lt;T&gt; struct { Value T Next *List&lt;T&gt; }
&gt;Maybe he doesn't write C. I have a 10 year career with of &gt; Do I have time? Not right now. Well, it's been 10 years. Sounds to me like you just need to make the time for it. If you like Go, C will come a bit more naturally. 
&gt; First of all, I hate angle brackets, so that's why I use square ones. This is the only reason, there's no rational one. EDIT: and it's really not important, feel free to replace [] with &lt;&gt;.
I would be disappointed if Go's take on generics was to make everything an interface. First of all, this would be incongruent with its builtin generic types, and secondly it would leave a lot of performance on the table (more GC pressure, less inlining). 
At this point, Go and C are similar enough to where it seems like it actually would be easier to work with Win32. If he was working in Java or C# or even Rust I'd see the point in dealing with it, because they're all very different from C in their own ways.
Nothing prevents the compiler to fully specialize the code for the given generic type to gain performance, it's very similar to inlining. Just from the point of the view of the language and its typesystem, it may appear as an interface inside the generic functions.
Well, my point was that Go isn't the simplest syntactical language out there. Java is probably the simplest, if only because Python has weird semantics with scoping and major power features, etc
&gt; If it looks shit, but makes you a ton of money, it's probably not shit. If you just want money from software, please, just get to management or something but don't code. &gt; I can only assume you've never seen those hard to fix bugs that take weeks to fix? LoL I've fixed bugs after *months* of meditation and doc-digging... &gt; Why do you distinguish your good programmers by their shitty websites? Not mine, I was talking about the popular ones. &gt; For me is the ones that work fast I can work fast too and let interns suffocate in my crap :P &gt; or they're the tech leads who do the architecture. Meh, they can be mediocre too. Tech leads used to have good domain knowledge and programming is just a secondary skill set for them. For great programmers, better have a look at those who design and code a simple and great system which is easy to maintain.
I'm noticing a lot of people giving me negative post values. I assure you, I wouldn't be asking if I didn't need a solution. The raw values out of HTML input are not being parsed by the time.Time type natively when my struct is pulled. So I am not sure why people are being so negative on this.
Here's a modified version that doesn't use bytes.Buffer. Activating/deactivating the cache now makes almost no difference. package gopad import ( "unicode/utf8" ) // pad pads out a string // it uses given rune slice with // first value or space by default for filling a space // it has caching for common use cases // and buffer for quicker concatenation func pad(s string, l int, ch []rune, di bool) string { l = l - utf8.RuneCountInString(s) if l &lt;= 0 { return s } c := ' ' if len(ch) &gt; 0 { c = ch[0] } r := string(c) bs := make([]byte, 0, len(s)+l*len(r)) if di { bs = append(bs, s...) } for ; l != 0; l-- { bs = append(bs, r...) } if !di { bs = append(bs, s...) } return string(bs) } // Left pads out the lefthand-side of strings func Left(s string, l int, ch ...rune) string { return pad(s, l, ch, false) } // Right pads out the righthand-side of strings func Right(s string, l int, ch ...rune) string { return pad(s, l, ch, true) } 
I've done it two ways before. &amp;nbsp; First is one struct for data access that has both caching and database interfaces in it. I used boltdb with an auto expiring cache system. Simple API and allows for auto handling of cache misses, distributing load, and quick integration. I used "parallel access" so cache misses didn't add to the db access time. This one was low turnover and small amounts of data. &amp;nbsp; Second one was a cache layer that also handles the database. This was larger amounts of data, with very high turnover. I used batched writing on the database and a cache only read system for performance. &amp;nbsp; Both were a single struct and used an api like data, err := db.Get(key) and err := db.Store(key, data), and everything else was internal to the package. I eventually added Write and Read functions so I could use it for simple io.
I've never seen a job listing that says remote for MSFT but I've been told they have them on some teams. No idea how you find those openings if you are looking though.
&gt; Nothing prevents the compiler to fully specialize the code for the given generic type to gain performance No, but the compiler doesn't do this now, so I don't have much hope that this optimization would be added to boost generics. Besides, what's the advantage of modeling generics on interfaces if not the ease of implementation? Put differently, if you need to build this optimization to get decent performance, why not just implement template generics like Rust or the builtin Go types?
Thank you for spending the time to do this! I'm extremely interested with using MIDI in Go, specifically [SDS](http://www.4front-tech.com/pguide/midi/midi8.html) / SDMI sample dumps. Hopefully you will venture into those areas as well, or maybe I'll do some PRs. Either way, happy to see this.
The reason to build generics on interfaces is that generic functions often require their type parameters to satisfy some conditions (Java's extends and super). This is completely achievable in Go by attaching an interface type to a generic argument and everything follows very naturally from there. And I belive that if Go 2 implemented these generics, it would specialize for concrete types, at least sometimes. Just like with inlining.
Huh, you're right. I was mistaken, taking the [Channel Axiom](https://dave.cheney.net/2014/03/19/channel-axioms) "A receive from a closed channel returns the zero value immediately" too literally. Dave even has [an example that shows I was wrong](https://play.golang.org/p/KcmnLYNlzL) on that page. Thanks for the correction!
&gt; I'm noticing a lot of people giving me negative post values. My best guess is because your post/question lacks details but most importantly you are blaming the `time` package instead of trying to solve your problem or at least explain it us so we can help. &gt; The raw values out of HTML input are not being parsed by the time.Time type natively **when my struct is pulled**. What does that mean? Did you try the code of [this](https://www.reddit.com/r/golang/comments/6o2ya3/better_timetime/dkelhsj/) comment? Write a simple example on Go playground of what you are trying to do and what doesn't work so we can talk with some code.
Are you [hit8run](https://news.ycombinator.com/user?id=hit8run) on HN? Here is the identical comment in the discussion there: https://news.ycombinator.com/item?id=14803879
For the people downvoting: give some constructive criticism! This post is just an idea, it's not a proposal. It's not something that's going to be implemented, it's something to be discussed.
I was only looking for a package. I didn't think code was necessary when I'm looking for a few suggestions. I am using him web framework and when I bind the body to a struct, unless I manually preformat it in my angular4 typescript, it will error from the date formatting in HTML. 
and I wish copy worked with maps, not just slices
I have no plans to do so (yet), but join the Google group and let's see, if we can make a package for it beneath github.com/gomidi
Why wouldn't you apply and see the result ?
You can want to take advantage of the significant features of Go and also simultaneously want to work with the Win32 API
So would you be able to put anything other than interface{} after your type letter? None of the examples do that I caught, so I wonder why we need that word there.
Generally you do your job for a while then someone determines that you can work effectively remotely. There is no direct positions that are inherently remote. 
Yes of course, you can put any interface there. Just imagine any use-case where you would use 'extends' or 'super' in Java generics.
We are definitely considering remote for the right person! Many of the ex-Deis team is not located in Boulder. For anyone considering the job, but not located in Boulder, we're looking for people who can work on US timezones as amerine2 said. Also, expect to travel about once a quarter to Boulder or Seattle/Redmond.
FWIW, my slides will be up today as well. I'll post on Twitter (@arschles) when they are.
Not at the moment, forgiveangel.
We're considering remote employees, but you'd have to work on US timezone hours daily. If that works for you, you can absolutely apply. I wrote up a little more about our expectations for remote employees [here](https://www.reddit.com/r/golang/comments/6o2lc3/microsoft_is_hiring_go_engineers_to_work_on/dkfruqx/?utm_content=permalink&amp;utm_medium=api&amp;utm_source=reddit&amp;utm_name=golang)
alright, well I'll reach out in a year with more experience
Why not use TLS instead? If you're trying to write your own crypto, be careful. It's highly nuanced.
I think he have Reddit account. Hi Dave! My question would be: what are top three programming language that you like? And why? Thanks for the answers.
While this is nice for existing employees who want to transition to remote, it pretty much eliminates anyone who already works remotely from applying.
Thanks for the follow-up. &lt;3
I am, Just thought maybe i should add another layer of protection... TBH, i am not that well versed in how TLS works and if the data can be sniffed or caught in a MITM attack.
Python's rather more complex than Go these days, tbh. Decorators, iterators, generators, coroutines, metaclasses. It is higher-level, though. Lisp, well, I just can seem to get my head around it. One day, though, and on that day I shall be enlightened. 
&gt;The "get out of here" post ... maybe Was mostly meant as a tongue in cheek comment but I would tend to agree about negativity in this forum. This is at least his 4th new account posting it over the last year+, so I have no regrets trying to be edgy. 
It's more appropriate to bring multiple accounts up to the mods, than to bring public negativity to the subreddit.
gott_modus is basically a C troll account. Their post history is littered with low-effort posts that simply say: &gt; why not just write in c then, man. Seriously, he just uses that same response multiple times, in multiple threads.
Simplicity is progress
Yeah, the mods are discussing it. I agree that it is a detriment to the subreddit to have every post by Kataras turn into a flamewar. I don't endorse what he's done with his project, but at the same time, it's not explicitly violating the Go CoC. What I'm trying to say is that it's tricky, and I hope everyone can try to stay courteous so that we keep r/golang as a great space to read about Go.
It can't, that's why TLS exists, to give you a secure channel over which to communicate a server and client. Just google how to use TLS with Go and you'll be on your way. The TLS library is very easy to use.
Answered this myself in case any one stumbles across it. https://stackoverflow.com/questions/45196950/gorilla-sessions-persistent-between-server-restarts/45197671#45197671 Use `gob` when you put the data in **and** when you try to take it out.
&gt; Just thought maybe i should add another layer of protection... For what specific reason? Is there a limitation or vulnerability in TLS that you are concerned with? If not, you are just overcomplicating your code and rebuilding the wheel when there's a great TLS package part of the standard library
I agree that generic types need constraints to be very useful. For sake of clarity, let's use Rust's terms traits (static interfaces, specialized) and trait objects (like Go's dynamic interfaces, not specialized). Your proposal seems to be to use trait objects in all cases and let the compiler decide when to specialize them. Unfortunately, Go's interfaces are runtime constructs, and reflection means it's not so simple (how does specialization handle `fmt.Println(reflect.TypeOf(interface{}))`? Should this print `interface{}` or `int`/`string`/etc?). Plugins are another case that makes specialization non-trivial. Basically, I think it's better to introduce a trait concept instead of trying to make Go's interfaces work as type parameters.
The problem is to to don't add a new problem when you want to resolve others... 
Specialization is really a non-problem for a number of reasons. var x interface{} = 3 fmt.Println(reflect.TypeOf(x)) // prints int, even in Go 1 So following from here, the answer to your question is obvious: it prints the concrete type. Reflection and calling other functions accepting interfaces is also a non-problem. Generic types can be specialized, but when passed to functions accepting interfaces, they simply get boxed, just like in Go 1.
TLS is designed for this, also, keep in mind that encrypting data with a public/private key has limitations in data length, TLS gets around this by seeding the symmetrical encryption with the public/private key so you can stream data. I would probably lean on the expertise of the more experience for your encryption requirements, as this is a field of many land minefields. Edit: Also from the DOC : WARNING: use of this function to encrypt plaintexts other than session keys is dangerous. Use RSA OAEP in new protocols. https://golang.org/pkg/crypto/rsa/#EncryptPKCS1v15
Just found this post via Google. Perhaps post this in /r/DestinyTheGame? You'd probably get more volunteers there.
Not a bad idea. Thanks for the tip 
Ever seen a VC++ template compiler error?
Glad you posted this! It will likely come in handy when I rewrite TwitchInstallsArchLinux in Golang and try to boot it up again. 
You're going to want to use tls as others have said. It's not a good idea to use asymmetric encryption to prevent eavesdropping of arbitrary payloads. For example here as soon as your data exceeds the key size your encryption call will fail. The first mistake developers then make is ... putting it in a for loop. Now you have the slowest encryption scheme concatenating ciphertext and spitting it over the internet with a public key. The real issue is they often encode a API key or some form of secret to validate the payload, often because it's an integration into existing system and tech debt yadda yadda. The danger here is now on any large message a carefully crafted attack can reuse the first Keysize bytes to attempt to alter the remaining cipher text for evil doing. You need a way to identify yourself to the endpoint for future request once your a known entity to them. Well maybe you google message authentication and tack that on, more to get wrong. So yea, use TLS :-)
Sorry, that example was from memory. Here's the more pertinent one: `var iface *(interface{}); fmt.Println(reflect.TypeOf(iface).Elem())`. Besides that, there's also plugins; we can't specialize types we don't know at compile-time. These are the barriers I see to replacing dynamic interfaces with static interfaces aka unifying dynamic and static interfaces. So specialization is a barrier to unifying static and dynamic interface concepts. If we can't unify these, we have to choose between retaining distinct concepts (traits vs trait objects) or accept a performance hit when generics are used (but interestingly not if those generics are builtin?). If we retain distinct concepts, we should make the distinction unambiguous and use distinct terms and syntaxes for each, at which point we basically have templates.
I see. I live in London. What hours during US timezone do you need to work in? There seems to be 6-7 hours difference between UK and Boulder.
I believe so, yes. Though there's still the issue of converting the `Id` field name into `ID` and the type from string to `bson.ObjectId`. 
Not just that unfortunately, there's converting the Id field to and from `Id string` and `ID bson.ObjectId` 
Your code looks pretty good, but it looks like you're only allowing for one callback function per OnMessage. You could turn that into an slice of functions and iterate over the slice to call each function. You could also play with nested maps like map[string]map[int]func(). So the map would look like ["OnMessage"][0]callBackFunc(1), ["OnMessage"][1]callBackFunc(2), etc.
I don't think having to refer to this doc whenever one needs to perform a relatively standard operation is a big win. I use it often, but I would greatly prefer to just be able to call an `Insert` method.
Well, yeah, sometimes it's impossible to specialize. But that's not that big of a problem, it's also sometimes impossible to inline or allocate on the stack. But Go does both of those things. The same would be with specializing. Go would figure out if it's possible to specialize, and based on some predictable heurestics, it either would or wouldn't specialize.
I'm not the author but I've had very similar thoughts. One example would be for generic sorting; you can make your elements have a LessThan interface that allows the sort to complete. In fact most of the generics _I_ want to write (YMMV) wouldn't actually be on `interface{}`, but with something specific.
&gt; First of all, this would be incongruent with its builtin generic types, Not really, they just have implicit `interface{}` in their special-purpose specification that you can't see, because there is currently no syntax to express them in. Once there is a syntax, `append` becomes `func append([]&lt;T interface{}&gt; s, t... &lt;T interface{}&gt;)` or something. The interface is used to say what the generic methods on the generic types must be able to do with the methods. How much performance you leave on the table is up to the compiler and how much work we're willing for it to do. In theory it could, as pointed out in the other thread, do specialized implementations for any given type, which could in theory go so far as to inline the method implementations and do further optimization based on that, if for instance if obj.SomethingOrOther() { ... } could be proved to be always false for some type (perhaps because the body of that method is simply `return false`). I'll cop to not having stared at all the generic proposals, but building them on top of interfaces seems to me to be the least disruptive to Go. Anything else that tries not to inevitably ends up duplicating concepts out of the interfaces in Go. I don't know if there's a whole lot of them that do. I've sometimes referred to interfaces as "the parts of generics that Go does in fact have". Which tends to ruffle feathers because people have gotten particularly emotionally invested (on both sides!) in the idea that _Go doesn't have generics_, therefore anything that may be described as "generics" must be something Go doesn't have. But I stick by it. Interfaces are not generics, but they _are_ halfway there. The best plan to get full generics is to keep moving that ball forward, not pick up a new ball. In fact... _technically_... if this proposal was done correctly, I don't think it would even have to be Go "2". It could just be a point release on Go, as it would not invalidate any previous Go code at all.
Good stuff Kris. We used kops to get our infrastructure up and running. justinsb was a huge help in slack in the early days.
Woo! I love hearing the success stories! Kops is so baller 
Do you think your work on kops will diminish since you released kubicorn? Any chance of any of that work making it back into kops, like the kubeadm support?
I will still continue to support, love and do everything I can to help kops and sig-aws. One of the big motivators of kubicorn was giving the community an opportunity to try a new approach in the name of experimenting. So right now kubicorn will get most of my Saturday's, but ideally my work on both will help us (the community) understand pros/cons to each approach. Kops offers way more in bootstrap land than kubeadm (and thus kubicorn) can do on at this moment so I don't know what the motivator would be to switch entirely. Happy to talk about it on Kops office hours if you want!
Right, so why choose the implementation that might specialize when we want it to over the implementation that reliably specializes when we want it to? Particularly when the latter implementation seems much more straightforward? Not trying to be a dick, I just can't seem to get you to answer this question.
With Python you don't have to worry about memory addressing, though. And the code is fairly terse. To each their own, of course.
This article feels distinctly inferior to, and not aware of, https://blog.golang.org/pipelines and https://blog.golang.org/context They go through a lot of complexity (atomics! CAS! "LevelCloser"!) for what seems like just bad decision in structuring the app; it just seems like all of that could be avoided, even easily.
Awesome. I've been using k8s since 1.2 and would love to help out once the craziness of shipping a 1.0 product dies done a bit at the office.
The pipeline is basically using signal channel and sync.WaitGroup. That is the first section of the blog post. But, we need more than that. The same signal can't be sent to all the stages, and the stages are not directly dependent on each like (not consuming other's output, at least directly). In a way, this is an encapsulation of the concepts of pipelines, in a more complex environment, required by Badger. Contexts can't be used here. You can cancel them, you can't wait for them. Have a look at the usage in Badger, the link is in the article. Maybe that'd give you a different perspective.
You're asserting that there can't be issues, I'm giving a real life counter-example. Here's another - template specializations can be really hard to understand if you support them.
[removed]
Happy to help you get involved in either project if you choose :)
`func NewCookieStore(keyPairs ...[]byte) *CookieStore` `keyPairs ...[]byte` changing key pairs = invalidating the sessions
Live and let live. 31,831 readers(subscribers), 18 upvotes. I don't believe the support you claim is there actually exists. There is a fine line between opinions and vitriol. I recall a few years back that those in support of generics were treated with just as much distain. *Yea, get mad and downvote without rebuttal. move along troll. You don't have the cognitive resources to compete. I just scanned your /r/golang comments, all vitriol - nothing with any value. Lets do this again five Sundays from never.
I have 200+ accounts. Most are burners. In the reddit world this is a unfortunate circumstance of how reddit works. I have accounts for specific subs that I won't use anywhere else, others I use in multiple locations, and then there are others I use everywhere. This simple tactic keeps the trolls in check. If they don't like my comment then tough titties, but to hell if they are going to shadow my every move on reddit in an attempt to troll me. reddit realizes this, that is why account creation is so easy. You shouldn't be the least concerned with multiple accounts. */u/FIuffyRabbit, yea, get mad and go on downvote tantrum. move along troll. You don't have the cognitive resources to compete. This is the exact reason why multiple accounts on reddit exist. Thank you for proving my point. Lets do this again five Sundays from never.
&gt; 31,831 readers(subscribers) How many of them are active? Threads don't get many votes often. &gt;I don't believe the support you claim is there actually exists You what? I didn't claim anything, I made an edgy comment and people liked it.
tour.golang.org is the best place to start to learn the language. golang.org has all the documentation you need.
18 trolls liked your trollish comment. I have seen this sub have between 200 to 500 active/live users. 240 are here now as I type this comment. Only the mods know the numbers, but I assume this sub gets thousands of unique viewers each month. *Yea, get mad and downvote without rebuttal. move along troll. You don't have the cognitive resources to compete. I just scanned your /r/golang comments, all vitriol - nothing with any value. Lets do this again five Sundays from never.
The `:=` symbol is part of a short variable declaration, a statement that declares one or more variables and gives them appropriate types based on the initializer values
I'm not saying that generics must suck, but they're tricky to get right as evidenced by the number of languages that have issues with them. I think that's a perfectly pragmatic reason for saying: &gt; The problem is to to don't add a new problem when you want to resolve others... They can add problems. They have added problems. Adding them without doing so is a key challenge.
I'd like to, but there are a lot of things to do out there, and I haven't gotten into drivers, graphics, kernels, hardware, etc and have enough on my plate for a while with APIs, web frameworks, data processing, and various other things that don't need C. Perhaps I'll force some time this weekend on your suggestion.
append is generic, in the sense that it is polymorphic- it accepts many types. now, what is being asked, is that this mechanism be extended to all types, my types, your types, his types, her types - custom types. the performance of interfaces is not the issue, the issue is the loss of type safety when using empty interfaces to make up for the language shortcomings.
https://golang.org/ref/spec#Short_variable_declarations
Why not just work with UNIX timestamps?
Well, that's fair enough. As we get older it can be hard to feel motivated for things which don't have direct application - I don't blame you.
I have data already that I have to keep in a mongo. I could do that, but if I understand correctly, I would have to go through each existing value and rebuild it.
&gt;For me, this is the most irritating part of the "I don't have in my mind a clear picture of the detailed, concrete problems that Go users need generics to solve", when the Go team solved some of their own issues with generics. how would constraints be implemented for all types? should generics be a compile time mechanism or a runtime feature? Generics is a catch-all for a bunch of disparate things - i dont know how it got that mucked, but it did. so now I think the questions to be asked now is what type of generics do you need? how would you implement that in Go and still be backward compatible? My answer is custom type-safe polymorphic container types. I would suggest a compile time preprocessor switched on with a knob. I would suggest building on ideas found in go:generate, go:oracle, /go package, and a talk by Robert Griesemer 'Prototype your design!' to create a new type of type model that would define constraints, then your generic types would be designed to accept models, these models could be very specific(int64), vague(comparable), or extremely abstract( interface{}). From what I understand about the generics problem in Go is that Go needs a mechanism to facilitate the construction of custom type safe polymorphic container types, with the notion that such reusable code would save time, and reduce errors, with very little cognitive strain. the request is simple. the solution should be simple - a rewriter. done is good. The catch is that this rewriter must be part of the standard distribution, but as a tool, this layer could make new compatibility guarantees, and as such, this tool would have time to grow, mature, standardize. this new tool has a stable foundation of those things firmed by the go 1 compat to build upon.
Interesting to hear how Dropbox on-boards engineers who are learning Go. 
What's the usecase there though. I'd rather have the user implement 1 function and then just use a channel to share the messages with other functions. 
Oh you wrote that? Awesome, the idea was funny as hell 
I can't take all the credit for it, but it certainly was an experiment in sysadmin hell (they kept pulling up porn on the desktop, not to mention the DDoS). I look forward to using your library :) 
cause it's c. 
I think this is a very good approach to a readable and usable generics syntax. Unfortunately, syntax appears to be the least of all problems that need to be solved, see [the official generics discussion document](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/preview). 
I'd like to read about the conditions they've found where the race detector doesn't help.
So dropbox has just 200,000 business customers. That seems really low. Unless each customer has a bunch of users underneath it. 
Well, if you read carefully, this is not about syntax, but more about semantics of generics. I agree that syntax is the least important.
If you describe "the latter" more precisely, then we can discuss if it's better or worse. What I expect is that any approach to generics which does not work with interfaces will need to duplicate interfaces in some way, which is a terribly non-Go way.
Constructive criticism: You are talking about the wrong thing. This isn't a new idea to anyone on either side of the aisle; it's pretty much the same syntax as any other generics implementation (java, C++, rust…). That's not the interesting question. Interesting questions are things like "how is type-inference going to work, so that you don't have to spread brackets all over the place?", or "how are they going to be implemented? Boxing vs. Templates vs. something else?" or "what things can be made generic? Types? Functions? Methods?"………… Not only can the answer to any of those questions invalidate whatever syntax you came up with before; answering them will likely make the correct syntax self-evident. And that's exactly why the go team wants experience reports: They are supposed to answer these kinds of questions.
Isn't really a golang thing, more of a general protocol/architecture thing. Mostly dependent on the use case. I have a solution in https://github.com/jpillora/velox though there's a few ways to do it.
My fault - I admit having read the article very quickly. Still, the point I tried to make is that there are a couple of things to consider besides syntax and semantics, such as: * How difficult is it to implement this * Is this approach slow at compile time * Is this approach slow at run time * Does it lead to bloated binaries * Can the compiler still issue understandable errors * Which other language features might be affected by this * Are there any edge cases to be considered If you read through the "Generics approaches" section of the aforementioned document, you'll know what I mean.
Why is 200,000 business (i.e. paying) customers really low? That number should produce a fairly nice and consistent income stream.
Map, slices and arrays already use [] to show the type. It sort of makes sense to use the same syntax.
What if I don't want to use Glide? All of my projects use dep.
Thanks for the feedback! I would argue that this is not an entirely old idea. The idea naturally answers most of the questions you are asking. Type inference: When possible, generic types can be inferred based on arguments/fields and when this is not possible, explicit type arguments would be provided. Note, that inference does not require any recursive agorithm here, like in other languages, because Go has no type hierarchy. Boxing vs templates: Since this idea builds on interfaces, the answer follows very naturally: its up to the compiler. IMO, template style specializing should be done similarly to inlining and stack allocations. Compiler should use some heurestics to determine when that's appropriate. What things: Types are a must for this design. But functions can only utilize generic types if they can be generic themselves, so functions too. Methods are not distinguished from functions in this design. This design brings more advantages. Makes it possible to call Go 2 code from Go 1. It interacts very orthogonally with the rest of the language. Note, that it simply creates a way to define types more DRY, it does not add almost any new concepts to the type system. An own generic Slice type would follow very similar rules as the bullt-in. Slice[int] would still be not assignable to Slice[interface{}], and so on. Maybe my post is not entirely clear about these things.
Please read my answer to TheMerovius where I answer some of your questions. And the rest. Implementation difficulty: without specialization, this is trivial. Specialization might be a bit tricky, but it's not hard to see how it could be done. The important part is, that specialization does not affect any semantics. Compile time / runtime performance: this is a compromise between specialization and boxing. Compiler should decide when to do which to achieve the optimal compromise. Errors: Since error checking is not deferred until specialization, errors would be very clear, for example: "type of x must be same as type of y, but isn't (int vs interface{})".
Should `struct{}{}` be used this generously, even in examples? Why not make it a bool chan for the sake of simplicity?
Nice project! I did something similar (https://github.com/simia-tech/netx). It's basically TCP over NATS (or consul, dnssrv, ...), but it can be used for gRPC too.
Why chan bool is simpler than chan struct{}?
&gt; When possible, generic types can be inferred based on arguments/fields and when this is not possible, explicit type arguments would be provided. Note, that inference does not require any recursive agorithm here, like in other languages, because Go has no type hierarchy. In your post, you write var l *List l.PushFront(2) l.PushFront(3) l.PushFront(l.Value.(int) + l.Next.Value.(int)) Now, how is this supposed to look? The var-declaration doesn't naturally contain the element type, so you either need to use non-local information (making compilation slower and complicating the spec), or it is going to require explicit annotations (i.e. no inference). Similarly, to when such a type is used as an argument or return value. Can fields be generic types? If so, how does type-inference work then, without "recursive algorithms"? Those algorithms don't exist for fun or their own sake, they exist so that you have to type less and not clutter your code with type-annotations. This question needs a *specific answer* (and that answer can't just rewrite this example; you need to say *how it works*) and that answer will inform syntax, not the other way around. And it needs to be rooted in good arguments, for why one or the other is preferable. &gt; What things: Types are a must for this design. But functions can only utilize generic types if they can be generic themselves, so functions too. Methods are not distinguished from functions in this design. What about receivers? Can they be generic? How would generic functions look? How are type identifiers scoped? This is intertwined with the previous question; how would the signature of a method on a List look? Does it require explicitly giving the type-parameter (leading to syntactic overhead) or doesn't it (leading to confusion about what "T" is supposed to be here)? &gt; Boxing vs templates: Since this idea builds on interfaces, the answer follows very naturally: its up to the compiler. IMO, template style specializing should be done similarly to inlining and stack allocations. Compiler should use some heurestics to determine when that's appropriate. This is what Java (or Python) is doing. Why is that the way to go? As others have pointed out here, this is critical for the performance of generics and probably too important to just leave up to vague hopes. Slices, channels and maps are at the center of pretty much every go program. Their performance matters. And a generics proposal needs to encompass the current generic builtins. Otherwise that's a spec-smell, as you'd end up with two different, non-orthogonal kind of generics. As [Ian Lance Taylor points out](http://www.airs.com/blog/archives/559), if we had generics from the beginning, append and copy wouldn't be builtin; the new spec should basically be as if we'd always had generics in this regard. Which brings me to: &gt; I would argue that this is not an entirely old idea. The idea naturally answers most of the questions you are asking. It doesn't, though. If anything, it *assumes* answers to these questions (but even that is an overstatement). It doesn't give any indication of why the assumed answers are correct. Or what would happen, if the correct answers turn out to contradict the assumed ones. And this is exactly why the go team asked for experience reports and why bikeshedding syntax is very premature. These questions need careful answering based on observations of the kinds of problems you want to solve. Your proposal is, in it's essence, just a superficial "hey, look, we can add some brackets and then we have generics-syntax"; yes, that *is* an entirely old idea. At least what your document actually contains (as opposed to the implicit assumptions you are seemingly making) is already implemented in Java, from what I can tell.
It's simpler, so to get the point the reader doesn't need in-depth information about an empty struct and its (Go specific) syntax.
Ok, but why it's simpler? What in-depth knowledge about struct{} one needs to have in order to use it?
Use single SQL query updating all resources instead multiple queries inside multiple goroutines.
I did a little digging in stdlib and it looks like chan bool is preferred over chan struct{} in tests (at least a couple places I checked out uses chan bool as chan struct{}). I still would prefer chan struct{}, but that's how it looks like in stdlib tests. *shrugs* $ ag 'chan bool' | wc -l 589 $ ag 'chan struct{}' | wc -l 163 In regular code chan struct{} seems to be prefferred. $ grep -rinH 'chan struct{}' . | grep -v '_test' | wc -l 88 $ grep -rinH 'chan bool' . | grep -v '_test' | wc -l 46 I enormously love Go for its context-free nature, so you can find out such things with a simple grep.
No way. Because every primary id is unique, can not update more than 1 row by 1 query statement.
Well, it looks like magic for starters. I don't think you need to optimize an example that much, sacrificing readibility to some extent.
What is the condition for updating the rows? You can use the WHERE for other things than id Assume you have a table like this: Id, value 1, 10 2, 15 3, 6 Etc. You can then do Update t set value = value * 2 where value &gt; 8; That will double the value in all rows where the value is already more than 8.
There is an official MSI installer: https://golang.org/dl/
Depending on your day library you can batch queries, so you don't have to wait for 1 query to finish, but rather can send them all to the mysql server at once.
I hoped that most of the stuff was relatively obvious from the article, but I might have been unclear. I'm being a little vague sometimes, because I hope that the things I'm silent about are obvious, but that might be wrong. Ok, so one by one. var l *List This is an example from Go 1. In my idea for generics, a generic type is incomplete without the generic arguments, so this wouldn't make sense. Since there are no struct fields to infer the generic argument from, you'd need to write: var l *List[int] What about receivers? Receiver is just another argument to a function in regards to these generics, so this is how you do it: func (t *Type[T]) Method[T Interface](...) { ... } And yes, each function or method requires explicit generic type annotations, but Go already requires explicit receiver annotations, so I don't think this is something special. Now, regarding the inference algorithm. Inference should work for struct literals and function and method calls. In a struct literal, let's consider the set of fields. In a function or method call, let's consider the set of arguments. For each element in the set of fields/elements, infer the type according to this algorithm (yes, this is recursive, but just in regards to the type structure, other languages do much more). If it's a direct instance of a generic argument, infer the type using the same method as with := statement. After this inference is done, check whether all instances of the same generic argument (arbitrarily deep within the structure) have the same type (int, float64, interface{}, fmt.Stringer). If not, raise a compile error. This is not a formal description, but should be understandable. If not, please tell me, I'll elaborate. And yes, this idea/proposal has some assumptions about what is good and what is not. If experience reports prove those assumptions wrong, I'll be more than happy to accept that. Maps and slices are fully expressible with these generics (except for nice operators): type Map[K, V interface{}] struct { /* ... */ } func (m *Map[K, V]) Get[K, V interface{}](key K) (val V) { /* ... */ } func (m *Map[K, V]) Set[K, V interface{}](key K, val V) { /* ... */ } type Slice[T interface{}] { /* ... */ } func (s *Slice[T]) Len[T interface{}]() int { /* ... */ } func (s *Slice[T]) At[T interface{}](i int) T { /* .... */ } func (s *Slice[T]) Set[T interface{}](i int, val T) { /* ... */ } This proposal is similar to what Java does, that's true, but it does it in the light of Go. Because Go has no type hierarchy, extends and super are not required at all. Also, in Java you can have a "typeless" instance of a generic type (List, instead of List&lt;Type&gt;), which doesn't make sense here. In this proposal, List[int] and List[interface{}] are different types that are not assignable or convertible to each other.
Dropbox also charges a freaking fortune so they're making off with it.
As I said. I already have pure go envitonment on dev machine. But get external libs is stikl painful 
I suspect this is more of a MySQL issue than a Go issue. In my experience this is one of the tradeoffs between SQL and NoSQL. Your DB is likely to have a table lock, so when you get above a certain number of concurrent operations per second your DB operates serially. Investigate if it is possible to shard your table. I haven't experimented with this personally, since I usually go for another type of DB when there are heavy write operations. Of course you could also look into doing what you are doing in another way, but since you didn't describe the problem you are solving there is no way for us to help.
How do you transfer files from the internet PC to the dev PC at the moment? Are they local network connected or do you use USB drives etc? If you're running "pip download" for python I don't see why you can't run "go get" for Go but I may be missing something in your setup. If you can get Go running at all on the internet PC (you can just download the zip file from https://storage.googleapis.com/golang/go1.8.3.windows-amd64.zip and set the GOPATH variable manually) then you should be able to just copy the entire GOPATH from one PC to the other. You shouldn't really need admin rights at all to develop in Go so you may be able to do everything on your internet PC without manually syncing files to the dev PC.
8 A.M. to 5 P.M. would be 1 P.M. to 9 P.M. here. That might be manageable. 
The fact that a VC puts up money doesn't change the fact 200,000 business users would generate quite a large income stream. At a very conservative (and probably way to low) $1,000.00 per business, per year you have $200 Million in annual revenue. I'm pretty sure it's numbers like that the VC would have enjoyed seeing before deciding to invest. 
Generic constraints would need at least "comparable to" definable mandatory constraint - or you can end up with pointer types which will be compared by address instead of value in your generic collection for example. 
&gt;How do you transfer files from the internet PC to the dev PC at the moment I have folder-shares over my PCs. I cannot use USB and its not one network, but has sort of internal mechanism for antivirus check etc. I gess I should try protable go. Does it download packages with all deps ? (I gess so but should ask)
"Go get" is the equivalent to "pip download" here. Have you tried running it? It's surprising that you'd be able to use pip that way without an internet connection.
The decision on what package manager should be used for a project, especially in a lack of De facto and De jure standards, is extremely ungrateful task. At the current moment Glide is preferable for many reasons in our projects, but I believe this question is discussable. Please, do not hesitate to open an issue in GitHub so other contributors could participate in this topic. According to the roadmap of the dep tool https://github.com/golang/dep/wiki/Roadmap, this tool will be part of the default Go toolchain in 2018 anyway.
If you currently have folder shares then you may want to look at a portable proxy server on the internet PC and then set the system proxy on the dev PC to point to that. I haven't had to face this issue in many years, but there should be a few portable proxy apps that you can run on non-privileged ports that will allow you to share the network connection from the internet PC to the dev PC. If you just use the ZIP file and set GOPATH manually on the internet PC you should be able to just do dev normally on the internet PC. If you can share the GOPATH folder between the 2 PCs then you can do all "go get" commands on the internet PC and then develop on the dev PC. &gt; Does it download packages with all deps ? Go only comes with the standard library. If you want 3rd party packages you will need to "go get" them.
I use pip in internet-PC. It has portable version. 
I canmot use proxy or what evar coz its no direct access there. So only files. 
I have use Golang's tx to solve this problem. tx, _ := db.Begin() tx.Exec("sql", param) tx.Exec("sql", param) tx.Commit()
My condition is id, where id = 12345 or where id = 78901 I use tx to solve this problem. tx, _ := db.Begin() tx.Exec("sql", param) tx.Exec("sql", param) tx.Commit() P.S.: How can I write code in reddit....
https://github.com/go-pg/pg even if you don't use it as orm, at least it properly handles reconnections, context, listen/notify.
Wow, another one, will take a look. There is also https://upper.io
A very small package that extracts a given struct to an array or to a map. There is option to ignore fields or to use the tag names as key on the struct. Any feedback is welcome!
So a couple of things. * Don't trust an article that doesn't even get the name of the programming language right. It's "Go", not "GO" nor "GOlang" or "Golang". * You don't unit-test your database, you just don't. You unit-test your functional units. * Your tests should be self-contained. You can't expect to have someone running mongodb on their machine just to run the tests. * Mock out the database by writing a FAKE database session, not a "real mock database", that's not a thing. Testable code depends on interfaces, mock those interfaces. PS: did you notice the article is about **integration** tests and not unit tests? 
Do it in two queries. This isn't a problem to solve using go. First, update the ID so that there will be no conflict with the desired range (e.g. id = id + 2000001), then use a second query to set the id to the desired value (e.g. id = id - 2000000). Alternatively, add a new column, set it to id+1, delete the old column, and rename the new column.
Hmmm, then what's the point of dbtest if not to make these temporary db's? Also, wouldn't mocking the whole mgo.Session be overkill? I mean wouldn't that mean I'd have to mock all the methods I use on the session, either that or check if it's a real dbsession or mock dbsession and act accordingly?
I'm not suggesting an answer or solution - I'm saying that to suggest that there's no well defined problem for what generics would be used for is a strange assertion to make if you've already used them.
&gt; what's the point of dbtest It's an integration test for the `mgo` driver itself. &gt; wouldn't mocking the whole mgo.Session be overkill? Probably. It's also difficult to get every edge case exactly identical. Thankfully, you don't need to mock the entire session. You just need to mock the interfaces your code depends on. In most cases, that just create, read, update &amp; delete. If that's not the case, then the first step would be to read about separation of concerns, information hiding, command/query segregation, etc. It's not easy to write testable code.
Just looking at the top language this ranking seems pure bullshit, Lets just look at the source: http://spectrum.ieee.org/ns/IEEE_TPL_2017/methods.html Personally I haven't even heard of half of these websites and the scale its bound to be heavily biased based on the choices, if you chose Linkedin instead of CareerBuilder you would probably get extra points for all JVM language, if you chose EU centric websites instead of US centric websites you'd probably, again, see a huge difference. Could be just stop caring about these metrics all together ? "Popularity" is a vauge term and it can be used to say whatever the fuck the author of the study wants it to say, because popularity is not a measurable value. Average wages are measurable, gross income of companies is measurable, number of employees is measurable, speed of generated asm is measurable, lines of code are measurable, google searches are measurable, projects on github are measurable... at lot of programming related things are, popularity is not, by definition, measurable because it doesn't have a strict enough definition.
I guess I'll read more on this, thanks for your input.
While all these metrics are flawed (and will be until global telepathic surveys are implemented), the changes over time are still relevant, as well as some comparisons between two similar languages. Furthermore, seeing that you know 2 to 6 top 10 languages on most ranking lists means you're looking to the right things as you invest in your skillsets. Perhaps someone outside stats is moving into a stats role and has never heard of R. Seeing it high on a list like this might give them the insight that it's a widely used tool. You could also use this type of data to realize that Objective C really is giving way rapidly to Swift or that C# is far larger in marketsize than VB.net. All of this is valuable information even if the "competition" between C# and R is totally meaningless. And the Java vs C# numbers might also be fairly rough as well. The competition and ranking might only serve to make the data exciting to read, and if that's the case, I'm glad for the narrative.
In my experience the fastest way to update a large number of rows to unique values that can't be calculated (assuming that's why you think you need multiple queries?) Is to use bulk copy https://github.com/denisenkom/go-mssqldb/blob/master/examples/bulk/bulk.go I'm not sure there is a mysql equivalent. But if there is. You bulk copy in a set of rows with the primary key and the new value into a temp table then do an update statement with an inner join to the new table then delete the temp table. Mssql bcp can do hundreds of thousands of inserts in less than a second
 BEGIN; UPDATE table SET col1=value1 WHERE id=1; UPDATE table SET col1=value2 WHERE id=2; UPDATE table SET col1=value3 WHERE id=3; ... UPDATE table SET col1=valueN WHERE id=N; COMMIT; This way you can update thousands of rows in a single request. Run all of this in one or multiple batches/transactions and you're good to go. As others have pointed out, this is not a golang problem.
All metrics are not flawed, that's my point, you can look at many metrics about a language that make sense. Combining them into a giant "POPULARITY" metrics with no clear definition using an arbitrary formula, however, means that those otherwise reasonable metrics will now mean garbage, because depending on your formula you can make the popularity metric say whatever you want it to say. Also, looking at the top x languages from a metric to decide which language to learn is exactly the kind of mistake this metrics might make people do, since a newbie programmer might look at this metrics and decide PHP, R, C# and C99 is a fine set of language to master, when instead he could just ignore them, learn language that he enjoys and probably end up being better suited for the "job market" a few years.
Your problem is partially that you're changing the primary key very incrementally and doing it with transactions, so you're incurring a lot of cost in practically every place you could. You've got the transaction log cost as well as potential table locks - It's a db issue, not a Go issue. You have to find a better way of doing it - preferably something that doesn't involve hideous locking or transaction logs. I'd be looking at the possibility of creating a new table with the same schema and filling it in a single operation, then deleting your original table and renaming the new one.
I'm trying https://github.com/olahol/melody instead of using gorilla/websockets directly for my current project.
Your best bet is to just download and unzip the ZIP version of Go onto the internet PC and set the GOPATH variable. This is effectively a "portable" version of Go. You can then do all dev on the internet PC. You basically unzip the file somewhere and then modify your local "PATH" variable to include the "bin" directory that you just unzipped. This will allow you to run the "go" command from your command prompt (cmd.exe or powershell.exe). You then need to setup the GOPATH. Create a folder that you want to develop your code under (can be anything) and then set a GOPATH environment variable pointing to this folder. You should then be able to use "go get" etc without problems.
&gt; Reliability of 99.9999999999% (twelve 9s) Does anyone know what the units are? Bits/year lost?
Overall pretty good. A couple of minor nits: https://github.com/gempir/go-twitch-irc/blob/master/client.go#L14 naming is typically camelCase and this doesn't need to be exported so switch to ircTwitch https://github.com/gempir/go-twitch-irc/blob/master/client.go#L73 printing conn when there was an error calling dial(), it is almost certainly going to be empty https://github.com/gempir/go-twitch-irc/blob/master/client.go#L96 If len(messages) is zero, the range statement on L99 won't do anything so this check isn't needed https://github.com/gempir/go-twitch-irc/blob/master/client.go#L109-L110 why use fmt.Sprintf inside a fmt.Fprintf, can do it all with the beginning fmt.Fprintf https://github.com/gempir/go-twitch-irc/blob/master/client.go#L126 fmt.Sprintf() isn't needed, just use c.send(strings.Replace(line, "PING", "PONG", 1)) https://github.com/gempir/go-twitch-irc/blob/master/client.go#L155 break isn't needed since not in a loop https://github.com/gempir/go-twitch-irc/blob/master/client.go#L169 declare func(channel string, user User, message Message) as a type like callback and then the On*Message func definitions will look cleaner Cheers! edit - some additional notes
The complexity is the part that seems unwarranted. *shrug*
&gt; I didn't even know benchcmp can work on a single result set It can't. That's the small modification I mentioned.
The one thing that these tools all suck at is joins...relationships are the whole point in using relational databases! Do people really just create a bunch of structs for each join?
&gt; the code is fairly terse "terse" does not equate to "simple". Usually the ability to write terse code requires very non-simple language features that make the code harder to read. The goal should be writing maintainable, readable, and robust code. The goal should *not* be minimising the number of lines of source code (that's [code golf](https://en.wikipedia.org/wiki/Code_golf) which can be a fun game/exercise but should never be done in practice). 
**Code golf** Code golf is a type of recreational computer programming competition in which participants strive to achieve the shortest possible source code that implements a certain algorithm. Code golf should not be confused with sizecoding, a contest to achieve the smallest binary executable code. Playing code golf is known as "golf scripting". Code golf tournaments may also be named with the programming language used (for example Perl golf). *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
If you want to do joins you can do it on the db side when you fire your query. Are you suggesting doing joins on the go side? 
I guess one creates a struct inside the function that has all the resulting columns..
As said by others this is smells like a design issue (xy problem). As long as you feel you must update one by one the problem will exist, as each record no matter the concurrency will need to lock the table while doing work. Without the reasoning for your "I have to clause" no one can really help. Questions I would ask someone who came to me with this: * can you get updates in smaller batches? I.e. more aggressive polling for example without implications for that system? * does this update edit every record in the table? If so you are not editing a table, you are replacing it. So do that instead, as suggested in thread. If this is the case it sounds more like a cache and should be designed with a storage system more suitable for it. * if the update intervals are fixed and the data is updated than can you change the way you partition your data and shift some responsibility to readers to aggregate across new tables? I.e insert records into new table with a naming convention suitable for your retention / rolloff, like table_update00N and have a table that keeps a counter clients can check for the current update ranges, deleting tables as they roll out of range.
This blog post is more for intermediate users who are already familiar with `chan struct{}`. Using a `chan bool`, or `chan int` would be strange for people who have been using Go for a bit and harder to justify, given the memory use implications.
Looks like you're doing your own IRC parsing/message composition. That's fine, but there are a few great libraries that help with that. I'm a fan of https://github.com/sorcix/irc, might save you some trouble with unexpected bugs.
Yeah...no, that's not how it works. They just move on. 
I’m curious: are MS employees obliged to use windows and PCS?
I did something along the same lines a while back - my memory might be a bit fuzzy and the case might be a little different. What I found to be fastest was LOAD DATA INFILE with indexing disabled. In my case, I was using Go to pull data from a bunch of sources, I'd write the data to files (I broke them up into reasonable chunks, 1GB I think), then turn off the indexing on the tables, load the data from the files to the database and re-enable indexing. I think I was working with ~50 million lines of data on m3.large and I could everything in ~45 minutes. Not sure if that helps.
TLS is extremely secure as long as your certificate authorities are trustworthy and your crypto libs are up-to-date. If you're really worried about security, look into certificate pinning and configure your server to only use stronger crypto suites (something like the "modern" configuration [here](https://wiki.mozilla.org/Security/Server_Side_TLS#Recommended_configurations)). If you want to get really fancy and your application allows it, you can look into also using client certificates, but I've heard that getting that working is a colossal headache.
SO R is number 6? R is cool, but umm #6? Looks like nonsense to me.
Nope. In fact, all of the ex-Deis team got Macbooks from Microsoft.
Most of the boulder team are on mac books. Running Mac OS X. Though there are a number of things that are easier in windows, like changing passwords for your domain account.
Plenty of jobs in my area that ask for R. Mostly data science and such, probably not as popular with devs though. 
Officially no. But there is a budget for rewards and so the leaders have to allocate that budget among their employees. So there "isn't" a stack ranking. But the leaders have to decide who receives how much of the reward. Internally lots of people say the real change was we lost transparency. The real question is are employees backstabbing each other. I think that varies team to team. I've been lucky enough to not deal with that. And it is part of what my team talks about when hiring people is that we want team players.
Using http://go-search.org/search?q=json+patch, this popped up: https://github.com/evanphx/json-patch
Neat!
The error is that you should reslice differently. You should write `io.ReadAtLeast(file, data[0:100000], 100000)` and `io.ReadAtLeast(file, data[100000:600000], 500000)`. Read more about slicing slices [here.](https://golang.org/doc/effective_go.html#slices) Also, right now, both of those calls should be returning errors. Remember to handle your errors! You would have spotted this bug instantly, had you not ignored the errors. I hope this helps!
Hashes impl io.Writer, you can use io.Copy and avoid such a massive buffer like that. If filesize is less than 1mb just io.Copy(hash, file), in other case use the fact file is a io.Seeker to use the same copy method. You would call Copy twice, once with your file wrapped in a LimitReader of 100k, then again after a call to file.Seek with a limitreader of 500k. After your final call to copy on either method call Sum with nil to get the hash. There are more efficient tricks we could use here but this is clear and correct.
gofmt your code!
Neither `master` nor the `v2` branch has ircv3 tags, which OP uses in their library. And IRC parsing is easy and testable enough that I'd personally rather spend the 5-6 hours doing it than leave the maintenance and decision making to such a core component to a third party.
FYI There's a way to calculate the hash as you write to it, no need send everything to a buffer.
Do you want CRUD, or so you actually want to use the SQL Database Query engine?
Another misconception about goroutines/threads. Goroutines/threads help with responsiveness... they don't increase overall performance. Matter of fact, the reverse is true. The more goroutines/threads being utilized... the slower the overall application performance. Like suggested here, optimize your SQL call and do away with all the goroutines doing the handling for you.
misleading title. there were only 10 languages on this list
Yeah I know a lib could do that for me but I have to parse custom twitch stuff anyway and I wanted a clean Lib without any dependencies So I just went with my online parser 
No, a join would be in the SQL database, but the results returned are usually marshaled into a struct (see upper or sqlx for example). So do people create these big structs with both fields from table a and table b when they are joined? 
Just leaving this here for others... http://fuckinggodateformat.com/
I think the problem is that you only read from your connection once. Look at this: package main import ( "bufio" "fmt" "log" "net" "os" "strings" "sync/atomic" ) func dowork(c net.Conn) { scanner := bufio.NewScanner(c) for scanner.Scan() { msg := scanner.Text() fmt.Println("Message Received:", string(msg)) c.Write([]byte(strings.ToUpper(msg) + "\n")) } if err := scanner.Err(); err != nil { fmt.Fprintln(os.Stderr, "error reading from connection:", err) } } func main() { var count int64 = 0 maxConns := 1 l, err := net.Listen("tcp", ":2222") if err != nil { log.Fatal(err) } defer l.Close() for { conn, err := l.Accept() if err != nil { log.Fatal(err) } fmt.Println("Current number of connections \n", count) if count &gt;= int64(maxConns) { log.Println("over limit") conn.Close() continue } go func() { atomic.AddInt64(&amp;count, 1) dowork(conn) atomic.AddInt64(&amp;count, -1) }() } } can't guarantee the sync logic is correct... I don't think the read of count in the comparison is safe, but it's a good example.
oh shit, I didnt even know about gofmt lol
This is the correct answer. You are reading in one less byte than you think you are. Slices are [low:high] where high is the last element + 1. https://golang.org/ref/spec#Slice_expressions
I'm not the author; I was just searching for this topic and found this article, which I think is an interesting read.
Ahhh I see what you mean now. It seems that is the only way to handle marshalling sql results. You can dynamically fill a map with field:arrayOfValues using sqlx but you'd still need to know what was in each table to be able to use them in your code. 
Read the docs on the main website for even more cool stuff.
Thanks, that's my problem. I got another question. If I modify your code from `dowork(conn)` to `go dowork(conn)`. The count will always stays at 0, why is that? 
because it returns immediately, and so `atomic.AddInt64(&amp;count, -1)` is executed before dowork is done processing. It's already in a goroutine, so no need to run it in another one. I wrote it like that so that there would be a separation of concerns between the connection limit logic and the "dowork" logic
&gt; this tool can give you some informations about your local git repositories That sounds similar to my project [`gostatus`](https://github.com/shurcooL/gostatus#readme), although it is more closely tied to Go packages (inside repositories). Just wanted to put that on your radar.
What does the repository pattern look like for when you want to do a join between Person and another table, say Jobs? You create a new struct called PersonJobs and Scan() into the joined table?
Funny how the site needs a whole section of explanation of what each symbol does. In `time` you only have to remember an order: `month, day, hour, minute, second, year` or just one date: `Mon Jan 2 15:04:05 MST 2006` Don't get me wrong. I thought `time` was weird at first too but I ended up loving it and preferring it over the traditional method. No more looking at the reference table to find out if I need a capital letter or not.
&gt; And the code is fairly terse It's only terse in as far as it's a very high-level language. It deliberately avoids inscrutable Perl-/Ruby-like brevity. 
No, there weren't. [Here is the complete list](http://spectrum.ieee.org/static/interactive-the-top-programming-languages-2017)
Pretty sure this will be of interest: https://github.com/jpillora/velox Demo: https://velox.jpillora.com/
1. `go get` doesn't allow you to specify which version of a library you want. It always pulls the latest. 2. Vendoring is making a copy of a package in your source tree underneath a `vendor/` folder. The import path is still to the remote (`github.com/org/example`), but the code is actually within your repository. 3. It's similar to committing the `node_modules` folder in git.
&gt; What do tools like glide/godep provide that go get ... doesn't handle? Let me illustrate with an example. So let's assume you are working on `awesome-go-project` which uses `unstable-dependency`. So on your local computer you have: `go/src/github.com/xandout/awesome-go-project` and `go/src/github.com/xataras/unstable-dependency` If you build a binary on your local machine and then deploy it on your server or always distribute binaries then all is good. But let's suppose that a co-worker or just someone from the net wants to work on your `awesome-go-project`. So they use `go get github.com/xandout/awesome-go-project` to get it on their local machine. Meanwhile `xataras` has made a breaking change on `unstable-dependency`. So now the person that was interested in `awesome-go-project` will see that the code doesn't work. So how do you ensure that `awesome-go-project` will always use a working version of `unstable-dependency`? You simply copy all the currently working `unstable-dependency` code in `awesome-go-project` and the convention/decision is for that to be copied under a `vendor` folder (so the various tools can automate the process).
git submodules solve all of this without any extra tooling - locked to a specific commit, whose code is not copied into the vendor directory unless needed, and even with the ability to fork the vendor and merge changes from upstream...
Tools like glide/godep/dep provide the equivalent of npm install + package.json of nodejs. These tools allow you to specify which version of a dependency that your program use so that when you ship your code around or when someone wants to use your code, they can easily install the same version of the dependencies that you use. This is important to guarantee that it's reproducible, that it's 100% using the same thing and it's going to work the exact same way. Vendoring is a fancy way of saying that you copy your dependencies in the vendor folder. Vendor is equivalent to node_modules.
Thanks for being the only one to answer the question at hand.
git submodules are a pain to use.
Hello, has this been peer reviewed? Might want to add a disclaimers your implementation is still awaiting review (and code coverage / testing). Until then x/crypto even if it lacks feature parity has had a lot of expert eyes on it. The first thing I noticed just now clicking your repo was dangerous use of constant time compare [here](https://github.com/kevinburke/nacl/blob/master/nacl.go#L82) you're not checking if the length of each slice is identical which leaks length equality. I'm not sure what Verify is used for here but seeing a user facing constant time comparisons in a package aiming to be hard to misuse I assume leaking any timing details is not your intent. Suggestion would be to either refactor the API to remove it, leaving both the sized T versions. Or if length has to be arbitrary have a (should be global var to prevent leaking the condition still via an allocation) zero value byte slice of len N where N is the safe upper bounds of length you can leak without providing an adversary any benefit and use that as needed in place of the lhs, rhs or both to back comparisons before returning false. If I get a chance I'll browse through some sub packages it looks interesting and like you put a good bit of effort into it so kudos.
It hasn't, but the secretbox and box packages are straight ports from golang.org/x/crypto/nacl, literally I copied the code from there and used the same license. I didn't implement any of my own crypto, just accumulated the correct functions from different Go libraries and called them correctly and added compat tests. I also ported all of the tests I could directly from the nacl C sources and relevant RFC's, so the tests all pass the same tests that the C/C++ sources do. https://github.com/kevinburke/nacl/blob/master/auth/auth_test.go#L16-L96 crypto/subtle also leaks length, I think, so I'm not sure that it's that important, honestly, or the Go team would not have offered that API. Obviously Verify16/Verify32 would not do that as they are constant length and you are welcome to use those if it is really important that the comparison does not leak length. "The time taken is a function of the length of the slices and is independent of the contents." https://godoc.org/crypto/subtle#ConstantTimeCompare Here are seven different constant time comparison implementations, none of which protect against different lengths. https://gist.github.com/levigross/8691015
Well I'm sure you made changes or have integration points where things can go wrong or there would be no point in copying anything. Integration points provides places for mistakes to happen, not saying they did.. was just raising the point. For the constant time compare, yes, that is exactly the point. It exits immediately if the sizes are not equal. This leaves the potential to leak the size of contents. In some situations this may provide an adversary an advantage, in others it may not. Crypto subtle requires careful use and places the burden of leaking length onto the caller. I see you import the Verify call from subpkgs that are comparing private keys and such. At the very least your providing a hint at key lengths and providing a public facing API without the clear indication for careful use given by subtle package. Just a suggestion though leave it if you please. Happy coding. **Edit** for your edits: Constant time comparisons typically don't have a reasonable thing to do if the lengths are not equal. Cryptograpic support functions like that have to have maintain their invariants under all input. They can't provide proper padding for ALL input hence unable to maintain the invariant that constant time comparisons to upper bound of len of left and right hand side. This is a understood detail in most any constant time comparison function... as you showed by copying and pasting many. This detail is also reasonable, because buffers around cryptography implementations are already surrounded by strong invariants so this validation may already be done at the call site. When it isn't it can be done more easily there. Leaking length also does not always provide an adversary an advantage. But sometimes it can, since I did not know your intended use of it and you are providing a public facing wrapper to a constant time comparison I wanted to make sure it was intentional. I'm just doing my due diligence as a security engineer, again I'm not saying it's wrong I just wanted to raise the point and make sure you were SURE it was safe in all your usages. Not guess, be sure. If you want to expose it to users that's your prerogative, we can agree to disagree.
Take a look at this article: http://marcio.io/2015/07/calculating-multiple-file-hashes-in-a-single-pass/
&gt; I see you import the Verify call from subpkgs that are comparing private keys and such. [edited] There's one place I do that; the code I copied originally called subtle.ConstantTimeCompare directly; I switched it to use the helper. https://github.com/golang/crypto/blob/master/ed25519/ed25519.go#L180
So why not install Go on to that internet-PC? Go can be copy installed, which means it is portable.
I applaud any effort at building something but I would suggest sticking with "golang.org/x/crypto/nacl". As far as I know it's reputably maintained. 
For box and secretbox, sure, (I literally copied the code and tests from there into this implementation and added the same LICENSE). But if you want the other NaCL functions, or compat with other languages you are going to have to know which Go functions to look for and how to call them. The other functions aren't implemented in crypto/nacl; part of my goal in implementing this library is to try to add more of these packages/implementations to the golang.org/x/crypto/nacl package. https://github.com/golang/go/issues/20265
 I know how to qualify a Go identifier but thanks for the tip.. anyways if you just did a grep instead of immediately saying my claim was inaccurate you would have seen [this](https://github.com/kevinburke/nacl/blob/cc61858a376d45325565e56592d048f55f175500/sign/sign.go#L190) var checkR [32]byte R.ToBytes(&amp;checkR) return nacl.Verify(sig[:32], checkR[:]) I don't know how many more places there are.. it's the first file I clicked on. Give it five minutes and research what I said man, it may not apply here and your usage is fine, it may not be and you fix it. Both scenarios are fine by me I'm not arguing or saying you did anything wrong. Have fun..
You probably want to change your atomic decrement to run in a defer if you end up with an outer recover in your final implementation, otherwise occasional panics could eventually prevent all requests from being serviced. If you want to ratelimit more granularly perhaps per IP and a global shared max while allowing occasional bursts you may want to look into: https://godoc.org/golang.org/x/time/rate 
I dont know where Kotlin places but apparently somewhere below Ladder Logic and Forth. 
Ah, that's the one case; the code I copied called subtle.ConstantTimeCompare directly; I switched it to use the helper. https://github.com/golang/crypto/blob/master/ed25519/ed25519.go#L180
The main bottleneck by far when mass-updating a table are the table indexes, especially if the table has many of them. Every insert or update also needs to update all of the indexes. These individual index updates sum up. A faster way is to drop all indexes before doing the mass update, and recreate them afterwards. This should give a very noticeable performance boost (of course depending on the number of indexes). *(Edit: typo - mass insert -&gt; mass update)
go-pg appears to be much more flexible and powerful. I use it extensively and found it most balanced between being too much abstraction and too much raw SQL.
I was more excited about the possibility of immutables, non one else seems to care though :'(
I went to get an old program to test it out and to my horror one of its deps didn't build. The dependency's maintainer has [nuked the repository and moved it](https://github.com/davecheney/profile) to a another url leaving only a deprecation notice in the old url. I haven't encountered this in my projects, but I personally want to put my code up on GitHub one day and count on that it will build as it builds now for years.
Well pointed! My only concern about the Go language, besides the fact that i love it, is that rapidly becoming or already is a trendy language. Just looking at the github stars on projects written in Go it will be obvious that some projects are overrated just because they are written in Go.
Why does it have to be the typical "Why REST sucks" headline at the beginning? How about they move the very important "gRPC downsides" paragraph way up and relabed the other one to "When REST isnt the right choice"? Otherwise it seems solid, but I hate this totally stupid "Oh I hate the old tech, lets use the new one for 20 pages... oh and by the way, its not working with JS" game.
Great, then your safe cause that call site ensures both buffers len are always identical, thanks for looking have a good evening.
Yes, another guy who look at my code suggested the same thign on defer. fun defer { c.close() atomic.AddInt64(&amp;count, -1) }() defer is quite new to me and I don't really understand it. What's the difference between defer and putting the content of defer at the last?
Yep, that's the same idea ;-) Thank you for your comment! :-)
Wanted to say the same thing. Use Go to generate an SQL file.
But a bool doesn't make sense. struct{} signifies the channel is being used for signalling, whereas bool implies you are sending and receiving boolean values, but that isn't what you want to do.
Take a look at Rust. &lt;&gt; are relatively OK for one parameter, but once there are nested ones these &gt;&gt; becomes annoyingly unreadable. People tried to write ]] instead and it turned to be dramatically better for readability. It would be a sane move: Go creators dropped poor thought syntax of C and ugly (from mathematical standpoint) concept of OOP via inheritance spaghetti. Let's don't be trapped in C++'s template burp as well.
There are some communities that simply love to star on githubs and others who don't. I bet you there are absolutely shitty 100 lines go or javascript projects on github with more stars than some of the major databases or webservers like apache or nginx... its just because some communities are really into the idea of "starting" projects whilst others are not.
Plus, it would be almost consistent with the syntax of other built-in generic types (maps, arrays and slices) which use brackets, too, and would avoid syntax ambiguities and annoyances (the famous pre-C++11 "vector&lt;vector&lt;int&gt; &gt;" space between "&gt;" signs).
You can do syscalls in pure Go, which means you can write user-space drivers in Go like with C.
It seems to me browser JS would be one of the most important clients, or is gRPC only meant for backend applications (ie. server to server)? I don't get it, can anyone explain why JS (over HTTP/2) is not a priority?
Why not: func (model *Model) Create() error
&gt; ** I would love to provide some citation on this, but I'll have to go and find it. [blog post](https://blog.golang.org/generate) &gt; Just keep in mind that it is for package authors, not clients, if only for the reason that the program it invokes might not be available on the target machine. Also, if the containing package is intended for import by go get, once the file is generated (and tested!) it must be checked into the source code repository to be available to clients.
Because then you can't do: model, err := Create(&amp;Model{fields...})
defer is a statement, not a function. It basically says - run a function in defer statement AFTER we had returned from the current one or on panic.
I think this is key conclusion in the paper in regards to Go's suitability for telecom systems: &gt; From the results of the implementation of the RRC model that was made, there was one overwhelming difference that could be observed; the scheduler. The Erlang scheduler is fair and ensures that all processes gets its equal share of the processing power, while the Golang scheduler is less fair but more capable. In this particular field of application, having low latency with the price of losing fairness is more valuable than having it the other way. **We therefore think that the scheduler that Golang possess is suitable for this kind of applications.**
I haven't built anything with the game engine yet, but I really enjoyed playing with the demos using the debug commands :) You'll hear back from me if I get around to building something with Oak. Thanks for sharing this with the community!
I like the idea, including the syntax. It seems to fit Go pretty well. Why don't you post the idea at the official Github issue tracker?
The reason why I didn't post it there is that I felt like it's too soon. Experience reports are being gathered now and so on. Also, I wanted to see the overall reaction. Since the reaction was controversial, I assume that either the idea is not very good, or I didn't explain it very well. At least one of the two things need to get fixed for an official proposal.
Very positive on Golang. Nice find. The last graph in the paper "Distribution of latency", Golang looks really nice an uniform distribution. Interesting read on why Go performs well too. 
I attended this talk and while I have my own use cases in mind, I noticed that Alan dedicated some time to the problems of gRPC, but *never mentioned why you'd use it instead of REST*. My fault for having expectations but I was kinda hoping for more.
I think it's assumed that some sort of "API Gateway" would be used for user clients, browser/mobile/native. The gateway can serialize into whatever the client needs. So for a browser call to the gateway, the gateway would return JSON. Which can be over http/2 or websockets or whatever you want. 
That's cool, good work! :)
I like the second one. It makes the code smaller which is always good, and IMHO it makes it more readable too. Infact I go even futher, i would do: https://play.golang.org/p/6e_Er9PtdH (sorry i couldnt get reddit code formatting to work)
Fair enough func (model *Model) Create() (*Model, error) Allows model, err := &amp;Model{fields ...}.Create()
This is every interesting, but, as it says, doesn't support client side changes, which is the entire purpose of application. If it did, I'd stop what I was doing all together and adopt this.
I don't think it is is a good idea to add database logic to your application's structs.
支持谢大
`keys` is not there because it would have to allocate a slice and copy the keys out to that. Go tends to discourage such wastefulness.
Reproducibility.
Just assign them directly. https://play.golang.org/p/Ki7fBK6uhT
I think the part that rocked me is that I didn't realize a `copy` of the pointer was passed on the function call. Is swapping by pointers and dereferencing better than copying and swapping by value? When I pass a pointer to a function, does the copied pointer have a different memory address location. Away from a computer to test but eager to know
I would have agreed with that in the past. Now that I'm thinking purely in terms of HTTP microservice systems, I find there's no benefit in the additional complexity. OP code implied the Create func was already in the Model struct's package. EDIT: 180 degree turn around after thinking it through.
This of it this way, a pointer is a value. It happens to be the address of some other value.
You get the same address when you copy, so you could do a dereference swap. However, you can't change the pointer the callee gave you. It's the normal rule: if you want to change something, you need a pointer to it. So you could pass in a pointer to your pointer, then you could pointer swap.
Welcome to Go! Good to see you jumped straight in! With this first experience behind you, take some time to look through some of the best practices out there. The basic ones are these: * Must read: https://golang.org/doc/effective_go.html * More good practices: https://github.com/golang/go/wiki/CodeReviewComments You can find much more out there by googling for it. I am sure other people also have some helpful links. Youtube also has a lot of great talks. Here are some of the most obvious things that jumped out when skimming the code. They are pretty basic, but also very common when people move to Go from other languages: Usually main functions are placed in `cmd/duck` folder, shared packages as directories in the root, or in 'pkg', but you have a lot of "extra" stuff in your repo. Drop the in-repo binary/build. &gt; https://github.com/snwfdhmp/duck/blob/master/src/duck.go#L5 Don't use relative imports. &gt; https://github.com/snwfdhmp/duck/tree/master/src/usage Keep this where it is used, ie main package. &gt; https://github.com/snwfdhmp/duck/blob/master/src/parser/parser.go#L19 Go documentation does not have special tags. Write as plain text what it does. See the standard library for how to write documentation. &gt; https://github.com/snwfdhmp/duck/blob/master/src/configuration/configuration.go#L86 Return "error" instead of bool. &gt; https://github.com/snwfdhmp/duck/blob/master/src/configuration/configuration.go#L127 This and many, many other places you are ignoring errors. Don't do that. Search for 'errcheck' for a tool that will show them to you. &gt; https://github.com/snwfdhmp/duck/blob/master/src/configuration/configuration.go#L50 Instead of storing configuration as a package level variable, return it to the caller. &gt; https://github.com/snwfdhmp/duck/blob/master/src/configuration/configuration.go#L438 No need for getters - all these are directly available. &gt; https://github.com/snwfdhmp/duck/blob/master/src/configuration/configuration.go#L454 Don't use panic for error handling. 
You're headed down the road to creating your own ORM. The path to hell is paved with good intentions!
Oh didn't even check for that. Yeah IRCv3 is pretty much required. There are other libs out there but honestly IRC parsing isn't the hard part. Harder for me is having like a reconnect feature etc.
Wow thank you. Really useful notes. I'm gonna work on those, some were just some leftovers I forgot to fix, the note with the type callback sounds really good! Thank you!
Is the latter method of a pointer to a pointer more efficient? Is this creator of redux, Dan?
Using pointers may or may not be more efficient, it always depends. It might move something from stack to heap, putting pressure on GC. It might be that the struct is large enough that dereference-swapping takes longer than 2 levels of indirection. Dereferencing is easier to understand, so I would personally go with that, unless you want to profile with realistic values and choose the most efficient solution, but be cautious of any allocations. 10% more cpu-time doing the swap is a good trade-off for saving even a couple of allocations.
Will there be vods?
Go's spiritual predecessor Inferno was used in some telecom projects at Lucent. I wonder if there's a write-up on lessons learned from those projects. Inferno also had garbage collection and cheap threads.
You don't want to do anything after the increment operation before first calling defer, the same way you see Mutex operations lock and defer a Unlock right after. The reason for this is if a panic occurs but is later recovered and the Mutex (or in your case counter) is used after the recover the defer will still ensure the lock is release (or counter is decremented). This means don't defer a full func block for this, defer the atomic by itself. In your example if close panics the atomic operation doesn't run. 
Can I ask what is going on with the downvotes? Is this not the right sub to ask golang questions? 
Thank you very much for your answer ! I will read your links now. About the review, there're some points I didn't understand : &gt; Drop the in-repo binary/build. I don't understand what you mean here &gt; Don't use relative imports. How should I do it ? I read this before but if I use absolute path, building this on a different computer will fail ? &gt; Go documentation does not have special tags. Write as plain text what it does. See the standard library for how to write I'm not sure to understand what you mean here ? Where should I write this documentation ? &gt; Instead of storing configuration as a package level variable, return it to the caller. Where should it be stored then ? Because in many other functions I assume that the 'project.conf' has been read and Conf contains the right values. Should I read the file every time I need it ? &gt; Don't use panic for error handling. What is your advice for handling errors ? Just displaying them ?
Isn't this a bachelor thesis? 
Don't mind. Some people here (the minority) are a bit toxic. They forgot they were also newbies in the past. You're free to ask questions here, but there are also other places, like [the forum](https://forum.golangbridge.org/) or the Gophers Slack.
May I ask too what you think about the project itself ? Well made ? How can I improve the quality of the project/tool ? Does it feel comfortable to use ? (there're informations in the README about how to install, or bellow a little documentation to see of it works)
&gt; "Drop the in-repo binary/build." You have the "duck" executable as well as latest.tar.gz in your repo. No real need for that. If you want binary releases, use githubs "releases" for that. &gt; I read this before but if I use absolute path Relative to your $GOPATH :) Change `"./parser"` to `"github.com/snwfdhmp/duck/src/parser"`. &gt; Where should I write this documentation? Instead of @returns and similar, use plain descriptions of it. See https://golang.org/doc/effective_go.html#commentary - https://blog.golang.org/godoc-documenting-go-code and look in the standard library for a good reference point. &gt; Where should it be stored then? Pass configuration values to where it is needed. It is not a deadly sin to have it available, however it will make things much harder to test, since your behavior depends on configuration settings in another package. Your main package is free to store its global state, however be aware that nothing can (or should) import it. &gt; What is your advice for handling errors. Handle (and optionally log) or pass upwards. Main function can `log.Fatal(err)` if it gets an error. But always handle them, never panic. See "Effective Go", https://blog.golang.org/error-handling-and-go and use google for more.
Cool. What a great idea. 
&gt; What problems do vendor/dependency managers solve in Go Let's have some downvotes: None. Both pretend to solve a problem that provably has no automatic solution in the general case. So yes, they can be helpful. Like in having an add operation that sometime produces the correct result.
They are actually in different packages, just wrote it that way for brevity because I'm on mobile.
It's a shame this post is getting downvoted so much. You've put serious work in, and yeah, there are serious concerns with any unvetted crypto software. But downvoting the post is imo not very productive. It means less people will see it, less people will know it exists, and less people will provide their (potentially very valuable) input. It's clear you've added needed functionality when it comes to interop with other languages that use nacl. This also fills a void for projects that cant or wont rely on Cgo bindings for libsodium. You are also intending to get your additions merged back into the upstream x/crypto/nacl package. Basically, you've shown us that you're serious about the task (work already done, future intentions) so I think we as a community should be supporting this. At any rate, I'm interested to see where the future takes this project. I hope you, OP, don't feel too demotivated by the poor reception here.
You're fighting the language. Don't fight the language.
All good!
I didn't tried the project myself, but I'll give a few suggestions based on the readme. * I would remove the Emojis from the project description and README * Don't tell people to run a bash script to install the project. Go users should install it with `go get` * You may want to automate the release process to GitHub releases with [GoReleaser](https://github.com/goreleaser/goreleaser) * The README doesn't make it clear how to I config these tasks. Should I manually create that JSON file? In which folder? With what name? Etc...
Glad to hear you've found it useful! I mainly write Go and play with Elixir and there are things on both side that miss on the other side - I'm not saying Go or Elixir should change. But (besides immutability &amp; fault tolerance) the main thing I miss in Go that Elixir already has it, is a standard way to design the structure of your application.And it's not just CLI apps. We do not have anything like Phoenix that gathers and focuses the community effort in web development or mix for dependency management or any approach like OTP. Go tooling is one of the best &amp; I'm sure in time these issues will get addressed in proper ways.
I don't see it. What I see is the orthognality of the DB and Model concepts in my program. "Simplicity comes from orthogonality and predictability." -- Rob Pike
Thank you for your answer, I will commit all of this soon !
this is what im looking for: https://stackoverflow.com/questions/42820620/map-of-struct-from-json-in-golang
https://play.golang.org/p/GdfehTHUhN
Is it boring for some people to ask this kind of thing on reddit ? Sorry if it is, I'm new to Reddit.
yes, perfect, thanks!
Awesome
I don't think reddit upvotes and some drive-by comments are a good gauge for invalidating an idea. But I agree that a more detailed elaboration would be necessary, including various using scenarios and the how it would be encoded in the data structures of the compiler and so on. 
https://gobyexample.com/range-over-channels ``` for val := range ch { fmt.Println(val) } ```
Looks like the site broke :( edit: Nevermind. It just didn't support my specific browser
What happens is that Go is a new language, and until few time ago to there were mostly early adopters, and this kind of people usually look to more advanced content. Now that more newbies are learning Go (and that is good!), same of the more advanced devs may find dealing with newbies boring. But you should not feel bad about it! They're the minority. We see this behavior more on Reddit, other Go communities are more welcome to newbies. Be welcome!
correction: he or she is fighting the tooling. The language places no such requirement, it's just you are going to have a much harder time.
&gt; It is a web standards architecture and HTTP Protocol. The REST protocol [...] REST is none of these. Representational State Transfer is an **Architectural Style** and nothing else. Your example API serves representations as content-type application/json which is not a hypermedia format. Technically this violates the HATEOS clause of the uniform interface constraint. Your example API ranks Level 2 out of 3 on the Richard Maturity Model https://martinfowler.com/articles/richardsonMaturityModel.html This API is more accurately an example of Resource Oriented Architecture than REST. Most people who think they understand REST are actually talking about ROA but somehow it hasn't gained the same sort of buzzword fervor that REST has picked up in recent years so the terms have become equivocal in general discourse. I don't mean to be that one guy in the room who pokes holes in all your fun I just think more people should know what REST is really all about.
I believe there is a 3rd option: func Create(u User) (User, error) or func Create(u User) (*User, error) You pass a copy with only the required values filled like say `Name` and you return a brand new user that contains the rest like `ID` and `Created`. I think it makes a little more sense than: func Create(u *User) (*User, error) Because if we are passing a pointer then why return it? Is it the same one? If it is then why not modify the original one instead? Of course there is still the argument that `User` might be big and we do not wish to copy it. So... I think my favorite option is : func Create(u *User) error Where you pass a pointer and after the function ends successfully if we inspect the fields of `u` the fields like `ID` and `Created` have been filled with the values from the database. It feels a little more "lightweight" to me and the fact that you pass down a pointer it means that the function is planning to modify its values. In the end I don't think it matters too much. Just be consistent across the codebase. P.S. I know it was an example but I detest seeing things like `models.Model` with `models` being the worst part.
Technically Correct: The Best Kind of Correct 👍
Did not know you could read on a closed buffered channel and still get all values out. Thanks!
Does this work if the chan writing and closing happens in another goroutine?
Is it really level 2? Responses code and headers are not being used. Also, can you clarify on the distinction between ROA and REST? I haven't heard the name before but most of what I could gather seems to indicate that ROA is just another name for it.
"I prefer the simplicity of ~~reinventing the wheel~~ handling that in my own code..."
I checked Wednesday and it was described as still in alpha, and today it's finally ready to use? Great! Will give it a try next week...
This API does return HTTP response codes. It just always happens to return 200 Okay. This API does use HTTP headers. For instance, I'm pretty sure the json encoder will set the content-type to application/json on your behalf (requires testing to verify). I highly recommend this book: *RESTful Web Services* by Leonard Richardson and Sam Ruby (with foreward by David Heinemeier Hansson) https://www.amazon.com/dp/0596529260 It does a fantastic job putting REST and Resource Oriented Architecture into perspective. You can also read it online with a 10 day free trial at O'Reilly http://shop.oreilly.com/product/9780596529260.do "Every developer working with the Web needs to read this book." -- David Heinemeier Hansson, creator of the Rails framework
Of course it's at least returning 200 and content-type automatically... It's not returning the correct code though or setting the correct headers that is expected of REST that follow standard HTTP. ie: If you create a new resource it's 201, not 200. (Unless gorilla/mux automatically does that for POST behind the scene in which case I apologize for bringing forward this useless example) Although I appreciate that you took the time to link me books on the subject, I'm interested in a direct answer. I'm not going to read 500 pages of a book.
Don't use a framework your first time around. It took me several projects to realize that net/http and encoding/json have everything you need for the majority of web apps. The Golang standard library is great, and I think a selling point of Go is that we often don't need to reach for third party tools when the Stl and a tiny bit of extra code will do.
If you're brand new to Go, be sure to start with the Go tour. Read Effective Go after that, then dive into the standard library. Don't use a framework. Use `net/http` and, perhaps, a third party request multiplexer if you want conveniences such as multiplexing based on HTTP method and having path parameters be parsed for you. [gorilla/mux](https://godoc.org/github.com/gorilla/mux) and [go-chi/chi](https://github.com/go-chi/chi) are both reasonable choices.
This is the first piece to a larger home automation project I'm working on. The final solution will end up being a bit tailored to my setup, but I thought that this particular piece may be of some use to someone else. You can remotely power-on your sleeping (not powered off!) XboxOne. The instant-on feature needs to be enabled and you'll need to know the Live ID for your console. This was inspired by a python script that accomplished the same task. Link to that project is in the README for the repo.
Level 1 is about separating resources into separate and distinct URIs. The opposite would be something like SOAP where one endpoint is used for all actions through the API. Level 2 is about using a protocol's uniform methods appropriately. The opposite would be something like SOAP or XML-RPC where all requests use POST which means that no requests are safe or idempotent making caching impossible. Here's an article on safety and idempotency in HTTP http://javarevisited.blogspot.com/2016/05/what-are-idempotent-and-safe-methods-of-HTTP-and-REST.html Use of proper status codes is not necessarily a requirement for REST except as it relates to response cacheability. According to HTTP, responses to POST requests SHOULD return a 201 status code upon resource creation but that's not explicitly required by the protocol. The reason that REST doesn't make any distinction regarding HTTP response status codes is because REST is not specific to HTTP. According to REST as originally defined by its creator Roy T. Fielding in his original PhD Thesis: "REST does not restrict communication to a particular protocol [...] the Web's primary transfer protocol is HTTP, but the architecture also includes seamless access to resources that originate on pre-existing network servers, including FTP, Gopher, and WAIS." It really is a good book. I read it cover to cover in 2 or 3 weeks on the 40 minute train ride to and from work. It took time to read that 500 page book but even 9 years later I still consider it time well spent.
thank you! Will read effective go.
Oh that's good to know, thank you!
Thank you. I'll probably get the book down the line.
I generally agree with /u/spiritofthetempest, but I'll tip my hat to: https://github.com/julienschmidt/httprouter It's a tiny, well tested, high performance library that suits my needs really, really well.
Took a quick look. * The author should not ignore JSON encode/decode errors. He should use a proper HTTP response code in case of a failure or a bad request. * There is a for loop inside the DeletePerson function that encodes the slice `people` on every iteration. Don't think it's what was intended. Edit: formatting
&gt; Don't tell people to run a bash script to install the project. For releases that is fine IMO, since users may not have Go an environment set up, but otherwise I `go get`should be ok.
Or if you like short, just`defer startServer()()` 
Im in the same boat as you, cause Im learning Go I've been sticking with standard library only (e: and a sqlite driver). so just net/http. Its been very enjoyable thus far, I doubt its the best way though.
It's been more ready to use than glide for more than a month now. After they finalised the the manifest format we almost instantly converted all our projects. It has been a much nicer experience than glide with its numerous bugs, so far we haven't had a single issue. 
I've been using it for a while and certainly doesn't feel alpha for quite some time. I think they're taking a rather defensive and conservative approach re labelling the maturity, just like others do (remember how long GMail was in beta? ;) Personally, I prefer this attitude over, for example, some ASF project who graduate after a couple of months, claim 1.0 GA and really are more like alpha+ …
Great post/talk! At my company we've been using dep for a while now and have been really happy. I even built a tool around it to solve the multi project workflow mentioned in the article (as well as adding support for version pinning executables): https://github.com/GetStream/vg If you're interested please see this pull request which improves that functionality even further: https://github.com/GetStream/vg/pull/8 It can use some feedback before merging it (which should happen somewhere next week). The PR also has a much better updated README: https://github.com/GetStream/vg/blob/workspace-settings/README.md
&gt; For me, the reason I was enthusiastic about Go is because just about the same time that we were starting on Go, I read (or tried to read) the C++0x proposed standard, and that was a convincer for me.
Or better still don't use a framework your third, fourth time
For me, It is the best way.. You can try a mux compatible with `net/http` (say chi).. Just a little bit low level
```gorilla/....` gives you most of this things.. And there are well tested libs you can import... No one is saying you should roll out your own sessions, JWT, ratelimiting all the time... Composability is key
Same here although I have been using the gorilla mux and a MySQL driver but otherwise no third party libraries. GitHub: https://github.com/steffen25/golang.zone/tree/develop Any feedback/improvements is highly appreciated :) I have one myself e.g. Right now I'm passing the DB to the router through the app.go and initializing my repos and controllers there but there must be a better way to do this I believe. The site is also live so feel free to test if you want to. 
I made some improvements, I'm still working on it. You can see what I already did here : https://github.com/snwfdhmp/duck
To me this feels like you're making your code a lot harder to read and understand. When I see a start function, I expect a stop function. I don't expect a start function to return a locally declared stop function. Even more so, because your stop function (most likely?) uses the listener created in the start function without passing it through as a function argument, you can't test your stop function in an isolated manner. To me this "trick" feels like you're hurting your code quality and readability.
FYI, you can do a for-range on a channel to read until it's closed, rather than your for-select with a break: for val := range myChan { ... } // Stops when myChan is closed
Awaiting for the rust comments to come...
I agree that RPC is a often a good idea, but still, it’s ironic how the example he uses is... a cache service — something that you basically have out of the box with HTTP/REST, and much more flexible at that.
I remember I felt quite amazed to see Ken on this video. It is one of those early videos that convinced me to take a more serious look on the language and I am glad it did. It is quite unfortunate that this is pretty much the only video where we see Ken in the context of Go. I am really curious if Ken still works on Go or if he even writes Go at all.
there's another vid (trying to find) where Rob Pike says that Ken is basically retired.. but still around..
https://www.reddit.com/r/golang/comments/46bd5h/ama_we_are_the_go_contributors_ask_us_anything/d03u88s/ He even created a reddit account for this AMA: https://www.reddit.com/user/unixken
`export GOPATH=$HOME/.go` IIRC when you only do `GOPATH=$HOME/.go` bash will make this available in the *current* shell, while `export` makes it available to *child processes like go get*.
Yeah thanks for the link. I remember the AMA. Seeing Ken replying was the best part for me.
`$HOME/go` is the default GOPATH value (after Go 1.8 I believe) and I would highly recommend to use that. But if you really want to change it then use `export GOPATH=$HOME/.go` and make sure to close and open the terminal for the change to have an effect. Another thing that is very useful to add to your .bashrc or .profile is something like this: `export CDPATH=.:$GOPATH/src:$GOPATH/src/github.com/&lt;your github username&gt;:` Which will allow you to easily `cd` to your Go workspace from anywhere.
&gt;$HOME/go is the default GOPATH value (after Go 1.8 I believe) and I would highly recommend to use that. Does it mean that I can safely remove lines `GOPATH=$HOME/.go PATH=$PATH:$GOPATH/bin` from my bashrc? I want to use defaults. &gt;Which will allow you to easily cd to your Go workspace from anywhere. How so?
Can't you just let systemd's logrotate handle this for you?
Strange, `echo $GOPATH` returns `/Users/user/.go` but `go env GOPATH` returns `/Users/user/go` 
I believe you still need the line: export PATH=$PATH:$GOPATH/bin &gt; Which will allow you to easily cd to your Go workspace from anywhere. &gt; How so? Setting this line in your .bashrc or .profile: export CDPATH=.:$GOPATH/src:$GOPATH/src/github.com/&lt;your github username&gt;: Makes your CDPATH include: * `.` * `$GOPATH/src` * `$GOPATH/src/github.com/&lt;your github username&gt;` So if we suppose you have `goproject` in your workspace then you can do `cd goproject` from any path and you will be transferred to `~/go/src/github.com/&lt;your github username&gt;/goproject`. Obviously you can modify CDPATH according to your needs.
&gt; My point is that if Go is not going to have a story for templated types, then we need to own it, just like Haskell programmers own their decisions. Well, that's the problem isn't it? We don't want to own 'go doesn't need generics'. We *want* generics. I think that's overwhelmingly obvious from the feedback on 'go 2.0'. If the community was just going to sit down and 'own' that go wont ever have generics, we would have done so by now. ...that we haven't, is really overwhelming proof it isn't suddenly magically going to happen now.
it means that the shell is not propagating the variable into subprocesses so Go is using the default value. I do recommend to try `export`
&gt; We don't want to own 'go doesn't need generics'. We want generics. Don't speak for all of us. 
The feedback from the community has been **overwhelming** on every forum regarding go 2.0. Look it up if you don't believe me. I may not speak for everyone, but I do speak for more than a handful of people.
- A lot of this feedback is from other communities with different values - Those who are discontent are the loudest, while those who are happy with the status-quo like me have no reason to speak up
I don't know why I'd need generics and I do not know what "every forum regarding go 2.0" even means.
I'd be really interested if there could be a different solution to the problem of "We're copying code for these structs because we don't have templated types" without using templated types or another more complex form of generics. But maybe that's not what he means when he says "the underlying business problem".
&gt; So my first answer is: Javascript should have some form of generics because it is a mainstream, imperative, block scoped language and it is expected these days. I love how this article does try to be objective and include valid arguments for both sides. &gt; I am not one of the language designers, only an exuberant fan (...) This isn’t simply a case of saying “nope, sorry, no generics for Go 2.0, maybe in another 5 years”, but a more fundamental statement that they are not something that will be implemented in Go because WE believe there is a better way to solve the underlying problem. Who's we? I can't build a compiler myself, but I can imagine that adding generics to the language will make the compiler a lot more complex to implement. That's a proper reason not to implement them. There's no other justification needed.
So here's the question for you: Given 'the community' has not rallied behind 'go doesn't need generics' up to now*, what on earth makes it likely to suddenly happen? Seriously, how do you plan to achieve that? ...but frankly pro or against generics, I see no viable road that unifies the community without generics. If I'm wrong, what am I missing? ...cause it sure hasn't worked so far. * and I'm not talking a split of the community where the status quo of satisfied and dissatisfied exist alongside each other. I mean the community really gathering behind the one solution, like they are with 'dep' for package management.
google 'go 2.0' and read the comments. It's been exhaustively discussed. Come on, you're going to participate in the discussion, spend the two minutes doing some background reading first.
&gt; I mean the community really gathering behind the one solution, like they are with 'dep' for package management. I know I'm not a fan of semantic versioning and npm/bundler/cargo/maven like package management beasts. But I also know that I don't have to use 'dep', so I don't oppose its development.
If generics clutter the language up too much, maybe having some built-ins that give us the most-used-functions (like filter, map, take...) would be the way to go → generics-functions only in the std-lib. This way complexity increases not much (programmer point-of-view), at the same time the amount of boilerplate code would be reduced. Before: var a []string for _, v := range []string{"Apple", "Banana"} { if strings.HasPrefix(v, "A") { a = append(a, v) } } With builtin generics: a := []string{"Apple", "Banana"} .filter(|v| strings.HasPrefix(v, "A")) 
&gt;The feedback from the community has been overwhelming on every forum regarding go 2.0 Well, obviously those who really want generics are more likely to make their voice heard than those who are happy/content with the language as is, I'm in the 'want generics' camp but I'm not sure the overwhelming majority of Go users see the lack of generics as a big problem, if that was the case Go would never have seen the great uptake it has had given that there's never been a promise to implement them. Anyway it's interesting to follow the brainstorming that the concept of Go 2.0 has brought, and I hope we will see generics and other language improvements come as a result of this, looking at all the proposals in the github repo shows that there is quite a lot of interest: https://github.com/golang/go/issues?q=is%3Aissue+is%3Aopen+label%3AGo2
Yep! Well argued, Dave. Go team, ship it or own it.
+1
Works with export. Thanks.
&gt; A better way to solve the underlying problem I think the problem is that there are a host of problems for which there isn't a better solution than generic types. With great pain, we can work around sorting with Go's type system, but there are some problems for which that isn't even possible. Unless you believe `interface{}` is better than actual generics, in which case why does Go have any static types? Please note that I share a concern about what generics might do to Go's simplicity, compiler performance, etc--the generics question is really nuanced, and we need to recognize that either decision will have significant tradeoffs.
I haven't seen many people expressing that this is a problem. I think Go has been pretty adamant that adding a couple extra lines of code to make an explicit loop is exactly what they want, and they aren't interested in going down the `map, filter, reduce ...` pattern of FP functions. 
I disagree--these builtins complicate the language without adding much to type safety or readability. They only make the code more brief, which is not a desirable outcome by itself. I can live with for loops. The problems that seriously cause me to consider another language are the lack of type-safe algorithms and data-structures. Fortunately for Go, there are few other languages that support generics but also value simplicity (in tooling as well as the language), but that is improving all the time...
I do something very similar. Often I will bind to :0 and return a port or a configured client to my server under test along side the close method. This way my tests can run in parallel.
I program in Go for more than a year and never met the need for generics. That doesn't prove that black swan don't exist of course. Go interfaces removes the need for generics for most use cases. Whatever quacks is a duck. So when you implement a container, one should provide an interface for items that can be stored in it. Or if we want to implement a function processing some type of data, we should provide an interface for the type that can be processed. The nice thing with this is that the interface is well defined. We don't need to look at the code of the templated function or class to see what methods it will use. This is something that always irritate me with templates. Now there are types and operations that don't support interface. The types are the basic types like int16, unit32, float, ... The operations are the arithmetic, binary and logical operations. For these types and operation, we are stuck to rewriting the functions for the different types. This is why I stick to int in my code. From my current understanding, these are the only use cases where generics may solve the problem. But it doesn't mean that generics is the only solution. 
As soon as Go gets generics it will be just another java or c# except worse. The simplicity of the language makes it stick out but it also that that makes experienced coders avoid it unless you come from say C or some of the dynamically typed languages. I don't belive that java or c# coders will ever migrate in masses to GO. There is a trend in the opposite direction the people are moving to more advanced languages like Scala, Kotlin and to some degree even F# . Go is a step backwards for jvm,.net devs. 
&gt; Mainstream programmers expect static typing, not for performance, but for readability and maintainability–just look at what Typescript and Dart are bringing to Javascript, and Python’s formative efforts with optional typing. I work on Dart. We spent about five years with an optional type system (the same as TypeScript). That flavor of typing gives you the readability of types, some of the maintainability, and none of the performance. In return for sacrificing the latter two, you can have a simpler type system that still doesn't prohibit lots of code that is dynamically correct by letting users easily skirt around the type system. At least for Dart, it turned out that that wasn't enough. We're replacing the optional type system with a full static type system — though one that has a dynamic type and lots of type inference. My experience is that there is an uncanny valley in type systems. If you offer users some amount of static types, it summons *all* of their expectations about what a statically-typed language entails. They naturally begin programming in a very static style, even though the language allows more flexibility. They also expect the safety, refactoring support, and performance of a full statically typed language and are *really* unpleasantly surprised when they discover they don't get that. This isn't true of *all* users, of course, but it was true of enough of our users, and we felt the limitations of not being able to rely on static types during compilation, that it made sense for us to go past the halfway point with optional types all the way to a complete sound static type system. With Go, I think they are suffering much of that same uncanny valley affect. They are statically typed (with a really neat static type system), so users expect *all* of the comforts and tools they're used to from other static type systems. They can learn to use structural typing and interfaces instead of classes and subtyping because there is real benefit to the former. But the lack of generics just feels like an absence to a lot of users.
No. Never. Just give more convenient tools for generating Go code.
Just because it's hard to do means we shouldn't? Not a good enough reason. 
As far as I know, the argument against generics (beside compiler complexity) is that go code could become a mess, because of too many "clever abstractions", which people tend to write. Go code is simple, that's what we love about Go, it is one of Go's major selling points. Builtin FP functions would allow us to have more flexibility but at the same time keep Go somewhat, what it is right now. &gt; adding a couple extra lines of code to make an explicit loop is exactly what they want I don't know if that's actually true. From my understanding, Go tries to keep complexity to a minimum, which IMHO, wouldn't disallow Go to have well known syntactic-sugar. Short, **expressive** code &gt; boilerplate code.
I'll express that this is a problem. Sure I want generics but what I really miss from other languages is map/reduce functionality on arrays. It is SO useful and often much clearer
I like generics myself. When thinking about how Go could introduce generics without leading to overly clever code, I thought about builtin FP functions – I'm not sure if that is the right approach though.
Although I may be part of other "programming communities" and in them I do value different things, I'm also part of this one. Despite simplicity being my favorite thing about Go (which seems to be opponents main objection) it's clear to me that generics are needed. I want as much guarantees as possible that my programs are correct at compile time and generics will provide more of them. The reflection API growing release after release with one of the largest [commit history logs](https://github.com/golang/go/commits/master?after=b81735924936291303559fd71dabaa1aa88f57c5+174&amp;path%5B%5D=src&amp;path%5B%5D=reflect) strengthens the argument there is a demand I think.
C doesn't have generics and it's doing fine. Almost every person who brings up generics when it comes to Go are people who just don't like Go. Yeah you can find a few enthusiasts who hate the lack of generics, but for the most part it's people from other communities who are just trying to find any perceived "flaw" they can. 
I think map/reduce functions are less explicit and use more complex syntax, but to each their own.
Complex and *unnecessary*. 
Ok I agree about to each their own but let me try to make my argument. There are endless reasons to write a loop. Anytime I see a loop someone has written I have to parse all that code and understand its intention. If I see .map on an array I know exactly what's happening. We are converting this struct to some other struct. And the same can be said for any of these other convenience functions. Yes there is a time and a place for them but I strongly believed when used appropriately they make code easier to understand and maintain because the purpose of the loop is explicitly stated--not to mention, less code to maintain. The convenience factor is very nice but it's just one positive thing IMO. 
You sure your code isn't Solidity?
I don't have much experience with cgo so I cannot answer your question but I'll say this: Do yourself a favor and switch to a [pure Go database](https://github.com/avelino/awesome-go#database). Personally I'd recommend [Bolt](https://github.com/boltdb/bolt) for projects with simple schemas. If possible just avoid cgo entirely and stick with pure Go. Even Rob Pike himself [has never used cgo](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=12m37s).
That it's more complex is obvious. That it's unnecessary isn't.
I really hate Dave's viewpoint on a lot of this kind of stuff. I feel like he comes off arrogant without proper backing. One aspect of go that really bothers me is that low-level data structures are nearly impossible to do well because of the lack of generics. Using an interface to represent a generic value has some large downfalls: - The compiler cannot find issues ahead of time, all type issues will be runtime issues - Overhead of running an interface rather than the direct struct (or value) A great example of this is the linked lib within the stdlib. Working with an interface-based data structure library feels awkward as hell. It's not a pleasant experience, and your code starts to feel muddy from all the: `val, ok := iface.(mystruct) if !ok { return ErrInvalidtype } ` (Sorry, reddit is making the formatting a bitch, but you get the idea)
People want generics because they are used to them. What if there'd be a better way to go at generics? Be open-minded and let the language designers take their time to make a profound statement and come up with a thorough solution.
&gt;I'd rather have the user implement 1 function and then just use a channel to share the messages with other functions. By using a channel you would only share it with a single function, if multiple functions are trying to read from the same channel they will each only read one input at a time. Sure, you could probably make it work by having a single function read from the channel and then resend that message out on other channels for each specific function, but it seems easier to just iterate over the list of functions to call when the message initially comes in.
Like simplicity, like "less is more", the problem with generic is that it's more difficult to explain why we don't need it (in fact) than why we could use it. At first, coming from Python i thought i will need generics, but the more and more I "think Go" the less I feel the need for generics. But it will be a lot easier for me to sell the features of Python than the simplicity of Go. Specially if I give short examples like we do here.
You can find a good definition of what RESTful is [here](https://en.wikipedia.org/wiki/Representational_state_transfer) and [here](https://stackoverflow.com/a/29648972) and a tutorial [here](http://www.restapitutorial.com). I found these resources searching "RESTful API" in one of those popular search engines.
We should do like they did at three to design Go, if not all of them was agree the feature didn't enter.
It's why we don't want generics :-)
thanks! I'm still new to go, but I'll change it and test some new modifications out. :) Originall, I was going to try websocketcpp, but felt like using golang was waaaaaaaaay faster. haha
I don't think Go needs generics, I think they are complex, but complete, solutions to a whole category of problems, whereas I would prefer simpler solutions to the more common problems in that category. I think there's a few tiny things that could be added to solve 99% of the problems that generics add. Adding full generics, to me, would mean everyone uses them and I find that makes libraries much more complex to use. The main thing missing, really, is working with a slice/map of anything. People able to specify that you accept "any" slice or "any" map (whose types have certain capabilities) without having to create a type for that slice/map and make it satisfy some interface. Anyway, that's just my argument, and is one of many perspectives on the issue.
You know that templated generics is basically builtin automatic code generation?
C does have generics (macros and __Generic in C11?). But! You don't need generics for what C is for (kernels, drivers, really low level code, ...). Also did you some some higher-level code in C? (GTK+ application?) It's just pure madness.
&gt; I want as much guarantees as possible That would mean dependent types and beyond. Barely anyone would want to use such a language. It's a fallacy to think that more static guarantees equal a better programming language. A good design balances many tradeoffs.
Wouldn't adding generics make the reflection API even bigger?
Putting aside pro generics or not what I like about this article is the fact that it is calling for closure one way or another. This limbo state of maybe they will maybe they wont results in the same old flame wars every thread.
I'd much rather let the compiler maintain that code for me than having to do it myself with code generation tools.
I agree completely. Everyone loves the mantra that adding anything new to the language is "complex" and "unnecessary". But often times that's just not true. Map/reduce functionality would let people write less code (less chance for bugs) that is more explicit (easier to maintain and understand). I've loved being a go developer for the past year but if go 2 refuses to do anything interesting then I might look for a new language for my next job. 
Too many people say they dislike Go because it doesn't have generics, inheritance, polymorphism, basically all the hallmarks of OOP in languages they are used to, predominantly C++ and Java. That doesn't make them right, and I'd much prefer Go to make the right choices for Go: keeping a simple, easy to understand language that encourages you to handle errors at all stages. I'm happy without generics, but some see great value in them. If a concept similar to templating can be formed that fits within the Go ethos, I wouldn't be opposed to it -- but blindly fitting generics in just because of popularity would be a mistake.
I just want to point out that just because you haven't personally run into the need for generics doesn't mean it doesn't exist. You definitely can do A LOT without generics in go. Go is a great language. People trying to write abstract packages outside of some prescribed business requirements are very likely to run into the pain of not having generics though, and if those guys get generics then the rest of us get to benefit as week even though we've always been able to figure a way through our issue. 
The hoops that kubernetes has to jump through are incredibly unfortunate, but the truth is that we have to codegen a bunch for performance reasons. The generated code is our #1 cause of merge conflicts and rebases across contributors. Moving to just-in-time codegen is what we want, but we t requires horrible, ridiculous 'makefile' hacks. Something better would be wonderful.
I think reasoning here is: * Generics are a compile-time affair * The alternative is switching over types at runtime * Switching types at runtime often calls for reflection * Demand for runtime reflection may indicate high demand for runtime solutions to lack of compile-time genericity. Personally, I'd love better generic support, though I'd settle for some kind of boost to interfaces, so you could lint things like "Type switch is exhaustive over all implementors of interface that are in scope, or provides a default".. Which might help interfaces to step into the generic void.
You could write it so it accepts a slice as a target. 
https://github.com/snwfdhmp/duck/blob/master/cmd/duck/duck.go#L73 If you use a bufio.NewScanner(os.os.Stdin), the logic will be a bit cleaner, won't need to strip the newlines https://github.com/snwfdhmp/duck/blob/master/cmd/duck/duck.go#L122 break statements aren't needed in the switch (I see that in a lot of places) https://github.com/snwfdhmp/duck/blob/master/pkg/logger/logger.go#L49 this is confusing since log.Fatal in stdlib always exits vs yours checks if err is nil https://github.com/snwfdhmp/duck/blob/master/pkg/logger/logger.go#L53 the os.Exit(1) isn't needed, log.Fataln exits https://github.com/snwfdhmp/duck/blob/master/pkg/parser/parser.go#L53 instead of if shouldContinue != true { use if ! shouldContinue { https://github.com/snwfdhmp/duck/blob/master/pkg/configuration/configuration.go#L119 comment doesn't match actual path https://github.com/snwfdhmp/duck/blob/master/pkg/configuration/configuration.go#L197-L200 I don't understand this part, isn't Lings a func local variable? https://github.com/snwfdhmp/duck/blob/master/pkg/configuration/configuration.go#L230 use os.Mkdir https://github.com/snwfdhmp/duck/blob/master/pkg/configuration/configuration.go#L264 looks like the break always occurs, do you only want that loop ran once? https://github.com/snwfdhmp/duck/blob/master/pkg/configuration/configuration.go#L266 if ! installed { https://github.com/snwfdhmp/duck/blob/master/pkg/configuration/configuration.go#L418 If there is a return in an if statement, the else isn't needed, could be converted to //looking for the commands corresponding to the label for _, ling := range Lings { if ling.Label == label { // if scheme's label is input, return it return ling.Commands } // look in its aliases for _, alias := range ling.Aliases { if alias == label { return ling.Commands } } } edit: formatting
Hard is also significantly more expensive, that's what I meant, who's going to pay for development time and maintenance?
If you haven't tried Rust yet, it seems like you'd enjoy it. Highly recommended.
If it used syntax that was closer to what go already used I'd be ok with it: Instead of a := []string{"Apple", "Banana"} .filter(|v| strings.HasPrefix(v, "A")) This: a := []string{"Apple", "Banana"} .filter(func(v string) bool { return strings.HasPrefix(v, "A") }) Otherwise it would seem like adding syntax for a new way to define functions. It would still make Go a less beginner friendly, I think. Depending on how many functions are blessed into the standard library to have generics, you change the loop tutorial in Go from "this is a for loop" to " this is a for loop, and these are the N keywords that are special types of loops". Edit: you could use that same argument to say that any new feature would make Go less beginner friendly though, so that's probably not fair. 
I'm a Rustian :)
Totally agree. We don't need a new way to define funcs, what we have now is plenty elegant and simple. And yes, that's true. More difficult for people new to programming. Possibly easier for people coming from other languages? 
I feel like generics would be very hazardous to the simplicity and readability of Go. I also feel like the need for generics is dramatically overstated.
&gt; I just want to point out that just because you haven't personally run into the need for generics doesn't mean it doesn't exist. Yes, but this is the premise that has led to paradigm bloat in other languages that try to be everything for everyone like in C++ and C#. I don't want Go to become that language. I want it to be a very specific, refined language, and do that *extremely well*
&gt; Don't use a framework. I echo this (no pun intended) and suggest to most people to *never* use a framework. Go really helps you break free from that mentality. In other languages, you tend to get attracted to them because of their big frameworks -- No one would have coded C# without the .NET framework, nobody would have probably coded Ruby if it weren't for Rails, and Java wouldn't attract so many people if it weren't for whatever enterprise monstrosity is popular these days (is it still Spring?). Go teaches you to be a programmer. I love that The only thing I find myself reaching for at times is a mux.
Generics has nothing to do with OOP. ML had them a decade before C++. Some of the features of OOP you refer to that are popular, are also widely considered to be misfeatures. There is a lot of literature about the issues faced in inheritance, to the point that some C++ style guides strongly discourage its use. Leaving that out of Go is entirely defensible. Generics already exist in Go for a very good reason - maps and slices being typed adds great value. Not exposing users of Go to this feature, limits expression *particularly in libraries*. If some people who like to write good libraries have less interest in Go for lack of this feature, I don't think that is a win for the community.
Someone already gave you a definition but here's a concrete example: http://pokeapi.co/
Dude, you need to learn to use google and stop posting basic questions unrelated to golang in the golang reddit. You've been doing this for two weeks and you haven't asked a single question that both made sense and couldn't be easily googled. You're also constantly posting bitcoin related stuff in here and this is not a subreddit about bitcoins. Learn to put some effort into the questions you ask, especially if you want people to put effort into answering your questions. Right now you're just spamming.
C does not have generics. The generic selection operator is not nearly the same thing as what is typically considered an implementation of generics. Macros are textual replacement, not generics. Note that `_Generic` came in only six years ago and isn't really used outside of implementations of the mathematical standard library. High level code in C is perfectly easy to write. As with every thing, you just need to know what you are doing.
And what are template generics? Basically text replacement right before compilation. You can use C macros almost as fully featured generics, but noone does it because it sucks and you get nonreadable error messages. But yeah, C doesn't have proiper generics. But it has something that can be used as generics (somewhat).
That does nothing to remove the allocation, just lets the caller, in the best case, reuse a slice for many `keys` calls. `range` has no such problem.
I think you're misunderstanding the purpose of `keys`. It's not to iterate. We have that. It's called `range`. It's because sometimes you need all the keys in a slice. For example, if you need your keys output in a sorted order.
And you can get that by iterating the keys, and putting them into a slice...
&gt; C doesn't have generics and it's doing fine. C and Go are different beasts. Let’s say you want to implement a min() function. In C, without generics, you can use a macro : #define MIN(a, b) ((a &lt; b) ? a : b) Whether you use ints, chars, doubles, this code just works, no need to cast anything. In Go, either you create multiple functions for Ints or Floats, or you use interface{} with a type switch, which would be ugly in this case. I don’t think I’m wrong if I say that most of us expect Go to be safer than C (less undefined behaviors, less segfaults due to bad memory usage, etc.). Generics will help, by enforcing type-safety at compile-time. edit: parenthesis around the macro
…which is a pain in the ass to type out, so we wish there were a function to make it less of a pain.
Templates do much more, like ensuring type safety and allowing for polymorphism (as in, you can use the same name for different instances of the same template) All these things are very difficult to do with macros.
Yet, if you add `keys` to the language, you'll end up with people using it unnecessarily; I guarantee you will end up seeing `for i, k := range keys(m)`. Python went through that, and trying to get people to switch to `iterkeys` was a pain.
C isn't "for kernels, drivers, really low level code". It's a general programming language, like Go is. There are billions of lines of "higher-level code" in C, with thousands being added every day. Whether it's a good thing that these sort of programs are being written in C is up for debate, but the fact is that there is loads of such code, and much of it works pretty well. ---- Macros aren't really "generics". You can do the same sort of "generics" in Go by generating code. Macros are just a shortcut to generate code.
Agree. Thats like with early Java. People were screaming to be able to overload operators like in C++. Java kept a firm stand on its no. Did this negatively affect the future of Java ? I no way. Java is a great success. This generic request sound to my like people requesting faster horses. Don't say WHAT you want. Say WHY you need it. The fact the we see so few justification for the need of generics is suspect. It looks like a feature nice to have. 
I wrote a POC to execute jsonlogic rules http://jsonlogic.com/ using the otto https://github.com/robertkrimen/otto javascript interpreter. It worked but the rules were limited to serial execution. I ultimately defined a similar json based syntax and implemented it directly in go using a map of handler wrappers over funcs to allow rules to recurse and resolve themselves. Sorry can't share though. The format was fairly easy to support in an angular UI for editing and showing the rule syntax in pseudo code. I solved infinite recursion by using a middleware handler to count the number of hits and depth and bail out when a configurable limit was detected.
As long as Go doesn't have `SimpleBeanFactoryAwareAspectInstanceFactory` or `InternalFrameInternalFrameTitlePaneInternalFrameTitlePane MaximizeButtonWindowNotFocusedState` it will be better than Java :-)
Not that difficult: https://repl.it/JdyF/0 Still in serious C it is practically useless.
https://play.golang.org/p/GYboDFzxsS
Real question to ask is "will you keep using Go even if it decides not to implement generics". Go has large user base, and I suspect 99% people using it would answer "yes". Large user base also proves lack of generics is not big turn off for new users. 
Yes you can do everything in C and Go too. But how many people ale writing kernels in Go and webservers in C? Like common. Why people don't mind code generation but when option of standardized and automatic code generation is brought up everyone looses their mind.
I will preface this by saying I generally use real data and seed packages and if testing.Short() ... t.Skip to avoid long tests that depend on a real database. For the case where you just want to test error handling, retry cancel logic or some other hard to produce edge case try github.com/DATA-DOG/go-sqlmock. I'm using it lightly with github.com/jmoiron/sqlx and postgres and getting stuff done.
I'm not sure what other underlying business problem he could be referring to. I'm looking forward to hearing his solution if they choose to go without them for 2.0. 
I'd say three quarters of the people who bring it up are people trying (or just reading about) Go and disliking the fact that they're missing, and a quarter are people actively programming in Go who have problems that would be solved or simplified if generics existed. I'm in the latter camp, personally.
Funny you mention fallacies right after assuming because I want Y (generics) I must also want X (Dependent types), Y..Z (beyond). I also didn't say that more static guarantees equal a better programming language.. I said it results in a more correct **(Go, remember, this is a thread about Go programs in a Go subreddit, hence any reasonable person can assume I am talking about Go)** program at compile time. My post is clear, I want more type safety by abolishing empty interface usage in places a generic T could be used instead. If you don't want generics that's fine, but at least form real arguments. It's amusing how so many people from a career field that demands constant critical thinking and making use of higher order reasoning use very little of either when it comes to opposing views. I mean try to apply your reasoning to computer science, I.e compilers: &gt; He wants generics, he MUST be want dependent types and beyond! i := 0 i++ // He incremented an integer, that means he must want // to exit the program immediately! &gt; That would mean dependent types and beyond. What? Compiler? Who said anything about exiting programs? **point: read the words, respond to the words, don't put new words, the other party is capable of writing their own. You may find as a result they pay more attention to yours when they don't have to reiterate their own.**
Thanks, you summarized my main reason for pointing out the reflection API accurately. Things like [Swapper](https://golang.org/pkg/reflect/#Swapper) I feel give a strong hint that generics are needed.
I too want closure, and agree that this is a good attempt to reach it, but it was decided pretty early on that Go 1 wouldn't have generics (or any other language change) and it still kept coming up.
Thanks a lot for your review ! I applied all changes you told me excepting the one with the logger package which requires more refactoring. &gt; I don't understand this part, isn't Lings a func local variable? I don't understand what you don't understand &gt; looks like the break always occurs, do you only want that loop ran once? No, the ``` if err != nil { continue } ``` L245-247 continue the loop if the package could not be downloaded
You may need a few parts, such as: * reflect.Kind const for generic * reflect.Generic struct possibly, but perhaps a generic can be represented in only a couple return values specifying InT and OutT meaning it could just live on Type interface and reflect.Value * reflect.GenericOf could maybe be needed depending on design outcomes and such All and all the surface area would be pretty minimal I think. If you removed recent additions for sorting along like [Swapper](https://golang.org/pkg/reflect/#Swapper) which only exist due to lack of generics you end up with a similar surface area.
Just give us generics for fucks sake. If we're going to go full autism and not have basic features then why do we have strings? Do we really need anything other than pointers to an array of characters? Like honestly guys I can do the same thing without strings in only 10x more code so why not simplify the language and remove strings since simplicity is so important. Do we really need types? Like why not just have pointers to an array of bytes. You make a variable with var x = byte(4) and then use those 4 bytes like an integer writing all of the functions you need and using bit operations. That would be so fucking simple, you don't even need most of the compiler features because the person just uses bytes directly with no complex ints or doubles floating around in the code.
What languages with generics have you used in the past and how does go reduce the need compared to them? Languages with generics always have some interface-equivalent feature, so I don't see how go's interfaces help with needing generics. 
1) more complex and slow compiler 2) more complex and hard to write/read/understand/debug language 3) less "social" language (none know what the hell it means) 4) a complete study of the language lasts more than a life 5) generics will not help with generating fastjson or gogo/protobuf like code 6) generics will not help with OpenGL bindings 7) There is Linux Torvalds' opinion about C++ and around, google it 8) there is `interface{}`, there is `unsafe.Pointer` 9) think about behaviour of a type instead of what a type is 10) use `go generate` 
&gt; Did this negatively affect the future of Java ? I no way. Java is a great success. Of course not, no language's future would be impacted by something as petty as operator overloading. Operator overloading is simply a syntactic convenience. Generics are different, because the alternatives have downsides. Manual templating of code (genny, etc) is sloppy and needs a build step. Dropping down to `interface {}` hurts performance and type safety. Operator overloading is just syntactic sugar and a readability enhancement. People haven't really gotten over this - this is still a common complaint in the community. It makes working in some domains annoying (eg, gamedev when you want to add two `Vector3`s together). &gt; This generic request sound to my like people requesting faster horses. Don't say WHAT you want. Say WHY you need it. This isn't necessary. Generics aren't a cutting edge or controversial feature (in non-go communities). They have been around for decades and their use cases are thoroughly understood. Just look at any anti-go blogpost and read people's complaints about generics. Or peruse go's stdlib docs and imagine the benefits of omitting `interface {}` from functions. Look at any generic-having language's stdlib and look at the functions that are generic, and ask yourself what a go implementation would look like.
&gt; Funny you mention fallacies right after assuming because I want Y (generics) I must also want X (Dependent types), Y..Z (beyond). You wrote "**as much** guarantees **as possible**", which leads to this conclusion.
&gt; C doesn't have generics and it's doing fine. This is a non-argument. No one is saying a language can't do its job without generics. But you see people working around generics in C, and it sucks there too. Functions often take `void *` which hurts performance and has no type safety. Or they use templates with placeholders as generators. 
I don't think generics necessarily obviate or even reduce the need for runtime reflection. Java, C#, and C++ all have generics and still use reflection quite a lot.
Do you use Go without relying on maps/slices/channels and the append/delete/copy/make functions? If you do not, this comment feels quite arrogant, since you obviously have no problem with consuming generic apis, yet think generic apis would somehow ruin the language.
 if a, s, d, f := 0, 5, get(val1, val2), 6; checkOut(a,s,d,f) == something { return } Programmers should not be allowed to make the code less readable
Compiler works with the language. All this things (generics, preprocessors, templates) are on top of compiler. Any developer can write his own level above. And there is only one reason why this thing is not alive. Nobody need it, except developers who don't know what they want. 
In a thread about adding generics to Go, you chose to interpret it that way so you would have something to disagree with rather than the obvious take away that generics would provide more guarantees your program is correct at compile time for many Go programs today. Again my entire point of the last reply was how unreasonable it is to assume that I want EVERY SINGLE feature that provides compile time type safety because I'm discussing the benefits of a single one in a Go subreddit. So, do you have a valid argument against my main claim, additional guarantees of a correct program at compile time from many of the Go programs we right today? If so I would love to hear it. If your argument is solid I may have to reevaluate my position for generics since this is a heavy factor for me along with programmer time. I may even become against generics if your view resonates that will with me, and it could, because I'm reasonable. I change my positions all the time on technical subjects because it's not personal. I arrived to every cconclusion off of research and experience.. not some internal spiritual journey guided by my moral compass. If I find new research or have new experience why on earth would I care to pivot? Or be butt hurt if I can't get someone else to, my experience and research formed a different conclusion. Cool, move on. People need to learn these things. Not specifically directed at you but it's so hard to have meaningful conversations here anymore.
I agree that I am working against the convention of the build system but realistically I can't see much of a draw back with this approach. Looking for specific reasons why this might bite me. To avoid name collisions of files I can actually pre-pend the directory names to the file names in the generated directory since the file names do not matter anyways. This way two files named view.go in directories module1 and module2 could resolve to module1-view.go, module2-view.go respectively. I think in terms of a web-server it makes sense to have separate directories for code organization that does not affect the build system. If I break out everything into sub packages to support multiple directories using the standard build command then everything has to be injected into everything else and has to be returned as functions to wrap scope which in my opinion is both ugly and unnecessary. One monolithic package while still supporting multiple directories to me is a big win. Its annoying trying to find the file I want on a server when there are 100+ files in one directory and several end up named similarly to reflect their relation rather than being grouped in a directory for the same effect.
It runs before compiler like `go generate` does
I have programmed for a long time and I cannot think of any problems that fit the "hey I need generics" to do this problem. Where is that list? Or what are some of the problems that need generics to be solved/worked on efficiently? Just wondering. 
I absolutely love Go. It's great. It would be greater with generics. It's a pain reimplementing stuff for different types.
Where can I learn about how to do this?
Note that this way, if you declare two `G` on different lines, they are going to have different types.
I'm not sure I agree. For the immediate future, yes of course. But the big advantage of go, easy concurrency is starting to appear in other languages. Pretty much every name brand language is getting some form of async/await syntax which are nearly as easy to use as go routines. Go wins on syntactic lightness in many cases, but even that is diminished now that type inference has made it to the main stream. 
&gt; generics, inheritance, polymorphism Yep, you should check [this](https://en.wikipedia.org/wiki/Polymorphism_(computer_science\)) out. &gt; Go: keeping a simple, easy to understand language What is the benefit? To hire more unskilled labour which will write more shitty code? &gt; ... encourages you to handle errors at all stages. It doesn't encourage it at all. If you forgot your `if(err != nil)` you're done. And you can't even manage errors properly. &gt; I'm happy without generics, but some see great value in them... but blindly fitting generics in just because of popularity would be a mistake. How about CS 101? Or just fuck typesafety and copy-paste like a retard? 
&gt; People want generics because they are used to them. Because they're useful and there's no saner and more typesafe way. &gt; What if there'd be a better way to go at generics? Be open-minded and let the language designers take their time to make a profound statement and come up with a thorough solution. Or just don't be stubborn idiots and learn what can generics do?
If your chief argument against Go being a simple language is "preventing the unclean from sullying our precious environment" then you definitely haven't understood the reason Go exists in the first place. &gt; It doesn't encourage it at all. It absolutely does. Every function capable of having an error condition in the standard library explicitly passes back an error type that you should handle. There are even tools like `errcheck` that process your code and point out where you haven't handled the error. This is in stark contrast to other languages where error checking is a lot more opaque. &gt; And you can't even manage errors properly. What? &gt; How about CS 101? Or just fuck typesafety and copy-paste like a retard? Yeah, you just lost any right to have a rational argument on this subreddit. https://golang.org/conduct
You could use cgo if you want to call the function from your Go application. If the rust system is large enough maybe considering separating it into its own service and creating an official contract between the two using grpc. Typically I think it's good to stay away from cgo unless you end up hitting a road block that leaves no other options.
&gt; Generics has nothing to do with OOP. It has a lot to do with it. The vast majority of languages that make heavy use of generics are object-oriented, with much of the rest being functional. &gt; If some people who like to write good libraries have less interest in Go for lack of this feature, I don't think that is a win for the community. A fair point, countered only by the fact that if you always follow "the will of the people" you end up with something akin to C++, which is what the Go founders were trying to actively avoid. I like the fact that I easily read and understood the language specification, and that it wasn't an impenetrable tome of corner cases and compromises. Go, to me, is very efficient. I understand every feature pretty well, and those that I don't are easily researched using the Go documents themselves, not just by searching countless web fora. That's just my opinion though.
It's pretty straightforward to do this if you find yourself using these loops a lot on a given type and find it cumbersome. You can easily write filter and map funcs on a list type such that you can chain the functions etc. https://play.golang.org/p/oWSTTwSwuu hasPrefixA := func(s string) bool { return strings.HasPrefix(s, "A") } atoDash := func(s string) string { return strings.Replace(s, "A", "-", 1) } a := StringList{"Apple", "Banana"}.Filter(hasPrefixA).Map(atoDash) -&gt; [-pple] Now I agree this might be nice to see first class support for (and other functions like range), but it is not exactly insoluble if you find yourself wanting to use these functions all the time, it's perfectly possible to work in a functional way and remain type safe. The number of types of lists you want to manipulate in this way is usually really quite limited, so I don't find it a huge problem in this particular instance just to write the functions on a list type and use that. 
Make that with a side of undefined behavior and infinite include-cycle sauce. 
While Go interfaces are a powerful tool, this isn't really a substitute for generic programming, For me, the issue lies with the fact that interfaces also come with a trade-off of interface values needing dynamic dispatch and not being inlinable, so using them has costs associated with it. I generally fall on the side of the argument that you shouldn't compare the two because one (generics) can be compile-time checked and therefore optimizations can be performed, and therefore Is a zero-cost abstraction while using an interface is not necessarily zero-cost. It may not be expensive in all cases, but anywhere with a tight loop will suffer a performance hit if a simple method (like sort.Interface's Less, generally implemented as a &lt; b) is called repeatedly and cannot be in-lined to prevent having to grow the stack. Of course, often generic programming benefits from operator overloading so as not to be restrictive, and that is a can of worms I'm not sure the Go team needs or wants to open.
&gt; The feedback from the community has been **overwhelming** on every forum regarding go 2.0. Look it up if you don't believe me. I may not speak for everyone, but I do speak for more than a handful of people. Those of us who don't want generics are pretty tired of others beating this dead horse all the time. It's not that we don't exist; it's that we're busy doing other things and find most of these discussions boring and pointless to contribute to. Those discussions are also often comprised of people who don't actually write Go as their primary language, as is evident from the names on the mailing list (oftentimes contributors to other languages, using their real names). As a Go programmer, I have better things to do than argue with someone who doesn't even write Go complaining that Go doesn't do things the same way their favorite language does. 
So we agree that maximizing compile time type safety is not a sensible programming language design goal. A line has to be drawn somewhere between no type safety and maximum type safety. You say it's at 80%, I say it's at 70%.
Generic algorithms can be done very cleanly using interfaces (the sort package/interface is an oft cited example of this). I think any proposal that adds generics which facilitate generic algorithms should be rejected as they unnecessarily complicate the language. After all, the beauty and power of Go is its simplicity. However, when it comes to generic data structures, Go is lacking. Evidently the original creators of Go felt this too when they decided to add a select few generic data structures to the language such as slices, maps, and channels. Fortunately, these data types cover nearly all the use cases where generics are really needed. The only time I've felt the need for generic types is when I've implemented or used specialized data structures. Losing compile type safety and having to liter type assertions through out my code to use these data structures is makes code more brittle, makes code less readable, and leads to excessive code duplication. I think one reason why generics haven't been added to the language is because most proposals try to accomplish both generic algorithms and generic data structures. They tend to propose some cute little syntax that doesn't cover all the corner cases, and also add incredible complication to the language as they would affect virtually every part of the language in some way not defined in the proposal. Personally, if I were writing a generics proposal for Go, I would only add them to struct types and nothing else, and would try to duplicate the syntax that is already in the language. Only the simplest, most minimalistic proposal will be accepted.
"Simplicity is a great virtue but it requires hard work to achieve it and education to appreciate it. And to make matters worse: complexity sells better." — Dijkstra (1984) On the nature of Computing Science (http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD896.html)
Honestly, most cases that folks coming from languages like C++ or Java cite are actually covered either through Go interfaces, or through the built-in generic data types like slice, map or channel. The only place where you really miss generics in Go is in implementing or using generic data structures such as the heap package which forces you to sprinkle type assertions all over. Admittedly, this happens far less frequently than many think, but when it does, Go really is quite awkward to use.
&gt;https://github.com/snwfdhmp/duck/blob/master/pkg/configuration/configuration.go#L197-L200 oh, I was missing that Lings was package global, not local to the func, in which case I don't think https://github.com/snwfdhmp/duck/blob/master/pkg/configuration/configuration.go#L183 is necessary since it was already declared in https://github.com/snwfdhmp/duck/blob/master/pkg/configuration/configuration.go#L53 
Generics is absolutely not a zero cost abstraction. It may be zero cost at runtime (depending on the implementation), but it is probably not zero cost to compile times, it is certainly not zero cost in the complexity of the compiler code, and it is not zero cost to the reader of the generic code either. http://250bpm.com/blog:86
&gt; The vast majority of languages that make heavy use of generics are object-oriented, with much of the rest being functional. [correlation != causation](https://xkcd.com/552/)
&gt;The main thing missing, really, is working with a slice/map of anything. People able to specify that you accept "any" slice or "any" map (whose types have certain capabilities) without having to create a type for that slice/map and make it satisfy some interface. ... So generics, except only for the special case of slices/maps?
you're talking about the part of the code, where it listens for broadcast messages correct?
I've seen multiple examples of Go code, usually by newbies, that simply ignored error handling one way or another. I think it was even on this sub a while ago. So yeah, so much for explicit errors... 
Thanks for the advice! Are there any real downsides to cgo?
The problem with this notion is that, once you put things in a container, you generally want to do stuff with it which is application specific. So you access the contents of the container... and are limited to whatever interface the container defined for its contents. The only way to access the operations *you* need is to use type assertions (even if only to another interface type). And this is where your code isn't statically type checked. A second problem with this notion is that a lot of operations require having two values of the same type, not just numeric operations. For example, if you have two slices and want to move values from one to the other, they need to be the same type of slice. Even if you're using interfaces everywhere and have slices of interfaces, you still need to know that the element types implement the same interface. If you want to put a value into the slice, its type needs to be the same as the element type of the slice, again, even with interfaces. Statically checked polymorphism based only on the operations provided by individual values is simply not sufficient for many common use cases, since you also need to be able to be polymorphic over the relationships *between* values. The only way around this is to use type assertions everywhere and treat the language as dynamically typed with inconvenient syntax (type assertions). Go is specifically not a dynamically typed language. A big point of the design is that interfaces are statically checked, and that it has concrete types like structs, numbers, arrays/slices, maps, channels, functions, and pointers, which you spend much of your time working with directly.
Hard means high opportunity cost. Its not so much "Who is going to pay for it?" More like "What could we have done with the same effort instead of generics?" and "What other features become significantly harder to implement after generics are in place?" Also, its not just the man hours to implement generics, what about the other expensive side-effects, like compile time? Like IDE complexity? Personally, I'm hoping we don't get generics, but that is mostly based on my experiences with them in Java, where the very heirarchical OO nature of the language made for a LOT of friction points when generics were introduced. Java too was a simple(r) language once :) I'm hoping that if the rowdy bunch gets their way and we get generics, it wont be as [shitty](https://docs.oracle.com/javase/tutorial/java/generics/nonReifiableVarargsType.html) as it is in [Java.](https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html) Closing thoughts... Some of us prefer our languages to be lean and mean, and to be easily read, and reasoned. Once they are there, they are there forever, for better or worse. We will pay for them with compile time on every.single.compile. Almost every line of Go code that we read will be a little less simple to rationalize, so we will pay and pay and pay in brain power. So, yes, IMO just because its hard IS a solid reason not to do it.
Is there a computing problem that cannot be solved in the absence of generics?I am not aware of one. I know many problems become simpler with generics, or less verbose, but I cannot think of any that *require* generics. 
There's these two projects called Apache and nginx, you may have heard of them...
&gt;Is there a computing problem that cannot be solved in the absence of generics?I am not aware of one. I know many problems become simpler with generics, or less verbose, but I cannot think of any that *require* generics. I can use all the same arguments you just gave for why we all should go back to programming in binary.
Oh, for sure. I didn't say it forced you to deal with errors though, just that it encourages it ;)
1) I asked a question, I didn't "give arguments." 2) It would be irrelevant to the thread, which is about the complexity and necessity of generics. I was trying to draw out from /u/Wenste why he thinks generics may be necessary. 
Haha i totalt didn't see that I was posting in the golang subreddit :-D 
Oh sure, we agree on an unrelated conclusion dealing in absolutes drawn by your subjective-to-the-point of arbitrary quantification. Since it can't be effectively measured and is a close number we've removed cognitive disparity with dissonance! Now we can both stop replying without being "wrong" and avoid the devastating consequences that come with it. Thanks for saving us from ourselves! Never mind the discussion at hand about adding generics, Like the point I provided that it means safer Go programs . Why would either one of us want all our points heard to the disagreeing party? I just want to walk away feeling like my team won! Happy coding and stuff. 
And yet those same algorithms that you mentioned suffer from poor performance precisely because they rely on interfaces. And they are much harder to use, and more confusing to novices. This simplicity you mention is nowhere to be found in this case. In fact, having an implementation using genetics would make things a lot simper. That's exactly why there's a new sort function in 1.8.
Sorry it is late here, I though you meant to say that you didn't wanted to add generic because they aren't necessary. My bad. Would generics be in the same way an necessity now a days in the same way we call functions necessary?
&gt;I can't build a compiler myself, but I can imagine that adding generics to the language will make the compiler a lot more complex to implement. It's not that hard, bro. You just substitute symbols. Your commander just doesn't want to admit that his decision was retarded. &gt; That's a proper reason not to implement them. There's no other justification needed. Rofl tell that to the people who work on compilers for every statically typed language that people give a shit about. Gb2 thought school this is cargo-cult tier justifications
&gt; I program in Go for more than a year and never met the need for generics. That doesn't prove that black swan don't exist of course. Have you used a map type? What about a channel? What about the append function? If you have, then you definitely had a need for genetics, and the language meet them with a handful of magic builtins. The problem is that they are quite magical. &gt; Go interfaces removes the need for generics for most use cases. Whatever quacks is a duck. So when you implement a container, one should provide an interface for items that can be stored in it Have you ever tried what you just wrote? If you had, you would've known that there are glaring limitations to this approach. &gt; This is why I stick to int in my code. So either you write very small apps, or you clearly have a need for genetics.
Yes I think working with cgo is just nuanced and unpleasant in general, but I also don't like working with c or c++ anymore so your mileage may vary. A more concrete reason to avoid it anything beyond hello world with basic types you end up importing unsafe to work outside the type system.
 - An overhead to calls across the cgo&lt;-&gt; go boundary, a few hundred ~~ms~~ **ns** - Cgo calls establish full C threads and are significantly more expensive than lightweight Go calls - It makes compiling and consuming your application much more difficult Dave Cheney goes into much more detail in this great article: https://dave.cheney.net/2016/01/18/cgo-is-not-go
If the performance hit of wrapping your concrete type with the sort interface is so big (and its not really big btw) that you can't use the sort package algorithm, then you've found a case where you do not want generic programming, but instead you need fine-tuned code custom tailored to your exact use case. The sort package is in fact quite simple. The sort interface is small and trivial to implement. Using interfaces in this way to accomplish generic algorithms may be different than how you'd do it in other languages, but that doesn't mean it is hard. Its just different. Go isn't that other language, nor should it be.
I think it's funny how Go is the language with the most memes adapted to it. I wonder why?
To be perfectly honest, in my opinion, generics are NOT a necessity, they are a language feature that makes SOME problems *easier* to solve, but at a dramatic costs, for example higher compile times, and more complexity in the language spec. I am not categorically against generics, I think that there should be languages with generics, and languages without generics. It may well be possible that Go 2.0 will provide generics, or something like them designed and implemented so well that the cost in the compiler, and the language complexity is lower than the gain for SOME classes of problem, but I am a skeptic. I don't think it is. &gt;Would generics be in the same way an necessity now a days in the same way we call functions necessary? Think for a second about an HTTP server. Listens on a TCP socket, accepts a handle, forks in some fashion or other, reads bytes, validates the request, deals with headers, routing, resources, and writing responses back to the client. It is almost impossible for me to conceive of such a complex program without functions. You would need to either copy huge chunks of code, or bring back GOTO, and deal with the tangled mess that arises. Functions also abstract away large chunks of complexity. Also, variable scoping is usually a pretty neat side effect of functions. Writing an http server without generics... that's been done. 
Yes yes yes yes yes yes yes yes yes yes yes yes yes. Otherwise why?
IIUC `void*` actually doesn't hurt performance, but throws type safety totally out the window (as-in, it's UB and you'll get incomprehensible errors). Type asserts in Go retain some form of safety because you can handle the error, but there you do take the performance hit.
C is a painful language
&gt; Generic algorithms can be done very cleanly using interfaces (the sort package/interface is an oft cited example of this). But this isn't _just_ using interfaces -- it relies somewhat heavily on the built-in genericism of slices, because that's almost always the underlying type implementing `sort.Interface`. When you don't have a built-in generic type to piggy-back off of, you often need to turn to using `interface{}`. E.g.: https://godoc.org/container/list
&gt; Go tries to keep complexity to a minimum, which IMHO, wouldn't disallow Go to have well known syntactic-sugar. I think it's been fairly clear that this is not what Go means by simplicity: they mean simplicity of the language constructs being used to build programs, not simplicity of the programs built over those constructs.
It's _very_ clear when this is happening though, which isn't the case for a function that may throw an exception.
Are you talking about sort.Interface with sort.Sort (which is just interfaces, and is an example of generic algorithms using interfaces), or the new (as of 1.8) sort.Slice which uses reflection to implement sort.Interface for sort.Sort? Reflection is a different animal than generics altogether...
&gt; which is just interfaces, and is an example of generic algorithms using interfaces Yes but the type that implements `sort.Interface` is almost always a slice, which is a built-in generic type. So it's in a sense "piggy-backing" off of the genercism baked into the language. Reflection and generics are different but related; you can often use both to solve similar problems.
A quick check to see if a variable is not being inherited by child processes is to run the same command proceeded by your var declaration, i.e. $ GOPATH=~/.go go get -u ...
&gt; Yes but the type that implements sort.Interface is almost always a slice, which is a built-in generic type. So it's in a sense "piggy-backing" off of the genercism baked into the language. The fact that it doesn't *have* to be a slice still illustrates the difference between generic algorithms via interfaces, and generic data structures, which we only have with slices, maps, channels and arrays. &gt; Reflection and generics are different but related; you can often use both to solve similar problems. Are you arguing that reflection is all we need in Go to implement generic data structures? I mean...sure you *can* do it this way, but you lose type safety and readability, which is a huge problem. Adding generic data types would give you the ability to cleanly solve these problem, and the existing interfaces gives you the ability to do generic algorithms using any type, including generic data structures.
I just want an easier way to extend interfaces. Currently it's just too much copy/paste and gratuitous repetition.
 I am an old C hacker and - more recently - a Python devotee' - just putting toes in the go waters.. Could you comment a bit on why you feel closure is needed?
&gt; An overhead to calls across the cgo&lt;-&gt; go boundary, a few hundred ms False, it is massively improved since 1.8 and never was hundreds of ms of begin with. &gt; Cgo calls establish full C threads and are significantly more expensive than lightweight Go calls Depending on your needs, this might not be a problem at all. &gt; It makes compiling and consuming your application much more difficult False, the compilation remains the same and if you layout the packages in a nice way, you pay the C compilation penalty only when you actually have changes in the C files, much like the Go compiler does for the .go files.
To me that shows how important of an issue it is to the community, and why the developers hardline stance of "lol no generics" is damaging the language in the long-term.
There are many ways to do generics, rust and typescript both have solid models that though different make many kinds of problem easier to read.
You should put parenthesis around the macro expression to avoid unintended side effects during the lexical expansion.
I use bolt with [storm](github.com/asdine/storm) whenever possible because it really leaves behind the trouble crossing from data store to app and back. If I can't use that I use a pure go SQL Server driver but am far less happy.
C used to be a highish level programming language like Go, but it isn't anymore.
You should build the binary locally and copy it on your box! You should also probably use something like Supervisor to make sure whatever it is you are running stays alive / restarts automatically etc.
Please don't use the word retard in this subreddit unless you mean "to hold back".
Awesome 🙂. I'm excited. Gonna go with systemd. Also completely irrelevant but from playing w GoLang this week, the error returns are intensely frequent. Do you typically handle all errors or ignore some? For instance I'm using datastore and saves return a potential error. Do you just log and proceed in such cases? Also appengine logs omit the line they occurred on o___O whattt
Please don't use the linked list library in the standard library. Just write your own if you need one. It's not hard. And saying that he doesn't have proper backing is funny, given that he's been writing Go since before 1.0. I worked with him for 3.5 years at Canonical on a 500k LOC codebase. He knows what he's talking about.
Do not use the term retarded in this subreddit.
Depends what you mean by handling it. Some errors are not a huge deal and there, I would only log those and move on. If they induce a break or a change in logic, then yeah, handle them directly. About logging: If you're using the `log` package, by default it does not include line numbers, but you can absolutely add them: `log.SetFlags(log.Lshortfile | log.LstdFlags)` `log.Lshortfile` is what adds the line numbers, `log.LstdFlags` is just to make sure the default settings for the logger are still there. Check the example here: https://play.golang.org/p/ZiYqmw1Fmv
Whoa, sorry, didn't mean to personally offend or anything! Happy to answer questions and discuss to clarify what I said. &gt; False, it is massively improved since 1.8 and never was hundreds of ms of begin with. I made a super trivial cgo program [here](https://play.golang.org/p/3fUwNqaVGS) and benchmarked it on 1.8.1 ➜ cgo_test go test -bench=. ./ BenchmarkCgoCall 20000000 96.4 ns/op PASS ok _/home/connor/cgo_test 2.030s The hundred**s** might have been a bit high, but bear in mind that for any non-trivial function you're probably going to be passing in data that needs to be allocated and copied over to the C heap. Even if it's just a filename for C to do further processing on. "Real world" overheads are usually in the hundreds of nanoseconds. Just passing in a string to the function, for instance, bumps it up to 372 ns/op. **edit**: realize I wrote ms instead of ns in my comment above, I meant ns. My bad! &gt; Depending on your needs, this might not be a problem at all. Totally agree! &gt; False, the compilation remains the same and if you layout the packages in a nice way Hm, that's interesting. For me, compilation of that sample program I linked above failed on Windows with Cygwin -- not a particularly exotic environment. { cgo-test } » go test -bench=. ./ gcc: error: CreateProcess: No such file or directory FAIL _/C_/Users/Connor/Downloads/cgo-test [build failed] Ended up running it on a Linux VM. Indeed, it looks like cgo in cygwin has [no shortage of issues](https://www.google.com/search?q=cygwin+cgo) and, at least four years ago, [no support](https://github.com/golang/go/issues/3624#issuecomment-66067201). Considering I develop normal Go code perfectly fine in cygwin, I would say this is making compilation more difficult.
I think rust did a great job with generics
When Peter Bourgon says you [don't](https://peter.bourgon.org/go-in-production/), you [don't](https://peter.bourgon.org/go-best-practices-2016/).
How much work would be required to add the training features to Go? This remains my biggest concern looking at Tensorflow.
Do you write code or libraries? You're absolutely right, code doesn't need generics. But libraries do. For example, sync.Map could be just as type-safe as the built in map. But it's not, because of the lack of generics.
But it's not like Go supports operator overloading, so yes, built in types are going to be special. For example, in C++ you can address a Vector (or LinkedList, or whatever it is in the STL) as `v[1]` not in Go. You can write something like `test := (5i+2)*(3i*4)` but not `test := myVec*3`
Also, another point :), is that one of the common complaints is that it's not "fair" since Go's inventors could create their own generics, but don't let us. The thing is that for the last five years (at least), they haven't added any new generic types. Maps, slices and channels were all around since Go 1.0, and the Go BDFLs have had to use interface{} for map.Sync. So they _do_ experience some of the pain.
He is about 75 now, so it wouldn't surprise me.
At my workplace, we have a jenkins box where the whole deployment pipeline runs (unit tests, integration tests, so on), and the building process happens. There, build the app and simply upload the binary to the server with the necessary configuration files for it to run.
I was thinking since the type isn't known in the function body, the compiler wouldn't be able to optimize the code as well as if it were a concrete type.
`echo $GOPATH` first expands the variable `GOPATH` available in the current shell. So it becomes `echo /Users/user/.go`. `go env GOPATH` uses the `GOPATH` in the child process.
We should: - Define a variable object with its various properties (copying the python implementation) - For every operation define the gradient: this is the longest part - Test everything 
JFFR: Use "env | grep GOPATH". As env is a sub-process (at least semantically), it won't know about local variables and only actual environment variables.
I don't believe that is true. The communication was always a pretty direct and consistent "we want generics, we just don't know how yet".
This is not anyone's stance on anything. It is a tiresome persistent meme, but it is a complete fabrication in direct contradiction to literally everything the go team has said on the topic. *I* don't want generics in go. But the go team sure as hell wants them.
I hate remote import path
[await/async isn't as nice as goroutines](http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/), though there are a few modern languages with similar ease of coroutines (Rust). Although there were quite a few languages with relatively simple concurrency before (Java), and it didn't stop `go` from starting.
I read your go hate blog post. Wew. Also, don't get your panties in a twist boy.
Same for me. I tried glide and hit a wall with its numerous bug which makes it unusable. I immediately went for dep once they finalized the manifest.
I'm not saying whether they should or shouldn't be implemented, I'm just saying that the Go team's refusal to compromise/debate isn't good.
&gt; I'm just saying that the Go team's refusal to compromise/debate isn't good. Again, this is completely fabricated. The go team has repeatedly discussed the topic. For crying out loud, Russ Cox' Keynote from Gophercon was pretty much just an hour long plea for arguments and problems; yet, so far literally the only actual reply I've seen doing what he asked, comes [from the go team](http://www.airs.com/blog/archives/559). You disagree with their conclusions so far? Fine. You don't understand why they need what they are saying? Okay. You think the issue is simpler than [what they think](https://research.swtch.com/generic)? That's your prerogative. But making claims about their position and willingness to discuss this that are just plain false and directly contradicting everything they have put out about the topic is not okay. It's harmful to your own position.
My understanding was that it would involve a (significant) language change, and would therefore need to be part of Go 2, but I could be wrong.
It'd be nice to have a collection of video snippets describing the reason about every Go decision, reading is one thing, but listening to the actual person that was part of the decision process explain it is way better. There's a lot to learn about Go and its philosophy from this video.
wat?
Thanks, edited.
&gt; If your chief argument against Go being a simple language is "preventing the unclean from sullying our precious environment" then you definitely haven't understood the reason Go exists in the first place. "The key point here is our programmers are Googlers, they’re not researchers. They’re typically, fairly young, fresh out of school, probably learned Java, maybe learned C or C++, probably learned Python. They’re not capable of understanding a brilliant language but we want to use them to build good software. So, the language that we give them has to be easy for them to understand and easy to adopt." – Rob Pike It exists because wannabe-coders can't understand normal languages and contemporary CS. &gt; It absolutely does. Does it compile if you don't handle your errors? If yes, then your argument is pointless. &gt; There are even tools like errcheck that process your code and point out where you haven't handled the error. Like for every language + there are languages with checked exceptions... &gt; What? Is `if(err != nil)` a proper way to manage errors for you? &gt; Yeah, you just lost any right to have a rational argument on this subreddit. It's not like you gophers are capable of rational arguments when you've been trapped in your echo-chamber for so long...
It’s interesting, but… &gt; * it may not be used outside a function. So, I can’t use blank types to create a “generic” structure (say, a b-tree structure)? It misses the point of generic types.
There has to made be a trade off, but still I think it allows for like 70% of what generics are needed for. Try figure out, if you could simulate a b-tree within these restrictions. It may be possible.
How do I store data in the structure? With an `interface{}`? It’s not enough.
As you said: It does not aim to be generic types that's why it is called blank type. Read the proposal. There the allowed kinds of composed blank types are defined. It might be possible to create the simulation of a tree with them (e.g. with a []$A slice or a map[int]$A map). I don't know if it is possible. It would require some out of the box thinking. Go figure if you can make it work. I frankly don't know. Even if it should not be possible to create a performing tree-like structure with this restrictions, the blank type might still be useful for a lot of applications where a generic function would be used (if Go had generics). (edit A -&gt; $A)
Rewrite your comment in Rust!
&gt; Read the proposal. There the allowed kinds of composed blank types are defined. It might be possible to create the simulation of a tree with them (e.g. with a []A slice or a map[int]A map). I don't know if it is possible. It would require some out of the box thinking. Go figure if you can make it work. I read the proposal. I found it interesting, except for the &gt; * it may not be used outside a function. Maybe I can implement a b-tree with a composed blank type, but the code will be really obscure. ~~And for some data structures, this is unacceptable to use an array (let say, BSTs).~~ &gt;Even if it should not be possible to create a performing tree-like structure with this restrictions, the blank type might still be useful for a lot of applications where a generic function would be used (if Go had generics). It’s not enough, some people want generic data structures, as I said.
I'm curious to see what solution better than parametric polymorphism (something rooted in decades of basic research on types and languages) they will come up with!
&gt; a better way to go at generics Please, elaborate on these ways
It would still be much more than what we have today/without generics.
Yes, but it does not necessarily make it a good solution. 
However，when I insert datas to this table, 200 thousands rows of data will only cost 1 minute.
You just described generics that can only be used inside functions... Why not admit Go need generics and do it properly? Also this syntax would generate unreadable errors. I recommend watching Johnatans Blows video of implementing generics in Jai language. Probably best idea/implementation of generics there is.
In fact, If I update only, the speed is more faster. one update statement only update one row. 
Thanks a lot.
In fact, what I use as a condition is not real primary id, it is just normal id which is unique. and there are not indexes on the related fields in this problem.
Could you elaborate your point about unreadable errors? The kind of errors I expect are: 1. errors from compilation of the blank function, like "blank function blah returns $B but did not get it" or "[][]$B is not allowed". 2. errors from calling a blank function like "blah is called with []$A -&gt; []string and returns $A -&gt; string. a (int) can't be assigned to $A (string) in line 120." 
I have used transactions just like your example. the problem is that, it is slower than execute one by one...
brilliant, I will try this method. thanks.
do you insert new data or update old data?
Yes, you are right, not necessarily. It does provide this without code generation cost and without big compilation cost while being backward compatible. That could make it a good enough solution.
Is he still working on Go? If not, why?
It sounds sad that the more goroutines the slower performance will be. Can you provide me some articles about how to use goroutines correctly? how to use goroutines to increase the performance?
Compiler cost is not the only thing to take in account. You’re overlooking maintainance cost, which is more important in the end. That’s not a tradeoff you’re making here.
&gt; Whoa, sorry, didn't mean to personally offend or anything! How did you even got that?
Use https://godoc.org/github.com/bwmarrin/discordgo#Session.ChannelMessageSendComplex with the Tts field set to true in https://godoc.org/github.com/bwmarrin/discordgo#MessageSend There is also a discordgo server if you need more help. It's where all the devs and users hang out. https://discord.gg/0f1SbxBZjYoCtNPP
 [bwmarrin/discordgo](https://github.com/bwmarrin/discordgo) &gt; *Description*: (Golang) Go bindings for Discord &gt; *Stars*: 332 &gt; *Forks*: 90 &gt; [Issues](https://github.com/bwmarrin/discordgo/issues) | [Pull Requests](https://github.com/bwmarrin/discordgo/pulls) *** ^(This is Earth radio, and now here's human music ♫) ^[Source](https://github.com/anaskhan96/github-stats-bot) ^| ^[PMme](https://np.reddit.com/message/compose?to=github-stats-bot)
Don't even get me started on accidental shadowing. But otherwise, yes, Go's error handling pattern is better than exceptions for control flow.
Probably the biggest problem is if you input two different types where should be one type. For example in this function: ``` func add(x $T, y $T) $T ``` what if users inputs string and int. You can tell them types do not match. Good enought, but not really helpfull. You could also exapnd (generate) that function and return same error as Go compiler returns now. Now you do not convey to the user that some function generate nonsense. More evident it is in function like this: ``` func fn(m map[$K]$T, k $K) $T ``` input types would be: map[int]string, double Now you for sure can't say types don't match (ofcourse they don't) and default error still won't help you. Now the solution is to indicate that some input type depends on another. If I don it same as Jai language, type with $ is the main one (defines the type). Now it looks like this: ``` func fn(m map[$K]$T, k K) T ``` And if user inputs wrong types you can warn them like this: Argument 2 of function fn is type of double but has to be type of int as defined in argument 1. Or something like this which really helps not to get lost in this.
definitely a wrong place to handle log rotation, sorry.
This is basically equivalent to define macros. What would be the type a $A be ? From my current understanding, this is only for base types. Otherwise we could use interfaces for that. No ?
I was actually looking at your client.write() method :) When looking a bit closer at your worker() method with the big select in the for-loop, I have a few other remarks: * Several cases publish on the broadcast channel. Consuming from that broadcast channel happens within the same for-select as the publish cases. A select will take a valid case at random if multiple exist. This means it is possible that your broadcast channel gets filled up to its limit, resulting in a deadlock. You can prevent it by having a priority read first, such as [1]. I am aware that you do have a buffered broadcast channel, so the likelihood if a deadlock may seem small. Nonetheless, you don't want to leave something like that to chance. * Writing a message on a websocket connection can take time if your recipient is slow or if there are some network oddities going on. One thing you can do is set a write deadline on your websocket connection before calling WriteMessage(). This results in your connection being broken (but not closed) when the deadline is exceeded. That way you can decide for yourself when a client should be disconnected. You can also add a buffer to the Client's send channel to allow for a bit of slack in the case of short network hic-ups. Writes that don't exceed a write deadline can still cause a notable delay. Lastly, standardize how you push on a client's send channel. When reading from the broadcast channel, you decide to close and remove a client whose send channel is full. In other cases you have a blocking send. Just a minor one to wrap up with: you can use fmt.Sprint(myIntValue) rather than strconv.Itoa(myIntValue) which accomplishes the same thing, but fmt.Sprint(..) works for anything you want to convert to a string. Less of a headache as you don't need to call the correct strconv method every time :) [1] https://stackoverflow.com/questions/11117382/priority-in-go-select-statement-workaround
https://youtu.be/u-kkf76TDHE?t=24m24s
&gt;[**GopherCon 2014 Inside the Gophers Studio with Blake Mizerany [48:19]**](http://youtu.be/u-kkf76TDHE) &gt;&gt;Presented with the realization that his thunder for his original talk had been covered by the presenters from the previous day Blake switched it up and conducts an insightful panel with the Go team, instead of his original presentation: &gt; [*^Confreaks*](https://www.youtube.com/channel/UCWnPjmqvljcafA0z2U1fwKQ) ^in ^Science ^&amp; ^Technology &gt;*^5,538 ^views ^since ^May ^2014* [^bot ^info](/r/youtubefactsbot/wiki/index)
Umm... first, ignore what I wrote previously. Updating a row requires finding that row first, so at least one index should remain undropped, in order to find that row *efficiently.* This might also be the reason why you observe that inserting is faster than updating. First, an insert does not need to find any row first, because the data is entirely new. Second, if an update affects an index, then two operations are required: one for deleting the old key from the index, and one for inserting a new key. An insert only needs to add a new key. [Here](http://use-the-index-luke.com/sql/dml) is a useful article about performance considerations on inserts, deletes, and updates (esp. the conclusions at the end of the index section).
To add one more consideration: If the volume of updated or inserted data is tiny compared to the volume of data that already exists in the table, dropping and re-creating the indexes might become quite costly so in this case you could be better of leaving the indexes in place. SQL performance tuning is not a cakewalk...
The best one we got is this: https://go-proverbs.github.io/ Each proverb is a link to the part of the video that explains it. If we had more like this it would be great.
&gt; Don't use a framework. Another go newbie here. I am coming from the Python world, and am experimenting on Go as a potential switch for my production apps to make them more maintainable. When would a framework like beego make sense in go? Is using mux okay even if I were to build an app which is meant for production use?
Or you could have real generics which allows for like 100% of what generics are **needed** for. 
There's no need to be rude about it. It's ok to have differing opinions, it's not ok to resort to name calling and rudeness just because you see opinions other than your own :(
TL;DR generics
Valid problem with the language, immutability would be nice, I usually don't let it stop me though. I can also understand the want for DRY but I also think that people that DRY way too religiously and end up writing worse code in the end.
The 10 line solution in the comments is nice. Will definitely add that to my toolbox
TL;DR * Author complains he has to write 30 extra lines of code in Go. * Person in comments provides a solution that reduces code to 10 lines. * Author complains he has to write 10 extra lines of code in Go. 
I would But I'm kinda...... Freshy?...
Funny moment, as soon as generics and parametric polymorphism is mentioned, Brad passes the mic to Rob. https://www.youtube.com/watch?v=u-kkf76TDHE&amp;t=34m33s Also Brad's expression while he does so is priceless.
And what do you need immutability for? Why not just document that the structure must not be modified?
Yeah right, immutability in C# is easy lol. I tried so many times and it never quite works without A LOT of work and going against the tide.
&gt; including an entire micro-service holey moley, no freaking way. Guys hold the phone, he wrote one whole *entire microservice!!!!!!* wowowowowowowow
Well I can't see a real problem here. The convention could simply be: read from left to right, so the first appearance of $[X] would be the reference and the next appearance must match, as in: "add(x $T, y $T) $T inferred $T -&gt; string, but you passed (string, int)" or "add(x $T, y $T) $T inferred $T -&gt; string and therefor returns string. a could not be converted to string." Well for sure these sentences are verbose and could be optimized, but I guess you'll get the point.
No. You misread the proposal. `$A` is just a lexical placeholder and contains no type. At runtime there is no blank type. Interfaces are types that exist at run time. Blank types are concrete types at runtime, so they are type safe. The "open" interface `interface{}` has to be type asserted at runtime to deal with the underlying type. That assertion might fail. With a blank type there is no need for a runtime assertion which might fail, since there is no blank type at runtime.
I've updated the proposal to include type assertion and a section that expands on the ideas. In this section you find an example that may be used to wrap a type/interface{} with the help of an anonymous function. Although just with one method (= the anon func) but it already opens up interesting possibilities.
Array based bsts perform just as well as structs with child pointers. The memory usage increase is minimal considering most BSTs are going to be balanced.
The actual operation needs to be an insert, but you can simulate an update by writing the updated record to the file then deleting it from the database before loading the data.
&gt; When would a framework like beego make sense in go? When you come from other languages and you've taught to think that you can't program without using a framework. &gt; Is using mux okay even if I were to build an app which is meant for production use? Yes. In fact I am not aware of any production code that comes from the Go team where they do not use mux. Take a look at [Upspin](https://github.com/upspin/upspin) for example. They just use mux.
Yup, it’s maybe a bad example. It would still result in obscure code though.
It would make (i.e.) rotations a nightmare, true
Thank you.
FWIW, it’s only usable for arrays, slices and maps. Why won’t you let us use blank types in structs?
&gt; IMHO generics would solve all of the issues above It would solve few of the issues. Not only that, there is no clear reason why the objects need to be immutable, nor why they must be processed in insertion order. There are great arguments for both conditions, but from what I read there is no compelling reason for either here...
In fact, if they need to be read in order, a slice would be the required structure, not a map. O(1) is kept because you're reading them in the order inserted!
I asked this last time this got posted, if I remember right... &gt; I need a data structure. It has the following requirements: Why? What do you need to do with it? Maybe I shouldn't say this because I just wrote [a blog post with contrived examples](https://deedlefake.com/2017/07/the-problem-with-interfaces/), but when I see contrived examples like this I always just wonder what you're trying to do and if maybe there's a better way to do it that doesn't require those features. I'm not saying there necessarily is, but... ^(Also, please ignore the awkward layout on the blog. I'm in the middle of redoing it and I'm experimenting a bit.)
Data structures are the primary reason I and most people I know want generics. To exclude them in a proposal seems odd to me.
Previous discussions: https://www.reddit.com/r/golang/comments/6gdqg1/why_im_so_frustrated_with_go_hacker_noon/ https://www.reddit.com/r/golang/comments/6evi2o/why_im_so_frustrated_with_go/
It's not rude it's honest. Which parts of my comments isn't true btw?
To be fair, where I work, a "microservice" involves more code than the Windows NT kernel. I mean, we can't have you just writing a function or two. You've got to make sure your Service Entity was isolated from the underlying implementation by a Data Entity obtained from a Data Manager, each of which is of course composed of an interface and an Impl class, because what are we, monsters? Don't forget to separate the transport with a layer of Abstract Transport Objects. I wish this was fictional. I once wrote a little prototype of a service in Clojure because I wanted to have something returning real data to the client I was working on. When they migrated the service to our enterprise java standards, the resulting project had more **files** than the original had **lines**. 
It's not a question of true of false when dealing with opinion -- your point comes across as "we shouldn't dumb things down or we will get poor coders using it" when really Go was designed to be simple to lower the barrier of entry, which (as you point out, attracts poorer quality coders, yes) but it also means that complexity is reduced allowing a third party to more easily understand "why" rather than just "how". My point is that by explicitly baking things like having a simple, easy to understand language specification, it makes things better for all. The generics argument has two, equally valid viewpoints: 1. There is a lot of code repetition and less neatness of expression without generic type implementations. 2. Generics complicate languages because unless well designed it can easily lead to undefined behaviour. The Go specification is right to be cautious, adding something as fundamental as generics is a one-time deal -- once added, you can't alter it substantially without breaking backwards compatibility. For the most part, the lack of generics caused me to embrace interfaces, but I know there are more experienced developers who have genuine desire for a true generic system, not based solely on "I've used these before, I want these". If Go implements a solution for the generics issue, you can be sure it will have been carefully considered and implemented in a way that doesn't overcomplicate the language. As the Go founders themselves said: it's not no to generics, it's just that they haven't seen a compelling case for them in such a way that fits the Go ethos. Who knows, in a few years we may see something generic-like that solves everyone's concerns :)
Ignoring a function's thrown exception is the default case: ``` x = foo() ``` there's no indication that `foo` may be throwing an exception and that you may be ignoring it. OTOH, `x, _ := foo()` makes it clear(er) that you're ignoring an error. Granted, you lose this benefit in the case of functions that only return an error.
Immutability is the enemy of reusability. If want to amortize resource allocation cost over the running time of an service (via a sync.Pool for instance), then those resources can't be immutable.
&gt; ...but it also means that complexity is reduced allowing a third party to more easily understand "why" rather than just "how". If you'll end up giving up typesafety and spamming `err != nil` this third party won't be able to find the *actual* logic between the heaps of useless code. Just think about C - usually the logic is deeply buried in generated code, pre-processors and weird function names. Currently, I'm working on large project which have many C submodules and I'd really love to have some generics but I can't use cpp since the generated code's type definitions causes errors in cpp's namespace rules... Self-repetition is a dumb thing to do and using generated code in production everywhere won't just make your code and compilation much more problematic but it'll also cause issues with code coherence. &gt; Generics complicate languages because unless well designed it can easily lead to undefined behaviour. Where did you get this nonsense? Who has done generics "wrong"? If google's engineers are so bright why they can't do generics right? &gt; The Go specification is right to be cautious, adding something as fundamental as generics is a one-time deal -- once added, you can't alter it substantially without breaking backwards compatibility. Java hasn't added generics at 1.0 and that poor decision had a negative effect on java for years - java coders ended up declaring everything with `Object` and those parts of the code were the worst. &gt; For the most part, the lack of generics caused me to embrace interfaces Interfaces in golang is poor and `interface{}` is java's `Object`. You can't enforce typesafety without generics - you can't define a sorting algorithm which can sort arrays based on its elements' comparison function/method. That's a huge issue if you want a modern language. &gt; but I know there are more experienced developers who have genuine desire for a true generic system, not based solely on "I've used these before, I want these". You don't say? What do you think - why people criticize golang so harshly? Because its designers managed to screw up to very useful thing - typesafety and error management - by not adding generics and some form of exceptions. Oh, they've also fucked up concurrency by adding CSP - one of the least useful concurrent techniques... &gt; If Go implements a solution for the generics issue, you can be sure it will have been carefully considered and implemented in a way that doesn't overcomplicate the language. So, golang's designers - who are afraid to implement generics, don't know what are generics, want to handle errors by `if(err != nil)` and couldn't implement a proper generational garbage collector - will magically create the "perfect" generics? What's golang, a cult? &gt; As the Go founders themselves said: it's not no to generics, it's just that they haven't seen a compelling case for them in such a way that fits the Go ethos. So, it's better to copy-paste code like a chicken... &gt; Who knows, in a few years we may see something generic-like that solves everyone's concerns :) I'm sure by that time most golang codebases will be the biggest cesspools - they already are - and by not adding *proper* error handling, generics and flexible concurrency you won't get out of that, except if you'll zealot not *wanting* to get out because "look ma', I'm using google's programming language, yes - that google, they surely know what's better!" - yeah, they know "better" than every other programmer and *decades* of CS research and industry experience...
Sounds like a true nightmare. Obviously people have different notions of just how "micro" their microservice should be (sometimes I like to call them macro services) Where I work, a perfect example of a microservice is a piece of code we write to deploy to AWS lambda through Apex. It's literally a small go binary that has a couple of files (typically a main.go, a services.go (if it needs to interact with other services we write interfaces around the behavior the other service provides, and use this in our lambda), and then whatever the function does in a file called function.go). main.go typically always looks the same. Anything else tends to be more of a just regular "service" rather than a true micro service. I actually don't like the word microservice at all, but I do think lambdas are a good example of a pure implementation because the CPU and time constraints forces you to keep it lean and small (unless you want a large lambda bill, then of course you can have more time and more CPU -- but for example our website that services millions of users, our lambda bill for last month was $3.86 -- and now this post sounds like its a big shill for lambda sorry)
&gt; how many people ale writing kernels in Go IIRC there was a Go kernel project. Either way, Go's garbage collection makes it unsuitable for "real" (non-toy) kernels. &gt; webservers in C Apache? Nginx? Lighttpd? Many more? There is lots of code being written in C; arguably a lot of that *should* be in a safer language (such as Go); but on the other hand, you *can* write very useful and secure software in C (see OpenBSD and related projects for an example). &gt; Why people don't mind code generation but when option of standardized and automatic code generation is brought up everyone looses their mind. A significant part of Go's attraction is its readability and lack of "magic". You can take a program and just read it top-down from "cover to cover"; no callbacks or inherited stuff or any of that. I'm not sure if anyone is "losing their mind" over generics, but I do think a lot of people are very aware that this is the strength of Go, and are careful with introducing new features that might weaken this.
this is a total lie. I have been part of the community since the start. I have pushed for generics since the beginning. Only recently(think the last 2 years) has the Go team considered the language might need generics - before it was just type it out, then copy and paste, and now code generation. Only now after considerable pressure from the greater go community, and the realization that Go is losing ground, and slowly fading to obscurity does the Go team admit that the lack of polymorphic types is a pain point. keep linking your nonsense, and I will dig up every thread from go-dev, go-nuts, and the personal conversations I've had with ian, russ, andrew, rob, and robert. In the end you will make both, yourself and them, look bad. Russ is asking three year too late. All the people with decent ideas have moved on. Now you are left with those that never wanted generics, those that never had the need for generics, and the so naive that they really have nothing to offer. 
Author should switch to Perl so all his programs can be one liners.
There is nothing wrong with sugar. (you are right)
Doesn't using value semantics over reference semantics solve the issue of immutability? Granted, with value semantics, you're making a copy, and that adds some overhead. But if you're trying to avoid side-effects, then why not just use value semantics and be done with it?
Here's a function: func F(o *Object, x int) And here's a method: func (o *Object) F(x int) Until we start talking about interfaces, these two things are pretty much equivalent. Where methods differ from simple functions is when it comes to interfaces. type Fer interface { F(x int) } Now, if we define a function F as above, the type *Object won't satisfy this interface. But, if we define a method, *Object will satisfy this interface. Another advantage of using methods is namespacing. With function, you always have to prefix them with the package name. With methods, you don't.
Wasn't implying anything inherently wrong with sugar, plenty of languages provide sugar to make things easier on the dev
One of my pet peeves that I saw pop up in those discussions you linked is someone just throwing slippery slope out there and somehow thinking they made a point. It always manifests itself this way *Person who does not want Go to become a feature-bloated, can-do-everything-for-everyone-and-then-some, trying-to-half-ass-every-paradigm language*: "Yes but when will it stop?" *Person who wants generics plus smorgasbord of other features from other languages*: "slippery slope!!!!!1111" How many times does history have to repeat itself with respects to languages and feature bloat for it to not be a slippery slope? It happened to C++, it happened to Java, it happened to C#, and it's happening now to ECMAScript (ugh) In these mainstream languages when have you ever seen the spec get *smaller*? That would be success in my eyes. I would love for the next C++ standard or Java 10/ C# 8.0 to *delete* a couple hundred pages from it's War-And-Peace sized tomes they call a "Language Specification"
He had a chance to explain himself in that article. Instead, he choose to be vague, because he knows the solution he has will fall short. His answers in the past was to type it out or copy/paste. I am sure that has not changed.
I was wondering the same thing, although it might be easy to forget perhaps?
If you have a `func (f *Foo) Bar(x int) error`, then that is `func Bar(f *Foo, x int) error`, but with no name collisions with other `Bar`s in the same package. See also [method expressions](https://golang.org/ref/spec#Method_expressions), where this is made obvious. Additionally, [method values](https://golang.org/ref/spec#Method_values) exist, and are incredibly useful. As for the implementation, there are no pointers to the method inside the struct. Methods are compiled as regular functions, under a name such as `(*Foo).Bar`. Understanding what happens when you call a method through an interface is a little bit more involved, but that is an implementation detail.
Ok webserver wasn't the right word. More like webapps. Applications like Reddit, Github, Wikipedia. Noone writes this in C. Apache, Nginx is another story. You need all the performance you can get and rust wasn't (and still isn't) mainstream so C or C++ is best option. About readability. Look at the new atomic map in 1.9. Can you tell me how less "readable" would it be if it was implemented using generics instead of interface{} ? And you would get copile time checks... Like wow... Sandart datatype in statically typed language that isn't type safe... Why do we bother with Go if Python, JS, and so on can do the same?
You are totally correct. The "sugarless" version of the method that takes the reciever as it's first parameter is called a [method expression](https://golang.org/ref/spec#Method_expressions).
Trust me, your type has been loud for quite some time now. I can think back to a time when I was the only one talking about generics in Go on the go-nuts and go-dev lists, and the amount of vitriol I had to endure. Now there are many of us, and so few of you.
They are not entirely sugar, because interfaces.
Of course. But, in this context, I am referring specifically to zero-cost at runtime.
So, it's similar to name mangling in C++?
Write a type safe map that I can use out of the box.
Yeah sure, no one is saying that using `interface{}` is great. Personally I'm not convinced that adding the atomic map in 1.9 was a good idea exactly because of this reason; the existing solutions worked well enough IMHO. That being said, just because there is a problem doesn't mean that any proposed solution is a *good* solution. It's like the old politician's fallacy: "we must do something, this is something, therefore we must do this" ;-)
&gt; Only recently(think the last 2 years) has the Go team considered the language might need generics [Russ Cox post about generics](https://research.swtch.com/generic), showing that the go team was considering adding them is from 2009. The [commit adding the FAQ item](https://github.com/golang/go/commit/dd64f86e0874804d0ec5b7138dafc28b51f61c12) is from 2009, clearly stating the possibility of them coming, if sufficient need is demonstrated and the problems with implementing them are solved. Ian Lance Taylor [references](http://www.airs.com/blog/archives/559) an E-Mail from 2009, where he says that he thinks generics should be added. He also references a thread from 2010, in which Robert Griesemer considers the possibility of adding generics later. That is now 4 of the 5 main developers of the language *directly* contradicting the claim of a stance of "lol no generics", *long* before the two years you are putting out here. The stance has literally always (some of these sources are earlier than the open sourcing of go, so *definitely* earlier than you being "part of the community since the start") been, that generics might be added later, if the issues with adding them could be figured out. And again: *I don't like that*. I'd prefer they would commit to not add them. The thought of go growing generics is making me queasy. But it's the way it is. &gt; keep linking your nonsense, and I will dig up every thread from go-dev, go-nuts, and the personal conversations I've had with ian, russ, andrew, rob, and robert. Please do. I'd be very interested in those sources. Honestly. Sources don't lie. As I said, it is a very persistent meme. But it is demonstrably false. &gt; All the people with decent ideas have moved on. Now you are left with those that never wanted generics, those that never had the need for generics, and the so naive that they really have nothing to offer. Which of those four are you? Presumably not the one that has moved on, you seem to still be here.
See, you make some good points but the further I read, the more insulting name-calling bigotry exposes itself. People would listen to you more if you explained yourself in a nicer manner. You clearly have some useful input to give but people are put off because you're painting yourself as the sole purveyor of sense in a world of idiots. Be nice, and people might just listen -- patience and clarity are virtues of good communicators.
Go maps and slices have reference semantics.
Well you have a problem in Go. You can't write type safe data structures and algorythms for types you will know at compile time. In 40? years of computer science only one solution poped up. Generics. Creators of Go are brilliant people, but not that brilliant to create new and better solution. Also another antiargument for generics making code more complex and unreadable. Is append unreadable? What about new? copy? delete? and so on. No they are not and they are clearly generic functions.
&gt; In these mainstream languages when have you ever seen the spec get smaller? C#7 and .Net Core. I know, not the language as such but rather the framework that got cut down in size. Want cross-platform with .Net, then forget about this, that and the other thing. I rather like it. And before the down-votes, I wish I could do Go full-time (I sneak it in were I can for peripheral services to our core business) but C# .Net Core is the main platform for the foreseeable future. Could be worse, could be Java marinaded in Spring :D
But that error will eventually be cught somewhere and your program will crash with a clear reason and stack trace. On the other hand, forgetting to check for the error when it is returned as a value can result in your program running for a few more hours and crashing in a totally different place for a totally different reason. Look, I'm a C programmer and I'm used to do status = func(); if (!SUCCESS(status)) { // whatever } but there are better way than this and with a few exceptions, exceptions should be used instead of this. Even in C, when I'm doing something for Windows I use SEH if I can. 
I've no problem with heated discussions or people in general. I've problem with laziness and bad echo-chambers.
That's really the weakest form of immutability. I would consider that a nice to have but not really worth asking for. What would be really nice is to declare a type as immutable. Then the compiler can require those values to be immutable and everything pointed to by those values also be immutable. Then you can pass those around to various go routines comfortable in the knowledge that they are 100% thread safe. 
You can't have that because programmers come in with different backgrounds and expectations. The best we can do is select which features work best with what we want to achieve.
It's mostly a plea for immutable data structures, though. 90% of the boiler plate mentioned is due to the requirement of making the thing immutable on the language level. Without it, it's just a `struct Animals { Idx map[string]int; A []Animal }` plus three lines to fill it in.
&gt; Those discussions are also often comprised of people who don't actually write Go as their primary language, I've gotta call this out. Using go is not some sort of all or nothing membership club. Criticizing the design of golang is not a right reserved for "true gophers". &gt; as is evident from the names on the mailing list (oftentimes contributors to other languages, using their real names). People with deep design and implementation experience in other languages are **exactly** who we should be looking to listen to and learn from.
He wants O(1) lookup by name. Should still use a slice, plus a `map[string]int`, though.
That's true, but IME the effect of ignoring errors being more obvious is that errors are hardly ever ignored (this is somewhat related to team culture and code review practices, so YMMV), which I think results in clearer failure modes than when errors get caught far up the call stack from where they occur. 
&gt; C doesn't have generics and it's doing fine. In c the problem is avoided via either using macros or void*. Golang was absolutely right to establish barriers and norms against this. The flip side is, golang hasn't provided an acceptable mechanism for the same needs. The drawbacks and limitations of interface{} are clear. Code generation is brittle. &gt; for the most part it's people from other communities who are just trying to find any perceived "flaw" they can. This is absolutely not the case. A whole bunch of us want to be able to write type safe containers as reusable libraries. We have a specific, clear, criticism, and it cannot be hand-waved away as "outsiders from other communities just trying to find any flaw they can".
To me, immutability is less about DRY, and more about offering voluntary handcuffs to other developers so that when they hand me their code, I know what they *can't* do, which helps me get a quick grasp on what they *can* do. Immutability is the same as language constants. Constants are useful only because they're a signal of voluntary restraint by another developer; they are communicating to you things that *can't* happen. So in that sense, immutability and constants are there to help humans write better interfaces for other humans. For the longest time, Python people communicated whether something was a constant by cultural convention of capitalization. That too is a communication to other developers, indicating information on what can or can't change, it's just weaker communication because it's secured by culture alone, rather than language mechanism.
Indeed. What's the old adage? Most programming is about choosing the right data structures for the job? Rings true here!
map, filter, reduce, min, max are one thing. The alternative to those is a short loop that everyone knows how to write. What go is missing is the some_list.sort(key=func) from python etc that is faster, simpler, and less error prone than writing compare functions. So sure, it would be nice if I was able to do something like available_backends = ", ".join(b.name for b in backends) instead of having to do var backend_names = []string for _, b := range backends { backend_names = append(backend_names, b.name) } available_backends := strings.Join(backend_names, ", ") But that's fine. The problem is when there is no good alternative to backends.sort(key=lambda b: b.name) # or same thing, backends.sort(key=operator.attrgetter('name')) especially when you want to do something like sort a list of people by age, then name, then height backends.sort(key=lambda b: (b.age, b.name, b.height)) # or same thing, backends.sort(key=operator.attrgetter('name', 'age', 'height')) Which in go turns into a giant mess. This barely even requires generics, it just requires real tuples and go to understand how to compare a tuple of types that it already knows how to compare individually. it's not that crazy to want to be able to do something like Sort(people, func (p Person) (int, string, int) { return p.age, p.name, p.height }) 
Yes, and they are syntactic sugar in every language. At the assembly level, the reference to the object is pushed onto the stack like any other argument.
Right.. You can already do that in go, just not.. generically: package main import ( "fmt" "strings" ) type FilterableStrings []string func (fs FilterableStrings) filter(f func(v string) bool) []string { var ret []string for _, s := range fs { if f(s) { ret = append(ret, s) } } return ret } func main() { a := []string{"Apple", "Banana"} filtered := FilterableStrings(a).filter(func(v string) bool { return strings.HasPrefix(v, "A") }) fmt.Printf("%v\n", filtered) } 
There's also the often useful variant, [method values](https://golang.org/ref/spec#Method_values).
In some cases, the right thing to do in handling an error could be logging it and moving on but that's actually rare. In the example you gave, I'd want to have some logic for retrying. You're trying to persist something in the database and you get an error, maybe due to a network issue. Perhaps you'd want to put in a small delay and try the transaction a few more times, only giving up after X tries. It's not a good idea to just mechanically check for an error and return it to the caller or log it without thinking about it. After each possible error, see if you can deal with it right there and only return it to the caller if there's nothing you can do. You want to do something to deal with it as close to the error location as possible. 
This reminds me of the Javascript community indicating private variables as prefixed with an underscore. 
Awesome thank you very much. So as an example, if you have a sequence of dependent actions that save to a database, if one of the db crud operations fail, then you may need to break out from performing the following actions? Moreover I'm guessing that the perfect program would potentially undo the prior operations and cleanup the affected entities but I'm also guessing that in the real world this is impractical and fairly rare (I.e. Remote database API experiencing issues/ random downtime). Thanks a lot :)
Not sure how I didn't think of that by now
&gt; For instance, try writing a reusable exponential backoff algorithm I'm failing to understand how this is even difficult. Is there a particular design in mind that isn't suited for the language in question?
This seems like it started as a generics implementation with unusual syntax and then had seemingly arbitrary constraints added. I have a feeling you would have discovered this in the usecases section, that's why it's part of proposals you need to see it in practice for issues to emerge. Some issues with your proposal: * Syntax doesn't align with Go specification. One reason Go is so easy to read is because keywords always precede identifiers with a single space. All use of identifiers qualify themselves distinctly in their statement. This creates a hidden readability you don't think about until something breaks this convention. I.e: type Foo string func Bar package baz var bax int const mark foo foo $T // one of these things is not like the others // one of these things is not the same * Constraint that I may not use a named type here adds a new level of indirection. This means that in order to resolve what a T may possibly be I have only one option, check each and every call site. * The above leads to the most obvious flaw, it's impossible to do nearly anything with the inbound values except return.. one of them. You offer no way to describe the incoming values. How useless this is was immediately shown to you when the most useful thing you achieved was assigning a map key and value.. which you had to have the user pass to you. You had to do this because you had no way to inbox the given $A or $B in your proposal. I.e: func Add1(key $A, val $B, m map[$A]$B) { m[$A] = $B } // the most usefull use case thus far is a new // syntax for: m[k] = v * The above flaw with not being able to describe the behavior of a $T makes this completely unusable. All of your examples for working with $A and $B show this. You are performing only operations that either bind a identifier or are a special builtin that allow any T. Basic generics use cases are impossible if you don't specify how to unbox types. In Go this is pretty easy we have type switches, but the edge cases around them need defined for generics. At the end of the day of generics isn't just about getting a T and returning a T. That is the simple part. Everything up in the air is defining how to perform operations on and around these T. Unbox of the T and what does the compiler qualify as a valid T for a given signature. It's why a form of "where" exists in all generics implementations I can think of, Go needs this too just have to define everything around it. It's where the slippery slope is because once you get into the weeds you end up with the basic types needing to implement interfaces so useful operations can be performed on them, in Go this may look like: type Adder interface { Add(rhs T) T } func (lhs int) Add(rhs int) { return lhs + rhs } // we need above to write something useful like: type MyInt int Sum(adder ...Adder) Adder I specifically avoided the familiar T notation to show that the real work in my eyes is getting the builtins to better integrate with interfaces and user types. It's hard for me to imagine generics that end up useful without a tighter integration with builtin types and interfaces. Not saying it's not possible.. but it's just what I've always thought would feel natural. I ramble more about this [here](https://www.reddit.com/r/golang/comments/69smja/what_would_you_most_like_to_see_in_go_20/dh971lj/).. and a few other posts I don't want to dig up. Otherwise I feel like userspace will end up with a ton of slightly different name, different signature similar or identical behavior interfaces to describe the where clause of a given generic T. A baseline set of interfaces is for useful operations is needed and with them all basic and built in types should implement them or the language will just be freaking awful to work with. You think sort interface is a pain? With generics if the built in types don't define any methods to implement a core set of common interfaces we will be in much worst shape in my opinion. I want int string etc to step their game up even without generics.. since it would allow tons of things that generic use cases are needed for.
Would appreciate a counter argument, if going to downvote. 
Well, Go actually did just add a nice sort utility? https://golang.org/doc/go1.8#sort_slice I really don't think Go needs its sorting logic redone.
They did?
C++ name mangling is a kludge for compatibility with C. Nothing like that exists here. https://en.wikipedia.org/wiki/Name_mangling#C.2B.2B
The whole example seems like the author is fixated on emulating the nice-to-have feature of immutability for no reason other than that he wants to have immutable objects.
Sorry, see the edit
It's obvious the entire article tries to justify not adding generics. The main pro-generics argument applies equally to weakly typed languages. Why else do you think I replaced "Go" with "Javascript" in my quote? &gt; It's not that hard, bro. You just substitute symbols. Then why don't you do that, and maintain the code base indefinitely. People will love you for it. You don't have time? Then why don't you pay others to do it for you? &gt; Your commander just doesn't want to admit that his decision was retarded. Who is my commander? What decision are you talking about?
Multiple updates to the database would likely greatly benefit from being run in a transaction. That way you don't have inconsistent state if the last method call returns an error.
A full example of that pattern where you can have several T's share a common implementation is [here](https://www.reddit.com/r/golang/comments/6evi2o/why_im_so_frustrated_with_go/didhp2z/). I use it often for things like google/btree, I'll define a mypkg.Cursor struct that wraps the Btree and unboxes the interfaces to my strong T and use functions for iteration. Like: package mypkg type Func func(value *MyStruct) (stop bool) func (f Func) Wrap(fn Func) Func { return func(v *MyStruct) bool { return f(v) &amp;&amp; fn(v) } } // now you can wrap visit funcs together to // filter and mutate values. func ByName(name string) Func { return func(..) } func IndexTo(m map[string]*MyStruct) Func { ... } type Cursor struct { tr *btree.Tree } func (c *Cursor) Visit(fn Func) { return c.tr.Visit(func(v interface{}) bool { return fn(v.(*MyStruct)) }} // above we can check T to allow multiple types // live in it, though ordering can get tricky or use // different trees and maintain invariants around // insertions through visibility of Cursor. c := Cursor{mytree.New()} // now we can build a quick index of users named // Chris m := make(map[string]*MyStruct) c.Visit(ByName("Chris").Wrap(IndexTo(m))) for k := range m { ... edit struct ... } Gotta be careful not to get carried away with chaining functions and what not and the above would be better written simply with a single Visit func that checked name and did a edit in a function literal. Just wanted to show how you can make more complex things composable nicely with a minimal amount of sort.Interface style wrapping with this pattern.
This is a little HTTPS server that you give your TLS certs to, and then you can run an external TLS quality checker against it. https://github.com/chris-short/ssl-tester/blob/master/server.go
If you run multiple db actions in a transaction and one fails, then they'll all be undone..? I didn't think that's how it worked. Also I don't think all db apis have a transaction component like datastore does
I'm concerned that doing so for all errors could result in too much premature optimization and time spent. 
&gt; When you come from other languages and you've taught to think that you can't program without using a framework. Or alternatively when you need to spend time focusing on your business logic instead of writing something that's been written a million times before.
I just don't understand why are people not talking about this. What's wrong with it as an idea? It's useful, it would solve problems, it sound easy (to my layman's eyes -- at least a big chunk of it is already done).
What Go needs is just a "variant" type. Empty interfaces should be considered harmful. Variants can allow explicit types to be specified to use for the input or output of a function instead of an empty interface and be checked at compile time. It could work like this: type Number variant { int float64 float32 } Replacing an empty interface with Number could allow a math library to work different types instead of having to cast everything to a single type (i.e. float64) or use empty interfaces everywhere. Variants would be more like a special type of interface that instead of requiring functions to be implemented, it requires specific types to be used.
&gt; Using go is not some sort of all or nothing membership club. Criticizing the design of golang is not a right reserved for "true gophers". Never said it was. But when we're talking about people who by their own admission do not write Go themselves, it's hard for me (and others who've been writing Go for a while and are happy without generics) to justify wasting our time trying to argue with those who don't actually write the language. 
On the surface, yes, but there's one place I know of where it's not simply sugar. Functions that receive functions/methods can invoke a pure function, but when they invoke the method, it's invoked **on the struct of the method** which makes enormous sense, but shows that they're not pure sugar, as a method is passed not as a function, but as a method. Here's a simple playground demonstration. https://play.golang.org/p/3ut-OCaOLP EDIT: Thanks /u/lstokeworth, /u/aclin0 and /u/DeedleFake for pointing out that these are known as method expressions and method values -- I haven't quite worked out the difference between the two.
Aha, that's what these are called. Just posted response to OP demonstrating this. Thanks!
Can just post a link to the repo here (I would probably edit and include it in your original post) and I'm sure someone will comment. If I get a chance later and someone hasn't answered, I can take a look and give feedback.
And method expressions and method values
I bet that underscore prefix for private stuff comes from python.
Aha, that's what these are called. Just posted response to OP demonstrating this. Thanks!
Post up a github repo or a gist and we will gladly take a look. 
Good luck focusing on that business logic when you have to learn to use the framework or something stops working and you have to investigate the framework's internals or when you want to do something that the framework does not support.
A very large part of what makes Go preferable over other languages like C++, Java And C# is that it has extremely short compile times, especially for very large code bases. A large part of that benefit comes in programmer productivity and fast iteration times on par with dynamic languages like Python. When it comes to programming language design, out of the following 3 features you can only choose 2: * Fast compile times * Fast runtime * Generics Golang chose the first 2 at the expense of the third. 
Out of curiosity, between the Gopkg files and the vendor directory, how close are we to getting rid of the GOPATH? Ie, if we use `dep`, then it would seem we have all the packages a project needs inside the vendor directory. Once we get to that stage... what good is GOPATH? Obviously GOPATH is a bit of a debated subject, but regardless of your feelings about GOPATH this is starting to sound like it's not even needed anymore. Will there continue to be a meaningful reason to keep GOPATH around?
I'm not using Go because of concurrency but because of simplicity and maintainability. It is funny to claim Go's advantage over other languages is some feature it has, it is not, it is lack of things. Minimalism, balance and lack of kitchen sink is what separates Go. C++ has every feature ever conceived added in last 20+ years yet I don't see people abandoning other languages, on the contrary, people are running away because of complexity.
There is the Go Discord server if you'd prefer a chat. https://discord.gg/R5Qu5U
If your code is open source you can use paste your github repo to https://goreportcard.com/ and it will let you know some stuff you can improve if any.
Thanks. How comprehensive is this? [I got an "A+"](https://goreportcard.com/report/github.com/tusing/SimpleScraper) but I'm not sure how much that really means.
Thanks! I've put the repo in the OP.
Thanks! I've put the repo in OP.
You are making the links point to files on disk. That is not allowed for security purposes. What you want to do is create a simple handler that serves an mp3 file based on an identifier. Let's say that's `/mp3/{id}`. Then on the handler you posted above all you have to do is make each link point to `"/mp3/" + id`. As a result when you click on a link you will make a request on the mp3 serving handler.
It's just for the basic stuff. If you want really comprehensive then use [gometalinter](https://github.com/alecthomas/gometalinter).
That's literally the entire point of and definition of a [database transaction](https://en.wikipedia.org/wiki/Database_transaction). You can wrap multiple queries in a single transaction to provide atomicity, which is the formal term for "if something goes wrong, nothing is permanently changed". I would strongly recommend looking into the transaction functionality for you DB and Golang tools of choice.
**Database transaction** A transaction symbolizes a unit of work performed within a database management system (or similar system) against a database, and treated in a coherent and reliable way independent of other transactions. A transaction generally represents any change in a database. Transactions in a database environment have two main purposes: To provide reliable units of work that allow correct recovery from failures and keep a database consistent even in cases of system failure, when execution stops (completely or partially) and many operations upon a database remain uncompleted, with unclear status. To provide isolation between programs accessing a database concurrently. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Error checking could be greatly improved, I noticed a lot of cases where errors are logged, but execution continues as if the error didn't matter. https://github.com/tusing/SimpleScraper/blob/master/main.go#L16 the error isn't checked (and not sure why it insists the hostname start with www) https://github.com/tusing/SimpleScraper/blob/master/main.go#L17-L20 can be replaced with: return validURL.Match([]byte(url) https://github.com/tusing/SimpleScraper/blob/master/construct.go#L10 since it can encounter an error, it should return (tomlConfig,error) https://github.com/tusing/SimpleScraper/blob/master/construct.go#L68 the error isn't handled, should it continue or break? https://github.com/tusing/SimpleScraper/blob/master/construct.go#L158 if you switch the ok, !ok checks it can be simplified since ok does a return and then no ! ok check is needed 
The original post is a pretty good intro to smart contracts with solidity. 👍🏼
Don't get me wrong, I find the general Go philosophy of using the Stalin over third party packages to be quite refreshing, and certainly encourages people to learn the language as opposed to a framework, which you definitely get in other languages. However, this does sometimes extend to a bit of an elitist attitude, that if you're not writing it yourself from scratch, you're not doing it "properly".
Does the converse exist? A go utility (client) which given a URL returns a score of the TLS implementation that server is running?
My problem with C++ is that all of the features interact poorly. C# is a kitchen sync language but is fairly maintainable. Other new languages with better integrated, more powerful features will certainly eat go's lunch. Rust, swift, crystal, and pony look like strong competitors from this end. The real threat to go in my opinion is C#. C# with AOT compilation, increasingly better Linux support and a gigantic existing user base with some of the best tooling in the business is pretty hard to beat. Most go engineers are coming from dynamically typed languages who wanted the maintainability of go's static types and the concurrency it offers. Typescript with async/await cuts squarely at the heart of this reasoning. More modern languages with type inference and less focus on inheritance based design seem to be gaining traction amongst these users as well. 
Well, again, there are tons of us that have been doing golang for years now that **do** want generics. And again, there's people very much worth listening to even if they don't write go 24/7/365. In particular recently we've seen comments from the Dart team about their experience changing their type system. We've also seen comments from folks in the academic and research community about how golang's limitations have prevented them from contributing golang versions of very relevant libraries. These people would all fail your test, but it's very clear that talking with them is anything but arguing and wasting time.
&gt; But if you're trying to avoid side-effects, then why not just use value semantics and be done with it? Just like you said, to avoid the overhead. Immutability is a blessing in non-trivial concurrent scenarios. Not having performant immutability available in a language with such a great M:N threading solution is a damn shame.
&gt;It's obvious the entire article tries to justify not adding generics. Mhmm. And? &gt; The main pro-generics argument applies equally to weakly typed languages. I'm sorry, but I fail to see the relevance to this discussion here. I'm honestly not even sure what argument you're referring to, exactly. &gt;&gt; It's not that hard, bro. You just substitute symbols. &gt; &gt;Then why don't you do that, and maintain the code base indefinitely. That's not a very good rebuttle, I'm afraid. It would make sense if I made the claim that you should implement generics in the Go codebase because it's not that difficult. The people who are involved in its design have the opinion that Generics aren't particularly useful. One has specifically mentioned that they've had trouble figuring out exactly what kind of problems generics help clearly solve. Therefore, their reasons for not implementing generics have very little to do with the work involved, be it difficult or otherwise. Even if it *were* incredibly difficult to integrate, that hasn't stopped every other widely-used statically typed language designer from incorporating it into their runtime. Considering that the people who work on Go have an excess amount of experience with systems programming in *general*, it's fallicious to think that this would be incredibly difficult for them. Ultimately every pull request to the repo has to be accepted before it actually makes any significant difference. If someone takes the time to support generics and they choose not to accept the additional code needed for that support, then the work and time needed has essentially been wasted. You can argue that a proof of concept will now exist, but a PoC isn't really that useful given that Generics aren't particularly new as a concept. Anyway, I have better things to do with my time than care about a programming language I don't use at all. Your assumption that I care at all is false, which kind of makes that particular point moot. &gt; People will love you for it. You don't have time? Then why don't you pay others to do it for you? Again, you're making the false assumption that I genuinely care enough to do this. Even if I did care at all, why would I pay money for people to implement a feature for a project I have no stake in whatsoever? Furthermore, how exactly does any of what you're saying at all contradict what I said about generics really not being as difficult as you claim? &gt;&gt; Your commander just doesn't want to admit that his decision was retarded. &gt; &gt;Who is my commander? What decision are you talking about? Your commander is Rob Pike. His decision to not implement generics from the start was retarded. 
Thanks, will take a closer look. What other types are we talking about? Interfaces? If so, didn't occur to me to differentiate.
What do you even mean by reusability in this case? If you mean code reuse, there's a one-word rebuttal: Haskell. A shorter, even better response: Idris. If you mean memory reuse, look up persistent data structures.
Thanks! Many errors are ignored on purpose, as I would like the script to continue chugging along even if it can't parse one small of a website (thus making it a bit more robust to website changes). Do you think I should relabel such incidents as `WARNING` rather than `ERROR`? 
No matter, could you add TCO instead?
&gt; given that he's been writing Go since before 1.0. I worked with him for 3.5 years at Canonical on a 500k LOC codebase. 500k LOC codebase of error checks? So what? Cheney has embrassed himself many times already and this is just another example of his closed-mindedness.
Reuse allocated resources. Small example is crypto/hmac doesn't have a SetKey method, so can't reuse the hmac (and the resources it needs). So that impacts HKDF which then needs double the resources needed. Or another example is bytes.Buffer, common in stdlib to use them in a sync.Pool. Buffer as a Reset() method to mutate it back the beginning state. 
Oh, sure. For some allocation-sensitive parts you'll have to deal with mutability. The point is to *avoid* mutability to make data flow simpler. Your message came across (to me, at least) as opposing immutability anywhere rather than opposing the shoehorning of immutability where it's strictly worse than mutability. This is why it's good to have the right abstraction capabilities to get the benefits of immutability while encapsulating side effects (like mutation) away. You get to have your cake and eat it too.
Here is an example: https://github.com/tusing/SimpleScraper/blob/master/construct.go#L65-L69 if err was ! nil then regex would be nil and https://github.com/tusing/SimpleScraper/blob/master/construct.go#L69 wouldn't work, in which case adding a continue after https://github.com/tusing/SimpleScraper/blob/master/construct.go#L66 would be the appropriate way to handle the error
Because then you couldn't go with a pure lexical solution. Then the blank types must be parameters that can be passed to functions and must be templates compiled to each requested use (= concrete type). This restriction means that no concept of generics is needed, because the compiler just needs to look at one function (apart from the addition with anonymous functions which is nontheless restricted).
I want to make sure you see this because Go has more or less exactly the function signature you're looking for in your `Sort` function in that link!
Again, as a developer who does a lot of C programming, a lot of my time is spent writing boilerplate code (check the input, check for errors, etc) and figuring out how to write nice, self explanatory code that deals with errors (usually it's cleanup + propagate the error up the call stack, which can get ugly). Why would you want all that in a modern language? Having exceptions doesn't mean that you're forced to use them. It's just another tool in the box for when you actually need the tool. It may seem easy and elegant to do these checks in go, but try doing this in a large project (~1000000 lines of code, 3+ years of active development + maintainance, 7-15 people team) and see how fast you want to escape it. It actually feels easy to me to do the checks in C (I never forgot to do it, I even have a VS macro that does it for me), but I really don't like it. Written from my phone, sorry for any typos / logic errors. 
It does not. It requires a `less` function. I don't want to give it a less function, I want to give it a key function. The `less` approach is inferior. It is more complicated to write and slower at runtime.
I completely agree go routines really can't be beat on user friendliness. However the question is "are these other concurrency features good enough?" especially when you have other powerful tools like genetics at your disposal in other languages. My team used to use node now we use go. However typescript offers use nearly the same benefits but we would have been able to keep our existing code bases. Async/await certainly makes go a min harder sell, particularly in the presence of glaringly missing features like generics. 
As sabas123 says, very few language features are "necessary," strictly speaking. I'm thinking in existential terms: will the language continue to thrive and attract new users given the absence of generics? Or will it plateau or fade out? I'm not advocating one way or the other, but lack of generics seems to be a sticking point for many would-be Go programmers.
Thanks for recognizing that this proposal avoids the hard parts of the implementation of generics. Sadly you fail to see what it makes possible. Try harder! ;-)
I think the whole `string` vs. `[]byte` problem (e.g. the existence of both a "bytes" and a "strings" package) already illustrates that this is a problem with immutability *in general*. There are already a lot of projects out there fighting with the extra allocation implied in converting an immutable value into a mutable one and vice-versa. And that's just for one type.
It makes way more sense than getting a function that returns an arbitrary number of elements, how would that be faster? How would it deal with accepting a function that returned something that wasn't sortable? These things aren't built into the language because you need to define how your structures are sorted yourself, I don't even know how your structs would be sorted by you returning three sortable items. The less function makes way more sense.
Yes, like using an interface that only exposes non-mutating methods. 
Go, without generics, is experiencing a meteoric rise in popularity. Do you really think generics are necessary, existentially?
It sounds like you think this feature isn't needed because you've never used a programming language that has it. &gt; It makes way more sense than getting a function that returns an arbitrary number of elements It does not. How does a key function that returns p.age, p.name, p.height Make less sense? It sorts by age, then name, then height. Please write the equivalent `less` function and then tell me that it makes more sense. &gt; how would that be faster? because the key function only needs to called once per item. If the sort function returned say, p.age, strings.ToLower(p.name), p.height to compare names ignoring case, they key function will call ToLower N times. Using a `less` function it will call ToLower... `2*NLog(N)` times? See https://play.golang.org/p/Fizg3S45Nl With 5 items: ToLower called: 14 times With 9 items: ToLower called: 26 times &gt; How would it deal with accepting a function that returned something that wasn't sortable? It wouldn't. How does sort.Slice deal with a function that panics? &gt; These things aren't built into the language because you need to define how your structures are sorted yourself Most of the data types in go already have a defined sort order. ` p.age, p.name, p.height` is an int,string,int. Go already knows how to sort those. Also, if only there was a generic way of defining how structures should be sorted compared to each other... &gt; I don't even know how your structs would be sorted by you returning three sortable items .. In order? have you never used SQL? A spreadsheet? You're telling me you have no idea how something like select * from people order by age,name,height would be sorted? &gt; The less function makes way more sense No, it does not. It's fine if you want to say that go does not need generics and adding them would overcomplicate things too much that you can accomplish the same thing without it (because you can, with more code). But don't stick your head in the sand and pretend that alternatives wouldn't be easier to use. That's some stockholm syndrome level shit. 
If you sorted by age, then name, then height, you'd get the opposite behavior from what you want. You need to think though this more. More things that break your syntax: returning the same thing multiple times. Returning things that are not an element of the person struct. You are trying to add magic where there is already a perfectly good fast solution in the standard library for you. The Slice function is explicit. Your function is magic. If you want optimal performance, you'd probably end up writing your own sorting function in whatever language you were using anyway. Also, your implementation can be easily optimized so the less function is identical to your magic in terms of your arbitrarily chosen metric. https://play.golang.org/p/mMrMnkBHFX
probably your aggressive use of the word FALSE
&gt; and poor java newbies are forced to learn that you absolutely can't compare objects with `==`
That's not a problem with immutability, but a problem with Go's lack of non-special-cased immutability. For example, in Rust everything is immutable by default. When you want something to be mutable from the start, just add the mut keyword. No need to convert back and forth.
Yeah, but currently in Go if you want to actually use the data from the struct you're forced to copy everything around, and that's not exactly efficient.
Well there is always maintenance cost, also with generics. I prefer to have the maintenance cost inside a (standard) library to having them inside the compiler, because the compiler should be heavily optimized in various directions (compilation speed, execution speed, error messages and needed informations) and is by nature a much more complex beast from the beginning than a library that is focused. So the trade off made here is: less complex compiler and more complex usage. But libraries using generics are supposed to be reused often anyway, so why not invest there and then reuse often? An important aspect of the proposal is that the packages could compile the blank types "away" (apart from keeping the type signature of the blank functions). So when they get used the implementation of the blank functions can be ignored from the stand point of the called (just the signature is needed)¹. Which keeps fast incremental compilation times. Generics on the other hand would require type copying/code generation (including methods etc) for each new use case (= concrete type). __________________ ¹This is obviously not true with the addendum of the anonymous functions. I have some ideas that will help with that too. Will need to elaborate more.
It doesn't seem that way. There's no language at the moment that does what Go does best, *and* provides generics.
&gt; If you sorted by age, then name, then height, you'd get the opposite behavior from what you want. Nope. &gt; You need to think though this more. Been using this method in python for 13 years. But please, tell me more about how I don't understand how this language feature works. A language feature that exists in multiple programming languages. &gt; More things that break your syntax: returning the same thing multiple times. It does not. What are you talking about? &gt; Returning things that are not an element of the person struct. WAT? THAT WOULDN'T EVEN COMPILE. WHAT ARE YOU TALKING ABOUT &gt; Your function is magic TIL that a natural sort of tuples is "magic" &gt;&gt;&gt; ("John", 22) &lt; ("Bob", 44) False such magic. &gt; If you want optimal performance, you'd probably end up writing your own sorting function in whatever language you were using anyway. Well that settles it. Go doesn't need generics because everyone should just write their own sort function. 
Wait, this wouldn't compile? func(Person) int {return 5} Have you used go before? If you sort by age, then name, then height, you'll get height prioritized lists, then name prioritized lists, then age prioritized. You probably want the other way around. &gt; Well that settles it. Go doesn't need generics because everyone should just write their own sort function. I did say ANY language, not just Go, thanks. This includes python, you'll need to call out to C code to have a performant sort. Also, yes, python uses a lot of magic, but tuple comparison isn't. If you wanted tuples in Go you could have said "I want tuples in Go" not "I want this broken function syntax for sorting" 
Ever heard about map(), contains(), etc?
The sort key function does not need to return items that are elements of the struct. Why would you think that it does? SortByKey(people, func (p Person) (int) { return len(p.name)}) Would sort the people by the lengths of their names. Your example is equivalent to sort.Slice(people, func(i, j int) bool { return false})
Why did you think it wouldn't compile? Have you used Go before? Also please address how you don't actually know what sorting by a field in a struct does. Finally, for what it's worth, you totally *could* write the function you want in Go *right now without generics*, as long as you change your return type.
Yeah, for anything that's not a scalar type. For non scalar, can not expose the state via getters, and just tell the struct what you want done. Eg: type Keys [keyMaterialLength]byte func (k *Keys) Decrypt(e Encrypter, ciphertext []byte) ([]byte, error) { return e.Decrypt(k.aesKey(), k.iv(), ciphertext) } Limiting the opportunities for state change, and ensuring e.Decrypt implementations doesn't modify it's inputs.
How do you say: this thing is false without using false? If I use "incorrect" instead would that make any difference? The statement is still false and I still have no control on how you choose to read the sentence. And for the record, I used "False", not "FALSE".
&gt; Why did you think it wouldn't compile? Because by &gt; Returning things that are not an element of the person struct. I interpreted that to mean SortByKey(people, func (p Person) (int) { return p.banana}) Because I couldn't even imagine that you would think returning 5 is a problem. &gt; Have you used Go before? Only for ~5 years or so. &gt; Also, yes, python uses a lot of magic, but tuple comparison isn't. If you wanted tuples in Go you could have said "I want tuples in Go" IN MY FIRST COMMENT I FUCKING SAID EXACTLY THAT: "This barely even requires generics, it just requires real tuples and go to understand how to compare a tuple of types that it already knows how to compare individually." &gt; not "I want this broken function syntax for sorting" Yep. Gotcha. Python is broken. Every other language that also supports sorting by a key function is broken. Everything that you don't understand is broken. Don't bother replying anymore. I am ignoring you now. Consider removing your head from your ass.
Dunno. When I see the world false, I read it in Dwight's voice and it bothers me. Reading "incorrect" seems pretty low-impact. Seems like I'm not alone also, only angry nerds actually use the word false in conversation, so there's that. edit: you can also totally correct someone without prefacing the correction with the words false or incorrect. they're implied by the correction, no? wtf am I even having this conversation just stop being an angry nerd
I was under the impression atomic meant that the resources defined in the transaction were "locked" from other db operations (minus reads). Is this true too or was I totally off?
Did you follow the instructions?
I'm glad you still haven't addressed that you don't actually know how sorting works, and you still haven't addressed that your arbitrary metric was meaningless.
You are probably right that it doesn't necessarily make the compiler significantly more complex, but from what I've heard it would require an entire rewrite of the compiler, and would require a lot of changes to the tooling and even standard library. Cheney worries in his article that the transition to a Go with generics risks fracturing the community. You also seem to be under the impression that I'm oblivious to the "cargo cult-tier justification" in the article. Perhaps if you actually read the article, you might have realized that the main pro-generics argument could also apply to weakly typed languages, and you might have noticed my sarcasm when I misquoted the original article. My point is that those who actually work on Go might not feel that generics are sufficiently beneficial for them to actually implement and maintain them. And that would be a valid justification for them not to implement them. Claiming otherwise just reeks of entitlement because you're free to implement it yourself.
&gt; wtf am I even having this conversation just stop being an angry nerd I'm very relaxed, it seems you are the one thinking I'm not (for whatever reason). Maybe try not to assume this much about plain text next time? It really is a terrible medium to convey emotions :)
Ah, I see. Need to get my mind right that methods can exist for non-structs as demonstrated. Thanks!
Totally. But it does invariably make someone sound like an angry nerd regardless. Just saying.
Note that on many platforms, the calling convention passes arguments in registers as this is faster than writing things to the stack. Go doesn't though.
I'm not sure if you meant to reply (all of that) to my comment? &gt; I really hate Dave's viewpoint on a lot of this kind of stuff. I feel like he comes off arrogant without proper backing. That's also what I took away from the article. The whole "mainstream programmers" talk felt very condescending for some reason, perhaps because I consider myself one. Maybe I'm imagining things, and I didn't want to actually say it, but it's definitely the reason for my snarky misquote.
He retired.
Of course I did, maybe I did something wrong but I don't think so
The two are not mutually exclusive, but atomicity is distinct from resource locking. Some databases implement row-level locking, some only provide table level locking. All databases worth using, however, are [ACID](https://en.wikipedia.org/wiki/ACID) compliant which includes locking, atomicity, and a variety of other less pithy guarantees about how durable data is. So you're right, mostly: transactions are *Isolated* as well as *Atomic*, two distinct properties that are (ideally) never far apart from each other.
**ACID** In computer science, ACID (Atomicity, Consistency, Isolation, Durability) is a set of properties of database transactions intended to guarantee validity even in the event of errors, power failures, etc. In the context of databases, a sequence of database operations that satisfies the ACID properties and, thus, can be perceived as single logical operation on the data, is called a transaction. For example, a transfer of funds from one bank account to another, even involving multiple changes such as debiting one account and crediting another, is a single transaction. In 1983, Andreas Reuter and Theo Härder coined the acronym ACID as shorthand for Atomicity, Consistency, Isolation, and Durability, building on earlier work by Jim Gray who enumerated Atomicity, Consistency, and Durability but left out Isolation when characterizing the transaction concept. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Yeah. His code would work just as fine if he would just document that the structure must not be mutated. But no, that doesn't cut it for Mr. Fancypants.
I really like this pattern! Thanks for sharing.
This is a nice post. I look forward to further comparisons. Memory / speed benchmarks are nice, but personally I'm more interested in the difference in theory and practice of the two subsystems. The points at the end were well made, thanks! 
That's fantastic! I've been really frustrated at the lack of proper unit testing provisions for Solidity contracts. Everything seems to just run through web3 on testnet. This is exactly what I've been looking for. I almost want to make a standalone unit test runner (maybe with a TOML state configuration) based on this post. Any idea if this exists somewhere I haven't found?
I have used a similar pattern several times but have the bad habit of calling the function "Each". I like Range better. 
thanks a lot.
Not sure why it would have consumed 9GB of RAM, but the min stack size since 1.4 has been 2kB, not 8. Otherwise a very interesting read. https://golang.org/doc/go1.4#runtime
Yes, but these have never slowed me down in practice because they are often trivial to implement. As a result, I have never found myself thinking, "I wish I had generics so I didn't have to write this map function..." That doesn't mean that a generic version of each couldn't be found useful by some developers, but it isn't reason enough to add generics or blank types to the language imo. On the other hand, data structures can have a lot more complexity involved. Heaps, linked hash maps, red black trees, etc are all useful in practice and having standard implementations of each with generics would be incredibly powerful and likely worth the complexity generics add. 
Also, a type can be a namespace type NameSpace struct{} // where struct{} is nothing func (NameSpace) Hello() string { return "hello" } func (NameSpace) Cya() string { return "cya" } type EvilSpace struct{} func (EvilSpace) Hello() string { return "hell" } func (EvilSpace) Cya() string { return "cya in the hell" } 
P Y R A M I D S C H E M E
Considering it's your proposal the burden to make people see the value it would add to the language is on you. You gave zero use cases or examples of "what it makes possible" and I saw nothing on my own, so I simply stated what I think it's missing. If you provide some better use cases my opinion may change.
Just in case anyone cares: The following code after building on the help of janderssen's snippet, works well. https://pastebin.com/6ETF8X4k
You should try errcheck: https://github.com/kisielk/errcheck Probably you are missing error handling somewhere. I would also recommend you watch https://www.youtube.com/watch?v=uBjoTxosSys for some interesting tools that could help you out.
Interesting article, well done. Being thorn between continuing my journey as a hobbyist dev with C#, or having a second look at Go, I welcome those readings. 
It's just an advice based on "the school of Go". Nobody says that if you are using a framework that you are doing it wrong. Every project has different needs and thus needs different solutions and tools. But it is important to keep the philosophy. If we abandon it and the first thing we say to new people is "Use X framework", that will only roll down and create an avalanche. An avalanche of people who only know X framework and cannot communicate with people that know Y framework, an avalanche of articles that show even the simplest code with the help of a framework etc. If you cannot realize how bad this can get, just Go and search on the internet for any JavaScript question. Chances are, the most prominent answer on Stack Overflow will be a solution including JQuery. You actually have to explicitly search for terms like "vanilla javascript" because just "javascript" has ended up being equivalent with "jquery included of course". And let's not even talk about the Java ecosystem.
This talk is so good that I don't mind watching it again.
thanks for the advice! I was actually trying to figure out how to do priority queue. I notice older clients get drop ; whenever new clients start moving around. I still have to test some more
This talk is gold
The golangbridge forum has a new ["Code Review" subcategory](https://forum.golangbridge.org/c/getting-help/code-review) for exactly this purpose.
Maybe I'll provide some better use cases, maybe not. Frankly I owe you nothing and I released the proposal to the open, so it is not "mine" any longer - it lives its life on its own. But I gave up arguing with the Go community long ago. If you can't see a value in it - it is not my problem. I won't convince you. If the community - or the Go team - doesn't like it - it won't happen. I answer questions, where I feel a real interest. That's why I answered you. But I won't participate in destructive opinionated discussions that pretend to be objective while they are clearly biased towards what they know or learned. So while I have nothing against examples, I think it is pretty easy for any reader to come up with some of their own and humiliating to put further time and effort into creating them, if I feel, people don't care anyway and would keep arguing against it, because they don't like it (then the argument would be unrealistic example, complex code, whatever they make up - experienced all sort of pseudo arguments). So if you or anybody is not willing to put this minimal effort into it to come up with examples on their own - well I don't care. Then they are probably not worth it. This proposal did grow in the last 4 years and has lots of insight from my experience with Go. But people don't read it as carefully as proposals of the Go team for example. That is fine, but I am not paid for working at Go and also have other interest. Just wanted to release the idea so that others may pick it up. Just crying "I want full support for generics or nothing" is childish and has been the general reaction. To understand something takes effort from the sender but also from the receiver - especially when it is unusual and complex. I can't see anybody spending any significant effort in trying to understand the proposal before criticizing it. So why should I keep spending time?
Fair enough. But go is not rust and I don't want it to become rust (we already have a rust). This whole immutability-by-default and borrowing and lifetime-annotation business is exactly why I find rust so exhausting to program in; my mental model is, that data is mutable. I understand the advantages of being able to occasionally annotate immutable data, but if you tell me that to make that work we need to have ~all data immutable, I'm definitely out the door.
&gt; I've recently wanted to dive into some Go programming. Just a small reminder that [Cgo is not Go](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=12m37s). Pretty much everyone, has problems with C code. That's why we are trying our best to stay with pure Go code but of course sometimes that's not possible. My advice would be to install a Linux distribution like Ubuntu through virtual box or something and try to get your work done there. To my experience C packages and dependencies are much easier to work on Linux. And if you can afford it, stay away from Cgo.
I absolutely agree that you owe me nothing; while I and the Go community members your proposal was published for owe you nothing as well. Yet I took the time to give you technical reasons why I think your proposal is lacking, with examples needed to strengthen it along with a prior post to add more context. Instead of trying to strengthen your claims you made a snarky reply telling me to try harder to see it's value, while I explained the reasons I didn't already. I accepted you were probably tired of discussing it and left you an opportunit to provide more examples later, letting you know I would be happy to re-evaluate my position. Instead of taking the opportunity to strengthen your proposal the second time around.. you write 5~ paragraphs venting about people's reactions. Rather than listen to criticism you completely ignored it and resorted to common psychological dissonance as a defense mechanism to cope with the opposing views. &gt; I can't see anybody spending any significant effort in trying to understand the proposal before criticizing it Is it any more fair for you to claim I put very little effort in reading it than it is for me to claim you put very little effort in writing it? Every proposal that has had serious debate was much more extensive and focused on the problems they were trying to solve with real world examples. &gt; But people don't read it as carefully as proposals of the Go team for example. Again with the not reading carefully. &gt; But I won't participate in destructive opinionated discussions that pretend to be objective while they are clearly biased towards what they know or learned. Technical discussions don't have to be objective or free of options. They just need to be civil and focus on technical merit that can be quantified. You forgot the second one and eventually the first. &gt; Just crying "I want full support for generics or nothing" is childish and has been the general reaction Childish is placing yourself in the spotlight with an official proposal and then claiming anyone who disagrees didn't read it, is biased, feels your not qualified or some other excuse that.... wait for it... can't be measured. It's all emotional. This was what you signed up for. Literally the entire purpose of a proposal is to put an idea you are passionate and feel strongly about through rigorous review by your peers. Thats what I did, I gave you a review. So did many others. You didn't listen you just got hurt that everyone wasn't praising your approach. You could have fostered some fantastic feedback but hopefully this reply and the experience in general will help you with future technical debate to be better poised to see it through more elegantly. Take care. 
Oldie but goldie.
I don't think you're seeing a race condition. It looks like you're simply not copying the data from your `file` instance to your `f` file?
hmm, but I added wait 5 second and it worked, I added that part of the code to the post. edit: actually you are right, another file is populating it in some other goroutine, thanks :)
ITT: OP getting mad that people don't magically understand his stupid idea, asks them to try harder, thinks he's doing us a favour.
Dave also provides the solution to your problem: https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully Create different error types with an attached behaviour. Then you can check for that behaviour and the error text itself can be anything and can change anytime. You also get the stack traces and no need to call Cause().
So basically you've designed something that overlooks what Go developpers needs the most, which is to have generics to build generics types.
&gt;Well there is always maintenance cost, also with generics. Sure, but generics lowers this cost. For instance, if I want a generic struct, either : * I duplicate the code. It's type safen, but the day I'll want to add a field somewhere, I have to do it everywhere. * I use `interface{}`, which isn't type safe. &gt;I prefer to have the maintenance cost inside a (standard) library to having them inside the compiler, because the compiler should be heavily optimized in various directions (compilation speed, execution speed, error messages and needed informations) and is by nature a much more complex beast from the beginning than a library that is focused. &gt;So the trade off made here is: less complex compiler and more complex usage. But libraries using generics are supposed to be reused often anyway, so why not invest there and then reuse often? No, the real tradeoff is to make a more complex compiler in order to have a proper generics in the language, that can be used anywhere. If you put everything into a library with structures that uses `interface{}`, as your proposal would force us, the cost would be not only in the library, but also in the "final" code, as we would have to use type assertions, type switches, and handle errors gracefully. Generics won't need that at all. You request a tree that contains Int64s? It will return Int64s, nothing more, nothing less. No type assertion is needed, no errors to check. This results in smaller and cleaner code. If you try to put or get something else into the tree, the compiler won't let you do that, but who knows what would happen with `interface{}`. Crash? DoS? If you want a simple compiler, you might as well use Lisp, not Go. &gt; An important aspect of the proposal is that the packages could compile the blank types "away" (apart from keeping the type signature of the blank functions). So when they get used the implementation of the blank functions can be ignored from the stand point of the called (just the signature is needed)¹. Which keeps fast incremental compilation times. Generics on the other hand would require type copying/code generation (including methods etc) for each new use case (= concrete type). I don't see why it's not possible with true generics. Could you expand a bit on that?
After listening to the talk, I doubt that generics will make it into the language. I fully agree with the Go team rationale. 
I have updated to proposal with ideas of how full feature parity with generics could be reached.
see my update
Thanks - I'm glad the post was useful for you. :) I haven't seen a Go-based standalone unit-test runner anywhere for smart-contracts. There are some web3 things I've seen in the JS-based frameworks, but I haven't seen much tooling for the Go-side of things. Sounds like a great idea! :)
See my update. Feature parity with generics could be reached.
That talk is so good that despite Rob's jacket I don't mind watching it again.
Prediction: Author would then start counting characters between ^ and $.
Yep... not the best solution at all. Things would be much, much simpler with true generics. Also, you can't really guarantee type safety if the struct is in the same package as the code that uses it.
If you work in a team, you do not have that luxury. The features that are selected include ones you would not have selected, but you still have to live with them. Some of those features will be chosen by above average programmers. Given that we cannot all be above average, some of us on the team will then be working with code that is harder to understand than we are prepared to deal with and still confidently and quickly make correct changes. Choosing Go (where the universally usable features and the available features are almost the same set) is not something you do for you, choosing Go is something you do so that your idiot coworkers can understand the code you are writing. But just remember: they get to say the same thing about you!
I love to see the principles of Go making their way out into other languages :). It's worth noting, though, that the biggest performance hurdle for channels is not the producer/consumer scenario, but the "select" construction. Channels in Go could be far faster if there were no select. Lots of interesting reading on the mailing list, one example below. Can't remember how to linkify from mobile, so apologies for the ugly link: https://groups.google.com/forum/m/#!searchin/golang-nuts/Channel$20select$20optimization/golang-nuts/Y657JhO2jpE
Comparing with [this](https://astaxie.gitbooks.io/build-web-application-with-golang/en/04.5.html) example, you don't test the returned error from FormFile. There could have been an error. You are also missing the io.Copy() which I guess writes the data in the file. You should also close that file. 
This should be required viewing for people wanting to change Go. Go's current features make for really good basis vectors. It's so easy to ruin that by adding things...
I've updated the proposal to include an idea about how feature parity with generics could be reached.
Well "not the best solution at all" doesn't look like an argument to me. Can you elaborate? I've pointed out the main benefits vs generics: i.e. no code generation for each type that is used with a blank function which is huge IMHO. Why do you think that type safety can't be guaranteed if the struct is in the same package as the code that uses it??? Can't see how package boundaries relate to that.
Registers are limited resource and do not contain much data, at best you can fit in integers or floats but no strings, structs, etc.
I find templating to be a bit of a pain to set up a good structure for using layouts and reusing elements
You can try gometalinter, and learn the tools in this set one by one. https://github.com/alecthomas/gometalinter All are helpful tools :-）
Do you have any obstacles in using an API driven front-end like Vue.js/Angular/React? What would you need to consider using one? (a few articles on how to set it up? an example project? somebody who'll tell you how to avoid some gotcha's?)
Ok, since you have taken the time for a long response, I will answer your questions or point out why I didn't answer your critique. The personal points I will ignore, since there are critiques and comments I did appreciate and answer although they were not praising my approach. My point was just that the Go community in general is good at criticizing for the sake of criticizing and bad at seeing possibilities and visions. However now to your critique: &gt; Syntax doesn't align with Go specification. Maybe but syntax is the least I would care about. Could be easily changed if a better idea comes up. However I think it is a good feature for blank types to stick out, since they have different properties and are no real/runtime types but just hints to the compiler. &gt; The above flaw with not being able to describe the behavior of a $T makes this completely unusable. Too general. Can't follow you. &gt; Basic generics use cases are impossible if you don't specify how to unbox types. You failed to recognize that blank type provide no boxing at all (that is the whole point: no new boxing is needed), since at runtime it is just the empty interface{} wrapper. However I implied that this would be clear from the proposal. I now made it explicit in the proposal. &gt; At the end of the day of generics isn't just about getting a T and returning a T. That is the simple part. You failed to read the title properly: It was not suggested as generics, but as an alternative to generics. However after some reasoning it became clear to me that even full feature parity to generics is possible with some small changes. I have now added these ideas to the proposal. So if you can't read the title properly in my book you didn't read carefully. "instead of" and "alternative to" is not the same as "equals" or "implements". The Go team provided functions like append(), len() etc. which are while providing some functionality expected from generics are by no means generic functions. Why can this be understood by the community while a simple: "Here is another approach to get some of the functionality expected from generics" can't be understood, although it is practically the same thing? (Well I understand the psychology behind this, but that's another topic). I don't think, it is necessary to get a proposal right in the first place. It might be improved by the input of others. However ignoring the purpose and claiming that it doesn't do what it wasn't supposed to do is not helpful in any way. That was my point. Now however that I found a way to get full feature parity with generics you may compare it to generics however you like. Just please don't ignore the purpose that is: no need for code generation each time a generic function is called with a different type. 
Yes. Strings are passed by placing the pointer (reference) to the string in a register. The pointer is not pushed onto the stack unless you have too many arguments for your registers.
&gt;Well "not the best solution at all" doesn't look like an argument to me. Can you elaborate? I've told you : it's overcomplicated compared to what we can do with generics. type List&lt;T&gt; struct { Length int FirstElement *ListElement&lt;T&gt; } type ListElement&lt;T&gt; struct { Value T NextElement *ListElement&lt;T&gt; } With all the methods behind, it's really simple implement, to understand and to maintain compared to your solution. &gt;I've pointed out the main benefits vs generics: i.e. no code generation for each type that is used with a blank function which is huge IMHO. As I said earlier, it's not the best tradeoff. &gt;Why do you think that type safety can't be guaranteed if the struct is in the same package as the code that uses it??? Can't see how package boundaries relate to that. If the code you're working with is in the same package as an element that starts with a minuscule character, you can access to it. If you're not in the same package, you can't. It implies that if I'm in the same package as the list struct you put in your example, I can do list := NewList(1); list.stdlist.PushBack("bépo"); The compiler won't catch it. It will only guarantee that you can't pass an int to the PushBack method of the struct you wrote.
I am in the middle of a project using ReactJS with a API in Golang. So far I'm very happy with the choice of technologies. It is a full single page application so the only interactions between the two are the API calls, just simply passing JSON. The API was quick to write only having a few endpoints to start with, so the main development has been in creating the views and handling the calls on the front-end. There is a good video tutorial on 'react single page applications with golang' I can't seem to find it right now though. If you're gonna go with react I would definitely recommend looking at create-react-app it will help get your dev environment set up and configured with everything you need really fast. As for the go API the only thing that I took some time to figure out was what type of authentication to use. I settled for using JWT middleware wrapped around certain endpoints to manage users.
I would be beneficial. If you would read and try it unbiased, then you would see. Instead you are getting personal. If you don't understand my idea, how can you judge it is stupid? Is everything stupid that you didn't understand in the first place? Interesting... Asking to try harder implies that I think you could understand if you try harder. I don't think you are stupid. But the mental effort must come from you. It is no magic and I can't help you if you don't want to try new ideas. Also if I don't understand something, I would ask questions instead of blaming.
&gt; I discover that creating a file and calling iotil.ReadFile immediately will lead to empty data returned even after file sync. That's correct. What else do you expect to read from an empty file??? Do the `f.Sync` (and check for errors), *after* writing data to the file or add os.O_SYNC to the flags.
Yeah, who needs horseless carriages, right?
I did try and model the problem using the behavioral approach, but I'd still have the same problem when trying to print the stack trace. In addition, I feel that as the error types would be part of the domain, and it should not be part of the domain to determine if something should be retryable, etc. I just want to let the caller know that a type of error happened, then they can make decisions about the next step and maybe pull more information out of the error to construct an error message.
Another good solution is the way [Upspin](https://github.com/upspin/upspin/blob/master/errors/errors.go) is doing errors.
Regarding the authentication endpoints and user management - did you consider using some external service like auth0, or some project which would get you half of the way there (ie, where you would just implement the user storage back-end interface?).
“Any fool can make something complicated. It takes a genius to make it simple.” ― Woody Guthrie
Yeah, I looked at a few options but wanted to avoid adding any extra dependencies. I ended up using gin-go to handle the routing and the middle ware so it was pretty much just a case of adding gin-jwt and configuring the endpoints that required auth in a group that used the jet middleware.
This is https://github.com/golang/go/issues/19412
Dealing with arbitrary json is a pain. So much interface{}.
[This](https://web.stanford.edu/class/cs101/) should be required for people who don't want to change Go. Go's current features make for really good echo chambers. It's so easy to ruin that by introducing logic and reasoning...
Ok, let's agree to disagree then when it comes to the trade offs. Concerning the same package issue, I understand you now. In practice though I think it won't matter much since I see blank functions mainly as reusable functions inside libraries and if you develop them you must know what you are doing anyway. But I accept that you have a different opinion on that. Anyway, thanks for the input!
I just really want to finish this project of mine that unfortunately needs cgo. Anyway, I'll try it today on my elementary os.
It is not possible because the package containing the generic function can't know it advance for which types it is going to be used. So when being used the compile needs to treat the original function as a template and "fill" it with the type info and then compile it, before it can be used (in order to be able to properly allocate memory etc. based on the types). So you end up compiling the same function over and over again for each combination of types. That will make the compiler slow for large code bases, even if you cache the compilation for each type/generic func combo needed.
Clearly explained and was something I haven't heard of yet. Thanks!! A great way to add extra client logging as well. 
Thanks a lot! I finally managed to get it working. 
How did you tackle that issue? Map everything to map[string]string? Decode only known fields into structs? What is your approach for dealing with arbitrary json?
Dependency Management is a bit awkward in my opinion. Especially regarding build-pipelines with private repositories and dependencies to projects in private repositories.
For cases where I don't care about the schema I like to use https://github.com/buger/jsonparser
&gt;Ok, let's agree to disagree then when it comes to the trade offs. Well, it's quite normal to make a compiler more complex to make the language more simple to use. Your proposition is just going to frustrate Go developers for another five years. &gt; Concerning the same package issue, I understand you now. In practice though I think it won't matter much since I see blank functions mainly as reusable functions inside libraries and if you develop them you must know what you are doing anyway. But I accept that you have a different opinion on that. Anyway, thanks for the input! There is how you conceive it, and how people will end up using it. Sometimes you need a generic data structure, but you don't necessarily put it in its own package.
The same thing goes with your proposition. For instance, when I multiply or divide an integer by a power of 2, the compiler can transform it to a bitshift. It can't do the same thing for floats, because they work differently. (or maybe I really don't understand what you're trying to say, in which case I'm sorry)
This isn't meant to be snarky or rude! I'm actually asking for examples of your use case which my apps have probably not been complex enough to require! That said: When you control both the front end code and the back end code, what arbitrary JSON are you encountering? I've always managed to define the message structures explicitly and therefore have never had to deal with arbitrary JSON.
Honestly, if you're trying to keep a dependency in a private repo (and by definition, don't vendor that dependency), you will not have reproducible builds. I guess the closest you can come is a git reference (git subproject)? How are you approaching tackling this issue? Extra tooling is always an option...
My most recent example of dealing with "arbitrary" JSON is a trading bot that interacts with the exchange's websockets feed. There are multiple possible schema for incoming messages, so before I can decode into the correct struct I have to do some testing to see what I'm dealing with.
What the hell is that? This code does go f(c0, c1); go f(c1, c2); ...; go f(cN_1, cN); cN &lt;- 1 &lt;- c0 What is the point of that? They're not going in parallel, it's a sequence. Why use channels and goroutines here? If there a real-life code like this? Then the C# version. Why use channels in C# in the first place? Go channels are used for promises, queues, events, etc. Because Go has no proper primitives for all of those, only channels. It's just how we use `map[T]bool` for sets because Go has no `set[T]`! C# already has `Task&lt;T&gt;` for a single value, use it. Using channel here is same as using `List&lt;T&gt;` for output parameters instead of `out T`. It works. But if you need to pass only one value, why use a full-blown queue for that?!
Well bit shifting and multiplications are no legal operations for a blank type. So you would have to write it for a concrete type anyhow. This proposal won't change that. However if Go would get union types (which is orthogonal to the proposal and could be well combined), then you could define a union type for all numeric types and a function with a type switch to do the bit shift or whatever in a type safe way (well you just accept n types and do n type switches). I was taking about the legal operations (according to proposal) on the unknown type that is a blank type in the definition and an interface{} wrapped value at runtime, like append etc. And what the blank function actually does. It all has to be compiled over and over even if the only thing that changes is the type which is inspected at runtime anyway (by the generic functions that receive and interface{}).
BTW I totally agree with you when it comes to a tight integration of builtin types and interfaces and also on the need of union types. While I don't think the former would be accepted by the Go team, the latter could be a different, orthogonal change that would nicely complement my proposal.
Aren't methods names mangled by the compiler? Could you check that (I don't have access to an Unix system, nor to a Go compiler right now)?
Sometimes it's necessary to use intermediate and/or compound structs, i.e., when I know the exact nature of *some* of the incoming json, but other parts of it can vary, I decode the json into a struct with known fields and specific types for the set/non-varying part, and for the varying part I use a type of json.RawMessage. Then as a second step I figure out what the format of the json.RawMessage part should be, and only then decode it into a proper struct.
I found that the best strategy for me is to just commit the vendor directory (when external public dependencies) and for private dependencies, rely on git submodules.
Can't map everything to strings because of arrays and objects. I don't remember the exact solution because I've run into this in multiple projects. Sometimes I use a third party library that makes grabbing nested fields easier. Sometimes I write a depth first traversal function, and sometimes I just decode known fields. It depends on what the project needs. Much easier when I control the json format.
Oh, that's a jacket? I thought I had some codec issue.
Not sure how you reached that conclusion. It's very common at companies to use a private repo to mirror dependencies. This allows you to keep known good versions and prevent developers from pulling down dependencies that may be incompatible from a licensing perspective. This is in fact, THE way to create reproducible builds in the working world.
Thanks for taking the time to read the post..
I wasn't referring to skill level but rather tools that will get the job done at a much faster pace. Instead of wrangling a bunch of techniques the language provided in your head for solving one problem, just select the one that is known to work well and stick with it. I think this will solve the feature bloat problem. I'm pretty sure language designers aren't expecting you to use every feature in order to be productive. 
I may have misunderstood the authors point. I assumed that the issue is that because the dependency is private, they are not allowed to vendor it into their project directly, and need to install it from the build pipeline (ie, with a glide/dep/other). As soon as you vendor the repository (or a mirror as you suggest), then you achieve reproducible builds. I'm not saying that you can't do this without vendoring, just that it requires several moving parts which may or may not be the same the next time you build your app, regardless of the actual cause as to why.
I wonder everyday if i should port legacy code to Go... Of course code that works should not be rewritten. But I add features regularly and they are mostly in Python2 ! So one time or another i will have to upgrade to Python 3, then why not rewrite them in Go directly ? If I want to rewrite Python code in Go even if I use Python since more than ten years it's because after few years of Go i found that my code is more easy to maintain. Easier to read, easier to update because of type checking and less dependencies.
Did you really make a throwaway account to trash talk tech stuff? Seriously?
&gt; Except the horseless carriage is simpler than the horse-drawn carriage. Really? The regular carriage has 2 animals plus some wood. Horseless carriages, on the other hand, have thousands of distinct parts sourced from hundreds of locations using thousands of different materials and all such parts need to work in perfect, high precision harmony. &gt; Now you have to have a barn to house your horse, Just like your car &gt; feed it daily, Just like your car &gt; and even if you take perfect care of it it may incomprehensibly die on you. Just like your car :)
Yes, I was talking about a case where vendoring the dependencies is not possible due to some project-specific restrictions - I didn't make that clear in my post, I'm sorry. :) And in that case, although technically possible, it's not trivial to have reproducible builds with a simple toolchain.
&gt; 2 animals plus some wood Each of those 2 animals are _way_ more complex than any car ever built by humans.
"interfaces are just set of methods.. people ask for variables there too all the time.. they ain't gonna get them" I am laughing my ass off thinking of one particular language that have been indiscriminately adding all new features imaginable for last 10 years while authors are wondering why it is not really popular yet.
This was a nice change in conversation to see this morning, I'll make sure to view your proposals updates after work. If my overal opinion doesn't change that it's a viable alternative for generics my opinion has changed about the discussion around your proposal so good work on that front regardless. The main thing is everyone has full generics on their minds, having the word alternative means people were looking to fill similar use cases. Me and others couldn't understand how some of the main use cases for generics could be facilitated. Again I'll check and see if changes you made allows those uses cases now. If I fail to see any of them I'll ask you to show me how I would achieve them. Thanks!
In case anyone else is confused about storage: CAS = computer algebra system.
In this analogy though, the animals have 0 complexity since nobody needs to design and implement them, unlike cars.
Thanks for the info. I can certainly understand that. It's not that it didn't cross my mind, I would love to put my teeth into select :) But I rarely use it outside of status checking and for that purpose non-blocking operations work just as well, despite being much cheaper to implement.
The short version is, always use append to assign back to the same variable. i.e. foo = append(foo, somestuff) This is because append can sometimes return a new backing object, so if you don't reassign it to the same variable, multiple appends can do surprising things. While there are times when it's safe to assign to a different variable, it's best not to get in the habit because of all the times when its not safe.
Man, I have stories there. How does a Go server with a CGI endpoint/websocket endpoint executing a PHP/bash/node/docker code sound? I mean, for me it sounds fine, I didn't have to change more than a few lines of code that works (no rewrites), but I feel like it's the most hacky thing I've written. Good thing it's an intranet app, of course. In a [relatively huge API service I'm writing](https://api.rtvslo.si/console) there are a few layers of implementation. The most vanilla one is PHP, while more important calls (or the most frequent calls) get completely phased-out from PHP and implemented either in Go or LUA(+Redis) and end up in the 0-1ms/req range. Basically, I can suggest you to do the same - the calls which you have problems with, implement in Go and perform some integration tests so you know they perform the same thing. If it's a rarely used call, just figure out how you will provide a Python 2 environment years from now. Eventually, old shit will be phased out.
So, how are you approaching it? Custom toolchain? Anything more or less available as open source? :)
I feel kinda dumb for not realizing this sooner. Got to thinking: does string concatenation have similar gotchas, since it is a []byte underneath, or is that safe?
http://fqa.9front.org/golang.gif
Currently I'm using a mix between the technique described in this post on "go get for private repos in docker" (https://divan.github.io/posts/go_get_private/) and the new docker multi-stage builds I described in this post (https://zupzup.org/docker-multi-stage-react/). Basically, the first step in the docker-build is to build the binary using the technique described in the first post and then copy that binary to the output-image. This way the ssh-key for fetching from the private repos is never in the filesystem of the output-image. On some CI systems such as GitLab, the ssh key can be provided via environment to the building docker-container, which makes things easier, but in any case, I dislike having to handle ssh keys because go get has no good solution for private repos at the moment... Unfortunately, I don't have any open source code for this right now, but it's really no magic, just a bit awkward to do. ;)
`bytes.Split` uses slices underneath so you get the following super confusing behoviour because of what is described in the blogpost: code: package main import ( "bytes" "fmt" ) func main() { subStrings := bytes.Split([]byte("a,b"), []byte(",")) a := subStrings[0] b := subStrings[1] fmt.Println(string(a)) fmt.Println(string(b)) aaa := append(a, 'a', 'a') fmt.Println(string(aaa)) fmt.Println(string(b)) } output (the last one is very unexpected): a b aaa a We even bought a special domain to show this off: http://fucking-go-slices.com/ EDIT: made example clearer
I'm not woo-hoo generics like some people, but I would find an official set type (ala map) quite useful. I'm not a fan imitating sets using map. I'd also like a way to have pass-by-value maps and slices and wish there was a way I could specify optional values in database/json mappings that didn't require the use of pointers. Pointers force us into pass-by-reference in many scenarios where I actually want pass-by-value.
Not to be repetitive, but let me repeat myself: if you work in a team, you don't get to choose the features. The language designers of Go wanted that all people working in teams of various skill level could understand and extend all code that their colleagues write. So yes, they very much expect you to be able to use every feature of Go without stumbling on gotchas.
Simplicity this, simplicity that, why is there so much simplicity jibber-jabber in Go community? Regardless of whether simplicity is or isn't a good thing, IMO it's not even true in case of Go to begin with, not _that_ much, anyway. I only had a brief experience with Go so far, but I think that's actually better when judging simplicity. Here are some reasons why I don't think Go is really as simple as people seem to frame it: - Duck-typed intefaces - it's dificult to tell what type implements what interfaces, since in order to tell whether a type implements an interface, you have to go through all the methods and check if they match. - A special case of the above is the catch-all `interface{}`, which is used for dynamic typing. Using both static typing and dynamic typing routinely in one language and switching between the two on the fly is rather confusing. - Panicking. Having the panic mechanism means there's two mechanisms for error handling. Panicking itself is a complex construct (it behaves like exceptions). (Note: I myself understand why there are these two mechanism and what the differences are, you don't need to explain. I'm just saying it is a complexity.) - Instead of enums there's the weird `iota` thing. IMHO it's less obvious than enums. - Instead of tuples there's multiple return values from functions, which seems needlesly complex. Having a function always return just one value is a lot simpler than having to worry about how many freaking values are returned from what functions. Tuples are fairly intuitive IMHO and many people are familiar with them from elsewhere. - Weird method syntax - the 'receiver' syntax. It's needlesly complex, because you kind of have two argument lists, the first one of which is special-purpose. Why not just use UFCS? That would be much simpler. Also, why allow arbitrary names for the receiver argument? Many other languages reserve `this` or `self` for the receiver argument, which makes it really stand out when reading method code. In Go, you first need to check what the receiver is named and then look for that in the code. - Syntax like the `defer` keyword or channel syntax (the `&lt;-` and `-&gt;`). Seems like it's just unnecessary "magic" syntax one needs to learn to be able to read Go code. It's also ironic that there's no dedicated syntax for `this`/`self`, but there _is_ dedicated syntax for defer and channels. The channels syntax kind of makes sense, I guess. The defer, not so much, that could've just been a builtin function. - The `make` function, which is a constructor for several unrelated types. That's off the top of my head right now. All in all, it seems to me the creators of Go wanted to avoid the complexity of some other languages, but ended up making tings differently just for the sake of difference and in the end in some cases only traded one complexity for another. Disclaimer: I'm not saying Go is an exceptionally complex language. It is simpler than, say, C++ or Haskell. But it doesn't seem to be extremely simple to me either. I'd say it's roughly comparable in complexity to Java (before 8) or Python. It's more complex than, say, ES5 IMO. The complexity level definitely doesn't justify the constant rants about simplicity. 
&gt; Simplicity this, simplicity that, why is there so much simplicity jibber-jabber in Go community? It's because of how Go was created: *Ken Thompson: When the three of us [Thompson, Rob Pike, and Robert Griesemer] got started, it was pure research. The three of us got together and decided that we hated C++.* ([Source](http://www.drdobbs.com/open-source/interview-with-ken-thompson/229502480)) Also I believe that a large portion of the Go community has been "burnt" by the complexity and bureaucracy of other language ecosystems and simplicity is a big reason why they are using Go.
Instead of tuples? Well, Python has tuples and it has multiple return values too. And i have never seen a decent Python code where multiple different by nature values would be returned from a function in a tuple. It's just gross.
&gt; Instead of tuples? Well, Python has tuples and it has multiple return values too. It doesn't have multiple return values, you return one value - a tuple. Not sure what you mean by the rest of the comment. 
The OP probably spent a lot of time writing this and I admire the effort, but I really wonder why reinventing the wheel : generics exists in almost every mainstream languages with static typing [1], why even starting a proposal about generics without looking at the design and trade-offs of other languages implementation ? [1] for instance : C++, Java, C#, TypeScript, Swift, Scala, Rust, Dart, OCaml, Haskell, *etc.*
Sounds like you might not be catching the error being thrown by `http.ListenAndServe`. As others have indicated linters do a fantastic job of letting you know where you might not be handling errors. If you don't handle the error you lose sight of the problem later on. ::sad gopher::
String concatenation won't suffer from this as the language treats the source strings as immutable. 
[removed]
This article is good in spirit and presents some good ideas, but doesn't quite hit the spot in terms of the code itself. Please try to present useful, correct code. Even if it's just for a short illustration, please don't `panic("Yup, we had an error")` in a function that returns an error. Just return the error. Beginners might get confused, experienced users might choose to not continue reading the article. Furthermore, in the general case, there is a race condition on `cacheTransport.data`, because `Clear` doesn't acquire the cache mutex. In the particular example in the article, the race does not occur, because the call to `Clear` is gated by a select and does not happen concurrently with other round-trips, but this is an atypical use case for a client (requests scheduled every X seconds).
A lot of your critiques relate to built in names or functions. What if I told you Go has less of these than basically any other modern language?
except this was a case of it NOT returning a new object but rather clobbering each others changes in a loop because the capacity of the underlying array was big enough. In this case the rule is don't append the same slice twice. 
Well, if you did foo = append(foo, bar) first, then it would be more clear that you need a new variable for each one. Ironically, what probably would work is that instead of Tags: append(commonTags, labelsToTags(d.Labels)...), you could do Tags: append(labelsToTags(d.Labels), commonTags...), And that would work (because presumably labelsToTags makes a new slice every time it's called). That is, assuming order doesn't matter.
And if limit the capacity func b() { x := []int{} x = append(x, 0) x = append(x, 1) x = append(x, 2) y := append(x[:len(x):len(x)], 3) z := append(x[:len(x):len(x)], 4) fmt.Println(y, z) } func main() { b() } [0 1 2 3] [0 1 2 4] As y, z lines don't modify x, but creates a new slice with x's contents. Not saying this is a good idea to do generally, but it works.
How is this one confusing? You're appending to the first element of the slice, which implies it itself is a slice.
&gt; I would prefer if I can find a solution where the file is checked for last modify time and serve the fresh copy instead. Go's http.FileServer already does this. It supports any HTTP client checking the last modification time via an HTTP HEAD request, and only fetching the file if it has changed. You can fire up [a quick server](https://gist.githubusercontent.com/paulmach/7271283/raw/2a1116ca15e34ee23ac5a3a87e2a626451424993/serve.go) on some temporary files and verify: % curl -I http://localhost:8100/compelling.png HTTP/1.1 200 OK Accept-Ranges: bytes Content-Length: 154093 Content-Type: image/png Last-Modified: Mon, 24 Jul 2017 17:26:46 GMT Date: Mon, 24 Jul 2017 17:29:32 GMT Touch the file, curl again, and you'll see the Last-Modified header is changed. &gt; I can bust the cache on the client by injecting a URL parameter string on each image reference but I would prefer if I can find a solution where the file is checked for last modify time and serve the fresh copy instead. Your server already supports the behavior you want, the problem is that as you've discovered, browsers don't always behave properly. So you're going to have to inject a URL parameter to force the browser to refresh its cache.
Definitely agree - a built-in set type would be great, I'm tired of writing my own set types, even if it's only like 40 lines or something for a full-featured set, I've done it too many times. The optional values thing I can see both sides of. There are a lot of devs who think the use of a nil/null pointer as a meaningful value is the worst kind of code smell, and I understand the reasoning, but the alternatives all seem clunky - and Go's stdlib doesn't provide any alternatives. There is no way after decoding JSON into a struct to know if a field was provided or not; you can only guess based on the zero value for the type. Some facility for interrogating the JSON parsing would be really useful in some cases.
Yeah you are spot on that the server is showing a modified time in the header response, indicating it has changed. Kinda funny that Google Chrome is the browser ignoring this header. You would think their own browser would handle this response header correctly given the standard lib expects it. I can even access the image URL explicitly and see different images based on the cache busting string I input.
Appending to the first slice overwrites the data in the second one. The most confusing part is that if you would add 3 a's it wouldn't happen because it allocates a new buffer. 
I'm currently doing some major refactoring because I made the mistake of trying to work around the lack of generics when building a data mapper layer. Sure, I avoided repeating myself, but the code ended up complicated and ugly. So now I'm giving in and not even trying to share an interface between mappers for different types, and the result is simpler code. I'll just have to remember to keep the interfaces in sync. I wish that wasn't the choice, though.
http.FileServer uses [serveContent](https://golang.org/src/net/http/fs.go?s=19273:19313#L152) under the hood. It either sets the `Last-Modified` header or omits it and replies with a "not modified" status. Seems to me the browser is not actually making any requests. Have you checked the actual browser behavior when making requests using the browser developer tools? Anyway, why not set the `Expires` header to a sensible date in the future? That way it will attempt to fetch the latest version when reaching the expiration date. The HTTP server might respond with "not modified" without sending a body OR simply send the latest version. EDIT: I don't know what the best practices here are. Feel free to correct me.
Even more strange: I can visit an image URL directly and see the stale image, and then click control+r to refresh and it starts showing the new image. Not sure what a page refresh is doing differently from a direct URL access but it clearly is treated differently in the browser.
I debated this but the issue the users are specially complaining about is that they modify an image and then generate a report within a few minutes, and the generated report has the stale image. Only way to ensure they never get a stale image is to expire cache immediately using this approach. I still want the cache to function, except I'd like to immediately expire cache for any image that is updated so it either grabs fresh copy or update image in cache.
Ahh, I see now. Thanks for the clarification. I've gotten in the habit of just treating slices like pointers to pointers, despite append returning something (that itself triggers the line of thinking that it's safe to use) edit: is there a bug report for this? It seems like this should be solved in the bytes package.
Can't have it both ways I suppose. Chrome requests a file and remembers the last modified date. Now it's cached. You visit the same site again and Chrome uses the cache: no request is made. Chrome can't know about the updated file until it actually requests it (ideally including the last modified date, so the server can respond with either 200 or "not modified").
That seems to defy the point of remembering the last modified date if it never sends another request to determine if the server's version has changed before using the cached value. What should I do from my perspective to make Chrome check with server before using its cache for these images?
This is really cool! I was looking for a symbolic math program in Go a while ago. I think it's a great (and very ambitious) project. From the README, it sounded like the goals were mostly to satisfy technical interests of the author(s). Is this correct? If so, is there a corresponding blog with "lessons learned"? I'd love to learn more about these systems (I use Sage a lot), but I don't think I'm motivated enough to read textbooks or tons of academic papers.
Check the [CSRF cheat sheet](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_\(CSRF\)_Prevention_Cheat_Sheet). An HttpOnly cookie is often used.
I just did a run through on an annual(ish) review. Any feedback &amp; suggestions for improvement welcome.
&gt; tags := []string{} https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices
Using a non arbitrary exchange format. JSON is almost entirely useless when it comes to provided real information in format. It always needs an external description. There is not much Go specific that will make dealing with JSON fun. Automatically generating the structs you will need for the incoming JSON is as much as one can really hope for. It's doubly sad that JSON is not only annoying to work with but also exceedingly unperformant.
On a line by line or screen-full by screen-full basis, Go is not complex, because there is very little magic between what the code says on the screen and what the code does at runtime. Thus the programmer maintains less complexity in his/her head. What Rob has said in this talk and others is that in order to get the kind of complexity you are talking about with not very much of the kind of complexity that makes people unproductive and programs have unpredictable behavior (i.e. bugs) you need very simple primitives that fit together in simple ways.
[removed]
I have programmed in C++ (mainly) and D. I have also programmed in Java before generics were added. I know what generics are and why I don't like them. I fully agree with Rob Pike´s view on the language simplicity. We don't want another C#, C++ or Java. Use them if you want generics. Go is about simplicity, and I don't see the benefit in adding generics. The interface in Go is very different from an abstract base class. There is no need to explicitly say that your class implements an interface. It is automatic. Go's interface is more powerful than inheriting an abstract base class. Go's interfaces is pure duck typing. Whatever quacks is a duck. All you need is to provide a quack method. 
Good point that this might be considered a bug. I haven't looked at the issue tracker yet to see if one exists already. I'll file one tomorrow once I'm at work again. Would be good to see the result make more sense by default. EDIT: just created the issue: https://github.com/golang/go/issues/21149
&gt; What if I told you Go has less of these than basically any other modern language? In terms of keywords, that's probably not true with C and quite likely Javascript if you disregard the ones that are reserved &amp; unused. Also, languages like C, C++ and such have no builtin functions and minimal set of builtin types. Go has a fair number of builtin functions and non-trivial builtin types (slice, map, channel - those are even generic!). In any case, I didn't really object to the number of keywords or builtins but rather the choice. 
Well, [Go has 25](https://golang.org/ref/spec#Keywords), and [C has 32](http://beginnersbook.com/2014/01/c-keywords-reserved-words/), and [Javascript has 48](https://www.w3schools.com/js/js_reserved.asp) in the newer versions. I believe the new types that Go added to the C typeset like slices and maps are there because they, or similar structures, are used extensively in so many programs in other languages that having them not be built in is silly. 
The mismatch between regular json being lower case and exported variables in Go being uppercase is annoying.
The fact that go's interfaces are structurally typed has no bearing on the usefulness of generics. Structural typing does not "save" you from usecases that are normally solved by generics. This is why I asked what your experience with generics was. Every time I hear "I haven't needed generics", it always seems like the person doesn't actually understand what they're for in the first place.
Since you can't use `Expires`.. I'd probably use the URL parameter and set it to the last modified date of the file. It is essentially a different file after it was modified; you might even rename the file itself instead. That way caching still works and you can update any time.
&gt; We are currently not interested to solve (1) in a fashion other languages do by providing primitives that can intercept every call. I wonder why that is. 
&gt; On a line by line or screen-full by screen-full basis, Go is not complex, because there is very little magic between what the code says on the screen and what the code does at runtime. Thus the programmer maintains less complexity in his/her head. This is entirely contradictory to the way I see Go and to my experience with other laguages. Languages like C++ or Rust do very little magic between what you see in the code and what happens in runtime, and that's precisely the reason they are complex. Because mapping abstractions to native code with minimal runtime inherently yields a complex language. Go on the other hand, is simple as a language, because there _is_ quite a lot of magic that's going on behind the code which maps the simple code to the complexities of more low-level computing. Go's runtime is substantially more complex than that of C, C++ or Rust (they basically have none). That's the reason the programmer doesn't have to think about so many complexities, the runtime and language does it for him. The same is true for other high-level runtime-equipped languages like JavaScript or Python. 
You can use the Go IDE created by them: https://www.jetbrains.com/go/ Additionally, you can use the Go plugin in any other JetBrains IDE from the JetBrains family (that's not a Community edition). You can read more about this here as well: https://www.jetbrains.com/help/go/faq.html Before seeing this thread, I've also added the part I left out, I don't have the time or resources to continue working on the plugin (and there's little sense in doing so since the IDE is so far ahead of the community plugin). I don't want to discourage any potential contributors, but if you look at the contributor numbers, I believe you'll find it that there aren't many that are willing to do the work for it, unfortunately. Hope it helps :)
&gt; Well, Go has 25, and C has 32, and Javascript has 48 in the newer versions. The fairness of that comparison is quiestionable, since the C and Javascript lists include primitive types. (Also, the JS list includes some keywords which are unused, I know of at least `goto` being unused). Arguably you can use Go primitive type names for identifiers, but I don't think that's encouraged, I definitely wouldn't like that. If we compare the list of builtin types, Go's is far larger than that of C or Javascript. And so, I'd say that comparison is apples to oranges. **EDIT**: Go also cheats by, for example, compacting `for` and `while` into a single keyword. This reduces the number of keywords _per se_, but since both constructs are still present, doesn't actually reduce complexity. The same goes for `private` and `public` - Go doesn't have those, but it has lowercase and uppercase indentifiers, which amounts to the same thing. &gt; I believe the new types that Go added to the C typeset like slices and maps are there because they, or similar structures, are used extensively in so many programs in other languages that having them not be built in is silly. Well, many languages have those as part of the standard library. In Go that's not possible, and so they went into builtins. Anyway, I know the reaons Go has those, I was just pointing out it's not as extremely simple as people claim it is. 