I understand the metaphor but I am not sure how much it applies here. After all, dlopen comes with dlclose, it is part of the protocol to close dynamic libraries. A Go plugin seems to be mostly a map from strings to symbols (as given by dlsym). Is there something about garbage collecting symbols that is problematic (this does not seem required, though)? I tried looking at the source code but I can't find the source of lastmoduleinit.
For this you should use something like [go-plugin](https://github.com/hashicorp/go-plugin). It is *really* hard (probably impossible) to cleanly unload shared libraries in go. You'd have to answer all these questions around goroutines spawned by that code, memory allocated by it, file descriptors referenced by it‚Ä¶ How do you make sure, that there are no resources are around? The answer to these questions is, that you isolate the plugin in it's own process and let the OS handle the cleanup. That's what go-plugin does. Plus, you get the added benefit that you can compile them with NaCl and get secure execution. Your usecase, indeed isn't satisfied by that. But your usecase, luckily, is already covered by a different implementation.
There already is [go-plugin](https://github.com/hashicorp/go-plugin) for that. Any `Close` would likely need to do mostly the same as they do anyway.
I can't find it either. Cruising through their github presence looking now: https://github.com/sourcegraph
The author is suggesting the exact opposite of Peters article 
I don't think it's impossible to implement clean up. When imementing a dl lib you have a ctor/dtor attributes that get called upon dl open/close. I think if when building a plugin Go called init() upon dlopen() and added a new func deinit() for dlclose() call you can entrust the higher level application resource management to users and then run Go' standard runtime shutdown process (merciless destruction of go routines like a main() exit). Important go routines could simply send on shutdown channels when deinit is called for critical Go routines to exit naturally. The plugin closing could block until all deinit funcs have exited. Maybe plugin close can return some sort of way to allow callers to cancel the shutdown after a duration via channels or deadline etc. Just some thoughts, I think closing may be important for a good bit of valid use cases.
Thank you, I'm beginning to see how incredibly useful this has the potential to be. Having pluggable functionality without having to recompile the main program is huge. I hope it is / ends up being relatively performant.
hey thanks for the update, is there a github mirror repo?
&gt; and javascript for the client OK, now I feel a bit like a jerk. . . yes, but you have no choice for the client. The backend API could be written in just about any language. That was my point. If you are new to programming then you should read up on this, or not, you'll find out soon enough.
As far as I know, Google used Go in dl.google.com, which is not really a web app. I'm not sure what sort of library/kit/framework/you-name-it Google uses for their user facing apps, like search. I think search is build on java/python/c++, but I might be wrong.
Ah I see, thanks for replying.
Go is somewhat platform agnostic, and as such wouldn't come with something this Windows-specific out of the box. You should be able to implement it with the Windows API though. Have a look at this: http://stackoverflow.com/questions/8046097/how-to-check-if-a-process-has-the-administrative-rights
Nobody ever said Go isn't suitable for large web apps, idiots who like controversy on the other hand like to make up stupid things like the title of that very thread. Enough with the made up controversy and click bait . What are you 5 year old ? 
/u/sqs , you seem to work on sourcegraph, would you be able tell us how you addressed the points raised in the parent comment by /u/fortytw2 when building sourcegraph?
Just curious, what is your go-to stack most of the times and why?
I have to use VB web forms for about half my job. Stupid monolith legacy app. Update panels can bite it. Can't wait until it's all done being converted.
*technically* you could use Elm or Typescript. Supersets of Javascript, but more resilient in different ways.
Even with SQLx, it's very easy to land up writing a ton of awful boilerplate to turn struct-that-maps-with-SQLx-from-query into thing-you-want-to-have 
It depends a lot - Ruby on Rails w/ Go in the background for more resource intensive/control-focused operations is generally my go-to for CRUD-focused webapps, but it really, really depends on what you're building. Django is great if you want some dataviz tossed in, Phoenix is fun with websockets, Sinatra/Flask when you want some dumb little web UIs for things, etc 
The lack of sane handling of subdirectories is annoying. I know you can reference them as another package with the whole path to the subdirectory, but why does it have to be so painful? I think in most places a subdir wouldn't stand alone as its own package, so I am always annoyed to have to treat it as such :(
Our company writes huge services using Golang. It's been an amazing experience and our entire team is happy with choosing Golang as our primary language
&gt; something that compiles to Javascript That is true, I could have said something that compiles to OR wraps Javascript. But you know what I mean, it's Javascript all the way down.
All the way to the bottom of that sad sad barrel.
any tl;dr summary of how this is different than Caddy?
Nice, really straightforward. &gt; shttp is a zero configuration HTTP server to help on development of web apps. After having problems with some alternatives like python -m SimpleHTTPServer I decided to write this tool. This is exactly why I wrote Caddy. üòÅ
Services, or does your company actually serve html from go?
Our client facing services (JSON/html) and the majority of our back end services are built in go
I recommend adding a concrete context to the handler signature. `func serveXYZ(ctx *connect.Context, w http.ResponseWriter, r *http.Request) error { ... }` It could be used for per-request db session. This helps a lot in package testing because there is no global state to manage. (By using context and receiver, you should not need global variables.) It is also helpful to define per-project context package to be used with handler. If you design the context fields well, the context can be reused across projects while you take advantage of go type checking. 
I'd far rather have a native GUI library.
You've got libraries like [authboss](https://github.com/go-authboss/authboss) to help with most of the boilerplate authentication and user stuff. 
If such people exist they clearly haven't a freakin' clue what they're talking about. If you want to make claims like that about any language you'd better have a pretty well researched list of reasons why not. Almost all such assertions come down to arbitrary preferences.
How about explaining what's your problem and closing my curiosity? From what I've seen people are actively advocating vendoring and I'm pretty much fine with vendoring my dependencies for 1) repeatable builds, 2) some reliability in case of package upstream API changes. Please be constructive/argumentative if you have a different view point, nobody is saying that the OP is wrong, or that I'm right, and there's no need for "please leave".
And the amount of boilerplate you write to bend authboss to your will is almost as much as writing it all yourself :'( 
Virtual allows for overriding and dynamic dispatch. The method is still implemented. Pure virtual has no implementation* and must be implemented by the subclass. Like an interface type or abstract method in java and fairly comparable to go interfaces. I'm not familiar enough with JavaScript or smalltalk to be sure, but being dynamically (duck) typed I don't see much use for a pure virtual function. Most languages class methods are always virtual from what I've understood. The only language i know that supports and has non-(not pure)virtual methods by default is C++ I really like go's interfaces, they bring the best parts of duck typing and adds static compile time checking. \* strictly not true, in C++ a pure virtual function can have an implementation but it must be overridden by a subclass. The pure virtual function has to be explicitly called and won't be used for dynamic dispatch. tl:dr I don't think JavaScript and smalltalk has pure virtual functions but I'm not familiar enough to to be 100% sure. 
That was also my first question. Or even if not a Context, I'd consider wrapping &amp; passing individual objects (db) to a function which would return a http.Handler. I wrote a [Golang tips blog post](https://scene-si.org/2016/08/01/golang-tips-and-tricks-part-3/) about this a few months back. What are your thoughts on this approach?
Yes, it takes a few iterations of sub-packages to figure out the correct... division of responsibilities? Isolation? ... The struggle is real
* small improvements in compile times * big improvements in ARM performance did you read the same page ?
I do not understand the point of this library :-|
Most of my use cases are the same, and explicit declaration is required. The only way it wouldn't be, is if the configuration would be used only in-app, not stored or exposed, not defined with int but always referenced by name. I don't have many such use cases, but for the few I do have, it's concise.
When they say that the feature freeze will occur on Nov 1st, does it mean the compiling optimization phase will also stop?
With regressions for some benchmarks (gzip &amp; regex are ~1,9% slower).
This is great news! Are there examples on how it can be used anywhere?
Ah, I see on my local, the same issue. I looks like it's the XML version header:`&lt;?xml version="1.0" encoding="ISO-8859-1" standalone="yes" ?&gt;`. Looks like by default the `xml.Unmarshal` function doesn't work with that encoding. I found this SO article https://stackoverflow.com/questions/6002619/unmarshal-an-iso-8859-1-xml-input-in-go and this GitHub issue: https://github.com/golang/go/issues/8937. Hopefully they help :)
I personally have dropped using a nginx or apache in front of my Go apps. Most of the time the only items I want cached are third party libraries stored in my bower_components. My customers hate being told to clear their cache for an update.
I missed that! Thank you!
I don't think anyone else noticed, let's just pretend I didn't say anything. . .
I skimmed the implementation, seems still at a very early stage. Have not found any code for building the graph. Maybe this is intended for only serving an existing tf graph?
Nice. Let us know if you have any issues. We've got a good number of bug fixes in the dev branch that should land in a new release soon :)
Where would the `$WORK` path/dir usually be? 
Nah bro, I've had too many issues where non-go developers get confused by using the term "go". It removes a lot of comprehension issues for people who aren't as familiar with the language. 
cool :) alternative ( but only for PostgreSQL ): https://github.com/lukasmartinelli/pgclimb 
Good idea, in fact, thats my sticking point, too :) I would appreciate it (and even pay for it)
It seems to point just to my `/tmp/` directory. I'll check the permissions on that folder. 
Well, it appears I have some competition over what is the best cli ledger app written in Go. https://github.com/howeyc/ledger 
As the original author of the XLSX library in use, I'm slightly excited to see this ;-)
Also using the XLSX library *yay*! :-)
This is what I had written up but I couldn't replicate the problem https://gist.github.com/sheenobu/49af43347a07eb8519f8dc9d6070f396
Oh, awesome. You've got a lot of export options there too. Glad you shared the link because I'm going to make some use of it :)
:) I've just dug into this and have been enjoying your lib so far. I do have some questions about how to set the type to Numeric or some of the other values. But, I need to just toy around with it a bit more at this point.
Great I'm not always the fastest to respond (day job, kids, animals all come first I'm afraid), but there are a fair few contributors who are active and willing to help.
Oh, I completely understand as I'm in the same boat. 
The Go Workbench: https://docs.google.com/presentation/d/1mUIX3btCiGPguqJOE4h9HDoOW3VyhU2-tzXufz9PqQ0/mobilepresent?slide=id.p
Gaas generics as a plugin
Do you plan to release binaries? (To solve the chicken-and-egg problem)
 I just commented on your [announcement](https://www.reddit.com/r/golang/comments/53jllz/go_setup_implements_the_go_workbench_idea_as_a/) before I noticed your reply here. 
The documentation is a bit too technical for me. What would be a cool idea to utilize plugins? I think that would help some of us grasp the concept.
I outlined [the original goal I had when I first started wanting plugins years ago](https://www.reddit.com/r/golang/comments/53adu8/initial_plugin_support_has_been_merged/d7rujjk) elsewhere in the thread.
Thanks, I'll consider using this approach! Didn't know about that trick.
Thanks! I will create a release and add some binaries to it!
The advice given below is good. Learning the mechanics of how and why these things work is definitely worthwhile, and sometimes that's all you need. There are also some helper packages for these sorts of things. One of the newer ones turns out to be quite nice: golang.org/x/sync/errgroup. The package docs have a few nice examples. A good article about the package was also just posted: https://www.oreilly.com/learning/run-strikingly-fast-parallel-file-searches-in-go-with-sync-errgroup.
&gt; if you close the channel, they all get notified To clarify, receiving from a closed channel always succeeds with the zero value of whatever type it transmits. Since a `select` case will be executed if a receive or send operation is possible, and receiving from a closed channel is always possible, then those cases will happen. Also, you can check if a channel is closed by assigning to two variables. For example, `v, ok := &lt;-c`. This can be used inside a select case to check whether a channel was closed or actually sent to. Something else to keep in mind: If multiple `select` cases are possible then one will be chosen pseudo-randomly.
Beego is bad. There are better tools you can group up yourself instead of being forced to use their bad tools. Instead of using beego, I recommend you just scour through https://github.com/avelino/awesome-go and choose the best stuff.
Like /u/DeedleFake said, a closed channel always acts "readable", so the select { case &lt;-cancel: return default: } construct will always return if run anytime after `quit` is closed. 
I enjoyed the article, sync.ErrGroup looks really handy. I think the example could be made a bit more interesting with a slight tweak to always print out the list of matches it found (and indicating the time limit was exceeded if that was the case) vs the current behavior of either time limit exceeded or the set of found files. Much &lt;3 for Gophercon and GoTime.
Sorry about that Try this: http://nescat.co
You should really, really just use [x/sync/errgroup.ErrGroup](https://godoc.org/golang.org/x/sync/errgroup). It is literally made for this and fumbling around with the channels yourself has some subtleties to it. Plus, the use of context will make your stuff compatible with the larger go ecosystem.
Thanks. I wonder why Go doesn't have `closed(chan) bool` func the check it.
Thanks, that's exactly what I need.
I took a Comparative Programming Languages Course (CMPT 383) in SFU just when Go first hit 1.0. The course mostly concentrated on Haskell and Prolog, after which Go felt very easy to learn. I think it was only mentioned at a high level in class with many other languages where a student would chose 2 languages to do homework on. Anyway, all I used was tour.golang.org and the docs. I don't think any additional resource is needed, at least for someone who already written multi-thread code.
I'd agree with that. It was such a headache on the first day but now I think it's awesome and I like it more than few other libraries I tried. Just in case anyone is reading this, there are short tutorial videos on beego, revel, gin, gorm and some other go topics on pluralsights (about 3 hour each): https://www.pluralsight.com/authors/mike-vansickle
thanks! I'll keep this in mind.
For those interested: http://www.swig.org/Doc3.0/Go.html
I was going to say "because SWIG is a pain to work with", but then I saw that this project uses a horrifying combination of YAML and regexp...
It's about a restful web api. The intent is deploy and care it as a microservice. Thank you so much for the tips! I was trying to work in a git model like master-only but I see your point and it would be safer to work with a develop branch. 
Honest question... So for someone that is experienced with SWIG, does this solution look to be more or less complex to use? I don't have any SWIG experience to judge. 
SWIG has many downsides. It can generate redundant code, the generated code is impossible to read and especially edit or complete with custom helpers. It lacks of fine tuning, some things like name conversions and pointer rules are impossible to guess for machine. Rules in YAML that people in comments called "a horrifying combination of YAML and regexp" are the main engine of the project that makes all the difference between cgogen and SWIG. It allows user to fine tune the bindings so naming will be as much idiomatic as possible, all pointers will be interpreted correctly. Moreover, you're free to submit an empty manifest just with list of headers and the package name, cgogen will fallback to defaults. Cgogen may act as SWIG, SWIG can't. &gt; For those interested: http://www.swig.org/Doc3.0/Go.html This is one of the links I checked many times, that are more confusing than helping. I saw no project in public made with Go+SWIG, I had no success of running SWIG myself with any serious codebase (I tried to compare a couple of things). SWIG does not have manual nor design documentation, for example, how situations of [][]string are handled, how Go 1.6 strict memory rules affected the memory unpacking flow and so on. And why so much about C++ when there is enough problems with plain old C. I really want to find a person who used SWIG and Go for real, to have a discussion so I can figure out the key differences. As for me, these tools are completely different.
I'll give this comment a +1. The net/http package is already powerful, most things that go webframeworks provide are merely fancied up if-statements.
You're free to avoid writing configuration, you're free to write it without regular expressions. The configs you see are made by an expert to show the power and flexibility of the tooling. After all, if somebody thinks that writing 30 lines of YAML "preferences" that allow machine do the rest is worse than writing thousands of lines of binding code by hand, then this guy seems to be new to bindings. 
I want to know that too, thanks.
You probably shouldn't use it, as it's ugly. One effect of it is on variable scope: https://play.golang.org/p/KVoSQ8oc3n So, in theory, you use this to keep your "namespace" in a function clean. But if it's large enough to need that, you probably should refactor that function anyway. One thing I *could* imagine this being useful for, is to simplify recursive descent code generators. By generating a new block as part of a larger function (instead of simply inlining it), you can declare new variables without worrying about name clashes.
Wtf is a micro check?
Read the godoc. Neat. :) 
Probably a lot of people going to use this via copy 'n pasting to avoid tight coupling
This is so great. Coming form a person who has built a game framework and other than opengl did most of the bindings themselves (vorbis included! That was exciting to just see that) This will be a great relief. Not just because I can do it myself but also because other people will do other libs. Getting a Go package right now to process different types of audio is pretty impossible. I have wav, vorbis, and flac working but only wav supports streaming because I don't know enough about vorbis or flac to be able to read a single frame at a time. Anyways this turned into a rant. Awesome work!
why the hell do you need Negative, Positive, Null ?!
I updated the OP again with the strace output of the go get -v command. 
Can't play on mobile. Can you make the controller work from the browser?
Indeed. &gt; In Go embedded structs cannot access the embedding struct so I had to create a struct for the base class, and an interface representing the methods implemented in the subclasses, then store that interface in the base struct. Then I created a struct for each of the subclasses embedding the base struct, and an interface representing the public interface of the whole thing. Plus all the wrapper methods required to implement the interfaces. Constructing your own attempt at a class hierarchy = terrible Go code smell.
Cool! Is there any way to specify that a parameter should be used as the receiver? For example, if it's the first parameter and the function name matches up with the type name (or something like that).
I saw the PR to get this into net/http and really hope that happens, but figured it is always worth checking out other alternatives. Thanks for linking this!
That makes sense.
Please read Ben Johnson's [Structuring Applications in Go]( https://medium.com/@benbjohnson/structuring-applications-in-go-3b04be4ff091) and the more recent [Standard Package Layout](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1).
Like always, I'm happy to answer questions in the comments here :)
Googling with "site:edu" or similar for other countries, and "golang" is useful. I just added Brown's CS138 found like that.
my point is : why are there C librairies linked to ANY GO program ? GO program can't compile without C ? I thougth GO was more "independant".
Could you post the reference you believe indicates that Go would always have C in it?
when I compile the small code above : # go build main.go # file main # main: ELF 64-bit LSB executable, x86-64, version 1 (FreeBSD), statically linked, not stripped
I am surely not the best qualified person to answer this, but I believe ELF is merely a binary file format for Unix-like systems that are running on x86, and it could have been compiled from any language. You might be able to find a disassembler to create C-code from that binary, but that doesn't mean it started in C. Go itself is all Go (both the runtime and compiler) except for some assembler, of course. The Go compiler WAS based off of an old C compiler, so it makes sense that it would use a similar binary format. What I don't know is if ALL native compiled language would use that format or if Go uses it merely because it's designed from the code base of a C compiler. It might also help to inter-operate between Go and C code when using GCCGO instead of the Go compiler, but I'm not an expert in that area, and GCCGO is different than Go in a few important ways.
Great article. It's always nice to see new or better ways to do things in go.
Thanks!
There used to be a website similar to this that had hundreds of ROMs. I used to waste so much time in class playing Super Mario. Anyway, good work! Keep it up :)
Two questions... Why the need to create a bin and pkg location upfront? And, this would break for a shell like tcsh, right? (export vs setenv) 
Thought the same.
this is terrific!
On most systems, you are likely to find that all program binaries are using the same executable format. For some systems, there's not even a choice: they only support a single format in the first place. In Linux for example, you can enable the old a.out format, that was used on Linux systems before ELF became common there. Most kernels today have it disabled, so you'd have to build your own kernel to enabe that format. It has nothing to do with the language a program was written in but all with what is supported by your operating system.
Only way to make sure is to read sources. https://golang.org/src/net/sock_stub.go and others
The closest thing online is probably [Effective Go](https://golang.org/doc/effective_go.html).
I'm not sure what i dislike more, the clickbait title of the submission or the tone of this reply.
That flair! /jealous :D What caused you to decide to work with o'reilly for the blog &amp; the training course you are doing? And would you mind sharing any details about your experience with them? You can get in touch with me via my username [at] gmail.com if you don't mind having a more in-depth conversation about it :D
Thank you! What's the advantage of putting the command in a subdirectory? Would the one-line install still work?
&gt; I don't have tcsh to test it, but I'd love to support it. :) I need to know where I should look for its profile/rc file, and if it is enough to setenv instead of export. csh/tcsh: http://www.tcsh.org/tcsh.html/Startup_and_shutdown.html And ya, setenv is the command instead of export: setenv FOO bar
Also multiplayer doesn't work on firefox yet.
This is tangential to your question, but I don't think the "address already in use, increment port by 1 and try again." is appropriate if a user has specified a listen port. If they have, and it is busy, the correct behavior is to report the error to the user. If the software wants to listen on a dynamic port, then use port 0, which will cause the OS to bind to a random free port and then you can use the Listener's Addr() method to find what port you are listening on.
Not an official one, but the community stepped up and provided [this helpful reference](https://github.com/luciotato/golang-notes/blob/master/OOP.md)
I'm not sure why it matters that JSON is part of the stdlib. JSON is a commonly used standard, letsencrypt is an initiative. I don't need Github, Twitter and Reddit libraries in the stdlib either. edit; i stand corrected.
At #12 there's a comment I don't understand that ends with `(logger, db =))`
/u/seriouslulz, I am curious: were you already familiar with this code here, or did you go fishing for uses?
At #13 you say, &gt; ...context may be used to store specific values: &gt; ... &gt; - user ip &gt; ... but [http.Request.RemoteAddr](https://golang.org/pkg/net/http/#Request) already contains this info.
At [#20](http://go-talks.appspot.com/github.com/dkondratovych/golang-ua-meetup/go-context/ctx.slide#20) you call a logger interface "`ILogger`". Don't use this convention :-) and just call it "`Logger`".
Same with `IDatabase` at #25
Good collection, thx! 
I have made some changes based on these comments. https://github.com/alioygur/is/releases
1... Well, what does rails console do. Can't really compare otherwise. 2. Those are good choices. Gorm is pretty easy and gin is damn flexible and fast. 3. Depends. I can knock out an app with about 10 API endpoint in a day... Or it might have 3 ... It depends on the logic.
1. I can basically do some real live programming with the current codebase , like creating users, doing math, calling functions etc. 2. Thanks! 3. yeah,maybe using number of endpoint is irrelevant.
1 &amp; 3 . so the term is REPL. I see. my first real programming job is RoR developer, hope I'm not pampered in this regard. wait. so if I want to do some edit on staging/production database I need to write the piece of code and run it while connecting to said database? might need some adjustment to that mindset. thanks for confirming my suspicion about this. 2. Heard that a lot. Yeah my previous coworkers that uses Go now write their SQL query manually. I ought to try that someday. 
The main use-case for context (IMHO) is still cancellation. Storing data in it is more of a side-thing.
The pattern I like for context-keys is this one: https://play.golang.org/p/4XVyVuIcml * The key type is still private. Though there isn't even a need for that (as `new` creates unique addresses, so the values being private is all that's needed) * You can create many keys, without needing many types, just in a single var declaration, so it's reasonably simple to use * Key equality is only a two-word compare. If you put a non-pointer into an interface, you always need to do one additional pointer dereference, as even if the values are equal, the pointers stored in the interface will, in general, not be. Pointers, however, will be stored directly in the interface so equality is just comparing the stored pointer. However, I'm also aware that that's completely over engineered and doing [this](https://play.golang.org/p/95KxZxlNjz) is simpler and the difference won't matter :)
Gin and Gorm have good reputations, though I personally favor writing my SQL over having an orm make choices for me. I'm fairly new to Go myself, and I also skipped Gin, favoring instead the stuff already in the standard library for my first website and api. Those are mere opinions. They are both high quality projects, and the important thing is you being comfortable as quickly as reasonable so you can get to enjoying code. My commentary of Ruby would be limited to comparing to my experience in Python, but I believe productivity would be similar between Ruby and Python so... Go takes slightly longer for me to write but far less time to debug and test. You might have an additional initial slowdown if you haven't seen pointers before. They're conceptually quite simple but in practice, everyone seems to get confused at first. Go prefers to be slightly more verbose to avoid weird hidden magic, so you might type a small bit more, but your code will be easier to understand once you know the language syntax. I think it'll be pleasant... As far as a REPL goes, I've seen a project (maybe multiple) but haven't looked. You don't need a REPL to play with as much once you have a language with type safety. You can still step debug, print to the console, etc, so there are plenty of options still.
All the arguments you wrote above are valid indeed. SWIG is horrible. I've not tried cgogen yet but it sounds very nice. The reason for my previous reply is for the comment of yours: "I saw no project in public made with Go+SWIG, I had no success of running SWIG myself with any serious codebase" SWIG generated Go code works (somehow), but you just don't feel confident about your code.
The only problems I encountered was an out-of-sync readme and also, the tests in the `models` package ask for a password out of the blue, which I suspected it could be the database password, but after typing it, nothing happens. I haven't looked at it for a long time, I'm just skipping this for now, but I'll get back with an issue (and evidence) on Github after we walk a little bit more with it. Nonetheless, thank you! This is a pretty cool project :D
It doesn't scale beyond seven servers so what's the point?
A lot of people would be agains putting logger and db into context, so to do this this is kind of "breaking the rules".
I'd use (fake) exported go enums with non exported type instead. If something is called Session it is easier to refer to it that way instead of allocating memory just for a key. type secret int8 const ( _ secret = iota Session SomeValue SomethingElse ) 
That's neat! Sounds like my plans for the weekend are now defined :) 
Well, as I mentioned (the "this" link) that's a reasonable possibility. It does, however, occur allocation on each use: https://play.golang.org/p/CdYALEYX7F As you see, the pointer stored in the interface is different each time you store `Session` in an `interface{}`. The reason for that is, that to store a value in an interface, you need to allocate space and then store a pointer to it. You can't just store a pointer to the value itself, as the value might change, leading the interface to change too: https://play.golang.org/p/FXeWTTPT7O So, doing this is worse from an allocation and performance perspective: Using a `*int8` instead of an `int8` means you only need to allocate once, at startup and then can just reuse that location everywhere *and* the comparison becomes cheaper, as you don't need to dereference the pointer at all. Using a `int8` means you need to allocate *on each call* to `context.WithValue` or `Context.Value` and the actual lookup requires going to a separate memory location (having worse caching behavior). (strictly speaking, btw, you could get away without allocation, if you'd use unsafe. As the pointers are never dereferenced, they could get away with storing invalid values in them, as long as all of them are distinct) interfaces are, when you get down to the meat of it and care about allocations actually pretty subtle.
no problem. guess ill have to wait until december
Great. Hook up with us, we'll sort out those issues. The tests in the model package basically shell out to createdb/dropdb/psql/pg_dump or mysql. It does this by creating a temporary PGPASS or MySQL Defaults file based on what's in your sqlboiler config file. If you have not specified your password in the configuration file, you'll encounter issues. We just released v2.0.1 which has a myriad of bug fixes. If you could report your issues soon so we could at least fix them for others interested in using it that would be great, thanks!
I guess that's a matter of opinion, I would point out that one of the most popular and probably one of the most widely used, gin, works this way. Custom ResponseWriters are not impossible, just different. I don't see how authentication middleware is impossible if used like in gin. But thats not important. Point is I don't think creating a new Request object just to set a context value is the best approach, why not just allow updating of the Context field?
1. It does not officially. There are some community driven REPLs, but not sure where they stand. Interestingly enough... I created a *rails c like* side car utility for use in some projects. Feel free to check it out. You need to write some glue to "teach" it how to load objects from your datastores, but it's fairly simple and once you've done it, you can simply boot into the console and load and interact with objects. The current version doesn't allow you to set values, but you can invoke functions and drill down into objects any level deep. PRs accepted for any missing features! https://github.com/StabbyCutyou/instructor 2. Gin is not bad. Gorm is so so. It has some odd quirks. I tend to stick to Gorilla and SQLX personally. 3. You're going to be missing **a lot** of things from ruby and rails in go. A real lot. Ruby and Rails basically give you an unlimited toolbox of techniques and tricks to make things easy. Go gives you at most 1 way of doing things, and not always with convenience in mind (as in, the type of things a rails dev would find convenient). Was a Ruby engineer for 4 years, then moved to Go. Some folks might disagree with me.
It sounds like you may be comparing a framework (Rails) with a language (Go), just something to be aware of when it seems things are missing. 1) Since Go is a compiled language it doesn't have anything like the Rails console. That said if your team is using it heavily in production that might be a sign that an admin panel would be a good addition for you guys, or maybe some tool that expose the needed operations, etc. 2) Those are fine choices, personally I like to stick with what is in the stdlib as much as possible. 3) One of the biggest hits coming from Rails is going to be the ORM. I haven't found anything quite as magical as ActiveRecord for Go, so you will certainly miss that at first. "The Go Way" includes being more explicit so you are going to feel less productive at first due to that. In the long run when you have to read old code and refactor some of those 140 end points, having a type system and some of the go tools (guru, gorename) will be very helpful and you could gain some productivity here you wouldn't with Rails. It's a small example but worth keeping in mind. I have found the Go community to be very welcoming so don't hesitate to ask questions here or elsewhere. Good luck!
&gt; No the main use case is cleaning up global states for request scoped variables, that's why it was created at first place. Unless you were the one that created it (I don't think you are), I'm going to call [citation needed] on this one. Also note, that I added an "IMHO". That was intentional. Storing data in a context is for many reasons suboptimal. I know how gorilla/~~session~~context works, and, quite frankly, it is superior to context.Context in a lot of ways. For example, a lookup in a gorilla-~~session~~context is O(1), whereas a lookup in a context is O(n) (where `n` is the total number of values stored in the context). gorilla-~~sessions~~contexts also have better locality. And you can iterate over it (it's theoretically possible to implement that in context, but it's much harder), which is interesting when it comes to serializing it to be sent over the network. I am not saying "don't store stuff in a Context". But you should understand the tradeoffs made in it and you definitely shouldn't overdo it. For example, if you where to store a request Id in a context and use that id in logs (or directly use a request-local logger), you are going to have a bad time with a full context, as lookup in a context means linear search in a linked list, which is notoriously slow. So your logging has the potential to significantly slow down your server. That's really unnecessary too. The stack behavior that a context gives you, which is good for cancellation and things, doesn't make sense for a lot of things that you'd want to store in a context. For example, the above request id will be set once, be valid over the request, and then get invalidated once the handler that created it returns. I.e. you don't need a stack of request id's there will always be at most one at any point in time. Storing this kind of data in one map is not only faster, it also makes more sense. [edit] as a further datapoint, note that grpc actually doesn't store request-scoped stuff directly in a context, but puts it into maps: https://godoc.org/google.golang.org/grpc#Header
Thanks! That post is what made me try the code in question, but it's still not clear. The examples in the post are starting goroutines outside of the for loop. I understand that passing the value by reference means all the goroutines will see the same value, but my code should be creating goroutines within the for loop and I expect one of them to run before the main goroutine completes the for loop.
1. I'm not comparing per se, I just want to know. But it's nice to know about compiled languages not having consoles. 2. Thanks for that, I will only consider super major defect for not using it TBH. 3. Yeah, feeling it now. might need to force through it. Nice to know that, I will generally google first for technicalities, and maybe ask philosophy related thingy here.
I understand. The "more clearer lines of code with less magic" is starting to make sense to me. Maybe my time dawdling in console will be better served to create better script/less errorprone code.
that's what I need. (TBH I need so much more. I don't even understand yet about middleware,deployment etc). thanks for your book recommendation.
1 you dont need a repl 2 you dont need those frame works (why to rails people like frameworks so much?) 3 it really depends how complicated your endpoint logic is.
Now you're getting it.
cheers bro!
https://go-traps.appspot.com/#rendezvous-iteration
Ah, good point.
`i` in your code is shared by all goroutines. If you want to capture the value of `i` in each iteration, just pass it in as an argument in your closure. go func(i int) { // safe to use i }(i) 
I'll be around for the next few hours and available to respond to comments.
Cool, I'll keep an eye on it.
&gt; An interesting property of Go‚Äôs **built in data structures** (emphasis mine)
He's talking data structures... I don't think a string or int counts as a data structure. They also can't be nil. I do really love that len and range work correctly on nil slices and maps. Not having the extra dumb nil check is just very nice.... same goes for strings that can't be nil. Can't tell you how annoying it is to check for nil or empty, when you really don't care. len(something) == 0 is so much nicer. It's a little unfortunate that range over a nil channel blocks forever, but that stays consistent with nil channels blocking on receive, which is needed for select to work correctly.
I think you're right. I ran it locally and it's acting more like how I was expecting (sample output from local: 2 5 4 5 13 13 13 14 15 16 17 17 17 19 20 20 20 20 20 20). Thank you!
That's great to hear. I'll definitely try this for tools where I need some interactivity.
[deleted] ^^^^^^^^^^^^^^^^0.3094 &gt; [What is this?](https://pastebin.com/64GuVi2F/28603)
On #5: "more easily and clear" should be either "easier and clearer" or "more easy and clear".
Cool!
Yep, I'm glad that you had success! I've read through repos and made my own conclusions ‚Äî it seems that SWIG is more useful for project authors rather than the users, i.e. for not those who consume bindings but who make them.
Thanks :) When I was newer, it was confusing to reason about what channels or maps did when they were nil. It's easy to remember if you think "read operations for nil are the same as empty".
(1) What are you doing with your Rails console? If you just use it to explore data, you could theoretically use something like [pgAdmin](https://www.pgadmin.org/) to achieve similar results. You could also keep the rails app, but only keep the models up to date. I don't mean keep EVERYTHING in them updated, but simply keep their associations (belongs_to, has_many, etc) up to date and use them to browse data. This would allow you to browse data with the rails console, but I wouldn't suggest doing live edits this way even if your app is 100% Rails. You are bound to make mistakes in prod at some point, and if you aren't keeping the Rails app it will be a massive headache to keep anything but the associations updated between the two. If you need to make writes/changes to data, can you share more about your use case? (2) I don't see any immediate issues with those choices, but you might find other options you like more as you build out your app. I would check out [goa](https://goa.design/) and writing your own code from scratch using things like [gorilla/mux](https://github.com/gorilla/mux) when that time comes. (3) There is going to be a ramp up period where you have to build a lot of the things rails gives you. You will have to figure out how to make your authentication work. You will need to learn how to add new routes, how to create new controllers or models, etc. Once you get the basics down and understand what you are doing I find Go to be just as fast to develop in, and it being a typed and compiled language reduces the total number of tests you need to write (imo).
Seconding using tools like MySQL Workbench or pgAdmin instead of messing around in a Rails console. I'm not a fan of using ORMs in Go at all, so using SQL directly in both my code and external tooling just makes sense.
My position actually is, that nil shouldn't even exist for those types (pretty much for that reason). But that's another story :)
One piece of advice - find out which end points are actually the slowest or in need of rewriting. Not just the "most used" ones. Read up on benchmarking your services to find where the time is spent, and which ones Go will bring the most benefit to. Depending on the workload, you might not see a ton of difference between the old and the new if, for example, they're both extremely I/O bound and not bound by something like CPU. That said, you'll likely see some improvement moving it out of Ruby and into Go (or really, most other languages). Also (and i'm inviting lots of people to jump in and tell me how wrong I am), Ruby and Go really support a similar concurrency style. The difference is that Go controls a pool of OS-level threads for you, and you place your trust in it to handle coordinating all of your go routines in that thread pool. With ruby, you'd need to manage the pool yourself, and you don't have the go routine abstraction (which is a good or bad thing, depending on what you're trying to do). But it's still the same (conceptual) approach - place work out of the main thread, and into another. Actually, since Go doesn't support forking, you might make the argument Ruby is actually a bit more flexible with concurrency options (but forking is typically a last resort approach - or atleast, it should be) And before anyone tries to point out "But go has channels!", Channels are just FIFO queues with *a lot* of opining baked into them. Ruby has the exact same construct (Queue), but it's much less particular about how you use it (from what I remember, anyways). Channels need to be used in a very specific manner or else you run into deadlocks or panics. TL;DR; Don't just go rewriting everything in Go because it seems cool or is a trendy thing to do. Pick your targets smartly by benchmarking where the bottlenecks are, and make a priority target list of things that get you the most bang (resources reclaimed) for your buck (time invested).
parse.com (now defunct) spend a full year rewriting their RAILS app to Go (\*). When I see the open source version of Parse on github it doesn't strike me as being a very large application. So be prepared to spend a significant time to rewrite your app. RAILS does subtle things and Go default server doesn't behave the same way. If you relied too much on RAILS custom behavior then good luck ... (\*) : which led me to think it wasn't the right thing to do and didn't solve their problems while sucking all their time into the rewrite, they didn't develop new features. Sometimes rewrites ARE harmful.
Upon reading that code, I can only assume that you are being sarcastic.
Very excited for the future development of this. Hoping this will grow into a very good and community supported framework
Can't wait for a linux version. :D
Is this something people could integrate into a plug-in for whatever IDE one is using? Like vim-go, etc?
Thanks, I hope so too!
Seems nice. Could use some tests for sure.
Updated in presentation, thanks for advice.
No, I just pointed bad example. And haven't read the request enough https://golang.org/src/net/net.go?s=12788:13562#L390 - is the source of OpError struct and it's methods. https://golang.org/src/net/tcpsock.go - is actual implementation, there's nothing platform-dependent here, but may be underlying it. And this I can't check, so someone needs to go and grep source.
Isn't the first example a more obscure way of doing `defer f.Close()`?
Cool project, I was looking for something like this for a project I have in mind. We'll try it as soon as linux is supported :)
What is the size of executable for hello world?
The executable itself is 2.2M, but it links to a dynamic library, and the complete standalone app bundle is 95M. (It has to link to a dylib because linking statically to the entire chromium codebase takes hours on a typical OSX machine.)
Reddit has a "save" feature.
I don't think runtime.LockOSThread could go in gallium.init since it only guarantees that the current goroutine will stay on the current thread, but there is no guarantee that the goroutine that runs init is the same one that runs main (since other init functions might create goroutines). The reason runtime.LockOSThread can't go at the top of gallium.Loop is that by this time the main function may already have created goroutines, and hence may have been swapped onto a different thread. It would work if the very first statement in main was always gallium.Loop, but that seems too onerous of a requirement to me.
[deleted] ^^^^^^^^^^^^^^^^0.2425 &gt; [What is this?](https://pastebin.com/64GuVi2F/60701)
You and me both, I guess... Ohhhh the waaaaiiiit. 
&gt; I think it would be great to be able to use OpenGL and have a window/controller/sound library without having to use cgo. Not sure what you mean by "use CGo" here. If you mean that you don't want to deal with CGo things yourself, the OpenGL bindings are autogenerated such that you don't need to deal with CGo: http://github.com/go-gl/ If you mean "having C dependencies is unacceptable", then you could write your own OpenGL implementation with pure Go. But it's not advisable (simply because you're taking on the full maintenance cost of OpenGL).
I'm very excited to give this a try in Linux. I've got a perfect project for it.
The reason is because the main loop finishes before there is time for the other goroutines to be scheduled (or if single thread the main thread never gives time to them until after the loop) Thus by the time the goroutines are run the value i is set to the final value in the loop because the loop already finished but the closure still has a reference to the value
I like the name
nice info about parse. I think I will prioritize the most important endpoint that need to be Go-fied
Yeah, Reddit has a "reply" feature
that's called an "upvote".
"Outsource" your Poem's Store and Load methods to a separate struct you load by default.
[You were close.](https://play.golang.org/p/NyJsN3Pt0n) Just need to call Storage.{Store,Load}. Infact, you don't need to even define Store/Load() for poem, since you're embedding the type Storage which promotes the exported fields/methods to Poem, [see here](https://play.golang.org/p/Ac4BremLne).
No. Why?
[deleted] ^^^^^^^^^^^^^^^^0.5854 &gt; [What is this?](https://pastebin.com/64GuVi2F/89095)
excuse me?
wonderful
No. Why?
[deleted] ^^^^^^^^^^^^^^^^0.5129 &gt; [What is this?](https://pastebin.com/64GuVi2F/80636)
Interesting that the bounds check eliminator is still pretty primitive. It should be able to reorder statements to make bounds checks at once instead of repeatedly. 
Is this about writing if err != nil a few hundred times an hour?
How large are the compiled binaries?
Nope. and you know very well that's not what I'm talking about.
`Poem` exposes `Store` and `Load` twice: * As methods of `Poem` itself * As methods of field `Poem.Storage` In this case, the selector expression poetry.Store evaluates to the "method at the shallowest depth" in Poem, according to the [Language Reference](https://golang.org/ref/spec#Selectors). The solutions have already been posted in other comments: Either drop the Poem methods entirely, as /u/knotdjb demonstrated, or outsource the Poem methods to another struct, as /u/mixedCase suggested.
Cool project! I am looking forward giving the windows Version a try.
I've decided that I'm going to completely re-write `suggest` and actually turn it into a fast useable application, so for now I'll leave this up on Github, but it will be replaced when it is ready :)
While your code requires just small fixes I think it has issues: a) interfaces do not have default methods, so you cannot override them and b) doing "normal" OOP is hurtful in Go. 
And that's how would you build an app? Right now, I see that the demo launches a window with a URL. That URL could be a local file, so then the only way to ever call back to go would be via Javascript, isn't it? Or is your idea to make it possible to manipulate the DOM (and receive events) directly from go?
I'm guessing it's default for now since they are the only one (at least that I know of). I'm sure there will be more consts later and perhaps there won't be a default when that happens. But still I'm leaning towards agreeing with your last statement. I think ACME should be in the standard lib, it's an ietf standard. I also like the idea that Golang has official support for a wide array of protocols and standards, it sets a high bar for 3rd party libs. 
Is there Web Components (Polymer i.e.) support?
Attempting to keep a similar style name and do the "go naming thing" where you start with "go" or at least "g": Gotron, Goson, Gozon, Gotrino, Gork, Gotrogen, Gorillium, Godium, Gucleus, Gocleus
`golang.org/x/exp/shiny` hides `runtime.LockOSThread` inside its `driver.Main` func. user code looks like: https://github.com/golang/exp/blob/master/shiny/example/basic/main.go 
speaking about `exp/shiny`, it would be quite "fun" to have a `exp/shiny/driver` implementation with `gallium` :) the interfaces look vaguely the same: https://godoc.org/golang.org/x/exp/shiny/screen
electron is a lepton. muon, tau and neutrino are other leptons. =&gt; neutrigo ?
Are you serious? Hope that day never comes &gt;Under the hood, the webview is running Chromium. Such a huge overhead. IMHO gui applications running on host os must be as native as possible. For everything else we have web applications. 
If resp != nil you should close the body You could write a very short test to figure out what the outcome will be. rw.WriteHeader(303) rw.Header().Set("location", "/") Should keep redirecting. Then see whether resp is nil or not when you call it with a client
Germanium.
I think this is [already considered a best practice](https://blog.golang.org/error-handling-and-go) for errors as it is what the standard library uses. Dave Cheney has some different and interesting ideas but I am not sold yet.
"he" = blackbaronstux. I was explaining why I think he said "Please leave". I run containerized Go, but only for deployment.
Couple of things, the context package favors latest added values so: Worst case: `O(n)`, best case: `O(1)` N being the number of values in that context chain, could be quite small locally. Gorrilla's version uses a global map of maps (last time I checked) which is worst case `O(N log N)` n being the number of current requests, then a second lookup of values in the key value map, which again can be `O(N log N)`. Also you have to think about the mutex that is on that double map, which is global and could be a source of contention in high demand. I don't know which is best, but the built in context package has some advantages, and I believe the situation is nuanced then you might expect. 
Please don't.
Yeah, I double checked, you are correct that its insertion is probably going to be O(1), as its a map based on a pointer. `O(n log n)` is likely when you are using a map against a string value, based on this answer. http://stackoverflow.com/questions/29677670/what-is-the-big-o-performance-of-maps-in-golang The other thing is if you are using gorilla mux, is that it clears the request from the global map when the request is completed (typical usage), that may not be what you want if you have dangling go routines that have not reached their cancellation point yet and expect context data to be present, which can easily be the source of all kinds of fun bugs. I am not entirely correcting you, just adding stuff that I have noticed, sorry if I came off that way.
I wouldn't look for this to happen. Your proposal is syntax sugar for a very special case. If `DoThing()` didn't take a `MyInterface` this wouldn't work. The compiler would need to know that the types in the type switch are all slices of things that implement `MyInterface` *and* that the thing in the body of the loop (`DoThing()`) takes a `MyInterface`.
Props for auto-indent. I would also love vim keybindings. These poor ergonomics are what keep me from using the playground as more than a copy/paste dump.
Good walkthrough particularly for folks not versed in other printf/scanf implementations. One comment, hdr := Header(‚ÄúGO WALKTHROUGH‚Äù) fmt.Printf(‚Äú%2.3s\n‚Äù, hdr) You have smart quotes here, since you don't have them elsewhere this looks like an oversight.
Seems like only a small departure from Go itself, unlike Oden which actually tries to move the needle with some fresh thinking....
Why?
On the other hand, Oden is implemented in Haskell and is having a hard time attracting developers. Maybe someone should take the best of both worlds...
12 is the Form Feed character, on some terminals (apparently including this one) it clears the screen.
The preceding characters (before 13) are non-printing characters. Additionally, at least in my experience, *.Println() doesn't print anything when the contents are not printable. I can't find anything to support this in the documentation, however. My experience (and frustration) trying to debug with Println() tells me that this is the case.
But doesn't it already have to check all of those things for the version where I implement each case separately? The sugar is simply unrolling the comma separated list into individual cases. Which, honestly, I would've thought was already what the compiler did. I'm essentially only asking for the compiler to do my copy/paste job for me.
net/http can do that part just fine by itself. What it doesn't know is when you're done with the response body, and that's why the note is there that you should call Close.
But the doc states &gt; The default HTTP client's Transport does not attempt to reuse HTTP/1.0 or TTP/1.1 TCP connections ("keep-alive") **unless the Body is read to completion** and is closed. ?
Yep. https://play.golang.org/p/u2eoNySz3J
Ah, cool. Thanks for the info.
&gt; The preceding characters (before 13) are non-printing characters. I'm printing `i` and `string(rune(i))`, so I would still expect to see the output for `i` even if `string(rune(i))` isn't printable. The other answers in this thread make more sense: the character `\f` (`12` in decimal) clears the screen on some terminals (apparently this one).
The compiler can only do this sugar under certain circumstances. Namely when it knows that the element type of each slice can implement a specific interface, and that the body of the case statement only does things that are supported by the interface. Given the complexity of that, maybe "sugar" is the wrong word. &gt; But doesn't it already have to check all of those things for the version where I implement each case separately? No. The compiler only needs to know that the body of each case statement is valid for the type specified for the case. It just happens that the element types for all of those cases implement `MyInterface` and that the body of each case statement only does things that `MyInterface` can do. EDIT: Not sure why you were downvoted for this. Here, have an upvote.
From [this](http://havelang.org/post/for_gophers/) &gt; Structs That looks like a bad idea. It makes it either impossible to define methods on non-structs, or it creates inconsistencies in how you define methods. &gt; Generic functions It's somewhat unclear how this is implemented. Does it use naive codegen (that's somewhat suggested)? Or does it wrap everything in `interface{}` (which the section about `when` suggests). &gt; Builtin functions This doesn't mention how overloading is handled (e.g. `make` can take between 1 and 3 parameters). Overall, my verdict is, that this a) has very few actual improvements, most seems to be changes based entirely on preference of the author b) those improvements are better suited to be addressed in go 2 and c) as a result of a, this ends up giving up a lot of the minimalism and orthogonal design of go. It seems like a patchwork language. So‚Ä¶ I guess, whatever floats your boat. I'll not change over and I'd predict that not a lot of people are, but that's fine for a hobby project.
Oh right, https://github.com/golang/go/issues/5645 . You're right, the way net/http is written right now is to not do any of that for you. "made things impossible", without much clarification. Oh well, future is HTTP/2. I'd avoid `ReadAll`, use something like `_, _ = io.CopyN(ioutil.Discard, resp.Body, 32*1024)` instead. No keepalive is better than accidentally downloading 100GB, or http://robpike.io/ So, to summarize: - Close is needed for correctness - draining the body enables keepalive 
Seconding the vim keybindings :)
Please don't be in a hurry to rename it. Gallium is not bad, IMO. There are many things named the same but in different domains, so it is ok.
That's not the language name though.
What happens if you re-run the install command: go install github.com/alexflint/gallium/cmd/gallium-bundle And then retry the gallium-bundle command?
Its based on Chromium... so yes you basically have Chrome in each windows.
nonononononono
Could it be made using only Flex &amp; Bison? I'd ask the author but can't.
/u/wowoc 
Well, we're storing some stuff to a database, and these types hold some metadata about how they get stored. They're otherwise pretty different. The code in question would like to use the metadata of the passed in object, create a new object for storage, and then store it. So DoThing() in my example is what actually does the "read, create, store" part and the DoStuff() is just a helper because we often end up with slices of objects and it would be nice to process them in batches rather than needed for loops every time we want to store or retrieve a big array of data.
The go playground is very, very far from being "a REPL type thing". It's just regular compilation and execution (if in a restricted environment). A REPL is a Read-Eval-Print-Loop. And the eval part just doesn't make a lot of sense in go.
Fair enough -- What I meant is that you could put in some code to see what happens easily without having to create a whole new 'main.go' etc
The extra complexity is knowing how to desugar and handle the cases where the body is illegal for some subset of the types in the `case` statement. This case is probably not sufficiently useful to justify the extra complexity.
"Have is an indentation based language" Nooope. That kills half the benefit of gofmt - fixing indentation. if foo: bar() Did I forget a "pass" or did I forget to indent bar? You can't tell, so you just have to punt. It also prevents fixing up copy and paste: if foo: --paste start-- if tooMuchIndentation(): something() --paste end-- previouslyInsideIf() What would your formatter do here? Did I mean for the last line to be inside the new if, or outside of it? You can't tell, so you have to make an assumption, and it'll be wrong half the time. And that's not to mention all the other benefits of braces, like easy visual indication where blocks start and stop, having anonymous blocks (without if true), etc. Also, requiring methods to be placed inside of structs (or, presumably other named types like `type foo int`) means that for large files, it won't be immediately clear what type a method is for. Halfway down the 1000 line file network.go you have func *String() string: return self.Name() What type is this declared on? There's no way to know. What type is self? Dunno. 
It is if we say so. The prerogative for naming belongs to the audience or people where the symbols have shared meaning for us. In other words, if you say, "No, my name is Dr. Jones Silverstein", and the audience says, "No, you are Prisoner #0031451"...
Havelang will travel?
Looks cool, but why use callbacks instead of channels for OnReady, OnClick ?
If only Oden had such a great intro blog
The thing is this stuff is pretty new and it might be not included in the version that Gallium embeds right now. any comment /u/alexflint?
&gt; I don't see a big chance that you are going to convince people that this is worthwile. While I'm sure you're correct, it *does* seem more correct, in a technical sense, for the compiler to do what I suggest. After all, I feel like the two versions in my OP are provably equal.
&gt; t does seem more correct, in a technical sense, for the compiler to do what I suggest. Hm? There is no correctness at play here. It's, at best, down to personal preference. &gt; After all, I feel like the two versions in my OP are provably equal. That is correct. But it's also correct for a whole slew of other specializations and language features, like implementing generic map/reduce/filter builtins, templated generics, option types and tons of others. But that doesn't mean go is going to be a better language with them.
* you can use a `chan struct{}` instead of `chan bool` for a "signalling" channel, it takes less space. * callbacks are usually not idiomatic Go * your queue is limited to strings * your queue has no way to do error reporting It's also not great for composition in my opinion. For example, I've written systems that act like queues to the outside (with a pending channel) but at regular intervals need to do something else than process the pending messages (like write to a database, send to a TCP socket, etc).
I just committed a change that vendors go-arg into gallium, so if you pull master the issue should be resolved.
Thanks for your feedback. I settled on strings instead of `interface{}` for the message type because passing strings or JSON payloads around is pretty common for my use cases and wanted to avoid extra type casting / checks. I like your idea about adding a timer function for cleanup, logging, and other tasks. It would be a good extra to implement.
Which is exactly what `defer f.Close()` is used for. Also, in your example db and redis already use Open/Close, so if I were to use your library, I would also prefer to use Open/Close for setup and tear-down. 
I agree with /u/Sphax. If you want to avoid a lot of explicit type casting, you could create methods like `queue.InitString()`, `queue.InitInt64()`, etc, where each takes a `func` with the matching job type. `queue.Init()` could be reserved for `interface{}` for use with custom types. I believe that's a fairly common pattern used in languages with statically typing. I also wouldn't mind a built in way of collecting the results of each job.
If you're using `gb`, do you need to use `gb rename` instead? Hint here... https://gist.github.com/tmichel/21d0245582934f6c0d72 Disclaimer : I don't use `gb`.
I'm super late to the party here, but the way larger apps handle this in Go is via code generation. As a point, for databases, I have released this tool -- [github.com/knq/xo](https://github.com/knq/xo) -- which handles a lot of that boilerplate generation for working with conventional SQL databases. You are also able to plug your own templates into xo. In my opinion, the reasons for using an ORM and other types of packages/libraries you see in the Java/PHP/Ruby/etc. world are outdated, and I honestly believe the better approach (and more easily provably correct one) is to generate code for things such as database, authentication, validation, etc. The performance gains are just simply amazing. Basically, a rule-of-thumb with Go is that anywhere you would be doing "dependency injection" (using metadata or some such), then Go you should be doing code generation. Because Go is still relatively young, there are not a lot of tools available (at least not publicly) that handle this for you. That will change in time.
What you fail to understand is that switch s := s.(type) { is a "compile time magic trick", the same way append or make are "compile time magic tricks". Instead of generalization of a behavior, a special case is handled by the compiler (with a switch statement ironically) but you don't have access to that magic behavior yourself. For instance it is impossible for you to implement a function that behaves like append with compile time type safety. This is important to understand that, as Go is full of special cases handled by the compiler, there is no runtime behavior like other switch statements where cases are evaluated at runtime. Whether it's a good thing or not doesn't matter, it isn't going to change, you just have to accept it. 
I don't use `gb` so I do not know the answer but I'd suggest you try to work with the standard workspace first and move later to `gb` when you have more experience and only if you have problems with the standard way. Are you having any specific problems that `gb` solves? Always remember that `gb` is an _exploration_ of what could be done if we abandoned the standard go tooling.
While this totally works and is the simplest approach, it breaks the zero value. If you ever forget to set the storage field, you'll crash at runtime. If you make a NewPoem() function that does this setup for you and make sure you use it everywhere, that's plenty good enough in practice, but you still have an unusable zero-value. To make your class totally idiot proof, the [go proverbs](https://go-proverbs.github.io/) recommend we make the zero value useful. [My comment above](https://www.reddit.com/r/golang/comments/53w7zw/how_can_i_override_the_default_methods_of_an/d7ybhpt) shows how to do that, but honestly, making every zero-value useful is probably overkill. If you aren't exposing this class in a public api, then totally removing the functions from your Poem class as suggested here by /u/knotdjb paired with a good NewPoem function that injects the default implementation will do the trick. [playground](https://play.golang.org/p/3hMG2ffn6d)
Does he mention Go at any point during the video? And if so, then when?
But if it saves prefs (such as the dark style) then maybe it could have a syntax highlighting toggle so that those opposed to it can leave it off? 
0-32 are all non-printing characters. Were your explanation true, it would have started at 33, not at 13.
I don't get why you'd brag about that being one file. That's a lot of types and very little documentation. I am unfamiliar with wolfram's tech beyond just using the site, so perhaps I'm not the target audience, but I just found it odd.
I'm not exactly sure what's wrong with this, it works for me: type MyInterface interface { DoThing() } type MyInterfaces []MyInterface type MyType1 struct { Name string } type MyType2 struct { Name string } type MyType3 struct { Name string } func (m MyType1) DoThing() { fmt.Printf("DoThing: %#v\n", m) } func (m MyType2) DoThing() { fmt.Printf("DoThing: %#v\n", m) } func (m MyType3) DoThing() { fmt.Printf("DoThing: %#v\n", m) } func DoStuff(m MyInterfaces) { fmt.Printf("DoStuff: %#v\n", m) for _, v := range m { v.DoThing() } } func main() { as := MyInterfaces{MyType1{"Hello"}, MyType2{"World"}} DoStuff(as) } Maybe I'm misunderstanding the question somehow? I actually implemented `DoThing` as a part of the interface ("I want to take a slice of *any* type that satisfies an interface"). If I'd change MyType2 DoThing to DoThing2, the usual interface error occurs: ./main.go:38: cannot use MyType2 literal (type MyType2) as type MyInterface in array or slice literal: MyType2 does not implement MyInterface (missing DoThing method) Am I off somewhere in terms of your requirements? Is there some specific reason you'd want to use `DoThing(MyInterface)` for all your types and rely on the type switch? Doesn't seem like you need to. You can however use it with your initial pattern, ie: func DoSomething(m MyInterface) { fmt.Printf("DoThing: %#v\n", m) } func DoStuff(m MyInterfaces) { fmt.Printf("DoStuff: %#v\n", m) for _, v := range m { DoSomething(v) } }
Why do you use a build container? edit: very nice otherwise. I'm increasingly into the idea of putting all non-main code into a pkg subdirectory, and keeping the root clean.
The build container should match the deliverable. For example, the `alpine` distro doesn't give you the same OS as `debian:jessie` obviously, but to be more exact, there are incompatibilities which mean that go binaries built on one may not work on the other. For example, from a debian built binary: $ ldd app linux-vdso.so.1 =&gt; (0x00007ffe4bb57000) libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f35d0b0a000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f35d0745000) /lib64/ld-linux-x86-64.so.2 (0x00007f35d0d28000) And the `alpine:latest` image doesn't have `/lib64`, concretely. Packaging go binaries into docker images just gives me the delivery options and process management that comes with the docker ecosystem. I suppose this by itself is the reason to use docker to build go programs by itself, also.
Vere nice ;) I would drop a .keep on /vendor to complete the assimilation.
No he doesn't mention Go. But in my opinion it's good to know what else is out there and/or what Go is up against. Also if you've been following Go talks and articles especially the earlier ones you'll notice that Bjarne in his talk basically is trying to shift C++ to reach where Go is today (Safety, faster compilation times &amp; concurrency). In this talk you can also see Co-routines coming in C++. Yup! Also he is talking about modules which are probably much different in design from packages but he kept repeating that by using modules you'll be able to reduce compile times. And oh they are pretty much working on a C++fmt! Of course all of this makes sense because Go was created out of frustration with existing system languages. But despite that, it's very notable that [Go didn't receive much attention from C++ programmers](https://commandcenter.blogspot.gr/2012/06/less-is-exponentially-more.html). That's basically the reason why I linked this talk. Sure it doesn't mention Go but it seems that Bjarne is trying to make C++ walk towards the direction of Go!
I don't disagree. I would just be a bit surprised if it got accepted. It might be better if someone forked the playground and made one with all these bells and whistles. I say that as someone who wouldn't mind a specific bell/whistle.
Wow, what an endorsement of many of the great decisions made, in the design of Go
This library changes everything! What will the naysayers say now?
I could have modified the Go and Rust versions to use multiple threads, but I didn't see much point, since I expect it to scale roughly linearly, apart from the GC issue. If your only criteria is how fast does code without explicit concurrency run, regardless of what the implementation does behind the scenes, then something with automatic paralellization would blow everything out of the water. But that is hardly fair.
I think it shows the power of Go when it comes to distilling complex solutions into truly simple and understandable code by everyone. It's a perfect example of craftsmanship. Thank you for your time and work on this!
I've already deployed this into production for an app with internet scaled traffic and it works just fine. I can now express things in golang which I couldn't before.
I love how there is a test file. Too bad the tests don't actually test for anything.
Hermetic builds. Tool versioning is important. As apps get more complex, you may want other tools, too. For example, many Kubernetes build bugs come down to MacOS having an ancient version of sed.
I don't want to prescribe that far, though maybe I should, given how painful it was to evolve :)
I made this mostly to learn how to do this but perhaps it is useful for others. For those wondering about Windows support it would require a bunch of work I have not bothered to do but it would require either ANSI emulation (Windows 10 or ansicon) or using Windows-only API. Also note that I did not use termbox-go or a similar library for a reason. Those tools rely on the terminal's "alternate screen" (what text editors typically use) so you then lose your current shell context while your application is active.
That's amazing! Perhaps I could add a list of projects successfully using the library, to showcase the benefit to the community... Or even some benchmarks to demonstrate how it's powerful and expressive nature comes at no additional cost to the runtime.
I don't really know enough about the problem or have the time to spend on analysis to offer a really good answer to that, I'm afraid.
Looks like you got the same idea I did when I wrote: https://github.com/ladydascalie/4tools Since our tools are essentially built to do the same type of thing, maybe we should collaborate on these?
&gt; In golang, it's been said that interface{} doesn't say anything. Because it doesn't. This is why you should avoid programming against it as a replacement for the lack of generics, as it's a meaningless crutch which tells you nothing about the behavior of the types underneath it. But the caller shouldn't need to know about the behavior -- just rely on it to do its job when passed the correct message. That's known as delegation. &gt; can confidently and securely rely on the power and flexibility of golangs built in interface{} interface{} isn't a special built-in, it's simply a degenerate use case. This doesn't say anything more than interface{} does, it simply puts lipstick on the pig. If you want to write Go like Ruby or Python, go right ahead -- but make sure you have a VERY complete test suite...
Oh god the javascript developers have found us!
The [FAQ](https://golang.org/doc/faq#What_is_the_status_of_the_project) has this to say: &gt; There may well be a Go 2 one day, but not for a few years and it will be influenced by what we learn using Go 1 as it is today. I see absolutely no reason to worry about any *Go 2* compatibility right now. Don't think about version numbers that way. Nothing speaks against a version 1.42.6 or 1.3141.0.
There is no specified date for when Go 2 will come. The versioning system that Go uses does not overflow at 10. That is, when Go 1.9 comes out, the next version will be Go 1.10, then Go1.11 and so on.
They are coming out of the walls!
If sed's part of your build, I feel bad for you, son. (Thanks for the answer!)
[go fix](https://blog.golang.org/introducing-gofix) will port most if not all of your code to 2.0
Ahhh I see what you mean, so keep the small static build purely for production, and leave the bigger, Go container for local development? 
Advantage: * It allows for named values Disadvantages: * The value loses type safety (being interface{}) * It requires the allocation of a map for every use * It requires a map lookup to access each value * It can't control what keys are passed in (there is no validation on misspelled keys) Personally, I believe the better approach is to declare a struct with the named fields you want and to take that struct as an input: type Config struct { Arg1 string Arg2 int Arg3 float64 } func myFunc(c Config) { ... } Using it looks like: myFunc(Config{Arg1: "string", Arg2: 5, Arg3: 3.14159}) If the proposal for https://github.com/golang/go/issues/12854 passes, you will be able to call myFunc simply as: myFunc({Arg1: "string", Arg2: 5, Arg3: 3.14159})
Oh yeah, I see! This is great, best of both worlds. I'll have a play around with this, and update my post with my findings :) I'm not sure how I missed this, it seems pretty obvious now, thinking about it
The downside of the struct way is that if you forget to name an argument, the "zero" value gets passed in silently with no compiler error. This is likely not what you want.
Some general advice, make sure not to try to search for equivalent solutions to your problems. I would put the problems on the table and try to objectively solve them freshly. I say this because you may be able to solve your same work flows with better or equivalent UX in a web app instead of a CLI. Also I would say try not to get too deep into ORMs or frameworks. You can do so much with standard library. Frameworks can be good don't get me wrong but just don't take on too much before you get a solid grasp of the language.
Interesting. I've looked at this a little. I might have to look some more as it isn't part of the standard branch so it will take some work to get working in my environment.
I'm not saying its my only criteria. It was a comment about something I saw being done in the tests, that stood out as odd to me. The code was said to not be concurrent in either of the languages, so what you are changing is runtime knobs to try to arbitrarily normalize them. The fact is that Go has a garbage collector, and to mitigate the cost of said garbage collector, it is allowed to utilize background threads. But you are saying it is fair to disable those things and let the garbage collector have a greater impact, even though it does nothing for the code you actually wrote. So it isn't the same as automatic parallelization because that is an optimization of your own code. So if you are going to turn runtime knobs to arbitrarily attempt to normalize tests between the languages, should you now start getting into turning off as many compiler/runtime optimizations as you can find in all the languages? Just run them in a real world scenario, where the language implementations run as they would for you given test machine.
Implicit zero values create the same sort of problem nil does. Since it inhabits everything, you have to think about it everywhere. It's true that you have to validate values at some point. The question is where. In Go, you don't have a choice but to be defensive and check your inputs with assertions or by assigning some arbitrary meaning to a zero value you might not care about. The language doesn't even almost provide facilities to invert this control and allow the callee to require the caller to provide this validation. It would definitely be nice to be able to have your type opt-out of default zero values.
I agree, and greatly prefer having a single, (relatively) deterministic, repeatable build artifact that requires no extra "build server" infrastructure to be produced. 
&gt; lot of conversions from []byte to string and back again Indeed. But the lowest hanging fruit seems to be the use of two large maps constructed without a [size hint to `make`](https://golang.org/pkg/builtin/#make). [Fixing just this with just two trivial lines](https://github.com/dchapes/enjarify/commit/8311f090f13f9192b36fb12c17d5570dd9b7a2cb) drops the hashtests run-time by ~11.4% for me (with GOMAXPROCS not set of course, as that's the only sane thing to do).
With an extra block you can limit the scope of local variables.
Take a look at protobuf. :)
If both versions were running with $numcores threads, then the GC would have to compete with computation in the Go version. So it's only fair to take that into account. Now, I have no idea how the impact of GC differs at different levels of parallelism, but it's not like the cost is 0 either. I just did my best to make the test fair. I can compare parallel versions too if you want, but I doubt the results will differ much. The results are also likely to be noisier.
Thanks, I didn't realize you could pass size hints to maps. I'm planning to try to optimize code as much as I can and then redo the benchmarks, so any other suggestions are welcome too. 
Good advice! You may prefer alpine (or any tiny district) as a base image instead of scratch for an easier debuggability or introspection. ( being able to sh into the container is sometimes nice )
How do you expect Go 2 to ever happen if people don't experiment with the language?
Great! I'll sure do. The past few weeks things were insane, but we'll get there. Thanks for the welcoming support :)
The best part is that it was so easy to refactor our enormous codebase to incorporate use of G! I can say with confidence that we are one step closer to making our system web-scale.
Not fair to use more than one core? How many computers this days only have one core? Even smart phones have more then one core. It's time to get on with time and allow the code to run on more cores instead of trying to frame things into your narrow definitions. That's the strength of Go and the language and you cut it's arms off. And like mentioned before, if you do that to Go, we can assume that you have disabled any optomisations with Rust by making sure not to use -O flag. Just to make it a level playing field, since Go doesn't use LLVM. As you can see we can twist our points and narrow world views into our own little arguments. But lets face it, by setting GOMAXPROCS one, you are using Go in a way that no one else in this world is.
Hi guys, I've started this project some time ago and wonder if some of the seasoned golang devs here can take a quick look at it, and maybe tell me if I'm doing something wrong/suboptimal/not golang-way. Also, this repo probably would be helpful if you want to prepare for interview in Google =)
What are zero values even a solution to?
:(
An unbuffered channel cannot hold one item. That would require a buffer. A channel is better thought as a rendezvous point where two goroutines meet to exchange an item of some sort. The item is always held by one goroutine or the other. A buffered channel of size N can hold N items before it has the same behavior as an unbuffered channel from the sender's perspective -- sends block until a receiver arrives to take an item. Select is the unblocking operator. It allows sends and receives to not block or to block on zero or more channel operations, not just exactly one as without.
Go ahead and attempt to run it, you'll get a lovely error
Any reason to use this instead of Go interfaces ?
&gt; while C++ is rapidly evolving. I wonder when it will stop maintaining backwards compatibility. How much can someone digest(30 years of changes/features, 100)?
I am the author of github.com/fgrosse/goldi which is also a DI container for go. My question is: how is cargo different from any of the existent DI frameworks and do you already use this in production or plan to do so? I created goldi just for the fun of it and to learn go but I never actually found any good reason to use it and I don't know of anybody who has. I could only come up with projects in other languages that make heavy use of a DI container but not for any go project that I know of.
Would you please elaborate without the sarcasm?
On a serious note; Good job on the hard work, but this is another library I suggest not be used in lieu of well-designed types.
Slow down, it's 4 in the morning here. Edit to add - My comment was not about sarcasm. I was having fun with rhyming my reasons for warning others. Also, no downvotes or upvotes in this post came from me.
Yeah, it's just my impression maybe that in the near future these kind of programs are going to be even more relevant for the Go environment.
I appreciate the feedback. I'm still a newbie in the Go community ‚Äì as you can likely tell by now ‚Äì, but with all due respect I disagree that a DI container is going to be slow just because of the use of reflection ‚Äì especially in an extremely performant language like Go. While I understand your point of view, my idea is to provide caching mechanisms through the use of service proxies, which would overcome the performance issues. Also, by type relationships I mean how objects relate to each other and how the workflow of their dependency chain creation is defined.
In todays world, web scalability is a sink or swim situation. With the power of the G type in package generics, modern engineers don't need to waste time fighting with a type system or language design that feels like it's out to get them at every turn.
&gt; Anybody who is disappointed at the rate of change of C++ would be absolutely infuriated with Go. I agree, that sounds perfectly logical. But you also have to take into consideration the kind of people/community that has formed around the language. Go was created out of frustration with existing languages. At the core of the Go community we have developers who are frustrated with their main/day X language for different reasons (complexity, bureaucracy, bad tooling, lack of good concurrency, speed, slow compilation times etc) and Go gave them what they were looking for. Usually those are the people who have jumped on the Go bandwagon early and are also the people who truly "get" the language. Let's call them true gophers. The true gophers are hardly ever disappointed at the rate of change in Go. On the contrary they feel *bliss* everytime they get a new release with minimal to zero language changes (and breaking changes) while they get improvements in performance and quality of life changes in libraries and tooling. That only makes sense because they have already experienced the frustration of working with their X language. Why would they want Go to become even remotely similar with X? They wouldn't simply because that's the very reason they came to Go in the first place! 
There's already a task runner called Godo. 
[removed]
Again, I could run the Rust and Go versions on max cores. I just didn't bother because I didn't think it would make a difference in the comparison. But I do plan to do that in the updated benchmark, just to shut everyone up about that stupid issue.
 package main import ( "fmt" ) func main() { var hello string hello = "test" fmt.Println(hello) } // [...] Bunch of new lines var string int
I was immediately annoyed by the extra idententation on line 8, so I pushed the format button and it killed off all the extra newlines.
Why _"CarGo"_ though? As someone who uses Rust too, having another tool named the same way as the official [Rust Package Manager](https://crates.io/) seems like a bad idea. You should consider changing the name, something like Depingo‚Ñ¢ ‚Äî Dependency Injection for Go... Mmmh actually I should use that for my own project... Yeah, forget what I said, keep using _"CarGo"_ I will trademark Depingo ~(Àò‚ñæÀò~)
I think you are misunderstanding it. Every language has its strengths (and weaknesses). Go is all about concurrency and how easy it is and its part of the language. You killed that. Rust has it features and it's aimed at different market. With Go you can make goroutines with ease and no threading, mutexes etc... Python has it's strengths and weaknesses. I think once you start using Rust the way it's intended, not carbon copy Python on top of it. And you do the same for Go, no one will have any issues. The issue that stands is that everything is supposed to be Python and you handicap other languages by it. For me, I'm a sysadmin. I use Ruby/Perl for quick and dirty tasks. For any major project, I might have to call lots of Rest APIs. Lots of asynchronous tasks, etc. I will never write a compiler etc, that's more aims at Rust. For what I do, standard threading is a total nightmare. With Go I can code all this up with my eyes closed. Try to embrace the differences and the strengths each language gives you. Not handicap them. For this project, Rust might be the best choice. But Go shouldn't be as slow as you have showed if it's written the Go way. Rust will be faster then as well. But they will be a lot closer to each other than they are now.
Love it!
I already addressed that in the introduction of my original post. There are pros and cons to both approaches. Pros of writing projects from scratch in each language * code is more idiomatic Pros of rewriting a single project in each language * allows comparing the performance of code that is doing the same thing in each case * allows comparing the verbosity of code that is doing the same thing in each case * takes a lot less time Anyway, I'm open to suggestions for how to make the code faster or more idiomatic (though the two often seem to be in conflict). I plan to optimize the Go version as much as I can and then redo the benchmarks.
Possibly my favorite thing about go. "Screw your opinion. What does `go fmt` think?" My eslintrc is so meticulous. "SPACES AROUND BRACKETS WHEN THEY'RE WRAPPED WITH PARENS!" I don't even bother with whitespace anymore. `,r*http.Request){` will fix itself. Don't even bother indenting that new line. You're wasting time. Then I have to use another language and I have to spend forever going back and fixing all the styling. I feel spoiled by go
Spoiler!
Thanks for the suggestions! I've updated it accordingly. How would you suggest handling the errors instead?
All of this can also be done with a couple of bash scripts (including testing in containers and building in containers). For example: https://github.com/gopheracademy/gopher
Amen. I didn't know about `ioutil.Discard`; 2 TILs in this thread! PS: a thought, `_, _ :=` is pointless. Just remove it
Needs header and method flags before it's useful.
I use assignment to `_` to explicitly say that yes I know I am ignoring errors, and it's intentional.
Thanks for the write up! I put together an example for the gRPC bridge filter as well. https://github.com/lyft/envoy/tree/master/examples/grpc-bridge
`_ = somethingThatMightErr()` is a pretty simple convention. It's enough to quiet https://github.com/kisielk/errcheck and works as a reasonably clear signal that the error is swallowed on purpose. If a comment is needed, the comment should say *why* that is true, not just `// swallow error`.
I think we're in agreement: if you are intentionally ignoring the possible outcomes, a comment on *why* should be attached. To me, this is more valuable than seeing a blank identifier and knowing "they called this thing that returns something... and didn't care... but, clearly, on purpose"
Don't do it! If you feel that you _have_ to, these are your best two options: 1. Rethink your data structure 2. Build it in another language The dynamic typing takes away all ability to analyze/read/understand your functions without deeply understanding the implementation. Recently, I was helping someone who had var serviceMap map[string]string var serverMap map[string]string var nodeMap map[string]string var statusMap map[string][]string z0 := make(chan string) z1 := make(chan string) z2 := make(chan string) z3 := make(chan string) z4 := make(chan string) results := make(chan []chan string) It took a few hours to wrap my head around what they were even attempting, much less what was actually happening. Having solid *types* that describe context and the actual entities makes a world of difference. It's worth doing: you'll become a better developer by practice of taking the time to sit and think about the best way to architect your application with simple pieces, rather than a quick and easy-in-the-short-term solution
But I get where he's coming from. I'm not a fan of magic and I relate DI to using `context` to pass around app dependencies. The app will work... If you know the magic strings. I'd prefer using a function that has its dependencies listed as params (interfaces) than one that takes nothing and infers the dependencies because of some global state. Let's say this is widely adopted and two things expect a `"logger"` injection - they may very well expect different interfaces. Let's, now, say you solve that and it just finds the `"logger"` that implements what is expects: how does the developer know which one was used? From my experience, untangling DI is a nightmare. You also lose all compile-time validations. I'll stick to calling functions with arguments over "set all the arguments over *here* and then call the functions" EDIT: this is not a knock on your library or code. It's just a design pattern that's given me a few too many headaches
True but bash scripts are a less-than-perfect option on Windows.
Some people prefer different trade-offs than the ones you prefer. 
This is service locator not DI. http://martinfowler.com/articles/injection.html#UsingAServiceLocator. 
I wrote https://github.com/carlmjohnson/get-headers for a similar reason. Go makes it very easy. 
how to you change the tor circuit for each new request? Is it possible to have multiple go routines running that each use a separate circuit?
No support, see https://go-review.googlesource.com/c/29439/ I think it is in /x/net/http2 but as a low level primitive. It isn't exposed to http.Handlers
So Go 2 is a whole new language by junior Go Team members in 30 years. That's a long wait. 
https://github.com/go-godo/godo
I spent a day optimizing the Go code and managed to get it down to 3 minutes (55% speedup). If you can find any other optimizations, feel free to tell me. 
Have something similar here: https://github.com/Redundancy/cdntest
Go is almost 10 years old. 
What's better than in https://github.com/joeshaw/gengen ? gengen supports two placeholders, that's pretty important for 2D data structures. EDIT: oh nevermind
Why do you need to change the dependencies during runtime? Why is constructing someComponent with dependencies provided at construction time insufficient?
I get the point with your library but don't you think it breaks another fundamental go rule : "A little copying is better than a little dependency" and it would be better to declare such a statement in your code directly ?
While this is true, the main drawback would be if you rely on libraries with also use G as a type, you'll run into compatibility problems. Once the aliasing feature comes in a future version of go to save us from nightmares like this, then I'll add a section to the readme giving the gophers an example of using G via the beloved "just copy and paste that code around, it's cool" approach espoused by our beloved proverbs. Until then, due to the universal compatibility issues, I'd recommend using the package itself.
Dave has made it clear he doesn't want to add significantly more features that would replicate the significant portion of the HTTP(S) functionality that curl provides to avoid having to build a more complicated test harness. I personally would rather not have to rely on both. Would there be interest in a fork of this that does? Based on what's left after the current list of slated features in the issues are essentially proxy, silent, cookie, basic auth, and custom tls certs.
thanks. any ideas for a new name? I'm open to any suggestions
Queueing up your work will completely change the nature of your service. Now you have to assume clients submit URLs and go away...you need to provide a means of identifying queue items, reporting processing and error status etc...and how does the client receive the completed work? This is trickier now because you have decoupled from responding directly to the initiating client...and when do you garbage-collect results that are never collected? etc etc Try to see how far you can get processing requests in full when they are received...then you can use regular http status codes to communicate directly with the initiating client....this will be much easier. Go has concurrency support for http requests so you can handle multiple simultaneous clients. You don't seem to have a reason to queue these requests logically, so if you are just queueing to manage load, let Go do that for you and profile it to see when you need more capacity. A well-written Go server should still be able to handle a decent amount of traffic, and when you hit a wall, scale horizontally with HAProxy or some other load balancer. I have written Go servers that handle creating and extracting multiple GB gzip'd files simultaneously and never had an issue. If your requests tend to be heavy enough that timeouts happen in the expected case, then you will need some kind of job control framework...these are a headache to build, and it is often easier just to pay up and use something like Kinesis etc... distributed work queues are a major ops headache stick to net/http in any case...you are only going to have a few simple routes
It is a bad practice to edit anything in the database using repl. 
Thanks for the feedback, these jobs will take a while to process to completion, up to several minutes in some cases . The clients will just submit the requests and expect a 200 if the response was received successfully, they will not wait for results. To back up a bit, my data will initially arrive in S3. I'm going to set up a notification when an objecteCreated event occurs which will either submit a request to my REST API via SNS or Lambda. My API will simply respond "yes, I got the URL message and will process it when I can" or "I did not receive the message successfully" e.g. an HTTP 40x response(s). For scaling, I'm thinking of using sustained queue size and/or CPU utilization to spin up new instances. I need to do some more research on options there, I may end up using AWS builtins for all of that e.g. ELB and API Gateway. Also, I have an added complication that the XML files may be split up and span multiple input files (URLs) so I'll need to keep some shared long term storage handy somewhere, either on EBS or something like DynamoDB. That is lower priority for me at this point since most of the data will not be split up. The reason for the split is that the input files (URLs) will be serialized Kinesis buffers and Kinesis Firehose has a 1 MB record size limit. I will definitely have some XML files which are large than 1 MB. But anyway, I'm getting a bit off track here, currently I'm looking to organize a set of channels in a sensible way for this pipeline. 
For the record.. I didn't enjoy it.
It is almost like we have worked on the same thing...I also used S3 and DynamoDB. My code predated Kinesis so I used SQS. If you also control the client code, you can use DynamoDB as a status reporting mechanism. In any case good luck, exploit AWS as best you can since you are already committed
Godock?
It seems to me people these days tend to come up with imaginary problems all over and over again. It's not about size, innit? Take care of your dependencies, make sure to keep things as flat as possible and just split them up once things get too clumsy. No way, let's write yet another beginner-sort-of-oriented piece on code modularity. Come on, you're only supposed to blow the bloody doors off!
How about just have clients submitting the URLs inside SQS messages and have a backend servers processing the queues?
Go version? Could we see the codebase?
The Go version is 1.7.1. The codebase is larger than I'd want to dive into if I were you, but you can: https://git.stephensearles.com/stephen/cabin (db parts: https://git.stephensearles.com/stephen/crazydb).
thanks for your reply , here is the link https://play.golang.org/p/Bj0T-OKXWw 
The main issue is that within the scope of logDataAdd, the pointer to the http.Request is being changed. However, this does not affect the pointer to the http.Request in the main func. The pointer must first be dereferenced so that the value the pointer is pointing to is modified. The following works: https://play.golang.org/p/Jopyty0TrA Further, it is more clear to alter the pointer to the http.Request in the main func: https://play.golang.org/p/Mpa8CR57P5 Otherwise... The type switching is unnecessary, the handler is not actually being tested in the play code, the map within a map is ugly, slow, and verbose, and much of the naming is hard to digest.
More sufficient pathways have been presented as possibilities for go generics, and last I checked those people you mentioned have been publicly silent in regards to that feedback. My point is that although this is a somewhat sloppy implementation, it shows once again that it's possible to have primitive generic interfaces without an insane amount of difficulty, which would be good-enough for most real use-cases.
Thanks! And thanks for the simplified code too. As for the need for `*r = *r.WithContext(context.WithValue(r.Context(), "log", m))`. I thought that because `r` is a `*http.Request` and is pass by reference that we could modify it like I was (apparently wrong). I believe my understanding now is that because we are not modifying the original request, but instead creating a new request, we need to change the pointer itself. Is that right? Cheers, and thanks again! [edit]: it looks like when I commented, there as just a google play link, but now there is a description. This makes sense. Your second link clarifies this too. Thanks again. And I did not realize I could do the membership and type check in the same line; that is _so_ helpful. Cheers!
This is exactly why Rob Pike says this &gt;In Go, everything is passed by value. Everything. &gt;There are some types (pointers, channels, maps, slices) that have reference-like properties, but in those cases the relevant data structure (pointer, channel pointer, map header, slice header) holds a pointer to an underlying, shared object (pointed-to thing, channel descriptor, hash table, array); the data structure itself is passed by value. Always. &gt;Always. &gt;-rob You can think of pointers like pass by reference up to a point, but never forget that pointers are still just passed by value. Edit: source https://groups.google.com/forum/m/#!topic/golang-nuts/INedfATw74A
Thanks for the clarification!
I was in the very same boat. If you have files in S3 and work enqueued in either SQS or Kinesis (or some other queue), I assume you are also letting AWS be the terminus of the data (DynamoDB, Aurora, etc). In this case you basically have the same scenario I was in - a middle process that takes mucky data and preps it for insertion. Spot instances can help. Figure out your average expected workload, build up a cluster based on that. Get alerts set up to tell you when your queue is too deep. When that happens, you have two scenarios: you have a legit bug in your code that is precluding processing...or you simply are flooded. If the latter, you can always spin up some spot instances to work it off. Beware that AWS databases like DynamoDB need their provisioning scaled up also in the event of spikes...I don't think any of this is fully automatic yet given the implications for runaway billing.
I agree with you. The title and some parts of my post may sound misleading and that's my fault. Go is about simplicity than 'modularity'. Thanks for leaving a comment.
Thank you for looking and advice on the time package. I'll start using it now, makes the conversions much easier and cleaner. Will also start using Wolfram from now forth. Did not know I could do this. Thanks!
Join an open source project 
Unix, bash, etc.
Well done, thank you!
In some cases a true static executable is not possible from what I've read somewhere. It's not just a matter of -ldflags static or whatever option. I'll be glad if someone corrects me on this. What I know for sure is that you'll have to add compiler/linker specific options when you build your app to have a static binary for some but not all of the time. Sure, a hello world will be static, but something using the net/* packages might not be IIRC.
Or you can inject them to the functions you need 
There are plenty of ways to do this in Go (or any other language). This will answer some of the questions you had http://www.florinpatan.ro/2016/09/using-dependency-injection-pattern-in-go.html?l
Inlining is `-l` not `-I`
And for good reasons. And what I've linked are concrete solutions. Using Context is not. It's an anti-pattern. This is Go not other programming languages. Learn the patterns and anti-patterns of this language. 
It literally solves every issue. &gt; What if db has dependencies of its own ? Provide dependencies at construction time! It's not difficult: db := NewDatabase(dep1, dep2, dep3) mw := NewMiddleware(db, otherThing) &gt; How do you inject dependencies in your struct that has handlers , and where (and when) do you inject them ? in a thread safe way. How do you do all this while keeping your types testable and mockable ? How do you make sure that a dependency that is not needed during the request/response cycle isn't created ? i.e. how to you create your dependencies in a lazy fashion ? The above advice satisfies all of your requirements. Honest request: can you _please_ tell us what you find lacking about it, so that we can address that issue in a way that is {testable, maintainable, coherent} without falling back to globally-scoped stringly-typed object registries, or reflection-based dependency stores, or passing database handles thru request contexts?
On the contrary this post advises not to use Context for both request and application scopes. 
NewDatabase cannot be created globally if it requires a *http.Request object as a dependency, like [App Engine datastore](https://cloud.google.com/appengine/docs/go/datastore/reference). If I wanted to swap db between App Engine datastore and a map in memory, how would you get that working in your scheme ? The map cannot be created per request. Do me a favor and read [Where Have All the Singletons Gone?](http://misko.hevery.com/2008/08/21/where-have-all-the-singletons-gone/) by Misko Hevery. 
Just curious, with .net core running everywhere why do you want to switch to go? 
agreed - there is a link to another repo with our notes, but documentation is still sorely lacking.
I see. You're right; that constraint on the AppEngine Datastore type imposes further constraints on your component design. But that weird design choice by AppEngine is absolutely exceptional, and it's important to start the discussion there: you can't/shouldn't generalize from this use case to others.
Yes. My company would probably hire anybody with the right background (networking for us), who is willing to learn Go.
A database handle _is_ almost always global. That App Engine keys off the HTTP request is almost certainly an artifact of their multitenanted design, which is an edge case. Of course everything is contextual, if you live and breathe in multitenant infrastructure then my edge case is your normal case. But let's not start people down frustrating and unmaintainable code roads by cargo-culting DI patterns from other languages and ecosystems. Always contextualize and justify designs like this upfront.
Go is perfectly suitable for Web based APIs. And it is in fact one of Gos strengths.
Yes, this is pretty much the use case that Go is designed for https://golang.org/doc/articles/wiki/ 
Do you consider freelancers? I know one which might be right up your alley and made contributions to [gopacket](https://github.com/google/gopacket) and can say first hand that he has a lot of Go experience (lately parsing ASN.1 flows with about 300GB data daily, I realize now it also falls under networking). If yes, send me a DM and I'll introduce you guys :)
Sure a database handle is almost always global. Once you go down the road of using closures for singletons and Context for request scoped types, you have to extend that assumption for all global vs request scoped types. Absolutely no contextualization required for that.
Haven't looked at the bluejay code yet. But from.my experience db is almost always global except for some edge cases.
I'm also available right here to answer any questions you might have :-)
.NET Core running everywhere is actually what might get me to choose C# for another project some time in the future. I haven't played with it yet to see how well it really does run everywhere. I want to change to a different language/ecosystem because as I heard in a software craftsmanship meetup once, there is no master craftsman with one tool in his toolbox. I chose Go as another main tool to focus on because I like the structural type system, among other things. I've also used Node but javascript is such a mess of a language that it hasn't been enjoyable.
I don't have anything specific, but I was hoping someone else did. Something like "I've hired 3 C# guys to do Go and they all bring X piece of baggage with them. Break that way of thinking."
That is handy. thanks!
Well, if you want to empty the resp.Body (as you should to reuse TCP connections / prevent memory leaks) you need to read/copy it and to do that you need to do the limbo with _, _ = io.Copy(ioutil.Discard, resp.Body) If you don't ignore the variables with _ Go will throw an error because you didn't use the variables. So I don't see a better way to do this.
If your friend has particular concerns about using it, perhaps you could find those out so people could address them more specifically?
Ignore me. It seems it's being worked on and uses httptrace instead. Amazing work to all those involved with the PR. https://github.com/davecheney/httpstat/pull/7 EDIT: spoke to soon. Looks like it might be abandoned.
[Feels good.](https://i.imgflip.com/1ba823.jpg)
You probably need a lock around the db variable as it can be read from and modified at the same time. Furthermore checkErr is usually a bad idiom, as does not encourage actually handling errors and prevents cleanup, such as closing resources. 
Well I imagine it would be done the same as with C#. I open the RegistryKey db and scan through the values. With installation I guess it's going to be more tricky especially getting the output from exe ?
Should definitely favor an injection-style passing of dependencies from main, downward into code which relies on them. Globals for dependencies like databases and configuration data are a weak design overall.
A kind soul on the #go-nuts IRC channel recommended I look at http://eagain.net/articles/go-dynamic-json/ and it seems this is exactly what I need. I'm going to give it a shot but I would love to hear any other comments you may have.
What is your actual problem with it? The example you have is completely fine, the actual Unmarshaling might be the only mess you'd have to consider cleaning up, and cleaning up the JSON above a bit: you have two possible representations for "params" values, you should enforce just one, depending if you want a map[string]string, or a struct{ key, value }. Structs are extensible in case if you'll consider adding new fields, even if they are optional. But a map value is easier to look up O(1) hash lookup vs. O(1..N) loop lookup. I have an IoT project on the shelf for some home automation thing I started a few months ago, I can give you a bit of a "dump". I structured my data into "devices" which might be a switch, sensor, a relay, and then "outputs", which might be the switch button (1), several sensor values (temperature, humidity, etc.), several outputs (4 channel relay, 8 channel relay - each relay channel is one output). I even hooked up exec as an output, so technically I can run shell commands on a server and not just control output. You can imagine the world it opens up in terms of public API calls, sending emails, SMS, and even phone calls like twilio etc.; I posted a screenshot of such a deliberate "run": Edit: I can't inline it, so link here: https://pbs.twimg.com/media/CqjQJ3JWAAEhVq_.jpg
Why? I am interested in how, but mostly the question is why. If you're doing alpine builds in alpine the ELF can be dynamic. And if it's static, you'd still run alpine just because you have access to actual useful linux distro parts like CA public keys for SSL verification, locales for i18n stuff, ssmtp for sending out e-mails maybe, and many other things which I can't anticipate off the top of my head, but I'm sure none of which are avail. in 'scratch' :), so, why? Edit: I do realise the point of having a static binary, I just don't see the point in producing one if you're targeting docker images as the distribution method. After all, you can run that alpine image on any platform as long as it's x86 (you need an arm build for arm,...), and same goes for debian, etc.
Looks pretty simple, this should help you start: type Params struct { Key string `json:"key"` Value float `json:"value"` Unit string `json:"unit,omitempty"` Graphable bool `json:"graphable,omitempty"` } type Device struct { Id string `json:"id"` Name string `json:"name"` Type string `json:"type"` Room string `json:"room"` Params []Params `json:"params"` } var devices []Device 
Now do that with http://robpike.io
The problem is that there's about 30 device types, and about 50 different types of parameters that can be sent. So I want to convert from a generic Device with a bunch of parameters in to a nicely formatted type like a Dimmer with fields that make sense and are nice to use. You can see the spec and actually play with the API a bit here: http://dev.evertygo.com/api/iss
Looks like too much of a PITA too me. Initially I would use something like above and make it generic. Then I would create another my own marshalling function which transcodes the above structure into one that has more device specific types. And those types would have methods and interfaces, etc... I'm not sure how to do it without a middle step, someone might have a better idea.
I would use floating point math where appropriate, since the answer is obviously not exactly 23km/h. you can also add a check at the end that tells you if the math is right instead of just printing out the number.
&gt; 0 values are just implicit initialization, there is nothing wrong with that. It's implicit initialization that everything has that nobody can opt-out of. That's the problem with it.
It won't change for a particular build of Go. Updating the error strings is a semi-manual process where someone runs a program (mkerrors.sh) that writes out a Go source file (zerrors_GOOS_GOARCH.go in package syscall) taking those constants from system headers and/or libraries. The most obvious difference between various systems or C libraries is the capitalization of the first letter. Go unifies this by making it lowercase, always. Actually, that's not true: the error string for EADDRINUSE begins with a capital A on NaCl, which might or might not be a bug.
Can you actually explain this please? I have a couple of web apps (mostly just rest API in go/go web server with serve static AngularJS front end) that use global variables for the db. How exactly should one do dependency injection downward into the code? Pointers/references? Geninuenly curious about this cause I was doing a lot of NodeJS development before and it was pretty common to just do a global db variable. Thanks!
He said he told friend he was planning to build a REST API. OP your friend is flat out wrong. Like others have said, Go was created for this. You can do plenty of other things with it, but "building a web API" is at the top of the list for best use cases
&gt; Incidentally, I think this is why no one has been able to write a decent GUI toolkit in Go yet. Most of the ones I've seen more or less follow the standard GTK and Qt-style inheritance-based widget hierarchy. It's just not going to work. All they need to do for Go is to follow the plan 9 way. As far as I know Rio was based on satisfying interfaces and not inheritance.
If you have the time and inclination, that would make a good blog post/article.
Go is basically made for Web APIs. If you want to get a CRUD up and running fast, there is api2go, which serves you up with a full CRUD-capable web handler. You only need to write the database handler and relationships. You can step down to gorilla, which gives you much more control (and less verbosity than jsonapi standards) but requires some more explicit code. Or you just use vanilla HTTP, which I've use a lot and it's still somewhat pleasant. Even at this level, only using the standard library, you can get going very fast.
Took 10.205589 seconds, ~100 times longer than usual for 1 link but finished without problems. if err != nil { c.Add(&amp;c.ErrCounter) Error.Println(err) if resp != nil { _, _ = io.Copy(ioutil.Discard, resp.Body) defer resp.Body.Close() } return } Logfile: &gt; {startPage:http://robpike.io filterGlobal:true startUrlHost:robpike.io filterHost: filterHostTLD: filterPathStart: filterPathPos: filterPathPosArray:[] filterPathNeg: filterPathNegArray:[] maxWorkers:10 maxDepth:-1 maxLinks:-1 maxRetries:1 logLevel:1 profile:false backlog:0} &gt; Type;Date;Backlog;Id;Level;Status;Source;Link &gt; LOG;2016/09/26 20:56:58 ;0;1;0;200 OK;___;http://robpike.io &gt; links;1 errors;0 total time;10.205589 time per link;10.205589 &gt; Total Link Count;0 Duplicate Checks;0/0; NaN% Host Checks;0/0; NaN% File Ending Checks;0/0; NaN% In comparison the log for http://www.example.com, took 0.394023 seconds &gt; {startPage:http://www.example.com filterGlobal:true startUrlHost:www.example.com filterHost: filterHostTLD: filterPathStart: filterPathPos: filterPathPosArray:[] filterPathNeg: filterPathNegArray:[] maxWorkers:10 maxDepth:-1 maxLinks:-1 maxRetries:1 logLevel:1 profile:false backlog:0} &gt; Type;Date;Backlog;Id;Level;Status;Source;Link &gt; LOG;2016/09/26 21:00:32 ;0;1;0;200 OK;___;http://www.example.com &gt; links;1 errors;0 total time;0.394023 time per link;0.394023 &gt; Total Link Count;1 Duplicate Checks;0/1;000.00% Host Checks;0/1;000.00% File Ending Checks;0/0; NaN% 
we have a number of distribution mechanisms still, so less moving parts is better.
Actually we have a similar issue at work with (only some) Java developers that came from doing Java for a long time, now working on Python projects and constantly wanting to bring in their Java ways into a Django code base, it can get quite frustrating there too.
what happens if you make a syntax error? is it smart enough to keep the old version loaded and dump the error in a prompt somewhere? also I think https://github.com/fsnotify/fsnotify is how other reload daemons work, instead of the millisecond scanning
Just to make sure I understand, you need a kind of 'variant types' right? If that's the case Go doesn't support it out of the box(unfortunately) so I would recommend you using an intermediary struct with a 'Type' field(string) and a field of type json.RawMessage to delay the rest of decoding. Once you find the type of device, you decode json.RawMessage into the appropriate structure and return it as an interface{} and then use a type switch to actually use it or even better return it as part of a struct with all the possible types as embedded pointers. Let me know if this helps. I could write some pseudo-code but I'm on mobile.... 
Good to know, Thanks for posting for future reference.
You can't get away without two unmarshals if you want to maintain separate types with common fields. You should ask yourself how a such decoder could possibly work.
You can do it with one unmarshal and then copying the common fields to the device-specific strict, but that's not much better than two unmarshals
(‚ï≠‚òû Õ°¬∞ Õú ñ Õ°¬∞)‚ï≠‚òû
Hah, so it's not an infinite stream of poo after all? That's a bit of a surprise. func Poo(w http.ResponseWriter, r *http.Request) { for { time.Sleep(100*time.Millisecond) if _ err := w.Write([]byte("üí©")); err != nil { return } } } 
I tried YCM, neocomplete and autocomplpop. I found YCM and neocomplete complicated and hard to debug. Autocomplpop was very simple, but not organized to extend very easily. So I forked autocomplpop (https://github.com/eikenb/acp) and have been pretty happy with it ever since. It is nothing super fancy like YCM but provides basic autocomplete functionality in easy to understand vimscript.
I've had a fairly good time with deoplete and neovim.
Regardless of the version or type the GC is not an option on driver/embedded/realtime development. &gt;&gt; I also believe, that when GC is not an option, people should just use rust. This is not always a satisfactory answer but seems the only option(i.e. use a non-GC language). For various reasons I think you rather end-up with C instead of rust so the modern C is actually still C.
This has been my experience with ycm as well. And I only have it because it's moderately useful for Python.
&gt; people should just use rust Yeah, about that - LLVM adoption is good, but not THAT good. Some devices are stuck with GCC 4.1 at best. At worst it some sort of custom C/C++ compiler. This is actually where I have a problem with Rust. Their feature matrix is nice, but hardware adoption is absolutely dependent on such from LLVM. P.S. There is also learning curve. Which, given the fact that the language is still changing, is high and unpredictable. P.P.S. I would pick C, if it would be up to me. Maybe C++ if I'm absolutely sure.
The number of bad things in the source is staggering.
This - deoplete is the only thing I really haven't had any problems with. 
AFAIR, YCM is using [jedi](https://github.com/davidhalter/jedi) for python support. If you're only with it for python, maybe you'll be better off using jedi directly?
fsnotify has problems with large amounts of files (lessons learned from working on GoConvey -- which uses the ms scanning method)... and can also have some cross-platform issues if I remember correctly.
Great news! I have implemented your struct merging suggestions. Thank you, you rock!
Thank you!
it's in my TODO-list actually
You can test like this: https://github.com/blue-jay/blueprint/blob/master/model/note/note_test.go. I could create a singleton factory, but most people are going to rewrite the models their way. And I'm using singletons, not global variables. Excerpt from https://github.com/blue-jay/core/blob/master/storage/driver/mysql/mysql.go#L51: var ( info Info infoMutex sync.RWMutex // SQL wrapper SQL *sqlx.DB ) // Info holds the details for the MySQL connection. type Info struct { Username string Password string Database string Charset string Collation string Hostname string Port int Parameter string MigrationFolder string Extension string } // SetConfig stores the config. func SetConfig(i Info) { infoMutex.Lock() info = i infoMutex.Unlock() } // Config returns the config. func Config() Info { infoMutex.RLock() defer infoMutex.RUnlock() return info } // ResetConfig removes the config. func ResetConfig() { infoMutex.Lock() info = Info{} infoMutex.Unlock() } // Connect to the database. func Connect(specificDatabase bool) error { var err error // Connect to MySQL and ping if SQL, err = sqlx.Connect("mysql", dsn(specificDatabase)); err != nil { return err } return err }
These must be the "globals" aikah79 was talking about (https://github.com/blue-jay/blueprint/blob/master/boot/boot.go): // RegisterServices sets up all the components. func RegisterServices(config *Info) { // Set up the session cookie store session.SetConfig(config.Session) // Set up CSRF protection xsrf.SetConfig(xsrf.Info{ AuthKey: config.Session.CSRFKey, Secure: config.Session.Options.Secure, }) // Connect to database mysql.SetConfig(config.MySQL) mysql.Connect(true) // Configure form handling form.SetConfig(config.Form) // Load the controller routes controller.LoadRoutes() // Set up the assets asset.SetConfig(config.Asset) // Set up the views view.SetConfig(config.View) view.SetTemplates(config.Template.Root, config.Template.Children) // Set up the functions for the views view.SetFuncMaps( asset.Map(config.View.BaseURI), link.Map(config.View.BaseURI), noescape.Map(), prettytime.Map(), form.Map(), ) // Set up the variables and modifiers for the views view.SetModifiers( authlevel.Modify, uri.Modify, xsrf.Token, flash.Modify, ) }
&gt; It's not true that you are expected to read or write only from a single go routine. If I have fixed size messages which are less than MTU, I can read from many routines as well as write from many routines, I don't see why it would be a problem. You should know this: This is unspecified non-portable behavior that you cannot rely upon ‚Äî you really do not know what the TCP stack is going to do with the received datagrams, and so you will have to deal with corruption in that case. If you are doing this, you are relying on a happenstance of your particular platform and system configuration which could change at any time. To be honest, I don't know of anyone who does that, save perhaps for people doing this over local UNIX sockets, which is supported, but that particular framing behavior (specification-wise) is unique to UNIX sockets. Therefore, I did not consider that someone might want to do that, and I have documented this quirk you mention as specifically-unsupported behavior. If you want to send data from multiple producers over a socket, you can always multiplex it using a goroutine.
Thank you
How about foreign podcasts section, for example http://golangshow.com/ in Russian?
&gt; There is also learning curve. The learning curve for C is probably higher. And mistakes are worse. &gt; I would pick C, if it would be up to me. Maybe C++ if I'm absolutely sure. Then you are being irresponsible. C is a DSL for CVEs
Serious, not troll question, does *any* major distribution still uses SysV Init?
Not everyone runs a "major" distro on their servers, not to mention non-Linux OSes.
Not sure if this is an issue or not, so I am posting it here: https://github.com/cedriczirtacic/g.go/blob/master/g.go#L66 Why check if the file exists first? It is generally frowned upon because the file system's state can change during the course of execution of the program. Here, if the file is deleted after you check for its existence, the call to Open will catch it, so you can keep it simple by dropping the first check.
This article feels like it's trying to convince people that choosing cgo is always a good idea. It's not; you should choose cgo when it's appropriate, and yes choosing LMDB for performance or libvorbis because there aren't any pure-Go vorbis decoder is ok in my book. However when there are pure-Go alternatives that are reasonably mature I will always choose them. For example, I would never link with the C libpq to talk to postgresql, or link to librdkafka to talk to Kafka, etc. I don't think anybody is arguing to never use cgo, we're saying it has a cost and if you have reasonable pure-Go alternatives you should chose that because it makes it easier for everyone involved.
do the tour https://tour.golang.org/welcome/1 1) you can't do var a := .... := is a short variable declaration with implicit type you can use inside functions 2) is an int array 
`a := &lt;expr&gt;` is a shorthand for `var a = &lt;expr&gt;` with special casing for if you have multiple variables on the left-hand side and some of them already exist. As such, `var a := &lt;expr&gt;` doesn't make a lot of sense; what would that expand to? `numbers := [6]int{1,2,3,5}` is thus * Declaring a variable with name `numbers` and the type `[6]int` * Initializing it to `[6]int{1,2,3,5}`, which, somewhat surprisingly, is actually a valid thing and sets the first four elements while leaving the last two initialized to 0.
Note that if there is no reason to distribute then GPL code can be used privately. But if you ever want to distribute then you'll have to share everything it links with to the entire GPL community. If you have one individual holding the copyright on original code and they want to share it with you, a friend interested in getting involved, my understanding is that this counts as distribution.
MIT if you want to keep copyright but allow free distrubution, modifcation, etc or CC0 if you do not care less what people will do with your code. Also, bear in mind that Apache 2.0 is incompatible with GPLv2.
Hi guys, just want to share with you a project that I worked on. It's a JSON decoder that is built for dealing with arbitrary JSON objects and is 2~ to 3~ times faster than the standard `encoding/json` (or some of the existing solutions). I created it because I searched for a decoder that can handle arbitrary JSON objects (and can work with `map[string]interface{}`), but is faster than the standard library, allocates less memory and is still safe. It doesn't do any magic or any unsafe stuff, I just wrote it from scratch with a lot of help from the `encoding/json` source code. I had fun to write it and hope some of you will find it useful. Please, feel free to give me yourfeedback, and of course any contribution is welcome. Thanks
Thanks. I'll definitely check that one out. For the exec.cmd...I prefer not to use it unless I absolutely have to. I guess I would rather venture to the world of unsafe and syscalls
&gt; the language is still changing Backwards compability since 1.0.
Tell me, who wants to use two entirely different languages on the same project (i.e. Go and C&lt;through gco&gt; )? I think a general purpose programming language should be great for 90% of its domain problem and good enough for the rest 10%. Rust is nothing like Go. It's a kind of safe C++. Zero cost abstractions but utterly bloated with all kind of quirks and tearse syntax/constructs. I would take C any day if I had to choose between Rust and C.
I think it all boils down to deterministic performance and realtime capabilities. A Go-baked solution would feel better than cgo or asm. I for once would like to mark specific parts of the program(i.e. a package, function etc) as `unsafe` so that it shouldn't be touched by the GC. That's it, memory would be managed manually. Maybe with some static analysis it could also be safe(i.e. like Rust does with its ownership model). 
You should probably make the poll interval configurable. Otherwise, there is no way to control the CPU impact of this package. e.g. if the files are on a high latency NFS server.
&gt; mastering and learning curve are slightly different things. Agreed. The thing is that you should master C before considering writing any serious software in it because of the dangers involved in releasing C software with bugs (most C bugs are memory safety bugs which are automatic security issues). &gt; Maybe you meant easier to learn than C++ not C. No I didn't. That's a given. &gt; It really looks like Rust was developed with C++ in mind So was go, just to be clear. People don't see that, but if you look at the Google C++ coding standards (and even more so, how it's used internally in practice) it's basically go. &gt; so far it's a complex and complicated language that I would use only if safety and zero cost abstractions are the most important things in your project. But that's my point. Safety should be a non-negotiable requirement in today's networked world. Which then leaves you with: If you need raw speed, you need to use rust and for the 98% of other software you probably want to use something with a garbage collector. &gt; To me a modern C would look more like Go without GC or with optional GC I claim, you either need to swallow the GC or maintain ownership information in source, which gives you the syntactic overhead of rust.
&gt; I would take C any day if I had to choose between Rust and C. Then we just have to agree to disagree. And I'll hope that you don't get your way and we eventually find our way out of the security nightmare we are currently living in with our C-based stack.
What are some key technical changes you made to achieve so much performance? That's a pretty huge difference between your lib and the standard lib. Are there other tradeoffs? Things that could be ported back to the standard library? Also, I see you mentioned you used MIT license but don't seem to have included it in the repo.
I got your point but I like to separete those checks because os.Open() will catch another file property errors like perms. There we are just checking if the user didn't wrote a wrong file path, the file was renamed or just deleted without notice before running.
How's it compare to https://github.com/tidwall/gjson
I'm also curious about all the above. Please share some of the details on how it's faster and how it works differently from the standard lib.
So, to give a trite example: Lets say you have an API endpoint that interacts with a WidgetService, and that WidgetService needs to access the database. In your main method, you would bootstrap the system. You'd load the configuration info from the environment, which would include the database credentials. You'd create the DB connection, and if it fails, you'd log and error and possibly terminate. Then you'd create a WidgetService with that DB Then you could boot your REST api code, and pass down the reference to the WidgetService into something that have your handlers attached to them. So that in your handler you can simply invoke the receiver of the handler (ex: (r *RestAPI) ShowWidgets(request,response) {...}, your receiver is "r"), and access the WidgetService. Now you've got everything being passed down from the top, created in a single location where you can control what happens if it fails and you can decide early on if any of the failure are critical and the app should terminate, and you can use an interface to make a MockWidgetService for testing, for example, if you need to. You never want to "new up" a critical dependency where it's needed. You always want to pass it down from the top, so that it's ready to be used by the code that needs it.
 status) status $app ;; As far as I know, the status command is part of upstart. If you are going to depend on upstart why write a 100 line init script when you can write a 10 line upstart service definition that does the same thing?
The "sleep 1" on line 20 will "reset" the exist status ( $? ) so your next test on line 23 will always succed. Also, you are testing that the application started, not that it's running so the comment is a little misleading 
What I'd like to see added to httpstat is a possibility to instrument an HTTP server with tracing, to get insights into the server side too. So, full end-to-end tracing of where a request spends it's time. Of course, that needs to be behind authentication, though.
&gt; Go and dozens of other languages are a real proof that safety is actually negotiable. Are you referring to the fact that go isn't safe in the presence of races? Because I'd agree that that's a problem. It's not an enormous problem, though, as such races will be very difficult to exploit in practice. If you are referring to the existence of `unsafe`, then I'd have to completely disagree. There is a qualitative difference between 1% of code being unsafe and 100% of code being unsafe. &gt; I think we need multiple implementations before to claim that the syntactic overhead of Rust is actually a requirement for safety. Go ahead and build one. When you are able to build a memory-safe and race-free language without a GC (and with decent speed), I might change my mind. Of course, if we assume an unbounded number of fantasy-languages that you could use to ship your software, I might change my mind about my recommendation of rust. However, as things stand today, I'll continue to recommend it absolutely in favor of C wherever possible.
Clarifying further, ``[6]int`` is an *array* of six integers which (perhaps confusingly) is different from a *slice* of ints which is more commonly used. An array is statically allocated and sized, while a slice can be dynamically resized, appended to, sub-sliced, etc. iarr := [6]int{1,2,3,5} // vs islice := []int{1,2,3,5} islice = append(islice, 6, 7, 8) 
Good addition, but &gt; statically allocated there is no interpretation of these words that I know of where they're true. Arrays are just as dynamically allocated just as anything else.
Well, the certs thing, which you would do using `net/tls`, it's similar in principle to this approach because certs are essentially private/public keypairs, much like what this library implements. There are a few practical differences which made me go the other way: * Certs have the additional complication of having to manage the certificate authority that emits the certificates, and possibly a revocation infrastructure. both for clients and servers. The whole PKI thing is also a bit of a mess ‚Äî you have to write extra code if you want to reject certificates not signed by, say, VeriSign... and you *have* to get that code right. * X.509 certificates (what you would use if you didn't want to be the wacko who reinvents the cert parsing crypto wheel) are extremely complex compared to simple base64 strings (what this library uses), and there have been vulnerabilities, sometimes years-old, in cert parsing code. * TLS (what you'd use if you didn't want to be the wacko who reinvents the on-the-wire crypto wheel) is extremely complex because of backwards compatibility reasons and the need to support many ciphers. This is all 100% unneeded complexity if what you want is to send / receive well-encrypted data between two private peers. Don't get me wrong, TLS is fine and dandy, very well supported in Go via the `net/tls` package, and many use cases effectively require you to use TLS. However, it brings in a *lot* more complexity than just handshake plus NaCL encryption, and that increases the attack surface. There's a niche in communications needs where TLS is overkill but plain TCP is irresponsible, and that is a niche which curvetls fills.
How about no?
I've often been disappointed that gophervids only has English content. Having people who could submit quality videos in other languages would be great, but the UI needs support for multiple languages.
inject automates wiring up the object graph. If you find yourself at a point where that feels onerous and error prone, it makes sense to automate it. My post is about decoupling all object construction into factories and hiding the difference between application/request scopes. Handlers come fully constructed and have no knowledge of where/how their dependencies are satisfied. Those factories could assemble the object graph manually or automate it using something like inject. Slightly different problems. EDIT: One of the advantages of encapsulating object construction is being able to try something like inject and roll back if you feel it doesn't work for you. The whole point of good design is to be able to try things out easily.
The motivation really doesn't say why you (think you) need `map[string]interface{}`, it just states you do. *shrug* `pquerna/ffjson` is a whole bunch of code that barely manages to be faster than `encoding/json`.
&gt; The motivation doesn't say why you need map[string]interface{} Agree. I'll add it to the README. thanks
That seems like an orthogonal problem more suited to something like zipkin.
A better way to put it would be "statically sized" since the size is known at compile time and can't be changed. Another nice property is that they can get allocated in-place while slices always have to go through a pointer to the heap. Barring escape analysis related heap allocations, arrays get to live on the stack or directly inside the struct that owns it, which is important for making your struct size/layout conform to C for ffi purposes. Edit: whoops, just noticed that your parent indicated static sizing already. 
&gt; Again, just so that we are clear what I am arguing here: Probably roughly 95% of software doesn't need to worry about GC pauses. For the other 5% of software, just use a memory safe, realtime-capable language like rust. I can't agree with that. If you follow that trail C++ should not exist. It would be C for the 5% where performance is critical and the rest 95% a 'proper' high level languages(i.e. Java). We know that didn't happen and developers chose a superset (c++) instead thus the reason why I'm advocating for a Go solution instead of interlop with various languages (i.e. rust, c etc) I don't see Rust developers writing web servers/frameworks or any other library in multiple languages. Why should a Go developer have to write the 5-10% in Rust or C? Unless the library you need already exists it is all or nothing.
I've been looking for something like this. The only thing I need that your library doesn't do is to marshal maps to an aliased type. For example, I might have this: type Attributes = map[string]interface{} Now I want this JSON: {"a": {"b": "c"}} ...to marshal into: Attributes{"a": Attributes{"b": "c"}} All the other types are fine. Is this something you would consider adding?
Each OS should provide an API for this. I hope you are not developing keylogger.
The set of errors reported by Open includes the ones reported by Stat, doesn't it? Note also that Stat can return an error if it failed to work, which does not imply that the file doesn't exist. See http://stackoverflow.com/a/10510718/124319. 
I don't think it's really orthogonal. I agree that zipkin can help here, too, but there is a difference between getting an end-to-end trace of everything for one request and getting a sample of traces for what the server is doing. The two can certainly interact though; using zipkin for the instrumentation on the server side and adding support into httpstat to trigger and collect a trace for a request.
This is a pretty good write-up: https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1
You can't error out on short reads from TCP connections, that'll break all over. https://github.com/Rudd-O/curvetls/blob/d5aa120e90731539d1d555f3fa3b85a296c77a06/curvezmq.go#L54
FWIW, I already blocked that bot, as I'm following the #golang hashtag and that bot basically doubles the noise there.
Awesome! I was just doing a simple httping tool last week to learn Golang, but my measurements with the standard library were way off... I was just measuring time before and after the GET is sent, so apparently there's a lot of overhead apart from the real RTT. I'll look into using this library instead.
https://github.com/mholt/caddy/tree/master/dist/init
&gt; The argument was not about writing parts of a single piece of software in Go and other parts in Rust. It was about different projects with different requirements. Well I'm talking about the same project with 95% of requirements satisfied by a GC language and 5% that require a non-GC language. e.g. A photo browsing app(95%) with a simple image filter&lt;5%&gt; (this may not be the best example but you get the idea). You need to write the filter in a non-GC language. Currently this can be done only using cgo or asm. I would prefer a snippet/package of 'unsafe Go' instead of cgo or asm.
4 . Thread local storage
&gt; The learning curve for C is probably higher. And mistakes are worse. Maybe. But I have established set of techniques. And tooling no other language matches. &gt; Then you are being irresponsible. No - being irresponsible is to pick a language from a company that continues to lose market each month. Sorry, but being a developer doesn't mean only picking a good language or nice technology. It's also about controlling risks.
&gt; a) I don't believe that is true, really, and b) then don't write such software in go. If you can't tolerate GC pauses, don't use a GC'ed language. And don't use C, because that is a walking security risk. Use rust. Well, I thought your initial stance was to use a GC language for 95% of the software and a non-GC language(i.e. rust) for the rest(5%) but I see that now it changed: If you have any low level requirement on your application you should use a low level language even if that requirement represents only 5% of the software. So this is exactly why I think we need a hacky/unsafe/workaround in Go to write this 5% without to rely on C or other languages. &gt; This is becoming really repetitive and tiresome, tbh. Agreed...
Perhaps I was sloppy with my terminology. My intent was to convey that a given ``[6]int`` will forever be a ``[6]int`` and can't be "resized" to a ``[7]int`` in the same way that a slice can be appended to. "Static" vs "dynamic" allocation (which I guess implies stack vs heap) is not relevant, so thank you for the correction.
&gt; Well, I thought your initial stance was to use a GC language for 95% of the software and a non-GC language(i.e. rust) for the rest(5%) but I see that now it changed: If you have any low level requirement on your application you should use a low level language even if that requirement represents only 5% of the software. Ahm. No. Nothing changed. My stance is, and always have been, that 95% of software works just fine with a GC language. And that you should use rust for the other 5%. You just gave an example of something that (in your opinion) belonged into that 5%. So, according to my stance, that example should probably use rust. &gt; So this is exactly why I think we need a hacky/unsafe/workaround in Go to write this 5% without to rely on C or other languages. So you want to poison 95% of software just to get around using a more suitable language for your 5%? I don't think that's a good idea at all (and, again, that is nothing new or changed. This is something I said in my original comment).
I've reported the account as spam to Twitter. It makes the #golang hashtag unfollowable
Edit: you are right. I'm looking into the fix. Thanks.
Would passing a db transaction in context be bad?
Done. Thanks! You rock!
[Livedev](https://github.com/qrtz/livedev) Dump error and panic in the browser with link to the source. Reload, restart and rebuild when necessary 
Python is still my first love since the community is very huge. However, there are already enough Golang packages to build an API with ease.
The requirements that lead to automating object construction or using Dependency Injection to hide object lifetimes have nothing to do with the language per se.
I really like the code man. This is a very pragmatic design. The non-orthogonality of filesystem event notification systems by the different operating systems really makes a general design based on events very difficult to figure out. This design fully centers around line 195, the polling part. https://github.com/radovskyb/watcher/blob/master/watcher.go#L195 I wish there was someting like an IMDB (internet movie database) for go code or something. I'd give this code like an 8.2. It's way higher than you'd normally see. You'd have to go take a look. This package is only 225 lines and it's a totally portable filesystem event notification system
Here is a little something I whipped up a few months ago. Basically I just wanted a little watcher to fire of `go test` when I changed a .go file. https://github.com/scottjbarr/watcher No tests, nothing fancy. Just built it quickly to keep my tests running. It uses github.com/go-fsnotify/fsnotify for file system notifications. Usage... watcher which defaults to watching the current directory, will run "go test" when files are changed. $ watcher --help Usage of watcher: -c string command to execute on change (default "go test") -d string directory to watch (default ".") It would be more flexible if I changed it to watch file suffixes other than .go but I haven't had the need, yet. 
Thanks a lot! I really appreciate that. I tried to make it's appearance look somewhat similar to fsnotify so it is easy to switch out for it if people wanted to use it :) That sounds like a fun project to build btw, the IMDB thing :P Maybe if I get bored I should start putting together something like that for a bit of fun?
That sounds like it was fun little project to build. The main reason I built this, was specifically because when I heard about using fsnotify, when I tried using it, when editing files in vim, I would receive about 5-6 separate notifications just when I modified the file, so it was quite un-natural for me to work around, so I realized that purely file system event based watchers would be a problem for me on my MacBook Pro. So this was really just a simple fix for that for me and seems to work well at the moment =]
Yeah, that seems like a better way to go. Thanks for the tip.
what if Receive just executes middleware functions? Define function for each switch case statement. type MessageReceiver func(state *persistentActor, context actor.Context) err that would enable building actors receiving pipeline 
They have everything to do with the language. You program for the programming language you write the code in. In Go, you avoid this requirement as it's not something you need to do.
Thank you! Which of the 12factor guidelines are you most interested in overall?
These seem roughly OK, if perhaps overly pedantic. &gt; [Use defer if its overhead](https://dmitri.shuralyov.com/idiomatic-go#use-defer-if-its-overhead-is-relatively-negligible-or-it-buys-meaningful-readability) is relatively negligible, or it buys meaningful readability Hmm, no. In my experience you always want to use defer by default, until profiling proves it worth optimizing away. It's insidiously easy to fuck up resource unwinding if you're doing it imperatively.
Why not telegraf? Just less popular?
&gt; That's the goal. :) No thing is too small to care about when you care a lot. Well, be careful. It's possible to overshoot and counterindicate your goal if you piss off your collaborators with changes that are, ultimately, very minor and not very consequential. Trust me. I've been there. &gt; but my suggestion was to write: Yes, I got it. I'm saying that's premature optimization, that using defer is perhaps negligibly more readable, but definitely moderately safer, over the lifetime of the program. (And hopefully you mean c.mtx.Lock/Unlock!) In your linked issue you've benchmarked and proved a ~5x speedup. That's good, that's the baseline for considering a change. But what is the impact of that speedup at the package level? Can you demonstrate higher-order gains? If not, I'm not sure it's necessarily LGTM. ns/op is not the final arbiter :) https://twitter.com/davecheney/status/781054998054514689
They compile to _exactly_ the same assembly; you must admit the second form is more readable, right?
Yes, I know that's the behavior. But it's rarely the behavior you want, because it lifts the Lock and Unlock methods to the Cache object, which means other packages can invoke those methods externally. When you have a mutex guarding some internal state, you typically want the mutex to be inaccessible.
The `Files` slice looks a bit racy if you have multiple goroutines adding to and reading from the slice without any synchronization.
I agree with that tweet, and I really do think the 3 lines of Go code without the extra defer is equally readable as the version with defer. I see `defer` as an extra keyword (which has a little performance and mental overhead) and I think it should be added when it provides some value. It shouldn't be added if it provides no value. At least that's my current opinion. I'll think more about it and see if it changes.
&gt; Well, be careful. It's possible to overshoot and counterindicate your goal if you piss off your collaborators with changes that are, ultimately, very minor and not very consequential. Trust me. I've been there. I understand. I think it goes both ways, it's also possible to overshoot and upset contributors by rejecting their PRs on the grounds that it's "too small of an improvement to bother merging in". In the end, you can't please everyone. I see your point, but I accept the consequences. I want to work with people with high standards and I'm ok if someone gets upset because I want higher quality code. I'm always looking to improve, I want to collaborate with other people who do too. 
I would consider a couple of changes. Use an interface for file info, expose poll duration (as a duration, not a ms multiplier), and add a rw mutex in the watcher. I think this is a handy package. We rolled something similar when we learned that fsnotify has system limits where only so many events can be tracked at a time, leading to lost create events in our case. Polling alleviated the concern.
Hey there! I'm not exactly sure for what file info you are referring to since the main file info is just an os.FileInfo interface (at least it is since my last commit). If you meant with how it was a slice of File type, that's changed now, since I've replaced the slice with a map of pathname's for keys and os.FileInfo's for values for speedups when returning the names of changed files etc. I really like the duration idea, thanks for your feedback! Edit: I just realized you might be talking about the fileInfo struct. That is purely for mocking an os.FileInfo object when using the Watcher's Trigger method to trigger events, in case an os.FileInfo is not given, to avoid panics if someone tries to access an event name from an empty os.FileInfo...
&gt; I want to work with people with high standards Sure! Definitely. Just make sure your opinions are actually &amp; justifiably higher in their standard, and not just pedantry for its own sake. (Again, speaking from hard-won experience, here.)
I agree, also there was a very recent optimization submitted for defer: https://github.com/golang/go/commit/f8b2314c563be4366f645536e8031a132cfdf3dd From the commit description: **In reality, this speeds up defer by about 2.2X.**
I already bought "API foundations in Go " so I will also buy the next one you write. ;)
Testing Gin is not really different from testing `net/http`. IMO this blog post would be much more useful if it showed how to write testable code that dealt with dependencies(config, db, logger etc) and showed how those dependencies are passed down. The current examples look as if you're pulling the important things out of global scope in the package. 
source: I read a lot of code reviews. For more specific examples: mutex "hat": https://talks.golang.org/2014/readability.slide#21 error names: https://talks.golang.org/2014/names.slide#15 comment spaces: https://golang.org/cmd/compile/#hdr-Compiler_Directives s == "" : the tool chain uses this a lot, and including the converted source code 
Thanks for digging those sources up, I'll incorporate them as references.
the error names slide seems wrong. capitalizing a variable name in Go has implications. i prefer `fooErr` to `ErrFoo`. when i am reviewing code an see capitalized variables, i get triggered to start looking for visibility concerns. human linters shuold be taking into consideration too
Absolutely right. See commit message in https://github.com/shurcooL/go/commit/1ab69ca4f77382ac0529be9cf93df0502236e817. :)
&gt; The one that makes the code clear. &gt; If I'm about to look at element x I typically write &gt; len(s) &gt; x, even for x == 0, but if I care about &gt; "is it this specific string" I tend to write s == "". Exactly. I need to clarify that suggestion. I meant for it to apply only in the specific situation where you want to check "does this string equal to empty string." It doesn't apply if you want to check other things.
&gt; almost everything Yep, everything. There are no more gist packages that exist. Only exception are in other people's repos where they vendor really old copies of my code.
Agreed. :)
`ErrFormat` is an example of an error declared (and exported) at the top-level of your package. 
I thought I was the only one that had to look twice at the error names slide. After a second look though it is indeed correct but the way it is written it makes a little confusing.
gO?
From personal experience I'd recommend PostgreSQL over MySQL but that's just me. What kind of data do you have and how large is it/will it be? There's also a very good Elasticsearch client at https://github.com/olivere/elastic that I've been happy with if you end up going that route. Whatever you end up using you should consider creating an interface for the backend methods so that the backend can be swapped out easily in case you do decide to move something else later on. Look at https://appliedgo.net/di/ for more details. 
It is called duck typing, not really applicable to go but in other dynamic languages testing "if it quacks" is better than "if it is a duck"
Oops. I *knew* I got it wrong again!
I've seen a lot of Python bugs caused by Falsey/Truthy.
Yeah, that's the negative impact, but on the plus side it also perfectly copes with stuff that's not a string but behaves like one, something go can't do
Also would read it. Suggestion - create a Github repo (if you haven't already) and let people submit ideas for the book in issues.
In this case, it's too clear the confusion about where your executed block starts. The `{` are what is making this necessary.
is it just to make the parser easier? there's not really any confusion, it seems, since you know you're inside the struct constructor.
Not only for `if`, but also `for` and `switch` statements there is a parsing ambiguity: when the parser is past `x == foo` and sees `{` there are two possibilities, `x == foo` is the expression and `{` begins an block, or `{` begins a composite literal of type `foo`, so `x == foo{ etc` is the expression and somewhere down the line another `{` occurs, which begin the block. Note that the compiler in general does not know what is `foo`, it might be declared later in the file or in another source file. Enclosing the composite literal with parentheses resolves the ambiguity, because the parser encounters `{` in the context of parsing an parenthesised expression and these cannot contain blocks. 
Could you answer here? With all due respect, I'm not curious enough to create an account on your website. You don't even have support for federated login. I don't need another set of credentials to manage.
To be honest, I'm a complete newb to development so any bit of wisdom in the area will give me an interesting read. 
This is interesting, but I wonder how it is useful. Most of the time you write code so your other coworkers can understand it, not the computer. Cases where the code works but is obscure indicate code smell at best. So to me there would have to be a very compelling technical reason to lay out your code in any other way than the standard initialization order. Otherwise, I would reject that during review and ask it to be changed.
Looks like it was fun to build :) The main reason I built this though was to not have to use filesystem events. For example, using something like `fsnotify`, just because I can see that as one of your imports. I like that sort of application though, reminds me of something I built recently that restarts processes and runs commands too by watching for failed processes. It's called `gobeat` if you are curious.
Ah, got it. Thanks for the excellent explanation.
The best use case for me at the moment are variables declarations across many files in the same package (last example). Initialization of variable "a" i a.go depends on "aa" from b.go and the same for "b" from b.go relying on "bb" from a.go. It could make sense to use two files for better organization. Agree that abusing it is rather bad idea.
access_token must be Access_token, i. e. exported
-_- thank you&lt;3
[removed]
[removed]
Generally it is a desirable property that languages are parseable without knowing type information, so that you can implement parsing and the type-checking in two completely separate steps: tokenization -&gt; parsing -&gt; type-checking -&gt; optimization -&gt; output This is also desirable because otherwise other tools that need to be able to parse the language (syntax highlighters, formatters, ...) that would otherwise be very simple would need to be very complex (and slow) and perform type-analysis on the code. Since the compilation process is factored this way, at the time when the { is encountered, the parser doesn't know yet that "foo" is a struct constructor, it just sees an identifier (or in general, some token) that could be anything. So it's not possible at that point in time to know yet how the code should be parsed. Whether making the syntax work this way in the first place (rather than e.g. always requiring the () or perhaps to use something other than {} for struct initialization, and to keep {} reserved for blocks) was a good idea could be argued about.
&gt; this is pretty annoying because I dont want to push the code to github anymore. Then don't :) &gt; Id like to be able to at least access my local project packages from another package. What is the issue with that? Put the local project somewhere in your GOPATH, then import it from there. &gt; is there a way I can do everything locally like building and running Yes. Just `cd $GOPATH/github.com/youraccount/yourproject` and do `go (test|build|install)` from there. &gt; regardless of where I place the application on the machine? Technically yes, but you are really in for a potential world of pain if you don't utilize your GOPATH. Overall, I don't really understand your problem. Your GOPATH is local, on your machine, it has, a priori, nothing to do with github, git or anything. `go get` fetches there and you'll likely also `git push` from there, but apart from that, there really is no connection between it and your github account.
Source code: https://github.com/google/election-au-2016
Also in an expression of the form `&lt;-chan int(c)` it's ambiguous if it's: * a receive operation on the conversion of `c` to type `chan int` * a conversion of `c` into the type `&lt;-chan int` But it is implicitly resolved by the leftmost derivation provided by Go's recursive descent (LL) parser.
Because the parser sucks. This should be classified as a bug as far as I'm concerned. 
Cool. I've actually been implementing something very similar at work, but instead of using Amazon KMS, we use our own home-grown HSMs for key management. 
K. Guess I'll stick with Javascript then.
I will consider [PM2](http://pm2.keymetrics.io/), but yeah, docker is not going away... Docker is an easy choice to get orchestration up and running (See my [article on a fault tolerant Docker Swarm cluster](https://scene-si.org/2016/08/17/setting-up-your-own-docker-swarm/)). And of course, migration to the cloud is a big yay factor in the grand scope of things. Docker is very much the low-price equivalent of Amazon AMI, which you can run on your laptop at zero cost. Zero cost is a good bootstrap, considering you have so many Docker hosting PaaS providers now which enable you to scale later on.
Committers burning out seems serious concern. Wish some kind of rotation or sufficiently prolonged breaks from Go project be there.
"Can't use Go because it lacks generics. Instead, I'll use this other language which lacks both generics and strong types." Cause that makes sense.
What were you actually trying to do? ( http://xyproblem.info/ )
He's a teen troll, look at his edgelord comment history
&gt; problem is im pushing to github to import code but it is in the same application on the same device? that doesnt make sense to me. You don't need to involve github at all, ever, unless you want to publish something &gt; when i try to import a local package in another package in the same app it cant be referenced e.g. ( import "../model/DAO" ) You can't import `../model/DAO`. Import `path/to/model/DAO`, i.e. use the full import path. The code doesn't need to live on github, but it does need to be in your GOPATH and you need to give the full path. The fact, that a lot of import paths contain `github.com/username` is, that an identifier for a package (in whatever language) needs to be globally unique. Other languages solve this by having a monolithic, centrally managed namespace. Go doesn't (or rather, `go get` doesn't). It implements a discovery-mechanism, where the identifier of a package (it's import path) contains a domain as the first component and then leaves it up to the domain-owner to guarantee uniqueness. In github's case, that's achieved by delegating one level down, making your username the second component and the repo-name the next and giving you the control. If you do not require the globally unique namespace, you could also choose to not use the domain name in the import path (so you could put stuff in `$GOPATH/foo`, for example). In practice, that's discouraged; it will prevent you from ever publishing your stuff, as the history will contain import paths like `foo`, which don't work with `go get`. Which is why most people still put their code at `github.com/foo/bar` - even if they don't intend to push it actually to github. But it means that they still make it part of the identifier, to preserve the option to do so later. But, at the end, the only requirement is, that a) you choose a unique import path for your project and b) you put your code under `$GOPATH/&lt;import path&gt;` and import it as `&lt;import path&gt;`. I, personally, have my own domain (let's call it `example.com`) and habitually start new stuff in `$GOPATH/example.com/pkg`. 99% of that never makes it to github (or bitbucket, or whatever), but it means if I *choose* to publish one of them, I can just push it to github, point my webserver to that repo and all the import paths already line up to make `go get` happy. This is a bit long and rambly, but I hope it at least *somewhat* helps. The one thing you need to remember is, that just because an import path has a `github.com` in it, doesn't mean you need to fetch it from `github.com`, it just means it must be under that particular path on disk. And don't do relative paths for imports, but always the full import path.
I also suggest you to change this piece of code: body, err := ioutil.ReadAll(res.Body) [...] Token := AuthToken{} err = json.Unmarshal(body, &amp;Token) ... to this: Token := AuthToken{} json.NewDecoder(res.Body).Decode(&amp;Token)
That makes me think it's pretty poorly explained. It reads very prescriptively about logging and events in that item with terms like 'never', where routing to a service like Loggly is a routing choice that potentially includes a custom handler (even if you treat it as an attached resource), and attaching to an message bus and sending "events" is also both routing and different from your logging concerns.
yeah. i think its relatively confusing alright but im learning. yeah. the fact that a lot of examples are using github.com in their folder struture suggested to me it was being retrieved from the remote repo. lol. 
That was actually the first way that I tried it, as I found a SO post saying that's best practice, but when I tried it I was having the same problem I posted here to solve. I'll update to use the json decoder.
I came to Go from working mostly C89. I recently started a C project after leaving it for a while, and wanted to do something concurrently...and then I wanted to test my code...and then I wanted to benchmark my code...and then...
&gt; I think it's the indirection that comes from the approach Go took on this. It's probably a combination of that and function call overhead (though I don't know in what proportion) as I'm guessing the generated versions benefit from inlining (I haven't looked at the generated code, so this may or may not be obvious).
[removed]
I started using GO because I needed to develop a highly threaded app that would deploy via docker containers so needed a small footprint. At that time Python (my other language) was suboptimal in both of these areas. I quickly turned from a GO skeptic (*another* compiled language? From Google? Cocky !) to a GO zealot. Everytime I'm asked to write something in Python or bash now a bit of me dies inside.
Your fellow Rails developer should try using Docker images for deployment.
"back end development int Go" is very good. I have built about 150k lines of "back end" code so far. Libraries are extensive and well tested. Documentation is excellent. Tools are comprehensive. 
More libraries is not necessarily better. When I setup Angular2.0 with NPM I get over 18000 libraries. That is a *LOT* of licenses to verify and a *LOT* of points of external failure to deal with. node/npm has a more libraries that cover more cases but it is at a cost too. 
came to Go from the opposite direction...got tired of wrestling with Haskell, i needed a tool that was a little less rigid
My bad.
Yea that's what I suggested too. He didn't like the extra level of abstraction. I can kind of understand the sentiment.
It's really only about namespacing (apart from go get). If you have two LDAP implementations, how do you keep the packages (both named "ldap") apart? One way would be to require all package authors to agree on who owns the name "ldap" but this doesn't scale. You could also generate random strings to prefix the import path with but no one can remember those. A common approach is to piggyback on the DNS. It already exists and there are procedures setup to acquire and release names. It's more commonly seen in its reverse form (where a path is denoted by e.g. com.reddit.x.y.z) but it's the same basic idea. It's just a convention, though. The build tools don't care. They just take the import path and search yor local file system for source files. No one prevents you from calling your packages however you want. So if you don't intend to share the package, go on and call it "ldap". Or "example.com/ldap". Except for "go get" everything will continue to work.
&gt; but I do sometimes miss generics Go has generics in exactly the sense Python has them: `interface{}`. The only difference is the boilerplate in Go required to opt-out of the type system (i.e., type assertions).
This is my personal opinion, but as someone who works in Ruby and Node a lot, for building backends, nothing touches Go. It's not as slick as ruby with syntactical sugar, but the static types and compiling more than make up for that. It's super reliable and very easy to reason about. The only thing I wish they would work out is a better package management solution, and generics might be cool, but not necessary.
Huh, that looks weird... Any link?
[Here](https://medium.com/friendship-dot-js/i-peeked-into-my-node-modules-directory-and-you-wont-believe-what-happened-next-b89f63d21558#.xldddrbr4) you go. Edit: this is a joke article apparently.
Thanks. It's good to hear that it's opinionated. After working for so long with Js where there are a million ways to do things, and then using a framework like angular 2 which is pretty opinionated, I love it. You know exactly how you should be doing things in your code.
then...then...I needed to append something to an array
that was a joke article thankfully
Ah! I thought so! I was so confused he was saying things like 'searching on google' and then linking to Bing. Thanks for letting me know.
Much of what is in that blog post isn't true
What's the point with these patterns? If you care about size why would you ever use a container including build tools and what not in the first place? You might want to try the KISS pattern: simply leave off all the containerization (except where required by infrastructure needs) and yield a 10x reduction in complexity.
Three words: Multiple. Return. Values. HOW IN THE WORLD ISN'T THIS THE NORM.
&gt; You might want to try the KISS pattern: simply leave off all the containerization (except where required by infrastructure needs) and yield a 10x reduction in complexity. sounds great. is there a dockerfile for that i could try?
Honestly for me Go fits exactly what I've wanted out of a platform for a long time. I prefer static typing, I feel like dynamic typing is a large gun that is always trained on your foot. I prefer compiled over interpreted, because performance tends to be better, and because it helps find defects earlier, like a required form of static code checking. I like simplicity - I always despised the Java/C# ways of turning a simple requirement into a sea of interfaces and abstract types and factories and then writing some XML to wire it up in your IoC container and... ugh. The Go Way is to keep things simple, and I'm on board with that. Garbage collection for me is a must - it eliminates a whole class of potential defects. Most of all though is the "here's a binary, run it" deployment. You don't need ruby or node or JVM or CLR installed, no shared libraries or ruby gems or npm modules, you just need one binary file. I keep my source code to myself unless I choose to publish it, and I get to ship a binary that you drop in and run and it works, period. Cross-compiling the same code for windows/linux/mac on x86/x64 is a breeze, and platform-specific code is easily managed. I'm really resistant to hype but I feel like Go really hits a sweet spot, at least for me. It's not without its faults, of course, but in terms of pros/cons I can't think of anything else I would rather work with. And yes, every time I need to install something made with ruby or node I cry a little bit inside now that I've gotten used to go.
Ah, I saw a post by you on their blog, but failed to initially notice that they were just republishing it from your blog.
thanks. Ive sorted my issue now. guess it was a misinterpretation of the docs on my part.
Wot?
Working with JSON is awfully annoying in both Go and Rust (especially Rust). You'd think that they'd have a cleaner way to do it since it's such a common function in web dev.
python is interpreted, rather than compiled, like go?
This is great. Since the conversation about vendoring during GopherCon 2016, I haven't seen news about a possible team responsible for spearheading package management and/or vendoring. Is this happening? Or is it still too early (or even improper) for that right now?
That's what my team did on a past project. And we deploy targeting a big financial corporation and some of its clients. Though, I would love to be using Go for all that instead. But I think the team will decide to go with Java and Groovy.
Yeah Go is really attractive for * Solid base library * Good documentation * Performance * First class concurrency primitives * Lack of dependency hell causing 100 MB shit * Quick compiles * Static native code for not even runtimes * Standardized format (gofmt) * Sane non-overengineered documentation (godoc) Not many languages manage to tick these boxes and in hindsight that almost feels weird since much is obvious! Even details like built in, smart concurrency features. Of course a modern language in a world of quad and octo core CPU's need that, for example. Of course standard docs should be easy to write by hand with no XML or tagging given the importance of convenience to make documentation happen in the first place. And so on. 
It's interesting, but a friend actually asked me "are you going to make a linter that checks/enforces all those?" I don't have such plans. Many of them hard to enforce/find with a linter. The point of all these is they're great items to catch and link to during code review. Instead of having to re-type an explanation, it's easier to link to something. &gt; When a team-mate errantly removes the whitespace (and passes all unit tests and linters), Does your team follow the Go style? Are your teammates familiar with https://golang.org/doc/effective_go.html and https://github.com/golang/go/wiki/CodeReviewComments? Do you do code review? Did you see/read https://talks.golang.org/2014/readability.slide#21? Mutex hat is not my invention, it's what all the high quality Go code I see does. Some newer people to Go don't know about it, but otherwise it's really easy to spot and recognize. None of my suggestions are about changing how people do something, it's meant to answer the question of "which decision does most high quality Go code make about this irrelevant style choice."
You could check out Gabs: https://github.com/Jeffail/gabs
The only reason our go apps are containerised is the packaging format and integration with mesos\marathon. much &lt;3 for a 3 file deploy (binary, root CAs and cert and key (tempted to shrink this to a single file and build the certs into the binary))
What made you tired of Haskell?
Go has the other kind of dependency hell. You can't state your versions, so every single one of your dependencies and indirect dependencies have to be API-compatible with each other. The vendor folder hides the issue by committing the current, presumably working, version of your dependencies to source control, but you will have to deal with it again when you update dependencies.
What are you confused about?
Templates are a form of generics.
Rob raised some good points about the C++ mindset, but I think an issue still hidden is the inherent brainwashing of programmers. Most programmers are extremely rigid about oop and its offshoots, many have never written non oop code ever. That's why most programmers hop around oop languages and try to force every tool into an oop sy context. A language like Go that requires a reevaluation of almost every inbred concept is hard to swallow . Go is almost atheist in the religion of programming languages.
FWIW 2 pointers (value &amp; type) is the same overhead as python and other dynamic languages have, where an object is passed by reference (pointer), and contains a pointer to its type information.
Same here. Go really is a great general-purpose language for modern systems development.
Honestly, the main point about logging was that there should be just a facility which allows streaming for your non-essential logs (access logs, specific example). The logs might indicate behavior when processed, but the principle indicates mainly the way you should produce them. Not all logs are created equal, so you have things like Errbit, Airbrake, Rollbar and Sentry that take care of error logs for example. And in the same fashion, if you have other output which doesn't fit into this mold, your best bet would be to implement it with other guidelines in mind - and the backing services fits the bill. I don't think it's poorly explained, but it is open to interpretation. You also have functional and objective oriented programming - both can deliver solid apps, but it's up to the programmer to apply these techniques correctly :)
Swift allows for multiple return values. Not sure about Rust.
You should be more concerned in an equivalent position, as the Go library may have less road hours than Ruby on Rails and contain bugs we won't know about for years, that Rails already figured out and forgot a bunch.
Even in a dynamic language, if you don't know the structure, or if this structure change, it's a pain ! Just that this pain is not at the same place. In Go you have to decode early, before you can use your data, your Go struct is self documented, you can use it safely. In a dynamic language you decode blindly and you don't know where your problems will land.
Really interesting, thanks for posting this! I rarely expect to see anything about reverse engineering outside of /r/reverseengineering or /r/netsec so this was a pleasant surprise.
This is something I've been thinking about for a while (I'm not talking about the readability issues but about the performance). Shouldn't be the Go compiler able to compile these two code snippets into the exact same set of instructions? func (c *Cache) Set(key, value string) { c.mu.Lock() c.cache[key] = value c.mu.Unlock() } func (c *Cache) Set(key, value string) { c.mu.Lock() defer c.mu.Unlock() c.cache[key] = value } Or is it difficult to identify such cases? Am I missing something?
Among many other good things listed here, one thing I found to be perfectly natural and effective but lacking in all other languages I used is package file structure. I don't want to lose time on overly organizing my code, moving functions from file to file then updating "import" hell. Package is just one folder with bunch of anonymous files. They are all imported, you don't have to think about inter relations or contents. Place code where ever you want, change, rename files etc. It is a big time saver, same as gofmt.
Thankfully there's `realloc`.
"C++" I'm guessing? Or this https://en.wikipedia.org/wiki/Actor-Based_Concurrent_Language#ABCL.2Fc.2B ? For C++, search for "cgo"
Thanks a lot, mattermost looks really interesting, just what i need to get my head round the file layout and things like that!
Isnt it too early for Angular 2 because all examples and stackoverflow answers are still v1.
Maybe, I will be using AngularJs(Angular 1) for it. Angular 2 is still a bit to large and new for me to bother, I use angularJS professional and there are no talk of even bothering to look at angular 2 yet.
ditch angularjs and use angular 2 WAY better, and use it with Typescript. Type integration just makes JS a beautiful experience.
Any reason you before 2 to js, apart from typescript? I don't mind using 2 if its a lot better at serving or its general easy/quicker/better? Just I don't want to have to learn typescript/angular2 and Go if the difference isn't huge.
I guess the immediate answer is: No, Go doesn't support C+(C++) -- comparing to C++ supports C
ReactiveX is a great idea for any language. It's a shame it can't be implemented for go.
DO you know any OO language? then you'll learn typescript in 1 day, be fluent in it within 3 days (see plural sight courses on Typescript and Angular2). Do you know Angularjs? then A LOT of concepts are in Angular2. But Angular2 API is way more organized and does not feel hackish at all. NO $scope crap, no useless Services, Factories, Providers all doing the same thing. In angular2 you got components and services that's all. You don't know angular.js? then go for angular2 it is easier to learn. Angular2 is way more intuitive, it learned from react hence it uses components instead of weird mvc architecture and humongous controllers. Components are just more intuitive and feel natural. Also trust me in this one I used to think typescript was yet another JS tool, but with Typescript you'll be using good practices and latest features from ES6. Once you go Typescript you will love even more JS. Imagine the power of OO language, its structure with the versatility of Javascript that my friend if Typescript. Typescript is here to stay even React can use Typescript and I think the future of JS will be Typescript, Angular2 tutorials are in Typescript google is encouraging its use so its backed be a strong community, microsoft and google.
Can you name a language that's 6 years old or younger that's more widely used than Go?
On the other hand, actually being able to use tuples everywhere else, as opposed to only for return values, would've been great.
You can use plain JavaScript with Angular2 as well, though I am personally looking into learning TypeScript in my next project so that I have the benefit of the type checking in my IDE. Angular2 is different enough that you won't save much time by knowing 1 if you start with 1 and move to 2 later. Massive companies ariund me already used 2 even before release because it is so much easier to learn and more reasonably organized. My team isn't looking forward to our migration from 1 to 2 on our flagship application, but we probably saved a little time by using 1 with only directives and no controllers. It'll still be a ton of work. As far as using it with Go goes, I don't think there will be any hitches. Go is quite a comfortable and peformant approach, though so much logic will be front end that most languages wouldn't prove too painful.
Twitch is written mostly in Go as well, if I remember correctly.
py2exe works but can be a pain sometimes.
Sure, planning ahead of time and good documentation of your API will save you a lot of headaches. But a lot of the times API resources take in completely different payloads. Having to create a struct almost per API resource is a big pain.
Big established languages have a surprising amount of momentum. I feel like most developers have been exposed to other "backend" languages like Java, C, C++. Go is fairly new and you have go out of your way a little bit to learn it. Honestly I'm surprised Go is doing as well as it is for only being 6 years old. It's in the 19th position of the [Tiobe index](http://www.tiobe.com/tiobe-index/) and compared to other more mature languages but also relatively newer languages like Scala (#32) it seems to be doing well. 
Nice cheers for the explanation, I'll give angular2 a go!
Sure. I think that's a reasonable request, I was just pointing out that you're not going to get that with Python. I wouldn't give up on Go though. Go has great profiling tools that help you optimize such that you can make Go very fast, and generics aren't actually necessary all that often. (All that said, I'm with you in wanting a good generic system).
although scala borns in 2003, it was only for academic purpose and start to becoming known since 2008 with the first book "programming in scala"...scala is probably the most popular "new language" so far...
There is tuple syntax in C# 7.
I thought Groovy was dead...
Docker is what gives you reproducibility of your configuration. If an image works on your machine, it's almost surely will on some other server somewhere else.
Scala is a great language, but it is not more widely used than Go. Not even close.
yeah, right on. wasn't sure which thing you were talking about
What benefit does having a container to build the binary have over just cross compiling using the standard Go tools and adding it to a container?
Concurrency is difficult in any programming language. It requires different ways of thinking about problems. I predict you'll hit similar problems with Rust too.
...which requires so much boilerplate to get right. every time i see ptr = realloc(ptr, size); i'm ready to shoot somebody.
&gt; Parsing json objects into Go structs or putting everything in a map[string]interface{} and having to encode/decode really annoys me. Are you manually creating Go structs for your JSON? Cuz yeah... that can be a bit of a pain :) Have you come across https://mholt.github.io/json-to-go/ or http://json2struct.mervine.net or https://github.com/ChimeraCoder/gojson? 
I completely agree. The problem though is that Go makes concurrency easy, but doesn't do much to help avoid accidentally writing unsafe code. Some features of Rust that I really like in this regard are: * Parameterized mutexes and destructors (the compiler can guarantee that mutexes get unlocked; defer is often not good enough) * Borrow checker prevents unsafe data access * No global/module level mutable state (encourages better design) I feel like it makes bad design obvious, which forces the programmer to think. Go makes it too easy to make assumptions and end up with a poor design. Race conditions are still obviously possible with Rust, but data races are preventable by the compiler. I expect to run into concurrency problems, but I expect to avoid the hard to debug/reproduce data corruption bugs and just have to deal with logic issues.
The main advantages go has over other languages I use(d) (C++/C/Java/Python/...) are for me: * syntax formatting standard: `go format` * diving into the source code of the stdlib and other libraries feels natural * it's development environment encourages writing everything as a reusable library, where your app is a small shim around this. This results in a ton of useful reusable stuff. * built-in test and benchmark framework * cross-compiling is dead-easy * simple concurrency * built in production-ready webserver * `defer` For scripting languages, the static typing, compile-time warnings and ease of deployment are a big win. There are however also some downsides/problems imho: * the library versioning and vendoring mess * the GOPATH stuff that needs to be updated for each project if you want to cleanly separate them * some bad early stdlib choices, where some things don't use interfaces (filesystem stuff for example) And then there is stuff I have mixed feelings about like like channels. Nice to have in some scenarios, but with many more pitfalls than many seem to realize. But writing code in it is fun, and feels productive. Not perfect, but all in all, one of the nicer options out-there.
People are using defer to unlock mutexes?!
wrestling with it....and not all wrestling is the result of programmer stupidity or laziness...i think even most Haskell fans accept that
what are you guys using? React or Angular.js? Justify it saying angular2 will give a boost in productive plus a more cohesive and robust code base. A senior dev must find arguments to convince business people. At least try :)
Worked great on windows! Still in production. Pain in the ass on Ubuntu. Switched to writing a Java jdbc to csv Export there.
Here is a project I worked on almost two years ago. AngularJS + Go + MongoDB http://mongolar.org/
If you are so smart, why do you ask such dumb questions?
Agreed, and outside of Spark etc, hardly used at all. Scala was saved by a killer app
Can I ask you a couple of questions? How good is the generated JS code from typescript? My question has to do with how easy is it to use the generated code with developer tools in the browser ? If you have to debug or profile (or chase a memory leak) an app on chrome dev tools how easy is it to follow the generated JS in relation to the actual typescript code? Also, how big (in size in proportion to the original code) is the generated code? Are the generated sources relatively small (meaning could they be used over a not so great mobile network)? Thanks in advance for the answers.
Generated code is perfect I heard it used to be problematic in the past but that was long ago typescript is now on version 2.0 it is very stable 
Nah man I have been using angular since beta and trust me there is plenty of documentation. It easy easier than angular 1 and you will love typescript 
Yes it tells you the file and line of error and type of error. Remember that typescript is busy syntactic sugar built over es6. So it is JavaScript but with kickass sintaxis. Forget about weird ass modules. Give it a try you'll love it 
Thank you for the answer. I will look into it. 
The most popular application of `defer` is for cleaning up or otherwise releasing resources that were acquired within a function. C++ does the same thing with RAII, though it's far less clear since destructors are invisible function calls. I find `defer` to be much better for this purpose.
The solution to the problem is an optional or maybe return type, or exceptions (or both). These are both way cleaner and clearer than multiple return values. Go's multiple return values were intended for errors. This is an improvement over C for sure, but still has downsides that the alternatives mentioned above do not suffer. For example composing functions that can fail, which can not be done in Go.
Assign before passing, pass the function instead of the result, or let it blow up returning crap with the outside function dealing with it; all depends on what the functions do. The simplest solution is to just assign before passing and doing the checking there. Keeps errors explicit and accompanied with explicit handling.
&gt; You also MUST use TypeScript Wrong...they're working on the ES6/JS guides as well as guides in Dart. 
I'm building small network tools as an exercise to learn Golang. I'm not even a developer, so I'll be more than happy to hear all criticism, suggestions and feedback in general. In this case I took an existing tool, forked the repo and expanded its functionality.
Yes, that's a completely reasonable use of `defer`, and what it's supposed to be for. However, mutexes should be held for as little time as possible. Ideally you refactor your code as necessary so that you can grab the mutex, do all the manipulation of shared state, and then immediately release the mutex. This is not _generally_ compatible with the semantics of `defer`, which are "do any number of things, including the specified thing, on leaving the scope of the current function". Sure, there may be situations where you have no other deferred cleanup, and the last statement in the function is also the last point at which you need to access the shared state. In that situation, defer would be fine, albeit adding some overhead. I suspect that precise situation is infrequent, though, and that refactoring to that pattern (for example, by always splitting out the minimum set of shared state manipulations into their own function) probably doesn't help greatly with code clarity.
And, more importantly, act on the error returned by the JSON decoding functions.
Its in use by Netflix as a layer on top of memcached serving millions of requests per second as a key/value store. Docker and Kubernetes are written in Go
I'm working on a local business that builds off-the-shelf Internet web delivery computers (e.g. https://newegg.com) for about $500 in parts and hope that home AGPL Linux network computers move with demand I make with neat open source Go HTTP/HTML web applications. I use http://squarespace.com for Internet websites. [edit] I'm just saying you are reinventing the wheel by making up a web server on some virtual computer somewhere.
I am allowed to add imports? syscall.Exit(n % 2)?
Remember, imports can only go at the top of the file
&gt; MongoDB Really?
The solution: 1) write the user code println("hello world!") DoExit(0) 2) add an antidote as `vendor/os/os.go` func DoExit(code int) { syscall.Exit(code) } 3) $ go run crack.go hello world! $ 
Doesn't sending templated email mark you as spam?
Documentation is for nerds anyway
&gt; if the user didn't wrote a wrong file path But then you just bail with `log.Fatal(err)` (by the way, the following `os.Exit` is never reached) which will produce almost the same error. If you want to handle/report non-existent file errors differently just call `os.Open` then use `os.IsNotExist(err)`.
Actually, it's copy of rito documentation.. See https://developer.riotgames.com/api/methods
Hardly matters, put that in your README
Thanks for your advice. I added it.
lol no generics
Exactly. You explained the current behavior correctly. If there were a block scoped defer (what I meant by "scoped"), I could more closely approximate the Rust's behavior with locks and basically implement Python's `with`. The better solution is to have destructors, and to be useful, these destructors must run deterministically (I.e. don't have to wait for the garbage collector).
That is an option (if they allow it), but how will you be sure you app will restart it's server if it fails/get's killed... or just something happens to it :D If your provider uses cPanel/WHM you could ask for them to add your app to chkservd (it's integrated with cPanel/WHM) to check if your app is running and if not - restart it, but I highly doubt that they will agree.
The premise is based on non-idiomatic code. This: doc1 := entities.NewDocument("document 1") _, err := printDocument(doc1) if err != nil { printError(err) } else { _, err := saveDocument(doc1) if err != nil { printError(err) } } Should be: doc1 := entities.NewDocument("document 1") if _, err := printDocument(doc1); err != nil { printError(err) } if _, err := saveDocument(doc1); err != nil { printError(err) } I'll watch a little more, but 2 minutes in and I'm already struggling to remain interested. *Edit at 6 minutes in: The intent of the proposed error handling method is sound, but the implementation is not. The approach in the video will make a type far too OO for Go and obscures details. For an idiomatic example, please consider https://blog.golang.org/errors-are-values (note that no new interface is created). *Edit, skipped ahead much further: The bad premise is acknowledged by the presenter and the proposed solution is warned against. In the end the presentation seems meaningless.
&gt; I guess on the other hand why wouldn't they just use if (a != nil) then... Because you won't have to write this test for things that are not defined as optional.
Probably not; enmasse only produces drafts. There is a send limit of 1000 mails per day IIRC that might trigger something. But if you need to send more than 1000 mails per day you probably shouldn‚Äôt be using Gmail üòÑ
That should work, yes, but bear in mind that it's a terrible idea performance-wise, and that you won't be able to use pretty much any of the web libraries/frameworks out there (including the built-in ones), because they're all pretty tightly married to the idea of an HTTP server; there isn't a WSGI/Rack/Plack-like abstraction layer that would support running the same code in net/http, CGI, FastCGI, testing, etc. environments.
He admits he cheated in the Q&amp;A afterwards.
Recently I've been using Go for the REST APIs and Aurelia for the UI. http://aurelia.io/ I think it is a great combination and have been really happy with the results. Both projects seems like the best tools for their specific jobs.
Containerization adds complexity up front, but makes managing your services much simpler in the long run. If you have 20 services running on a server and the server gets patched, you may end up having to make 20 separate fixes. Using containers, I only have to worry about one point of failure. Plus I can safely deploy services to any server in the infrastructure without worrying about the configuration of the server.
You could accept an interface instead of A and B in both Save methods and implement getters and setters on A and B. Of course, in that case I would just have one interface which is outside either package, instead of InterfaceA and InterfaceB. But you might have valid reasons for not doing so.
Yes, that was my question. It doesn't matter, I sent you a more interesting solution using only the included imports.
Other solution is: go func() { // User code here f, _ := OpenFile("testing.txt", O_CREATE|O_RDWR, ModePerm) f.Write([]byte(`testing`)) f.Close() }() 
Yeah, I've used geter/seter interfaces in some cases before but if structure is too big and contains other structures in it (or arrays of structures) it's quite painful to implement.
I want to know 'how should be these modules developed to make their interfaces substitutable' without using common imports. Why anonymous struct solution wouldn't work if these packages have been developed this way?
What
http://cryto.net/~joepie91/blog/2015/07/19/why-you-should-never-ever-ever-use-mongodb/
I have never had any issues with MongoDB. It has scaled well with my projects and I have found it to be very easy to use / performant. 
That sucks having your first view into it as a career is a migration project. I can see how that would just kill the joy in it.
Yeah it's great solution as well as making interfaces with getters+setters for each field. But the problem is that the amount of fields can be extremely high and especially if there are arrays of other structures in it. type Video struct { Name string Size int Tags []struct { Name string Description string } }
Lisp
Just to add to the other discussions. map is also a pointer type, or called reference type in go (https://blog.golang.org/go-maps-in-action). In the same way, I can also define a type, such as `type file *os.File` and remove the asterisk. However * and &amp; give you the option of copy by reference (sharing data, what happens to one also happens to the other) or copy by value (duplicate the data).
what are you actually trying to do? There is probably an easier way to go about this. Your use of interfaces is not [effective](https://golang.org/doc/effective_go.html#interfaces) 1. Never make a `fileSaverImpl{} struct{}` or any other impl structs, it makes your code confusing and non reusable. 2. Your structures and not identical, `type foo int` is not the same as `type bar int`, so your interfaces are not the same because the func sig are different 3. Interfaces should be as generic, and if ever possible use interfaces from the stdlib some solutions if you want to keep .Save() http://pastebin.com/azsAPGBS edit: mobile formatting sucks
No problem; happy to help!
contribute to improve (with code or suggestions)
I don't understand you problem, but I'll take a shot at it. 1. Cast InterfaceA to struct A to struct B to InterfaceB, put that in func A2B(InterfaceA a) InterfaceB. 2. See if A/B implements some more common interfaces such as io.Writer and use that. (You should be able to save to a writer in a good api) 3. If you need to use A/B interchangeably in many places, then make a struct that is a union of A/B and an implementation that select the right one to use at run time. 4. Create InterfaceZ, which A and B implements, hack up stream, or create A2 and B2 that encapsulate A and B to do so. so you can Save(b InterfaceZ) 5. Give up on natural and clean, as long as the hacks are self contained.
1. sorry I'm new to Go. What if I want to make some service like FileSavingService and make only the interface to be exported? Can't I call interface FileSavingService, implement it as local structure fileSavingServiceImpl and return FileSavingService in a method that creates fileSavingServiceImpl ? 2. but VideoFile and File have absolutely identical fields and can be casted to each other 3. nice, will take a look at this way. Thank you!
It runs default browser of you OS if chrome is not found.
&gt; Ehren Murdick &gt; &gt;@rubyprogrammer This is what happens when people who do not really "get" Go make talks about Go.
Yes there is. Please read https://golang.org/doc/articles/wiki/.
Your interface and corresponding getters and setters only need to include the properties that are used in Save
I figured it out, I was using SystemParametersInfoA when i needed SystemParametersInfoW! Info: https://msdn.microsoft.com/en-us/library/windows/desktop/ms724947(v=vs.85).aspx Fixed Working Code: package main import ( "fmt" "syscall" "time" "unsafe" ) var ( user32 = syscall.NewLazyDLL("user32.dll") //user32.dll systemParametersInfo = user32.NewProc("SystemParametersInfoW") ) func main() { ImageLocA := `C:\Users\satur\Desktop\a.jpg` ImageLocB := `C:\Users\satur\Desktop\b.jpg` fmt.Println("Setting BG to: " + ImageLocA) ret, _, _ := systemParametersInfo.Call(20, 0, uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(ImageLocA))), 2) fmt.Println(ret) time.Sleep(5 * time.Second) fmt.Println("Setting BG to: " + ImageLocB) ret, _, _ = systemParametersInfo.Call(20, 0, uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(ImageLocB))), 2) fmt.Println(ret) } 
Did you ever get it working on Ubuntu? I've got unixodbc set up correctly I think, and isql runs fine, but I get an error everytime I try to actually use it under Go. It works fine in Python (using informixdb), so I may end up writing some service in Python to proxy queries if I can't get it working, but that feels really ugly and error prone.
It looks fine as is, you need to add server logic that does different actions per page to show how you code is organized, but so far, unless you are looking to use it as a CMS, I don't see what is getting super long.
About the performance - absolutely! But since he asked about shared hosting this is the only realistic way to run it (at least from what I've seen so far). About the frameworks - for my testing I've used github.com/gorilla/mux and it worked (at least for the simple things I did..) - not sure if it will do for something more complex. Basically I created a simple API that can accept json with user information and write it in MySQL, get that information from mysql and delete an entry. 
I actually use the cross compilation in my build (all managed by make like it's 1999), but docker-compose lets me ensure that once I run the thing I'm using the same binary and very similar external services, and that other devs picking up my code get the same thing. Also, statically compiled go binaries are extra convenient in Docker and orchestration frameworks.
I find it's easiest to learn by building something. I found a good starting point is 'Learn Go By Example' and then jump straight into making a simple server (it's literally less than 10 lines to make one). Then add in a database connection after that. Then maybe fancier routing if necessary. By that time you should have a decent understanding to be able to play around and extend functionality at will, learning a bit more here and there on the way.
[removed]
You could solve this problem a lot more simply by using buffered channels in the test since things won't block. You're doing some pretty silly things with channels here. Your process function has no reason to be suing channels. It's just a for loop that happens on a different go routine because the values are passed through a channel. You might as well just write a for loop over a slice of values.
Neat, though I'd say "Goer" might be a tad more Go-like then "Doer".
How would you scrape JS based websites? (angular and etc)
I don't know why you were downvoted, this is absolutely correct (although this is not a particularly efficient way to get hot swapping, if that's what you're after).
Those techs either add HTML/formatting or make API calls to get the data you'd want to scrape. In the first case, the formatting often would make the scraping harder, so it's good to get the data without the client side programming firing. In the second case, you would only scrape to get any credentials/arguments you'd need to call the API directly, if even necessary, again making the job of scraping way easier when you just call a json API. 
This really needs to be emphasized; runtime.SetFinalizer is not guaranteed to be run, and any program that relies on it for correct behavior is broken.
That's pretty much the situation. I've done a bit of digging on this topic while working on [Surf](https://github.com/headzoo/surf), and I've found DOM libraries for Go, and I've found Javascript (V8) bindings for Go, but no one has put the two together yet.
They may need to set up a selenium equivalent in Go. 
Why not take nightlies of open source projects and incrementally compile them, using the same options the maintainers themselves use. It would give a more real world comparison. 
The stuff nightmares are made of right here.
&gt; Pascal: Fatal: No memory left (There was no x64 version available of the compiler.) :( http://www.freepascal.org/down/x86_64/win64.var But that links to https://sourceforge.net/projects/freepascal/files/Win32/3.0.0/ and now I'm irritated.
Because then you can't compare the languages if you bench different source codes?
Afaik any compiler flag is seen as not "Goish" and nobody uses anything but the standard optimized one. Didn't even know "no optimization mode" exists.
Because then you're comparing different projects with different languages. Something has to be constant.
I'm just getting into Go. Would love to see some guides on .vue files with Go as the backend. Know any? Or have you written any blog posts?
You can use http://go-talks.appspot.com to show your presentation. No need to have a running daemon in a setting you might not have a computer at hand. 
I have the same "rewrite everything in go" urge for the same reason. I hate having to drop python and perl and Java and Ruby on boxes now. I just want a binary.
ops, wrong decade :)
And I'm just sitting here waiting for my Swift project to compile.
Yeah it's a huge article after all... There you go: https://golang.org/doc/articles/wiki/#tmp_6
Good question! If I benchmark it, I'll let you know!
You're correct that this ignores templates and repeated include file parsing (and many other things).
I understand the point you were trying to make, but this is what logarithmic scales were made for. 
Great read. Looking forward to more
[Relevant xkcd](https://imgs.xkcd.com/comics/compiling.png)
https://play.golang.org/p/WbCAY0gtix
Much appreciated. If you have any feedback for me, I'll be glad to receive it :) Best, Tit
You can get a VPS from OVH from $3.49 a month. https://www.ovh.com/us/vps/vps-ssd.xml
[go-bindata](https://github.com/jteeuwen/go-bindata) Edit: The same but with filesystem API for HTTP FileServer: [go-bindata-assets](https://github.com/elazarl/go-bindata-assetfs)
From what I can read about it, it compiles assets into go code, and doesn't append them to the binary like the mjl/asset or go.rice which was suggested by @ulfurinn. Doesn't fit my req's, even tho it seems it's a very popular project. I'll keep it in mind if I'm ever fine with extending build times for this stuff :)
PhantomJS. I made a small web crawler in Go that outputs every single page on that website into a CSV (together with link number, search deep etc) and another small loader that takes that CSV and sends HTTP requests to the PhantomJS webserver returning the wanted data from a specific request, then logging it into another CSV, easily openable via Excel / Libre Office. Didn't found an alternative yet sadly (aside from switchting to NodeJS to execute the JS directly but ... it's NodeJS so yeah).
The one I've found can only execute one line of JS. Pretty .... useless.
Yeah it embeds the assets into the code. I use it with a lot of html/css/js and it doesn't add much to the build times to be honest. But I understand if it doesn't fit your needs.
I use this one too, it works perfectly for my use case.
Thanks for that tidbit. I'm new and was a bit clueless about dlv.
Markdown + http://www.decksetapp.com
How to communicate with typical financial systems: - Login to sFTP - Download CSVs - Parse Data / Do Stuff - Upload CSVs to sFTP - cry
You should try C and different C++ compilers.
I'm not sure I'm very confident of running banking backend on Go ( and I really like Go )
Java is #1 for banks (beside Cobol).
I'm not a fan of that much `interface{}` :(
get it via the canonical import path: go get npf.io/gorram Still a work in progress, but fun to play around with right now. Lets you do things like this: $ echo 12345 | gorram encoding/base64.StdEncoding.EncodeToString MTIzNDU2Cg== or $ gorram encoding/json.Indent foo.json "" $'\t' { "foo" : "bar" } or even just $ gorram math.Sqrt 25 5
Thank you.
I wasn't a fan of this article. It's really just a discussion of their implementation of a microservice architecture, and really has no specific discussion on the needs of a "Modern Bank Backend" besides: &gt; Our systems must be available 24x7 no matter what happens, scalable to hundreds of millions of customers around the world, and very extensible. Hopefully if they continue the series there will be some actual discussion of the specific needs of a modern banking backend and some of their novel solutions to those problems instead of content that I can and have read repeatedly from other authors. 
That's because Kaylee is usually in charge of technical issues and Mal is not. ^^^sorry ^^^if ^^^wrong ^^^reference
&gt; You can still compare the source codes by some measurement of complicity. No you can't. And different languages must of course have different source codes but if you compare a simple task like they did in the example you can compare the same thing and look at the compile times. func(int x) { for i=0;i&lt;x;i++ { fmt.println(i) } } You can do that simple example in every language and compare compile time. It's about the task, not the syntax.
I'm an engineer at Monzo, feel free to ask me any questions you have.
[Log scales for you](http://imgur.com/a/6jiqM)
I was expecting a treatise on using float to represent currency.
Everything's shiny. It's the right gorram reference :)
for example, this is what gorram generates for encoding/json.Indent: https://play.golang.org/p/Y_bWriV8FB
Tried to run it, got panic: panic: runtime error: slice bounds out of range goroutine 1 [running]: panic(0x126020, 0x1050a018) /usr/local/go/src/runtime/panic.go:500 +0x720 main.main() /tmp/sandbox664614309/main.go:19 +0x5c0 Not sure if intended. I edited out my comment about bragging, since it's irrelevant and does not contribute to the original topic. I still have hard times getting used to the social media, where we post things without prior research. Sorry for that. Your tool and goexec differs in command line args handling, not quite sure what's the difference. gorran json.Marshal "$TEXT" and goexec "json.Marshal($TEXT)" Looks the same to me.
Fixed that panic, btw. This is why I'm currently writing tests.
From the user (as in the person who runs the app), none. From my side, I can burn in user specific configs (like client id, user specific assets,...) without having to compile go code on the fly. Basically, this is a simpler process to deliver basically the same thing. Well, no, you can also unzip the binary this way, giving a simpler way to inspect asset contents in comparison, if that would ever be important.
That has nothing to with Go.
Neat!
Since your file can be split line by line simply count up number of lines in your file then divide up as necessary to fit in the amount of RAM you have available and process chunk by chunk?
ReadFile reads the *whole* file into memory. So it won't work. You want a plain `os.Open`, it just opens a file handle and then you wrap that file handle in a `bufio.Scanner` to read the file line by line.
What exactly do you want to do with all this json objects? If you want to Unmarshal them into structs (so that you can retrieve special values), [`json.Decoder`](https://golang.org/pkg/encoding/json/#Decoder) (to decode one object at a time from a stream) is probably a good fit for you. The Standard Library has a [simple](https://golang.org/pkg/encoding/json/#example_Decoder) and an [advanced](https://golang.org/pkg/encoding/json/#example_Decoder_Decode_stream) example.
Why are you crying? At least it's **s**FTP.
Thanks, I think this will work.
Every gopher should do three things in their life‚Ä¶
i do not know why but .Scan only reads 103 lines from file with 2700 lines
There were a couple problems with Win (tested on Win 10) and I believe I fixed them all, but I need to go to bed and am working a long day tomorrow, so it will be 20 hours before I can make a pull request. :) More later!
Nailed it.
I found a settings for a buffer size and this code worked very well file, err := os.Open("json.txt") if err != nil { println(err) } defer file.Close() scanner := bufio.NewScanner(file) buf := make([]byte, 0, 1024*1024) scanner.Buffer(buf, 10*1024*1024) for scanner.Scan() { print(scanner.Text()) }
No. It is not open source. Only some components. https://github.com/Gelembjuk/articletext https://github.com/Gelembjuk/keyphrases
no problem at all ! I'm waiting for your PR anytime.
Fair post, nicely written - however, you should really try to avoid any dependency on global state or package-import side effects in your programs :) 
I'd love it if we had too many tools and frameworks for graphics, media and native GUI in Go. Web frameworks, routers and loggers on the other hand...
Sometimes it's inevitable but I totally agree that it should be avoided as much as possible.
No.
It looks pretty tidy, I'd maybe make these kinds of structures and things on my own in a project even. But why call your middleware "decorators"?
What's up with the go generate? It generates the sort.go file on compile time?
For a express equivalent take a look at Gin: https://github.com/gin-gonic/gin You can search packages by categories in this list: http://awesome-go.com/
Just use https://golang.org/pkg/net/http/ and https://golang.org/pkg/encoding/json/
I have been waiting for this functionality for 3 years. Thank you.
Discussion on HN is way more active: https://news.ycombinator.com/item?id=12633191
In modern C++ implementations, exceptions cost nothing in terms of additional computation if they are not thrown/used, they do cost something in terms of space occupied in memory because of the unwinding tables. Emulating them in Go by means of panic/recover should get you similar results, performance-wise, to the setjmp/longjmp-style c++ exceptions. Unwinding in Go has to happen even if you don't use exception emulation, or else you end up leaking resources. I like Go mostly for its goroutines, but as for the rest I feel being thrown back in the C/ObjectiveC times: after all, nothing has ever forbidden you to return multiple values in C/C++, you just need to add additional "out" function parameters or pack the return values in a structure of sorts.
Why? I don't have a shortage of ports.
Not to detract from your point, but it seems to me that the biggest obstacle to a native GUI is that it's really, really hard to build a toolkit that looks respectable on different platforms, not to mention abstracting over a bunch of graphics stacks. Text rendering alone is non-trivial. At least that's my perspective as a newb who has take a few weak swings at it.
I was wondering that too. Maybe restrictive network policies inflict a shortage of ports?
Gin is probably a close analog to express, but it's less widely used (and thus less documentation) than the standard library. Gin might be more familiar to you, but it might be harder to get help. Just a heads up. If you can afford to, you might want to learn the standard HTTP library first.
Thanks! Only big question would be what would you advise someone who doesn't know any Go to learn? I.e. what resources/web tutorials should I be looking at?
Thank you :-), that makes sense.
It's a lot of fun, go for it. I spent several years on an XMPP server in Go as my day job, here's my tips: 1. Read the [specs](http://xmpp.org/extensions/index.html) carefully. XMPP has amazing specifications, the most precise and detailed I've ever used. They are quite long. - https://datatracker.ietf.org/doc/rfc6120/ - https://datatracker.ietf.org/doc/rfc6121/ 2. Choose a good XML library; you will be dealing with XML a lot. We used [etree](https://github.com/beevik/etree). The stdlib XML library is nowhere near powerful enough. We tried using gokogiri (libxml2 wrapper) but having cgo in the critical path was a pain. Try to move away from handling strings as early as possible; build a `Stanza` type/interface and pass that around instead. 3. Write integration tests. The beautiful part of working on a network server is there's no UI, you can write integration tests at the TCP level. [xmlpath](https://github.com/grahamking/xmlpath) was helpful for checking responses. Test with several real clients. 4. Get unstuck. Use the Prosody source as a reference when the spec doesn't give you clarity. It's Lua, but without knowing the language I still found it very easy to read. Join the [jdev](http://xmpp.org/community/chat.html) channel to talk to other XMPP devs. It's quiet in there, and can take a while for a response (US vs Europe time zone) but friendly and helpful. After 20 years of writing servers, I still think there's nothing as magical as typing "Hello" on one computer and seeing it appear on another one, knowing you made that happen. I clap my hands with glee every first time.
Similar to what u/webrc2 said - there are lots of tutorials for things like Gin because they were made to be used. ([Gin](https://gin-gonic.github.io/gin/), [Negroni](https://github.com/urfave/negroni), [Gorilla](http://www.gorillatoolkit.org/), etc.) There are a few different different flavors. If you want to get straight to your logic, these make the network-routing 'easier' and more like what you might have seen in rails, though GO's HTTP library is so reasonable, that if you want to start at the beginning, the beginning really isn't too far down the rabbit hole. And in the long run is probably worth doing.
Oh thanks but I meant general learning golang - not just for http
Ah, sorry. I started with the tour: https://tour.golang.org/welcome/1 This got me started on the basics, but I already had a strong, statically-typed background. If you don't, you might want to solicit advice from other people with JS backgrounds. I've seen quite a few "Go for JavaScript users" tutorials floating around; that could be a useful Google query as well.
Yes, but presented solution - worst engineering ever. Right way - proxifying all required protocols trough the one transport protocol, good example VPN connection.
I'm not going to give the comprehensive answer of course, but Go is multi-threaded as opposed to something like Python or Ruby, which are single threaded. Depending on your application, that may make it more useful. All of these (and several others) are useful for Web / app, and a multitude of other uses. Go in particular is supposed to be easy to learn, and since it's supported by Google, that lends that it'll always be in use (Google tech tends to be pretty good).
First and foremost, abandon the idea endemic to Node development that step 1 of a new project is to go looking for libraries and frameworks. Start by writing your code, and look for a third-party library when you find you actually need one. External dependencies are just technical debt wearing a nicer suit.
Like you, I'm fairly new to Go, having mainly worked in C and C++. I've found it pretty easy to get into. If you're coming from the world of Object-Orientation, you may find the more procedural approach of Go a bit restrictive. It isn't, it just feels that way in the start. The big strength of Go (apart from the very fast compile times, cross-platform support producing native binaries as opposed to working through cumbersome Virtual-Machines) is its' easy concurrency implementation. It makes it dead-easy to spin up as many 'threads' as you want with very little overhead or memory-hogging. At the moment, Go is more for writing server applications. The backend for Web and mobile Apps. For IoT, C is still your best bet. Tiny little microcontrollers where you need to read registers directly is something C excels at. However, Go is great for tying all those little IoT devices together. Say using a little Rasperry Pi - where you can even control the GPIO directly using the embd library. Much faster and efficient than say Python or similar interpreted languages. And just as easy. As for frontend applications... not so much. Go is a bit weak in that department at the moment. I am sure in time we'll get powerful (cross platform compatible) libraries to handle UIs and 2D/3D graphics, but it's not here yet. It *can* be done, but the libraries are a bit immature and have issues.
Thanks for the well explained post. I see that Go could mostly be used for back end Security and server stuff, and thats actually pretty cool. I mainly considered GO as for it being a relativity New Languages, whit good up to date courses/videos. (Makes it easier to understand and get into while everything still is the same if you know what i mean) So i Guess i maybe will put it on the shelf until it gets more populated for the normal type of stuff, as making apps (Which should be pretty fast as Google = android). And hopefully it can be used in the same sence as Python, or even Java/C#/C++ and so forth. 
Yep, just what i liked about the idea of GO, its GOOGLE, so should be a Language used wide across multiply platforms. 
 package main // // To Compile put this in it's own directory, all it simp2 for example, then... // // $ go get // // this will pull in the "github.com/pschlump/json" // // $ go build // // this will compile to 'simp2'. The executable is the same as the directory name. // // $ ./simp2 // // Then browse to http://localhost:8080/echo/ // import ( "fmt" "log" "net/http" "github.com/pschlump/json" // Modifed from: "encoding/json" to not quit on "chanel" data type ) func SVarI(v interface{}) string { s, err := json.MarshalIndent(v, "", "\t") if err != nil { return fmt.Sprintf("Error:%s", err) } else { return string(s) } } func main() { // on seeing requst with /ping/ will respond with Hello World. // Tells you that your service is working. http.HandleFunc("/ping/", func(www http.ResponseWriter, req *http.Request) { fmt.Fprintf(www, "Hello, world!\n") }) // Shows what is in the request object back to as JSON data. http.HandleFunc("/echo/", func(www http.ResponseWriter, req *http.Request) { fmt.Fprintf(www, `%s`+"\n", SVarI(req)) }) log.Println("Listening on port 8080") if err := http.ListenAndServe(":8080", nil); err != nil { log.Fatalln(err) } }
Great! I've been looking for something like this. One question: what creates the n ‚â§ 16 limitation?
That's already made, you need to come up with an alternative.
&gt; the biggest obstacle to a native GUI is that it's really, really hard to build a toolkit that looks respectable on different platforms, not to mention abstracting over a bunch of graphics stacks. Yeah I mostly agree on that. Then again we have some examples like Java Swing which looks the same/decent on all platforms. Of course Java is a different case since it runs on a vm but I believe that by good interface usage, the abstraction should be possible for Go. I also believe that instead of going the standard route that most GUI toolkits follow, we need to take ideas from the way plan 9 way does graphics which is based more on satisfying interfaces and not inheritance. I think that another big problem, except the ones you mentioned, is that there doesn't seem to be enough interest and focus from the community for something like this. I get the feeling that native GUI is slowly dying and people focus more and more on web tech. I mean just look how many successful modern programs use web tech for their GUI nowadays (Atom, VScode, Discord etc). We also lately had some community Go "web native" projects come out while there hasn't been much progress for native GUI projects. Maybe web tech is the way to go? Only time will tell. Still I believe that with the right team, developing a native, cross platform GUI library for Go is possible. But is there enough incentive? Is it worth it vs web tech? And the million dollar question, who's gonna do the job?
[Betteridge's law of headlines](https://en.wikipedia.org/wiki/Betteridge%27s_law_of_headlines)
How does mino/dsync compare to samuel/go-zookeeper?
Practicality. They mention this in the README that the quorum size and communication complexity grows as the cluster-size does.
&gt; Unless something has changed recently, Swing is notoriously ugly. It's been a while since the last time I used it but I think nowadays there's stuff like JavaFX that make it look much better. When I was using Swing around 2005-2008 I believed it looked just fine but then again beauty is in the eye of the beholder. &gt; Even still, it would probably still be a large undertaking to reproduce it in Go. I suggested something else. &gt; I think the advantages of native GUI are a native appearance--to get something that looks passably native on multiple platforms Indeed but to be honest, I personally value the cross-platform part much more than the native appearance. Just imagine working on a Go project with GUI on linux and being able to cross compile it and have it just work on windows or mac. I mean that's like "the dream"! And to give you a practical example, check out [this project](https://github.com/driusan/de) which is a text editor that is built on top of `exp/shiny`. Sure it doesn't look like much in terms of appearance but the fact that it is pure Go and you can effortlessly cross compile it, is pure bliss. Besides, if the fundamental hard work is done, the appearance will improve over time.
&gt;We examine the titles of all published articles in the year 2014 from five top-ranked and five mid-range journals in each of six **academic** fields (n = 7845) 
Have you seen [boltdb](https://github.com/boltdb/bolt)? Looks like what you want, and it uses memory-mapped files, so the OS will be the one taking care of loading as much of a file as it can.
This project is in active development for a long time now and seems mature: https://github.com/btcsuite/btcd/
If you like to learn from videos, Told McLeod's channel is a great resource. https://www.youtube.com/user/toddmcleod
Two downsides of this exception library: 1. It may make the code more readable for Java programmes but definitely *less* readable for Go programmers. One of the strengths of Go is the ability to read other's code easily. This is enforced by tools like `go fmt` and by strong coding conventions (a.k.a "idiomatic Go") within the Go community. 2. It uses `panic` and `recover` as a means for constructing the exception flow. IMHO, `panic` should only be used when it's about time to panic, but never for constructing new language elements.
You could use more features. 1. grpc as api running on a localhost port https://github.com/grpc/grpc-go 2. grpc to http/json gateway pointed to talk to the grpc api (mapping defined in .proto) and served on the external ip https://github.com/grpc-ecosystem/grpc-gateway Its sadly a little bit of work to set up, maybe an hour to understand and use it, but should be working fine then. Incase your requirement is to access all the http stuff, then use net/http. Mapping the encoding of a form submission is not supported right now, so you would have to submit the form data in javascript with jquery-serialize-object to json. Oh and its a good idea to wrap the gateway with a cors Handler so the gateway says yes, cross-origin requests are fine with me, like so: import "github.com/rs/cors" func (s *server) GatewayStart() error { c := cors.New(cors.Options{ AllowedOrigins: []string{"*"}, AllowedMethods: []string{"GET", "POST", "PUT", "DELETE"}, AllowCredentials: true, }) mux := runtime.NewServeMux() opts := []grpc.DialOption{grpc.WithInsecure()} err := proto.RegisterYourServiceDaemonHandlerFromEndpoint(s.ctx, mux, s.grpcAddress, opts) if err != nil { return err } go func() { http.ListenAndServe(s.proxyAddress, c.Handler(mux)) }() return nil } note: "method not allowed" means the methods you defined for that path does not include your method of access(incase of browser surfing http's get. The following example maps delete -&gt; /service and post -&gt; /service, so accessing it with http's get method(browser) does give you method not allowed. service YourService { rpc ChangeItem(StringMessage) returns (StringMessage) { option (google.api.http) = { post: "/v1/service/echo" body: "*" }; } rpc DeleteItem(StringMessage) returns (StringMessage) { option (google.api.http) = { delete: "/v1/service/echo" }; } } Looking at this in hindsight it looks fairly complicated, but its quite simple really.
Yes, and computer science is an academic field, isn't it?
thanks for the reply, yes I check boltdb but I'm not sure if it supports globs/regex for get keys.although I think than would be possible use a combination of iteration and regex... thanks
&gt; I skimmed through the code. It doesn't address the full complexity of failure detection, membership change, etc. There's no epoch mechanism that I can see, which means that in the presence of reconfiguration after a failure it will not provide consistency. There is no concept of a master node which is why you don't see any membership change, epochs etc. Failure is assumed to be normal occurrence and handled gracefully based on a simple quorum mechanism. Dsync is also meant to be for simpler systems of immutable set of N nodes with in which you would need distributed locking. Dsync doesn't cater for dynamic addition and removal of nodes from this set. This immutable set in-turn governs the quorum ratio for its lifetime. We did explore RAFT but it just added more complexity for our needs. 
This package is aimed at limited scalability in combination with a static configuration of nodes which meets our needs for the minio object storage server (distributed version). It does not address changes in memberships/(re)configurations and if that is what is needed then raft is the way to go. One could probably do that in a similar fashion to dsync, and while that would be fun to do it is unlikely that we will do it any time soon...
Both are built for different purposes so harder to compare dsync is for locking alone. zookeeper is more general purpose. 
Edited the post with the full code from the project
That crosses into consultancy work territory. Sorry, you'll have to do it yourself.
But blog posts are different from articles published in academic journals, so I don't know if their research applies here. Anyway thanks for linking this paper.
&gt; There is a server component also with Dsync which handles this. How does it ensure that if any participant in the prior system instance attempts to talk to a participant in the new system instance, that is detected and stale inputs are rejected? &gt; Dsync is meant for applications which scale on demand and deployed in immutable sets What mechanism ensures that these distinct sets never overlap/communicate? What allows clients to handle the transition more smoothly than a global unavailability long enough to ensure all systems are quiescent, even the ones you no longer can can influence or control due to byzantine behavior but are still active on the underlaying substrate? &gt; We explored these approaches in our previous project GlusterFS, at scale things became complex and failed. I'm honestly a bit baffled at someone claiming experience with Gluster is a good justification for ignoring known, already implemented, well tested and formally verified consistent replication mechanisms and attempting to invent their own instead. That is the sort of thinking that lead to Gluster being as flawed as it is. Edit: it seems you may have misunderstood what I meant when asking why you didn't just use a known good open source implementation. I'm not asking why you built minio. I'm asking why you aren't using known good consistent replication mechanisms in a distributed locking service.
Very true, that does not sound like a problem. That is how it is supposed to be. If OP means restrictive environments where you are limited by port number(s) on one end, then you run a transparent TCP proxy or a usual L4 or L3 Tunnel, you do not write broken programs to solve a non-existent problem.
yes.
The net package uses it for lookups: https://github.com/golang/go/blob/release-branch.go1.7/src/net/lookup.go#L62-L87
There definitely isn't any shortage of ports, But the case with us is that we support HTTP and gRPC based communication between the client and server and we want to serve all the requests through one port and not differentiate based on the service.
Reading some of the comments about why do this, it's not that we had shortage of ports, or anything, it's more about user convenience. This is for the client facing port, which can be queried either via HTTP or via GRPC. Having different ports for different modes of communication is just inconvenient for anyone running the database, because they need to either map multiple public IPs, or use Nginx or something to forward to the right port, and for the client because they need to switch the addresses being talked to depending upon what they do. This avoids that. So, it's not really a problem by definition, but it's definitely convenient for the user to have just one public port for all client communication. We still use a different port for internal inter-server communication.
You probably don't even need a real tunnel. Even if I were to do it, I'd rather encapsulate the data within a simple protocol and use it to mux multiple ports on localhost. Content Detection is risky and *can* lead to very difficult bugs to fix if it's not explicit.
That is why someone made really nice to use protocols like GRE. Use a well know tunneling protocol with a defined contract. Or use a simple protobuf encapsulation if you want to write your own.
&gt; Why do you use `gvm`? Did the [Go 1 compatibility promise](https://golang.org/doc/go1compat) not work out for you? I used `gvm` because it's easier to just use this to update go whenever a new version is out. &gt; Does the output of `go env` look ok? `go env` and `go version` output: https://ghostbin.com/paste/ayebv &gt; Does the glide yml file look ok? not sure what you mean by "okay" but here's my glide.yaml: https://ghostbin.com/paste/3zsd2 &gt; What happens if you get `gin` the classic way via `go get` (and try `go run` again)? it works (the package is installed in `/home/yowmamasita/.gvm/pkgsets/go1.7.1/global/src/github.com/gin-gonic/gin`) &gt; What happens if you move the glide files (yml and lock) and the vendor dir to a safe location, then start over by going through the steps /u/philoserf suggested (`glide init`, `glide up`), and finally do `glide get` again? Doesn't work again (removed gin installed globally)
A simple example is with unused variables and import.
Blog posts are different from newspaper articles too, Id say. :)
&gt; Now I'm relearning Go If you are relearning Go then I'd recommend this time to learn to do the procedure yourself. To update to a new version you delete the old folder, download the new version, unzip it and copy it to the old location. On Windows the procedure is even simpler. Now unfortunately we do not have a community blessed vendor tool yet. My personal recommendation is [gvt](https://github.com/FiloSottile/gvt). It's so simple it hurts. Still I would recommend before using a tool, to do the vendoring procedure a few times by hand to get a better feel of how things work.
I think that's it. I don't have it under `$GOPATH/src`. It's just in my `$HOME/projects`. What should I put in my glide.yaml file? Or is it moving my project folder that is the proper way? Big thanks btw
It's yet another one of those...
You know, [a Maybe monad](https://blog.golang.org/errors-are-values) isn't hard to implement in Go
Doesn't this mitigate the purpose of lint tool's complaints? Non-descriptive comments are as useless as no comments at all Lint tools complain about missing comments because descriptive comments would enhance your code readability for others 
You are out of your fucking mind.
&gt; Java Swing I found it's succesor JavaFX neat.
Yes, and neither is in C/C++. C++, in fact, in my opinion makes it even more elegant, as Alexandrescu's [`Expected&lt;T&gt;` idiom](https://www.reddit.com/r/cpp/comments/2f2bpv/alexandrescus_expectedt_code_style_and_idioms/) shows. The point of this article is to just illustrate a way that exceptions can be used in Go too.
Regarding point 2, since I'm new to Go, could you point out which legitimate uses does the panic/recover couple have, in your opinion and/or in the "idiomatic Go"?
`panic` is a means to terminate a program if an unexpected condition occurs that cannot be handled. (As opposed to handling foreseeable errors via error return values.) `recover` can be useful if a long-running process (usually a server of some kind) shall not crash even if a crash situation occurs. `recover` can then initiate some kind of controlled restart or reset. I do not claim that this is the "idiomatic" use. However, using `panic/recover` for implementing new control structures does not seem very idiomatic to me. 
[Consul](https://godoc.org/github.com/hashicorp/consul/api#Lock) would be a better choice I think.
I think it depends on your existing architecture. If you already have Consul setup then sure, but generally (at least for me) I almost always have a Redis instance/cluster already.
The problem is that the go run command checks for the project to be in the Go src directory. Personally I hate using that directory, but if you don't mind not being able to use go run or go install, the go build command works in any directory.
You shouldn't be using relative import paths. All of your import paths besides built in go packages should be absolute paths. That might have something to do with the issue... Also look into govendor for managing your third party dependencies. 
How would you use consul for dist locking?
Ah neat, this is formerly part of groupcache, which is one those awe inspiring Go projects, equal parts succinct and brilliant: https://talks.golang.org/2013/oscon-dl.slide
sessions and the kv store https://www.consul.io/docs/internals/sessions.html
Check out the linked documentation. The API is pretty straightforward. There's also a [semaphore](https://godoc.org/github.com/hashicorp/consul/api#Semaphore) implementation (lock with multiple slots). Operationally you'll need a Consul cluster and a local Consul agent running on the same machine as the Go app accessing the lock/semaphore. If you ever get into a microservice-like architecture having Consul on hand will be useful. I tend to trust the failure handling of Consul more than Redis, which is why I recommended it despite the more complex runtime setup.
Yeah, that's exactly it. Make your local package imports be fully qualified.
You'll have a network roundtrip if you use Consul or Redis (or any distributed lock mechanism, really). You'd need to benchmark the exact scenario to get a sense of any latency difference between them. If you're very concerned about maximizing QPS you probably shouldn't be putting a distributed lock in the synchronous path. 
Will it trace http2 based payloads too? E.g like a gRPC call?
Callbacks are concurrency control. Throwing around theory of comp sci words does not make your case at all. A very nice abstraction of nodejs is it streaming api. Btw, Connect was a great way to remove callbacks in general if used correctly. Declaring callbacks as functions of an object or global scope rather than nesting anonymous functions results in extremely legible code. Stack and Values can be tracked via Continuation Local Storage. Promises still technically use callbacks, however they break the pyramid, like connect does. Javascript is awesome, its the "script kiddies" that use it, that make it bad. If i want to write cool experimental code I choose javascript. If I want to write stable, performant code, I choose Go. Simple as that...
damn, you're right! thank you so much! :) 
In a pinch, Redis' operations can be used as distributed locks, but it's probably a poor man's solution
What kind of performance do you need? 6x slower than LuaJIT might be about the same as Python depending on the workload. I suppose the question is, what do these scripts do? What are some examples of user-defined functions?
There are various libraries bringing V8 bindings to Go. Which will let you execute Javascript dynamically. https://github.com/lazytiger/go-v8 and https://github.com/ry/v8worker At that point though, you might as well just use Node instead of Go.
You could try storing binary versions of functions rather than the strings. That can be a pain in the neck, but it should cut down on load time. Another option would be to preload all the functions and reload them when they change, vs loading the functions every time you run an operation. I'm not arguing either of these solutions are better than a go solution, but simply suggesting some models that might make performance good enough. If you executor that applies the functions calls a process, then using go + whatever you want would apply. At that point you're getting close to hadoop, but hopefully it is easier to operate. Good luck!
No, it's just a quick way to add a place holder, which you can fill it later. Sometimes, you don't want to slow down your development process just because of filling comments to bulk of files. Maybe you can use: gocmt -t 'TODO(fill in later)' main.go
Irks me to see GO same as Lua guys to see LUA.
Also libraries should never let panic cross over, eg. they should recover and return error.
Yeah it really all comes down to what you're using it for and what you're building. For many projects where you're limited on resources and already have a Redis instance, it's great. If you have unlimited resources, there are certainly better options out there.
Why do you believe it won't scale up more?
Kubernetes is Born From Borg but Google Internally are using a new evolution of Borg called Omega: https://cloudplatform.googleblog.com/2016/07/from-Google-to-the-world-the-Kubernetes-origin-story.html
But you don't need multiple IP address to accept traffic on two ports, that's a non-argument. Anything internet scale will have some form of load balancer that can do arbitrary redirects whether that's pfsense, an F5, haproxy, or an ALB/ELB. It's easy and normal to have one internet IP redirecting different ports to different internal services. Forcing HTTP and GRPC onto the same internal service doesn't seem like good design. 
Fair point +1
Just that newness I think should be enough. Swift not only has basically nonexistent Linux support, it also apparently introduces breaking changes at irregular intervals. Not great for a production setting.
I thought Swift 3 supported Linux? It seems to do at least: https://swift.org/download/#releases Swift does get around many of the issues that I have with Go, with a lot of the perks that Go has. It doesn't have all of them though, and I haven't been able to evaluate much of Swift yet compared to Go. My biggest concern with Swift right now is the lack of a standard library like Go's, and also a lack of third-party, server-side libraries. Things will not be as mature as Go yet, but I really do honestly think that Swift will become much more of a serious contender against Go in coming months / years.
Pardon, where in the article it says they'll use Go? EDIT: Thanks guys!
It doesn't directly, but you can visit the github repo linked and see for yourself that it is Go. https://github.com/opencontrol/compliance-masonry
There are a few tools: Compliance Masonry: https://github.com/opencontrol/compliance-masonry This essentially is an aggregator for compliance data and can do various logical operations on the data (e.g. diff) It also can render compliance data into a gitbook: https://compliance.cloud.gov/ is an example of that. However, there are other word documents for compliance. One of these documents is the FedRamp System Security Plan. The logic for rendering into that is in progress and is in this repo. https://github.com/opencontrol/fedramp-templater There's a community building around automating compliance called OpenControl. http://opencontrol.xyz/ 
We've deployed Swift on the server to a low-traffic production service at least once - this was a few months back, we think we may have been the first site in the World to do it outside of IBM or Apple. We're sticking with Go for now. Why? Well, there's so much missing at the moment in Swift's Linux land, that when you think "OK, now I need to talk to this MySQL DB", you realise _you_ are going to be writing the lib/driver for MySQL. My colleague ended up implementing UDP in Swift for one application. Yes, UDP. Really. That's fun, perhaps, but, you know‚Ä¶ life is short. It'll get better, and we _think_ we'll re-evaluate it in the middle of 2017, but for now it's obvious we stay with Go. Node, we've seen that roll out in a couple of places. JS bunnies love it, obvious, so that's fine. Those of us who spend more time in languages that actually make sense tend to eye those micro-services more suspiciously than their authors do.
This thing is a *lock server*, you wouldn't build a lock server on top of CRDTs. If you used CRDTs, you wouldn't *need* a lock server (you'd just have some other, perhaps more "interesting", issues).
For Go: "Made a new lean, flexible, and idiomatic web application framework. Princess was saved by net/http"
Not that this a particularly good reason, but I was using the pattern shown here: https://www.youtube.com/watch?v=xyDkyFjzFVc#t=14m38s where he uses the term "Decorator". 
They created it .
Note that most claims made in that post aren't about throughput and speed, but about latency and predictability.
Swift doesn't support async http yet. It shouldn't even be in the running. 
Yes on http2, but github.com/grpc/grpc-go doesn't use Go's http2 transport. I wrote https://github.com/bradfitz/grpc-go16-demo to show it's possible, but the official grpc-go client still has its own http2 implementation. 
At the same time I can't think of an un-lazy Lisp joke that would fit in the center panel. Something about spending all day writing a function which simply takes _any_ member of royalty and returns another function which allows that person to free themselves?
Anyone who wants to learn writing web apps from Go can read this/ https://github.com/thewhitetulip/web-dev-golang-anti-textbook/
As I said. 1. Influence on the container market 2. Fun for their own developers 3. The most important, so people use Google Kontainer engine, as that's the easiest way to use k8s
I did some experiments, integrating NodeJS, LuaJIT &amp; Python inside Go, and LuaJIT seems to perform better (I'm initializing a Lua interpreter for each goroutine). You may find more details here: https://github.com/TykTechnologies/tyk/tree/experiment/coprocess/coprocess#coprocess---poc
I know that works, but it seems to me the inference embedding-&gt;embedded could be the same for both the method and the function, since essentially the method argument is nothing but a parameter.
Thanks, it's similar to vfsgen comparison, I didn't even think there would be a section for this on this very cool list :)
Also passerby, but I gave a talk on exactly this topic last week. [Video](https://www.youtube.com/watch?v=woX0NUqt0Ow) and [slides](http://go-talks.appspot.com/github.com/eldeal/talks/people.slide) if you're interested. I'd still love to hear the speakers answers as well tho!
The castle would be held under lease, and unfortunately, you can't move the princess out of a borrowed context, unless you replace her with another princess. Maybe you could rescue her clone, instead.
How does mino/dsync compare to https://www.consul.io/docs/internals/sessions.html?
FP programmers are exceptionally touchy and need to get over themselves. edit: and the number of downvotes on this posts proves it :)
I'm not particularly exited about the Go part of this. There are a few mistakes here and there. But still a great job. Let me start with this: if err == nil { Rather than doing this, in Go it's idiomatic to return immediately on an error and otherwise continue as is. This makes the code a bit fragmented and not very easy to read. A good advice is 'line of sight' reading. You should be able the read downwards in one straight line, and understand what the code is doing rather than jump around in indentations. Since you are doing this: return func(c echo.Context) error { All the time... Create a wrapper function for it, instead of returning and having to understand what it does. And once echo.Context changes it's interface, you are f*cked and have to go around and fix that function everywhere. Rather than only at one place. Try not to panic... :) Rather create a handler which handles the panic, and doesn't kill your server but returns a meaningful error. You can still panic, just create a middleware that catches that so you might try again after you resolved the issue. Extract the SQL. e.Run(standard.New(":8080") In 99% of the time this will collide with anything else anybody has running on his/her laptop. :) result, err2 := stmt.Exec(id) if err2 != nil { panic(err2) } You can safely reuse err. In Go, you usually don't redeclare a new variable for err. Just use err, and go from there. Since it should be empty by the time your code gets there. There are a couple of duplications in the model tasks.go which you could extract, but meh. That's it. Hope this helps in your further endeavors. :)
&gt; Apart from the obvious lack of native support, on Linux servers Uhhh .... I guess the server is running Linux so ... no-brainer to NOT choose Swift at the moment?
If you really just care about "does it have access to x" then you probably want to use interfaces, but this means you need to write a method to access name. eg: https://play.golang.org/p/TmigbUQKw5
I think you can't go wrong with either one but Go is more stable and mature. The best part of Swift is its frontend/UI ecosystem. That being said if your team already works on the frontend with Swift it makes sense to use Swift on the server too otherwise there is no reason to choose it over Go. Node is a no-go as far as I'm concerned. 
Okay, let me know if you're able to verify for certain. I thought I was about done, but I was still stuck on the arguments splitting on spaces. I looked at the carrot approach on there now for osx, and I'm not sure that's the correct approach. I wrote a couple other changes too. Offhand, I changed the registry code. I'll make sure to pull changes from you before my pull request to prevent conflicts.
I do not understand what is the purpose of this ebook. ¬ø?
18F uses Go a lot AFAIK. 
Is app engine used much any more? I don't hear much news about it
yes, it is Khan Academy, Rovio, and many others use it (just to name a couple) And with the App Engine Flexible environment getting better I think it's worth keeping App Engine in mind :-) Also, still my favorite way to get your code deployed for free!
Yeah, as I was writing the post I kinda of realized what I was doing wrong, which was to parent under my github folder instead of golang.org. 
I couldn't find any more repositories on GitHub. Do you have any sources to back that up? I'd love to add them to GoUsers.
I do quite a lot programming in swift for ios apps and golang for servers and would personally always choose go for the server as the language itself is already much less complex and thus more comprehensible and the standard libraries and tools included allow for a wicked fast development (especially in regards to formatting and testing). Swift is nice in the context of creating UIs, but for api development nothing beats golang for me currently. It is also very easy to deploy on different operating systems - and I did also develop in C#, Java, PHP and a lot of javascript (node and browser).
&gt; our old API's are PHP So you shouldn't encounter too many surprises transitioning to Hack ;-)
structs can embed interfaces too. So you could do something like type NameValuer interface { Name() string Value() int } func (p *embedded) Name() string { return name } func (p *embedded) Value() int { return value } type embedding struct { NameValuer ext bool } func printName(p NameValuer) { println(p.Name()) } And now `printname(d)` works. However, I don't recommend doing so as it's probably not idiomatic Go and confuses the roles of structs and interfaces. The typical use of interface embedding is to override methods of the parent; for example, `sort.Reverse` embeds another `sort.Interface` and overrides its `Less` method to compare the operands in reverse.
A package can restrict the import path it can be imported at. This is to prevent importing the same name twice under different import paths and is often used for vanity imports (such as the golang.org/x repos). The package in question [does this](https://github.com/golang/mobile/blob/master/bind/bind.go#L10)
&gt;Discfg is intended to be hosted in AWS and be serverless. WAT?
If it's a proper windows service, it won't run as your user but rather as administrator. I got burned by this too. As far as I can tell there's no way to have a service run as a user, but I may well be mistaken here. What I ended up doing was setting my app to be "autorun" via [this registry key](https://msdn.microsoft.com/fr-fr/library/windows/desktop/aa376977(v=vs.85\).aspx). You can look at the function `enableAutoRun` I wrote [here](https://git.vrischmann.me/orryg/blob/master/gui_windows.go#L-427). Also, I would suggest not using environment variables on Windows, the Win32 API provides a way to get what you want, and it's easily obtainable with Go. For example take a look at what I've done [here](https://github.com/vrischmann/userdir/blob/master/userdir_windows.go) to get the AppData path. To get the username, you would call [this](https://msdn.microsoft.com/fr-fr/library/windows/desktop/ms724432(v=vs.85\).aspx) via the same procedure.
ahh thanks man! I've went down the rabbit whole this past week and noticed the lack of understanding I have with the windows environment. I'll go ahead a take a look into what you provided and start testing things out. Btw, have you run into any issues with any of the window versions when running these scripts( 7,8,10 )?
I'm running Windows 10 and never tested my app on anything else, so I can't say for sure, but the APIs I mentioned are super old and standard, so I'd expect it would work on 7 and 8 too.
Ok, thanks for the head up. Well appreciated
I think you're not really gaining much by using echo over net/http, personal opinion. But a very nicely constructed low-dependency app. In comparison, your usage of sqlite3 package is on point. Maybe add a more complex router, so one can get a feeling how VUE works for a slightly more complex app? :)
Yes, thanks. I know about interfaces, but it seemed so obvious to me that if both types can be used in the context of one function call, that they can also be used in the context of another. I've given up on this approach for the moment, and made a big "union" struct with a field that specifies the type. Ugly, but easy on the calling functions.
Thanks for the detail there, I didn't know about this feature. I'm not going to even complain about it being restricted via a comment :)
I strongly suggest to never use Redis as a lock service. The main reason is that if you can‚Äôt tolerate data loss, Redis Sentinel (and by extension Redis Cluster) is not safe for use. Distributed lock services must be CP. Use a CP consensus system, like Consul, ETCD or Zookeeper. Also for Distributed lock services Replication alone is not enough you need linearizability. reference: https://aphyr.com/posts/283-jepsen-redis
&gt; this You call that easy ? what is that dancing with syscall and uintptrs ? :-|
https://scotch.io/tutorials/create-a-single-page-app-with-go-echo-and-vue
copied straight from the website: &gt; Writing An Interpreter In Go &gt; &gt; In this book we will create a programming language together. &gt; &gt; We'll start with 0 lines of code and end up with a fully working interpreter for the Monkey* programming language. &gt; &gt; Step by step. From tokens to output. All code shown and included. Fully tested.
18F uses cloud foundry for it's offering of cloud.gov. So a lot of the tools are cloud foundry focused - https://github.com/18F/cg-dashboard (uses Go for the backend) - https://github.com/18F/cg-fake-uaa - https://github.com/18F/aws-broker - https://github.com/18F/cf-cdn-service-broker And there are some tools that are from forked repos. - https://github.com/18F/kubernetes-broker There's some stuff for concourse.ci as well - https://github.com/18F/cg-deploy-kubernetes - https://github.com/18F/cg-common-resource These are all in addition to the stuff worked on in OpenControl. In addition, 18F contributes back to Go libraries, most recently: - https://github.com/apuigsech/git-seekret - https://github.com/apuigsech/seekret
I think I was one of them at the meetup lol
For something like this, I wonder then, could you get an even faster performance by using memcached? I don't see the need for redis' features if all you are needing is a mem-mapped lock for distributed use.
Nice package but this has existed for a while https://github.com/go-playground/overalls
&lt;3
const nbytes = 8 &lt;&lt; (^uint(0)&gt;&gt;63) 
I wish the go tooling had support for this.
I believe I fixed every problems I noticed , including white space problems of os x. do git pull and try again if you have time. Thank you for your efforts. :) 
I checked the rules of the challenge and you're not.
Are there any plans to improve penalty due to reflection in standard library? What is the stance on Generics for near future?
Windows services can be run as any user by either changing the "RunAs" tab in the services GUI, or modifying / creating the service config with the "sc" utility. This does have a few caveats to do with permissions, but similar issues exist with all operating systems. There is also the golang.org/x/sys/windows package which may help with some of the username stuff (I think it basically does the same syscall dance that you're doing, but it's maintained by the Go team so it may be a safer option in the long run.
I found even with a simple hello world app, the running costs were not free...
I don't understand how can you be so iresponsible to promote iris, a framework which is constantly breaking, not attributing the code from which it copies (httprouter, fasthttp to name a few) thus breaching the licenses of those projects and stealing and the leadership of the project constantly edits issues and denies participation in it. It also bases the claims on benchmarks which have been proven wrong, on extensively using unsafe and reflect and on projects which otherwise are great. Please remove that awful project from the list