I agree mailing lists arent the best if you're just browsing for interesting content. You can always set up a rule to stick the emails in a folder and/or delete them after x days, to stop it taking attention away from your main inbox.
Great observation! That sounds interesting, I'll take a look into that! That's definitely this could use! 
Good shout! 8 go routines is fine now, but we could end up with many more. I'll look into workers, I've seen a few good examples before actually, I'll dig them out 
Thank you very much for caring. These are good arguments. I'll stick to the Idiomatic library then. 
Your breezy optimism underestimates the complexity of the task, I fear.
Great! Yes, I feel like there's enough "meat" to gRPC to warrant its own set of discussions.
Well, one of my main motivations behind the book was that I do find parsers/lexers interesting and was really bugged out by other resources skipping them. Half of the book concerns itself with the lexer/parser and the rest with the tree-walking evaluation/object-model/builtin-functions. I thought about putting up a ToC on the landingpage before and now I think I should really get to it :)
Just for reference, I haven't had too many issues with the $GOPATH, as multiple GOPATHs are supported (just add both . and ../vendor). That has dealt with almost all of my tooling issues related to code completion etc. GB has exact Git revision, but I've tended to check the entire thing into source control to ensure that I have an exact copy and state of the dependencies backed up.
Create a bookmarklet with the following content and click on it when your eye aches due to the font. javascript:document.querySelector('link[href="/fonts.css"]').remove()
I am not going to comment anymore, you'll just say that I'm wrong and I'd rather learn something than have someone else actively discourage me from learning. Just a last piece of comment, we live in an ironic world, where pros decide what things are _easy_ for newbies to understand. Adios. (We both can agree that this is a waste of time, yours more as you have to explain the same thing over and over again to me about don't use framework and that I don't understand this and that..)
It's not looking good on Windows 7 / Chrome. I'll check it on OSX later as well. Has an aliased / blurry kind of thing going on. Not a fan.
I really don't like it, either. I find it hard to read, especially at smaller sizes. I suppose there's not enough negative space. Edit: typos
They're defining a new strBuf in the else block, but the value is never actually used because it never leaves the scope of the else block, hence the error.
Atleast it's not comic sans.
It looks beautiful on my OS X system (Retina). On my Windows 7 system (resolution: 1920x1200) the rendering looks jagged. * Mac: http://imgur.com/a/W98fH * Win: http://imgur.com/a/J1sFC
It is ugly on macOS, too.
That's my point. I never understood why people see certain things as valuable. I often see tons of features without much justification.
woah what happened on Win
That doesn't hit all of the fonts because their styles are still cached. javascript:(function(){var font='Times New Roman';document.body.style.fontFamily=font; document.code.style.fontFamily=font; document.pre.style.fontFamily=font;})()
It's all runny on Win/Chrome.
i like it!, the mono font looks great for me i think. http://i.imgur.com/kKMu9mw.png
its a terrible font. the serif version looks like a throw-away version of Courier. the sans-serif version looks sloppy. i get why they wanted a font for use with testing...but why use it for content? if they want to be user-friendly they should just default to system fonts. i already know what font i prefer by default and i'm mostly not interested in what particular sites feel like i should be using instead...there are exceptions when precise layout demands a particular font...but most blogs don't qualify
In Chrome it looks fine in Win10, much like the Mac version.
The monospace fonts puts reminds me of the grotty bitmapped fonts in Linux 15+ years ago when TTF support was spotty. Looks particularly awful inline with the proportional text (which doesn't look great, either). 
I find the code is easier to read, but the prose is harder to read. Which isn't ideal for a blog..
Are any of these packages self-contained meaning ship the Go binary and everything works, or do you have to install shared libraries?
I thought they were quite weird until I read [the Go fonts blog post in full](https://blog.golang.org/go-fonts), and by the end of it, I loved them. The decision to use a humanist font seems as much a philosophical stance as it is an aesthetic choice.
Looks blurry and along on OSX/Chrome. However, it feels very reminiscent of reading really old textbooks.
To each his own, personally I love these fonts, and I'm using them in my editors and terminal for my day to day work. I find sans-serif fonts make it harder to read in general, that might be because of my own vision being slightly sub-par, however
Totally. It makes me feel like I'm on our old unix workstations in college in the late 90s.
It means I typo'd the word "small" :p
don't think it's a technical term, but basically the ttf gets rendered awkwardly at certain scales (including the default zoom in my browser): https://i.imgur.com/Fje4475.png
So it does. Perhaps we can set a replacement CSS for that site? I think Firefox has an extension to do that.
StumpWM? Looking good.
"yay for thinking" i think.. i dunno, but some agenda of go.. seems to be that of "hey! stop and think for a moment" .. so i guess that is what they say that..
They look awful, and are very distracting. Luckily they are still using some Inconsolata/Menlo style font in the repo.
I find myself preferring "var ..." over "... := " because of this kind of issue. In this case, it would add an extra two lines (`err` and `lenLen`, unless I'm misreading something), but it makes it clearer (to me). I like the precise knowledge that verbosity buys me. 1: I have two new locally scoped variables. 2: I know exactly what those variables' types are. 3: I know that I'm assigning `strBuf`, but it's declared elsewhere.
I feel the same. I would prefer to have larger line height which makes the overall text less noisy.
I think the best way to kill this is by making something that is compelling enough to spur migration. Maybe the community can host something based on vBulletin. Maybe we can even build something in Go for us to move to. Whatever we do, I don't think the solution is to just tear this down. There are many Go users on here and our use of this platform is valid. We are not some leper colony. I think it's safe to say if we had something better to move on to then most of us would go without a fuss.
&gt; But still better, for some reason. Probably because it's doing full-native AA with the rasteriser engine built into Windows and working with your monitor.
Ehh... the proportional font is just another generic Helvetica knockoff. Maybe a *tad* dense for my taste, but I'd probably assume it's the default system Arial unless someone pointed it out to me. The monospace code font is actually pretty nice. It reminds me of something you'd see in an expensive Computer Science college textbook. Granted, I **wouldn't** use this in an IDE for actual work. But for code snippets on a blog or in printed material, it adds some distinct character. Either way, c'mon Reddit... an entire thread griping about the *font* on someone's blog is a little too "Hacker News"-y.
It's not the goodness of the rendered fonts that surprised me so much as the badness of the screenshot. Looking at it more closely, it turns out the screenshot has sub-pixel rendering for a monitor with the sub-pixels in the opposite order from my monitor. It's no wonder it looks terrible. The other images of the font use greyscale anti-aliasing, and they look perfectly fine.
Holy shit, I just saw this. What year is this, 1996? I have a strong Comic Sans / Geocities vibe from this
If you're so emotionally unstable that criticism causes you extremes distress you should stay off the internet and stop trying to enforce your "safe space" on everyone else. 
The change in fonts was a solution in search of a problem. 
Looks great to me on a 24" FHD screen. Only the pictures in the blog post seem like bad renderings to me. The fonts itself are readable and pleasant to me. Remind me, how often do you come across a new font that doesn't seem slightly off? Give it a chance..
Bad move by them. And what you described is called hypocrisy, no less. NOTE1: Reading further, they are reconsidering their stance of deleting this subreddit in favor of making it more obvious that it isn't official. That's cool. NOTE2: I understand Bradz's frustration with this platform. "Dropping the official badge" of this sub would suffice though. Those who want to leave have the right to do so.
Ugly on Arch Linux with font rendering fixes from Ubuntu (making it look neat in GNOME and Firefox). 
The new Go fonts are absolutely hideous and unreadable as coding fonts. I do not really understand why would anyone make their own set of fonts if there are plenty of open source programming fonts out there to chose from.
wtf is that font - a joke? "go play with fonts on your tombstone" I once heard from UX/UI specialist (he was rude but right).
&gt;[**Office Space - Horrible, this idea [0:09]**](http://youtu.be/uSudkID3zJM) &gt; [*^Ronnie ^Clark*](https://www.youtube.com/channel/UC3thNttQVyLB1URh0v17UvA) ^in ^People ^&amp; ^Blogs &gt;*^9,072 ^views ^since ^Oct ^2014* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
It's bad but it's a small act, reddit is bigger than spez. 
Changing the p tag's line-height to 1.5em makes it look a lot nicer.
I'm not a fan of the monospaced font. I tried it in vim for about 10 minutes before switching back to my previous font. I do like the proportional font though. It's readable, not ugly, and unencumbered.
It looks fine on my Arch installation with Infinality, and on my Android phone, but it looks pretty horrible on Windows 10 for me. Regardless, I don't like the font anyway, despite their claims that "humanist" fonts are more readable.
A castle can be bigger than a swamp, but you don't build castles on swamps. 
If the Go fonts by Bigelow &amp; Holmes rip off the luxi-mono by Bigelow &amp; Holmes I'd say it isn't a big surprise.
I also find it less readable than the old font on my macbook with retina screen.
/r/notinteresting is leaking
On the bright-side, there's a [Getting Started](https://github.com/andlabs/ui/wiki/Getting-Started).
+1 I don't want to pile on people for contributing, but if I'm bluntly honest I find the new go fonts entirely unsatisfactory. They're just too dense horizontally, and on modern displays trying to squeeze letters to save pixels is mostly pointless. I have weak vision and these fonts make it *much* more difficult for me to scan code. I doubt I'm alone in this aspect. I'd much prefer a more conventional code font with a suitable license. There is zero chance I'll use these fonts personally, and if they're adopted as some sort of official font for go project documentation I expect to continuously struggle to read them.
This was a good talk. We have also found HTTP to be a great way to communicate between services, even on the same server.
I felt like the line spacing looked too small (probably a trick of the taller proportions) with the proportional font. Did you like it as-is or did you try increasing the line spacing?
Hey, I am with you on this. Nevertheless, we are talking about cross platform GUI support in Go here. There are not many solutions out there. Spending an extra minute to scan the incomplete README and notice the two links is worth it if you are interested in the topic.
I'm happy to remain. I have been fairly inactive lately, but I check in from time to time. I should note that I am a Google employee (though I've been a r/golang mod for longer) who is not on the Go team.
The line spacing didn't bother me, but I can see what you mean. Maybe another 5% would be sufficient.
I used to be more active with moderation, but I found that u/dsymonds was responsive and felt that my close attention wasn't needed. I also don't reddit as much as I used to. But, if people feel that more moderation is needed I can step back in.
No, that's really awful. It's not different; it's bad. 
&gt; I just searched for "Getting Started" on the Github page, nothing to be found. Are you sure? I get one result in the code linking to the wiki, I get one exact match for the page in the wiki, and I get 8 issues discussing documentation.
You just wasted your time writing **three** comments, complaining that you "didn't have time" to notice the Getting Started guide... which the volunteer author of this free open source project wrote and linked directly from the README. Speaking as someone who's maintained a few open source projects over the years, we *hope* that people like this will move along. 
I thought that was great. 
Thank you to whomever it was that decided to waste their $20 on me. I'll do my best to put it to good use ridiculing "safe spaces", "codes of conduct", "preferred pronouns" and the overly sensitive thought police that are trying to shove this driveling nonsense down everyone's throat against their will. 
Normally when I see you being harsh (or rude..lol) around here I try to balance the universe with some constructive criticism. So I opened the repo and started writing a reply. Very first thing of course was the regex compile every function call, wrote that he should compile once at startup, yadda yadda but this problem shouldn't use regex at all. He could just lex it and it would save him the call to ParseInt too, started to write how easy it is to convert a well formed string to a integer with rune index.. Then I went back to look for more and noticed it was ParseFloat. Then I noticed he didn't return a time.Duration. That's when I realized it wasn't likely he put much thought or effort into it. So, just this once while I still got a bad taste in my mouth for writing a chunk of text on this wretched little iPhone just to click cancel.. I'll say.. This repo was awful and your response was polite with the ammunition you had.
I'm sure if this example shows me the full power of Go generate. It feels a bit wrong to mix your source code with project related stuff. And particular with this example I'd rather have the contributor generator in a Makefile. I have projects using different kind of languages and a Makefile I can reuse across those projects. Does someone has other examples of using go generate?
The http://python.org guys brought over their aesthetics. 
Might be something on your site, Chrome+ArchLinux and I don't see this problem.
Check errors.
&gt; I am not going to comment anymore, you'll just say that I'm wrong I'm not just saying it, I'm _proving_ you're incorrect. &gt; and I'd rather learn something than have someone else actively discourage me from learning. Please provide proof as to where I've actively told you that you shouldn't learn. Or are you spewing yet more bullshit? &gt; Just a last piece of comment, we live in an ironic world, where pros decide what things are easy for newbies to understand. I'm was a newbie as well, I have no idea what you're going on about. &gt; Adios. (We both can agree that this is a waste of time, yours more as you have to explain the same thing over and over again to me about don't use framework and that I don't understand this and that..) I mean yeah, when I have to repeat one point because you've kept on spewing the same bullshit, it's definitely a waste of time, and yeah, you don't seem to understand a single word I've said to you. --- **Example #1** [I explain to you that the pull request is completely valid HTML5](https://www.reddit.com/r/golang/comments/5eubdp/the_future_of_rgolang/dag2d1j/) including links to the official HTML5 standards as well as the Google Style Guide showing you that it's not only valid, but in fact recommended, then you go and write: &gt; [Behaviour like yours is exactly the problem which I wanted to highlight. (inflexibility for adding things for aiding newcomers).](https://www.reddit.com/r/golang/comments/5eubdp/the_future_of_rgolang/dag3z9t/) and end up writing a bunch of bullshit about NPM and webpack, when there's already messages on their [Installation page](https://vuejs.org/v2/guide/installation.html) explaining exactly why they're there, and explain this in my response. This is also [the first time](https://www.reddit.com/r/golang/comments/5eubdp/the_future_of_rgolang/dag55io/) I mention that what you wanted to change would help absolutely no one except people who have no idea what JavaScript is (aka those who don't know how to include JavaScript on a page using the &lt;script&gt; tag), and this is what __I have to keep repeating the entire time__. I'll do it again for clarity. You don't learn a framework without know the very basics of the language it's built upon, since you'll need to use that language anyways when you start using the framework. Good? Good. --- **Example #2** You then [edit this entire comment](https://www.reddit.com/r/golang/comments/5eubdp/the_future_of_rgolang/dagen43), but luckily I can just [see it anyways](https://uneddit.com/). You said: &gt; Does the official docs show that by example? Fuck no. They just shoo people off asking them that "learn advanced bullshit of JS and that we aren't responsible to teach you that". Except that the message is very clear that _the documentation_ ___assumes___ that the people reading it have an intermediate level of HTML/CSS/JS: &gt; The official guide assumes intermediate level knowledge of HTML, CSS, and JavaScript. If you are totally new to frontend development, it might not be the best idea to jump right into a framework as your first step - grasp the basics then come back! Prior experience with other frameworks helps, but is not required. You then say: &gt; You know what a newcomer to a language wants? We already established that a newcomer to the language should not be using Vue.js using their documentation. And now you're making me repeat it __again__. --- __Example #3__ &gt; Exactly my problem. You don't need that ecosystem. The current docs kinda portray that vanilla is out of the option and "go fuck off to lean webpack before you come back", my PR would have shown them that, see, copy this html into a file and carry along. That one paragraph makes a lot of difference to newcomers. It would have made a difference to me. Again, as I showed in #1, __the documentation already explains this__. Do you see how you're repeating yourself constantly, forcing me to repeat my answers to you? --- __Example #4__ I explain: &gt; It's not invalid markup, that's the entire point. It's valid, as per the standard I linked. &gt; &gt; That was not my point. My point is that I have written a vue app with Go backend without knowing npm shit. You do not need to use webpack and shit, the docs do an amazingly bad job at advertising it. You couldn't even grasp the context of __your own text__. And in fact, [this is still wrong in your initial comment](https://www.reddit.com/r/golang/comments/5eubdp/the_future_of_rgolang/dafyzkr/). Then you do __even more__ spewing about how the documentation needs to be more newbie friendly, although we've already established (#1 and #3) that it's not meant for absolute beginners, and you've also failed to point out any valid shortcomings to beginners in the first place: &gt; that's why the DOCS need to be more newbie friendly, I was learning Go 10 months ago, I had a million problems, the same ones I face with Vuejs, the docs are great, but not beginner friendly --- __Example #5__ You say: &gt; This is how you be beginner friendly rather than shoo them off to some obscure link on the internet and ask them to learn unnecessary JS bullshit. **FUCKING AGAIN**, the text doesn't say that they have to learn webpack, it says: &gt; __It pairs nicely with__ module bundlers such as Webpack or Browserify. What exactly are you smoking to come up with so much bullshit, and actually believe you're somehow making sense and _not_ repeating yourself? --- __Example #6__ You say: &gt; The problem I have is that the doc teaches people to use webpack and things like that. Do we really need that? ...like, are you serious at this point? Pointing out webpack __again__, even though we've already established that it's not for beginners? --- __Example #7__ You say: &gt; My point (please excuse the many f*) was this, docs are great, but they can me made better? You guys are Vue pros now, so it might not matter to you! It does to the newcomers who struggle with npm. And now you're talking about npm __again__! Jesus Christ... --- __Example #8__ You say: &gt; lastly, there is really no need to use npm webpack, I do realize it is their docs and their decision, which is why I abstain now. But I do strongly feel that docs should be as newbie friendly as possible. And I get very angry at how docs are not newbie friendly Oh man, after that first sentence, I thought you actually had some sense knocked into you. But then you go and _completely_ fuck it up with your second and one. Same thing, __yet again__. --- __Example #9__ You say: &gt; okay, so the problem I was having is this, there is an example of npm here, shouldn't there be an example of &lt;script&gt; tag. ...you're asking for the absolute most basic part of JavaScript be mentioned in documentation, when almost no other libraries do because __it's the first thing you learn__. Hopefully you won't make me say the word __again__ for the rest of these examples. --- __Example #10__ You say: &gt; yes, the docs do not force us to use npm and stuff, and now that they explicitly tell that "this docs expects intermediate level" they technically are correct, but at the same time, wouldn't it be great for a newcomer... __AGAIN__. You made me say __again__, __again__. No, it wouldn't be great for someone who knows absolutely __nothing__ about JavaScript to start using Vue.js, because, and I fucking repeat, hopefully for the last time, __you need to know JavaScript in order to use Vue.js. There's no if, and, or buts, it's simply the truth__. --- __Example #11__ Oh no. You didn't. Please don't tell you me repeated the same thing again. &gt; I read on HN that Vue has amazing docs, I go to guide page. It warns me that I need to have intermediate level JS knowledge. I get confused, go to webpack and stuff. Oh my fucking god, you've mentioned webpack again even though the website specifically says that you don't need it. What's wrong with you? --- __Example #12__ &gt; also don't you agree with the point that if you are having an example of initializing a project with the cli, you should at least have an example which shows the basic html? including the &lt;script&gt; tag? ...I have nothing else to say. Absolutely nothing. I've done more than __prove__ my point. --- __Bonus #1__ You say: &gt; Since my backend language is Go, I have no clue how to use webpack with Go AND &gt; I use Go at my backend, I have no clue how to run webpack apps by using Go I mention how the webpack website clearly mentions what it does and has nothing to do with Go, then you say: &gt; I am not trying to use webpack with Go. Seriously man, what the fuck. How do you not see how fucked-up you sound when you contradict yourself like this? On top of everything else? --- __Bonus #2__ You said: &gt; about your point that even jquery doesn't have it. I do not think it confuses newcomers, at least I started using jquery before node existed, so I can't say if it confuses newcomers now Dude... Vue.js explains it the __exact__ same way that jQuery does it. So if you were able to use jQuery, you should be able to use Vue.js. End of story. --- And yeah, at this point I've ignored your user. I've been trying to help you, and would have gotten a better conversation out of a stuffed animal and some DMT. I won't be able to make that mistake anymore, thankfully. Learn how to self-reflect and admit you're wrong for fuck's sake, otherwise you're going to have a tough life ahead of you.
Thanks! Seems useful 
I use the standard reddit web interface and the reddit mobile app.
Advantages of zb over gb? P.S. How do you come up with those names?
really can't stand the new font. Not sure why any resources were dedicated to it at all, regardless of licensing issues. And in typical go-nuts fashion, since unofficial consensus is that the new font sucks--when do we start a petition to delete the golang blog? Because that's what gophers do now when they don't like something, right?
&gt; practically brushed off in the go-nuts channel this has been my experience 100% of the time with go-nuts. Asking for help or even posting a tip seems like at best: a lesson in futility, and at worst, an invitation for ridicule and condescension. That dynamic is what makes this subreddit all the more appealing.
I'd say it has a more tangible effect as well, in that I believe it would not incur a branch when along the happy/hot codepath.
Most definitely! I really like https://github.com/alecthomas/gometalinter for finding issues like this.
What the hell did they do to "y" in monospaced version?! It looks very much like "v".
One additional limitation is that functions may only return a single value, or a single value + err. 
I found it to work great.
Instead of trying to mutate items have you considered mutating the key you use to refer to them when the contents change? If you do that you could use groupcache as it is.
Thank's for quick response! If all Go functionality is available, does that mean I can create channels, use types from other packages and use arrays, as well? In some document, which of course I can't find anymore, was described that these features I mentioned, and some other as well, aren't supported. But that document might be outdated by now.
I use an RSS reader (feedly). All entries come by, I open them by shortcut in a new tab and then quickly go through them and close everything I don't find interesting. Other subreddits I'm subscribed to, I'll consume using the frontpage, every once in a while.
Still cannot use groupcache because you cannot add a key programmatically and that key be distributed to the other nodes - as far as I can tell. 
Oh, I'm not the one who posted the pictures. And even with cleartype set up as best I can l, and on a 4k screen, Windows font rendering has always been sub-par for me.
Have you run the ClearType wizard to set it up to your liking?
Yes you can use goroutines, channels, etc.
I think the document you're looking for is just the gobind docs. See here: https://godoc.org/golang.org/x/mobile/cmd/gobind#hdr-Type_restrictions The section I linked explains the rules for exported types. The key here is "exported". It goes on to say: &gt; Unexported symbols have no effect on the cross-language interface, and as such are not restricted.
Reddit is Fun on Android is pretty good for mobile.
I primarily use the mobile app on both major mobile platforms. It works very nicely and if you're subscribed to a number of subs the "feed" portion is pretty nice. Definitely +1 for mobile.
Thank you for that explanation - the light turned on and I got it!!!
Unfortunately I can't figure out how to install gobind with the gotip version of Go. I wanted to try the objc example, but can't seem to make it past this issue https://github.com/golang/go/issues/17750
BaconReader on Android
With a splash of salt.
Interesting, but I find the title a bit confusing. My understanding of go generate is, you use it to run commands possibly before building the project. On the other hand I found this line on the README &gt; When the program is next run, Doggo will generate the asset.go file, containing the file system from that moment. Well, it looks like the tool still generate the file. And you will need to build the project again, then run it for it to have effect. **NOTE** I haven't used go generate that much, this is based on what I remember when the feature was first introduced. Nice project BTW. I will try this out, just wish it was on github and not bitbucket :)
&gt;Well, it looks like the tool still generate the file. And you will need to build the project again, then run it for it to have effect. Basically yes. On the other hand it works simply by the act of executing the program inside the source code directory. Which is why i call it the most horrible embedding engine; if you don't include the generated files into your VCS, you'll effectively have to compile, run and compile a second time. On the other hand, it does not rely on `go generate` at all, so all you need to do is use `go build`. The theory is that during development, you'll run it inside your VCS directory and therefore automatically update the embedded assets. &gt;just wish it was on github and not bitbucket :) I too find github better from a UI perspective, but there are political and technical reasons (mostly technical: private repos)
Thank you so much 
That would be useful for many scenarios outside mobile development, wouldn't it? :D
I'm having trouble getting something returned from .Search(..) method. So far returns nothing and can't figure out for which calls I need to authenticate.
Seconded, it really is a terrible font.
But the "Who is this book for?" says it's not for beginners!? 
Sriracha ftw.
Too hot
No worse than 'go'... Both require two hands using standard typing or stretching a single hand. (using a single hand, "go" requires you to twist your wrist a bit; "zb" only requires you to move your hand down a row). Regardless, this conversation is the canonical example of bike shedding.
I just wanted to point out one more thing, the link in my previous comment does explicitly list what is supported. &gt; All exported symbols in the package must have types that are supported. Supported types include: &gt; - Signed integer and floating point types. &gt; - String and boolean types. &gt; - Byte slice types. Note that byte slices are passed by reference, and support mutation. &gt; - Any function type all of whose parameters and results have supported types. Functions must return either no results, one result, or two results where the type of the second is the built-in 'error' type. &gt; - Any interface type, all of whose exported methods have supported function types. &gt; - Any struct type, all of whose exported methods have supported function types and all of whose exported fields have supported types. I hope this helps get you started. Cheers!
Yeah, I understand that now. I played around a bit with gomobile today and I was able to return a custom struct with supported types to Android. This can be very interesting as I get a better understanding of gomobile and how to use it properly.
don't 'go get' the entire repository recursively. you only want to 'go get golang.org/x/mobile/cmd/gomobile', once you have that run 'gomobile init'. if you upgrade your source to tip (bugs for the android runtime were fixed yesterday) you need to re-run gomobile init.
What should I do after? I've installed gomobile and ran gomobile init alread. Full disclaimer, I'm not really interested in "mobile development", I do want to try the `objc` bind though, and would like to get the objc testpackage in the repo to compile and run. https://github.com/golang/mobile/tree/master/bind/testpkg/objcpkg
there's no example for objc as of yet, i don't think. this is experimental territory.
Are you asking how to speed it up, or why it is running slower on Go? I'm unsure as to why it is running slower in Go, but you could speed it up significantly by using an efficient sorting algorithm such as quicksort or mergesort. The library function `sort/Ints` uses introsort. Seems like yours runs in O( n^2 ) time. startTime := time.Now() sort.Ints(unsortedArray) fmt.Println(time.Since(startTime)) For 131072 random elements, your version takes `23.338753874s`, sort.Ints takes `7.89203ms`.
You are right; I should fix such comment.
&gt; Rust is definitely a great language. Thanks for the insight.
"Objective"? So garbage collectors are *objectively* a bad thing? I don't even
That's cool! May I ask what the motivation behind the project was? Definitely checking it out tomorrow.
&gt; I also must admit that this sentence is confusing me. I must clarify that it would be for applications to use in different platforms.
If you are interested to get some opinions from people who are *actually* doing gaming development in Go, I highly recommend you to join the Gophers Slack on #gamedev channel.
That^ And it's pretty silly to say why is Lang X snippet slower than Lang Y without seeing Y. 
Something tells me, just a guess, it's not "equivalent" java code.
Rewrote my port.sh shell script as a cross-platform Go binary
I wouldn't say there's anything really stopping it from being a decent game development system other than cgo performance. Almost every engine component is going to require cgo interop of some kind. Since the C -&gt; Go transition in 1.4, the performance of cgo based code has been at least 2x slower (dependent on platform), but https://github.com/golang/go/issues/9704 suggests that in the 1.8 timeframe it may be back down to pre-1.4 levels. I personally wouldn't want to end up in the situation where a new version of Go regressed performance of a critical component in my engine by an order of magnitude and the issue wouldn't be resolved for like 2 years. https://dave.cheney.net/2016/01/18/cgo-is-not-go is another example of why this ends up being a problem. Your C dependencies in a cgo application have a lot of baggage, and you have to do a lot to manage cross-platform support, static library/single binary compilation, concurrency, marshalling, etc.
The best project on that domain that I have found so far is [engo](https://github.com/EngoEngine/engo) 
&gt; I believe that https://github.com/vulkan-go/vulkan said somewhere about eventually not having C bindings. I don't know if this is true but... &lt;heavy breathing&gt;
If you have found a bug, please open a ticket: https://gitlab.com/fastchemail/fastchemail-go/issues 
To be fair; functionally equivalent code with Java syntax (assignment / declaration, time measuring) will be faster in Java.
Really late reply, took a break from internet for a few weeks and suddenly this. &gt; Purpose This sub has been fulfilling this purpose already and why it's active. Anything Go related goes. &gt; A moderation revamp. Should the Go Team members be asked to step down? [...] none of the Go team moderators are active contributors I don't care if they actively contribute, the question is if they actively moderate. If they do not, then yes, they should step down. &gt; Community Building. There's clearly a lot of contempt for /r/golang in the mailing lists. How (or should) this be addressed? Actions speak louder than words, and while I myself would consider /r/golang healthy conversation as-is, what builds communities are community leaders. This falls back to the current moderators and whether or not they are actively involved in this subreddit community. If they are not, then this subreddit simply needs more involved community **leaders**. &gt; Engagement and Structure Many of the idea presented here sound interesting, and this again falls back on the community leaders and what they are most apt at doing. Find leaders that have the desire to pursue such ideas even if they might not concretely know what said ideas are in the immediate sense. &gt; Customisation Yeah, I guess, sidebar looks fine to me, there's a gopher up top. I'd also like to add that the CoC is not necessary as mentioned by another user here. There are enough people here that toxic comments get voted down. For questionable comments, it's important to have sensible moderators and leaders that can empathize with offended users and understand the nuisances of other's comments so as to act as a responsible and sensible moderator and community leader. It's just part of the job and if the current moderators are not capable of this level of engagement, they should be replaced. I'd think there are enough users of this subreddit now that such people are available.
Yea, I don't mind Java the language.. it's Java the ecosystem that I will do everything I can to stay away from. I don't want to spend hours navigating documentation just to get an "enterprise Hello World", jk exception. Stack trace leads me to find out the frameworks creator wrote it in JavaScript, the JS transpiler was written during his coworkers two week wet dream, in jruby. After a long day of trying to find out why I can't print a few bytes to stdout I realize I was using the wrong console package, for ultimate web scale the framework wraps fd1 and translates it to json, hello world parse error bro. Merc me.
The basic problem is: cgo is slow. 
While this is true... I think that is fine in this case. But good point!
Thanks, that is an interesting idea.
But what they are saying is that if you say "I prefer a language with more features" then you are not being objective. You are already deducting points from Go for it not fitting into your overall desire for a language with lots of features. It would be more objective to rate Go purely on what it can do, to solve your tasks, as opposed to how it doesn't fill a general feature set.
Go test is only as effective as the tests you write.
How does this compare to other cross-compiling tools like, e.g., [gox](https://github.com/mitchellh/gox)?
Like you said, a lot of (if not exactly hardware pushing) games have been and are being written in Java, JavaScript, C#, Python, Lua in frameworks like libgdx, Phaser, XNA, Monogame, Cocos2d, Löve etc, which means Go is good enough from a language performance standpoint. What Go lacks is perhaps a mature game development framework like those aforementioned, I know of *engo* which makes use of the 'entity+component' system, but I haven't used it myself.
&gt;other than cgo performance. Is cgo performance worse than when calling external code from say Java or C# ?
Cool, I've played around with Löve so I have to check this out!
@jaekim What's the URL ?
To be honest even in Go 1.7 it's not easy to hit cgo wall if you're not an AAA company. My personal measurements show that around 5000-10000 C calls amounts to roughly 500 microseconds in total. I'm OK with it.
Personally I don't like the mix of Yaml+Jinja2 which Ansible is using, and wanted to keep things simple by using a single language for the DSL. We've been discussing the various options of DSL in this issue here as well. * https://github.com/dnaeon/gru/issues/30
That is your conclusion; the mine is that I prefer a language with more features to use any of them in case I need it. Anyway I prefer the syntax and the error handling in Rust or Swift over the other languages (Go and Dart).
As tempting as it is to down vote this as an agree/disagree mechanism, lets take this argument on. &gt; Go is good at writing net-tools(servers and co) and cli-tools. That's about it. I would say that Go definitely excels at this. But to say, "That's about it" really sells it short. There's going to be more factors when asking yourself, "Should I use Go or something else?" Things Go can bring to the table, off the top of my drunk head: easy syntax, quick compiles, portability, easy C binding, solid standard library, static binaries, decent execution speed, speed of code construction.... I feel that posts like yours assume an infinite timeline or amount of resources. Like, yea, C++ or C or assembly will get you better performance. The question as always is, **"At what cost?"** That's where you evaluate other strengths of Go vs other languages. 
Plugins! https://beta.golang.org/pkg/plugin/
[removed]
That's 30 frames???
60 FPS is 16.6 miliseconds per frame. This is only 500 microseconds consumed by cgo (which makes 0.5 miliseconds) so i still have most of the time to be consumed by my actual game code.
BTW this also gives me incentive to switch to better OpenGL practice. I'm now trying to implement bindless textures on my game to drastically reduce OpenGL calls
Does the "c-shared" and "shared" build options are now supported on Windows platform ?
You realize Go is a google programming language right? If you don't like when companies overstep their bounds, then you should drop Go right now, because google as an entity is much worse than reddit or the reddit CEO. 
I agree with you, and I tried to configure my application to ignore some error checks, but I discovered that is not so easy as Readme tells. =/
Correct me if I am wrong but this article seems like it is introducing 4 new Go packages and mentions 1 more. That is cool and all but I wouldn't call that "tips".
lmbo
Newer versions of errcheck ignore some known always-nil errors on some stdlib functions and methods. The list is incomplete (patches welcome), and it's based on methods, not on arguments. That is, there's no way to ignore fmt.Fprintf only for specific types of io.Writer.
s/broke/break/g
I'm a Google engineer working in cloud, and I used to be on the Cloud SDK team. I (and one of my colleagues) did a lot of the original framework that makes it easy for Google engineers to jam things into gcloud without making gcloud suck. So, gcloud UX is a topic close to my heart. Also, there was a customer for the product I work on now (https://cloud.google.com/container-builder/docs/) who couldn't use 'gcloud container builds' because it was in a new version of the SDK, and they were pinned to an older version so that 'gcloud app deploy' wouldn't have some new undesirable behavior. If pincloud had been available at the time... I wouldn't have pushed so hard to have that behavior fixed in the most up-to-date version of 'gcloud app deploy' :) but also they could have used the cloud build CLI more easily.
&gt;As codebases grow, it becomes infeasible to do all the repairs at one time. The repairs must be done gradually, and the programming language must make that possible. I argue that tools should make that possible, not the language.
Scan RSS list in Feedly. Open interesting ones in browser tab, comment if desired.
Does dmesg or anything else tell you which illegal instruction?
Also affected: GL-AR150 with custom firmware where `make menuconfig` suggests fpu emulation is enabled by default.
trolling? you started this entire discussion with the following statement: &gt; Can we also get rid of you then? tell me again how /u/OdinSQL is trolling, and you're the one contributing useful feedback?
I have a feeling you will enjoy [this](http://store.steampowered.com/app/370360/). :)
You can use the [Insert()] (https://godoc.org/labix.org/v2/mgo#Collection.Insert) function of your collection to insert your user. The function will return an [error](https://godoc.org/labix.org/v2/mgo#IsDup), if the user already exists. You can check the error like this: err := r.C.Insert(user) if err != nil { if !mgo.IsDup(err) { // TODO look for that specific user in the database and update it // or inform the user that the username/email already exists } // TODO }
I'm nitpicking, but an order of magnitude is 10x
Btw it is a good idea to [ensure an index](https://godoc.org/labix.org/v2/mgo#Collection.EnsureIndex) in your collection.
I think I failed to provide enough context. I meant that the tooling should allow you refactor these types *throughout* the codebase all at once, rather than gradually. This is already done by any decent IDE for Java or C#. And I don't see what would prevent tooling from doing the same in Go.
[CoreOS](https://github.com/coreos) has a bevy of open source Go stuff. Full disclosure: I'm a community manager at CoreOS
Was just poking around traefik's repo the other day. What you're doing looks super cool!
Did you read the article?
It would work just fine, you'd just have to make careful use of the unsafe package to do it.
Oh that page isn't 503ing anymore!? yay!
&gt; Just as long as you're okay with them forcing you to use your real name or disabling your account if you don't Wow really? Has that actually happened!?
So, a suggestion: Currently I use a script called `dtrx` which does the following: - If the archive contains a single folder as the top level item, it unpacks the archive as is. - If the archive contains multiple top level items, it makes a folder named for the archive, then unpacks the archive into that folder. The benefit is I can type `dtrx something.tar.gz` and not worry about my current directory ending up with a README, INSTALL, fifteen C files and a Makefile in it. So... Maybe Archiver should have the same behavior?
You seem to only be considering the case where the refactor is happening within a single codebase, or multiple codebases controlled by a single entity. Consider the use-case of moving `Context` from the `x` sub-repo into the standard library. There are many repositories outside of Google's control that would benefit from an in-language way to forward the old type to the new type, given that it is not possible to refactor all code across a distributed code set all at once. 
People like you are the ones who allow bad things to happen in the world, brushing people off and calling them trolls when they take an ethical stand against egregious and unethical behavior from companies. Nothing more than judgmental trash without an ethical bone in their body to stand on. It's sickening. "First they ignore you, then they laugh at you, then they fight you, then you win." - Mahatma Gandhi
Thanks 😊
&gt; 's repo the other day. What yo I'm interest too, how can I help you in traefik.io?
No, it's very a topical subject in light of recent events and this post is linked on reddit. Therefor, it's not out of context.
golang.org shows the documentation for the stable version. beta.golang.org is new, and shows documentation for the latest unstable version. tip.golang.org shows the documentation at tip, but is frequently down (we have some infrastructure problems to sort out, there), so /u/bradfitz set up beta.golang.org so people have access to 1.8 documentation.
"Corruption and unethical behavior is okay as long as it only affects others and not myself at this current moment. So just shut up about it."
The user would point to a struct and the tool should be able to move it to the new package with all its methods and rewrite all its uses. This is the Java and C# IDE functionality I had in mind when I brought it up.
It looks like it's an HTTP client with automatic retries with backoff, among some other things. Stuff lots of people do by hand.
Yeah sorry maybe I just used that short hand because I've been in a world of this for a few days. Yeah basically this package decorates the standard http client stuff to handle when things go wrong better. The decorators are: - Retry, allows for automatic retries with a backoff strategy and error classifier to tell it which errors should just be ignored and which ones should be retried. Useful because transient errors will happen. - Breaker, which will cause a "circuit break" when too many successive errors happen from the underlying client. When the break is open requests will automatically fail without even attempting the http call. This is useful if you are connecting up a long lived process to another service that experiences outtages (basically every service out there). - RateLimit, will ratelimit your underlying http client so that you can limit the amount of http requests being made at any one point. I was getting a lot of errors because my client would end up making a bunch of requests at the same time and saturated my underlying tcp connection. - Logger, which prints a useful summary of the http call. Not strictly adding any resiliency but does help you figure out what the hell is going on when something goes wrong! That explain it a bit better?
https://www.reddit.com/r/golang/comments/5fv8xw/alias_isnt_in_go_18_what_should_be_in_go_19/dao2yp0/
Maybe I'm not understanding you fully, but how will a tool like git or mercurial help me here?
Wow, that's pretty awesome. I'm definitely going to have to play with that. I might say goodbye to Wordpress lol
&gt; but I dont see anything stopping Go to getting to that level itself. Me neither.
Oh, I missed that bit. I was just skimming the page and not reading it thoroughly :P
Read the file in and use fsnotify to monitor for changes. When there is a change, compare each line of the file you have in memory with the new file and you can tell exactly what was modified.
https://invite.slack.golangbridge.org to get an invite then just gophers.slack.com
Thanks for the clarification!
What are the changes for json?
Have you tried running it against Java 1.8.x instead of Java 1.7.x? Just since thats what the op was asking about. Edit: I was also assuming that with the new SSA backend things would be improved a fair bit in Go 1.8 as well.
Nice work, are there any plans of supporting compression levels ?
Sorry, I don't know what I tried before. You are correct, it does run indefinitely until `done` receives a message.
Thanks for showing me `go-diff`! I was able to use it to get what I need.
Thanks. Not at this time, no.
That fixes it on an individual package basis, but it doesn't help me when I use two libraries, one that has upgraded to the standard library `Context` (pkgA) and one that is lagging behind and still uses `x/Context` (pkgB). Now I have an incompatibility in my application and I can't pass `Context` from pkgA to pkgB. Sure, I could take it on myself to update pkgB (with the help of good tooling, yes), and then deal maintaining a fork while I get the changes upstreamed, but that's kind of a pain and it seems like it would be nice if the language could handle that for me somehow.
Just trying to execute a loop once every `Duration`. This is exactly the point of `time.Ticker`, except that I need it to tick once instantly when it's created.
That particular use feels like a hack and very much the kind of thing some of us are worried will start popping up in codebases. In this case the solution isn't as painful as you describe it. You just fork, run goimports, submit the PR and vendor your version instead of upstream. It shouldn't take you more than a few minutes and fixes the problem properly instead of adding another level of indirection to keep in mind when reading the code.
Run the tool in your vendored library.
This was worth reading just for the step-by-step illustration of a concurrect tricolor garbage collector.
Python
Python if you want a good complimentary language to Go, keeping in mind you won't be learning many new computer science principles coming from Go. But you will learn a practical and high velocity language that works good for front end development, which compliments go well. Rust might be a cool learning experience, with more take away around lower level concepts.. I would consider it very close to Go.
Allocating stuff only on the stack isn't insanely obvious due to the escape analysis. If you get the address of a variable or send the variable on a channel anywhere later in the function, Go will helpfully allocate your variable on the heap if it can't determine that the pointer can't leak outside the function.
Thanks!
 for c := time.Tick(1 * time.Minute);; &lt;-c { // ticks immediately and every 1m thereafter } Via https://groups.google.com/forum/m/#!topic/golang-nuts/H_55uzPp98s
I like this one the most, but I lose the ability to wait cancel with the Context
Nodejs
I'm not familiar with Go's unsafe pointers. So are you saying that they are not traversed by the GC? How are you supposed to free memory?
I'm also really excited about plugins. Not sure why though
Thanks for the info. &gt; gox often includes vendor/ commands Apparently, gox is a tool from the pre-vendor/ era.
&gt; and I want to learn something new If you want to learn something new but not necessarily new itself why not try Java?
Me too. I'm hoping/assuming it will make it possible to package things like caddy properly.
context.Context always as the first argument ;-) https://blog.golang.org/context
Thank you very much. I've been a software developer for some time now, professionally for 3 years, and I've never heard this term even though the concept makes total sense and I intentionally implemented tools with it in mind. Or did you just pick an adjective that sounded nice?
If you enjoy functional programming languages, Clojure is really great for web dev. It's JVM based, which could be a positive or negative for you, depending on your perspective. The language is expressive and fun, and there's a fairly large web development community.
FPS is very poor way of measuring performance, you can have 60 FPS and still very jerky output with lots of stuttering - all FPS checks is how consistent frame rendering is, it doesn't measure real performance which is how long it takes to render one frame. I suspect there most likely are some frame latency issues with GC.
&gt; How are you supposed to free memory? Good question. I won't. Instead, I would use some memory management package like this one: https://github.com/teh-cmc/mmm
80% of my excitement for the plugins is in regards to Caddy! :-) I don't know if they'll implement a non-Windows solution, though, so I don't know that we'll see the plugins hit Caddy during 1.8. We'll see.
Oh! I hadn't seen that.
Anyone know how the chart was created?
Yes, the offset field is used to make it so that the same group isn't always in the enabled sample set. That offset is calculated based off the name you set for each flag so it should keep flags with the same name consistent. 
I usually do that. So in this case it would mean duplicating the following instruction ? return strBuf[copy(strBuf, str):], nil Anyway, the rule of thumb I follow now is to not use the := in blocks unless I sure the left hand side variables are only used locally. 
+1 for *go vet* I didn't now existed. Thank you very much. 
Thanks, makes sense. So it's some sort of session-level behavior switch that can be used for randomized A/B testing. 
You missed the string copy in the if block. This code example (that I don't use anymore) is returning a slice of the remaining free space after writing the tag byte, the string size and the string size in buf. shortStrLen, shortStringTag and longStringTag are constants. I'm not very keen of full upper case constants and, beside, the first letter can't be uppercase because it is not exported. The file is small and consts are declared at the top. So this should be obvious for the reader. My rule of thumb is to not have global variables, unless it's Friday ;)
The is another problem with :=. If the right hand side is a function, the type of the variable is not clearly visible for the reader. This hurts code readability. It's ok with a smart IDE which can show you the signature of the function whon clicking on it, but it harms productivity. On the other side, this := is very handy and increases productivity. It just has to be used wisely. That is the difficulty I'm having. ;)
I hope this'll allow me to use Go for game development.
Someone was keeping a wiki page of "Moved to Go from X" articles. Has this been added to that list yet?
Sorry
Not that I know of. Care to link to the list?
For me, I would go super esoteric because Go fills in the practical needs: * Crystal * Elixir * Nim * Racket 
I've been thinking about this comment and I think it's really spot on. It would be cool to be able to specify my interest areas (time series data, recommendation systems, redis, etc.) and get stories catering to those. Even code snippets for different libraries and packages or Stackoverflow question / answer pairs would be cool. The TIL idea is cool. Would you be able to stomach a daily email of this kind? What would you want to see? 
 I wonder if its possible to convert existing C assembly into Plan9 assembly via this?
Scala is great for web dev with the Play framework. Great combination of functional and object oriented. Runs in the JVM which can be good or bad depending on what you are used to or looking for. I didn't like it when I first started working with it but it's really grown on me after the initial learning curve. That being said I still love Go and it's my go-to language for personal projects.
TypeScript makes js less shitty.
Thank you for replying :) 
Elixir is getting some nice momentum and is centered around concurrent web applications. 
&gt; I think the kinds of things that have been being posted to /r/golang have been fine thus far +1 on that. I contribute as much as I can, and come here almost daily for a variety of reasons. I also frequent https://forum.golangbridge.org/, and I think the diversity is important.
The no-op no-op no-op interface maneuver can work as a substitute?
First, I've seen a few people mention that this sub's purpose is to disseminate new blog posts, projects and other content that may help people learn Go or advance their Go skills. I am strongly in favor of that purpose. I use this sub to post new Go In 5 Minutes episodes. It happens to be a great way to reach Gophers and foster discussion on each episode's topics. Second, I think engagement could be improved. There is usually discussion on each thread, but nothing that brings people together. I look in the Gophers slack and see channels like "show and tell", "reviews", "writing", and similar. The spirit of these roughly matches the examples given in the OP. Why not give something like "show and tell fridays" a try, and integrate it with the slack channel?
Rust would probably be my distant second choice. Possible something on a VM like Kotlin/Java/C#.
It's probably not cool to say, but C# is my favorite programming language. I'm not a fan of ASP or Windows servers so I try to avoid it for web work. However .NET Core looks interesting, I'll give it a try. EDIT: I just found out AWS Lambda runs .NET Core which is perfect for the project I'm working on now. Thanks for the information.
I'm pretty proficient in C# and I'd like to learn something with a slightly different paradigm.
Clojure
Is this guarantee documented anywhere? Also, which operating systems? I thought it only guarantees that the file will still exist, at least according to http://stackoverflow.com/questions/2028874/what-happens-to-an-open-file-handler-on-linux-if-the-pointed-file-gets-moved-de
I have benched it. Here are the results: https://gist.githubusercontent.com/nhooyr/58d60bb7f146e1f637945e9cccea0dec/raw/246d84a8623ab3e1a18953ccfb6e07ccbdb541a0/results code: https://gist.github.com/nhooyr/9e049054393ccbf205f6e29ae385b398 According to the link I gave as a reply to /u/The_Sly_Marbo os.Open has the same race condition. The OS doesn't guarantee the file does not change as far as I can tell.
Have a look here at the last example, it's in C... does a os.Stat() os.Open() f.Stat() and compares Dev and Ino's to make sure it opened the same file. https://www.securecoding.cert.org/confluence/display/c/FIO45-C.+Avoid+TOCTOU+race+conditions+while+accessing+files 
But thanks, I'm gonna go ahead and implement it kind of like that now. os.Stat() first, and then os.Open() and f.Stat(). I need to ensure I give an accurate "Last-Modified" header but I can't do that if I do os.Stat and then ioutil.ReadFile. edit: wait, I can't ensure that anyway unless I lock it. Welp, I guess I'll have to lock it. I'll use os.Stat first, then os.Open, then syscall.Flock, then f.Stat and f.Read, then unlock with syscall.Flock. I think that'll do the trick. Thanks!
Have you benchmarked what type of improvements you are getting on top of the built in filesystem cache by having the files cached a second time explicitly by you? EDIT: Have you considered monitoring the filesystem with something like fsnotify so you don't need to do checks, you know if something is stale or not. 
Worth benchmarking to have at least an idea -- why guess? 
Delete $GOPATH/bin and your executable in the directory if you used go build. Now build and try again. If the issue persists it's possible your editor and file system are not in sync, try running cat and seeing if the file matches the editor.
Nononono! Don't lock the file. I'm sorry, but everyone here is wrong. There is no race condition. on request for `file`: f.. = os.Open(file) mtime = f.Stat... if mtime &gt; mtimes[file] { cached[file] = read_and_compress(f) mtimes[file] = mtime } If there was a race and the file was modified after you opened it, what will actually happen? On the next request, stat will get the newer mtime and you read and cache the file again. It doesn't actually matter or not if you have a consistent cache mapping, only that the invariant that the cached mtime is equal or earlier to the time the file was written. what WOULD be a race condition would be if you did if get_mtime(file) &gt; mtimes[file] { cached[file] = read_and_compress(f) mtimes[file] = get_mtime(file) } since with that code you could end up caching one file, but setting the cached mtime to the time of the NEWER file. This will not correct itself on the next request. Additionally, you should probably cache the mtimes themselves.. at high requests/sec with lots of small files, you don't want to bother opening/stating the files 20000 times a second.. instead cache the mtime for 100ms or so, which would cap the open/stats to 10 per second per file. Most likely you aren't replacing your files more than 10 times per second.
That makes much more sense. Thanks! In that case, my current approach is fine right? os.Stat() followed by ioutil.ReadFile?
Yep this subreddit is amazing :)
Okay, I am commenting after a break &amp; I did introspect :-) thank you for your guidance. There is little point in me asking the guide to be more user friendly because it is the documentation and **not** a book. I had this utopian notion that doc should be enough The past week I spent learning JS and then writing an app. Yeah I was wrong and stuff. I thank you for guiding me :-) ( you and the other guy) I'll ping you the link of my book/github guide to Vuejs. I'd love your critique on it :-)
I find modeling and running simulators pretty interesting and can be done fairly quickly. It's not THE most practical thing, but you get to show off a little bit of many Go features. Some ideas - fighter game/player matchups, simple economics, card games. Pick some scenario with fairly few objects and behaviors/interactions and model it with structs, methods, etc. 
Was it related with line segment detector? I didn't see this article but I really need this stuff in go. I am trying to write a wrap for c lsd library. But I suppose native realization should be better.
Should you not protect `cached` and `mtimes` with a RWMutex though?
yes! i mentioned that in another comment. and you'd likely want some kind of mutex to prevent a thundering herd problem on a lot of requests coming in for the same uncached large file.
&gt; doesn't include whitespace Nor [brainf*ck](https://en.m.wikipedia.org/wiki/Brainfuck)
Dude the speed of a web server will only ever matter when you are receiving thousands of requests per second. Since this is a small application, basically any web framework will be perfectly fine. Using the stdlib would be the smartest option since everything you need is there already. You don't need to rely on dependencies.
You should also be able to achieve the same effect with `go clean`.
I think the combination of Go and (client-side) Javascript makes you invincible ;-)
Yes ... it's a combination of segment detection and other filter to create something like [Engraving Effect](https://i.ytimg.com/vi/-tNKVwJmjY0/maxresdefault.jpg)
Good Resource .... Thanks for the prompt response. Actually am trying to create something like [Engraving Effect](https://i.ytimg.com/vi/-tNKVwJmjY0/maxresdefault.jpg) dynamically 
that looks pretty neat! I'd be interested in seeing what you come up with and how you do do if you're planning to share. I've never done any fancy image processing like that in code, but I would if I knew how :) good luck!
I tought I'd share this before the Go community adopts the mistake that is semantic versioning. 
Ironically, I understood that my point was wrong when I faced an issue with double binding of a select tag. The docs gave one simple example which solved my problem, thus, books = more details; docs = as min as possible and generic :-)
I don't really buy it, especially for Go. What's the problem if the compiler sees more code than it needs? Our vendor dir starts to fill up? With dead code elimination, the extra bits don't end up in production anyway. SemVer already handles the identification of breaking changes. IDK, I didn't make it past the first half hour because I wasn't motivated that this is a real problem. Maybe I don't work on large enough code bases.
This sounds very similar to a lightweight hystrix implementation. Is this how you see it going?
In my previous experiences I've only needed two types of "generics" that are not yet supported. I generally have no problem that Go has no generics, except: * there's no simple way to accept interfaces for the elements of arrays, slices and maps; see https://play.golang.org/p/w_HAO9jvwe * there's no way to write e.g. math functions that accept any integer or float type, these are usually small and simple functions The first point requires an extension of how interfaces work. Interfaces are a great way to convey behavior, it would be awesome if they'd work for slices too.
Thank you, thank you so much, thank you so very much.
Cool! Can you provide some details? When exactly did you read it? Maybe some key words? I need this stuff. I will scan reddit until I find it 
That's precisely the problem. Real Go programmers are suffering immeasurably _today_ due to the lack of _any_ kind of consistent versioning and dependency management solution. The window of opportunity for Go to innovate in this space closed years ago. At this point, we _desperately_ need a _good enough_ solution to just stop the bleeding. And that is SemVer; the ship has sailed.
I don't know how it did before, but according to [this blog post](https://blog.bracebin.com/achieving-perfect-ssl-labs-score-with-go), Go's TLS stack now gets an A out of the box, and an A+ if you add an HSTS header.
Nope, my server running behind Go's TLS and ACME implementation gets an A (now A+ because of HSTS) https://www.ssllabs.com/ssltest/analyze.html?d=aubble.com&amp;s=159.203.24.82&amp;latest It could be even higher if I had an http server running behind it (done now) and gave up some compatibility with older clients.
I believe that because most of the Go core team members were working at Google, they could never really find a good solution for this problem since they never had it. The window of opportunity for Go to innovate in this space is right now.
&gt; IDK, I didn't make it past the first half hour Then you missed out on some of the best parts.
Thanks for the corection, that's wonderful news.
Another advantage with generics that you didn't mention is that the probability of creating an error is obviously greater if you have to right similar code again and again, adding development time and test time with each iteration.
I don't think the compilation time is the main problem with Generics on Go. For me, the main problems are the source code unreadability and the lack of useful compilation errors. 
I didn't call it generics. I called it `goreify` and used the language "a form of generics". It lets you write code once and re-use it for other types, using a standard part of the language tooling (go generate). It's clumsy but it's the best I could come up with. Some of us actually use Go to write code and this library has practical applications: https://github.com/badgerodon/container/blob/master/unrolledlist.go
&gt; It occurred to me that generics could mess with incremental compilation, is this the reason? Can languages with generics not incrementally compile in the same way? Yes there is a reason. Go does incremental compilation at the package level. When you compile a package, all the dependencies and everything you need from them is already compiled, so all you're doing is linking functions. With a generic function you have to generate the concrete implementation, so if the generic function can be exported, it means compilation is now much more complicated, since it's no longer just linking. The exported code is really more of a template than actually machine code. C# solves this problem by putting the types directly in the bytecode and generating the code at runtime. Java solved it using type erasure. C++ is just slow. Maybe there's some other way to do it more efficiently, but from what I've seen, other languages all have this problem as well. (rust, scala, etc) 
Yea everyone better stop doing things they enjoy because someone who is generally unhappy with their life may get upset. Oh, wait, people who are unhappy are actively seeking things that reinforce the position they want to remain in. The truly miserable ones may find company anywhere, including posts about programming in a specific language in a small community about a specific language. Isn't there somewhere else for you to be unhappy at? Perhaps with people who are also miserable.
You are missing OP's point that the time spent by the compiler is now spent on the human who has to expand the "generic" manually. It also makes the code more brittle because there is now multiple implementations of the same algorithm that must be updated. 
I for my part would be happy having `map``filter`and a couple of slice functions - this would still reduce significantly the visual noise. Having a `set` type would be nice, too.
I'm a big fan of code generation myself, though I usually end up writing python for loops adhoc since it's usually a one shot thing that doesn't take much time. One thing that's never clear to me when I've checked out gengen or your library is a breakdown of the process and what you end up with. For example with your readme you show me: Given this function "Sum(..)..." you get "Sum_int()". This leads me to ask first where was Sum defined? Was it inside a template file or my Go code? Clearly it can't be in the Go code without you mutating the function to dispatch it to the types versions. So the next thing I want is to see the dispatching! Because that's the most important part, I've done a good bit of working around this area, as unidiomatic it may be. I.e. [go-conv/map.go](https://github.com/cstockton/go-conv/blob/master/map.go) uses a giant type assertion because it only allows a fixed set of types. But I use a different technique in [go-call/analyze.go](https://github.com/cstockton/go-call/blob/master/analyze.go) and perform some basic heuristics first since it's a longer lived object and select a fast method if I can, but fall back to supporting everything. One thing I gave up on return types because it's impossible to do with a nice API or single entry point. Instead I've taken a approach like: [this](https://github.com/cstockton/go-conv/blob/master/slice.go#L12) and require callers to pass a reference. If a generation library would take care of the uglies required under the hood for that it would be a nice win, because I'm super picky about public API and cluttering it up with generated code is something i avoid. Like a sum in a generics form may look like, excuse formatting mobile: Sum(total *T, from []T) error Caller can use as: ints := []int{1,2,3} total := new(int) err := Sum(total, ints) The downside is that you take a interface and return an error. The plus side is a tidy API for caller and a bit more room under the hood to optimize maybe. Be nice to have some heuristics that use go/types and generate the operations with the safe possible conversions statically, with a fallback to a runtime assertion into a set of T the original template code could use. But yea, just stuff about this topic I think about since I find it interesting and useful. Cool project and good work! Have fun.
I don't think I missed ops point, though you may have missed mine :) I think rsc is well aware of the cost to humans by not having generics, the proposal doesn't quantity anything including compile times. It simply lists the metrics that would be used when there was something far enough along to be quantified. How they all add up relative to each other is impossible to speculate without something to measure in front of everyone.
I believe it's this one. https://github.com/golang/go/issues/16293 . Applies only to maps with pointers
In the example, the original Sum function was defined in Go code, specified as part of the command line args: https://github.com/badgerodon/goreify/blob/master/examples/sum.go It's actually callable in its original form using big type switches: https://github.com/badgerodon/goreify/blob/master/generics/builtins.gen.go#L44 // Add calls the '+' operator func Add(x, y interface{}) interface{} { switch t := x.(type) { case complex128: return t + To_complex128(y) case complex64: return t + To_complex64(y) case float32: return t + To_float32(y) case float64: return t + To_float64(y) But you would really only ever use the more concrete version, at least for a function like Sum. For a container it might make sense to actually use the `interface{}` version. The program should handle receiver methods (so you can generate code for a type `List`) as well as global functions which return a type (`func NewList() *List`), so you wouldn't have to pass in a reference parameter. I agree that if you're not generating code, it is a little cleaner. (It would be the standard pattern for things like `json.Unmarshal`) There are probably lots of edge cases I'm not thinking about. Also there are code patterns which I don't know how you implement using generics: func NewPair(els ...?) Tuple&lt;?,?...&gt; Or: func Zip(lists ...[]?) []Tuple&lt;...?&gt; In practice languages like C# just provide implementations for each one: Create&lt;T1&gt;(T1) Create&lt;T1, T2&gt;(T1, T2) Create&lt;T1, T2, T3&gt;(T1, T2, T3) Create&lt;T1, T2, T3, T4&gt;(T1, T2, T3, T4) C# also can't do generics with numeric functions... but maybe other ways of doing generics are more powerful and can handle these things.
Disclaimer: I don't know much about compilers. I can see there is a difference between compiling at package level and depending on them just being linking versus depending on an extra compilation step when depending on an exported generic function. So my question is then, how do languages with generics approach incremental compilation and what are the measurable trade offs? I know that rust is working on this; do their exported generics have some kind of intermediate representation?
I won't get into why this isn't a good idea, as its specific to the "ReadCloser" type and not productive overall. What you asked for is this: func read(readers []io.Reader) {/* .... */} readClosers := []io.ReadCloser{} read(readClosers) How is having a separate function like that can take a "generic" any better than just doing this? func readOneCloser(rc io.ReadCloser) { /* ... */} for _, rc := range readClosers { readOneReadCloser(rc) } One of the best things about Go is that it forces a specific type of programming, that makes things more "standardized" -- in this respect, it forces you to write one specific way of doing something, which in the long run makes it better because when you come back 5 years later trying to figure out what your code does, its that much easier to digest / intake again because it's all standardized. Also, I'm thinking that what you are looking to accomplish is type assertion against a slice of interfaces: func DoSomething(things []interface{}) { for _, x := range things { switch v := x.(type) { case io.ReadCloser: /* do something with v, which will be of type io.ReadCloser */ case *MyType: /* do something with v, which is a *MyType */ } } }
Yeah they break up the compilation into multiple stages and (try to) cache each step: https://blog.rust-lang.org/2016/09/08/incremental.html . C# has a staggering number of passes: https://blogs.msdn.microsoft.com/ericlippert/2010/02/04/how-many-passes/ . I've made toy compilers before, but never tried to implement a type system... I think it's really hard. Programming languages are so complex it's amazing they work as well as they do. Go is much simpler, but it's not trivial. Alan Donovan gave a talk at Gotham Go last year that talks about resolving types: https://youtu.be/p_cz7AxVdfg?list=PLeGxIOPLk9ELh9tsPZMzau6CzMjfMzp9-. Compiler performance is not the only consideration. There's also the cognitive burden it adds to the language. If it's hard to imagine how the compiler can possibly build the code, how do we expect programmers to understand what's going on? I tend to be in favor of generics and hope they add them, but it will be a sad day when Go becomes a hyper-technical language only suitable for experts and I have to try and explain what contravariance and covariance are to new developers.
Hey, The StackOverflow questions with an accepted answer or decent discussion would also be nice to get included. The daily or alternate day email in a 1-2 minute readable with 'Read More' link(which may take longer to read or watch) would be what I would personally prefer. Content may be regarding to code or how to use a library with examples and when to use one over the other alternatives. 1. A simple example could be when I should use a library like a "gopkg.in/yaml.v2" package and when I should use the one from the standard/built-in library with pros and cons exploring different angles for programmers. 2. Another example could be in the lines of How Go Routines work and make use of all Cores with an example for users to run their own. All these could be already existing articles, otherwise, creating content would be the most time taking part. The current TIL Ruby/Elixir feed I follow usually takes me like ~30 seconds per post to understand what they learned that day with help of a code snippet.
If the data can be mutated only you can really determine if locking is needed. If you are using a proper caching mechanism it would make sense to lock the file, the cost is minuscule. If flock became a point of contention you should put the file info behind a database and version them (or evaluate if they should even be stored as files).
Generally speaking, leaders should care about the communities they control. It would be good for everyone if disgruntled moderators stepped down. I'm glad that Brad had the decency to step down after voicing his desire to shutter the community without offering any evidence that such a drastic thing needed to be done. I have no idea what the other Go leaders think, and I dare not waste my time in that horribly depressing Google thread again to find out. I hope people choose to do the nice thing. Too many men wish to destroy what is good in the world in pursuit of purity.
D has templates and compiles fast.
thanks for your reply, it helped me a lot. i will fix these stuff and get back to you.
It's pretty rare though that you have to run the CMakeFile during normal development. When you do, it takes like 2 seconds extra or so, and that's only when you add a new file etc, as you say. Also, you don't have to manually re-run cmake, it happens automatically if necessary when you type `make`. Anyway, this is a property of the build-system (if anything) not the go compiler, so it's a different matter anyway. At work, we're still using a build-system (not cmake tho) with go, for instance.
This is great. I think I agree entirely. Any interest on working on this? :-)
&gt; it was 15-30 seconds easily That's insane, I've never experienced it taking that long, even when building very big projects (e.g. OpenCV which uses cmake or ~500 000 LoC Qt codebases.) I don't think that's a typical experience. &gt; it isn't somehow faster simply because the makefile kicks it off Yeah, I just wanted to clarify that this isn't necessarily a step that needs to be done manually &gt; builds get exponentially slower the deeper you go. That's true, but I still don't think it's generally a big issue. With e.g. clang and -O0, it builds as fast or maybe even faster than the go compiler anyway. And generally the deeper stuff in the hierachy isn't modified very often (because it forms a relatively static foundations, e.g. vector classes and other such basic primitives/datastructures.) And if you have very deep structures, then that's kinda a code-smell anyway, IMO (but okay, that is really situational.) And anyway, I think adding templates has the potential to speed the compiler up rather than slowing it down. As mentioned because emitting a templated code N times is faster than compiling the (close-to) same code N times from scratch, and secondly because this could also actually act synergistically with incremental compilation. Consider the two following scenarios: - have a datastructure.go handling ints. 100 .go files use this datastructure. You now need to duplicate the code to also work with strings, so you add a string-based implementation of the same datastructure to the same file (maybe auto-generated.) 100 .go files need to be re-compiled - have a datastructure.go handling template type T. 100 .go files use this datastructure. You now add .go file 101 that uses the datastructure but with template parameter string. Since the datastructure.go file has not changed, only 1 file needs to be recompiled.
Source: https://octoverse.github.com/
This seems very interesting. The controller mechanics look interesting and very ergonomic, though different then the standard library way. I'm going to be reading its implementation soon. Out of curiosity: Have you benchmarked your framework?
Happy to hear that! Nope, I haven't benchmarked it yet. Any recommendation on which benchmark suite you would like to see used for utron?
&gt; Go becomes a hyper-technical language only suitable for experts and I have to try and explain what contravariance and covariance are to new developers go doesn't really have subtyping, so you avoid that by saying they're all invariant
Very good point! I can see how the rewrites would make for better articles (performance/server requirement comparisons). I like beer so point 3 rings loud and clear haha
We definitely have a limited view from our internal use as we're still maintaining our legacy RoR apps and I personally am just learning Go. I've seen plenty write-ups of how companies are swapping in Go for performance intensive parts of their backend, but hardly anything about ground up builds 
Our entire backend has been built in Go for nearly 3 years and it is awesome. It's crazy performant for CRUD operations. I'm surprised when we see double digit ms server-side latency for most calls. If I were building from the ground up today, I would architect everything using gRPC, then put https://github.com/grpc-ecosystem/grpc-gateway in front of it. That gives you performant, self-documenting code that can still be accessed via REST. We're actually about to start this migration from our existing code base. It also sounds like you are a dev shop, building lots of CRUD apps. I would look into https://goa.design/ as that could save you a lot of dev time. You design the API, including validation, types and even relations into your data. Then it uses code generation so you get performant code with the ease of use of reflection.
&gt; IDK, I didn't make it past the first half hour because I wasn't motivated that this is a real problem. Yeah, same. Haven't really felt any pain from semver so far, but have definitely felt pain from not using semver. Does anyone want to provide a TL;DR version of this argument? I'm kinda curious, but I don't want to spend 1hr 15min of my life on something that I don't know if I should care about.
I'm not sure about a benchmark suit. But it would be nice to see benchmarks of both simple and heavy HTTP serving. Suggestion: Since you created the utronframework Github organization to include examples, how about moving the framework itself there?
Go isn't as easy as some languages when interacting with SQL databases. 
don't use this. it re-parses the templates before each rendering which is redundant.
Looks really neat! However, why the underscores? This will make all my linting tools while about the generated code.
i took the last 10 months to rewrite our file processing layer from C# to golang. this includes a web API, interaction with rabbitMQ and S3, etc. it's been rock solid. a big headache i encountered was conflicting JSON representations of the same conceptual data structure. for example, the System.TimeSpan class in .NET is serialized to something like d.hh.mm:ss.fffffff, but the equivalent golang struct is the time.Duration struct, which is an int64 nanosecond count. it's not that big of a deal, though, because you can just implement `UnmarshalJSON` and `MarshalJSON` for any customer serialization logic and interop just fine after that. in hindsight, we didn't pay enough attention to the .NET serialization design. we *should* have always serialized things like System.TimeSpan to a more "universal" data structure, like a float or integer, but you know what they say about hindsight. i'd highly recommend using go for anything network related. for example, a service exists in our backend that takes a message off of a rabbitMQ queue and then simply makes a web API call. the instrumentation around the .NET implementation indicated that these calls took around 350ms or so. after switching to the golang implementation, the runtime of these calls decreased to around 30ms!!! granted, the web API being called was also written in golang, but that's a great feeling. golang is also great for concurrency. we wrote a simple worker pool in golang in just a few lines of code. sure, there's always the `lol no generics` argument, but i've found myself missing them maybe 5-10% of the time i'm writing go. i make this trade-off because go is fast, and go just works. 
This might help: https://gocodecloud.com/blog/2016/11/15/simple-golang-http-request-context-example/
I was told that C++ is obsolete and Rust is its successor, but this graphic suggests otherwise. Was I misinformed?
Yes
awesome tool! Here is my implementation of a similar problem: https://github.com/taylorchu/generic. The major difference is that it generates code at package-level instead of function. Package could contain an implementation that is more complex than a single function, and gives a namespace for the generated code. There are more in the readme: https://github.com/taylorchu/generic#faq. Also don't forget to add some tests! 
Why?
https://github.com/julienschmidt/go-http-routing-benchmark
Hmm not sure how I feel about pull requests as a metric for popularity. I suppose commits wouldn't be much better. Maybe show me a graph of every metric type and I'll side with the one that aligns with my own perspective :)
&gt; Curious, what are you using for graphql and go? You... you gonna answer that?
goa feels like a bloated grpc. With grpc around, I cannot see a use for something like goa.
We switched from Node to Go about a year ago and have a much more reliable and stable service now. It was quite a success. Our backend runs on almost 100 servers and processes dozens of millions of things every month and it works pretty well. 
This. Yet none of the 'everything sails smoothly' comments in this thread mentioned anything about sql. What do you guys use?
A few people have stated the same migration in this thread. None described the technical details. - What did you replace ActiveRecord with? Raw sql? - There s a good chance you were using Devise or similar, what did you replace it with? Home grown auth?
How come you decided Go over migrating to .NET Core?
I will say that ORMs are more annoying in a staticly typed language (especially one without generics). There are a few go ORMs, but I hear they aren't as nice as ActiveRecord. Many gophers don't use them and just write their mappers manually with the sql or sqlx package. I'd expect this to be the biggest pain point coming from ruby. Edit: I haven't actually used ActiveRecord myself, so take this with a grain of salt. 
Indeed. Also all of the Go standard libraries (including /x/ ones) do not use Pull Requests but rather Gerrit -- so this excludes some of the most significant Go projects today..
goa and gRPC aren't mutually exclusive. They do solve some of the same problems, but there are a lot of great things you can get from goa that aren't in gRPC, like middleware handling, auto decoding/encoding support, auto-generated validation functions, just to name a few.
We use straight database/sql and it works great. The only major issue I have with it is the lack of context support, which is being resolved in 1.8.
Okay, I will see what I can do about that. One note is, utron uses gorilla mux router, and the router has lots of benchmarks. It makes sense to bench utron though as a whole lot of different routing setup is used. That is the plan. In long term, the framework will live under he organization. For now my focus is on documentation, and tutorials.
&gt; What did you replace ActiveRecord with? Raw sql? It was running on mongodb, so it got replaced with upper/db and mgo. Not long after my push to switch to PostgreSQL was successful and we're using upper/db + bond. &gt; There s a good chance you were using Devise or similar, what did you replace it with? Home grown auth? Yes and yes.
And most of the significant C projects don't use pull requests either (e.g. the GNU savannah ones, the linux kernel with its mailing list, many other mailing list oriented ones). Same for C++ (firefox/chromium both use their own tooling for that). Some very significant java is under the apache foundation and also doesn't use github... Tons of javascript and PHP aren't even version controlled properly and tons of that also isn't on github. ------------------- Your claim that Go could be less represented due to this is frankly retarded if you take a quarter second to think about it. All the other languages I mentioned predate github, and so naturally important projects started on other source servers and many of them never moved. Go is massively over-represented on github because it came out after github was so big and because of its go-get integration therein, as well as all the large go projects being on github. Almost every other language's largest projects live elsewhere due to predating Go and Github.
&gt; It's a fucking pain in the ass to have to write loops to find an element in an array, to filter or map or reduce an array. Writing your own map() and reduce() functions is [trivial](https://appliedgo.net/mapreduce). &gt; Rust looks sweeter everyday I spend using Go. May I take a wild guess - It was not your own decision to use Go, right? Rather something like, you are in some dev team that decided for Go and you had to agree. Otherwise I guess you would have left Go for [Rust|D|Haskell|enter your favorite language here] a long time ago.
Whoops, thanks for the reminder!
By what measure?
Very nice man, congrats on 2.0!
I'm pretty new to Go, but I've been using prepared statements of raw SQL. For selects I wrap all fields that could return NULL in `COALESCE` functions with a default value so I can use the row scan functions without having to write a ton of weird error handling for the types. If anyone has a better way of working with NULLs, let me know.
I am going with this camp. I have deployed Go backend apps and Ruby, and I would still choose Ruby over Go for HTTP REST API services. The reason why is because these services tend to have complex business logic on them. You know, the kind of logic that only makes sense to product managers and executives. Logic like *"Users who signed up must have all marketing emails sent to them unless it's their birthday or April 1st, or some random promotion that we run determined by our dysfunctional marketing team who wants to control their campaigns from emails and emails only, or unless our lawyers said so"* Stupid requirements like this can be annoying to implement in Go, while expressive languages like Ruby is where it shines. If your corporation has a history of making ridiculous requirements like above, then I'd recommend to stick to Rails. But if you can separate your services into smaller sub-services where the logic is straight-up common sense and less dependent on other departments in your company, then Go is a great choice.
The biggest thing I miss from ruby isn't AR, but the migration system in Rails. I have yet to find a go alternative that allows me to not only migrate my database tables, but also run go code to help with those migrations. If you have any suggestions or alternatives please share them :)
I doubt this is a good metric. All those JS pull requests seem to indicate that everything is broken rather than popular.
GORM. It's a great ORM in comparison to ActiveRecord (this coming from a ruby veteran of ~10 years). I've found that the golang devs that don't use ORMs choose that path because they care about squeezing out the most performance from their code: they often are fundamentally against ORMs to begin with.
Why did we let node.js get to this point? Should've been killed at birth
&gt; Tons of javascript and PHP aren't even version controlled properly The understated-ness of this is huge. HotScripts listed 7000-8000 scripts in PHP before GH existed. All hosted on sourceforge and random code dumps/blogs/forums. Many of those projects are still hosted outside of the github ecosystem and quite a few that do have a github project page just use it to mirror stable branches. The same goes for: * Perl + CPAN * Python + BitBucket * C# + CodePlex and MSDN And the sheer number of C and C++ projects that have self-hosted CVS/SVN servers, exist on numerous other hosting platforms or have no public version control at all is insane. Complaining that Go, Rust or D are *under*-represented on GitHub is just plain naive.
After this [long talk](https://www.reddit.com/r/golang/comments/5af5pw/best_tool_for_database_migrations/) about Go database migration tools I ended up not using any tool and instead using a simple Go script that creates and updates my schema. It is not a full-fledged, generic solution but it requires no dependencies or external tools. I can just run it with `go run`. I am quite satisfied with how it turned to be.
&gt; My first choice would be Rust(if it had proper autocomplete) There's [racer](https://github.com/phildawes/racer) for that.
ok, do you have any recommended about this ? or you can pull-request anyway, I made it to understand logic 
Lol! Noted, I will try to make screen casts about it! 
Looks nice and simple, really goey. You might also want to check out taskwarrior.org.
Heh, I had a lot of hope for Dart but the generated JS is too large (megabytes) for what it does and they've abandoned the native browser module so compiled to JS is the only way. I'd say Elm does a lot of what Dart tried to, better. Saying that, I have a lot of gripes with it, a lot of which are me preferring more of a C-like syntax.
Thanks. Wow taskwarrior is really awesome. it can be good reference. thanks a lot!
Why not just keep using ruby to script your dev environment? I had dropped ruby for years, but recently picked it up again for just that purpose when i started using go for all my backend stuff.
How does this impact client frameworks? Does this mean we'll see Go based frameworks that build parallel DOM and allow you to write your client side app in Go? Could be cool.
Thanks
A good documentation with a "getting started" is even more important.
&gt; Say goodbye to the beautiful ActiveRecord! You'll be writing raw SQL statements. For those who know SQL statements really really really well. That's actually a good thing.
You will not see blog post about basic web app because it's not so interesting, event big apps, it just works. Even if i use Python since decades and Go since one year, now i work faster with Go (for the sames kind of web apps). But more important than that is maintainability in the long term. It's a lot easier to refactorize, no magic to remember, very good tools to check the code when you write and when you compile... Also you don't need to change for scaling or new technology like websocket or else that you don't think now. No more worries about deployment. A lot of things that make you win a lot of time even if in the begin of course you need more time to learn a new language. Sometimes I even have more difficulties to read my own code written 10 years ago in Python because of some magic that I liked before and because I cannot be sure what is used or not than Go code written by somebody else ! For accounting I think you will have to take care of date-time, decimal precision and maybe libs for reporting. After that it will be smooth ! 
Thanks, didn't know about upper.io. Home grown authentication is no trivial, and there is a lot of security guidelines to follow. How much code would you say your authentication system has now? If you need to build another Go web app, can you re-use your authentication system as a drop in?
Doesn't [goose's "go migrations"](https://github.com/steinbacher/goose/blob/master/README.md#go-migrations) do what you want?
For a while now, our DBA(s) have had a policy against null values for the most part. Even before we adopted Go years ago. Still, legacy things have nulls. It means we have to have extra handling with NullString, NullInt, and the like. Not terrible, but not "fun" by any means. 
thanks for your recommended, I will consider it.
On my team we do something similar. We have a log object inside the context, and the first line of any context-aware function looks like: ``` func Foo(ctx context.Context, param Type) { log, ctx := clog.FromContext(ctx) ... } ``` Here, "clog" is a package I made to handle this and is short for "context logger". Then, if you want to add a keyword to the log, ``` log.AddKeyword("foo=bar") ``` And all log messages will have that keyword tacked onto the end, as well as log messages from derived contexts. 
Hi - one of the Browsix authors here. Most of the heavy lifting is done by GopherJS to compile Go code to JavaScript -- we provide an implementation of the syscall package and some other runtime modifications to run programs compiled with our modified GopherJS as "processes" in Web Workers. Happy to answer any questions people have!
That's akin to saying 200 years ago that humans don't need airplanes, otherwise engineers would have long built them. Not having generics simply means 1) there were higher priority issues; 2) no simple enough solution was found yet.
Can it run [links](http://links.twibright.com/)?
The problem for me isn't writing the sql, it's massaging the results of the queries back into stucts, especially when there are relationships in the data.
You've written all this code to parse the port number and make sure that it is valid. If you just treat it as a string you can delete all that code. And if you delete all that code then what is left is just one line: `http.ListenAndServe(":"+port, http.FileServer(http.Dir(".")))`
not yet -- once this issue ( https://github.com/plasma-umass/browsix/issues/33 ) is resolved it should be possible, but it can only possibly work for sites that allow CORS in their configs.
I've created an index for the collection userIndex := mgo.Index{ Key: []string{"email"}, Unique: true, Background: true, Sparse: true, } For some reason it still overwrites the entry that's already in the collection. Is it because I'm generating unique id's in the createUser func?
Why full Go? I think that Go + Java might be good for any kind of stuff.
Lib author here. I welcome any questions or criticisms. 
If you put a logger into your context it means you are glueing your whole stack together from the API handlers to your concrete database implementors in an opaque way (as some already pointed out). My own rules when using Context are those: (1) in the same layer of the stack, use the context for local data which relates to the current request. That data shouldn't leak into the next layer as it should be incomprehensible by the outsiders. (2) Across layers, use context only to notify (timeout / cancel). You don't need to use Context for data that crosses boundaries. There's already a mechanism for that: function parameters. I wouldn't pass a logger to every function call down the stack. I could stop there but here's my architecture so far with golang and others... Each and every layer should be instantiable and testable independently with proper dependency injection. This makes the code more modular, even interchangeable because I define contracts with functions parameters and sometimes interfaces. For example: Your API handlers or your endpoints (1st layer) are nothing more than marshalers to contact your "core" layer. They take user input in the form of http requests and transform those objects to something understandable by your "core". They shouldn't do more, they shouldn't know more. They should be forced to comply to that contract to contact your core. Your handlers are only responsible to handle the http stuff. Your "core" (2nd layer), where the business rules happens, shouldn't know about wether you requests are coming from an http request or a console input or whatever. It exposes a contract to contact it. We are not doing this because it might one day happen but because it makes the architecture better naturally. Your core then contact services or repositories (3rd layer) and there again, it shouldn't know wether it uses a DB or a flat file. I use interfaces here (and it's the only place). The interfaces of the repositories and the models are defined in the core so even if there's no concrete implementation whatsoever, I can focus on the business rules and make the code compile without having a single 3rd party library in there. I usually name the objects that are the entry points "controllers". This is where the dependency injections occurs for me, when I create my controllers. What I'm saying is, each of those portions should be injected independently and shouldn't expect anything from the previous/next stack besides interfaces and function parameters. Even if it means injecting the exact same logger in all of the layers when bootstrapping your app. That's what I do in go and I'm pretty happy about the result. Sorry about the length. EDIT: words
Yeah, I can see that valuable long term, but in the short term I just want to shovel code out as quickly as possible.
But Go doesn't have enough syntax so it's not expressive! /s
Can you do "return (v&gt;0 &amp;&amp; v&lt;65536);"
That would make Go not a good candidate for start ups, where you have to move quickly at start, or die.
&gt; The biggest problem about it is the word "horribly". Why exactly do we need that characterization there? Because it is. You are forced into a date format which is * No ISO standard * is hardcoded * is nowhere used outside the US and it's pure shit even there
&gt; A Symbol is can be “any exported variable or function” I presume that includes constants. As for types, I wonder if the conversation around type aliasing in Go 1.9 will include using the plugin and reflection packages to dynamically import and use types. 
&amp;gt; I presume that includes constants. Some quick testing finds that it does not. Also, somewhat oddly, given the following code in a plugin var Example = 3 looking up the symbol `Example` yields a `*int`, not an `int`.
&gt; I'm trying install a package that yields multiple binary files upon running the "go install" command. Try this: go install ...
The command I'm currently using is: go install -tags netgo ./... This does successfully build the files, but one of the files still doesn't seem to have been affected by the '-tags netgo' :(
is the .so file a shared library that can be accessed by C too or this is just a naming convention?
I have it like this where you can't use anything but the hardcoded formats for log.Ldate and log.Ltime. // SET LOGGING FILE + LOGGING LEVEL logfilename := fmt.Sprintf("%s_%d-%02d-%02d_%02d-%02d-%02d.csv", parameterX, t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second()) file, err := os.OpenFile(logfilename, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666) if err != nil { Error.Println("failed to create and/or open log file") os.Exit(1) } defer file.Close() setLogLevel(int64(g.logLevel), file) func setLogLevel(logLevel int64, fileHandle io.Writer) { infoHandle := ioutil.Discard warnHandle := ioutil.Discard errorHandle := ioutil.Discard debugHandle := ioutil.Discard if logLevel == 1 { infoHandle = os.Stdout warnHandle = os.Stdout errorHandle = os.Stderr } if fileHandle != nil &amp;&amp; logLevel != -1 { if infoHandle == os.Stdout || infoHandle != os.Stdout { infoHandle = io.MultiWriter(fileHandle, infoHandle) } } Log = log.New(infoHandle, "LOG;", log.Ldate|log.Ltime) Warning = log.New(warnHandle, "WARNING;", log.Ldate|log.Ltime) Error = log.New(errorHandle, "ERROR;", log.Ldate|log.Ltime) Debug = log.New(debugHandle, "DEB;", log.Ldate|log.Ltime) }
Yes we can do that. The code earlier was huge with reflection and stuff, that's why it is so expressive.
You don't have to use NullString, NullInt, etc. We just deal with NULL from the database the same as we deal with it from an API standpoint. If something can be null, define it as *string or *int. Our struct fields are already defined that way so we can handle Patch semantics, so it's easy coming out of the DB layer.
Thanks, I hope you find it useful!
&gt;I know what's going on and why, but it is not very appealing
lol, misread that. Well, it's the only way to do it and you'd have a similar syntax in other languages; I think it's cool.
If you didn't get a pointer, you'd get a copy of the current value, which would break things if it is mutated.
That makes sense.
F# or C# handles this kind of stuff like a boss. I mean I don't know about this case specifically but the mixture of dynamic typed things in those languages is done really well in my opinion. This just seems icky for some reason... I mean it's cool and it's a great example I just hope it has a very small set of use cases it gets used for. 
I too am very curious about this. And if so can you load other .so c libraries and call from golang using plugins system?
Hmm I'm not sure, I imagine that they must be compiled in to the .a files. I might be wrong in this context. With binary only pkgs it looks like you need prototype like go files for docs, but didn't see const. Though in this case I don't think you're importing a specific package just the stub that you map to via the type assertions. 
In reality you'd have something like this type AddFunc func(a, b int) int then later fn := add.(AddFunc) sum := fn(1,2) (Although I'd probably chose slightly different names so that the resulting Go function is named `add`.) Also more likely in practice is that you'd be loading a type that implements some known interface, and doing an assertion to a named interface type is pretty natural (and appealing to me).
Faster how? man time For timing the execution of both commands. But honestly it doesn't matter, you would spend more time typing the command. Hit control + r and the "n ma" will likely have you a instant Go run for your main, where as executing the binary requires the name of the command by default. After that it doesn't matter, hit {up} and the last command is ran. Better yet use a fsnotify utility and it runs for you after changes. But there ya go, a real answer for a rather silly question lol..
Finally...I'll know why `json.NewEncoder.Decode` fails. 
Much better! This is how the stdlib API for using plugins should work.
Bump I also would like to know why not?
Now all we gotta do is get this on bare metal and not in the browser. Boot to Browsix. Then we'll have come full circle &gt;.&gt; But no for real it's neat :D
For commercial libraries, for example, when you don't have sources. But another question is why so bad? I can't imagine usage of this with more then 10 functions in the library.
Yes. Faster to type, that is.
The blog article explaining context in a more succinct and direct form is [here](https://blog.golang.org/context)
You can write a "simple" wrapper to add the context functions to your library without changing the existing API. https://play.golang.org/p/L0xBNKNAqG
As a newbie, it's the first time I see an example of level logging using the standard log library. I didn't thought of that. I started using glog for that. This means that all my packages would depend on these set of global variables. There is indeed no need for a context then. But now I have to deal with multiple agents (named go routines) in my main program and I would like to add that name in front of the log. How could I do that with the standard log library ? In my case I use object programming. That is I use a struct to hold context information and only methods. I guess I should use a logging method which itself uses a logging object with the name as member variable. Could there be a simpler and more idiomatic way ? 
Good question, and there's a surprisingly convoluted answer. TL;DR this is the fastest (in general) because it compiles *and installs* intermediate packages: go build -i a.go &amp;&amp; ./a Note the `-i`. When you use `go run` or `go build` without `-i`, any intermediate packages that are out of date will be compiled and discarded on every invocation. You can test this yourself, but here's an example with kingpin where I've deleted the kingpin.a library, forcing the package to be out of date: First up, `go run`. Note that `gopkg.in/alecthomas/kingpin.v2` is rebuilt on every invocation: [alec@cavern:~/Projects/kingpin]go run -v ./_examples/ping/main.go gopkg.in/alecthomas/kingpin.v2 command-line-arguments main: error: required flag --timeout not provided, try --help exit status 1 [alec@cavern:~/Projects/kingpin]go run -v ./_examples/ping/main.go gopkg.in/alecthomas/kingpin.v2 command-line-arguments main: error: required flag --timeout not provided, try --help exit status 1 Next, `go build` by itself. Note that `gopkg.in/alecthomas/kingpin.v2` is rebuilt on every invocation: [alec@cavern:~/Projects/kingpin]go build -v ./_examples/ping/main.go &amp;&amp; ./main gopkg.in/alecthomas/kingpin.v2 command-line-arguments main: error: required flag --timeout not provided, try --help [alec@cavern:~/Projects/kingpin]go build -v ./_examples/ping/main.go &amp;&amp; ./main gopkg.in/alecthomas/kingpin.v2 command-line-arguments main: error: required flag --timeout not provided, try --help Finally, build with `-i`: [alec@cavern:~/Projects/kingpin]go build -i -v ./_examples/ping/main.go &amp;&amp; ./main gopkg.in/alecthomas/kingpin.v2 command-line-arguments main: error: required flag --timeout not provided, try --help [alec@cavern:~/Projects/kingpin]go build -i -v ./_examples/ping/main.go &amp;&amp; ./main command-line-arguments main: error: required flag --timeout not provided, try --help Note that on the last invocation, the out of date package is not rebuilt (because `-i` installs all artifacts). Confused? Yeah.
Even when you do have the source available and, say, it's an internal application and internal plugins... It still has the benefit of letting the plugins have different version streams and product owners than the main application. 
Yo /u/jeremywho, anyone not running OS X is not going to have the Menlo font on their system, and therefore all your code samples will appear to them in their generic proportional-width default browser font. Looks like ass.
&gt; This code can probably be made even better but it works. But that's not a custom date format but a "const nihonDateFormat" = doesn't change any values?
I'm really excited for plugins in Go, but I can't help but feel they're not ready yet. I was playing with a concept for a web server which could dynamically load applications/handlers via a monitored plugin folder. The simplest version, which included a main package to load the plugins and start the server, plus a plugin file defining an exported http.Handler which simply executed a template, failed with a panic about an invalid symbol table. I can't imagine that anything I did was particlary out of the ordinary, as I was only using a few stdlib packages. If anyone wants to try to duplicate this result, [there's an issue open with Go on github](https://github.com/golang/go/issues/18190)
&gt; But that's not a custom date format but a "const nihonDateFormat" = doesn't change any values? You can obviously replace the const with any format you want even `time.RFC3339`. In order to make a standard library `log.Logger` you can now use the function `NewLogger` that takes a custom date format. It is essentially the same signature as the standard library `log.New` except that the last argument instead of the standard library flags (`flag int`) you can pass any date format you want. You can easily change the other functions to pass down a different date format.
Thanks for letting me know! The hugo theme I'm using had that set to just menlo, I didn't realize it. It's been updated!
How would runtime extension functionality make go more or less suited to lambda?
It's just a beta at this point, have patience. 
I updated the post, thanks!
`err = http.ListenAndServe`. I thought this is what you meant. I tested reusing the same port on two different terminal prompts &amp; the program throws an error message and exits. Is that not enough for a simple server? This is a very simple server whoch is designed to be used at a personal level
For your particular use case, it does make sense to randomly start a web server. My use case was with writing code in a JS framework called Vue.js that's why I needed a server to tender static fine. I intentional didn't use the flag package, I just wanted to use one argument which would be the port number. It also helps me to start the vuejs docs, I have fenerated the html &amp; start a server on 8080 or 9090
I'm now considering skipping the command line argument. The server can choose the port number by itself in case existing port is in use, we can use another one.
In fact, it compiles faster than Go! (on large code bases) http://imgur.com/a/jQUav 
If you are "fairly certain", than the downside is obviously that you might get them and crash your server :) The better possibility is to wrap your reader in your own buffered version, that maintains it's position and a certain amount of context for your error messages. That way you get the best of both worlds. You can probably even get away with just passing in a `*bufio.Reader`, as `bufio.NewReader` will reuse it, if possible, so you get access to the internal buffer after all (I don't know the json implementation enough to judge that, though). [edit] also, you can of course also limit the amount of bytes possibly read by creating a sufficiently large `[]byte`, `io.ReadFull` into that and, if it isn't enough, handle the unusually large response manually. It's at least better than just using `ioutil.ReadAll`.
I asked a few weeks ago about that in golang-nuts https://groups.google.com/forum/#!topic/golang-nuts/EsdxsZFAw00 but didn't have the time to look further, got no answer. Subscribed to the issue, thanks
Cheers, maybe if the theme has a place for feedback you can tell them about it too.
I agree that using the `flag` is a mistake. It severely reduces the use cases for this library. I'll refactor sometime in the next few days to use a config struct.
DSP? Use io.TeeReader. :) https://golang.org/pkg/io/#TeeReader
&gt; but imo using flag is a mistake Why? What is wrong with flags?
So a friend was complaining about how ugly too many type-asserts from plugin lookups can get, so I commented that it should be easy to have a wrapper like... this. Note that this requires Go tip until 1.8 comes out.
I would combine the above with a type switch. That gives better error handling (panic or err on the default case). Situational, of course. 
&gt; If I dont check valid port number, how do I write test case for the same? This case is already handled by the standard library and the system. If you try to bind on a already used port, you will get a very descriptive error that says exactly that. You don't need to write a test or anything really. This program is just one line of code by using Go's powerful standard library. You know what they say. The best code is no code at all.
Of course. I was just giving a minimal example of what it took for me to make adg's assertion work in practice with the type system. I could be missing something, so feel free to check out the example I posted below and let me know if it's wonky.
Yes, as ever :)
Anytime you are mixing typed and untyped code, some form of reflection is occurring, which has a yuge impact on performance, at least during the initial load. What Go is doing is fully typed, static library loading. This syntax is similar to what one has in C/C++ when calling dlopen.
IIUC Windows support for plugins will not be in 1.8 final, either.
An alternate approach I have taken is that plugins should register themselves when they are first initialized. Something like: func init(){ pluginRegistry.Register(myImpl) } Where the host app has a central registry of implementations of a given interface. Doesn't require ant of the type assertions or reflection that using Lookup requires.
The way Lambda works is a host process loading your code as a module, which is why it supports Python and Node nicely. Go support can only be done via invoking an external process inside a Node shim, or [compiling your Go module as a Python shared library extension](https://github.com/eawsy/aws-lambda-go/blob/master/service/lambda/runtime/proxy.c) so it can be loaded by Lambda's Python runtime. Plugins make module loading officially supported, making it easier for the AWS team to rely on for implementation, I suppose.
Seems like there should be a CLI tool to reflect a plugin package and auto generate type safe bindings.
Seems all programming languages work best on Linux unless they're specifically made by Microsoft or Apple for their specific platforms. (In my experience anyway).
You beat me to it. I've been working full time in Linux for the last two years and haven't looked back.
Especially in the "meta-programming", and "code size to do the same thing" arenas, eh ?
&gt; The problem is when the boring is constantly so verbose that it's obnoxious. Which language does it better?
https://www.youtube.com/watch?v=5kj5ApnhPAE
&gt;[**OSCON 2010: Rob Pike, "Public Static Void" [12:31]**](http://youtu.be/5kj5ApnhPAE) &gt; [*^O'Reilly*](https://www.youtube.com/channel/UC3BGlwmI-Vk6PWyMt15dKGw) ^in ^Science ^&amp; ^Technology &gt;*^64,659 ^views ^since ^Jul ^2010* [^bot ^info](http://www.reddit.com/r/youtubefactsbot/wiki/index)
You should be renamed to botfart.
I get what fathers of Go meant, but they IMO went too far, and the overt verbosity hurts both read&amp;write-ability (you'll sooner lose track of the forest because of the trees). I like less verbose languages (more code on screen, less jumping around, less reading, less writing, more thinking). And I feel that a lot of the verbosity was unnecessary choice due to personal tastes (fallacy: verbose code is "simple") EDIT: You have to learn all the necessary concepts anyhow. I opt for a richer vocabulary instead of walls of "dead-simple boilerplate".
Sure, if you think node. js or python dev is going smoothly on windows. Yeah maybe you're right, it's me who doesn't have a clue about the good life of a developer running Windows. But come back after you used Linux for a while, because you're missing some stuff in your superficial judgment. 
The truth is, no language is perfect. And everyone has their own opinion about what makes a language great. 
&gt;Go only really works on Linux it seems - if you want all the features. Are there any other features apart from the new shiny 'plugins' which aren't available on the other platforms ? Also it doesn't sound as if full platform support of plugins is out of the picture, just that platform specific bugs means it won't be fully cross-platform supported in the 1.8 release.
How does it interact when both a plugin and the main program are compiled against the same package?
I also think that CoffeeScript is not the future of programming. But when you come from Ruby then you will be comfortable with the Syntax. I just want to cite: " I've worked with PHP, Ruby and ASP.NET". So in that case CoffeeScript would be good to learn. It compiles to JS and by learning CoffeeScript you get in touch with JS.
couldn't we just create a new subreddit? eg.: /r/go_lang or /r/golanguage or just /r/go 
You should use the Go workspace as described in the docs. The Go tooling like `go get` relies heavily on this structure.
Why not have an interface type, define the name of one global symbol which has to be of that type and then make *one* type-assertion when loading (and from then on only deal with statically typed values)?
I structure my stuff the way it works well. I.e. the "official" layout and I'm old enough to not spend half a second thinking about if I like it or not. It's reasonable, it works, now drawbacks, who cares. 
Thanks, what do you mean by that exactly? I seem to be able to create a .go file anywhere and still use `go run` or `go build` commands without issues.
`go get` is for downloading packages right? Would that prevent me from keeping my project files separate as long as I include the right package directories in my project?
The go tool uses GOPATH to find imports. For example if you had a program: package main import "github.com/DanChm/yourlibrary" func main() { yourlibrary.SomeFunction() } It's going to look for "github.com/DanChm/yourlibrary" in $GOPATH/src/github.com/DanChm/yourlibrary
A lot of the devs I know (not me) use a Mac but their apps are actually running in Linux via the magic of Vagrant.
I see, good info, thanks.
then you lose the runtime loading benefits of the plugin, the idea behind it is the runtime adaptability of your binaries
upvote for mentioning autojump. 
Linus Torvalds (Linux kernel maintainer) used to use Fedora on a macbook, so I imagine it runs pretty smoothly most of the time. He now uses it on a Dell XPS. I've had really good experiences with Fedora on a macbook too. If you think about going back to Linux you should give Fedora a shot. 
I use Go on OS X all the time, and I've also used it without problem on Windows.
I never said anything like this, in fact I like conventions. I just wondered how others organise their projects.
Distros doesn't change the issues I've been having. My prior MacBook pros worked fine on Linux. This current one has lots of weird driver issues
Great link, useful info.
It should "just work". Would be worth testing though. I have had a hard time getting it to work on osx though, likely due to linker bugs. Probably why they are likely going to remove osx support before the 1.8 release: https://github.com/golang/go/issues/18190#issuecomment-265250864
&gt; Suppose I submit yhis code for awesome-go repo, they'll reject it becayse we do not have a test case for it. From what I have learned from Reddit community is that we ought to write test cases for everything, plus, my test case is only for checking that my IsValidPort function is working correctly :-) &gt; I'm not actually doing unit testing on stdlib. The valid aspect is about the port number not being 80 or things like that. So let me get this straight. It is obvious that all the value of this project is *one line of code* that makes use of the standard library. Obviously you should not write tests for the standard library so naturally this one line project cannot have test cases. So are you saying that you are *writing code that you do not have to write* simply because you want to have tests in your project? And the reason you want to have tests is because it is considered good and not because you actually *have something to test*? Are you aware how insane this sounds?
As much as I hate GOPATH, too many tools assume it, so if you try to exist outside of it, you will get all sorts of weird failures.
Thanks! Yeah, I'm writing up an article at the moment on how plugins might be used in practice with an eye towards talking about best practices.
Have you started by reading the document that describes this? https://golang.org/doc/code.html Reading that is probably the fastest way to ingest the most information.
That's exactly the page that sparked the question :-)
The most popular packages for these tasks are currently: * [net/http](https://golang.org/pkg/net/http/) * [encoding/json](https://golang.org/pkg/encoding/json/) * [encoding/xml](https://golang.org/pkg/encoding/xml/) (in case you are returning xml) 
Why so sad?
You could also check go-swagger. I didn't use it yet. I just checked that it worked with a given swagger file.
the benchmark has been updated with tables and charts: https://github.com/json-iterator/go-benchmark
My 100% personal opinion happens to be that I think it looks bad and has inferior readability. I am finding it a bit amusing to see it pop up in random screenshots of Go code in various places now. With syntax highlighting disabled, of course. The cult/worship mentality in the Go community is a bit baffling to me. edit: Even with the most carefully worded post, even the tiniest question of the Go cult and I get downvoted from +3 to -2 in a matter of minutes. So damn classy around here. Just like last time when I was yelled at for implying that the multitude of vendoring tools causes real problems for large projects. I'm so sorry I questioned the cult. The Go font is amazing and is basically the best font ever. I've removed all other fonts from my system except the Go font. And generics suck and are the worst thing ever and anyone who wants them is a big ole dummy. Woo! What's my prize? Oh right, my prize is another reminder of why I try to avoid this subreddit like the scourge it is for a reason.
&gt; I also find it amusing to see it pop up in random screenshots of Go code in various places now. As far as I know, the Go font is only used in the Go blog. I am really curious to see those other places. Any links?
The Go community needs guidance. The excellent articles from the Go team on the official blog are rare. Most of all we need best practices. You've done [your part](https://peter.bourgon.org/go-best-practices-2016/) and thank you for that. We need more like this but we also need them to be easily found.
Sorry, it was a couple random things I saw on Twitter, possibly all from the same person, it would be really hard to find it again.
First I've seen it (been heads down on a massive c++ project). Dear Turing that's awful. Who puts serifs on a programming font? There's enough odd characters without all that flourish garbage.
Are you referring to the monospaced version or the regular one? I'm not really a fan of the regular version of it, and I agree the website is less readable with the new font, but the monospaced version has grown on me for coding and I have been using it for a couple weeks now.
The Windows rendering I saw a screenshot of was inexcusably awful. I don't know if Windows is at fault or the font is somehow missing data, but it looks like pure garbage.
I've been using this since the day I started in Go. I met Onsi about a year later and he's a talented developer that worked on the (Go) internals of Cloud Foundry before he made it up to VP of engineering. Not much later I watched him do the keynote of a Vegas conference. It's not a teeny library kept up by some guy - everyone I know from pivotal that writes go uses it (and maintains it) That being said: if you prefer to stick with `t.*` I'm not against you. But it's not an iris or any of that junk. If you're looking for a BDD/TDD testing library, this will do 99% of what you want it to and will maintain strong XP principles (since the pivotal folks are super XP)
&gt; Holy shit. Yeah, I seriously think there's a cult and a six paragraph rant was totally warranted here. &lt;insert passion profanity here&gt; 1 Minute goes bye. &gt; Holy shit. Yeah, I seriously think there's a cult and a six paragraph rant was totally warranted here. /s since you apparently need it. Take out the profanity, the initial emotional "trigger" of a stranger observing your behavior in their own way has subdued enough to remember you are in a public outlet. *A few moments goes by. Another edit.* &gt; Also, could you put more words in my mouth or lie more, possibly? I'm still upset, I would never say or present myself how he is describing. How could he possibly observe me like that? *Another edit moments later comes from you.* &gt; This subreddit has an obvious pattern of downvoting anything perceived as an attack on the one true way of Go. it was clearly evident in the last time dependency management came up and I was shouted at by people who later admitted they had no idea what they were talking about. Now that I've calmed down a bit I'll justify my behavior by redirecting the focus to an occurrence unrelated to this one. *A few moments pass, he hasn't responded, passion edit time.* &gt; By the way, project much? &gt; I came in to express a personal opinion and observation relevant to the OP. Who the fuck are you to make wild accusations about my intentions. &gt; Way to disprove my point bro. Who is anyone to formulate an opinion about someone based on observation from an experience they had. &gt; This subreddit has an obvious pattern of downvoting anything perceived as an attack on the one true way of Go. it was clearly evident in the last time dependency management came up and I was shouted at by people who later admitted they had no idea what they were talking about. &gt; This subreddit has an obvious pattern of downvoting anything perceived as an attack on the one true way of Go. it was clearly evident in the last time dependency management came up and I was shouted at by people who later admitted they had no idea what they were talking about. *Now Another edit has just came through.* You remove the portion where I am a liar, because it was an emotional response and try to begin a more articulate debate. You go on to ask who I am to diagnose your psychological state. The simple fact is I don't need a PHD in order to formulate an opinion based on your actions. Here you have edited your post around 6-8 times in a period of 20 minutes, each one cycling through a completely different writing style as your emotional state changes. You are a smart and articulate man, every other edit said otherwise. *The last edit you made* &gt; "my reply" &gt; What does any of that serve except you being able to demean me as a person through sweeping assumptions and generalizations? And then you take it one step further by acting like my opinion about a font has any merit on my ability to participate in a technical discussion? &gt; sweeping assumptions and generalizations "The cult/worship mentality in the Go community is a bit baffling to me." &gt; And then you take it one step further by acting like my opinion about a font has any merit on my ability to participate in a technical discussion? "even the tiniest question of the Go cult and I get downvoted from +3 to -2 in a matter of minutes. So damn classy around here" ^ That is why I said you are unable to participate in technical discussion. You simply reinforced it with your flood of edits and reply. I would take a step back and really think about the series of events here, as an engineer it's rather easy to compose and I'm sure you are a good one. Have a good evening.
To each their own of course, but I find that horrifying.
BDD adds a bunch of strange abstractions with unclear benefit. How is this... Context("initially", func() { cart := Cart{} It("has 0 items", func() { Expect(cart.TotalUniqueItems()).Should(BeZero()) }) } ...better than this? cart := Cart{} if got := cart.TotalUniqueItems(); got != 0 { t.Fatalf("\ngot: %d\nwant: %d", got, 0) } The BDD test is a chain of 8 function calls doing godknowswhat (constructing an English sentence?). The stdlib test is 2 function calls and no magic.
Damn you OP. I didn't notice it until I read your post. Now I can't ignore it. This font needs to go, from the blog at least Edit: It appears that this font was used only for this one post. I hope it stays that way. Phew!
Right there with ya. Can't wait until these "BDD experts" vanish. ;D
Routes and middlewares for all your http.Handler : https://github.com/pressly/chi
Well, other fonts render fine, so I'd say it's probably the font.
Well I am using those + gorilla/mux. And all that works fine, don't feel the need for more sophisticated routing library. However, what I am looking is not related to routing or anything like that. I am just looking for small utility library which would do following tasks: * Help generate hyperlinks. * Embed json objects into response. * Pagination parameter parsing and structs for that. All of this is quite easy to implement yourself, but just thinking, that instead of writing it myself or creating new library I should check if one already exists.
Well, I find it more readable ;)
Does everything have to be decided by the community ? I don't think it's unreasonable for them to decide what font to use on their blog (or website).
Then you should check out [unrolled/render](https://github.com/unrolled/render) which is a utility to return all kinds of responses, including json
SpiderMonkey it back to "normal"
I have no problem with them whatsoever. I've adopted the Go Mono font everywhere because I find it very easy to read. I don't like the regular version as much however. I think the point some seem to miss is that the biggest design decision for having these fonts in the first place is the license that they ship with.
made it for my need as small and useful thing. ready for PR and issues. thanks.
Upvoting you just because it seems that you got downvoted for hating the cult mentality.
No, I can't stand it either. At least the monospace one. I use Hack myself.
It looks crappy in safari too.
So, has anyone gone through the book already? I'm considering buying it, but I'd like to read some thoughts on it first. From the sample, it looks pretty good.
I really liked Go font and think that Go blog has a great readability. It works pretty well on my laptop and mobile browsers. I'm running acme with Go font and it's great, I've tested on Atom and don't liked so much. I think Go font works well on light background and syntax highlighting disabled. On dark and colorful editors it's a nuisance.
If they'd silently switched to the new font I wonder how many people would have noticed? And how long would it have taken the average reader to notice? My guess is that most people don't give a shit, some small proportion of people would notice and think "cool, nice font!", some other small proportion of people would think "not my bag, but always handy to have a relatively well licensed font in the bag of tricks" and the remaining small proportion of people would vomit all over their keyboard before forsaking golang and it's serif-ed font devilry forever more.
I love go font, it reminds me of plan9. Switched my system and editor's fonts to gofont. By the way, in emacs and urxvr these fonts look great, but in goblog they look ugly.
What is so problematic about setting GOPATH? It's easy and works fine.
I downvoted you (and the parent), because you're singling out specific communities like this is a problem with them and not programming communities in general. The cult mentality behind languages like C++ and Java are much worse than anything I've seen from the go community. Every tech community I've been a part of consisted of arrogant elitists too. It's disingenuous to claim that Go's community or the Linux community is worse than other communities when it comes to these things. Windows fanboys and MacOS fanboys can often be worse than Linux fanboys. Half the time you even bring up an alternative to Windows in a popular sub-reddit, suddenly theirs ten windows evangelists ready to go on and on about how flawless windows is, while completely ignoring the whole windows 10 fiasco we saw a few months ago. There seems to be a lot of cognitive dissonance in almost every tech/programming community, and you have to ask why? Is it really because people are insecure? OR are there other factors at play? I think the programming/tech community consists of a lot of "trolls" and paid shills whose specific purpose/intention is to shift community dynamics. Clearly, there are multiple entities who have multiple end games, private organizations, state actors, rogue mercenaries, etc. I think in the age we live in it's kind of naive to believe the opposite. Look at how opinionated people are about something as simple as a font. Seems to get everyone to come out of the woodwork doesn't it? We're all programmers, we can change the font on the page if we want, but instead lots of people are using something a silly as a font to create a political war, almost between the reddit community and the rest of the community. It's the old "divide and conquer" strategy. We're not arguing over plugins, or any new features in go 1.8. So instead of having the community argue over something that matters and that we could use our collective "intelligence" to improve upon, we're now arguing over something as stupid as a font. If we change the font, then it's still just wasted time and non-productive. Of course if the detractors had us arguing about something that matters, we could change things for the better. Threads like these are unproductive and can never actually help go as a language, but they can help to fracture the community, which is their only purpose. 
Hey dude, don't worry about the downvotes. Many /r/golang subscribers do seem to exhibit unthinking partisanship. The average person golang user probably believes that generics are a hoax invented by the Chinese (or by Bjarne Stroustrup).
&gt; With syntax highlighting disabled, of course. The cult/worship mentality in the Go community is a bit baffling to me. Oh, so i'm stupid cultist if i don't like syntax highlighting, right?
I'm with you. This brings back bad memories from my "Enterprise" days of C# and Java. With a sprinkle of "hey I just learned this new cool language called Ruby and here's my new testing framework!!!" It's like some people have an aversion to clarity and simplicity. 
You could just change the font you see in the CSS file, in the chrome inspector.
It looks just fine.
&gt; the *topographer* responsible for the fonts https://en.wikipedia.org/wiki/Topography https://en.wikipedia.org/wiki/Typography
Correct, there is no need to write test cases for those functions written by the core team since they are already battle tested. In hindsight, I can now say that there was no need to write the `IsValidPort` function at all, because I can just handle the err object by our `ListenAndServe` method. Also, I do understand that this project has no real project at all + it doesn't really belong in a project like awesome-go. The moral of the story is that I've understood the purpose and use of unit tests, this experience is way better than reading "how to write test cases". Thank you for your guidance!
No. A lot of people do. I think it's the serifs and that it's pretty dense. Go Mono that is. The normal, proportional, less talked about Go font seems more okay. :p
Can someone explain why they made it? It seems Go is the only language that comes with a font family. Why?
Double this. And it is very uncomfortable when you have a long-standing practice of using dir-tree style of your codebase. Only Go demands special rules and privileges in a absolute code arrangement. ps: example of hierarchy of my directories: `/home/user/Dev/{home,work,petprjct,tmp}/{$langname/$projectname,$projectname}` pps: tried to solve this problem with symlinks, but many go-tools and libs aren't able to work with them 
Is this what y'all talk about nowadays on the go sub? A font? No wonder there was talk of dropping the subreddit: it's full of children.
Why not symlink to the gopath? If you have a codebase with many different languages, just symlink the go one to the GOPATH and be done with it.
You'll still need to handle the case in which the data is not of the expected type.
Surely. But the question is what were they trying to test for? Were they trying to create a cult?
Oof. Thanks for the link. I kept going to golang.org and thinking "man these fonts don't look bad at all, what's the big deal?" I should have read the OP more carefully. Now I see and I wish I could unsee. ;)
Just wish the monospace was sans-serif
Did you join the cult yet?
I like the community. That being said, I have my issues with it as well.
You have been banished from the cult. 
I installed the font on my system to check it out and I really like it so far. It's unique but not over-done.
Did you consider implementing equals with a hash [like this](https://play.golang.org/p/8FJ_9iQ4RU)?
What I think would be nice is if the go tool could use the package import declaration comments as hints about workspaces. What I mean is, if you write your package statement like so ``` package foobar // import "github.com/skelterjohn/foobar" ``` then the go tool won't let it build unless that's the package it's trying to build. I say go one step further, and decide that's the package it's building. So if you have a directory, not in `$GOPATH`, with a single source file that has an import declaration comment like the above, it assumes it's in a GOPATH subdirectory that works. You'd still need `$GOPATH` set, so it knows where to put the binaries, but that could be a single universal spot.
I fully support this proposal and want to publicly thank /u/dgryski for all he does here and for the Go community. 
Thumbs up on all fronts.
👍
I also fully support this proposal.
Any alternative to this subreddit that is official?
He's definitely the best source for Go content on Twitter, too!
I fully support this and I think there couldn't be a better person to be mod here.
fyi you can just link folders i keep my code in `~/programming/$topic/$project_name`but my actual go stuff is in `~/.go/` -- so I link it up such that `~/.go/src/github.com/myname/myproject` is a link to/from `~/programming/$topic/myproject` it means i can keep all of *my* code together and don't need to mess around with someone else's shitty assumptions on how i work.
I'd also vote to keep skelterjohn around
And his collection of Go conference talks is both amazing and a lot of work http://gophervids.appspot.com/
I'm happy to remain modlike. If the only way to let /u/dgryski be top mod is to un-mod and let him re-add me, that's fine. I don't think it really matters who is on top, though.
&gt; that at least some of the pushback comes from the feeling that it was imposed by people who do not participate in this community (and in fact express open contempt towards it elsewhere) To be frank, I think this is what caused the majority of the pushback. I've not seen anyone who has issues with the current content of the values and behaviour sections of the CoC, whereas I've seen nothing but complaints about the way it's enforced. There are still people who claim it shouldn't exist, but I think most understand having a set of written rules and values is important for moderation purposes.
A faster implementation found here: https://github.com/AlasdairF/Random/
Sounds good.
He's on twitter too? With all his activity 24 hours a day on anything Go related on Reddit, GitHub, Slack, and apparently twitter, are we sure he's not an AI?
&gt;With syntax highlighting disabled Pyke. 
I know it would be hard to estimate exactly, but what kind of time investment are we talking about? A project that would take a week in Python takes a month in Go, or less dramatic than that? Given a project like say, a forum with login, registration and simple posts.
I could not agree more, glad to see this happening.
Wordpress and Golang are completely two different things. Wordpress comes with a bunch of pre installed PHP code, and then there is a separate web server. With Golang the web server is built into the programming language. Also Golang has great tooling built into the language. I can "go get" any github remote repository and within seconds I'll have all the library files I need. The go get is almost like NPM but better because all the third party libraries actually work out of the box and are stable. No offense to the JS community though, its just I had a bad experience when every week a new JS framework update comes out and things break because its not backwards compatible with a certain version. 
+1
What do you mean by overkill? I don't see what the cost is for using Go. Go is a simple language to learn compared to any other object oriented language. You don't have to specialize. Most of the ideas cross language and tools, especially for web and databases.
If you already know Python but not Go, then two weeks. One week to learn Go, one week to write the code. Unless there is a particular frame work you want to use. Although personally, if I want a forum, I would choose a forum software or hosted service, and not a programing language. 
That seems a little severe, but I'll leave that to /u/dgryski. It's true I reacted too quickly without considering how the existing Reddit users would feel. (I naively assumed everybody would be equally offended. Obviously that wasn't true.) 
[removed]
I'm just gonna leave this here. https://groups.google.com/d/msg/golang-nuts/XoOhzUClDPs/bYS9SKY7CAAJ
&gt; Wordpress comes with a bunch of pre installed PHP code, and then there is a separate web server. And don't forget that WordPress comes with a huge library of pre-made security vulnerabilities you can install with a few clicks. With Go you'd have to write all of those yourself.
&gt; I've not seen anyone who has issues with the current content of the values and behaviour sections of the CoC I had a very different impression from the discussions around it's introduction, especially here on reddit. I took away from it that people had very broad objections to exactly those sections and that the enforcement was barely mentioned (except the part about also taking into account behavior outside the official go spaces). [There](https://www.reddit.com/r/golang/comments/3t82mt/code_of_conduct_proposal_2/) [are](https://www.reddit.com/r/golang/comments/3abyva/a_code_of_conduct_for_the_go_community/) [several](https://www.reddit.com/r/golang/comments/3afdgj/no_code_of_conduct/) [threads](https://www.reddit.com/r/golang/comments/3r2t63/proposed_code_of_conduct_for_the_go_project/) on /r/golang that I read through at the time and I encourage you to read them. If you then still believe that the criticism of it had mostly to do with who the moderators of /r/golang are, we can talk again. Honestly, I can only think of one occasion, where the enforcement of the CoC was criticized; the most recent thread about it. Which makes me suspect that this is an instance of recency bias.
Oh look, someone else [disproved your point for me](https://www.reddit.com/r/golang/comments/5h87u6/proposal_dgryski_for_top_mod/dayhjr6/) (if we don't want to count the vote count on my original comment as conclusive evidence anyway).
Not sure you can get much "worse off" than being loathed by your moderators, but who knows. That said, I suspect it will be a less dramatic shift than people expect. 
I don't think Brian is, or was at any point in time, a moderator of this subreddit.
I am totally onboard with this. In general, I'm against the trend that I've seen frequently, that views being a moderator as a perk or other high-status thing. No, it is not. If you are a moderator of a sub, you're there to do work. Checking for spam, checking for things wrongly marked as spam, looking at the new queue, monitoring discussions to ensure they adhere to the sub's rules. Being a moderator is work, it is a responsibility. If you aren't active in the sub, then you shouldn't be a moderator in general. 
&gt; I think it's worth pointing out that your posts are probably getting downvoted by two separate groups of people. I think you are overreading the limited data available. In particular: &gt; All of my posts which have suggested keeping the core of the code, and the enforcement being done by /r/golang moderators have had plenty of upvotes, where as people who simply disagree with the CoC would have downvoted them. In my experience, once a comment has reached significant negative view count, the voting behavior of the children deviates significantly from the norm, as the children are hidden by default, so people would need to explicitly search them out. I wouldn't infer anything from this. &gt; /r/golang will not be moderated by the CoC Working Group as it will no longer be an official space, so the argument is rather moot. Well, as my argument is about whether that should be the case, I don't see how. Note, that this, so far, is a proposal, not a decision (even though it will very likely be implemented). Anyway. I am going to stay pessimistic, from everything that I've seen on reddit so far and the go community in regards to the CoC specifically, that losing the enforcement will likely mean I will contribute much less (if at all) here in the future. It's bad enough as it is. And I don't trust redditors, out of experience, to moderate effectively.
+1 wise moderator is more important than wise rules.
&gt; I think you are overreading the limited data available. In this thread perhaps, but there's plenty of discussion in the Future of Golang thread that I started two weeks ago: https://www.reddit.com/r/golang/comments/5eubdp/the_future_of_rgolang/ I'll point you to this comment thread in particular which discuss the CoC and enforcement: https://www.reddit.com/r/golang/comments/5eubdp/the_future_of_rgolang/dafpvxy/ 
If anybody nominates me, I am going to accept any nomination. I am currently moderating /r/C_Programming (a subreddit with 24.090 readers, so about as large as /r/golang) with good results and very little complaints so far. If given the chance, I would moderate /r/golang with the same standards I use to moderate /r/C_Programming.
And what rule of the sub did he violate recently? Nothing? I thought so. You don't just ban people because you disagree with them.
The CEO's behavior was deplorable and juvenile. I don't think there's much disagreement there. Am I ready to completely abandon Reddit because of that? Not quite yet. If people are building a modern, decentralized discussion forum with some of the features current forums like Reddit have (upvoting, moderation, etc., but with the good stuff from NetNews) then I'll certainly give it a try.
Brian was made a moderator 9 days before he made those comments. He also posted Tweets encouraging the deletion of /r/golang. After making them, some of the community asked him to step down as a moderator and he did: https://twitter.com/bketelsen/status/802319989294399488
Admittedly I don't know as many tricks and methods to Go as others, but I think Go wouldn't be a good fit for a CMS/eCommerce package that isn't maintained by a developer in the language. To my knowledge there is no way to include other files as modules/plugins except in 1.8 . The code is also compiled so there's more issues IMO than there would be with an interpreted language like PHP or JS. The modules that could be supplied would either be precompiled and have unknown code in it, or it could come uncompiled but then the user needs to do it themselves. Making it as easy and open as possible would IMO be the best choice for either but right now it's not easy unless you're the developer.
How can a code of conduct be enforced for a community that mostly use pseudonymous identities? It is fundamentally flawed - rules and moderation is probably the most reasonable approach given the nature of the service.
AYE!
Since you asked. User authentication (including salted PW hashes), with user sessions/cookies/context without a framework or 3rd party libraries. Basically, a super slimmed down (but secure &amp; complete) example of user login that demonstrates accepting a user/pass combo, hashing the PW, *&lt;comparing username/pwhash to persisted data can be left out and up to the reader&gt;* and opening a session, setting cookies, or anything else related to tracking that someone is logged in as they navigate the site. And of course, tearing down the session at logout. It's been hard to find examples, and I know I can probably make it work on my own but I don't know all the best practices and I have a feeling it would get really messy in my HTTP handler functions very quickly. I am sure there is an elegant way.
Stage 6: when writing performance critical code, goto Bargaining 
Does /u/dgryski want the responsibility? Will any core developers want to continue to be moderators? Will any core developers continue to add to this community? 
They both have their uses. Mutex is like a 4 way stop, use it when you don't want two routines to crash into each other. Channels is like a bus stop, use it when you want to have one routine wait for another. 
O(1) vs O(N) where n ~ 1
Use io.Copy + io.LimitReader if you need to slurp with bounded memory.
Guess you don't do multivariate testing or integrate with ERP systems, among other things. You can run ~$50M/year ecommerce businesses like you describe but you're gonna have a bad time if you have any special use cases like private sales or internationalization.
ROTFL
You're still in the bargaining stage :)
I'd be really interested in seeing your approach to pulling the querystring apart, especially in situations where some querystring arguments might be applicable to a large numbers of endpoints.
I've done some experiments with raw sockets in Go as well! https://github.com/mdlayher/raw I also have a couple of packages to layer on top of it, like Ethernet frames and ARP. Hope they're useful for someone.
I liked this write up, thanks for taking the time to do it. Only thing I'm curious about is if there was any technical reason you couldn't pack the payload into a byte slice (aside from convenience)? 
If you want to get a better understanding of the TCP/IP/UDP I highly recommend to read the first 2 chapters of the book [TCP/IP Network Administration](http://shop.oreilly.com/product/9780596002978.do). This book was part of the [Humble Unix Book Bundle](https://www.humblebundle.com/books/unix-book-bundle) recently. Despite being old, it's from 2002, the concepts of TCP/IPv4/UDP doesn't have changed. I learned a lot from it.
Oh thanks, i'll check that out. It might ease the pain in future projects.
&gt;You can run a static hello world web server in like 10 lines of Go code. Three lines in Python. &gt;Golang is faster then Python and has better support for concurrency. Neither speed or concurrency matters for small applications or forums. &gt;There is no reason to choose Python over Go for web development. Cooooome on, mate. I know we're in /r/golang, but coooooome on. It's just not true. Python is an incredible, powerful and expressive dynamic language. It most certainly will be better than Go in short-term. Moreover, I'm afraid most small applications won't reach the scale at which they could benefit from Go whatsoever.
Shameless plug time! https://github.com/quii/mockingjay-server It's pretty well battle-tested, used a lot in my current job and a little in my previous one too. Well over a year of incremental improvements but always happy for more feedback to take on.
The language **is** stupid. The language **is** disservice to intelligent programmers. The language **does** ignore all of the PL design research. It's the main reason why I find it kind of fascinating. Finally, a triumph of practice and pragmatism over theory and academism! Interesting how it'll play in the long run though.
Just convenience :) I did originally think about trying to use just a byte slice, but this way was much simpler (and didn't require remembering the byte offsets)
Thank you for this! (it isn't a shameless plug if it related to the topic) Is this a part of awesome-go? It'd be great if it was (in case it is a part and I wasn't able to find it) edit: go get throws this error ../../quii/mockingjay-server/main.go:45: undefined: assetFS
Of course there are shops which sell 50 basically fixed items (unconfigurable) in one country doing 200 transactions a day. You do this by a ecommerce SaaS or some tiny PHP. I clearly asked about "modern eCommerce solution", not your aunt's tiny homemade socks shop. And there are large retail stores doing &gt;200 orders per second, selling in 5 languages into 10 countries with 20 different VATs, large personalisation, couponing, customized products, ship, drop shipping, click&amp;collect, click and reserve, credit screening, fraud detection and lot's of stuff you haven't heard of. But of course: Most ecommerce sites are tiny.
Yes, I raised it :-) By the way, I am getting "unexpected EOF" while reading a html file, any ideas/suggestions?
By overkill I meant that I don't have all the frameworks and tools that older languages have. (e.g. no CMS like Wordpress, and no frameworks like Django). And also if I can't take advantage of Go's concurrency then it might seem like trying to hammer in a nail with a sniper rifle. Also, I don't see how you'd get anything done without picking a language and sticking with it. I can't learn everything at the same time.
Yep, I understand. I've done projects in PHP and Python on the server-side so I can use more than one language. But I can't just hand in my CV that says I'm a PHP, Python, Go, Java, Ruby back-end developer. No one is going to take me seriously.
The cost ? Lack of libraries ? Lack of expressiveness ? I mean, Go is cool for building large-scale apps with a lot of users (that's even its *raison d'être*), but OP seems to be targetting small apps for small companies and small groups of developpers. I really love go, but I don't see it as a clear winner in OP's situation.
I usually start with nginx (but any web server will do). The most "stupid" example of a mocked back-end api is just an API folder with several json files stored within it, which then the front-end is requesting. I wrote a [gallery-angular](https://github.com/titpetric/gallery-angular) project a while back, so I could see what the fuss with Angular was about, and I created a generator that would create these json files from whatever folder structures/images (script run in the same repo). Think of it like a 'hugo' for API endpoints. The principle is quite useful.
Meh... I think OCaml/C++ went too far in one direction, Python/Go went too far in the other. Some stuff (error propagation in manipulating deep hierarchical structures) is just stupidly verbose. It happens to have better C integration than Java while not being C++ which is what sold it to our team. Swift looks like the sweetspot, Rust might be a little too wonky for the majority of people although it's still a decent compromise I guess. Go's authors' primary insight was beating everyone else to the punch on realizing that C++ probably isn't ever going to really get better, and there's a whole lot of C code out there being worked on by people who are tired of dealing with C where it isn't necessary to do so. Betting on JSON serialization wasn't a bad idea either. (And then there's D, which decided that C++ wasn't complicated enough, so here's a few more constructs and an optional garbage collector...)
I also found out that it makes testings easier. By defining an interface as argument type, I can pass a dummy implementation of the service. I.e a database to add user. Instead of needing a real database for which it is difficult to force the return of an error, it becomes trivial with my own implementation of the database interface. This is a good design pattern for Go programmer. 
Found the issue, &lt;!-- {{if .Search}} &lt;a class="navbar-brand"&gt; Results for: {{.Search}}&lt;/a&gt; {{else}} {{ if eq .Navigation "pending"}} {{ $url:="" }} {{else if eq .Navigation "completed"}} {{ $url := "" }} {{else if eq .Navigation "deleted"}} {{$url := ""}} {{else if eq .Navigation "edit"}} {{$url := ""}} {{else}} {{$url := "/category"}}{{end}} --&gt; This block was causing the issue, it was commented, but do not understand why the Go templating engine did not neglect it.
True! Channels are good, but sometimes they could be very slow.
I am working on something quite similar. We started to use gomobile to extend existing mobile applications (with native ui). Due some limitations in gomobile (when it comes to data exchange) we switched to use https://www.grpc.io as a "data exchange layer" some time ago. So now the gomobile part provides a tcp/http2 endpoint and communicates with the native UI via grpc. Although our setup is a bit different (using grpc), I can tell you that the basic architecture should work as you expect: Gomobile as embedded server with some native frontend (the webview in your case) is working fine. Sadly I can not provide any sample code, but if you need any help feel free to ask. 
No. It doesn't care about html comments. It only cares about the contents of {{ }} blocks.
I understand this, how shall I then comment out blocks consisting of {{ }} which I don't want now but might need later? store them separately somewhere?
I don't understand why one has to use CGo for syscalls. I've done some syscalling/ioctl myself and everything could be done with normal go structs using `uintptr(unsafe.Pointer(&amp;mystruct))`.
Do you have some time to talk about our Lord and Savior Robert Pike?
You don't speak for everyone.
Good point. I used os.Exit(0) in order to make it explicit zero was the intended exit status. OTOH, doc on os.Exit() indicates os.Exit(0) isn't as clean as a plain return from main() (since "deferred functions are not run"). https://golang.org/pkg/os/#Exit Exit causes the current program to exit with the given status code. Conventionally, code zero indicates success, non-zero an error. The program terminates immediately; deferred functions are not run. 
Not sure, could you try explaining the steps? I think i have made it go-get-able again now, sorry about that
Here you go. Thanks for the help! http://pastebin.com/143AJJW1
Go is successful for the same reason C is successful: It satisfies the needs of the programmer instead of the fantasies of CS professors.
Honestly, I like it better the other way because it's clearer (at least to me), that and you don't need to keep re declaring err over and over again. 
I'd argue that this is a job for version control rather than comments. Moving the "maybe later" code to a branch or stashing it would accomplish the same thing without cluttering the code. As it suits you though -- personal or team preferences may vary.
It seems like everyone is in favor of this idea. Assuming the consensus is still there after the weekend, I'll do this on Monday. Updated the original post.
Thank you! And by the way, thanks for your contributions to the Go community. I've used your packages in many projects.
Cute, but... Why?
One experiment I've tried is to write a gomobile sever and a react native client that both run on the phone (Android). The server was just a proxy to the backend and the client talked directly to the server running on the phone.
I wouldn't call it stupid, it tries not to be too clever. In practical (team) programming, being clever is source of all sorts of problems for minimal or no gain. If I could chose, I would always chose more to be productive than intelligent programmer. It gives better results and pays the bills which is more satisfying (and leaves me with more spare time) than stroking ones intelligence ego. You have plenty of new languages exploring all sorts of new things and catering to cleverness and academia (D, Rust, pretty much every functional language etc.). Why there wouldn't be one exploring different direction? 
I think you need to reconsider whether you should be specializing in the first place. PHP is a horrid language IMO, but I still use it for very quick projects, sometimes with no framework of any kind and even inline HTML. It makes me cry a little, but it's the right choice for a one-day project that's easily deployed to the vast majority of *nix servers. Drupal is overkill for 90% of the things it's used for, but it's a great choice if you need to give somebody who isn't a programmer a LOT of power, and it has a lot of problems already solved, such as user login and granular permissions. Go is absolutely wonderful for code you have to maintain, thanks to its very simple syntax and very fast compiler. You can quickly jump back into your own projects pretty fast even months later, which is sometimes a major pain point with other technologies. The fast compiler and static typing means refactoring is almost a joy compared to trying to refactor PHP or even Python. Or Ruby on Rails, oh dear lord, so painful.... I've used Go for medium-sized projects and been pretty happy with it. I've used it for command-line "scripts" and I usually prefer it over Python (though Python still has some major benefits in certain situations, such as walking directories with symlink-following, deleting entire directory trees in a single command, etc.). I've even used Go for very tiny web pages, but only in situations where it was truly the best fit - running a Go service at all times is not nearly as easy as just dropping a PHP file onto a server that's already got Apache set up for PHP. For a website, Python can be very painful, because you still have all the same issues getting a server running and staying on, but you also don't have a single binary to just copy up to production. You end up needing something like virtualenv to really deal with dependency management, and setup is often a bit of a pain. Go's static compilation is a huge benefit for deployment. That said, there will be times when a framework like Django, heavy though it is, just makes way more sense for a particular project. My philosophy has been to know a good amount about about many technologies. Start with whatever you find most exciting, because you'll learn more if you like it. But don't hope to have a career by specializing in one technology. I think only people working in very nice fields doing very low-level work (such as for AAA game engines) can choose one tech and live there forever - and that tech will probably never be Python, PHP, or Go.
ARGH - that last sentence should have the phrase "people working in very *niche* fields". Not "nice" fields.
For me it went like this: Annoyance: Why does Go not have ...? Why can't I just ... like in ...? Subversion: How do (sockets in C|unicode|multithreading) work again? Ah, fuck it, just write it in Go. Arrogance: I have found that I rarely ever need ...
yes, +1 /u/dgryski
Enlighten me, please.
Took me a while to realize why the other languages were not visible in the chart
I remember when i began with Python, I used only stdlib to make a web server, and deploy it with one exe with py2exe... I worked like that some years without any problem... For me Go is what should have been Python 2+
&gt; Who cares if that map might be access concurrently, it never crashed in production There is [no such thing as a benign data race](https://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong). I'd educate or fire anyone working for me that said the above.
Good point, I think instead of abandoning my PHP skills and focusing on Go, I'd be better off using both. Learn Go when I have the opportunity to work with Go, and if needed I can still use PHP for simple sites. Although I do worry that I'll just end up being bad at both, for now I'm having a blast reading the "Go programming language" book.
Why not edit it :-) ?
Have a handful of nice helper functions (asString, toFloat...) and use those.
Yeah, it's hard to be good at multiple languages. It definitely helps to start with one and then slowly work your way into others. It can be handy to choose one to just play with in your free time while using the crappy ones at your job. I find every language has tons of annoyances, but Go annoys me the least.... However, my Go work is far more often done on my own since it's "too much" to expect new devs here to learn it. (Which I find odd given how simple it is)
&gt; PHP is a horrid language IMO Oh boy, another one that hasn't used PHP in a decade... 
I dunno, I feel like that's cheating :) I don't like "edit" functionality that can cause the original context to get lost. Chalk it up to my work in a library for the past ~5 years. Makes me appreciate holding onto all the history of all the things :)
Edit: I see what you are looking to do, set the keep alive on the underlying tcp connection for the TLS conn. I.e. Create a tcp connection configured as you would like then create your TLS connection using https://golang.org/pkg/crypto/tls/#Client 
Another shameless plug: https://github.com/sethgrid/fakettp Fakettp is a light http reverse debugging proxy. What that means for you: you can let requests go through to downstream dependencies or highjack them and force a delay or to change the response. I've not used it as a complete stand in for a remote service, though it will work for that. My typical use case is that I have a complex app where I don't want to mock out all the interactions, and I just want to mock one particular endpoint to validate my error handling. 
I like to play with other languages that help me bend my brains and think harder about what code can do to computers. I love Rust, for instance, purely because I love to learn. But after a couple of leisure hours playing with it, and specially after a work day of coding in Java, I always end my day in awe thinking about Go's simplicity and how for every clever solution another language provides, Go's is always down-to-earth _super_ easy to implement and understand. No convoluted cleverness. No crazy amounts of syntactic sugar. No crazy amounts of typing to make the compiler happy. And most importantly: I can get stuff done, and I can come back to it months later and still now what the code is doing.
&gt; ... rarely ever need ... 1. It's easy! 2. It's *easy*! 3. It's *impossible*!
GitHub is almost entirely remote
Glad to hear. Here're some other tools that you might find useful: https://stedolan.github.io/jq https://github.com/simeji/jid https://github.com/tidwall/jsoned 
then why bashing? I get php was horrid a while back, but nowadays it isn't the case anymore.
Even more: in absolute scale go is invisible https://www.indeed.com/jobtrends/q-java-q-C++-q-C%23-q-objective-c-q-golang.html (Disclaimer: I love Go)
The hashes in question are stream hashes, they don't load the whole file into memory so I'm not sure where that concern comes from. That being said, I'd like to see some benchmarks to see how much slower reading into a hash (maybe try a few different hash functions) is than your method (bytes.Equal is good, just curious). I wouldn't be surprised if the IO cost makes the difference negligible. (but only good benchmarks could say for sure). Also, you might consider using [io.LimitReader](https://golang.org/pkg/io/#LimitReader) to limit the size instead of passing a maxSize param, it's more composable.
Yes this is expected because you can run TLS on more protocols than just TCP.
Sidenote: Lots of jobs being posted in the gophers slack in #golang-jobs as well.
https://github.com/jessicard/remote-jobs Lots of companies on that list do Go.
This is interesting. My big pain point with Go is looking at a type I can't immediately tell which interface(s) a particular type implements. Of course, well-documented code helps, but documentation can lag... lol
&gt; Bargaining: ...put together some junk that that feels a little bit like exception handling...
Lol I've been angry^1 about having to use Go for at least two years and I don't think it's gonna change anytime soon, sorry. But yes, defer-panic-recover is fully equivalent to exception handling, as shown by the simple transformations in the LtU thread . ^(1 - why you ask? because `if err != nil {return nil, err}`, that's why.)
&gt; transformations Bargaining. There's no need to re-interpret what Go does in the context of what you're used to doing.
I support and appreciate this proposal. I'd also like to note I and hopefully other /r/golang participants appreciate the positive contributions all Google employees and Go authors have made to this sub. In particular, the AMA was excellent. It seems if this plan is executed it appears the language of the Go Community Code of Conduct should be reworded reflecting it's the sub's code of conduct and the reference to conduct@ should be elided.
Of course they won't. You'll need to add JavaScript as well. :-) I have never once had anyone complain about my knowing "too many" languages, and when I do hiring interviews, it has never been discussed as a concern with a candidate. 
Hopefully we can see deprecation warnings merged into go vet soon 👌
It was standardized in https://github.com/golang/go/issues/10909 The discussion in that issue goes on for a while, and it's hard to tell what the outcome was just by skimming. The summary in the article is excellent.
&gt; But adding a UI still means going native (Java / ObjC). That is not true. On the title you mention building a *web-based* App. Unless you mean something different, why do you need native UI for that? Yeah sure the native UI will be faster but the advantages of building a (non native) web-based app are very big. You essentially trade off the native feeling and speed for the cross-platform / write-once benefit which depending on your budget can be extremely beneficial. For me the best way to do this right now is to have a solid and robust API on the back-end (written in Go) and use one of the available solutions for building a modern, mobile-first, progressive web app on the front-end that will consume the API. Personally I use [polymer](https://www.youtube.com/watch?v=VBbejeKHrjg) for that but any of the other solutions will work. Moreover, this gives you the benefit that if later you want to expand into a native app, you just create another front-end, this time on android / iOS that consumes the same Go API.
I'd be curious to get some feedback on this. I have absolutely no knowledge of or experience with literate programming, it just always seemed like a neat idea and a blog post I read recently about "writing a shell in C" made me decide it might be a good excuse to try it (in Go, obviously.)
I didn't even think of that! I just name everything dX after myself, because I'm too lazy to think of creative names.
[io.LimitedReader](https://golang.org/pkg/io/#LimitedReader) has a field "N" which contains the max # of bytes remaining (until the limit has been reached). You could always use that hitting 0 as an indicator.
Which framework/folder structure did you use to rewrite your Rails app ?
This is a great idea,that way they are actually commented:-)
&gt; You may be tempted to check if a user has access to some data at the web layer, but this type of access control should always be done at the app layer When `user.Profile()` is called in `web` layer and returns an error, should the handler return 500 or 403? I find keeping authorization rules in a single place less error prune, errors that can lead to security disasters (your private photos are now leaked). I cannot have a clear mental map of auth rule when they are spread across methods.
Correct, we can use {{/**/}}
&gt; What do you suggest for a server that handles multiple clients that read and write to a map for some shared state? Channels! &gt; ...you need to send channels inside channels for the multi user getters. Yes. This is exactly how I do it. It's really not that hard. Definitely not "much harder". I guess, yes, it is harder than slapping lock/unlock around atomic operations, but that is a really lazy way to avoid thinking about the complex problem that is concurrency. I've been working with some code recently, and there were unnecessary locks all over the place because the guy that wrote it apparently didn't want to bother thinking if the locks were actually needed or not. Switching to channels also changes the way you structure your code, and while channels may be slower, you need to use them much less if you're doing it right.
Interesting book. I expected more of the state machine inside. Why you decided that !!0 == true instead of false in Monkey?
In practice, if you lay out a struct right, it's perfectly safe to use with syscalls. Go itself does that.
I know Rails omniauth stores some state in the session. Have a look at that library for a good reference implementation.
Could you be more specific? Which parts of the Code that I've listed below actually prioritizes one political agenda or ideology? **Gopher values** These are the values to which people in the Go community (“Gophers”) should aspire. * Be friendly and welcoming * Be patient - Remember that people have varying communication styles and that not everyone is using their native language. (Meaning and tone can be lost in translation.) * Be thoughtful - Productive communication requires effort. Think about how your words will be interpreted. - Remember that sometimes it is best to refrain entirely from commenting. * Be respectful - In particular, respect differences of opinion. * Be charitable - Interpret the arguments of others in good faith, do not seek to disagree. - When we do disagree, try to understand why. * Avoid destructive behavior: - Derailing: stay on topic; if you want to talk about something else, start a new conversation. - Unconstructive criticism: don't merely decry the current state of affairs; offer—or at least solicit—suggestions as to how things may be improved. - Snarking (pithy, unproductive, sniping comments) - Discussing potentially offensive or sensitive issues; this all too often leads to unnecessary conflict. - Microaggressions: brief and commonplace verbal, behavioral and environmental indignities that communicate hostile, derogatory or negative slights and insults to a person or group. People are complicated. You should expect to be misunderstood and to misunderstand others; when this inevitably occurs, resist the urge to be defensive or assign blame. Try not to take offense where no offense was intended. Give people the benefit of the doubt. Even if the intent was to provoke, do not rise to it. It is the responsibility of all parties to de-escalate conflict when it arises. **Unwelcome behavior** These actions are explicitly forbidden in Go spaces: * Insulting, demeaning, hateful, or threatening remarks. * Discrimination based on age, disability, gender, nationality, race, religion, sexuality, or similar personal characteristic. * Bullying or systematic harassment. * Unwelcome sexual advances. * Incitement to any of these.
&gt; Unless you mean something different, why do you need native UI for that? Sorry for the confusion. I was talking about the case of using gomobile. In general that means using the gomobile native bindings to create a native UI on each platform. I do not need a native UI so that is why I now consider a web app wrapped up for each platform. Like Cordova does. I had the same ideas about dividing the code. As much as possible is already handled by a backend API. So the device part can be as thin as possible.
I'm not sure why you say there's no binary discover or command line editing. I just typed "ls -l&lt;bs&gt;&lt;bs&gt;" and got a directory listing in short form. The Go standard library taking care of something for us doesn't mean it's not doing something, it just means we're working in a higher level language than C. Either that, or I'm misunderstand what you mean by "binary discovery" and "command line editing" But even without that, I disagree about it meaning it's not a shell, it would just mean it's not a good one.
The kickstarter was there: https://www.kickstarter.com/projects/1604791210/go-gopher-toy Quite happy with the results.
Mine also arrived :D https://www.instagram.com/p/BNxAKrChZoj/
I like the original one more - https://blog.golang.org/gopher/plush.jpg.
Awesome! Perfect timing as I am about to start a SQL based project.
Are the eyes supposed to be that wide apart? O . O
Me too!
I wish Google still sold the original. 
&gt; after reviewing main.go, the commenting friendly, but I would have expected more abstraction to improve human readability over constructs. For instance the for loop in main(). &gt; Can you explain what you mean by that a little more? &gt; Two main()'s: I believe this is a vet error. Probably fine to ignore if this is just a Literate Programming toy. If you plan to have other people consume this, you should consider making tokenize it's own package or combine the two (my preference). &gt; Maybe the comment at the start of the readme needs some clarification. If a block is redeclared, it means "replace the current implementation of the block of that name with this implementation instead", unless there's a += at the end which means "append to that block". There's only 1 main (unless I accidentally included a += somewhere that shouldn't have one.) (This is why I need to formalize the notation I'm using.. that, and so I can write a better tool than copy/paste for compiling the markdown into Go.) Eventually moving Tokenize to its own package might be a good idea, but it's probably not mature enough to do that yet. &gt; Signals: it would be nice to have signal interrupts, like SIGINT/SIGTERM. I believe you can find them in the os package. Like the previous comment, this fine to ignore if you only care about LP, and you're not making a replacement for Bash :) &gt; I plan on eventually implementing signals. First tab completion (actually, first a major bug I discovered where I forgot to actually make the call the set the terminal into raw mode, *then* tab completion), then pipes and redirection, then signals and background processes. It'll probably never replace bash (or zsh), because I'm mostly interested in playing around with the literate programming side of things, but I still want to build it up into something non-trivial because otherwise I can't say that I've *really* tried doing something with LP.
I am concerned with some of the comments made by /u/dgryski. I am not sure this person is the right choice for this sub moving forward.
The slides can be found here: https://speakerdeck.com/farslan/how-to-write-your-own-go-tool
They really dropped the ball. Looks nothing like the original, nothing like the mascot. Still, I kinda want one.
For the most part, I'd agree with you, especially if your access controls are complicated. I'd say you should probably even have a package dedicated solely to security management tucked underneath your app layer. For townsourced, the security model really isn't that complicated, and most of the time it's not about what you *can't* show a user, but what a user should be seeing. So the access controls become a *behavior* that should belong next to their types where you expect to find behaviors. Take the profile example (which I greatly simplified for the purpose of the post), If you want to look at your own profile, you can see everything about the user like their email address, but if you are accessing someone else's profile, then the email address is hidden. It's fine line between access controls, and behaviors.
I wish I could get that one!
I kind of wish I could go back in time, and *not* comment. :) I jumped into reading the code instead of README.md. I've been trying to improve my own literacy by reading README's less, and spending more team reading the code. And that was definitely a mistake with dsh.
Theoretically, the code is an artifact of the markdown. (In practice, I haven't written any tool to automagically extract the code yet..) So if anything, you can just blame it on the fact that I'm still working on it and the README has probably changed since you commented..
Alright, thanks. Do you use gorilla/session or just stdlib?
This demo was so fun. Really loved this talk!
It's certainly better than nothing but in my opinion the original gopher looks much better.
Could you elaborate on that? Is there a particular reason why you would not use Go for Android/iOS? 
Very interesting article that helped me understanding DDD a bit better. A disclaimer first: You seem to have boiled down the sample code from a much larger problem that might have occurred in your real-life projects, so apologies if I am completely missing the point... ...but here is a big HOWEVER: The first version of the code (the pure Go, non-DDD version) is clear and easy to read (just like Gophers love it), while the final version is quite hard to swallow and contains FIVE(!) separate incarnations of the Product entity, with just the same functionality than the first version has. Question: Do you apply DDD - (a) at the moment you find that you *will* have to use the search packages in another domain outside `Product`, or (b) from the beginning, just in case that someone *might* *perhaps* *maybe* want to use the search packages in some project in the future? In case of (b), beware of becoming an [Architecture Astronaut] (https://www.joelonsoftware.com/2001/04/21/dont-let-architecture-astronauts-scare-you/). 
thx, very helpful.
Got mine too. I like it. It's more like [tenntenn's gopher](https://github.com/tenntenn/gopher-stickers) than the official one. It's still a nice plush. My only complaint is that there's a little bit of glue or other white stuff stuck to my gopher's left pupil, but it's not very noticeable. 
An absolutely fantastic talk. Thank you very much /u/farslan -- I did not lose interest!
Well, I expect some clues from Rob Pike's [Lexical Scanning in Go](https://talks.golang.org/2011/lex.slide). Will try to implement lexing that way. And 0 is falsey in C. Go just refuses to use ints in boolean context. As Monkey is... C-style, I expected that C convention, so question followed.
Copy/paste and discipline (then running `go fmt`). I did a quick search for "literate markdown", and the tools that call themselves that seem too heavy weight to me, so I just did something that was easy and made sense. I was going to write a spec (in the same style), then use it to implement itself with copy/paste the same way I'm doing now, then write the shell, but that all seemed boring since I'm still not sold on LP, so I just went straight to step 3. If I think it's worth it, I'll go back and write the tool (and spec) later.
Oh, now I know what you mean! You were only talking about the lexer. Right, I didn't use Pike's approach, because my aim was not to say "here's a super neat, Go-specific solution" but rather "here's a blueprint of what 99% of X out there look like, go forth and modify, extend, optimize as you wish". Monkey is only C-style in syntax :)
Bought mine from Google: http://imgur.com/ROaL3Kb What's funny is that I am not even developing Go - at all - right now. I did the Go Wikipedia clone tutorial and fell in love with it. Unfortunately, my job has me stuck in Java Spring Boot Land and Rails Land previous to that. I plan on learning Go when I need to develop a backend for my mobile app. 
I don't use gorilla/session as I don't really like the concept of a "session" at all. I just use securecookie to encode/verify and handle the cookie myself. I also make sure to delete the cookie after the callback is received.
RWMutex.lock() it is. No fucking idea why they didn't implement concurrent safe types in a concurrent language .........
Aside from the usual dynamic language gripes: its global namespace polluting is obnoxious, its willingness to continue execution on typoed variables emitting a mere NOTICE is laughably poor design, the $ variable prefixing drives me nuts, and constantly having to look up which global function I need for a given situation.... Sorry, I just don't like PHP even a little. It's still a necessity in a lot of situations and my go-to language for quite a bit of work. But I don't like it.
So I believe in helping by teaching to fish. On your command line try go -h You will see a list of built commands: build compile packages and dependencies clean remove object files doc show documentation for package or symbol env print Go environment information fix run go tool fix on packages fmt run gofmt on package sources generate generate Go files by processing source get download and install packages and dependencies install compile and install packages and dependencies list list packages run compile and run Go program test test packages tool run specified go tool version print Go version vet run go tool vet on packages Out of these, fmt and vet are very useful. fmt will format your code and vet will tell you if you have basic problems with your code. Now you can try go help vet or go help generate Other really useful tools out there that are not built in but are highly recommend are: GoRename - Rename something throughout your workspace. Your code will compile after still or the rename will not happen and you will get a useful error https://godoc.org/golang.org/x/tools/cmd/gorename GoImports - Fix your imports automatically https://godoc.org/golang.org/x/tools/cmd/goimports Go Guru - tell you tons of stuff about your code https://docs.google.com/document/d/1_Y9xCEMj5S-7rv2ooHpZNH15JgRT5iM742gJkw5LtmQ/edit I use all of these tools integrated into my editor, vim, with vim-go. https://github.com/fatih/vim-go Though they are all just command line tools that you don't need any editor to use. The tooling in golang is amazing, it has spoiled me from most other languages at this point.
just saying https://godoc.org/golang.org/x/sync/errgroup
I still like this pattern much better than anything in the sync package personally. I have not done benchmarks for comparison, but based on a purely aesthetic standpoint I think this ranging over the input slice twice is very readable and just feels good to use. Also it only uses things in the standard library which is a plus. Though if I was doing things with context then errgroup would be really useful.
NT was never going to be the Unix killer. License costs were. Either way, these two things aren't really comparable since one is a language and the other an operating system.
Finest hand-made `tangle`, so to speak!
&gt; I remember the magazine covers Ah the 90s... &gt; "Go being the C Killer" But seriously nobody ever said *that*.
Eh. Go is probably not going to replace C anytime soon, especially for embedded use when you get 16KB of RAM on your microcontroller, that's a task for other languages. and Go isn't going to stay around forever either, time kills everything. Something better will suceed Go, if that is Go 2 or something else is another question. I personally think go is probably going to make some significant impact, one way or another, it's a great language after all.
In the spirit of releasing early, I thought someone else might benefit from this queue. It's a circular-buffer queue, based on the sequencer design from LMAX. Transfer is allocation free, and you can optionally allocate queue records for yourself up front, using the queue to transfer "control" of a pre-allocated record back and forth between producer and consumer. If others find it useful, it'd be easy to expand to include SPSC, MPMC and SPMC as well. Obviously Go Channels is the better choice in 99.999% of use cases - but if you are building something where the 4th nine matters, this queue might be useful to you. Edit: **Heads up:** I found an error in the benchmarks (surprise, surprise! Benchmarking is hard..), the performance numbers are supposed to be "Latency at 83ns, vs 95ns for channels" for the use case benchmarked in the repo. That obv. reduces the hype factor - though the key selling point of a queue that lets you do batched drains and allocation-free transfer remains.
I don't think there's really a prescribed way to design your packages. I've always followed the go proverb: *design the architecture, name the components, document the details.* The tools allow easy refactoring so that you can easily change the layout of the package as it begins to make more sense. Having said that I guess I end up going the "Ben Johnson" way, which just seems to just be another way of saying loose coupling &amp; high cohesion.
That's very unlikely to happen.
[JWT](https://jwt.io/)
Imagine if it does happen. 
I suppose 'killer' was too strong a term ... an 'alternative to C' may have be more accurate... I haven't seen any serious articles about Go 'killing' C, just more catchy headlines, ie: http://www.woohooitsbacon.com/is-go-the-c-killer/
I can't because Go cannot be bought. 
interfacer is fantastic!
It's true you shouldn't add flexibility for flexibility's sake but a pattern that works the same way for a bunch of different use cases is better than having a different pattern for each one. Unless it adds more complexity to what would otherwise be a simple code. That isn't really the case here though, your code would slightly shorter if you used ErrGroup. It makes sense that you wouldn't have heard of ErrGroup in 2 years of programming in Go, it was added a few months ago in 1.7. It was added because people were developing different patterns for stuff like this and they wanted there to be a standard way to do it. Use whatever you like of course, it's your code and your time that gets wasted when you implement bugs. But don't be surprised when projects start requiring you to use ErrGroup. I certainly wouldn't accept a PR with this pattern in it.
Dude, did you just come to the the church and insult Jesus and expect to get out in one piece?
Impossible. On a second thought, if Trump can be the president...
I am not saying I will be surprised when I do need it. I just was saying I don't need it here. I will not submit pull requests to your projects then, I do wanna say I feel you are being very hostile. Have a nice day.
Thanks! \ʕ◔ϖ◔ʔ/
&gt; I think you're missing the joke Possibly. Is the joke "Haha, Oracle might buy Go, haha" (because Google is using Java on android and stuff)? If that is the joke then I got it and I took the opportunity to generate a discussion from it. Maybe the new topic of discussion is poor? I don't think so. "Go in enterprise" is very close to my heart and it should be an important topic for every gopher. Too bad I see the OP deleted this thread. I'd rather read something silly / funny about Go than any of the drama we had lately.
Your point is quite valid for existing infrastructure, but the benefits inherent to Go would easily sway many conscientious managers of new builds.
&gt; Also bear in mind that you're not the only one who'll read your code, you can expect other Go developers to understand how an ErrGroup works, you can't expect them to understand the half-baked pattern you cooked up to compete with it. The solution the article offers is simple, clear and readable. I could even go as far as to say that it is the (current) idiomatic way of doing things. It just uses loops, errors and channels. *Those* are the things you can expect Go developers to understand. ErrGroup on the other hand? No matter how we see it, it is an external package. That doesn't make it bad by itself but it still means that the average developer has to go and read the documentation for it, understand how it works etc. &gt; It's true you shouldn't add flexibility for flexibility's sake but a pattern that works the same way for a bunch of different use cases is better than having a different pattern for each one. Unless it adds more complexity to what would otherwise be a simple code. That isn't really the case here though, your code would slightly shorter if you used ErrGroup. I would argue that a solution that uses simple language constructs (loops, errors, channels) is as flexible as you can get because you can program with those and they do not require you to learn a new API. And what if the code ends up being longer? It's still simpler and more readable. &gt; Standardization is a good thing in programming languages, it allows the less interesting parts to slip into the background so we can focus on the more interesting parts. Don't fight it. The only standard we have right now is Go itself. If ErrGroup ever becomes a real "standard" then it will become part of the standard library like context did. Right now though this is not the case. &gt; I certainly wouldn't accept a PR with this pattern in it. And I certainly wouldn't accept a PR that suddenly introduced a new dependency in the project for a small part of code while the problem could be be easily solved with simple language constructs. (Obviously if the project was full of code that required this pattern then ErrGroup might make sense to have as a dependency.)
As soon as I have some spare computing power, I'm going to run this on a dedicated server.
&gt; but the benefits inherent to Go would easily sway many conscientious managers of new builds. I totally agree but this not the whole story. Again unless the new build is something that could rely heavily on Go's strength (concurrency), a manager or company has no reason to use Go over Java. Java is the current standard when it comes to "enterprise". (I put enterprise in quotes to emphasize that it is just a system that has been using and trusting the Java solutions for so long.) From my point of view, the Go solutions are already very robust and battle tested and should be adequate for the enterprise world. Nevertheless, the current Java solutions are good enough. Again, unless it is the nature of the project that perfectly fits Go's strengths, you cannot answer the question "Why use Go over Java?" for the general case. And answering this question is very important to convince managers, colleagues, clients etc. And if you might think stuff like simplicity, clarity, readability etc. I can easily say that most higher ups do not care about those (they won't have to write the code anyways).
I need one for all the email spam/hack bots lol
Very good work! Also `:%s/GO/Go/g`.
I think the drama is going to go away eventually and people will move on. Growing pains of the entire community, I guess. &gt;Go in enterprise is very close to my heart So for me. I love Go. I want Go to win in Enterprise.
Exactly. That's what I meant. A example is this Video4Linux library: https://github.com/blackjack/webcam
I'll go through the links. Thank you.
I read, what do yout think about the away that I organized the packages?
Thanks to share with me this article, I agree with it 100%, but in my case, the architecture that we choose is not fancy at all. 
Understood. The point I was trying to make is: Avoid generalizing a design unless you have to. You might never need that level of generalization but the added complexity will remain in the code, making it harder to read and harder to maintain.
Sweet thanks for the link I'll check it out.
For future reference, this kind of comment is not actionable, because it contains no concrete evidence to evaluate. (I can't tell if maybe it was a joke.) 
this is awesome! nice job.
Do you limit the download speed to tie up the bot for longer? That would be a good option.
Please realize that *unit* tests are just one kind of tests. There are also other tests, most of which have some tools or frameworks to help you. A unit test tests only a very limited logical unit like for example a function replacing all whitespaces in a string with an underscore.
Hadn't thought of that, but it's a good idea.
Thanks, you'll do great
Valid point, my question itself was invalid. I can't change it now! Let me rephrase the question, "What are the best practices to test a webserver or API?"
I have two of the original but the one pictured above plus another as-yet-conceived design would make a nice family of gophers.
As of now I am just using Sqlite, so I can mock an entire database for each unit test. Yes, not having to mock an entire database seems nice. It would be great if you can write a blog post about the same.
I'd just like to say that I also program in rust, and the rust community is *fantastic*. I heartily second reaching out to them for advice.
I have added a CompareMultiple() function to enable automatic file hashing: [func CompareMultiple(h hash.Hash, compareOnMatch bool)](https://godoc.org/github.com/udhos/equalfile#CompareMultiple) Usage: equalfile.CompareMultiple(sha256.New(), true) // enable multiple comparison context equal, err := equalfile.CompareFile("file1", "file2") Can you take a look? I accept suggestions on how to include io.LimitedReader in the mix. :)
In all of that earlier noise, did anything actually get *decided* about the relationship between Google and this subreddit? I know that a couple of Googlers stepped down as mods. But I also see that the sub is still listed as one of "*the official forums operated by the Go project*" on the [CoC link](https://golang.org/conduct#spaces). I also see that the sidebar instructs people to contact Google rather than the mods if they have an issue. Who owns this forum at this point? Is there still any of risk of shutdown or major disruption if someone at Google changes their mind down the road? P.S. Regardless, thanks /u/dgryski!
Yes. /r/golang is no longer considered official. The bug to remove it from the website is https://github.com/golang/go/issues/18289 . I've updated the sidebar to say to contact the moderators.
Does someone has a server setup with this? I would like to test my webcrawler.
The HN commenting rules are on https://news.ycombinator.com/newsguidelines.html under "In Comments" . Not a bad set of guidelines.
Holy cow the mod list is looking bare. Was expecting a couple people to step down, but not a complete exodus. Did I miss a thread with more context? Thanks for inheriting the community! Hopefully things will be less dramatic moving forward with moderation that enjoys spending time here.
I'll tweak the wording on the sidebar to indicate that we strive to follow Gopher Values, and link to it. That should make it clear which parts are applicable. The sidebar already says to contact the moderators.
I have been moving to something like what the article highlights. I think it is a pretty good pattern. 
Thanks /u/dgryski for volunteering for this responsibility and for giving your time to the community. I'm hoping this can be a thriving community and I am glad to be a part of it. 
Id rather it be phrased as "allowed technical criticism", rather than an "allowed technical attack". I don't really want to be a part of an environment where people can vent negativity if its disguised as a technical disagreement. ( If I wanted that, I'd just stay in /r/javascript ). Additionally, attacks are often not aimed to improve; criticism is, and one of the things I have always liked about the Go community is that it really does feel like people are trying to improve one another. So, lets keep that here if we can. EDIT: Cute, downvotes. Always nice to see some developers prefer to attack others.
Well, I don't really frequent hacker news, because I just find it to be a very unpleasant place to visit. So, I can't really give it a fair assessment. But here goes: 1) It's an echo chamber for the valley/startup mentality and associated ideologies. For that reason alone, I'm not interested in hanging out there. I'm tolerant of those view points, but I have no interest in posting somewhere that those are the prevailing attitudes. 2) The attitude there is...unbearably smug. I realize this is not a strong argument, but fuck if it isn't true. Now, HN may still have a fantastic moderation policy and maybe good discussions happen there, but I will never find out because the 10 times I've been on HN have been more than enough for me. 
I tweaked the wording to be "Criticising somebody's code or ideas" instead of "Attacking ...".
If you are looking for an extra mod I'm happy to help out. Not sure what the process for picking them will be but I would like to be considered :)
Congrats on figuring this out yourself :) This is actually a fairly well known thing (for lack of a better word) and iirc even the standard library's sort package does something like this. See https://golang.org/src/sort/sort.go In the standard library I believe it uses a version of quick sort and heapsort but I only glanced at the code. Basically, some algorithms are better with smaller datasets and some are better at chunking together large datasets into their corresponding sections, so if we merge them we can write algorithms that are faster in practice. Sorting algorithms are interesting because there isn't always one optimal solution. A bubble sort is better than most sorting algorithms with mostly sorted data. Some sorts do better with large datasets. Others perform better on smaller datasets. I always found them fascinating even if you rarely need to actually implement one in your day to day work.
Actually really good and lots of specific annoying things called out, titles, etc. 
This is brilliant!
1. Really? I've not really perceived this despite having been active for years. Further, I'm from the midwest and I've worked in "traditional" industries as well as a startup. Only once in a great while do I find anyone making valley-centric statements about the world at large. In particular, a good chunk of HN seems to be non-American (lots of British spelling or non-native-English speakers). 2. I've not been part of an tech-centric internet community where this isn't true. In my view, the distinction is that the commenters on HN are more likely to be knowledgeable about something (smug or not). Further, I guess I prefer metered smugness to the outright flaming that I see in other fora. For example, HN comments are much more polite, intelligent, and correct than /r/programming (where the loudest, rudest opinions are voted to the top so long as they're *popular*, with complete disregard for correctness). If indeed your Internet haunts are of better quality than HN, I'd sincerely love to learn about them! &gt; Now, HN may still have a fantastic moderation policy and maybe good discussions happen there, but I will never find out because the 10 times I've been on HN have been more than enough for me. Sorry to hear about your negative experiences. In my opinion, it's less the *policy* than the willingness of the moderators to be subjective and moderate posts (remove posts or propose more respectful language, etc) that they perceive to be overly negative--I say this as someone who has had comments moderated a few times. I guess HN mods seem purposeful about *cultivating* a community for respectful, intelligent conversation (obviously lots slips through the cracks). But I guess your mileage may vary.
I'd suggest the change set referenced has some serious deficiencies, may subvert the spirit, if not the letter, of the go 1 compatibility guidelines, and raises questions about the project's deprecation policy in general. I'd also suggest the issue/implementation/code review sequence that lead to this change set being incorporated appears to have exercised much more discretion than restraint.
I'd suggest the change set referenced has some serious deficiencies, may subvert the spirit, if not the letter, of the go 1 compatibility guidelines, and raises questions about the project's deprecation policy in general. I'd also suggest the issue/implementation/code review sequence that lead to this change set being incorporated appears to have exercised much more discretion than restraint.
thanks. actually I'm following your blog series - Let's learn Algorithms - https://www.calhoun.io which in turn led to this. I'll digress for a moment to say Thanks again for your series, so far I've learned so much directly and indirectly just following along and asking questions.
They had to to make dgryski the head mod.
I like to use the technique described here: [https://blog.golang.org/error-handling-and-go#TOC_3.](https://blog.golang.org/error-handling-and-go#TOC_3.)
[removed]
Awesome stuff man! I will definitely try and learn some from this. Been trying to do some GL stuff in Go.
I've been working through this myself and have found that unit testing http handlers is often not all that useful. IMO Unit tests are good for things where you have little interaction outside of the function (like a test to check valid formats of some thing). But when it comes to http API testing integration/acceptance testing are king. I've landed on the following solution. 1. I use https://github.com/DATA-DOG/go-txdb to create a single-transaction during my test so that data is not leaked out of a test run. 1. Each test does it's own setup (creating things, deleting things) and then runs through test cases. So lets say I have some generic resource `{"foo": [{"bar"}]}` that I expect back from an endpoint. The test would be: * create txdb * get foo via handler (see nothing, assuming a fresh test-db) * setup: insert a foo into the db directly * get foo via handler (see the inserted result) * cleanup: remove foo from db directly * txdb does it's magic and reverts the transaction
Cool! Reminds me one of my favourite games — Hammerfight https://youtu.be/Me7GZcfH8cs?t=64
I do also like this article. Also in Env i put a logger that i use to log some infos. If an error is returned from the handler I record all the infos and the error and send it to an other server (like sentry). If no error I don't print any log. If I start my app with -debug I print all the log every time. I also use the errors package of Dave Cheney to record the traceback and remove all the lines of the stack before the handler to keep it smaller.
Python's [standard sorting algorithm](https://en.wikipedia.org/wiki/Timsort) works exactly as you described (with some other fancy stuff thrown in). 
Instead of returning an error code, I prefer to call "Panic" at any level of my handler and "Defer" a "Recover" at the highest level of the handler.
So once I learn more of the algorithms heap, quick, radix etc... then you just code procedure for selecting the most efficient combination of algorithm to use with the selected data structure??
The most efficient procedure can often be mathematically derived and then implemented as a proof. 
https://blog.golang.org/errors-are-values Obscuring (and likely jeopardizing) control flow over non-exceptional errors is reckless.
Thanks for posting this. I'm not a great coder, and i'd be reluctant to share code if someone personally attacked me, the second version is a constructive criticism, a person could learn from that without feeling like a terrible human being. :)
The idea is plainly not idiomatic. I don't downvote ideas that I don't like, I downvote ideas that are wrong. It is specifically prescribed to not use panic as a normal control flow mechanism.
indeed. I don't have those skills. yet. honestly the math eludes me. I'm trying to remedy that problem. Your link is a very interesting read. I'll bookmark and read a couple times more. thanks. 
"In summary, the defer statement (with or without panic and recover) provides an unusual and POWERFUL mechanism for control flow. It can be used to model a number of features implemented by special-purpose structures in other programming languages. Try it out." By Andrew Gerrand https://blog.golang.org/defer-panic-and-recover 
I hadn't thought of that, but maybe you could send a Zip bomb. 
I feel like this math eludes like 50% (if not more) of people who even go to college and get a computer science degree. Sure, all of those people have to learn how to create proofs and do this, but a vast majority of them only learn enough to get by and quickly forget it after college. I'm saying this not to say that you shouldn't give it a go, but to let you know that it isn't easy for everyone and that you shouldn't get disappointed if it is challenging.
I have to start with objections to the blog post's implementation: *Env is being treated as a surrogate global, Handler is intended to be used as a pseudosingleton, and in many cases, certainly this one, you can accomplish what's accomplished with the H member of the Handler type with an interface. The underlying thought process appears to conflict with my design philosophy. I tend to start from easiest to test and maximum coverage, which enforces separation of concerns, so in general it results in a hybrid approach to handler implementations with a short circuit path to handle protocol and related common logic that handle http.ResponseWriter themselves and a panic/recover mechanism for functions and methods that return an error type, generally along the lines of: defer Recover(w) if session(w,r) &amp;&amp; auth(w,r) &amp;&amp; postform(w,r) { data, err := doSomething(r.Form) if err != nil { PanicCode(500,err) } writeJSON(w,data) } I believe handler implementations should mostly concern themselves with the protocol and be as short as possible with as few logic flows as possible. The example in the blog post makes implementations difficult to test and exhibits an unnecessarily complicated usage and type graph. 
I think you might be going down the wrong path a bit. I see mutable global state in your package, which means that it can't be used concurrently. I'll do up some more details in a bit on what I feel is a more idiomatic API.
Let me see if I understand. The standard JSON package (https://golang.org/src/encoding/json/decode.go) makes use of dozens of panics to simplify its flow control. So, for you, those are not idiomatic too, right?
Even though there is VisualRust (and VisualD) as an example of what you are looking for, I don't see any benefit coding `go` from Visual Studio. Visual Studio Code is a much better experience, in my opinion. 
Gotcha. Thanks for spelling that out for me. Definitely missed the part about deleting other moderators.
Of course it depends on context. It is not appropriate in this context. If you are calling panic() for things which should not panic, it is wrong. Events which should panic are: - logically impossible (covered for thoroughness/clarity/etc.) - unrecoverable
thanks. I'm trying to keep focused on data structures and algorithms. But, I get distracted. I learn new things, sometimes something that was known to me and that l lacked understanding of has light on it with this new knowledge and I'm drawn to it like a moth.
Hey, I'm a little late but wanted to say this is really cool. I looked into game Dev a couple years or so ago with Go, it's something I enjoy for fun but decided to wait for better gfx support. since then go mobile was released and I remember conversation about bringing together a few of the emerging OpenGL libraries into a single effort but it was tough finding a good OpenGL pick. I was really hoping at the time that google would make a big invest in Go mobile (and with that solidifying the OpenGL libs) with the Java patent fiasco but I looked recently and didn't seem like it was moving much. So what's your opinion after having worked with OpenGL recently in Go? Is the Go-gl I see in your project the best library if I wanted to play around? 
Sent you over a pull request! https://github.com/o1egl/govatar/pull/1
Looks like an interesting product. I've seen a lot of these, but very few have an on-premise solution I can run myself. Does stackimpact? Shipping this kind of data to the cloud is a non starter for a lot of orgs. 
I disagree. You never earn the right to belittle others. 
Nitpick: please, do not add a period (full stop) at the end of your titles (headlines). Ref: http://english.stackexchange.com/questions/32884/should-i-use-a-period-at-the-end-of-a-headline
Is there any chance of getting some nicer CSS? The default blue on reddit is close enough to Go blue that the default style almost works, but it can't hurt.
Thank you. I have a different thought, how about creating an entirely new database for the test case? After all this is an API is just going to call a db method to insert or update or delete or fetch. Is it wise to spawn a new db, have a table driven test for insertion, after each insert, fetch the count and the values if you like, if not okay, then problem, else it's okay. Later, checking the json returned by the handlers?
Search for "unreachable" or "unaddressable". Where are there calls to panic such that they are reasonably reachable or recoverable? If you have found such places, please, fix the APIs, or write your own improved versions.
A couple examples of the types of issues you might see: 1. Testing is harder (imo). 2. Memory leaks and rogue go routines. I haven't verified the second one, but I suspect if your handler first creates a go routine that it needs to tell to stop (like a [time.Ticker](https://golang.org/pkg/time/#NewTicker)), and then (b) `panic`s, that the ticker will continue running forever. By using a `panic/recover` model, you are effectively not giving that handler a chance to clean up after itself when an error does occur, which is especially bad when concurrency is as easy to use as it is in Go. All of that said, I think most of us have probably written a Go server with something like [negroni](https://github.com/urfave/negroni)'s Recovery middleware and abused it without any issues, but it is possible to run into real issues if you continue using this pattern. 
AFAIK one of the best experiences right now in go is Visual Studio Code (editing, testing, debugging etc). Visual Studio 2015 does not have any support... It is refreshing to use Code since it is lighting fast when compared to VS... VS Code is excellent in doing what everybody does. Code editing, intellisense and debugging (delve). Why would you use VS, which is a pretty big 
Thanks. I didn't know you could change the vue delimiters. Very interesting! How have you found using vue.js in general? I'm a fan of how small it is but didn't really get further than the examples.
My best guess is that Go gives you simple tools which you can combine to create a full solution the way it fits your needs. I've also thought many times that it's kinda stupid that the normal http handler does not return an error. Then again nobody stops you from making it return an error. Also why should it return an error and not (int, error) or why not *appError? It is not easy to answer these questions and if somehow you do then you end up creating an opinionated web framework and there are already dozens of those. Also after using a custom handler that returns an error for many projects, I've come to appreciate using a plain http handler and just have my own custom error function to call inside that functions similar to `http.Error`. Nevertheless a custom http handler signature is a very good pattern and I believe it is what Go is all about.
[go-gl/gl](https://github.com/go-gl/gl) together with [go-gl/glfw](https://github.com/go-gl/) is a solid solution -- thin wrapper over gl and glfw; so you cannot go wrong with this. However it doesn't feel like a idiomatic solution. There's [goxjs/gl](https://github.com/goxjs/gl) and [goxjs/glfw](https://github.com/goxjs/glfw), which adds some compatibility across desktop, mobile and web. It's a thin wrap over the previous, so should be quite stable as well. I like [x/mobile](https://github.com/golang/mobile), but it's still in experimental stage. It has a breaking bug on Windows at the moment[*](https://github.com/golang/go/issues/17325), which is the main reason I didn't use it this time. _I'm also not quite sure whether the gl API will change or not._ There's also [github.com/azul3d](https://github.com/azul3d), whose API looks really nice. Although, I haven't used it so I cannot vouch for it's quality. _Now, what I would like to see is [raylib](http://www.raylib.com/) for Go. I think it would be a good baseline for an idiomatic Go game library._ Whichever you pick, try to write your game code such that it will be easy to switch out the renderer/window/audio/input libraries. e.g. see render commands approaches [1](http://www.roundcrisis.com/2013/05/24/multithreading-rendering-in-a-game-engine-with-cdouble-buffer-implementation/) [2](http://fabiensanglard.net/quake3/index.php).
I was very careful in my wording. This subreddit is not under the purview of the CoC, but I was using the descriptions of Gopher Values as a list of encouraged and discouraged behaviours. Can you point to a specific clause in "Gopher Values" section that you think inhibits *technical* discussion? The comments are still not a free-for-all. As I stated above, personal attacks are not welcome here.
&gt; For callings of this case, Go compilers will &gt; have the same signature (at least in Go1.7): I am almost convinced those two cases are typos.
You mean the two lines are shown together? Not for me. Could you show a screenshot? [edit] ok, I removed a redundant &lt;/p&gt; in the page.
This machine keeps eating my quarters.
I thought about that last night and tried to comment out the block in line 164 (supposed the http.post returned no error). After I commented out the block in line 164, the code ran to line 197 =&gt; break and exit at 208. I am thinking the json I send from the server is not right json.
Hi! I have always seen this subreddit as a less-technical/more-casual place to discuss about golang, and the golang mailing lists as the place about golang itself and more technical/serious place. Will /r/golang still be such place?
Well done, this shows great insight and understanding! How long have you been coding?
&gt; You mean the two lines are shown together? Not for me. Could you show a screenshot? &gt; [edit] ok, I removed a redundant &lt;/p&gt; in the page. Sorry it was a bad attempt at a joke. The joke is that the word Golang is used so much in this article that the two only cases that the word Go is used (shown above) feel like typos.
Agreed, most probably the error is caused by wrong data.
Um, it's one of the more accessible technical documentations by the guy who created C++. At any rate... the idea of a Concept in C++ is quite similar the concept of typeclasses in Haskell, and small interfaces in Go. I must stress the idea of small interfaces because I've seen libraries with huge ass interfaces (some of my own libraries fall into that trap too). Huge interfaces sorta break the idea of a concept. The idea is best exemplified in the typical examples of Go interfaces: `io.Reader`. The `Reader` interface has one method: `Read()`. Now, if you follow to Go adage of accepting interfaces and returning specific structs, you pretty much are doing a majority of what Stroustrup wrote. Now take this idea, and apply it on EVERYTHING in Go (which I think cannot be done,and shouldn't be done), and you have Concepts... more or less. The generics bit of course, is this: imagine if `int` implements a hypothetical `Adder` interface, and a `float64` implements an `Adder` interface. You can then have a `Number` interface that looks like this: type Number interface{ Adder Subber Muller Divver } Or all slices implement a `Ranger` interface. You then have the concept of Concepts. But of course Go's compiler treats primitive types as special cases, which is a reason why we don't have these interfaces to begin with. TL;DR - Concepts are Go's interfaces + "accept interfaces return structs" that is enforced by a compiler
This document is about C++ Concepts which is similar (in an idea, not in implementation) to Rust's traits and Haskell type classes. Correctly C++ already supports some sort of it using SFINAE and tag dispatch methods of metaprogramming. But verbosity of errors on wrong argument type is quite... big. More importantly, it's quite hard to implement constraints where there is several of them on one type. Concepts are proposed to solve both of this issues. I fail to see how this is relevant for Go, though. C++ type system is drastically different from Go's. There are similarities between Concepts and Go interfaces (both essentially are the type constraints), but Concepts work in compile-time where Go interfaces work in runtime. Interfaces could be adapted to work in compile-time, but that would require solving the "boxing" problem. Among many others. 
The majority of the discussion should be around Go. Drawing the line at exactly what counts as "technical" vs "casual chit-chat" is not something I want to police. More important I think is the *tone* of the conversation: hence my comments about communication style.
I can't edit titles :(
&gt;I used Apache in the past, for hosting PHP websites. I know very little about NGINX but from what I understand it's also a web/mail server. Nginx uses an asynchronous model for serving requests which gives it better performance than Apache for certain use cases. It has historically had extremely good capabilities for serving static content, or tons of connections without the memory overhead of tons of threads to service them. &gt;How do most developers use Go on the server, do they install the web server software together with the Go program, or do they use the stdlib http/smtp server? Go has a stdlib which contains a production grade net package. It can be used directly as a web server without the need for a reverse proxy. That is, many people simply copy a binary to a server and start it on a port. But others may have reasons for putting a Go server behind a reverse proxy (Apache, nginx, Caddy) &gt;What are the pros and cons of using full web servers like Apache and using only the Go libraries? A Go binary can be a full web server on its own without Apache. But if you need to proxy requests to different applications, then maybe a dedicated web server like Apache, nginx, caddy, or other may be desirable to you. Maybe a particular server has very good caching and serving of static content. Or you want to use a load balancer in front of multiple instances of a server. Or you want to handle authentication or encryption before your Go application. 
Maybe one of these can be of some use for you: * [github.com/gonum/plot](https://github.com/gonum/plot) * [github.com/cznic/plot](https://github.com/cznic/plot)
Mostly I like the idea, but since I pay for bandwidth and the bot is likely using a hacked server, I keep thinking it'd be like getting back at car thieves by tricking them into all parking in your driveway. :)
`errors` is a channel. Channels are useful for passing data from one goroutine to another. The `&lt;-` operator has two meanings: err := &lt;-errors // read from channel errors into err errors &lt;- err // write the value of err into channel errors The second version appears in function `AddN`, in the select/case block. More details about this operator [here (basic)](https://tour.golang.org/concurrency/2), [here (advanced)](https://golang.org/doc/effective_go.html#channels), and also [here (by example)](https://gobyexample.com/channels). In the code, `AddN` spawns `n` goroutines that call `CallWithoutResult` and, in case of an error, send err to the errors channel. (Yes, they all share the same channel.) In `main()`, the statement `if err := &lt;- errors ...` blocks until one error is received from any of the goroutines. It seems that `AddN` closes the error channel when it exits (`defer close(errors)`), so the goroutines (which might still run after AddN exits) might not have a chance to write to the errors channel when they need to. Maybe one thing to look closer into.
I am no expert in front end dev, but Vue is amazing. I mean it. It was just one month ago that I started reading about it, and I have a fully functioning app, http://github.com/thewhitetulip/Tasks-vue I am documenting my learnings into a web tutorial which I'll publish via leanpub (and will be pay what you want model) here, http://github.com/thewhitetulip/intro-to-vuejs
I took a Java and VB class in college - years ago. Read a couple of C books but then dropped any programming for a long while. I decided about 3 months ago I was going to learn and I was going to finish. I picked a new language, read a ton of articles about the different tracks that lead to developer jobs and dug in. I'm 4 months in learning part-time. But, I code for about an hour at least 5 days a week and read or watch related material 7 days a week with a day off about every 2 weeks. There is a ton to learn. Admittedly it's somewhat intimidating. 
Okay, so I should tag my tests, test against a mock db and an actual db. Thank you :-)
Very good list!
Yup, agreed. People can rightly criticize C++ for a lot of things: baroque syntax, backwards compatibility with dangerous C behavior, and lurking footguns. But with all that said, Bjarne definitely wants to make the language straightforward to use, and accessible to the everyday application programmer, not just to the "gurus". It's a reason he's quite popular within the C++ community.
I'll give it look. I read the sort.go code that u/joncalhoun posted. I didn't understand most of it. I might try tweaking a little more on my code. However, I am trying to really stay focused on my studies. Quick, Radix, Merge, Insertion and others I'm probably not aware of, all the data structures linked list(doubly) , stacks, Trees, Trie, BST, Ques, OH my. So much. And did I mention that recursion just blows my mind. It's all awesome fun.
What about this new api? https://godoc.org/github.com/udhos/equalfile 
I agree. If the clause at the top of the program was the entire challenge description, then this is a good submission. I could come up with some nits around error handling, perhaps a bit of structural improvement... but nothing serious.
That is mostly correct, tho Bjarne himself says that if you have Concept with one method you are doing something wrong, because there is a possibility that type is going to be wrongly used. For example in cases where Draw can represent painting or taking one's weapon from the holster. Go has similar problem, but in practice it almost never happens. Also Concepts do not have any runtime performance penalty unlike Go interfaces. Currently interface call is around 10-20 times slower than direct method call in worst case scenario. Keep in mind that even that penalty is still in ns's, so you shouldn't really worry about it in 99.9999% of the cases of Go development. C++ on the other hand is used mostly in time\resource constraint enthronements, so it matters there.
That user case (error handling between two goroutines) is not appropriated for "panic, defer and recover". Rob Pyke wrote about it: "Another proposal may happen regarding handling/monitoring exceptions in goroutine A from the safety of goroutine B, but that is not part of this proposal and may not happen at all, although we believe it may be achievable entirely by library code given this proposal." https://groups.google.com/forum/#!topic/golang-nuts/HOXNBQu5c-Q Anyway, the same problem could happen with a conventional error handling and should be resolved case by case.
right on time, as i'm getting my personal project just about ready for some graphql/dgraph integration. keep up the good work
Line 39: `Timeout` is a `time.Duration`, for a one second timeout you should use `Timeout: time.Second,` (and for a 10 second timeout you should use `Timeout: 10 * time.Second,`). Line 51: I'd avoid reading the entire (possibly huge) response body into memory with `ioutil.ReadAll` and instead count occurrences while reading/streaming the body. Lines 77 &amp; 84: you use `defer` for `wg.Done()` but put `&lt;-sem` at the end where it won't get run if something should panic. I'd put both cleanup together (either as `defer` [preferred] or at the end of the function). Line 81: IMO this belongs at line 104; it's cleaner that way and writing to `os.Stdout` via `fmt.Printf` may not be safe in concurrent gotroutines.
that's the point it has been designed for, it doesn't need any other application.
Cool; let me know of any issues you run into :)
Javascript and Go is not only about a print/log statement. Go simply feels better and "cleaner". I think it's due its type system but not only. Once you learn Go well you never look back at JS. JS feels like bash used wrong(i.e. for complex apps). 
I'd prefer the top mod to be a true leader - not a puppet. That CoC has caused so much grief that it shouldn't even be considered as a foundation to a new beginning. *I'm not even sure why CoCs were brought up in the meet&amp;greet post. I haven't seen behavior here that would warrant such actions.
Hey, I think that's a step in the right direction! Encapsulating the parts into a struct is good, and unifying the API is pretty good too. One of the strong points of Go in my opinion is how it leads you to write orthogonal concepts which can be composed to create more complicated behaviours. For example, you wanted to be able to limit how many bytes were read, but wanted it to be an error case if it goes over. I would create a new io.Reader concept called something like [AtMostReader](https://play.golang.org/p/j7v7Il6676) which returns normally if it reads &lt;= n bytes, but once it reads n+1 bytes returns an error. Then, you don't use this reader at all in your library. Instead, clients of your lib would wrap their input reader to your lib with AtMostReader, which will give you the desired behaviour, without baking the logic into your code (and even better, this new concept can be re-used in other situations!) With that said I have a couple other pointers * Consider reading Rob Pikes thing on one way to design [Options](https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html). It may not apply perfectly here, but it's a good read that can help provide a new way at looking at problems. * Consider ways to make this API more composable itself (or at least use composition more internally). One common trick is to do: newR := io.TeeReader(originalR, hasher). The neat thing about this is that newR works just like originalR, but will also write every read by to hasher as well. So once it's all read (say by your byte-by-byte comparison method) you can easily grab the hash of the data. * Could any of your types implement std. interfaces? Maybe your Cmp type could implement something like [io.ReaderFrom](https://golang.org/pkg/io/#ReaderFrom) so that it could consume a reader and tell you if it matches other ones it's read (via the hash). Just some ideas though, I hope you're having fun with Go.
push me baby one more time
I also went to the rust subreddit, I could not find an ounce of negativity. There is a little negativity in our golang sub, but yes, we can do better.
Even I have had a good experience with HN, I am not from US.
Nice list! I think that if you make this into a github repo, "awesome projects", then it'd be great, the page is too big, it took my Safari 3seconds to load the search bar
If you want to learn how to write webapps in Go without using a web framework, you might like reading this tutorial(which I wrote), http://github.com/thewhitetulip/web-dev-golang-anti-textbook http is built into the language and it is an amazing package, hence no framework needed. All you need are a collection of libraries.
Thank you. I understand now. May I ask from line 102 to 108, inside the func Call(url string, args ...Serializer) (src SliceReadCloser, err error) block, is that where the src got declared as a struct{} and immediately got initialized with values ?
HTTP was designed for hypertext and look at it now
How did you come to that conclusion??
Exactly. It just looks a bit strange because of the two {}{} blocks. But it's just as you assumed: A struct declaration followed by a struct literal for initialization. 
yeah but keep in mind that having a 50MB pdf will eat up that much memory, you need to write it in chunks to avoid huge memory usage.
What happens if you push something the client already has cached? Seems like you speed up the first page load at the cost of slowing down subsequent ones.
Thanks for the amazing ideas! I guess I will need some time to digest them. :) 
I just commit all my dependencies to `vendor/` and manually update them.
I like the idea, but how would you pass information from app to data without running into a cyclical import error?
You can still set the headers and then use ServeFile as well. It is slightly better than io.Copy 
Thanks! But I still can't seem to run example/starwars/server/server.go. I keep getting loads of errors...
Yeah I only adding the tea leaf part to try to get it back to the golang reddit somehow, but I suspect that rsc may actually have interests outside of go.
Yeah, but I also can understand seeing a project as your baby and not wanting to let go of it. I definitely do respect people who can say no to money.
Which is okay if you're working on code built into executable. Not so much if you're working on library code that is shared and uses shared types.
Lately I'm convinced that the only tool that does it right is gb. GOPATH is the problem. The biggest problem of all is that you tend to keep it messy with libs/apps installed from various sources. And go tool just silently compiles your code if you forgot to vendor something. While getting towards more npm-like approach where you can have both global and local workspaces is a way to go. There is another problem of course and that is what to do with dependencies of dependencies. I think flattening the tree is the only valid option here. Yes it will lead to conflicts, but at the same time you need to resolve these conflicts eventually one way or another. And despite all the pain that gb tool gives (going away from GOPATH and go tool, means all Go tools may not work with gb structured repos), it's the only one that works for me personally. EDIT: But that's when it comes to binary apps, have no clue what to do with libraries though, path-based versioning with major releases seems to be working well for many libs out there. 
This code is indeed not very intuitive, and I reckon there is a clearer way of doing the same. Short answer: The code makes `AddN` wait until the first of the goroutines has finished. Long answer: This line creates a channel of empty structs: done := make(chan struct{}) The defer statement says: Execute this anonymous func() whenever the current function (which is AddN) exits: defer func() { &lt;-done }() The func() executes `&lt;-done`, and `&lt;-done` blocks until it can receive something from the `done`channel. So `AddN` cannot exit until the `done` channel delivers something. The following lines spawn a goroutine that closes the done channel when it exits: go func() { defer close(done) And this is called in a loop, causing a number of goroutines to attempt closing the done channel on exiting. This does not seem to make any sense, but in fact it just does a weird trick. The point is that [reading from a closed channel always succeeds](https://golang.org/ref/spec#Close) (!), and each read returns the zero value of the channel's type. This is a bit counter-intuitive, but that's life. (Side note: It is possible to check whether a channel is closed, by using the "comma, ok" idiom: `val, ok = &lt;-done` - the `ok` value is `true` as long as the channel is open.) What now happens is: After the first goroutine exits, the deferred `close(done)` is called. Now the `done` channel is closed and therefore `AddN`'s `&lt;-done` statement is able to read something from the channel. So it unblocks, and the deferred func() can exit, and thus `AddN` can exit. In summary, `AddN` does not exit until the first goroutine exits.
&gt;&gt; HTTP was designed for hypertext and look at it now &gt; Yup, still transporting hypertext like a boss. Yup, along with a ton of other use cases not involving screens, graphics or point-and-clicks EDIT: formatting 
The browsers send RST_STREAM to reject to re-request cached objects.
I thought it was in line with the conception of an official package manager for Go. Not aliases. I am glad to see such a good analysis of the current situation and how they can (or cannot) improve it. Thanks for sharing it.
&gt; (IIRC, in some versions of Go, the second word could be a plain value instead of a pointer if, e.g., you have an int, but I could be misremembering.) Earlier versions of Go did perform this optimization, but [starting in 1.4](https://golang.org/doc/go1.4#performance) the behavior was dropped to make the garbage collector simpler: &gt; The implementation of interface values has been modified. In earlier releases, the interface contained a word that was either a pointer or a one-word scalar value, depending on the type of the concrete object stored. This implementation was problematical for the garbage collector, so as of 1.4 interface values always hold a pointer. In running programs, most interface values were pointers anyway, so the effect is minimal, but programs that store integers (for example) in interfaces will see more allocations.
Go get the project Change into example/server folder Go build Run ./server Should work
I've found git submodules, gopath-per-project and being disciplined about vendoring "below" is adequate.
It's made by the creator of GopherJS. :)
The user survey is entirely broken in Firefox on Linux (Ubuntu 16.04). Each screen is blank with the exception of the title and the Back/Continue buttons. I can click through each page without filling anything in.
I had no problem on Firefox in Windows, and even then I'm running tons of blockers. It *should* technically work the same, right? It's all Gecko...
I'm amazed how Russ Cox manages to write about difficult things so even an unexperienced person can understand what it's all about. Great reading!
This is still one of the most disgraceful things about Go, so it's good that someone is taking the reigns on sorting it out. On the other hand, the best solutions to this problem are known already. We need a central repository with a refined version of the tools from languages that have already done it properly: JS/npm, Rust/Cargo, Elixir/Mix. And we need to get rid of the stupid GOPATH. The fact that that isn't the clear message from this is worrying. It's great that something is being done, but it remains frustrating that it has taken so long. 
hmph, I said hugs and free puppies. Oh, and stop trying so hard.
I'm on ff nightly on Fedora 25 and have no issues (also running ublock origin). 
(Offtopic warning) Omgosh that new Go font is not growing on me *at all*. :( Can we make a deal: add alias, ditch the font?
Apple is using http/2 server push for push notifications, and firebase.io uses http/2 server push for data updates through their client. It's up to YOU, the server/client side maintainer, to decide the application of the data you wish to push.
Why are you still here?
This was part of an R&amp;D project I was doing which ended up going a different route, so I wanted to make this library available in case it is of interest to anyone. Was holding off tagging a 1.0.0 in case there was any initial feedback. 
1. Because it's mission is to archive everything of meaning on internet? Including things that aren't intended to be searched and user-provided URLs. 2. Not use crypto random, seed pseudorandom using crypto random.
well, nice to get another opinion. are you on linux maybe? here's how it looks for me on mac: http://pasteboard.co/9z3M9nd3d.png the vertical and spacing is so weird it almost creates a "text is swimming" effect for me when reading it. here's a closeup, with another font for comparison: http://pasteboard.co/XjP5Zrpm.png notice how in the golang font the h and the n float above the average height, and how there are large gaps in space between u and a, and a very small gap between l and a? (i do concede though that a lot of it probably has to do with familiarity. the go font seems to have a lot more in common with old-school back-in-the-day computer fonts than fonts we're used to seeing on the web today.)
You wouldn't. The interaction between the app and the data layers will depend on what database you are using. If it's a sql database, your data layers calls will return sql rows. If you are using an ORM or a NoSQL database, then you're unfortunately left with typeless empty interfaces that you'll pass pointers to your app types through. I'd also consider the data package to option, especially on smaller web apps. My number one reason for splitting the data layer out to a separate package is so that I could potentially change my database backend if needed without impacting my application logic to much. Switching from Mongo to RethinkDB? Just swap out the queries in the data layers and everything should still work. That's the idea.
Agreed, its the mono I like. 
&gt; There is another problem of course and that is what to do with dependencies of dependencies. I think flattening the tree is the only valid option here. Yes it will lead to conflicts, but at the same time you need to resolve these conflicts eventually one way or another. Isn't this one of the things that node does rather nicely? In the sense that a package will call _its_ dependencies within _its_ vendor folder. Thus this structure: myapp/ vendor/ pkg1/ vendor/ pkgA@1.0/ pkg2/ vendor/ pkgA@2.0/ works fine. If pkg1 says "doThingFromPkgA" it'll get the 1.0 library, where as pkg2 will get the 2.0 library. NPM does "flatten" things out, but just to optimize downloads (it then symlinks where needed). Or maybe that's just something that _can't_ be done in `go`?
This seems like the best solution. Thanks!
A well-written article that helps OO programmers to gently transition from OO thinking to Go thinking. 
split, sort, loop look at strings pkg, sort pkg. go through tour.golang.org for basic understanding of loops `type numrange struct { begin, end int }` `func( n numrange) String() string { }` setup an array of numrange and fill it in. loop and print if begin == end, print without ..
Man, that just looks like you're running Solaris.
Go isn't able to import multiple versions of a single namespace at once, to my knowledge.
I'm excited. And Caddy will support it right away as well: https://github.com/mholt/caddy/pull/1215 (There's some ongoing discussion about how to make server push more automatic and easy to use -- likely parsing HTML documents as they're sent over the wire, but if you have ideas/comments about that, feel free to contribute to the discussion there too.)
There have already been two huge threads about the new Go fonts. We don't need more.
Yeah, PHP has the same problem. Because javascript libraries are just big, wrapped up objects, each package can reference the "wrapped up object" returned by executing `pkgA@2.0/exported.js`. I kinda figured go was in the boat of "two *.go files say `package myname` so, uh, kahblooey!"
This seems like… clickbait. And likely, an exaggeration. Some questions: 1. Was the code, at that point, already released as Open Source? What License? 2. What were the specific proposed terms of "buying the software"? Does it come with the agreement to not work on it anymore? Or with the requirement to continue to work for them? 3. Why doesn't this US company have the standard clause about IP in their contracts? I'm assuming the answer to 1 is "yes" and it that case, I can't imagine the downsides of making the deal outweighing the upsides. Even if I assume the worst possible things for 2 (yes, I have to continue to work for them, no I can't work on this project in my free time), that would still mean that they are paying me $1M to work on something I love for two years and the project still being available to the community to do whatever with it. I don't know. The article leaves out all the interesting information to evaluate this.
I would like a vote on renaming Go to Golang. To many Gos around.
Sounds like couchdb
What the article doesn't cover (and what is my greatest annoyance with all this versioning business): What about people who don't want to be bothered with all this vendoring/versioning/locking/… business? What happens to me, who wants people to just use HEAD for their projects and just want to use HEAD of other people's projects? For most of my stuff "releases" just don't make a lot of sense. Will people like me still be able to use go? Or will we be forced to buy into paying time into a bureaucracy we don't believe in? (and yeah, if this is not supported, I'll totally write a script that tags each commit with a major version increase, to continue to live in the world I want to live in while staying technically compatible with the tools…)
`w.Header().Set("Content-Type", r.Header.Get("Content-Type"))` Use `"application/pdf"` instead of setting content type from the request.
[removed]
Note not a shell, a shell formatter. With a misleading name.
Well said. Unfortunately as Peter Bourgon wrote: "[the ship has sailed](https://www.reddit.com/r/golang/comments/5g91zm/speculation_keynote_rich_hickey_why_semver_is/daqty2d/)". That made me quite sad and made me realize that is it not even worth discussing about this subject anymore.
Free plush gopher toys for everyone!
You'll still be able to use `go get` for fetching HEAD, so if you don't want dependency management, you don't have to do anything.
What kind of plots do you surmise to use or need? 1d? 2D? 3D? Interactive plots? One possible avenue is to leverage github.com/gonum/plot to achieve this. See for example: https://github.com/go-hep/hplot 
"It's Go not Golang"
Thanks for a fresh start. While we're at it, can we update the side bar too ?
I did a quick bit of testing of gini vs minisat on a large problem from the SAT2007 competition. (mizh-md5-47-3.cnf, 65604 variables and 273522 clauses). minisat took 55s, gini took 1m30s, picosat took 3m. edit: building gini's internal solver package with '-B' (to eliminate bounds checks, as recommended by the docs) drops the time to 1m20s.
1. No - it was never open sourced :( 2. It would be to work WITH the IP on other projects, not focussed on the original project itself 3. The IP was developed before I started working for the company It's not exaggeration, in fact, as a result of writing the post the CEO got in touch and clarified that the stock (they exited last year) would have meant I'd receive more than $1M. Shit.
I don't see how my sexuality is relevant to the project, why are they including those questions. I find that annoying since my life is not focused around it.
Okay, that changes things a bit, then. :) I wouldn't fret the stock too much, though. Equity is always a gamble.
So essentially the same as caseynashvegas suggested. Good to hear more people do that !
Now what do we call forums written in Go?
good catch, thank you
What about preallocating space for `encountered` and `result`?
Are we really discussing the _idiomatic_ way of removing duplicates in a bloody slice?
https://archive.org/about/faqs.php#14 You can do that. I like getting the same results for the first fetch. After that, it's the same either way. 
Not specific to sidebar, but I have a couple of ideas - - I think a well written wiki is a must. - An FAQ. Must contain: what "framework" to use when writing web apps. - Strictly no more trolling/whining on generics. On the resources side, I think we need a revamp. I have found these articles to be very helpful - - https://peter.bourgon.org/go-best-practices-2016/ - http://archive.is/http://arslan.io/ten-useful-techniques-in-go (The original link seems to be down because Fatih's domain does not resolve anymore) ping /u/farslan 
There are two ways here: https://play.golang.org/p/n6O6V5lzu- since Get only reads the pointer is not necessary. The other solution would be: https://play.golang.org/p/Owg-U_JYsk where you take the pointer to the object and now it implements the interface. Kinda hard at the beginning to grasp :) 
FF on Android worked fine for me.
Your `SliceUniq` func works *in place*, and so it's only the first time your benchmarks use the unmodified input.
I have had a quick look at the existing possibilities of plotting with Go. The one that I liked the most so far is this: https://github.com/wcharczuk/go-chart However, Matplotlib is very commonly used when producing graphs for scientific purposes. Porting that particular library would substantially lower the threshold when switching to Go, for anyone coming from Matlab or Python coding (both very common for scientific purposes). I know it would for me! And I would also feel much safer knowing that all the functionality I am used to from Matlab/Python will be available for me when I'm starting out some new big project in Go. 
Time to update my pocket queue !
I think first and foremost is having a solid foundation for your application. Building the structure, that foundation, is what will take the longest. For instance, you start building the API and then realize you should probably code up proper error handling to match JSONAPI specs. Once this structure is in place though, adding to it becomes a much faster process because it's already there, you just have to basically copy the same logic and methods over to the new routes, services, etc that you create. Tbh I spent a lot of time building my current SaaS project, but a large part of that was learning Go. Shameless plug here btw because I'm a single founder and need the traffic :) [https://maildb.io/](https://maildb.io/) . Everything on there is coded in Go, including the crawler application. I'm thinking of doing a blog post about how my app is structured, similar to what another gopher posted not too long ago. If anyone is interested let me know, I wanna cover as many aspects of building a production level SaaS application in Go as I can.
The test is wrong. Because the go app is executing templates for every request. 
Code looked fine until I came across this: https://github.com/alistanis/silentinstall/blob/master/silent/cmd.go#L105 The docstring is confusing, the actual struct is also confusing, an IO struct with two string fields? Looked at how it's used here: https://github.com/alistanis/silentinstall/blob/master/silent/cmd.go#L231 Feel like I'd probably need to go another step to get the full picture but feel like a better docstring and maybe name would have clarified from the get-go.
is having a variable named `i2` idiomatic?
Nice! I really like your use of the `make(..., len(s))` and the `j` because it will avoid the extra allocations that was, like OP said taking up most of the time in OP's benchmark.
Thanks for taking a look! I actually struggled with what to name it. Do you think that naming the struct Expectation or something similar would help to clarify the intent?
In my tests Go is much faster than phalcon. I would not trust these results.
That sounds like it's more on the right track based on what I saw in the Match method, but keep in mind I still don't know what it looks like exactly. One of my favorite things to do once you have a couple word choices, like `Expectation`, is to consult a thesaurus for some synonyms for some additional choices. If the struct has a very specific use (it looked like it did), I'd give it a very specific/detailed docstring (that doesn't necessarily mean lengthy). Right now for example, the docstring just mentions `input/output` three different times without saying much of anything. That works for something like `io.Reader` which is truly generic, but not in this case I think. Overall though, most of the code looked good in my brief perusing.
Is there any benefit to using the empty struct as the value instead of something like a bool?
i don't see an issue with it. especially considering idiomatic golang's propensity for shorter variable names
Nope, no 3D plots per se (except for 2D plots + z encoded as color)
An empty struct doesn't use any memory (although using bool values make the code slightly more readable IMHO) Dave Cheney has a good post on this (also read the comments): https://dave.cheney.net/2014/03/25/the-empty-struct
No
I can't tell if this is sarcasm or not. But the question is important for at least trying to see if the community is diverse. Edit: Also, you don't have to answer if you don't want to.
That made me curious. Just to put into perspective if you forgot the 2nd parameter in make map. with 10k elements: 100 23609788 ns/op 0 B/op 0 allocs/op old with O(n^2) with 2 slices 1000 1696117 ns/op 383012 B/op 624 allocs/op without len() as 2nd param in make 2000 937479 ns/op 176523 B/op 135 allocs/op with len() as 2nd param in make map Speed over less allocs?
No, the committee is not rubberstamping one of the existing designs. You can see exactly what the process has been, including the user stories, design space, and spec documents, [here](https://docs.google.com/document/d/18tNd8r5DV0yluCR7tPvkMTsWD_lYcRO7NhpNSDymRr8/edit#).
My favorite keyword is despiteallobjections
goBB - like phpBB but designed for this millennium.
Yes
It's also a bit like the IBM PC ROM console font.
When designing the software, model your data structures first. Your data structures are the most important part of the system, especially when it comes to refactoring and iterating. How data is stored, retrieved, processed, and presented (via an API if you have one) is all secondary to how your application represents the data internally. A poor data structure is going to have a poor persistence model, poor algorithms, and a poor API. If I'm making something with an HTTP API, I prefer either using just `net/http` or if I need a third-party router, one that is easily compatible with `net/http`. This excludes most routers/frameworks with nonstandard handler signatures, but ensures that *if I do* need to change something, I have less work to do. Encapsulate. If you're not hiding information, refactoring and iterating is more difficult. If you find yourself frequently "reaching through" several nested layers of custom data structures, you should revisit your abstractions. I say "custom" here because standard library data structures are practically guaranteed not to change in incompatible ways. But it's still a good idea to encapsulate there too; it not only makes your module's API more clear, but allows for changes in the implementation without affecting anything outside of your module. An extension of encapsulation is a gratuitous use of interfaces. Methods that accept interfaces are more flexible for clients and make refactoring, iterating, **and testing** a breeze. If a module's API utilizes structs with methods, try to make them interfaces instead. Releasing the software: continuous integration. Get some sort of pipeline running so that you can quickly build your entire software package. Depending on your application and its dependencies, Docker can help here.
&gt; "idiomatic Go" witch hunts. this. too many tools out there now that suggest petty stylistic concerns. bake them into the compiler as errors if they are really mandated
fair enough, i almost feel like j would be more confusing than i2 since it looks somewhat similar to i. k works, but that could be confusing to a newcomer w/o context of why j was skipped.
Cheating at toy benchmarks: https://play.golang.org/p/fQ7fol2O2l BenchmarkUniques-4 5000000 322 ns/op 240 B/op 1 allocs/op BenchmarkSliceUniq-4 5000000 361 ns/op 0 B/op 0 allocs/op BenchmarkRemoveDuplicates-4 1000000 2012 ns/op 571 B/op 8 allocs/op tho the alloc makes clear the cheat.
I've heard some people say it's bad form to use numbers in a variable name, but I can't remember if it was Go or some other language. Like others said, I mostly use j or k as my secondary iterator var. Plus I'm fresh out of calculus and i2 looked confusing to me for a second.
This free Ultimate Go is a 2-day workshop for any underprivileged intermediate-level developer who has some experience with other programming languages and wants to learn Go. Bill Kennedy is teaching!
I have no idea what I am looking at.
Agreed, and think the question exists to see if the community is inclusive.
The point is that even if it beats it on the small, unless you seriously need the performance, it's better to just use the less efficient algorithm for social reasons - for example your coworker then using that function without understanding the caveats.
thanks for the ansible share. I have documented how I build all of my non go code like nginx and postgresql. I need to automate some of this including upgrading newer versions
Nice work!
ha, good point :P
Yeah, that docstring is what I presumed and more clear. &gt; [...] can be improved or better optimized? I'd avoid premature optimization. Think of use cases you want to address. Test and benchmark them, and if one of those is too slow, optimize. I don't know what all of the cases are you want to address so I can't answer that. I saw you mentioned fuzzy matching in one of the comments. I don't exactly know what your program does exactly but if you need to be correct 100% of the time, then fuzzy matching may not be a good choice. User input is good for fuzzy matching because the user can react with multiple attempts to find something easier than non-fuzzy methods, for example.
https://github.com/Masterminds/glide to solve package management issue. https://github.com/grpc-ecosystem/grpc-gateway to write service api end points 
I'm actually quite sure trans people are overrepresented in the tech community compared to their population as a whole. I'm confident enough to say that there is no other community or bussines field with as many transgenderer people.
The biggest problem I see for Go today is debugging. We have Delve (which is good, don't get me wrong) and I know it's not developed by Google, but I wish Google's Go developers gave it more attention. I have a very strong java background and I miss a lot having expression evaluation during debugging (which is not currently working in all situations). Edit: And in the docs, it would be nice to have a dedicated place for tag documentation, currently it's kinda hard to find information about the tags.
It looks like your match method could have a bug in it, if you have the same bufferstring in expectations (as you just remove one) you could shorten it to // Match checks the buffer string against expected cases, removing from the list when one is found func (s *SilentCmd) Match(bufferString string) (match bool, expectation *Expectation) { for i, e := range s.Expectations { // naive check - thinking about fuzzy matching here but open to ideas. // Maybe just check for the exact length of what's expected? // Don't want to get caught on possible extra white space though. if strings.Contains(bufferString, e.Input) { s.Expectations = append(s.Expectations[:i], s.Expectations[i+1:]...) return true, e } } return false, &amp;Expectation{} } And then what it looks like you're doing is adding the returned e.Output string to the write method once this function is returned, so you can drop the match, and just return a complete string or empty string then check on the presence of that. Also you have a bunch of redundant looking error handling for the handing of adding the Stdinpipe(), etc... functions You can wrap those to a struct and embed the struct. It would clean things up here's a blog post that explains what I'm talking about: https://blog.golang.org/errors-are-values Finally, you can remove the deprecated functions and the NewSilentCmd function as they just clutter the code. It would require more refactoring, but you can move the Stdinpipe(), etc... functions to the struct and that would remove you having to make a separate channel for them and running two extra go routines... because it looks like you could remove the channels and just work with the io.Reader and io.Writer interfaces. (That's just a strong suspicion). All in all this looks like something I would use! 
Also according to what I understood from the Phalcon benchmark/docs, it's not doing HTML escaping by default (while the Go version is doing). Search for "autoescape" the below link. https://docs.phalconphp.com/en/3.0.0/reference/volt.html Edit: He deleted my comment. It seems he's not an *avid learner and a tech perfectionist* after all.
This honestly has nothing to do with go. Proper system design and tooling is important no matter what language you use. So that said, I think what most folks have said still apply.
This is about providing a library that will extend a user-defined type. Your last example is exactly what you're asking for, though. Think about it like this: Any "wrapper" you create will need to define an interface of "core methods" that it needs, so we already know that it's going to look something like this: type CoreORM interface { KeysInDb(keys []string) ([]bool, error) } Now, something has to hold what we pass it, obviously. Closure or struct, take your pick. type ExtendedORM struct { Child CoreORM } Now I suppose what you're missing is the last step, how to allow users to override methods. Well there's two things. First, why do you need to do this? The user can keep a reference to their "ORM" object and query it directly. The only thing I can see that may not be satisfying you is that methods on the ExtendedORM struct won't have access to overridden methods... In your example, the user ORM struct also defines a "KeyInDb" method, so the ExtendedORM struct should use it. This isn't hard to do at all, though. The idea here is to first check if the child has implemented the method and if so, proxy through to it. Otherwise, use the default behaviors. The ExtendedORM's KeyInDb method should just check to see if the child has overridden it. func (o *ExtendedORM) KeyInDb(key string) (bool, error) { if proxy, yes := o.Child.(interface{KeyInDb(string)(bool, error)}); yes { return proxy.KeyInDb(key) } if result, err := o.Child.KeysInDb([]string{key}); err != nil { return false, err } else { return result[0], nil } } Hope this helps. :)
yeah type MyChecker struct { Checker other data } // define any function you want on mychecker including your on KeyInDb let the client use the core take an interface that you need, provide a struct which does what you think it should and let the client compose and embed to create a value which your library requires.