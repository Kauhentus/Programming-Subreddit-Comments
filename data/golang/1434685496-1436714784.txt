This is how politics can ruin a community.
It looks like OP just means the general places that represent a large part of the formal Go community - the Go mailing list, IRC, subreddit, and conferences. This wouldn't apply to other Go subreddits or package maintainers for example unless they choose to adopt them.
I personally had no trouble "getting over it". I've been speaking English since I was a child so I could make the adjustment quickly. For people who aren't native speakers, it might be very discouraging to be labelled sexist when trying to contribute to a project. They would only be speaking how they've been taught and might find it difficult to change. You should remember that being "inclusive" means including people who aren't native English speakers too.
If a respected open source project issues a public reprimand to a person for sexism or racism, how difficult do you think it would be for that person to find a job afterwards? Every prospective employer googles for the candidate's background and when this comes up they're unlikely to want to hire them. In their eyes the person would be a lawsuit just waiting to happen. The person would still find work, but it would be really difficult from that point on. The internet never forgets.
Actually, I find it very hard to write in a gender neutral way, particularly discussing past tense events. Often writing gender neutral is very stilted or strange. Regardless, it's not ok to skewer someone for failing to do so. so... no. you get over it :&lt;
You're still engaging in hypothetical scenarios. Do you have a case in point?
That might look like a good idea on the surface. There is, however, a very disturbing context, and the communities they use for reference (Python/Django) are even worse. Just to give a couple of examples of _problematic_ events that happened around there; I won't get into much details for brevity, there's plenty of stuff on the Net about it. 1) DongleGate - a feminist eavesdropped on the private conversation between two men on PyCon, who were joking about devices with "big dongles" and then talking about 'forking' (repos - not joking already). Claimed she feared for her life, publicly shamed them, one of the guys (a father of three) got fired - for making a dick joke and talking about forking. What's worse, [she still doesn't admit she did anything wrong](https://www.reddit.com/r/Python/comments/2y4yxv/guy_shamed_publicly_at_pycon_loses_job_but_pycon/), and recently ran for PSF board of directors. 2) PronounGate - Alex Gaynor, a PSF director, submits a patch changing _three_ pronouns in node.js code (from 'he' to 'they', to be gender-neutral). That's it, no code changed, no other content. The patch gets rejected by the maintainer (Ben Noordhuis - a Dutch man, so not a native speaker) as insignificant, and also because Gaynor didn't sign necessary contributor agreements, gets overridden by another maintainer, gets reverted again... another huge shitstorm follows, Ben gets harassed, threatened with firing, etc etc etc. Noordhuis (who was _the_ most important contributor to libuv, relevant part of Node) left the project shortly after. It should be noted that Gaynor never contributed anything else to Node either before or after the scandal. Gaynor also supported Richards in DongleGate, BTW. ---------------------- Then there was a huge pile of other scandals not directly related to Python/Django, but still started by far-left/feminists/SJWs, whatever you prefer calling them: meritocracy scandal at GitHub with Julie-Ann Horvath, then another scandal with her again, which resulted in GitHub president and founder resigning (over the row Horvath had with his wife). Then Brendan Eich - a founder of Mozilla and Javascript creator - was harassed and forced to resign for a financial contribution to the "wrong" political cause. There were more scandals, but the point I'm trying to make is - while they claim they want to stop harassment, people behind these CoCs are the ones harassing others, harming their careers and threatening their lives and families (no, really? Getting a father of three fired over a dick joke you eavesdropped on?) So, Python community are not the kind of people one needs to follow on this, I'm afraid. ---------------------- Also, in this thread - people coming out in defense of this, intortus and LackingIsntEmpty, are SRS contributors. Giving SRS people any influence in your community is a terrible idea.
Yeah, I agree that when someone makes a mistake we should be empathic, and especially so when they don't know they made the mistake. However I don't really find how Noordhuis' story fits in with this. As far as I can tell the reason he reverted the commit was not out of misunderstanding, but obstinence. He didn't like the change, so he reverted it multiple times simply because he didn't like it.
Just use they, them, or their instead of he, him, or his. You can also use ey, em, or eir but those are newer constructions. It really just takes a bit of practice and then the mental block goes away, like when people say they don't like Math. If you ever need help rewriting something I'd be glad to help. But yeah, it's not OK to skewer someone for making a mistake, especially if they didn't know because English is not their native language. The skewering of Noordhuis' was a over the top, but he was also being obstinate.
Exactly, if you're familiar with the context, it's not about stopping harassment, but promoting political views: forced diversity, attacks on meritocracy (not in the sense 'this community is not meritocratic', but 'meritocracy is bad'), employment quotas, censoring differing views, etc etc etc. Authoritarian far-left stuff.
Because I refused to stop using "she" in documentation. I've been unhireable ever since. *It could happen to you.*
...and this is the example how people behind CoCs will behave if a problem arises. To the readers, Intortus was removed from Reddit admins a while ago - there were allegations of him abusing his admin powers, but little is known publicly.
Got any examples?
I can contort my expression into all manner of constructed languages, but I absolutely cannot stop using "he".
Yep that's what I meant.
Allegations! Oh dear.
Dealing with the zero value of a generic type is challenging unless you commit to monomorphizing everywhere. I don't think the team will want to go for monomorphized generics solely on that basis though, because that means they'd be committing to a potentially non-ideal system just to get the feature in before 2.0. And then there's the problem of allowing efficient generic code to be written for built-in types. This likely requires some combination of dynamic and static polymorphic code in order to make it efficient and scalable, which severely complicates the design space. You'd probably also need some form of method namespacing to allow for methods on built-in types without cluttering up method sets, which conflicts somewhat with the current ad-hoc approach to interfaces. It's doable, but it's a fairly big feature on its own even without adding generics, and it's not clear that it justifies itself without reference to generics.
So then we should just say "don't be shitty" and leave it at that. Having anything else flies in the face of simplicity, and to me that is the essence of go, is doing things in a simple, and pragmatic way. Not setting up guidelines and policies to babysit adults. We should just lead by example, and not be shitty, and I feel that is already happening. Just because we haven't had drama like Node, Python, or a Zed Shaw rant yet, does not mean we will. There is an old saying, "if you stare at the tree while driving down the road, and not look at the road, you will drive into the tree" (crashing the car). Don't borrow trouble where there is none. I suppose next there is going to be a mob of people telling me that even saying there isn't a problem is a huge problem. To that, I say, that is harassment, where is the form that I can fill out complaining? Lets worry about programming, and not be shitty to each other.
At a basic level, we provide official forums like this subreddit in which to discuss Go. Because of this we have a responsibility for what goes on in those forums.
That's great. Btw, you and the rest of the Go team have been doing a great job of improving the language. I also think having you, bradfitz and rsc engage with the community on reddit and HN also does a world of good to improve the general perception of Go. Thanks for both :)
That makes sense and I think thats diligent. I just would hope to avoid that being some prominent thing that becomes a huge deal. These discussions about these things get out of hand. One github issue recently got hundreds and hundreds of comments and is still going discussing a code of conduct. It's a touchy subject and its arguable whether having one will make go better or worse: you simply can't make everyone happy. My advise is if you have one, the more simple and vague it is, is the better, you only need it when you want to point someone at an official reason for why they are out of line. 
here is a trailhead to follow: https://github.com/opal/opal/issues/941 this is why its a slippery slope. your friends impression was the go-nuts mailing list was negative, so you think that guidelines would help this? browsing through the last couple months there is nothing that stands out to me. I saw one post referenced about some language mis-communication, but nothing else. It does seem like we are worrying about a problem that does not exist or when it does we have enough adults around to resolve. Your friend does sound pretty sensitive. I'm curious what specifically they found negative about go-nuts? It seems like an extremely helpful and adult crowd to me.
Ben's initial words on the gender change commit - "Sorry, not interested in trivial changes like that." ([link](https://github.com/joyent/libuv/pull/1015)). Please understand that for people not from the Bay Area, English is the same as it has been for the last few centuries, ie, using a gendered pronoun is perfectly correct. Perhaps you don't know many people who speak English as a second or third language, but I do. They learn the language by watching TV shows, reading novels and from their textbooks. All of these sources, as well as their teachers tell them that a certain way is correct. Now suddenly people tell them in a super hostile manner that not only are they wrong (when they aren't) but they are "soooo sexist". Is it easy to understand why they go on the defensive and stick to their guns? After all, OED and Strunk &amp; White are on their side. In their eyes, these sources have higher weight than SJWs from the Bay Area. I appreciate that you would like to see more inclusiveness in our industry. However that shouldn't start and end with women. Comments that ask people who aren't native English speakers to "get over it" or leave the community do more damage than good.
&gt; Then Brendan Eich - a founder of Mozilla and Javascript creator - was harassed and forced to resign for a financial contribution to the "wrong" political cause Was funding a campaign to take away the right to marry. Yes let's fund a campaign to take away your rights. see how much you like it. Mozilla employees were uncomfortable with him taking over the CEO role. the public face of the organisation. I wonder if their fear that someone who had already made a public stand that taking away basic rights from people he finds icky would some how impact how he had to stand on company policies or issues.
I believe that best way to learn something is to make something. For instance, I took a pdf server generator which we use in our company (written in NodeJs) and started rewriting it in Go. I used Martini framework for http api and gofpdf for creating pdfs. Beside that, I started doing a bunch of algorithm tasks on hackerrank.com in Go. 
This is awesome. Do somebody have the link of the app ?
veteran in other languages. I'm looking for stuff which which makes the experience better. GoSublime, GoVim, GoLint are some examples which makes it better.
For the editor I would suggest using Sublime Text with the GoSublime plugin. Here are the [installation instructions](http://blog.campoy.cat/2013/12/integrating-goimports-with-gosublime-on.html). As far as I know, the vast majority of Go programmers use text editors like Sublime, vim or emacs rather than IDEs. You can still check out Intellij IDEA with the Go plugin if you really want an IDE. I second the suggestion by someone else in the thread that you should start with a project (though not with his endorsement of Martini). That's the best way to learn, I feel. One project that I recently did was a link shortener using redis. I used only the standard library and a [redis library](https://github.com/garyburd/redigo). It was short, fun and useful. If you decide to try this out, we can compare implementations later :)
&gt; Now the "correct" way is to intersperse "he" and "she" liberally, or not to use pronouns at all (like I have in this paragraph) The correct way to refer to a person unknown to the author is "they" and has been for hundreds of years. Strunk and White be damned!
My advice. Whenever needing to Marshall anything, structures are your friend. Especially with bson and json. Bu I am still a noob.
Remarkably, some people expect adult behavior in a professional environment. That usually includes no dick jokes.
They who believes that is right, whomever they is.
Singular person**s**. English is a funny old game.
I'm horrified at some of the comments posted here. It is clear to me this code of conduct proposal is overdue, by six years. It should have been in place from day one.
You don't call somebody out for that in the public. That's bad style. You tell the person directly (she didn't) and if you feel uncomfortable you speak to the event management. You always have the option to go elsewhere, nobody is forcing you to listen to stupid dick jokes. You could also decide to not be offended by stupid dick jokes. Come on; is there anything you are not offended by?
Not to mention the recent Kubuntu drama. http://www.omgubuntu.co.uk/2015/05/kubuntu-project-lead-asked-to-step-down-by-ubuntu-community-council. A CoC is just a clever way to control the community and remove strong opinions.
I've seen some people argue that doesn't go far enough and that 'she' should almost exclusively be used instead of 'they' or 'he'.
I don't want to go to that kind of tech conference.
People tend to follow statements with supporting facts. Can you please explain? I attend DefCon most years and I would hardly place that in the professional realm. It's all relative which makes it impossible to debate in any reasonable fashion.
A lynch mob in action: https://github.com/opal/opal/issues/941 As soon as you introduce politics into a technology project, you make that project all about politics and not about technology. Whatever I say, publicly that has nothing to do with go shouldn't impact my ability to use,write or contribute to the go project if I did not say that in the go project context (a discussion in a issue tracker, on a go official forum or a commit comment). The world isn't the silicon valley and yes , people all over the world have different view on a wide range of issues. I should not have to care whether someone I interact with is white, black, male,female,"cisgender", trans, progressive or conservative, muslim or atheist , I'm talking to people from programmer to programmer , not from identity A to identity B. While i'm not going to make "dick jokes" in a issue tracker or /r/golang , I should be free to do so on /r/dickjokes or on twitter without the "inquisition" watching.
From [MW](http://www.merriam-webster.com/dictionary/professional) definition 1.c: "(1) : characterized by or conforming to the technical or ethical standards of a profession (2) : exhibiting a courteous, conscientious, and generally businesslike manner in the workplace".
What you say is the important point many people seem to miss. Stop introducing politics to software projects. They are not about politics and I would still use ReiserFS even though Mr. Reiser murdered his wife.
Correct. It's all relative. If i attend the conference as a individual then my personal ethics and standards are applicable. If I attend with co-works and it's being paid for by X then the situation is different. 
Agree, I only meant if they pay for it. Edit: important to also be aware of employee contracts and the language of said contracts/agreements. 
She wasn't fired for being bad at her job, she was fired because the internet DDoSed her place of work. Pure extortion.
Do we really want the future of the internet (and therefore all of humanity) to be designed by bigots?
Perl IRC's [Code of Conduct](http://www.irc.perl.org/rules.html)'s Community Principles rocks [Reasonable Person Principle](http://www.irc.perl.org/reasonable_person.html) well, as one possible definition for what not being shitty is like. H/T [@kragen](https://twitter.com/kragen/status/611770392802402304)
Point taken. I agree with these ideas. I would, however, be disappointed if the people I meet were not courteous and conscientious and could not conduct themselves appropriate to a public setting. Let's not pretend that this is not a public community.
Yes. Regulate behavior. Cause, without rules covering all the perceived missteps one may make along the way, we wouldn't be where we are today. Free of all injustices.
I want the future of the internet to be decided by people who are allowed to have their own weird opinions. People tend to have questionable views in some fields. That does not make them unsuitable to work in completely unrelated fields. What you need to learn is the ability to separate the political opinions of a person from his participation in open source projects.
&gt; While it's not okay to harrass someone for any reason at all Agreed. &gt; you should really be prepared for some backlash Nothing wrong with a few angry tweets in response. But as we've established, this was harassment. &gt; when you destroy a persons life over a stupid dick joke. And how did she do that? She just publicly shamed somebody on Twitter. That's not ruining somebody's life. If anybody's to blame for these guys getting fired it's their employer.
Great attitude. This would make a good policy.
That's a good way to alienate contributors, which is good for artificially inflating your salary, but bad for software and humanity in general.
There's a world of difference between an "opinion" and financing a discriminatory political campaign. An internet built by bigots does not serve humanity, it serves the majority.
&gt; There are thousands of us, and we see no reason why minorities should be excluded. Who's excluding minorities? The project leader with weird political opinions who keeps his opinions out of the project or you who tries to throw people out of a project because of their political opinion? Because it's you who's discriminating. You are the perpetrator and the bigot is the victim who's getting kicked out because of his opinion. Strange twisted world, isn't it? &gt; If you don't have a code of conduct, then minorities don't participate, regardless of merit. That's a bug that needs to be corrected. If you can't participate in a project where people have opinions that conflict with yours, especially when these opinions are kept out of the project, then you should probably try to raise your own tolerance level. There are always going to be people with ideas you don't like and running away from such ideas is not going to get you anywhere. Again: I don't care about your opinions and you shouldn't care about mine. Just let us write software. Together.
I added SSN
I still don't see how this reflects my on him being ESL. He clearly understands what's being said if he calls the issue academic and felt the issue large enough to reverse twice. If it was trivial, which it is, he would have let the change pass - he even says himself that he shouldn't have overridden Isaac. Both my parents are ESL and most of the people I grew up around are ESL. One of my good friends now is ESL - I don't beat him up on pronunciation and he also doesn't dismiss concepts of gender as trivial. I also think Joyent's response was over the top and the StrongLoop response of being empathic and taking the time for private discussion to be much more properly measured. I don't want to see the Go community get into ridiculous rows like that and I think that the proposed guidelines will help prevent that. Going over the Django guidelines, they mostly emphasize being calm, collected, empathic, and helpful, and not vitriol infused like the whole Noordhuis fiasco. I think had guidelines been in place it would have given Noordhuis direction and clarity, and the tempered his critics. Let's face it, it's not just SJWs who are known for throwing shitfits - techies pioneered that into an ideal and guidelines like these should help keep calm on all sides and let us focus on the code inclusively.
Because sexism don't real and feminazi SJWs are taking away our freedom of speech!
Thank you for your comment, I shall address the points individually. &gt; For example, when hiring, I am very interested in feedback from people who did not accept an offer. If I only ask people who already work in a company what they think of the interview process, I'll wind up with an echo chamber. One important difference is that when you want to hire someone, it's you (the company) who wants something from someone else. If you want something from someone else you might want to listen to the demands of that other person. After all, interviews are all about reaching an agreement suitable for both employer and employee. &gt; And of course you should filter "random" feature requests, but every successful company pays attention to people who aren't using their product. They are, after all, the market for the product. That's why I specifically said “random” feature request. Reading my comment again, it's easy to understand. I think Joel Spolsky gives a good [summary](http://blog.codinghorror.com/listen-to-your-community-but-dont-let-them-tell-you-what-to-do/) about what to do with user feedback and wishes. Another thing is that I'm often not marketing my project. One of my personal rules for projects I participate in in my free time is that the project is my personal enjoyment. If someone else wants to use it, that's fine. If someone else makes specific demands, he should better pay me. Why should I be interested in marketing? I don't get pleasure from having a large influx of people who use the project because of hearsay and not because they actually determined that it's good. &gt; If you only ask contributors what they think of your code of conduct, and you only ask users what they want in the product, and you only ask employees how to hire, you are going to quickly find a local maxima. That's correct as well, the post I linked above addresses this, too. You should always *listen* to feedback from the outside but it shouldn't dominate your project and while you should incorporate such feedback, it shouldn't decide how your project is moving forward. &gt; If you want to do better, you have to find a way to filter out the noise but still incorporate the views of people who aren't contributing. One thing I found to have a significant effect on feedback quality is to ignore people whose critique is one of these: * Your project is bad because it's not like *other project* * Your project is bad because *person* participates, remove *person* * Your project is bad because I used it for the first time today and didn't understand how it works immediately. I don't plan to read any documentation either. &gt; Either that, or just hang a sign that says, "Private club, we don't need anyone else, we're already smart enough for our purposes." Which might be true, you might personally be perfectly happy with the culture you already have and don't really want anyone else to get involved unless they are homogeneous with the existing people. Hanging up such a sign can have a very positive effect on project quality. A project where all participants think alike is a project with effective development that isn't getting stuck in pointless debates and bike-shedding all the time. A good portion of respect between project members helps, too.
There's another reddit programming community with a code of conduct stuck to the top of their reddit. It immediately cast a negative light on that community for me not because equality and fair treatment aren't good ideas but because many (basically overzealous SJW's) twist what it means to be fair and equal. The whole thing is a sliding scale. Anyone can find anything offensive and decide that something else they don't want to find offensive isn't. I've been through many race and gender discussions with SJW's where you get into twisted logic like "yes you're a minority but not a woman so your view of what's offensive is irrelevant." Next person comes along and because they aren't a minority and I am their opinion is irrelevant compared to mine. Then what happens when you go global and the people involved have no understanding of who is and isn't a minority in some context. Not saying that this is the intent at all of those wanting to create a code of conduct but this is where it inevitably ends up. I think though there is good intent its really just inviting an extremist war into the community that will end up being offensive to someone no matter how you slice it. And some community leader will seek to ban people finding application of the code of conduct offensive because they don't see things the same way and off starts the cycle.
&gt; weird political opinions I'll go along with you when it comes to "weird" political opinions. For example, a belief in proportional representation is weird by North American standards. But some opinions are not just weird. And not just a difference of opinion. And in fact, they go beyond the merely political. For example, the young man who wanted to start a race war by murdering nine people. That kind of belief, that we need a race war, and a separate homeland for different races, is not "weird" to some people. Perhaps to you it is only a "ha ha, isn't that person strange when they aren't coding." But hopefully you and I can agree that some things are just weird, and some things are far beyond weird. And for those things that are just weird, I agree with you. I may disagree with your weirdness, but it should not affect our ability to write software together.
&gt;https://github.com/opal/opal/issues/941 oh my god. &gt;You're failing at it: right now, as a queer woman, I do not believe Opal would treat any contributions I might make fairly. I do not believe that I would be welcomed onto the project. I want to see that pull request. "PR #968, Fixed missing keyword in Template and it is FABULOUS." "PR rejected. too queer."
A "questionable political opinion" is something like "there should be a flat tax." Outright discrimination goes way beyond politics: it's bigotry. Bigotry is antithetical to humanism, and open source development is a humanist endeavor. Bigots alienate minorities. Bigots build products that don't serve minorities. Bigots lead projects that exclude minorities. It just makes no sense to coddle bigots. 
&gt; But some opinions are not just weird. And not just a difference of opinion. And in fact, they go beyond the merely political. For example, the young man who wanted to start a race war by murdering nine people. There is of course no unconditional acceptance of weird opinion just as there is no unconditional love. We should try to be as open as possible to other people's opinions, especially when they never (physically) hurt anyone with their opinion or when they keep these out of the project. Some questions are hard to answer, like the question if I wanted to write software with that person. If I didn't knew what he did, I would probably do so. If I did, I might make a different decision but I'm not sure either, especially since knowing that this man went on a killing streak might severely change the way I interact with him. &gt; But hopefully you and I can agree that some things are just weird, and some things are far beyond weird. And for those things that are just weird, I agree with you. I may disagree with your weirdness, but it should not affect our ability to write software together. Thank you.
&gt; while you should incorporate such feedback, it shouldn't decide how your project is moving forward. We agree on this. I would, for example, pay close attention to feedback about whether my blog comes across in a sexist manner. I would listen to, but likely ignore, suggestions that I start writing about PHP. At the end of the day, deciders have to decide. &gt; Hanging up such a sign can have a very positive effect on project quality. A project where all participants think alike is a project with effective development that isn't getting stuck in pointless debates and bike-shedding all the time. I think there are both moral and economic arguments against the point of view that all participants in a project should think alike, but I doubt there is space here to debate them.
Django ist totally racist! Me as a transgendered homo lesbian is offended. Django is so macho, change it immideatly, or i will call you all nazi!! Better call it durango! No, more better call it Shemango! Not good enough - call it X Gendered Person carried by six nubian slaves! Yes, that sounds good - make it so or i will be offended once more. 
Who gets to decide what opinion is questionable and what is discrimination? A flat tax proposal is discrimination against the lower and middle class; is it bigotry as well? &gt; Bigots build products that don't serve minorities. All the projects I've bigots seen build (like opal) don't particularly care if you are a majority. It's not that there's a text box saying ”YOU CAN NOT USE THIS IF YOU ARE GAY!!!” And on the other hand, why does the project has to specifically serve minorities? Why does the minority deserve being specifically catered towards? &gt; Bigots alienate minorities. (...) Bigots lead projects that exclude minorities. How? Because the member of a minority is scared of working in that project? Please, show me a single significant project where a bigot leader threw out someone because of his sexual oriented, religion or whatever it is he discriminates against. &gt; It just makes no sense to coddle bigots. I don't want to coddle anyone. I just don't care what thoughts you have, just as I don't care what's between your legs or what colour your skin is. The internet has this great property that I don't *need* to make sure I don't care because I never get to see that information either.
If you're serious about it, you can do a lot better using pcmpistri (SSE 4.2 instruction).
&gt; A flat tax proposal is discrimination against the lower and middle class; is it bigotry as well? Perhaps. Wouldn't it be a tragedy if the open source community excluded the lower and middle class? Wouldn't something important be lost? What sort of difference would you see in the software, and the features it offers? &gt; Because the member of a minority is scared of working in that project? Countless people have spoken up and stated that a code or conduct makes or breaks their will to participate. It's not simply a matter of a leader banishing someone they don't like. It boils down to this: if you participate (i.e., on a mailing list, or pull request, or whatever), and someone attacks, denigrates, or dismisses you because of who you are, will that community have your back? When you adamantly refuse to take on even a modest *aspirational* policy (that's under a page long and is just a weak commitment to basic human values), you send a firm negative message to anyone who isn't comfortably a member of the in-group. Believe whatever you like about politics, but this homogeneity demonstrably harms the software and the process.
&gt; It's not simply a matter of a leader banishing someone they don't like. It boils down to this: if you participate (i.e., on a mailing list, or pull request, or whatever), and someone attacks, denigrates, or dismisses you because of who you are, will that community have your back? Again, I'm not protecting people who discriminate others in a project. If a project leader was to remove people from a project because of who they are, that's not okay. If his opinion is that they should be who they are but keeps these thoughts out of the project, that's perfectly fine. I don't want a thought police. &gt; When you adamantly refuse to take on even a modest aspirational policy (that's under a page long and is just a weak commitment to basic human values), you send a firm negative message to anyone who isn't comfortably a member of the in-group. Believe whatever you like about politics, but this homogeneity demonstrably harms the software and the process. Where in any of my comments did I argue for or against the policy to be introduced by the Go project? It is true though that I have problems with many code-of-conduct policies because they offer loopholes to have arbitrary people removed because you feel offended for some bullshit reason. That's what I don't want.
The expectations outlined in the Django code of conduct look very reasonable and what I would expect from such forums. Rather then the first step be to report the behavior, I think the first step should be to reach out to the offender for clarification in most circumstances. One thing that may be missing from the CoC are limiters: * it is to be applied to go forums, * public shaming is not respectful, * following a CoC makes a person easier to get along with but policing people does NOT make you better or more right, * give people the benefit of the doubt when possible (see "respect"), * taking people out of context is not respectful, * small issues should be responded in small ways, * intent is important (see "give people the benefit of the doubt"), * different culture must not be a scapegoat, but culture should be taken into account when understanding intent, We live in a big world; we can always learn more. 
Indeed, the len(s) should be done in the compiler. If there isn't an existing bug report, file one. Also, your graph is slightly dishonest. Start your axis on zero please.
Don't know if someone missed the possible sarcasm in your comment but this is exactly what happens when you start down this path of a code of conduct.
You are doing a fantastic job demonstrating why this sort of thing is so worrisome... either you agree with the code of conduct in toto, or you are a bigot. Implicitly, there's no third alternative. It's bigotry itself. No, I don't mean that as a joke, or to be funny, or to rhetorically score a point. I'm saying, you're being bigoted, full stop. Off of one small data point you feel you can judge the moral worth of people. It is the same thing as racism or sexism, the same brain structures, the same cognitive shortcuts, the same danger to a community, just a different target that happens to be approved by your social circle. And I agree with the others... this sort of code of conduct is designed to be impossible to disagree with without being treated as a bigot, but ultimately it encodes its own form of sanctioned bigotry into the community. You want a code of conduct? "Do unto others as you would have them do unto you." Do _you_ enjoy it when others come to you and insist that you must have certain beliefs? No, you don't. Of course you don't. Here you are doing to others, though.
I don't think you understand what that word means, nor did you comprehend whom I was applying that term to.
You don't have to leave the conference to escape a private conversation about dick jokes. You could move a meter to the left and just like that you don't hear the conversation any more. It's that simple. &gt; Is it really too much to ask to be more respectful and conscious in a professional environment so other people don't feel like they're walking in the wrong club? I knew nothing of the DongleGate until now, so I'm not being specific about that, but as a general rule I'd hate to be the one who drove someone off of programming because they didn't feel they belong, when everybody knows that it's a problem. As I said elsewhere, I don't really [consider a conference a professional environment](http://www.reddit.com/r/golang/comments/3abyva/a_code_of_conduct_for_the_go_community/csbw6k3). I think most tech conferences are a good mix of community meet-up and interesting talks. While there probably are “business conferences” where you get weird looks if you don't wear shirt and tie, that's not the situation was. Lastly, I don't feel comfortable in a place where I can't make a silly (dick) joke with a friend for the fear of being witch-hunted by someone who feels offended by our private conversation. That's a really toxic atmosphere. It's okay though if someone tells me to stop making these jokes, I would probably stop unless that person is being a huge dick (hehe) to me.
Testify is an assertion framework. This is just a collection of helpers to generate helpful error messages with whatever framework you wish. I personally use vanilla go tests with the goconvey web UI. I found myself repeating the same pattern and decided to make a library of it. There are no assert or logic methods in this library, that is up to you. It only helps you format sane messages. 
[Image](http://imgs.xkcd.com/comics/slippery_slope.png) **Title:** Slippery Slope **Title-text:** Sure, taking a few seconds to be respectful toward someone about something they care about doesn't sound hard. But if you talk to hundreds of people every day and they all start expecting that same consideration, it could potentially add up to MINUTES wasted. And for WHAT? [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/1332#Explanation) **Stats:** This comic has been referenced 48 times, representing 0.0699% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_csc1yrz)
While all the other comments are correct about compiler misses and costing of the len function I would like to commend the OP. I think it is awesome that you are learning and went to the source then wondered if changing something might make it faster. So you tried it. Awesome job. Keep up your curiosity.
Amen. Its worth noting that in the cases of Gaynor and Eich, the opponents considered the outcome a victory. If Go embraces this, it will be forked.
If that's the case, then the two are wrong in what they did. Yet, her reaction is disproportionate.
I don't know if anyone else noticed it, but `if s == "" { ... }` is faster than `if len(s) == 0 { ... }`.
Also, the top comment has "exposed" me as someone who occasionally posts in SRS subreddits. The horror!
/r/shitredditsays and the related subs. They're feminist spaces. Generally loathed across the rest of reddit.
I wonder if adding a second switch for cases using m below the first switch and only initializing m after this first switch would be better? That way you could avoid the allocation for cases of n == 0 and n == 1
Test: are posters from Israeli settlements bigots? They relocated Palestinians off of their property by force. The Palestinians were evacuated based on their political and religious affiliations as well as their national origin. Will you disallow posts from these settlements? If not, why not? It is almost too easy to box people in on a CoC...in the end, you are just another person passing judgement
So I did this for myself, because knowing what's in a big and intricate value, such as Go ASTs, can get difficult. I'm sharing it in case it comes handy for someone else too.
could you give an example
'Wow, more censorship? Luckily I'm just barely into Go, so I'll just quit and learn another language with a community that doesn't forcefully censor people. Fuck "social justice" and fuck this internet. ' Circle jerker or brogrammer? You decide! 
A link to the discussion would help: https://groups.google.com/forum/#!msg/golang-nuts/sy-YcVPADjg/bcO6LAr29EIJ
I'll just quote @erisdev from the thread: &gt; we're an angry lynch mob now. cool. way to compare *a bunch of queers who are upset about the way you handled an issue to the systematic and brutal public murder of black people*. keep it classy, kid.
This is interesting because in the Opal fiasco, the person whose views were considered objectionable had not expressed them in any forum directly related to the project. He was being held accountable for tweets. Hopefully the Go community will not scour the internet for objectionable views.
Agreed that the Django thing doesn't bring up race. However, it reads like it was written for adolescent children. I don't need a baby sitter, or to be told not to be mean to people. All of these discussions are tiring and make me scared to even ask a question to the communities that adopt these codes. What if i say "him" and not "they", or something. I don't want to have to be careful beyond how I am being now. I don't have time. Thats why I got into golang in the first place. Its simple, it saves me time. It starts up quick. If i wanted endless bureaucratic process I would go back to java. I'm sure all we have to do is find the right abstraction or factory somewhere. 
I think this is more about the symbolic meaning of forcing a community to "sign" a CoC. It can also be used as a means of control. A CoC has a lot of implications you are ignoring or haven't thought of yet. https://skitterman.wordpress.com/2015/05/26/information-exchange-between-the-ubuntu-community-council-and-the-kubuntu-council/ Please examine the above link for an example of bullying using a CoC.
I hate to derail your comment (which already abandoned the scope of /r/golang), but this is absolutely false &gt; For example, both Mormons and Orthodox Jews accept as a basic doctrine that women are by definition secondary authorities in family life. and I must stand for it. I can't speak for Orthodox Jews, but I know Mormons don't define women as "secondary authorities" in family life or their religion. You should study [this talk by Gordon Hinckley](https://www.lds.org/general-conference/2004/10/the-women-in-our-lives). A man in the Mormon church who thinks of his wife as "secondary" endangers his family, marriage, and his personal worthiness to Priesthood duties. So I just wanted to clarify what you said because it is anything but a trivial example. (Even beside your example, the thought is a little extreme in my opinion.)
Definitely agree. It's a tricky thing to solve so this part is just my opinion but unless the maintainer brings that attitude to the repo and discriminates against trans people regardless of the merit of their work then they aren't able to be as good as a maintainer as they should be and if they can't do the job because they let their political ideas get in the way then it's reasonable to see about replacing them if possible.
The proposed real world benefits of a CoC outweigh any "symbolic" objection to it. Yeah I haven't seen that example before and a CoC is definitely not a perfect solution but it's a better solution imo
It's written so that anyone can understand it. The Django CoC is not intentionally setting out to insult anyone's intelligence. And you may not need a baby sitter but if everyone was behaving perfectly then there wouldn't be a reason to adopt the CoC. Can't answer your hypothetical but if you are concerned about things like that I think you should bring it up. It's hard to figure out where to draw the line in the sand but you may as well see what people say
Yea, that whole thing's a mess. I deeply support LGBT but that was very hypocritical. That same crap was used by bigots to justify not hiring gay physical education teachers. Everyone has the right to be themselves and think what they want. We all just need to stop bullying people into our belief systems.
Adding... To be fair, after running the benchmark many more times and for longer, the "optimized" code does, sometimes, return faster results. I've updated the gist with an example of that. Nonetheless, the difference is minuscule, inconsistent and, in my opinion, not worth addressing.
Correct, that is your opinion but not mine. Why is one better than the other? Why do I have to abandon my moral fiber for you and to be part of this awesome community?
Ah, I misunderstood sorry if that was bold. I think he has good intentions but it's just not necessary. https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/CodeOfConflict?id=ddbd2b7ad99a418c60397901a0f3c997d030c65e I would be ok with this.
&gt; The most damaging unintended consequence may be a chilling effect on expression in formal and -- more critically -- informal communications within the community. I'll quote Wheaton's law: "don't be a dick." As long as you stick to that and maintain a professional conduct, like in a proper job, you won't have any problems. If you think to need to engage in hate speech, sexism, racism, or similar, then the Go community is not the place for that. After all, free speech means you're free to speak, but it doesn't include the right to be heard by everyone. If you deviate from the topic of the Go community, which is Go, chances are high people aren't interested in receiving your speech in the first place. You're always free to speak out somewhere else, in more appropriate forums. Just by this fact alone it is clear that a CoC can never possibly have a chilling effect on free speech.
No problem :) Yeah we're both on the same "side" it's just a matter of how far we should go. This is why a discussion about this is important. Better to point out other ways of accomplishing the same goal and maybe influence the process instead of flat out being opposed because you have slightly different ideals. I think you should post that maybe a simpler CoC should be adopted and post that link.
Agree 100% with everything you said. I created a new post http://www.reddit.com/r/golang/comments/3afyep/be_excellent_to_each_other_lets_use_the_kernel_coc/ to get a conversation started. I think your right, short and to the point could get both sides of the debate onboard.
yes, this is the longest acceptable solution. once you add more than this, it just goes downhill. i imagine there will still be people on both sides. people that want more details, more clarity, want us to iterate every gender, race, culture that we accept, etc. I'm sure there will be people that probably still want nothing. This is vague, and designed to not get in the way of discussions, and asks people to grow tough skin, which is needed. Not everyone has time or patience to hold people's hands.
no, and I have no idea why you think this based on what I wrote. 
I've never done it, but it's possible: http://golang.org/cmd/go/#hdr-Remote_import_paths
I don't see any reference to private repositories :/
&gt; You want a code of conduct? "Do unto others as you would have them do unto you." Do you enjoy it when others come to you and insist that you must have certain beliefs? No, you don't. Of course you don't. Here you are doing to others, though. What about masochists?
More details is not necessarily wrong. Its boring to create and read, but if planned correctly it should protect you, in the end, against any abuse using this document. Creating it correctly is different topic entirely, tho.
I don't know about this. Linux kernel mail-list can be harsh even without Linus. And with him - IIRC there was minor scandal when Linus said to some female developer that she isn't good at writing software (not because she is female, but because she is bad developer). I don't remember the details, but somehow developer sex got involved, and it got weird.
Which is exactly why you should moderate your speech with a COC.
Let's say you start a new business - would you wait until there were abuse before writing guidelines? Anyway, according to Andrew Gerrand, there is abuse, albeit rare.
You're misconstruing the purpose of a code of conduct.
At no point did I insinuate, imply, or outright state that there is a code of conduct. I am well aware that there is no code of conduct, and that this entire discussion is on if one should or shouldn't exist. Beyond that, I still think you're misconstruing the purpose of a code of conduct. The purpose is to codify the rules of a community and how members of that community act towards each other in public forums. A good code of conduct would also give people a place to air their grievances and hopefully find some form of resolution. I simply can't understand why people are so adamantly opposed to the creation and adoption of a code of conduct. Yes, a poorly written code of conduct could be abused, but that's why it should go through a discussion phase where people can express dissatisfaction with certain points, and express how and why those points should be changed or removed for the betterment of the community. Additionally, should, following the adoption of a code of conduct, it end up being abused, the community should address that. Just taking pot shots at the entire concept of a code of conduct instead of expressing why you don't like it on principle, and suggesting how one could be written to keep the potential problems you see to a minimum doesn't help anyone, and solidifies you as a stick in the mud who would rather kvetch about the fact that people want to make the community better, rather than providing your own view on how one could make the community better.
I encourage you to go read my other replies throughout the three posts on /r/golang on this topic. I explain my position and even put-forth my recommendations for a CoC. I am not going to rewrite my position here solely for your benefit although I'm sure you're an awesome person. It's just more of a bandwidth thing.
Here's your code at a play.golang link: https://play.golang.org/p/wXWIerOIg- (It's a little easier to share Go code this way, as it allows people to run it and see how it works in the browser). I generally prefer putting putting more work into the `for` statement, so I might do something like this: https://play.golang.org/p/CSBz_1jGP- Also, I should probably point out that the new slices simply point at the underlying array for the input slice. This is cool for performance reasons, but also means the input &amp; output are pointing to the same data, and a change to one will affect the other. Depending on your needs, this might be bad, irrelevant, or desired behavior. If it's undesired, you can use the `copy()` built-in. Overall, pretty good and not very different from how I'd write it. :)
That's fair, but you're also taking pot shots, which doesn't help anything. Also, going through your post history, you really haven't done anything more than take pot shots at the idea of a code of conduct besides proposing adopting something similar to the Linux Kernel's Code of Conflict. Yes, you've pointed out it can be abused, but almost always while also being overly dismissive of the concept of a code of conduct. Yes, I think adopting something like the Linux Kernel's Code of Conflict is a great idea, because at its essence it says "don't be a dick, and if you think someone is being a dick email these guys". But you could've proposed that and not made disparaging remarks about codes of conduct at the same time.
Behind the firewall works good, but I was hoping for a way for *go get* to install dependencies from my personal private repository, right now I use a bash script #!/bin/bash git clone http://$1 $GOPATH/src/$1 But it doesn't help much when i need to run *go get* to download a bunch of private repositories... I'll have to try the ssh + private key method you just mentioned.
With all do respect how I explain my views and conduct myself is my own business. I appreciate your interest but if you don't understand my position there isn't much much I can do for you. It's clear to me and others with similar views. Maybe re-read them with a more open mind? Anyway, take care.
&gt; Any interactions outside of members of the community interacting with each other in public are not governed or held to the code of conduct. Except Django CoC (that conversation starter used as a reference) explicitly states otherwise: &gt; [In addition, violations](https://www.djangoproject.com/conduct/) of this code outside these spaces may affect a person's ability to participate within them. So, yes, they (EDIT - Django team. I hope Go team would be more sane.) want to censor and punish you for saying and doing things they don't like _anywhere_. On Twitter (tons of examples). In personal conversation overheard by someone (Donglegate). As Eich's example shows, even actions taken many years prior... everything and anything would count.
I just started getting into golang a few weeks ago, and this whole code of conduct thing had made me reconsider and just go learn Haskell. It's condescending and insulting. I swear all of tech has turned into a kindergarten. What new language are the adults using?
What nonsense? Politics is politics and work is work. There is no need to mix these two.
I'm using godep (github.com/tools/godep) for a while now and it does the jov for me. Also a search either here or on the mailing list would help you find other threads just like this. 
If the code of conduct is your reason for choosing haskell over go, then I'd suggest you rethink your priorities. Sure, the community around the language is an important consideration, but please make technical decisions on technical merit. There are lots of good reasons to choose haskell over go (and visa versa), but the existence of a code of conduct shouldn't be anywhere near the top of that list. A CoC won't magically change the go community into a child/nanny dynamic. Thay said, go is unapologetically opinionated, and the community generally likes that about the language. If you think the go maintainers aren't treating you like an adult because of a generic CoC, then you really aren't gonna like how the language/compiler treats you.
&gt;“Have you ever had an altercation at school and you could feel the hairs rise up on your back?” she asked me. &gt;“You felt fear?” I asked. &gt;“Danger,” she said. “Clearly my body was telling me, ‘You are unsafe.’” &gt;Which was why, she said, even though she’d never before complained about sexual harassment, she “slowly stood up, rotated from my hips, and took three photos”. She tweeted one, “with a very brief summary of what they said. Then I sent another tweet describing my location. Right? And then the third tweet was the [conference’s] code of conduct.” &gt;“You talked about danger,” I said. “What were you imagining might…?” &gt;“Have you ever heard that thing, men are afraid that women will laugh at them and women are afraid that men will kill them?” she replied. “So. Yeah.” &gt;'He’s a white male,' Adria said. 'I’m a black Jewish female. He said things that could be inferred as offensive to me' I told Adria that people might consider that an overblown thing to say. She had, after all, been at a tech conference with 2,000 bystanders. &gt;“Sure,” she replied. “And those people would probably be white and they would probably be male.” &gt;“Somebody getting fired is pretty bad,” I said. “I know you didn’t call for him to be fired, but you must have felt pretty bad.” &gt;“Not too bad,” she said. She thought more and shook her head decisively. “He’s a white male. I’m a black Jewish female. He was saying things that could be inferred as offensive to me, sitting in front of him. I do have empathy for him, but it only goes so far. If he had Down’s syndrome and he accidently pushed someone off a subway, that would be different… I’ve seen things where people are like, ‘Adria didn’t know what she was doing by tweeting it.’ Yes, I did.” She wasn't sorry that she wrecked someone's career over this. Also what the hell is up with her down's example, are these two really comparable? Though of course if you think it's okay to ruin someone's life over a quick, non offensive joke then I don't really know what to say.
@mephux, I don't see how the above (lengthy!) article could be considered as bullying using a CoC. From what I read, the CoC was blatantly disregarded by the bullies, meaning that it wasn't used, but was rather circumvented entirely. So you can't blame the above misdeeds of Canonical upon the use of a CoC, unless I'm misreading some pertinent detail.
There are lot of options, but from my experience [godep](https://github.com/tools/godep) and [gb](http://getgb.io/) are probably the two standouts. Go itself will have some limited capability to build from vendored dependencies with the `-vendor` flag in (probably) 1.5 but there is no standardised manifest for tracking versions. This is partly because Go packages don't have their own concept of a version; only the VCS the package is in does.
&gt;“Have you ever had an altercation at school and you could feel the hairs rise up on your back?” she asked me. &gt;“You felt fear?” I asked. &gt;“Danger,” she said. “Clearly my body was telling me, ‘You are unsafe.’” &gt;Which was why, she said, even though she’d never before complained about sexual harassment, she “slowly stood up, rotated from my hips, and took three photos”. She tweeted one, “with a very brief summary of what they said. Then I sent another tweet describing my location. Right? And then the third tweet was the [conference’s] code of conduct.” &gt;“You talked about danger,” I said. “What were you imagining might…?” &gt;“Have you ever heard that thing, men are afraid that women will laugh at them and women are afraid that men will kill them?” she replied. “So. Yeah.” &gt;'He’s a white male,' Adria said. 'I’m a black Jewish female. He said things that could be inferred as offensive to me' I told Adria that people might consider that an overblown thing to say. She had, after all, been at a tech conference with 2,000 bystanders. &gt;“Sure,” she replied. “And those people would probably be white and they would probably be male.” &gt;“Somebody getting fired is pretty bad,” I said. “I know you didn’t call for him to be fired, but you must have felt pretty bad.” &gt;“Not too bad,” she said. She thought more and shook her head decisively. “He’s a white male. I’m a black Jewish female. He was saying things that could be inferred as offensive to me, sitting in front of him. I do have empathy for him, but it only goes so far. If he had Down’s syndrome and he accidently pushed someone off a subway, that would be different… I’ve seen things where people are like, ‘Adria didn’t know what she was doing by tweeting it.’ Yes, I did.” I wish this wasn't real quote, it's disgusting.
I'm seriously unsubscribing from this sub because I have no fucking idea how people could bring you down to -4 for thinking getting someone fired is the appropriate act for someone who made a dick joke. Not even an offensive dick joke, just a bad, not even funny joke. The forking one is pretty clever though. But seriously, fuck this sub. I liked go too.
I honestly don't think the majority of people in this sub are programmers based on how some of your other posts were treated. I always thought going to a conference would be pretty chill and fun, but if its like a god damned job interview why would I bother?
Not exactly the point here, but I feel it's important to point out that the vast majority of those who are against gay marriage are only against calling it marriage, as to them marriage "is a scared word" and is between a man and a woman (usually the result of a religious background). They don't give a damn if two gays are in a relationship together, they just don't want it called marriage. If he had donated to one of those causes that seriously think being gay is a sin and should be punished, then I think people would have a point. But people blow the whole gay marriage issue out of proportion. It's a real shame he was forced out too, since he lived and bled Mozilla, and was a true genius, minus not realizing the importance of anonymous donations. He developed Javascript, which is used in almost website on the internet today. He could have done great things for Mozilla, but their shortsightedness led to him being forced to leave.
+1 for gb
I was surprised at all the backlash against someone suggesting we be civil to each other. That's disappointing.
&gt;bigot: a person who is intolerant toward those holding different opinions. No, you're the one who doesn't know what the word means. You are incapable of understanding that someone may have a different opinion then your own, that someone, somehow, could believe that marriage should be a term reserved for a union between a man and woman. It's not like people against gay marriage are trying to exterminate all the gays, or even convert them back to heterosexuality. They just don't want their relationship to be able to be called a marriage. Any other word would satisfy 99% of the anti-gay marriage crowd.
Lol, I actually was using these terms at work and was wondering to myself if it was still okay to say them. Seems I was correct in thinking it was only a matter of time. And why do people over there think primary/replica would be a good alternative? Replica is a clone of the original... Doesn't really work with most master/slave setups I know of.
You can precompute the size of `chunks`. Here's another way using a more standard for loop: https://play.golang.org/p/kaOA_y9Agz. The advantage of a standard for loop is its more obviously correct. There's nothing wrong with the code you wrote, but I had to read it carefully to make sure there wasn't an infinite loop in there. 
No (uniform) code of conduct. Everyone has a code of conduct. The question of which one is *best* remains an unsolved problem, as history can attest to. History also shows that it's never been necessary for everyone to agree in advance on the details to form a successful community. All they need is a common purpose and the willingness to treat each other civilly. The [reasonable person principle](http://www.cs.cmu.edu/~weigand/staff/) is more conducive to building community than excluding people for not agreeing to one author's (or worse, a committee's) reactionary laundry-list of good and bad behavior.
&gt;Yes because separate buy equal was such a great idea. Well in the case of marriage they could literally be equal, as it's just paper. A law could be written that states "Marriage is a legal union between a man and woman. A Civil Union is union between two members of the same gender, and is otherwise the legal equivalent of a marriage." And done. It's not anything like separate schools or water fountains like you seem to be trying to make it out to be. &gt;He donated to a campaign to force the nullification of marriages that had already been issued. that would cause people who were gay to lose rights. "In California, where domestic partnership (DP) has been available to same-sex and certain opposite-sex couples since 2000, a wholesale revision of the law in 2005 made it substantially equivalent to marriage at the state level. In 2007, the Legislature took a further step toward equality when it required same-sex DP couples to file state income taxes jointly." So yea, they were pretty much equal. &gt;The guy could have remained in another position. being put into a position where he would be the public face of the organisation, where he could set policy decisions for the organisation. The organization didn't respect him enough to believe in him that he could separate his personal beliefs from running a company that would quite literally never be in a position where they would complicate a single decision. Most people would make a similar decision as he did.
look at this post on github: https://github.com/gogits/gogs/issues/1304 ppl saying the project is dead and some guys are forking
I think this is a giant strawman. From my read of that github issue, that was someone complaining (on bad grounds) and the administration of the project ignoring them. Is there any *actual* project out there with a Code of Conduct that polices people's political views outside of the project? The only comparable case that I can think of is Brendan Eich (which I also find seriously problematic), and even in that case it was informal public pressure and media attention that seems to have forced him to resign. There was never a Mozilla Code of Conduct passed that would have forced him to resign; in fact, such a thing would have been blatantly illegal under California law, which protects both political party affiliation and religious beliefs from discrimination.
Yes, Django. The one they want to use as a starting point for the Go CoC.
I think this is a wonderful idea, but I just don't see it as being realistic. One, who defines polite? Two, for common definitions of 'polite', we of the internet are _not_ all perfectly capable of being polite. EDIT: I should say, I'm not optimistic that a code of conduct will help matters significantly, but I find this vehement opposition bizarre and disappointing.
Yea, I think you may have missed a few important parts.. no worries, i'll paraphrase. The guy in question had licensing concerns and kept pushing the UCC to reply and respond. They did but it was mostly stalling and/or ignoring the questions. So, he kept asking and they claimed he was being aggressive, hard to work with and argumentative. This all (in their views) violates the Ubuntu CoC. As a result, they had the power to kick him off the distro he built.. his own project. Long story short the Kubuntu team said no because it was all BS.
What the fuck dude, you really are a bigot. I'm done with this, you're pretty fucked up.
I feel like, by this rule, I'm going to get automagically banned from this subreddit, if someone of power and with a very narrow sense of what *discrimination* is, sees my activity on Reddit. People like me are very unpopular on the Internet, I better get prepared...
And the collective experience of, like, everybody, shows that not too be the case. I get where you're coming from but communities go toxic all the time.
The Go list is already quite well behaved, so I don't see politeness as being intractable and nobody else does either. I can assure you once a CoC is published and cited in discussion, the list will become less civilized as everyone becomes polarized around their support or opposition to the CoC.
&gt; as everyone becomes polarized around their support or opposition to the CoC Thus proving my point, sadly. I guess the way I see it, the 'adult thing to do' is _not_ to start a website bordering on the propagandistic ('good list' and 'bad list'? seriously?) when something happens you don't like. Evidently some people feel a CoC would make them feel more comfortable and improve the community; in a spirit of warmth and friendship, why would you start to point and call names (SJW being a favourite) instead of gracefully accepting that they feel differently than you? Do you really think it's the sheer presence of a CoC that encourages bad behaviour from the sort of person that tends to get labelled an SJW? EDIT: also, disclaimer, I don't frequent the Go mailing list at all so I have no opinion on it. I'm also not hugely invested in the Go community, but I do find the furore here (and in so many other similar situations) interesting.
Agree, I was surprised by people hating the patriot act too. They just wanted to protect us.
Because [the evil bit](https://www.ietf.org/rfc/rfc3514.txt) was never implemented, and therefore TCP/IP automatically strips all malice, defamation, or hostility from anything carried over it. Thus, it is not really possible to threaten, libel, or harass anyone over the Internet, and anyone who claims otherwise is making shit up to unfairly win an argument.
Solution to what problem? (Seriously, I think I'm out of the loop.)
Actually history has a long list of written agreements, for things you take part in everyday. 
a graph that shows relations and derives for struct values. Very useful. +1
And thus will all the packets be [happy](https://tools.ietf.org/html/rfc5841).
&gt; Working in the tech industry we can see that certain groups are under-represented and we'd like to do our part to change that. I think many people look at the disparity as a problem. Their claims generally seem to be that the existence of a disparity is prima fascia evidence of discrimination and lack of opportunity. I don't think perpetuating this fallacious reasoning advances your goals of fairness and inclusion. &gt; Our spaces should be ~~more~~ inclusive and welcoming and most right-minded people would agree with this. No reason to assume they aren't already. Individuals may not be, but through community members' maturity, we should be able to include both those individuals and the ones they're trying to exclude. &gt; An example of the second point - recently while contributing to a discussion (on Github) on a Go project, I found someone on Twitter had flagged that discussion for sexist remarks. The complainer said, and I quote "ewwwww, that's soooo sexist" and this complaint was taken very seriously. I was surprised and I actually went through the entire discussion again trying to find the offensive parts but I couldn't find any. Later I learnt the complainer took issue with the pronouns that the commenter was using. The commenter had been using "he" while referring to an arbitrary user of the software. This is normal in English as it has been spoken for the last several centuries and certainly what children are taught in schools. But America (or some Americans) have changed their opinion about this in recent years, and anyone who hasn't kept up and changed they way they speak English is considered sexist. Now the "correct" way is to intersperse "he" and "she" liberally, or not to use pronouns at all (like I have in this paragraph) Though you didn't call it out explicitly, there's a very interesting point here. The very people that are demanding we be inclusive are asking us to exclude people who think/speak differently than they do. There's also a good side point here about accepting the fact that someone will always be offended and to not take unsubstantiated accusations very seriously. Overall, I thought your post was very well thought out and insightful. Thank you for your contribution. 
"In the second version, we’ve moved our flag declaration into the main function" -- I think declaring flags in main thus making them private variables are unnecessarily complicated things, because I believe flags, which influence how the program behave, are better be global variables. That's far better than making them private, then use another set of private variables just to passing them around. 
&gt; One, who defines polite? I feel like this is the entire point. We all do individually. You have one idea of what is polite. I may have another idea. If it turns out that we agree on enough of a definition of politeness to have a functioning community, then you and I will stay. If a group of us have enough overlap but the rest of the community doesn't then we start our own new community. Communities evolve organically and naturally based on mutual respect, interest and ideas, as opposed to attempting to shoehorn everybody into the same group with disastrous results. It seems pretty similar to how friendship groups operate in meatspace. If a bunch of people I'm friends with suddenly start having a totally difference idea about what is socially acceptable then I'll probably take the people I concur with and start a new group.
Ah I like the for loop in this manner more it makes the code much cleaner to understand thanks! As for the ```copy``` I thought this could perhaps be done via a boolean flag passed into the function?
How is someone arguing for true equality in the eyes of the law everywhere, and pointing out how hypocritical the "traditional marriage" viewpoint is a bigot?
Look up the word bigot lol
simple way https://gopkg.in
&gt; -- are determined to throw a temper tantrum and demand to have their unfiltered voices heard. Unfiltered, how? The NoCoC looks to me like they are reserving their right to keep the discussion strictly to *what the topic of the community is*. In this case it would be Go, programming etc. . It would expressively *not* be what people's genders are, their personal background, what they did last weekend, political opinions, etc. . If someone starts insulting people, then they would be violating the NoCoC, because it states that people should act like proper adults (mature well-balanced people, I guess not *literally* adult people). So what are these *unfiltered voices*? If you mean that they want to reserve the right to behave like they please *outside of the community* (in this case, outside /r/golang, the mailing list and similar avenues), then what does that have to do with the Go community? People who are part of the Go community don't have to care what participants of the community say on their own personal twitter or whatever. And they aren't reserving the right "to be heard" since this thing is so much about keeping the topic of the community *on topic* and not about other stuff. *Other stuff* would for example making a comment in this subreddit like "Hey guys I have a super-opinionated political blog, y'all should check it out!!". That would violate the NoCoC.
[**@freakboy3742**](https://twitter.com/freakboy3742/) &gt; [2015-06-20 06:14 UTC](https://twitter.com/freakboy3742/status/612141472570183684) &gt; @nocofc So that's the rub. I don't believe you can separate "unofficial" statements from official ones, esp when delivered in same medium. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I hadn't read that interview. I guess I was wrong about that.
I politely disagree, but I would urge you to hold off as it will likely be decided for go in the near future. If golang implements a CoC, and that CoC does not mandate that what you say in non golang areas, then I tend to say, it's not a lot different from other languages. (still, would rather not have one, personally) If they implement a CoC like django's that has a whole framework for dealing with criticism, and enforcement, and they do care what you say on twitter if your a contributor, then yes, it's time to fork golang and move on, or like you mentioned, go somewhere else.
Think GitHub, but decentralized.
Also http://www.colm.net/open-source/ragel/
It has its own syntax that you need to learn if you want to use it.
Yes, I should have handled this better. I fully accept being downvoted.
Yes. `append` grows a slice by creating a new larger array and copying everything over. It does this by doubling the capacity, so it will only happen a few times, but in general it's a good idea to set the initial size if you can. An alternative approach is to set the capacity of the slice instead of its length (`make([][]int, 0, n)`). This will yield the same performance but you could still use append.
Yes, I spent the time to create a scanner for a toy language so I would have the framework ready for when I needed or for real. https://github.com/dgryski/dpc/blob/master/lexer.rl
Completely agree. Also this line: "Linux gets a lot of grief for being a 'toxic' community. The fact is, it’s not." Whether it is toxic or not is not something you can say is "fact". Harassment and hostility is a personal experience, and dismissing voices like that does not help in understanding the problem.
I'm always puzzled when someone mentions gopkg.in when dependency management is brought up. All gopkg.does is provide a way that a package author can use to version their package import path. Further, it *only* works with GitHub repositories! It helps not-at-all for someone trying to manage their project's dependencies. I have no control of which my dependencies are on GitHub, Bitbucket, LauchPad, code.google.com, etc and which choose to use gopkg.in. Further, it helps not at all when I depend on package A which imports gopkg.in/foo.v1 and package B which imports gopkg.in/foo.v2; unless you assume silently having two compiled in slightly different versions of foo is somehow always (ever?) the right thing.
this makes no sense. &gt; "since marginalized groups are the ones most heavily discouraged from contribution when these events happen." source, please. if someone is intimidated by linux kernel developers, why does it have to be labeled as more-likely-to-not-be-white? so, if you have some way to add more data, it could be an interesting point. trying to fix the linus approach is going to hurt a lot more than it helps. defining toxic is key. in your definition, being mean, falls under toxic. that isn't how the world works. 
I don't think this is true. If that was the real motivation, there would be literally no reason to oppose a CoC, because if you are polite, it won't have any interaction with you whatsoever. i.e. you argue that you don't need it, but you fail to show that it shouldn't exist. The answer is, obviously, that your notion of "polite" is not a subset of what a CoC might consider "polite". That's why we need CoCs, to come to a common notion of "polite" for a given setting.
&gt;do you need to hurt other people's feelings? What's with the thinly-veiled accusations? Do you not agree that there's a difference between running into a jerk and being systematically harassed? Are you seriously trying to equate the two with your implication? Or worse, are you implying that the two should be treated in the same manner? I'm all for avoiding harassment in all forms, but these codes of conduct have a funny way of being heavy-handed over garden-variety immaturity/ass-hattery. Have you really *never* had a bad day and been mean to someone? Have you really *never* been *anything* less than *perfectly* cordial, tolerant, professional and mature? I'm not perfect. I've said mean things to people in the past. I still think I'm a competent developer and a good person, overall. I think it would be disproportionate for me to be ostracized or publicly shamed as a result of those actions.
You were being sarcastic, which is a universal sign of not being constructive. And my reading from all the opponents posts is apparently very different from yours. Because what I read is not "questioning" or "being skeptical", but grossly misrepresenting the intention and content of the proposition of a CoC. Notably every post who talks about "censorship", "rules", "SJW" or "political correctnes" is in direct contradiction to what was proposed and uses inflammatory language, to appeal to emotion. That's three of the twelve logical fallacies right there.
I'm sorry if that came off as an accusation. That was not my intention. My question was, why do you think "garden-variety immaturity/ass-hattery" shouldn't be avoided? I have very often been aggressive, sarcastic, polemic, mean (to the point of being a bully), racist (to the point of being a Nazi), sexist and a thousand different things. Most of them I regret deeply. And in recent times, whenever I notice that that was the case, I apologize honestly and move on. And that is clue. And I know of literally no case, where an honest apology wasn't accepted. So why wouldn't I want to "child-proof" the world? Why wouldn't I grab any opportinity to learn, what part of my behavior people find negative and to try to better it? Notably, nobody says everyone has to be perfect all the time. Just that everybody has to try and to recognize, when they did something wrong and try to make it better. A CoC is a helpfull tool with that: It's guideluines I can use to measure and control my behavior in a community and to prevent me from doing things, I might regret in hindsight.
No, unfortunately I did support it. But, with most things it turned sour and was a rushed decision. &gt; but grossly misrepresenting the intention and content of the proposition of a CoC A CoC is not defined by one individual but a community. Any suggestion should be given the same respect as any other suggestion. &gt; Notably every post who talks about "censorship", "rules", "SJW" or "political correctnes" is in direct contradiction to what was proposed and uses inflammatory language If people feel this way it should be evaluated for its merit and not looked down on because you disagree. Please try to be respectful and open minded. 
&gt; What are "the goals" What I wrote is what I have largely preceived as "the goals of the proponents of a CoC". But I am also perfectly happy, for the sake of the discussion, to reformulate as "The goals a CoC should have, in my opinion". &gt; Are you sure you read the whole kernel CoC? It clearly says to treat people with respect and abuse will not be tolerated. But it doesn't specify, what is considered "respect" or "abuse". That was my point. &gt; This is powerful because if gives you the right to define both inside the base foundations of their meanings. But that is a problem. That doesn't help me. How am I supposed to know, what the community considers "polite", if my personal definition, due to cultural background, is vastly different? Note, that I am arguing from the viewpoint of a person who places a greater value on not hurting others, than validating my own cultural or personal views of what appropriate conduct is. &gt; You clearly only care about punishment and who's the judge. I don't and I can not see, what gave you that impression, given that I explicitely stated, that any reactionary or enforcement part is outside of the scope of the proposal. I actually don't think we *need* a judge (or punishment, for that matter). I do think we need concrete, specific guideluines that can be used to a) orient yourself and b) point people too, that violate them. &gt; I'm offended because I'm a proponent for a CoC and I don't want that. I am sorry, that was not my intention. Let me rephrase as "Proponents of a CoC in the spirit of the Django CoC". &gt; I find it hard to believe that the community cannot know how to treat people with respect and kindness without a formal document that defines how you should react if someone offends you by not being open minded, dismissive and uncooperative. I think empirical evidence disproves this. Debian even *has* a CoC and I know multiple, very technically competent people that left the project alltogether because of the toxic community. I am not very technically competent, but when I began to interact with the go community, I found it very dismissive, aggressive and flippant and considered jumping ship (or rather, not to become part of the community and just use the language). Even today I have the desire to contribute code to the language, but so far I have been too afraid of the reactions I have seen.
Trust me, the title was not my choice or suggestion. Heck, Oracle was never even mentioned in the interview. And it would be a bit arrogant to think that a fairly inconsequential article in BI.com could change the market :-)
Making it an official CoC allows people think they can use it to lawyer with. I, and possibly most of us, don't want lawyering of community members' behavior. I think it's sufficient to ask people with bad behavior to be nicer, let anyone who feels like they were attacked know they are welcome here, and move on.
There's been a big discussion the past few days about whether having a Code of Conduct would be a good thing or not for the Go community. I think it would be ok as long as the CoC applies only to official Go communities (irc, this subreddit, go-nuts, conferences, etc.) and their are clear rules outlining forbidden behavior and any consequences. 
gogs is already go get-able... only problem is it only works with public repositories, I want to be able to do a go get import, from a private repository.
I blame overprotective parenting. A few years ago overprotection became synonym with great parenting and that overprotected generation grew up and this is what we have now - people that believe that the world *owes* them an apology for hurt feelings. Everybody is a special and unique snowflake and the Sun is out to get you.
&gt; I swear all of tech has turned into a kindergarten. Can you guess when did that start happening? Take a guess.
I'd agree that's the likely cause. As for how, I suppose the simple answer is those people are thinking emotionally instead of rationally. People tend to want witch burnings until the witch is them or someone they love.
Not exactly. The current implementation compiles (at runtime) the regular expression into a series of instructions and runs it in a sort of virtual machine. https://swtch.com/~rsc/regexp/regexp2.html As a result, the generated FSM can be 10x faster.
Common? No, for a project, yes. A programming community? Not so much. In fact it's super strange. &gt; I don't know, where you read that I have given you retorts to your claims, questions and concerns but you continue to say the same thing. That's fine, but I don't want to drive in circles here. &gt; Regarding the quote from the Kernel CoC: I disagree. Code quality and collaboration are still part of the process. You dismissed this without thinking about it critically (back to driving in circles). &gt; Also, we are not the linux kernel and every community is not the same, if I may. True, nor any other community which is why we should start simple and grow into our own culture. Give people like me and others that take issue with golang telling us how to interact with society time to prove this is irrelevant and unnecessary. Although I am fine with documenting our anti-abuse positions (that's just common sense - no one against the CoC wants to hurt people). Anyway, it's been fun chatting but I think we are at a fork in the road and it's pretty useless to continue as I feel the go team doesn't really care anyway.
We use dbr and sick the classic ORM stuff with it.
I use https://github.com/mgutz/dat - it has some composable, ORM-like features, although I use it to load SQL files off disk and for its performance. [sqlx](https://github.com/jmoiron/sqlx) is my older (but still very good) recommendation otherwise.
We use xorm. Documentation has a lot of holes, but so far it has been a good library without major bugs.
I use gorm ... I definitely have had some frustration with it, but overall it works well. When I started using it the migration features weren't working so I have never used the migrations. 
&gt;gocraft/dbr doesn't use prepared statements. We ported mysql's query escape functionality directly into our package, which means we interpolate all of those question marks with their arguments before they get to MySQL. The result of this is that it's way faster, and just as secure. Not sure how I feel about this. Can someone verify that it's just as secure?
Since you asked for it, this one is an example. Not only are you disrespectfull, you are also assuming extremely bad intentions. Comments like this are a very bad basis for working together.
Soooo… "agree with my opinion, to proof you are not a bigot for calling me a bigot"? :)
https://gobyexample.com/json
go generate
I think https://github.com/jmoiron/sqlx gives the perfect balance between being simple and being convenient :) It's not an ORM, but then again, a "real" ORM is difficult to do in go.
I did copy the style. However, this style is only a place holder. Due to it being written in CSS, it is possible to stylize it in different manner. I wanted it to be vertical rather than horizontal as it will be easier to setup to be printed (@media print). The example slides were not exactly "yanked" from "golang/tools/present". I originally created this tool as a very short hacky script that did not support authors and was laid out with each slide being a separate file. It worked well but was very hard to scale. This is why the file type is `.slide` rather than `.keypoint`. The presentation info was originally in a `.info` file. When I discovered that the tool "present" solved this be placing everything in a single file, I did the same, as well as implementing a similar system for multiple authors. I did not occur to me originally that I would need multiple authors as this tools was just for me but it seemed useful and I saw no reason not to implement it. I do not however, like that `present` requires learning another mark(up|down) in order to create the slides. `present` is geared towards presentations on Go. I wanted to presentations regarding mathematics, physics, and C/C++ talks. I wanted a simple tool that I could extend to support anything I needed, not just Go code. 
I only glanced through the code a bit, but it seems to me that more than just the style was borrowed from Go Present; and yet, none of it was credited to Go Present.
You probably know this, but others may not. You can create anonymous types directly in a function: package main import "database/sql" type User struct { ID int Email string } func GetUser() (*User, error) { var u struct { ID sql.NullInt64 Email sql.NullString } // run your query, fill in &amp;u... return &amp;User{ ID: u.ID.Int64, Email: u.Email.String, }, nil } You still have to do the mapping, but at least you don't have to expose the extra type.
After reading your second link, I think the problem is blown out of proportions. Yes, it is a pitfall, that the sql package might use prepared statements unexpectantly, if used incorrectly, but once you know that, that should be easy to avoid. I would even say, that the vast majority of applications only need a finite (and small-ish) number of queries, so you should be able to just prepare them once and reuse them all the time (thus saving parsing time). But meh.
Yeah, to me that says a lot about the credibility of the author and the software. I should have see the comments first, then I wouldn't bother watching the video. In the video, the title is # Title of slide or section (must have asterisk) I was confused why the "(must have asterisk)" clause, but after looking at the http://godoc.org/golang.org/x/tools/present, I suddenly realized why -- even the slides are "borrowed" from Go Present, without even care to remove the conflicting info. It might be a good tool, but I won't spend any of my effort in it.
Care to repeat this to people defending Ferguson rioters? Rationalizing - or, rather, understanding the reasons - does not equal 'justifying'. I said several times that harassers were wrong - both Richards AND whoever harassed her (it just so happened that feminists' Internet Hate Machine was smaller that that of anti-feminists'). Yet, both were wrong, period. And injustice might lead to excessive, ugly, and in case of Ferguson - directly violent outbursts: it's not justification, but a statement of fact, simple cause-and-effect. Now if you let go of these pearls for a moment, what would be the position that I - or, rather, 'my best self' - should've taken? "Oh poor ~~girl~~ ~~(sorry, woman)~~ (sorry, womyn), she suffered so much, she was totally right getting this disgusting sexist pig fired, leaving him (and his wife (and their three children)) with no means to live! He said 'forking a repo', how dared he, I can't even!" Is that what I should've said, or did I miss anything? How much harassment should a wrongdoer take before she becomes innocent? How much harassment should a feminist take before she's justified putting three children at risk being hungry? How would _your_ best self answer these questions? And as you suggested, I looked in the mirror. I need to shave.
If it's done right, it is. Many cases of DB/driver combos don't use server-side prepared statements at all, but they still support placeholders in the API, and they just quote and substitute parameters for placeholders before sending the query to the server. Of course it's possible that there are bugs in the escaping or in the server's SQL parser that allow something untoward to happen, but it's also possible that there are bugs in the handling of prepared statements on the server that could cause trouble. In both cases, if people did their jobs correctly than you should be secure.
yeah, but only as an option when there is no other options. 
It's 'hard' in that homebrew local interpolation is an area with a high attack surface. The old PHP functions didn't do this concept much of a favor, especially with function names like `mysql_real_escape_string` which replaced `mysql_escape_string` (absolute madness). mgutz/dat has [a comment around](https://github.com/mgutz/dat#why-is-interpolation-faster) local interpolation performance: &gt; Keep in mind that prepared statements are only valid for the current session and unless the same query is be executed MANY times in the same session there is little benefit in using prepared statements other than protecting against SQL injections. See Interpolation Safety section above. mgutz/dat also added some [fuzzing tests](https://github.com/mgutz/dat/commit/3b89fc59253b3a994fa3e8ab6ac4e3eee18ef51f) in response to a comment I made here—noting that fuzzing isn't foolproof. If you're still really concerned about it—and I can understand that, although the homework appears to have been done—note that `dat.EnableInterpolation` is set to `false` by default. 
All of the apps I've written in Golang are heavily cached anyway. I've made heavy use of Groupcache &amp; Redis where appropriate. Adding that already existing layer to my database logic is simple &amp; makes a lot more sense than relying on the ORM. With Groupcache I can maintain data caches between servers and only hit the database when necessary. Wouldn't you rather know where &amp; how your queries were being cached? It's pretty simple to roll your own caching layer that makes use of already existing libraries &amp; tools like [Groupcache](https://github.com/golang/groupcache) &amp; [Redis](https://github.com/go-redis/redis). It means you are in control of how your data is being cached, which in my opinion is preferable.
Take a look at https://github.com/go-pg/pg - PostgreSQL only (how often do you switch database? :) - automatic connection management - raw SQL for querying - struct mapping - fast and effecient since it combines PG client and struct mapping
One of the ways I dealt with this before was to clone private repo manually into $GOHOME/src/&lt;private_repo_package_path&gt;. After that go get -u will work correctly.
Your SSH private key is stored in "clear text" on the file system ;)
Well no, it's stored encrypted, and there is a whole system in place to make sure you don't need to enter the passphrase every time (including integration with native windowing for password asking, native keyrings for storage, etc.).
Hahaha, this project is beautiful. Love it.
We have this: https://github.com/MediaMath/cove#gosh---get-over-ssh---simple-script-for-getting-go-packages-at-supplied-uris It is very simple open source project to get private repos over ssh.
This is one reason I made [caddy](https://caddyserver.com). (Python's server doesn't support the Range header). Also see [spark](https://github.com/rif/spark).
I have had to make a similar thing some months ago- good on you for publishing yours. That being said, Sweet Baby Jesus fix your indentation. I sent you a pull request with it run through go fmt.
I'm so sorry about that. I hacked this over one night. I'll fix this ASAP.
Thanks a ton for the formatting @mcvoid1
Set your editor to go fmt every time you save ;)
Similar information is present on the official Go's FAQ: http://golang.org/doc/faq#git_https
So you're saying it would be a difficult to write a for loop using range, discard nil values with with an if and append to a new slice without making errors? I'm sorry but this just backs my theory that we've abstracted so much that we couldn't code our way out of a CS101 class today. We no longer write logic. We just tab our way through one liners as we guess from what the IDE will let us enter next.
Good point, I completely forgot I had done that. It's excellent.
If users don't put passphrases on SSH keys (very unlikely as it is the default and recommended in all online tutorials) then better teach them how to do. Still, there IS a way to encrypt them, while there is no hope with netrc. Disk encryption is a totally different level of protection. I have FDE as well, but still do not store any password or secret in clear text on disk, and refuse to use anything which doesn't use the keyring for this. In case of a local exploit, FDE is useless; on the contrary, a local attacker can only use the SSH agent to connect but not silently steal any clear text secret. Do you store all your passwords in clear in a file called all_my_passwords.txt in your home? Because your line of reasoning would make that acceptable as well.
No, I'm not saying that this is hard, but it has absolutely no value to have this boiler plate in your code. And, yes, there are enough cases where errors occur in such mechanical code blocks.
what's the game called you show in your demo?
Also, you are outputting unescaped things into the HTML, why not just use html/template?
You should add Gzip, and use the log package.
thanks ;)
beware over-complication serve.go: package main import ( "net/http" "os" ) func main() { wd, err := os.Getwd() if err != nil { panic(err) } println("http://localhost:8080/") panic(http.ListenAndServe(":8080", http.FileServer(http.Dir(wd)))) } 
The code for this is so simple (thanks to the awesome net/http) that I hesitated before publishing mine. But there: https://github.com/yannk/simplehttpserver Now you have the choice of license: MIT for mine.
Another one. https://github.com/naoina/genmai I like this.
As a bonus, this version won't be susceptible to path-traversal attacks. i.e. Try visiting "http://localhost:8080/foo/bar/../../../../../" in the OP's version.
Yeeeaah, buddy. https://github.com/variadico/scaneo
&gt; so I placed a breakpoint a couple lines above the if in question, recompiled the whole of RRDNS with godebug instrumentation, dropped the binary on a staging server, and replayed some DNS traffic Uh, that sounds a lot like sprinkling tracing statements throughout your code, recompiling, and re-running. A good *debugger* should just hook into your code.
But their actions weren't actually permitted by the CoC. As pointed out by Scott, their own actions did not follow the CoC and actually violated the CoC. So again I say, the existence of the CoC couldn't be blamed for their actions, since they were operating outside of the CoC :-)
very nice - a unified interface to pwn all your bases ;)
Well you need to be careful with inputs (we are not kids anymore). If you combine it with auth, ssl it's useful tool. :-) 
Because Go doesn't have the two-stage compilation that would be required to implement this. However, a regex engine coupled with 'go generate' could be used. For example, a tool could extract 'go generate regex' comments and expand a template to produce ragel or ra2dfa code that performs the appropriate matching.
Understood, but my point is relativity. They claim they can, so who's right? At the end of the day it doesn't matter. The point is a CoC was used to kick someone off of their own project for upsetting the UCC.
What I'm complaining about is that the way your recommendations are written, a company might come and enact these for their internal rules. I want to save programmers from having to get their code through a tool that has explicitly been designed to be not userful as an automatic step in a code review process.
If this idea gets popular, perhaps consider a badge or mini-banner that people can put on their project to indicate that the project aims to comply with one of the levels you indicate. (Unfortunately I am not a graphic designer.) I guess people can raise a bug against projects that significantly fall short of the aim. Project quality is always going to be subjective, and different projects have very different requirements for review and testing (e.g. crypto has very specific requirements to not expose exploitable weaknesses, quite different to other areas; or a game might have very little automated testing but a community of players exercising the code), so there is no rule that works for everyone, no "one size fits all", but aiming for a good standard is always going to help. So we should respect anyone who makes the effort. Also, publication of alpha code is still to be encouraged (i.e. code with almost no checkboxes ticked), so long as it is made clear that it is alpha code and doesn't (yet) aspire to beta or stable status.
You'd really have to post some specific examples to get a better answer. One thing that Go does more of than some other OO languages is write functions that manipulate things through their interfaces. When what a function has coming in is an `io.Writer`, what are you going to call it? `socket`? `file`? You don't know what it is, so it may as well be `w`. There's also a suite of more Go-specific shortcuts, like `w` for `io.Writer`, `r` for `io.Reader`, I see a lot of `f` for a file, stuff like that. I also find myself occasionally using shorter or weirder names because a package took up the generic one I really want to use. The `path` module is full of great stuff for manipulating paths, but also therefore claims the `path` name for itself, so.... `p`? Guess so. You'll probably work out what `p` is when I keep calling `path` stuff on it.... Later edit: One thing about Go's philosophy is that generally speaking you shouldn't see that many tokens on a line anyhow. `n, err := w.Write(b)` may be full of single-character names, but once you're used to it it's all pretty standard. Now, go ask the Haskell community about how many tokens they're willing to put on a single line.... Also be sure to hook up [godef](http://godoc.org/code.google.com/p/rog-go/exp/cmd/godef) support in your editor, which ought to make "jump to definition" one keystroke.
While on occasion I disagree with golint, I've been organizing my code so that it has no complaints so that I can use it as a on-checkin thing for my published projects. That doesn't always mean "doing what it says", sometimes I just respell things until it is happy. It's close enough that it saves me more than it loses. I only do that on released projects, though. During exploratory development it's a royal pain since it insists on so much documentation.
&gt; I ended up just using sqlx, which wasn't too bad, although it was a pain in the ass having to have two versions of all my types, one with sql.NullInt64/NullString/NullBool in them, and one with the real things, and to have to manually copy data between them, just so that I could fetch queries with left joins in them. This concept might help: [Data access object](https://en.wikipedia.org/wiki/Data_access_object). It won't save you from duplication, but makes it more organized 
http://doc.cat-v.org/bell_labs/pikestyle – Variable names in particular.
Simply put, it's laziness. - [brvty](http://michaelwhatcott.com/familiarity-admits-brevity/) - [go code that stutters](http://michaelwhatcott.com/go-code-that-stutters/)
I have to admit I'm getting "this close" to just using `self`, `this`, or even just `s` for all my handlers, yeah. It's frustrating when I refactor a name to go rename all the handlers (and naked search&amp;replace doesn't work so good when you're renaming "a" to "c"), it's frustrating when the abbreviation comes out to one of the existing single-character names, it's frustrating when it still comes out ambiguous anyhow (i.e., two classes in the same file that abbreviate the same), it's frustrating when my class name has three words in it and I can't quite figure out how to abbreviate it... It's a whole lot of frustration for what is, as near as I can tell, zero gain in clarity over a convention for "self", and arguably _less_ than zero because there is no convention now so you have to read the function declaration to tell what it's doing.
http://www.reddit.com/r/golang/comments/3aporh/why_so_many_gophers_use_single_letter_variables/cset924 Yes w.Write is quite obvious and for built in stuff I usually stick with the single letters because it's obvious. The problem lies in using single variable names indiscriminately. Like in the [video](https://youtu.be/sFUSP8Au_PE) the other guy posted, using c as commit and saying "we can use c, it's obivous" (which it is if you read it, but isn't if you glance at the function). Reading a full codebase riddled with s,p,h,sp,fs,dt,op,nb,mp variables is a nightmare. Yes, the meaning is obvious if you read the function, but when you are just "scrolling down looking for shit" it's a freaking nightmare because it forces you to read to look for context. Which imo, is very very dumb.
Use comments to describe what is what. Don't try to encode the said comments in variable names. 
"The proper use of comments is to compensate for our failure to express ourselves in code" Are you saying that we don't need to write self-explanatory code because we can explain in comments? Well, I'm sorry, but I have a very contrary opinion and I won't change it anytime soon: if you need to look at a comment to understand a piece of code, the code is bad. Good comments explain why the programmer made a decision, not what the code does. Tool generated docs for api documentation is obviously a very different scenario.
"The proper use of comments is to compensate for our failure to express ourselves in code" This can be said by someone who has never encountered a piece of non-trivial code. I regularly read entire books or multi page articles, which explain why and how a particular algorithm works. PS. Besides, I've clearly written "what" and not "how". The comment should be the answer to "what". The code itself should be the answer to "how". If it's simple enough. 
&gt; This can be said by someone who has never encountered a piece of non-trivial code. I regularly read entire books or multi page articles, which explain why and how a particular algorithm works. Most programmers work with trivial code. That generalization applies to trivial code. You can't expect regex voodoo and complex sorting algorithms to be self-explanatory, no one is saying that. &gt; The comment should be the answer to "what". The code itself should be the answer to "how". If it's simple enough. Slightly disagree. Variable/function names, and if they are not enough also Class/package/function comments, answer "what". Code itself answers "how". "In-code" comments answer "why". Again, more complex code is an exception, but again, most programming is not complex algorithms, most programming is just tying together a couple libraries made by someone else.
I used to question this as well but after reading a lot of good Golang code and realizing that I wasn't having problems tracking those variables, I adopted it and now it feels natural to me. The idea is that if your design is good, you'll likely not have many variables to track in a single method/function. For package variables or anything that has a longer lifetime, you'll notice that longer names are used. Also, they are rarely arbitrary variables. They are usually common wide-used abbreviations, for example: n and i for numbers, the latter mostly used for array indexes and/or counters; b or buf for buffers; h for Handler, etc. Also, it probably comes a bit from computer science / math background, in which single letters are used for variables, logic predicates, etc.
The big crime in that hub example is that the h is declared in another file. Big crime in my book. &gt; I agree with you that if code get complicated, you're helped from descriptive variable names. Anyway the point is that: code should be kept simple. Complexity should arise from combining simple pieces of understandable cod Totally agree. But as I said in another reply, scrolling down a file riddled with "sh" "fh" "bh" "sp" "mb" "s" "m" "f", etc ican be a frustrating exercise that could be a breeze with more descriptive names, even if you have simple code. Another issue is the using of the same letter in different context. if "m" is message, then m is message forever. There can't be an multiplexer called "m". It *will* confuse the reader sooner or later, specially if the repetition happens in the same file/package. But this example of [actual golang code](http://golang.org/src/bufio/bufio.go?s=12421:12490#L523) (line 523 - flush()), similar to the one found on [this article](http://michaelwhatcott.com/go-code-that-stutters/) someone shared in this post perfectly illustrates my frustration. That piece of code is simply not legible. Period. It's bad, really bad and I would be ashamed if it was code written by me.
Looks pretty clear to me. Would you prefer this: func (writer *Writer) flush() error { if writer.err != nil { return writer.err } if writer.size == 0 { return nil } written, err := writer.writer.Write(writer.buffer[0:writer.size]) if written &lt; writer.size &amp;&amp; err == nil { err = io.ErrShortWrite } if err != nil { if written &gt; 0 &amp;&amp; written &lt; writer.size { copy(writer.buffer[0:writer.size-written], writer.buffer[written:writer.size]) } writer.size -= written writer.err = err return err } writer.size = 0 return nil } The original below is more readable to me. The longer names obscure the logic. It's like reading "[buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo](https://en.wikipedia.org/wiki/Buffalo_buffalo_Buffalo_buffalo_buffalo_buffalo_Buffalo_buffalo)". func (b *Writer) flush() error { if b.err != nil { return b.err } if b.n == 0 { return nil } n, err := b.wr.Write(b.buf[0:b.n]) if n &lt; b.n &amp;&amp; err == nil { err = io.ErrShortWrite } if err != nil { if n &gt; 0 &amp;&amp; n &lt; b.n { copy(b.buf[0:b.n-n], b.buf[n:b.n]) } b.n -= n b.err = err return err } b.n = 0 return nil } Edit: Lengthened local var `n` in the modified example. (Hopefully we can agree that `err` for `error`s is OK.) Edit2: I forgot to change the receiver in the declaration from `b` to `writer`. Edit3: writer.written → writer.size, as it should have been (still horrific)
&gt; The best Go configuration system is not TOML *Article is about parsing TOML*
Because that's a pretty lousy rule. Variables that are referenced in a small scope should have useful but *short* names. By keeping the semantic content of the variables small you give your brain less things to process, which makes it easier to understand the code as high-level chunks. It's stuff that's externally visible that needs to be named well. And even there, *good* naming isn't necessarily the same as *verbose* naming. If you have a library that revolves around one or a few central concepts, I would rather you gave those concepts short distinctive names (especially in Go where anything from another package is going to be used with qualified names anyway).
&gt; When you cross compile a Go program for another platform you are not using cgo anyhow, so you don't link against its C library. You *can* use cgo when cross-compiling Go for another platform, but then that requires you to also have a C cross-compiler and library that target the same platform. Tricky, but it works.
Musl is a Linux libc, it doesn't work on any other system, no *BSD, nor Darwin. 
Thank you for illustrating my point, the first option may be ugly and could be bettered but is still better than the second. Why? Because b.n is not the characters that were written, but the characters that exist in the buffer (in other words, "size"... Why not fucking call it size??). Ofc you wouldn't have failed translating/understanding the code if the code had good variable names :3 Also, yes, there is no problem in calling error err or multiplexer mux, or whatever. But there is a problem when you are calling "size" "n" and written characters also "n". It's not simplicity, it's unnecessary obfuscation. And why not call b "buf"?? It's so more explicit and still so short... I mean, I agree, I prefer short variable names. Those java guys who write variableThatDoesThisAndThatAndThatThingAlso get to my nerves, but the opposite is also bad, that code snippet is the extreme opposite, and imo, borderline retarded. Edit: My main complaint is that this is the extreme opposite of overdescriptive variable names. I should look at the function and understand it without spending 5 minutes trying to read the code. Simple 3 letter variable names and a bit longer when needed greatly simplify that task. Also, fast scrolling while reading the code is easy and possible with descriptive variable names (even if it's 3 letter variable names), but much harder when more than 50% of your variables are single letters. It's a nightmare actually.
Good point, but I'm not convinced. My careless search &amp; replace, after a long day, without attention to detail should should not be misrepresented `Writer.n` is obviously not the amount of bytes that have been written, it doesn't even make sense. If I would have just looked at what the code was doing instead of trying to write a snarky comment, I would probably have realized that. That being said, I would probably have chosen `size` myself, but as they say, *familiarity admits brevity*.
always check for errors... always
&gt; Also be sure to hook up godef support in your editor, which ought to &gt; make "jump to definition" one keystroke. Just wanted to point out that the canonical location of godef is now http://godoc.org/github.com/rogpeppe/godef. 
To add to that: read /u/jmoiron's article on using `io.Reader` for the greater good - http://jmoiron.net/blog/crossing-streams-a-love-letter-to-ioreader/
&gt; San Francisco, CA (relocation offered) For those, like me, wondering.
&gt; don't take it personally &gt; what that guy is saying is borderline retarded We can understand your position without the need for any name-calling. Please don't do this.
&gt; Yes, the meaning is obvious if you read the function, but when you are just "scrolling down looking for shit" it's a freaking nightmare because it forces you to read to look for context. You should always be reading the function to understand the code. You shouldn't optimize your code for readers who are skimming at maximum speed.
&gt; I also find myself occasionally using shorter or weirder names because a package took up the generic one I really want to use. The path module is full of great stuff for manipulating paths, but also therefore claims the path name for itself, so.... p? Guess so. You'll probably work out what p is when I keep calling path stuff on it.... Is this because package names have to be lower-case? Is there a reason behind why they stipulate to be lower-case instead of upper-case?
It's a convention so it's mostly arbitrary, but consistency matters. One way it can matter: both OSX and Windows have case insensitive file systems. If you've ever had to deal with case issues in git, it's not a fun problem. You end up just always using lower case names.
I feel like one of the reasons is that your code should be broken into short pieces which do simple units of work. My roommate goes by the mantra that a function should be 5 lines or less, and at most 25 lines is really pushing it (he doesn't write Go code though). With such short pieces it really does make sense to use short variables because they become obvious in the context of the code and you aren't juggling 15 different variables. Once those start to coalesce into large units - for example at the package level, descriptive names are great and plentiful in Go.
`b.n` and `n` represent the same concept, number of bytes, which is why they use the same identifier. `b` is not called `buf` because it is not a buffer in the traditional sense, it is a Writer wrapper to a buffer. I have never seen this code before but it took me about 5 mins to figure all of this out.
I might be missing something, but I think you can cut a bit of unnecessary logic out by skipping the empty string argument and the check for an empty string by just calling `ForeignIP("/")`: http://play.golang.org/p/ejpKFARqBB.
But the issue with git/file systems is the same. The only way to avoid it is to be consistent. In the current scenario, to always be lower-case. The same applies if the convention would be upper-case. If it was arbitrary, then it means that this situation only got caught at a latter process, when the convention was already established. Not a big problem, just a minor inconvenience. Went to look on the documentation to found anything. They just advise exactly against path scenario [**Don't steal good names from the user**](https://blog.golang.org/package-names). Maybe if the convention was upper-case this issue wouldn't happen. But then, maybe it would appear other issues, maybe clashing if there was also a struct `Path`.
 Beginner here as well, how would you mock the HTTP GET? Why shouldn't the test go to the real web service?
(ret uint) declares a returned variable, not a parameter. The first set of empty parens is for the parameters.
You will be if you allow everyone to post jobs. Why do the people at Iron.io get special treatment? Is it because they're friends with the mods?
i'm not really satisfied with my implementation checking the empty ip.. but your seems better, thank you!
A package-level var incremented in a function: package main import "fmt" var n int func f() { n++ } func main() { f(); fmt.Println(n) f(); fmt.Println(n) f(); fmt.Println(n) } That will print out 1, 2, 3.
Iron.io isn't special. I approved this posting before seeing it; I had no idea who it was for. I'm not sure I even know anyone who works for Iron.io. We've been allowing job postings since this subreddit started. We haven't been flooded yet. If it starts heading that way then we'll change our policy.
&gt; A closure (here, an anonymous function) is called that because it "closes" over the state of all the variables around it. That may depend on an actual implementation or even the school of programming you went through, but in general, a closure only closes over free variables of a function (see, e.g., SICP).
dude... what's the issue with using 4 freakin letters... name it byte. problem solved. edit: yah, byte is built in, can't name it byte. But my stance remains the same; I'm advocating to abbreviating as much as you can without stripping the meaning.
&gt; You should always be reading the function to understand the code. You shouldn't optimize your code for readers who are skimming at maximum speed. That's like saying you don't need to write perfectly clear english because the reader should take his time to understand the meaning of what you wrote. The code should be as clear as possible and optimized for maximum readability by anyone in any situation. It doesn't even matter if you are fast skimming.
yep. not useful at all, sorry for that. But go read go source code. When the guys behind a language are enforcing rules that force you to spend 5 minutes understanding a function that could have been understood at a glance if it had good var names. That rule is a bad rule and creates more problems than solves
As Tacticus mentions, storage is the primary function. With this method, you place shards on different servers. This allows you to take a number of servers offline (up to the number of parity shards you have), and you can still access all your data. Since processing is so fast, there should not be any real difference if you work on reconstructed or "real" data. Secondly, it helps in any sort of lossy data transmission. Here you typically use more shards, and checksum each of them. If any checksum fails, reconstruct the shrad. This is very useful for backup, if someone still uses DVD's, tapes, etc. The PAR2 tool serves a similar purpose for that, although PAR2 has some problems with its math, that makes it unable to reconstruct in some rare cases. 
I don't really see Elixir as an alternative to Go but nevertheless interesting read for all Golangers. 
Holy cow, Argus. I'm reading these comments as a primarily C#/JS dev, and I don't understand why everyone is defending unreadable code. Maybe I need to read golang more, but the arguments of "that's what comments are for" and "you'd understand what b.n is if you read the entire function and Writer documentation" or "anything except lowercase burns my soul" are entirely unacceptable. Variable names are a tool for the developer. The runtime doesn't particularly care. If this is the kind of crap that the golang community and its libraries cultivate, my interest is waning.
Happy to see some people get to like multiconfig. We use it in all our apps and I myself use it in my personal projects too. It's really very capable and highly extensible. It has really nice features, such as converting a struct field of `FooBar` to a `--foo-bar` flag automatically. You can even add your own configuration loader and extend it. Let me know what you think about it.
And about migrations? Gophers tend to use raw sql in the data layer, but migrations isnt a thing that i can live without it, what you guys using?
http://research.swtch.com/interfaces
Also, QR codes use Reed-Solomon, so each bit doesn't have to be decoded perfectly, for your mobile to make sense of them. Here is a nice article by Russ Cox of the Go team: http://research.swtch.com/qart
&gt;That being said, have you tried writing a web app in Go? You can do it, but it isn't exactly entertaining. All those nice form-handling libraries you are used to in Python and Ruby? Yeah, they aren't nearly as good. You can try writing some validation functions for different form inputs, but you'll probably run into limitations with the type system and find there are certain things you cannot express in the same way you could with the languages you came from. Database handling gets more verbose, models get very ugly with tags for JSON, databases, and whatever else. It isn't an ideal situation. I'm ready to embrace simplicity, but writing web apps is already pretty menial work, Go only exacerbates that with so many simple tasks. I don't buy it. This is the reason I CHOSE golang for webapp backbends. I want flexibility in handling requests and responses however I see fit. With these heavy frameworks out there you're often forced to stick with doing something one particular way. I'm not saying Go isn't a bit verbose at times, but I tend to like it. With gofmt my code is very readable. As far as form handling... Reflection package is pretty damn amazing IMO. I'm not such a stickler for speed (go is faster than anything I came from anyway) so I'm not sure about how quickly the reflection package can handle things vs other languages/framework. It's just so easy to go in and write code in Go ... Its easy to change code in Go. That being said it's a good read, always good to know other tools and where they shine.
Just making sure you have checked out Effective Go. There's a section on interfaces https://golang.org/doc/effective_go.html#interfaces_and_types
`b` gives you context, number is bytes left in the buffer. `n` is declared in the code so you already know that it was number of bytes written. The part that is being missed is that names won't give you context only the code can, so stop typing to put context into names that doesn't help any.
A lot of it depends on personal preference, to be sure. There's definitely something about our brain that let's us grasp short letters more easily *once you're familiar with their meanings*, though. Have you done much math? There's a reason everything uses hyper-condensed notation; it makes it much easier to manipulate. But there's a lot of spin up time in learning what all the notation is, and getting into the current context. I think for something like the given example, where it's all private variables of the implementation, it's pretty reasonable to be brief.
This has already been on /r/golang, but contrast with my [Go: More UNIX than UNIX](http://www.jerf.org/iri/post/2931). Actually, re-reading this post again, looking for the UNIXness, it really doesn't make its point very well. It's just a throwaway sentence at the end and tangential to the point, I'd have removed UNIX from the title, honestly, because it's got enough other content in it to stand up on its own. (I don't necessarily agree with it as a matter of opinion, but it's still got enough meat.)
Great job. I'd love to read a blog post about optimizing Go code with assembler.
&gt; If you spent more seconds in the article, **you will find how multiconfig improve things dramatically** false
to get the hex value just use the method: https://godoc.org/labix.org/v2/mgo/bson#ObjectId.Hex I agree that its confusing. The problem here is how you print the result. ObjectID implements the fmt.Stringer() interface which would give you a nice output. But you cast the type to string, so it loses all informations about its type. Try printing the value with fmt.Printf("%s", id).
Again as was pointed out here before (and many claimed that they don't see this happening) here's another functional language person that feels the need to explain why their functional language of choice should be used over Go. Couldn't the article just stick to why the author uses Elixir instead of setting it up as an alternative to Go? Let Elixir stand on its own.
Thank you, I'll have a look
Author here. I saw /u/olahol's post about [greasyphone](https://github.com/olahol/greasyphone) the other day, which lets you play NES games on your PC using your smartphone as a gamepad. This reminded me of something I wrote a while ago that lets you do the same thing for all games on your (Linux) PC. I've just spent an hour tidying it up a bit so it works again, in case anyone wants to take it (or the idea) further.
And I do agree with having non cryptic source code, I don't however feel that gophers are being "lazy" because there is a level of standardization present in go that isn't there in other languages, plus with type casting it takes out the guesswork of what a variable actually is nor does one have to inspect an object just for the purpose of type discovery 
It doesn't seem like you have cookie auth middleware.
Thanks a lot, and would just be happy to have someone else take a look at the src :) We are currently using Bamboo at my work in production and its working ok, but I wanted something a bit easier to deploy and with less complexity. I have also done a bit of testing with moxy and it feels quite ready to handle a bit of load already, so I will probably start soon to replace some of our Bamboo instances with moxy. On top of that moxy became a side project for me to learn more Go ;)
&gt; It is mostly about which programming language is suitable for which job and just get it done with. You'd be surprised how few workplaces are okay with that. There are all kinds of people out there that refuse to budge from their favorite toolset, at the expense of personal development *and* the betterment of the solution both.
Choice of language may matter when it comes to maintenence and new members of a team. I know some Perl shops are struggling in that regard. 
Are these talks being recorded?
Yes indeed. Location is an important part of a job offer as, sadly, I'm not as mobile as I'd like to be.
Go compiler and surrounding tools have some code style guidelines, but nobody forces you to use them in your own projects. Actually many people prefer camelCase naming in their own packages. To be fair, camelCase has its flaws - its adds sufficient amount of "dots" for your eyes to recognize and create text in your mind. It takes even longer to read code properly. While it can be better for new team members, the old ones - who are already familiar with codebase, are actually getting tired of reading this "containerIndex" variables. They know what n stands for and that shortage helps them understand and code faster. But at the end of the day, its just the matter of personal preference. And Go, as language, even with go fmt, doesn't force you to any specific variable naming, so you're free to choose whatever you like. I never seen any github Issue about renaming variables in go projects. For anyone who thinks differently - look at docker or camlistore or cayley code. The last one even mixes shot one and camelCase. P.S. This "Worship of the gods" is beginning to be really disturbing. Go creators sad, that they created Go for practical reasons, and language HAS flaws. It's not perfect, it's not supreme - it's just a good and simple tool for writing applications. Yet, I still see people, who use famous "go community" names like its supposed to be ultimate answer to ANY question. We are engineers here or what? 
I don't think I fully understand why you must lose some of the reliability guarantees. Unless you're making a point about the question I have, which is: Does GAS do queuing? If the connection is down, does GAS queue messages in the interm? because if not then this has pretty limited use.
Has anyone here tried https://github.com/Nomon/gonfig ? That's the one that caught my eye last time I researched this, but I haven't gotten to try it yet. It also seemed lighter weight than viper but without losing the features I wanted.
Very nice explanation of how it compares to PHP, definitely helps me to understand it better. I was mostly confused also by seeing empty or nil interfaces that duck typed structs and could do things in a more dynamic fashion. I do like the fact that go mostly enforces static types and it takes a lot of the guesswork out of variable typecasting (imo one of the biggest caveats of dynamic languages is needing to dump the var and pretty print it to see its structure). I wanted to see what the benefits of either side of the coin. For obvious reasons, static typing leads to less computation overhead (again one of the pitfalls of dynamic runtime compilers) and is usually less error prone at runtime. But thank you for this, as I was mostly trying to figure out how to get string values from an interface and hit a roadblock there. There's lots of good well written documentation but most often requires a lot more thought to understand first, rather than "shoot first and ask questions later"
&gt; Couldn't the article just stick to why the author uses Elixir instead of setting it up as an alternative to Go? Let Elixir stand on its own. How is that different from the blog posts of using Go instead of C++, Java, Python, Ruby, etc? Sometimes you talk/write in regard to a base reference. I don't see any problem with that, and I actually think the idea/concept is transmitted better if the audience already knows the base reference.
Ah I see. I was mostly confused about how the variable, i, was kept in memory. I am thinking it is because nextEven is a reference to makeEvenGenerator, and as long as nextEven is accessible, then i will not disappear. Is that correct?
This is a slightly cleaner approach and the type of your global will be Commenter rather than Container. http://play.golang.org/p/-aE6FUmrGU A more elegant approach would be to use the factory and driver patterns. That way you can change the type of Commenter that is constructed based on a build tag, a test file, or even a string.
Ohh... that's neat! Thank you for sharing.
Just use plain-ol DI: 1. Inject dependencies onto structs where the funcs that need access to the deps are methods on the struct. 2. Wire up the dependency graph by hand in the main function. 3. Eventually, where needed, create factories. 4. Once there is significant wiring and factory logic, consider a DI framework to centralize and streamline initialization logic.
I think you're probably right. I also think an advantage of the basic approach would be discouraging the direct access of dependencies beyond the bare minimum, which would be evident in step #2 becoming a nightmare.
&gt; It always seems to be Haskell or Erlang folks making pitches. For a while you could find someone pitching these in comments on many Go articles in a tone that would make you think that something was terribly wrong with using or liking Go. I would say that is related to the point of view of where we are in a discussion. Probably there are people of C++ that will make the same critic of Go people always saying that compilation is slow, language is bloated, etc. It never feels good to see something that you like being criticised; that doesn't mean that it is an invalid criticism. Different people, values different things, differently. But I understand your point. Regarding the article, I actually think it's a little poor. Lot of text for very little substance. But the last thing that crossed my mind, is that the author was bitter about Go.
In the sequence: 1. Send A. 2. Send B. 3. Send C. 4. Receive a message acknowledging C somehow. TCP guarantees that the remote has received A, B, and C. With this approach, it is possible that a disconnection and reconnection happened at the right time, and _only_ B was lost. Without additional work, something like this is unavoidable. There are many ways to push around how you pay for that if you want to fix that, but you'll have to pay somehow. This is only an example of the general problem. With some assumptions that are actually reasonably likely to be true of a Go program, one can also construct scenarios where the remote end effectively receives the messages out of order. Of course, if it so happens that all you were planning on doing when a connection is lost is reconnect and try to keep going, a perfectly valid use case (though one behind to wonder if you shouldn't be building on UDP instead), this is a fine approach. Users just need to realize this is a fundamental change in the contract, and is no longer a TCP connection any more. It's a different protocol that is implemented with TCP. Or they can adapt the protocol. Or, as I said, you can wrap a higher level protocol on top. With a bit of work I could name real systems that do all of those things, there's nothing wrong with any of them. But you don't get "a reconnecting TCP socket" for free. And let me emphasize one more time, this isn't intrinsically _wrong_, just _different_, and anyone who wants to use this should know and understand that, or face some very unpleasant debugging sessions.
The criticism isn't the issue. I've read plenty of complaints about Go and have my own. It's just a specific tone from a specific crowd that sticks out. I mean just look at the title of this one. It's pitching a language as a Go alternative targeting Go users in particular as if the need to be shown something better. I just recently read an article about switching to Nim that talkeed about why Go didn't fit their needs. I didn't get the feeling there that I should be looking to abandon Go.
Very well written. Thank you for sharing this
I've been setting up my applications in an MVC like fashion, where the models of business logic go in one folder, and the controllers and views in the others. Then I import them using import("model/modelname") and so on. Then you can use modelname.FunctionCall() to use them. Keeps my code nice and modular, and my main.go is only about 10 lines at most. The main package mostly just serves as a bootstrap and I can swap out packages as I see fit. 
I believe they are
How do you do your dependency injection?
It can definitely be said on Java IDEs, which nowadays is defined to be equivalent to a Maven project. Simple is not something I'd say lightly on `go build`. We have `internal`, URL redirection for `go get`, rules for selection of branch tags based on current go version, etc.
just have separate directories for the separate executables. main\main.go and redisclient\main.go (both in package main), which are then buildable with go build main/redisclient and the executables will be called main and redisclient.. or go build/install ./... to compile all your code, including the binaries. or put them in a separate frontend-directory and then you can do go build frontend/... 
Just added support for multiple files streaming.
What do you mean by "fully tested"? 
&gt; Why do we receive a message acknowledging C but not A or B? I think you've got a fundamental misapprehension about what I'm doing here, and a fundamental misapprehension about how you analyze network traffic. True analysis of this sort of thing takes real math, but a passable approximation can be obtained using normal human reasoning if you imagine that there's an [evil leprechaun](http://img1.wikia.nocookie.net/__cb20100127013737/villains/images/3/3f/Leprechaun.png) sitting on the wire, and it's his job to _screw you over in every way he possibly can_, and you have to stop him. Anthropomorphizing is dangerous in general, but you can turn it to your advantage here. This leprechaun is all-powerful, too; he can flip bits. He can spontaneously create new traffic. He can cause dropouts whenever he wants. He can plug your network wire in to his vacuum cleaner and generate nothing but noise. He's an ass, and you hate him, and he hates you. So the point isn't that there is some specific protocol I have in mind that we respond only to every third message or something. The point is that it is _valid_ use of the network to send two messages that wouldn't be ack'ed, followed by one that is. Perhaps the first two were advisory and the third was an RPC call... it doesn't matter, the point is that it's legal, and it happens all the time. Your job isn't to ask "Is there a possible world where everything works as designed?" Your job is to ask "What's the worst possible way the leprechaun could screw me over?" In the case I was constructing, the sender could send A, then send B, then receive a disconnection. The recipient could receive only A, because the leprechaun ate B; when a TCP socket is disconnected, you _do not_ know how much of the stream got to the other side. gas transparently reinitiates the connection, which the leprechaun graciously permits, because he is snickering up his sleeve at what is coming. The sender then sends C, and receives the answer for C. As I mentioned in my first post, if you get the ack of C, TCP _guarantees_ that the recipient has received A and B. TCP itself won't let C through to the receiver until A and B have arrived. It guarantees order. A gas-backed auto-reconnect may not. The evil leprechaun has a brother sitting in the receiver's chassis, too, and he does the most evil thing he can imagine to the remote computer. Suppose you do the sensible thing, and start a new goroutine for each connection. Suppose the sender sends A, which the first evil leprechaun lets through, but then cuts your connection. gas reestablishes it, and you send B, which is received by a new goroutine. On the receiver's side, the brother has created a situation of high load, and he sets it up so that the goroutine processing message B is scheduled before the one for A. In a single TCP stream, it is guaranteed that the recipient will receive A, then B, but with gas, the evil leprechauns can fiddle with things until the order guarantee is no longer in effect, and you may do B before A. (Consider the case where A creates something and B modifies it, if you need something more specific. You may have a case fail that shouldn't because you tried to modify something that doesn't exist yet. Within one TCP connection, you would at least be guaranteed to receive the messages in order. Of course, you could screw up the threading, which is _also_ well modeled by the evil leprechaun, but that's a separate discussion for another day.) So, the point is that I've constructed a case where you're just chuggin' along, doing things that seem sensible to you, but unbeknownst to you, the behavior of gas introduced new ways for the leprechaun to screw with you. My point is that you need to know about these new ways for the leprechaun to screw with you if you want to use it. As I said in the previous message, it _may_ be the case you don't care about any of them, in which case, gas is a nice solution. But you need to be _sure_ you don't care, because if you _do_ but you use gas anyhow, you're in for a world of hurt someday. It turns out, and I want to make it clear I'm being dead serious here despite the amusing mental image I'm trying to evoke, that as you scale things, the "evil leprechaun" mental model comes closer and closer to reality. Pretty much any nasty thing that can happen, will. It's very important to make sure the bad things you don't want to happen are impossible, because otherwise they _will_ happen. 
Thank you. If you need help / got questions don`t hesitate to open an issue at https://github.com/trivago/gollum
&gt; From my point of view, this is basically supposed to be a "best-effort-at-least-once message delivery" layer on top of TCP. Then you ought to document that. I suspect you understand what you're doing well enough, but the way you've written it makes it look like "auto-reconnecting TCP socket" to a lot of people, which it isn't. I'm trying to say this every time, so I'll say it again... there's nothing _wrong_ with this, as long as you understand the needs, and if it does meet your needs it's good software engineering to abstract away the underlying reconnect. It's just that you need to understand a gas connection has different characteristics than a TCP connection. And there's nothing wrong with _that_, either... a net.Conn does not intrinsically promise TCP, which we can tell by the way it'll happily do UDP too, as well as raw IP. SO_LINGER, for what it's worth, handles closing a socket normally... it can't handle spontaneous failures of the stream, because that's not possible. You can not know what has been received on the other end in a failed stream without more higher-level acknowledgments, which causes its own infinite regression problem with acks.
I wrote up something I call the [environment object pattern](http://www.jerf.org/iri/post/2929), which I still prefer to anything I see linked in this discussion as of this writing. Also, note that if all your setter does is set something, you might as well just have a public member. You're doing more paperwork than you need to. (Heck, all these other suggestions are doing more paperwork than they need to.)
Works great and crazy fast compared to par2. Thank you for sharing.
Similar is http://research.swtch.com/names (I was surprised I didn't see this link in other replies). In particular, some people here seem to neglect the half of these recommendations that explicitly say that global (or otherwise rare or distant) references need to convey more information and therefore should be somewhat longer (but `longerDoesnotMeanEntireSentences` like some of the `examplesInThatLink`).
Got it, sorry about not mentioning it here. We want people to work in SF long-term, but ok with having people remote for 3-5 months and then relocating. I know it's not ideal and there are really good Go engineers all over, but we're trying to grow our SF team right now...
https://github.com/smartystreets/goconvey Runs tests on package and sub pkgs, does coverage. Not sure about the last bullet on your list. You can ignore the whole new way to write tests with goconvey, it works fine with standard Go tests.
Would love to see this get traction....Slack is imho a little expensive considering it is basically a pretty IRC, and you have to wonder how wise it is to put all of your company's private communications into the database of a startup.
Ha. This looks pretty neat. I had seen goconvey but I was under the impression that I had to change my tests to use their BDD-style of test so I never gave it a try. 
If you work at any large enterprise, there is a big limitation on which data you can integrate. This is a big change. As an example, companies that work on healthcare information are guided by HIPAA. Self hosting is a must.
Missed a divine opportunity to name a library "goquests"
There is also [kaiwa](http://getkaiwa.com) which is based on XMPP, and is under the MIT license. I do like that the MatterMost project is released under the AGPL, though.
[**@mholt6**](https://twitter.com/mholt6/) &gt; [2015-06-17 14:51 UTC](https://twitter.com/mholt6/status/611184506070962176) &gt; Specifically designed to make you feel legit while programming ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I couldn't figure out what to name the library so I just went for slapping a `g` onto `requests`. The name can always be changed....
Not true, there are two parts to goconvey, the BDD library (which is built on top of the "testing" package), and the runner, which actually just runs "go test" on all your packages when a change is detected.
It's very hard to undo things when you are building something with many users. Once something is there, people depend on it, and any changes you make will break people, which makes them unhappy and less likely to keep using whatever it is you are building. The Go 1 compatiblity doc (https://golang.org/doc/go1compat) is an explicit promise, both to our users and to ourselves, that we'll not do that if at all possible. But the flip side is that we have to be very careful about what we put in. If we're not happy with it, we'll still be stuck with it for a long time. You could argue that we should just say certain things are experimental and can change, and if users depend on them and break, well, too bad for them, they were warned. But that's really still a bad experience for users. It's very easy to depend on something without realizing it. So we drew as wide a line around that promise as we could. Any new thing we do can have surprises that might cause pain or make us wish we hadn't done that, but surprises are far more likely in the "things that are not well understood." So that's really the justification. For the second half, being against "things that don't work well with Go", it seems like that should be self-evident. :-) 
+1 goconvey is awesome. BIG GREEN DASHBOARD 
Thank you for your suggestions! I have update the code to cleanly pass golint and added the capacity to the channel.
Have you guys thought about breaking out the two pieces? They don't really seem to need to be together.
Besides docs, this should be converted to expose a library and allow users to use it. If that's not the plan then it should be stated as such. It's also missing tests. If you want some pointers to how to get this done, reply here. 
Read on HN that this also relies on Ruby, Node, MySQL and Redis?! OK, update: install instructions confirms: https://github.com/mattermost/platform/blob/5bc0a19953a4c66058da08e7d560a01b0d428607/scripts/README_DEV.md
Yes, actually. https://docs.google.com/document/d/1R72jRHDdbadhn1TC9SXvZSccrWAphYpkjpVYklhLzdk Never got around to it, though - didn't have enough time.
Would you like to accept applicant of any Chinese developers?
Why is this getting downvoted?
Probably because it's a link to a sales page without comments from OP so people think this is a spam submission?
I don't have your restraint. Oh God! Why!?
He never answers: http://www.reddit.com/user/God
Perhaps, perhaps not. Your example code does not use the 'Animals' interface type at all. You could remove it and it would still compile and run. That is because 'a' is of type 'Animal struct', so the call to a.Speak is resolved at compile time. Secondly, your Animal struct type does not implement the Animals interface because the Animals interface requires a method called Speak(string) which takes a string, while Animal.Speak() takes no arguments. To make your example use an interface (not that it needs one, but just to illustrate), something like this would do: type Animals interface { Speak() } ...&lt;Animal and Animal.Speak as you have them&gt;... func main() { var i Animals i = Animal{"Cat"} i.Speak() } 
The examples in the README the calls to Get and GetAsync should be prefixed with the package name.
Tbh this looks quite smooth. Hmmmm.
1. Thank you! 1. I modified the code so that the `http.DefaultClient` is used unless a custom transport is *needed* [1](https://github.com/levigross/grequests/blob/master/request.go#L244-L246) 1. I am reworking the responses to be more robust (and not hide errors)
&gt; This is nitpicky of me, but... &gt; CLAs almost never assign copyright, so you still "own all the rights" to your code. You are free to relicense, sublicense, sell the copyright assignment, etc. &gt; The CLA just adds an explicit step in which you grant some third party (usually a corporation or foundation) a perpetual and irrevocable license to the code. Some CLAs also give the third party the right to sublicense or relicense the code. If you're a permissive license type, that's probably ok, but if the project is GPL or LGPL, for example, you might be less ok with that. &gt; Always read the CLA before signing. Yes, exactly. It's usually the re-licensing terms of CLA's that I object to. There's nothing wrong with this at all, it's all very open. I just a personal choice not to contribute under these terms to various projects.
Sorry for the zero contribution comment, but the name `controller` bothers me enough that I am making this comment. Go community have already made naming conventions around router, multiplexer, and request handler. Controller offers nothing new and instantly sticks out when comparing between projects. After taking a closer look at the `controllers` package, a few things sticks out: `ServiceControllerImpl` is Java naming convention to indicate that a particular `Class` implements a certain interface. Since Go `struct` implements interfaces implicitly, this type of naming convention is no longer relevant. Furthermore, I don't see any `type interface` anywhere. `Register()` method does not add any value and instead, forcing this controller to only work with `github.com/gorilla/mux`. It's so much better to just expose `single` as `Single`. Lastly, passing dependencies through constructor function is a trap full of busy work. Whenever you add a new dependency, it's a search and replace galore. The workflow is much simpler if one were to use `context` object, e.g. http://www.gorillatoolkit.org/pkg/context. `main()` can simply set all dependencies into `context` object and every request handlers have access to it. This makes testing setup simpler too since you can create test specific `context` object.
That's certainly a fair question. There seems to be a need for realignment regarding the mindset of many dynamic language web dev converts (of which I am one). The code is generally far too verbose and looks like Java. Function bodies in Go often look like formulas rather than an abbreviated todo list (as I am accustomed to when writing Php code). The code context should imply most of what is needed to know without requiring long names for guidance. This issue even brings in the penalty of very long function definitions. Long lines can be acceptable, and more readable, but first cut down the length of var, field, and object names. More so, try to avoid naming a string "SomeString". The author is using the term "controller" in place of "context object". "Context" would be better, but that is ambiguous. Something such as "RefServer" might be most suitable. Not only is naming important for looking back at old code, it also helps set the tone of reasoning while first writing it. This is also to say that there is some mixing of request context and server object dependencies. Handler functions come across somewhat as an after thought in the discussed source. This is possibly linked to the mental overflow brought about by the "mixing" issue I mentioned in the previous paragraph. http.handler and/or context+http.handler function chains is the most idiomatic solution. (I enjoy plugging this, it makes me feel as though I have something great to offer the community - https://github.com/codemodus/chain.) While the author could replace Negroni with my own Chain package along with reorganized dependency embeds, they probably shouldn't be using any function chainer at all (just nest the two needed functions) unless the momentum of my suggestions brings about increased use of handlers. Lastly, organizing packages by topic rather than by well organized dependencies reduces orthogonality. There are a few other minor things like there being "New" functions which are verbose and don't do anything interesting (e.g. NewReferralCodeController), but with shortened naming, it probably wouldn't look as mired as it does now. While I'm relatively confident in my opinion, please be cautious as I didn't dig too deeply into the discussed code.
Ultimately I believe that the right way to write handlers is to use an injection mechanism at run time (like Martini). The OP code is a mess to maintain and to test. In an app with 500 handlers it wouldn't scale. Some dependencies have child dependencies. Service location is handy when configuring a complex applications. That's no mystery, what works in other statically typed languages works in Go too. All the Go webapp codebases I've seen that do not use injection are an unreadable mess. Go allows very little reflection so claiming injection is "magic" is ridiculous. On the contrary, injection helps fight the temptation of using globals. 
Yes, we accept applications from any developer that's interested in Iron.io. As I said below, if you're not in the San Francisco bay area, can't relocate right now, but are willing to relocate within 3-5 months, we'll try to work something out.
Storing all of your handler-wide deps in a context—which is an `interface{}`—is not ideal either. You need to write getters &amp; setters to type assert your dep out of the context map, and a bunch of `const myKey type` to provide fixed keys that you don't want to typo. At the same time you don't have to go straight to globals. Create a struct that accepts a handler and your application env—or create your handlers as methods on a struct (or structs; if you wish to have multiple types) that embed your deps - e.g. `func (e *Env) MyHandler(w http.ResponseWriter, r *http.Request) { ... }` or similar approaches. `main()` can then just pass your `*sqlx.DB`, your `*sessions.Store` and whatever else you have straight into the struct before calling your routes. PS: I wrote about my approach (i.e. what works for me) here: http://elithrar.github.io/article/custom-handlers-avoiding-globals/ — although my handler signature has changed a little since.
Globals are not inherently bad, especially for (ahem) global dependencies like database connection objects/factories. Personally I find Martini-style frameworks (heck, frameworks *in general*) distasteful in Go. Let go of the baggage from $LANGUAGE.
Today interfaces finally "clicked" for me today... these are the droids ive been looking for.
That's the thing I don't understand, these frameworks really don't provide a lot of functionality that can't easily be replicated by the standard library. If you're just starting out with Go, you should definitely learn the standard library before you start bringing in monolithic frameworks. Then, once you've learnt the basics of the standard library you are in the position to decide whether this library is actually worth your time or not. Which of course, it isn't.
At UserVoice we use (and build!) [gocraft/web](https://github.com/gocraft/web#your-context) which allows us to use context objects with request handlers. I used Martini a little bit before we built gocraft/web and liked it quite a fair amount, but we make heavy usage of Context objects in most of our apps and this allows us a natural way to tie them into our HTTP stack.
That's exactly what I'm recommending - if the struct members are thread-safe you can just (for example) create handlers as methods on your struct type, or pass the struct as another argument to your own handler type. 
I know where the author is coming from. I run a fairly popular programming-related event, and we've had a person email us saying that he had signed "the CoC pledge". This means that he would be boycotting our event until we had created a Code of Conduct for it. It was confusing at first, and it took a few emails back and forth to understand what it is he was asking for, or what injustice he was fighting so hard against. I went and read the example Codes of Conduct that he had sent to us, and I couldn't help but feel that they all went too far into censorship territory, even though I did agree with a few of his points about real problems that needed addressing. This NCoC thing makes perfect sense to me in that context. I don't agree with everything in this document either, but I understand where the author is coming from, having been through a similary thing myself.
&gt; it works fine with standard Go tests It works incorrectly with some tests. Imagine you have the following function in your code: func SomeFunction(...) { if condition { panic("...") } } In tests you want to make sure it panics in case of certain condition: func TestSomeFunction_PanicInCaseOfSmth(t *testing.T) { // Make sure the function panic'ed. defer func() { if err := recover(); err == nil { t.Error("SomeFunction was expected to panic, but it didn't.") } } SomeFunction(...) } This is an absolutely valid test in go that should pass if `SomeFunction` panics. But, goconvey doesn't think so.
I just posted on the HN story, but I'll say it here too: You _should_ change your package to remove all attempts at being "asynchronous" for us. All Go code is _already_ asynchronous, in the way that people care about lately [1]. You aren't _making_ it asynchronous, you're _forcing a particular choice_ on us, which actually _reduces_ the utility of the library greatly. You really, really should remove it all. [1]: I mean, yes, technically it's still synchronous, but since _certain communities_ came along and taught everybody the false idea that "Synchronous" means "The whole process blocks", well, all Go code is already "asynchronous" in that it doesn't block the whole process. Within its goroutine it is still technically synchronous but since _certain communities_ decided to change the meaning, I guess that means less than it used to.
Sure, it's just a case of someone writing a Windows implementation in `input_windows.go`.
Actually, due to how caching works if you set ETag it may be more efficient. If you actually want to serve separate JS files, you could embed them into the relevant templates.
so handy :) thanks
Trying to write my first Go slide, I really hope that it had adopted the simple markdown as the mark up language, instead of forcing everyone to learn yet another markup language. If so, the two problems that I just found would not be a problem at all. 
The net package is quite good. Stdlib is enought for a lot of things.. 
Agree. But being a google product, you really can't keep it to yourself, no matter how hard you try, isn't it? :-) https://groups.google.com/forum/?hl=en#!searchin/golang-nuts/presentation$20tool/golang-nuts/6162hejza6w/7u-81AfBTG8J 
It's not a Google product. 
I agree, this is a valid test. I haven't run into this in use of goconvey. File a bug report?
Not everything written by a Googler is a Google Product. Not even if they did it as their day job. In particular, go is not a Google Product (as far as I know Google doesn't even hold copyright, but it's © "The Go authors").
If you think about it, markdown is a *really* crappy language for presentations. And yes, I know there are tools out there, that pretend that that's not the case. But in my experience they a) don't use markdown (but a dialect) and b) they aren't really fun to use either and produce crappy results often.
Reflection is SO SLOW
My attempt at it: https://github.com/opennota/linkify
Greenspun's 10th rule applied proactively.
maybe RethinkDB support? ;)
It's really about the same thing, but not making it look like a test is certainly less confusing. The test way is nice for backwards compatibility with older versions of go, though. If that's not a factor then certainly the testmain way is cleaner. Thanks for that example!
Added a section on performance considerations, which includes the data stored in db.
Suggestion: Test against text with [these test cases in twitter-text/conformance/autolink.yml](https://github.com/twitter/twitter-text/blob/master/conformance/autolink.yml#L402)
How to write a REST API in Go: 1. Completely ignore the standard library. 2. Import not one, but two frameworks! 3. `// Code!`
When we ran our first CPU profile, 60% of CPU time was in JSON processing. Switching to a non-reflection JSON parser (code-generation) was something like 3 times faster
in func location(name, city string) (name, continent string) you are using the variable name twice. Change the second name to n or something. Then it should compile.
Thanks for this. I've fixed a couple of edge cases.
Very interesting. Would have been great if you guys would have put up some metrics and code example. I'll definitely look at options. I use the json parser quite a bit but don't have anything in place to measure metrics and performance of it. 
If you haven't been through the [tour](https://tour.golang.org/welcome/1) it's a solid intro
*MargaretThatcherIs110%Sexy* and this is a password that is 110% memorable ;)
Enjoy :) https://github.com/manishrjain/gocrud/pull/3
[Was that your password? 'Cause all I saw was a bunch of stars.](http://bash.org/?244321) :-)
Seems like my diceware passphrase generator - https://github.com/natefinch/diceware
HTTP/2 changes this, but we have time to adapt, so I wouldn't worry too much about it for now. 
They disabled GH issues and I don't feel like I want to send them e-mail.
I think last time someone was using "Learn X The Hard Way" for his book, LcodeTHW series author was very unhappy. Cannot find the conversation and don't remember the details, but I think it would be polite to ask Zed if he does not mind. 
lol
Where do you usually deploy your Go apps? I'm developing a Go+Postgres+Redis app and so far I think AWS and Heroku are the only viable options. I like Heroku but it is just too expensive. For example the smallest database with a backup node costs at least $200/mo. 
Been back and forth on the idea, do you think it is necessary for security reasons? If the point is to generate a *memorable* password, probably the constraints imposed on the password to make it memorable outweigh any benefit of a strong PRNG over a weaker one. I ended up using math/rand instead as it is faster, especially on VPS.
I have only got the impression that he encourages others to use the same concept for their own work. There is a [git repository](https://gitorious.org/learn-x-the-hard-way/learn-x-the-hard-way/source/663fd4f6afd17f9d16fe10bafe3e64fdfb29e629:) which is a skeleton latex project for making a 'learn x the hard way', which was linked from learncodethehardway.org. I don't see any mention of having to ask Z. Shaw for permission before doing anything any place.
And I would have to agree. The "Learn X The Hard Way" is designed for _beginners_. My first language was c++ and as such I think Go is a fine first language and a "Learn Go The Hard Way" could be a great addition to the series. However, if this is not targeted at absolute beginners, you should very much re-evaluate the title. 
Hrm, you may be wrong. http://c.learncodethehardway.org/book/preface.html &gt;Finally, don't forget that I have Learn Python The Hard Way which you should read if you can't code yet. **LCTHW will not be for beginners, but for people who have at least read LPTHW or know one other programming language.** The title will be good if the book's good anyway.
Go half way and use BoltDB. It's more optimized than querying a config file and doesn't require a database engine to run so you don't sacrifice portability. 
http://regex.learncodethehardway.org/book/preface.html The regex one is not aimed at people who have never coded, just beginners at regex.
As an important aside to the topic, I suggest changing the domain and correcting any other content in which you refer to Go as Golang. Golang is the search term, Go is the language. On topic, I look forward to seeing what you put together. Also, so far, I have not felt the need to reach for a book while learning Go. How will this relate to the official learning avenues such as the docs, tour, etc.? Edit to add: By "etc." I mean the official and unofficial blogs. It seems to me that new programmers and seasoned programmers have ample resources. It might be useful to target specific languages and dispel certain mindsets and tendencies which are detrimental to Go projects.
If the structure of the processed results is very simple then you could simply write it to a file and read it back in on the next run of the program. Either write that code yourself or look at using an encoder that takes, e.g. a `struct`, and *serialises* it for the file. http://golang.org/pkg/encoding/
Panicing in handlers is a faux pas. Instead just log an error and return an appropriate HTTP status (500 or whatever).
In sub.go, you are ignoring the error return of all db functions (eg. line 44, Get() method could return an error). You should instead change your *Sub functions to return this error to the handler and follow gohacker's suggestion.
First thing I noticed is that all your code is in main package. For a small API it is not a problem per se, but generally it is better idea to decouple your code into packages, and expose (make public) only necessary things. For example db declared in main.go is accessed in sub.go as well. I would suggest creating for example dba package, where all your db code lives, and you can control access to database by exposing only needed functions. I also support what /u/gohacker and /u/michaelbironneau said. Never panic in handler. Actually avoid panic in whole user request flow - just log the error and return some error code. Panic is for unexpected errors, like failing to connect to db in main.go:34. Also, where those panics are invoked, you are writing those errors as json to response. My usual approach to handling errors is to define few common errors (404, 500, etc...) and write them instead. I know error checking can be bothering at times, and you can skip it where you deem unnecessary. Fetching stuff from db is not the place to skip. Some db drivers will return error on 0 records found - you need to catch that and inform the user that results are empty. 
yea seralizing your data (to binary) and writing it to disk is the sweet spot between the two.
Good call, thank you. I've added some better error handling. Any further advice? https://github.com/shwing/moledro/commit/145e1a0c190130cb801f8fcc14b7a83e5cddab29
Thanks. I've added some better error handling. Any further advice? https://github.com/shwing/moledro/commit/145e1a0c190130cb801f8fcc14b7a83e5cddab29
This is the official site: http://learncodethehardway.org/ There's C but no C++
Great feedback. Anything else? Multiple returns in the handlers feel funky. Are my naming conventions idiomatic? For some reason I have a tendency to name functions with lowercase letter for the first word? Maybe too much JS. I feel a bit weird about having all of these functions on global namespace. I feel like it makes more sense to have things like Model.Create() Model.Get() etc. Is this just because I've been tainted by Ruby?
No, I have no problem with someone using Learn X The Hard Way at all. The whole point of making it was to help people out who want to make a book similar to mine, because the method works well. What I objected to was some guy at Engine Yard taking my Python book, ripping out the Python code, putting Ruby in, then not finishing the book, and leaving me to handle his mess. That's very different from using a simple template that helps you write a book. 
Hmm, interesting to see that I'm not the only one having this issue. It'd seem more effective if they used something like docker rather than than go cart. 
I'm not married to the idea of using openshift, just saw that it was free for small apps and wanted to test response times of a web socket api in an actual server-client scenario. The main reason was the 'free for small scale' part since I'm still experimenting with go. 
I develop locally since I'm just recently jumping into go. I've been considering Go+Cassandra+Redis though. I'd be better off building my own test machine than paying 200 a month, that is a bit much, especially since this is an experimental personal project. 
The next version is based on docker. I don't know how soon that will be released tho.
I see you repeat setting the header in all your handlers: w.Header().Set("Content-Type", "application/json; charset=UTF-8") You should consider wrapping this up into a function that you call rather than just writing the same line in all the handlers. That way if in the future you need to add more headers (such as the cors headers for example) you don't need to go update every single one.
Nice, I will take a look. Thanks!
Cool, I will check it out. Thanks!
Thanks, this is super helpful. Do you have any recommendations on getting started writing integration tests?
I started this project just to learn go, so your feedback is appreciated!
Thank you for not making another framework.
This is pretty sweet! The only suggestion I can possibly offer is including HTTPS as a configurable option.
Changing Golang to Go in the title is a good idea, but using Golang in URLs is more common, I'd keep it that way. Some examples for the latter: http://golangprojects.com/, http://golangweekly.com/, https://twitter.com/golang, https://www.reddit.com/r/golang/
It's also vulnerable to XSS attacks.
One small question. I see that you have written all the routes in gowebapp.go. What if I had more routes, how would you have split the routes across multiple files and namespaced them ?
I'm sure you're aware that using a cookie to store the number of login attempts is a weak protection against brute-force attacks.
Not really "getting started", but one of the more illuminating pieces of code I've read from the Go std lib is the builtin net/http server tests (https://golang.org/src/net/http/serve_test.go). Some of the tests are simple, some of them are quite complex, but you should be able to get an idea for what you can do. Also, the httputil package is pretty useful for http server tests. http://golang.org/pkg/net/http/httputil/
Yeah, you're right. All a hacker would need to do is delete their cookie every couple attempts and they could keep attacking. What method would you suggest to protect against brute force? Save the attacking IPs in a table? Link up with fail2ban to block IPs?
Martini is not recommended anymore. Its not very idiomatic to Go. Piecing together a framework works much better, you can make this easier by using components from the Gorilla Toolkit, or some other wonderful libraries out there. The creator of Martini also made Negroni which is a nice middleware handler. I'm sure you may have heard this before but in case you haven't, its good to look into. 
I agree with you completely. Thank you for letting others do this while also being protective of the brand and your work.
There's [BadActor](http://badactor.org) to help with that.
What's the current state of most of these frameworks. I was lucky enough to do a considerable amount of server side Go at work last year. I've only dabbled in some of the Go Web frameworks but they seem to quickly hit some wall where the complexity spikes to an unreasonable level compared to other frameworks. In some cases you need to implement your own ORM (or the existing ones are incomplete or don't quiet work as documented), or you have to implement your own transactions. Other variations of things like this continue but overall I'd say that I haven't seen anything that is usable by someone in Go without what seems to be a deeper systems or protocol knowledge than would normally be required in other frameworks.
That's why I think Go has really moved to modular tools in a create your own framework type of mindset. Which I think was the idea with the creation if net/http. As far as ORM... I use gorm, and some days I wish I just made my own ORM specifically for my app. But gorm isn't bad at all and you can make custom SQL calls. The only downside is I feel like there are unnecessary calls to the db at times with the associations, specifically updating associations. But like I said gorm is pretty flexible. I've heard good things about using sqlx just to help you build your own queries. Putting a framework together from scratch can be very difficult for someone who comes from rails who might have never taken the opportunity to know what's happening behind then scenes of his framework.
"Brute force" is not a thing you can protect against; it's a class of attacks. You really need to split your analysis of the problem up into multiple pieces before you can get anywhere with it. And to be honest, the more I learn about brute force attacks, the less I care about trying to defend against them. The only one I still find myself really caring about is brute force password checks, and probably the best thing to do about that is use bcrypt set with a decent difficulty, so that even if you hammer the server, you're limited to an uselessly low rate of checks. Trashes the server in the meantime, but there's less you can do about that than you initially think. (Won't say there's "nothing", exactly, but all your obvious ideas don't really work at scale, or work hardly any better than what bcrypt is already doing. bcrypt used properly already prevents more that a few dozen password attempts per second per core by brute physics.) You simply can't prevent brute-force bandwidth exhaustion at the web framework level... by the time it's reached the web framework it's already too late.
Haha I had to look up the term. I guess I am.
Go handles this very differently from other languages. Some developers might find this really weird because it isn't something that they are used to (resistance is fu.*). The most obvious solution is to refactor towards only one function that knows about all types. This approach is very fragile and therefore not a good idea. There is a nice article at http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go This article describes your case in detail. Go's simplistic approach to this problem is that you have to write the code separately for each type. There is no shortcut to success. Perhaps you want a special case for User struct's password marshaling. That should be placed to User struct's member function and should not be placed in some generic function that knows about each type. This simplistic approach is truly the sweet spot for Go. I &lt;3 it! Also take a look at sort.Interface. It describes an approach to sorting where the sorted type doesn't matter! 
I'm not sure if there's a good tutorial, but I was able to figure out how to use OAuth2 with Go by studying https://github.com/bitly/oauth2_proxy and various REST API client libs. https://github.com/digitalocean/godo https://github.com/google/google-api-go-client/blob/master/GettingStarted.md Finaly, have you seen [goth](https://github.com/markbates/goth)? It's a Go library that implements multi provider authentication. 
You can handle everything inside also. The way I do it is create endpoints on my server that then redirect to the appropriate provider. That provider redirects back to my *server* and I get all the sensitive information there. This way you don't store/transmit that sensitive information client side. Use https://github.com/markbates/goth and simply set up routes such as `/auth/facebook/login and /auth/facebook/callback`. I use https://github.com/labstack/echo for routing, which allows me to have `/auth/:provider/login|callback` so it can be dynamic. Once you get your callback from the oauth server, do the exchange (via goth) and store the info in your DB. Generate your OWN token that then gets sent to the client. That token is what the client uses to auth with YOU.
Thanks, I'll play around with a few and see what makes sense.
Yeah, I know what you mean. I like the idea of redis or BadActor coupled with a captcha after a few bad attempts. I know Google used a captcha a while ago, no idea if they still do it now. I just know you need some type of protection because you're right, it can trash your server while you're coming up with a fix.
Thanks!
is there a code tutorial or a github project where I can look at your solution?
Do I have to implement token management system early on? I am doing a MVP and I didn't thought I'd have to use redis so early on.
I think you need to reorder your dispatch.yaml file because the first catch all will serve up module 2 results. 
You're welcome. Yes, we can sponsor work visas.
https://mholt.github.io/json-to-go/ works for most things.
http://golang.org/pkg/encoding/json/ https://gobyexample.com/json
Is GoDoc support working? I just installed Atom and the go-plus package and I see it looks for GoDoc but I don't see how I can look up a documentation of something. It would be nice to write "strings.Split(" and see its documentation on a right-side pane, or a left-side pane below the tree view, anywhere really, the HTML rendering of "godoc -html=True strings Split"). Is this what you have in mind?
Great work Dan—appreciate the hard work you put in on this!
Looks good! Your file management is Linux/Mac only, you might take a look at the tools that allow you to work in both Windows and *nix environments. No other big issues, though.
Nice! Hadn't seen that before. Very handy.
It's a [known issue](https://github.com/mholt/json-to-go/issues/6) when an array does not contain consistently-typed values. Pull requests welcome.
Take a look at Go Report Card: http://goreportcard.com/report/gregf/podfetcher I see a couple of low hanging fruit in there. 
There is also a similar project [gofresh](https://github.com/divan/gofresh), which also works with non-github and hg repositories.
If your value types are changing for the same keys, I would re-evaluate the values you are storing. 
 $ go get [github.com/tmc/json-to-struct](https://github.com/tmc/json-to-struct) 
Thanks that great to hear :) If you have any questions I am usually available in https://gitter.im/dancannon/gorethink. I have attempted to make GoRethink as similar as possible to the JS driver but there are a couple of things to be aware of: - I would recommend always using struct tags to prevent clashes - The Go version of row("fieldname") is row.Field("fieldname") - Functions have types for example function(row) {...} is now func(row r.Term) interface{} {...} There are probably some other gotchas but I think these are the main ones.
Thanks for sharing. I have a question not necesarily directed to OP: does gorilla/sessions really need CSRF protection? It handles variables/parameters behind the scenes, not via URL queries and such. Although you could, but it is a bad practice
Nah, a simple Makefile setting the GOPATH for "go build" is as simple as it gets. "make" is faster to type than "go build", too.
Thanks, had no idea about that.
1. This is not a serious question. Or is it? 2. Totally the same. Use package html/template 3. Doesn't matter, all are good. Postgres, MySQL, MongoDB, whatever.
1. I'd say Go is pretty much made for purposes like this. So go ahead :) 2. If you mean if Go has html templating then yes it has.. look [here](http://astaxie.gitbooks.io/build-web-application-with-golang/content/en/07.4.html). There are also 3rd party templating libraries just a quick googling away. 3. Which database to choose depends on your requirements and your knowledge of the various implementations. The major ones (mysql, postgres...) are all supported sufficiently in go. 
You may not have a choice. What if you're dealing with someone else's API? Either way, though, `encoding/json` can handle [this particular case](https://play.golang.org/p/GOv_08OMAJ) just fine. ^(Writing code on a tablet is annoying...)
 Here's some sample code: http://play.golang.org/p/CG8JQePuAr I initially thought that you have to explicitly cast the marshal result, but Go handles that pretty transparently! There's an intentional bug in the second JSON string. 
[Convert JSON to Struct](http://json2struct.mervine.net/)
Another interesting one if you're interested in building a trie, I found the cutoff for []byte was around 40-50, which in most cases is also just about the largest possible branching factor you're realistically going to get for textual data. Basically the whole array comes in as one cache line and it's still faster to linear-search the whole thing than pull in even one other cache line.
Hello! Go is a great language to write web servers thanks to the excellent [`net/http`](http://golang.org/pkg/net/http/) package in the standard library. 1. The [ServeFile](http://golang.org/pkg/net/http/#ServeFile) and [FileServer](http://golang.org/pkg/net/http/#FileServer) are probably the methods you're searching for. I used both to make a Go version of woof - [goof](https://github.com/nindalf/goof/) in a couple of hundred lines. (Code is messy at the moment, sorry). 2. As others have mentioned, there is [`html/template`](http://golang.org/pkg/html/template/), though I think the general pattern is to create an API in Go and write the client in a JS framework. 3. There are good drivers for all the major databases. If you want to keep it simple you could go with a file-based KV store like [bolt](https://github.com/boltdb/bolt). Apart from these questions I'd like to add that Go is really simple to learn. Most of the people who try the language report that they're productive in a week. I think it takes a little longer to learn to write idiomatic Go code, but it'll come with time. If there's anything else you'd like to ask, be it about conventions, or the preferred text editors/plugins or example projects, I'd be happy to help :)
What's the argument for server side storage? What's wrong with client side storage?
The jsontuils seems a good starting point. I might have to do changes to what is there. Here is my problem. We express metadata of our data model in json. Here is a simple example: { "name": "Resource", "pluralName": "Resources", "parent": "Base", "description": "This is the parent class of all resources with some default attributes defined", "fields": { "healthState": { "mandatory": true, "description": "", "dataType": "enumeration", "enumValues": [ "healthy", "error", "probation", "maintenance", "unknown"], "defaultValue" : "unknown" }, "policyGroups" : { "description": "The policy group associated with this resource", "dataType": "relationship", "relationType": "Reference", "refDataType": "PolicyGroup", "cardinality": "Many" } } } I would like the mapping to be // Comments from description type Resource struct { Base // Comments from description healthState string //My comment: All references become strings which has the id of the object policyGroups [] string } The above mapping would be super useful for me to extract instances of resource coming on the wire from http calls. Does my problem makes sense? Is there a better way to do it?
Thanks a lot for taking the time to answer my questions :)
Thank you for answering :) I've been playing around with Go yesterday and today and just found out how to work with the Go workspace and now this seems quite easy...I guess. But creating a simple HTTP server with routes at least takes less lines of code than in Node. Also thank you for offering your help :)
Apologies! I should have read twice instead of succumbing to support-fatigue. :/
As a tip for GOPATH, I'd recommend doing it *exactly* like they suggest - one directory (your GOPATH), under which there is the src/ directory containing all your different projects.
I don't think that's necessary. The play on words just happens to be somewhat amusing.
Setting up a web server is super easy in Go. What I've done for my blog is use html/template for generating pages that get cached. Then I use nginx to serve static content and pull requests from the go server for blog content as necessary. Pretty easy to do. Here's a snippit from a test project I was doing to serve customized fBm perlin/opensimplex noise as images to a leafleft js map. import ( "fmt" "time" "net/http" ) // ... now in a main function ... // register the handlers http.HandleFunc("/api/map/tile", mapTileHandler) http.HandleFunc("/api/noise/setJSON", noiseSetJSONHandler) http.HandleFunc("/", mainPageHandler) // start the serve loop go func() { for { fmt.Printf("Starting web server at %s.", serveAddress) s := &amp;http.Server{ Addr: serveAddress, Handler: nil, ReadTimeout: 120 * time.Second, WriteTimeout: 120 * time.Second, MaxHeaderBytes: 1 &lt;&lt; 20, } err := s.ListenAndServe() if err != nil { fmt.Printf("Web server failed with an error; will restart. %v", err) } } }() An example of a handler is the main page handler that serves static content: func mainPageHandler(w http.ResponseWriter, req *http.Request) { resourcePath := WebRoot + req.URL.Path if req.URL.Path == "/" { resourcePath = WebRoot + mainHTMLPage } fmt.Printf("serving static file =&gt; %s\n", resourcePath) http.ServeFile(w, req, resourcePath) } Real easy. You'll find a ton of tutorials on it. So that should give you an idea for question #1. As for JSON, that's also easily done. You can serialize/deserialze structs super easy: import ( "encoding/json" ) type APIResponse struct { Success bool } // ... now in a handler function with w as a http.ResponseWriter ... output := APIResponse{Success: true} outputStr, _ := json.Marshal(output) w.Write(outputStr) Deserializing is pretty much just as easy. So for question #2, I would build a struct for your user data, populate it in normal Go code, then just marshal it out to JSON per above. Look at [encoding/json](http://golang.org/pkg/encoding/json/#Marshal) docs for further details. Sadly, I don't have enough experience to answer #3 for you.
Since you're starting out with http in Go, allow me to offer a couple of points * Stick to the standard library. A lot of libraries offer a lot of features, but they break the simple and effective [`http.HandlerFunc`](http://golang.org/pkg/net/http/#HandlerFunc) interface. Its best to stick to this, IMO. * If you're looking for more features in your router, look at the [`gorilla/mux`](http://www.gorillatoolkit.org/pkg/mux) library. * I think its a good idea to have some bits of middleware. If you've used Express.js you'd be familiar with this concept. Its easy to implement with the `http.HandlerFunc` interface. I did it in a recent project [here](https://github.com/nindalf/linkto/blob/master/middleware.go) I hope this helps. If you don't mind my asking, which text editor are you using?
What would be interesting is to add the time to populate the map vs the time to populate the slice. I always wonder if it is worth it to use a map when I extract some values from a database and i have to access them later by a key.
Why Martini? Didn't Negroni supersede Martini ages ago? http://codegangsta.io/blog/2014/05/19/my-thoughts-on-martini/
Yes, you could start off with a strong password, and then add a component relative to the service that is easily deducible for you (but not necessarily for someone else) An easy example would be to just add the first letter of the service to the password: - *MargaretThatcherIs110%SexyF* for your Facebook password - *MargaretThatcherIs110%SexyG* for you Google password You could be more fancy, say change the percentage according to the position of the second letter of the service in the alphabet, so: - *MargaretThatcherIs101%Sexy* for Facebook (because F**a**cebook, a is the first letter, so 100 + 1 for the percentage). - *MargaretThatcherIs115%Sexy* for Google (because G**o**ogle, o is the 15th letter, so 100 + 15 for the percentage). You could also have different "root" passwords for different levels of importance. You're not going to use the same root password for some shitty service than you would for your email or web-server password because you sort of expect the shittier services to compromise your password one way or the other. I'm not saying a password manager is a bad solution per se, it can be useful, but it makes you 100% dependent on having the manager installed and have your password file available. It also creates a password file that - once obtained by an attacker - could be brute forced without restrictions. If you're traveling or using someone else's computer you might not be able to access your password manager easily.
The IntelliJ plugin is being developed by JetBrains' emplyees. What would "official support" mean?
Very nice. Especially like the timeout feature. 
Can you use it for Android?
Not sure I follow... Sure you can use make, however that doesn't come by default on a lot of nix distros so a shell script seemed more appropriate. Also, the GOPATH is not just something you set only because you want to build. Every go X action runs there. e.g. "go get" to get your dependencies.
Probably an official product on the jetbrains website, right alongside IntelliJ Idea, PyCharm, RubyMine, WebStorm, etc...
Very nice indeed. That should come in handy.
hold the phone. is it native or is it just "compiling" to js/html rendered in a web view?
Ha ha ha.... Swift is the new Microsoft Silverlight :D You can build apps with JS for iOS, now GO....
https://youtrack.jetbrains.com/issue/IDEABKL-5938 this is an old but active request on jetbrains youtrack, there are currently 279 votes for this. things i would like to see are template support (context - autocompletion, etc)
&gt; is it native or is it just "compiling" to js/html rendered in a web view? It's native, but in the way that C++ games on iOS are native. You can't make a native (UIKit) GUI app on iOS with Go.
You can see lots of progress here: https://github.com/go-lang-plugin-org/go-lang-idea-plugin A Jetbrain worker is pushing alot of commits there so I think they really care, but before offical support they need to get several things working and fixxed. * Delve(Debugger) has a network api binding now but It's still not working with the plugin. * If I remember right there was some fuck up with the GoPath * You can see there alot of other issues @ Github So as IntelliJ is a good product I think they really want to make it good before releasing it.
Looks very useful, time to play.
It's not quite ready for release yet, but if you Google "golang intellij plugin" it will bring you here, with full installation instructions: https://github.com/go-lang-plugin-org/go-lang-idea-plugin
If the keys are numeric and not sparse use a slice or array. If the keys aren't numeric or are sparse (e.g., 1, 200, 5892, 2104912, ...) then use a map.
Oh hell yeah. That's a killer feature.
Yes and no. It does compile to native code (both arm and arm64) and being able to use Go as a shared library means that inevitably people will wrap the UIKit elements with Go bindings. We're not working on that part, though.
CGO may be an option, although you would basically be doing the binding work by working with the ObjC runtime. objc_msgSend(object, sel_getUid("foo:bar:err:"), var, var2, errVar); http://stackoverflow.com/questions/6322194/cocoa-bindings-for-the-go-language
Just when I thought "God had close a door", because I was just informed recently, "no current plans to support go in the NDK" -- https://code.google.com/p/android/issues/detail?id=39482. Good Job!
What is "production ready" in this context? Tested under high load for about a year? 
That is *literally* the same plugin.
Debugging is a hit or miss with GDB because GDB itself doesn't really support Go. While it's true that there might be some bugs in the implementation, I'm pretty sure most of the times the issues come from GDB itself. Delve support is in-progress.
I hate to say this, but on WWDC, Apple announced "[Bitcode](https://developer.apple.com/library/prerelease/watchos/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html#//apple_ref/doc/uid/TP40012582-CH35-SW2)", which is fancy Apple talk for compiling your apps as LLVM bytecode, so Apple can recompile/optimize and package that bytecode to the native CPU of the device downloading the app without devs having to recompile and re-submit anything, which on it's own can be pretty nice. Right now it's pretty new, but this sounds like Apple might require devs to publish their apps compiled as "Bitcode" in the future in order to be able to submit it to the app-store. For the Apple watch - it's already a requirement, and in the latest XCode, it's apparently already the standard for iOS devices. In the longer run, they might add non-standard ARM extensions to their CPU's - or even have the option to switch architectures all together. Now not that it would impossible for Go to target LLVM bytecode, but it's yet another platform...
Thanks! I am writing a [shell / template hybrid](https://github.com/miku/clam) library, and Deputy has been already an inspiration, e.g. the timeout feature. 
Few years ago I've done something similar but to build cross OS X app https://github.com/kavu/cocoa-go EDIT: not sure if it still works 
I think the app should check if node is installed and fall back to being just an api server when not
duktape performance for rendering React apps is really really bad. But I am working on a library using v8worker to render React apps: https://github.com/nmerouze/sgo (performances are better than Node.js). In my mind, isomorphism is more for SEO than the small percentage of people with js disabled. If your website/webapp is not public, isomorphism is probably not necessary.
It's an awesome tool. I'd love to use to verify builds, but we'd have to alter our policy on using deferred calls (e.g. 'defer file.Close()') first. In most cases I'd like to wrap them in a function which logs errors, but I think it's good to contain the use of `defer` to cases when you really don't need to know the outcome - e.g. 'close' on a file read seems much less important than 'close' while writing a file
I have no problem with you setting down with vim-go, but if you want to give Emacs a try, and don't know where to start, see if starting from https://github.com/suntong001/emacs.d will make it a bit easier for you. It is for me, because it is using the modern Emacs approach, and its hierarchy and "plug-in" arrangement is much more manageable and beneficial than a single humongous init file. The go setting is at https://github.com/suntong001/emacs.d/blob/master/lisp/init-code0p_go.el, HTH
Not specific to the go language, but Vim is going to be a more modern approach. No offense to maedo, but the only people I know who use Emacs are 50+. Go home grandpa. Only cool kids are allowed here.
I used that tool, but I'm not sure if the below modification is good or not. Change `defer resp.Body.Close()` into defer func() { if err := resp.Body.Close(); err != nil { log.Fatal(err) } }() So which one is better?
just tried it, feels really good, might go with this, thanks!
My set up is as you describe but the docs on golang say nothing about doing a build first in their "How to Write Go Code" page. I do the "install" just as they describe.
OP Quote "I get tired of using my mouse/trackpad."
slight problem though. Whenever I do :GoRun on a chat server I made, then I try to close it with C-C it closes the terminal but the server remains open o.O so I can't run it again until I close it because of the used port. https://github.com/neovim/neovim/issues/1234 its a filed issue, welp i guess i'll use neovim when its fully released. Looks good so far otherwise.
geany
I know - but in ACME the experience is very different, enough to not get tired anymore of mouse.
Cocoa support?
[Previous discussion, before it was released](https://www.reddit.com/r/golang/comments/304otq/stablelib_lts_distribution_of_curated_go_packages/). I want to thank commenters there for helping me figuring out what I should do better or what I should explain/document more clearly. Happy to answer your questions. 
I use Sublime Text with Vintageous (vim emulation). It's the best of both worlds for me. You get all the features of a GUI editor with the ability to rarely use your mouse. Vim would come second for me, though I've never honestly worked with emacs much.
just checked and there seems to be one for intellij idea too, thanks, definitely gonna check it out. Might not even need to switch.
See https://golang.org/cmd/go/ for documentation (or just run `go install -h`).
That is my understanding but it conflicts with the docs unless somehow I'm misreading them on the page I talked about. I can build, then install, but the docs say just to install. In any case, I'm able to make this work. Thanks.
Google Bot may be able to handle basic JS now, but I don't think it sits around waiting for AJAX calls to complete to populate the page. So if your content still isn't there on first load, Google won't index it.
I use emacs, but in a pretty simple way for Go, with a binding to run goimports and a binding to run godef, and the default go-mode for syntax highlighting. It works well. (In general emacs is a slow and bug-ridden and kind of sucks, but I'm addicted to its flexibility. I'm not sure I'd recommend using it if you weren't already addicted...on the other hand there aren't alternatives if you want something that you can run in a terminal.)
Huh. Might have missed that. Either way, it's good that the information is there.
Isn't it Vintage? Also: sublime + vintage SO HARD. I use vim on servers a lot, but when I really want to go into something, I am finding I copy it into sublime more and more.
Vintage is the Sublime-supplied vim keybindings emulator. Vintageous is a plugin that is little more complete and closer to vim, but if all you want is insert/escape mode and navigation using hjkl then Vintage mode will do it.
| It's notably insecure to have all of your business logic embedded in just your client (validations and whatnot), as a relational database alone is insufficient to represent all of your application's concerns. you don't need an isomorphic setup to validate on both frontend and backend. It's just a simple ajax call to an API to find out if the action was ok. That doesn't make it isomorphic, what makes it isomorphic is the ability to render the state of the app on the server. 
If by plans to support you mean tickets then yes, you should keep an eye on this https://github.com/go-lang-plugin-org/go-lang-idea-plugin/issues/351. If you'd ask for a time frame, unfortunately I cannot give you that. I can tell you that if someone would come tomorrow and ask for guidance to implement it then he/she would receive it (and we'd definitely appreciate the help). For example, in the latest 'alpha' release there was a contribution to have support for gocheck testing framework. Personally I have used the templates only once, when I was learning Go so for me those are not a priority. If no one will do it until I get around maybe I'll add it, but who knows? Currently I'm working on Delve support, I don't think there's another editor/IDE supporting that at the moment, is there? Also, in all fairness, the support for templates came up among the least requested features, where as the debugger I think it dwarfs all the other requests combined and time is limited for any of us, unfortunately. 
With Carlos Castillo's vim-mode, you can embed neovim editing into Atom. Pretty cool. I assume all your vimrc stuff will also work. https://github.com/carlosdcastillo/vim-mode https://www.youtube.com/watch?v=FTInd3H7Zec&amp;feature=youtu.be
Would you mind to share a bit more details on how it works? I mean, is the algorithm you are using described somewhere, perhaps in a book or blog post?
The go tool normally works on a **package** **level**, not on a file level. You do a go install or a go build for whole packages only, typically the package contained in the current folder. You either do a go install to install the package in the current directory or you do a go install full/path/to/package to instal package the package contained in $GOROOT/src/full/path/to/package The only exception to the "use the go tool on packages only" is for go run which operates on a file level. So your go install test.go is completely wrong as there are (and cannot be) packages named "test.go". A simple go install is all you need.
&gt; Is the peer closing the connection abnormally? Yes. Figuring out why is the whole point of this exercise. 
I've got a server handling hundreds of WebSockets with no issues. One important thing, it seems you are missing a pong handler and doing periodic pings. In order to keep connections alive you should: - Set a short deadline - In your writer, periodically send a ping - Set a pong handler You can [check the gorilla examples in order to implement it](https://github.com/gorilla/websocket/blob/master/examples/chat/conn.go#L83-L86). Setting a long deadline is not enough, since the connection will drop due to inactivity anyway but you would not notice in the server due to the huge deadline.
We use this all the time. We have a build that is MMDDHHMM and most of our applications expose a "/build" route that dumps it. Really easy to see if A. It deployed and B. We're running into caches. 
This is ugly! I don't understand why they've overloaded the comment syntax. Comments should be comments. Why not use a different delimiter to mark compiler directives?
I recently recommended [this](http://manuel.kiessling.net/2012/09/28/applying-the-clean-architecture-to-go-applications/) article to someone on a similar [thread](https://www.reddit.com/r/golang/comments/3awbyl/dependency_injection_by_overriding_interfaces/). Your article titles look pretty legit tho; I'll have to give them a read.
Good call. I guess I oughta do a subreddit search before posting next time and not expect Google alone to surface all of the interesting threads. 
Alas, Google is not yet all-powerful. Btw, that thread is only 8 days old; some people may still appreciate your links there.
https://nullpntr.com/pborges/go-templates if your curious, supports partials and a master page
&gt; Also, I have "null" messages going from the client to the server and from the server to the client every 0.5-0.75 seconds. I don't see how that's done in the code snippet you posted. Can you elaborate?
Oh awesome! I like how you set yours up. It's a lot more in-depth than mine is. BTW, there's also a Go version of Window's FileNotify (I think, not 100% sure). 
Ooo. I'll have to look into that. 
Can you provide the code? I'll give you my line of reasoning. The error suggests the client is closing the websocket. The question is, "What justifies my expectation the client would not close the websocket?" The answer is the keep-alive pings you're sending to it. So the question becomes, "What lines of code justify my expectation that the keep-alive packets are being sent?" I have not seen those lines in your post.
&gt; The error suggests the client is closing the websocket. According to the websocket spec, error code 1006 is never sent over the connection, and is only local to one side of it. 
&gt; and is only local to one side of it. I don't think that's what the spec says. I think 1006 only means it was closed without a close frame being received. 
Maybe pick an editor which you can get the most help on? If there are lots of emacs users in your environment, you can get more help from them.
I doubt that most Gophers would consider any form of DI or IOC idiomatic.
Most probably you didn't export it :-)
 gohacker:~/test$ ./test Home dir : /home/gohacker PS1 var : gohacker:~/test$ export PS1 gohacker:~/test$ ./test Home dir : /home/gohacker PS1 var : \[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$ 
Very nice! Thanks for sharing!
I'm a little sad that they both don't use the dependency feature of make. Like build only if go files have been modified. Hashicorp for example builds with a shell script and uses make only for tasks.
Go definitely needs a runtime in the sense that it needs something running behind the scenes to do GC and goroutine scheduling. Rust however can run without any runtime at all (only the code you actually wrote runs; there is nothing running in the background at all), which is important for certain applications.
Learned something new today! For others interested, [go runtime](https://golang.org/pkg/runtime/) and [rust runtime](http://doc.rust-lang.org/0.12.0/guide-runtime.html)
According to Pike (see [systems programming panel](https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/Panel-Systems-Programming-Languages-in-2014-and-Beyond) of lang.NEXT 2014 conference) "system" in the Go context means something like "server". It's mentioned sometime at the beginning.
I suppose, meant to implement system services traditionally written in C/C++. Some examples are docker, heka, etcd, consul, influxdb, ... 
I disagree, at the end of the day there is a market and he who gets the biggest share wins. If you can get a big enough share you can strangle the other guys out by creating convention. Js is a competitor in that regards. 
True but we are talking about 2 languages that do share a lot of the same problem domain.
Please specify how many images you intend to serve.
Options include: * Just use the net/http FileServer, by writing uploaded images to the filesystem * Use AWS with S3. [Libraries](https://github.com/mitchellh/goamz) for go already exist 
https://github.com/VoycerAG/gridfs-image-server does this help?
Thank you for taking the time to answer :) What exactly would be the benefits of using S3 over just the net/http fileserver?
For me, they are competitors. I have a wish list of features both of them have different but incomplete sets those features. Rust has variants and generics. On the other hand, Go gets a huge simplicity boost by having GC. 
They compete, but for any given situation, they are different enough in their approaches that one or the other would be preferable.
Yeah, I think he roughly means "command line applications". Calling that a "system" makes sense if you think about it. Look at an operating system like Unix. What are many of the components of it that you interact with directly? `ls`, `cat`, `mkdir`, `grep`, etc. Those are part of the "system", and they are all just command line apps. Hence, a language for implementing those kinds of tools is a "systems language".
I'm probably not the best person to answer this, but I believe in sqlx, nested structs are only used as a convenience to reduce typing the same fields in multiple tables. For instance, if two tables both have an id field and a created_by field, you can create a struct with just id and created_by and nest that inside the 2 two table structs. You can read more about it here: http://jmoiron.github.io/sqlx/#advancedScanning Gorm I believe has additional relationship functionality with nested structs: https://github.com/jinzhu/gorm#polymorphism Edit: To be sure, I just tried using a nested struct with sqlx and received this error: Scan error on column index 2: unsupported driver -&gt; Scan pair: int64 -&gt; *database.User_status
He means the volume of images you expect = how much traffic. 1.000 - 10.000? Install it on your desktop pc. 1.000.000? Maybe think about a server.
Yeah, not going the way Google shoves down your throat is ..... not worth it.
Then you need a server. And using S3 seems to be the best solution, it scales well (afaik?) and you don't have to worry about the space. Hosting this on your own computers ... well, not a good idea.
I do agree with you that there is a minimum amount of market share that's required to even consider a language in the first place.. that much is definitely true. For instance, nobody would ever consider doing a project in [whitespace](https://en.wikipedia.org/wiki/Whitespace_(programming_language)
Dave just keeps getting more and more out of touch with reality.
I said: mostly used without a runtime. It depends on what you think "runtime" means. It could be your event loop handling library, the Piston game-engine, a fork-join handler ... even jemalloc would count as a runtime according to Wikipedia. So I guess that makes me wrong, because almost everyone uses heap memory. Only a few are experimenting with embedded stuff that perhaps don't need an allocator runtime. But anyway, with Rust (like C, and unlike Go) you get to choose what runtime(s) you use.
But let's say I don't want to use this service in production, but rather just want to develop it for now and see what's possible later. There's gotta be a way to just store a smaller amount of data on my own devices and access it and later transfer it to a server. It all seemed quite easy with NodeJS, but since I have no real idea about Go yet, it doesn't come as easy.
This is great, lots of interesting ideas here that I've wrestled with often. Thanks for the write up.
Go is just so much simpler. For that reason alone, I think it is worth experimenting with using Go for projects that most might choose Rust or C/C++ for. To address GC pauses, you can keep Go's heap tiny by managing your own heaps and making good API boundaries between those modules/subsystems. It starts to look more like C than Go, but it is like working with a much nicer C, and part of what my personal experiments have been in is seeing how much of this can be contained to unexported code. Curious if anyone else has had similar thoughts or related experiences. Edit: Now, if you really are shooting for near-theoretical maximum work output from the target hardware. Sure, you should stick to C or whatever.
A wishlist of variants, generics, and GC sounds a lot like OCaml, though I hear OCaml's concurrency story is lacking relative to Go and Rust.
&gt; You can't easily pass in additional arguments (i.e. database pools, configuration values). You end up having to either use a bunch of globals (not terrible, but tracking them can scale poorly) or stash those things into a request context and then type assert each of them out. There's an alternative you should consider: func NewComplicatedHandler(env *Env, ...) func(http.ResponseWriter, *http.Request) { return func(http.ResponseWriter, *http.Request) { // use env freely in here } } Usage: router.HandleFunc("/route", NewComplicatedHandler(env)) Both of these approaches have their time and place, and apply well beyond just the net/http. This closure-based approach can also be used if you're just writing a really quick &amp; dirty web server.... right there in your main function, grab some environment stuff, and then: router.HandleFunc("/route", func (rw http.ResponseWriter, req *http.Request) { // body here }) Boom. Done. Closures are not as big a focus in Go as they are in some other languages between the lack of generics forbidding "functional" programming and interfaces being only fulfilled by objects, but you'll still want them in your toolbelt.
[flotilla](https://github.com/thrisp/flotilla/tree/develop) just went through a round of testing revisions I haven't pushed out yet, and could always use contributors.
How much control do you have over memory allocation when it comes to Rust's standard library? Not trying to poke any holes, just piqued my curiosity.
It does. Sadly, OCaml seems to be a near miss for me. I want to like it but there are enough issues that I don't.
Just to reiterate, the internet being what it is, I very much meant that as "something else to consider as an option" and not "elithrar\_ wuz doin' it wrong". I totally do stuff like your post too. It definitely has a place.
Agreed. Images on a file system + nginx with sendfile enabled is probably the fastest you'll be able to get
My first dive into Go. I would love a code review on my Gist if anyone feels like digging through it. It's a basic program with just a few functions and loops that makes some web service calls to BitBucket. Feedback welcome....!
We're always looking for people to help us out with [Ark](https://github.com/ark-lang/ark). It's a compiled programming language that targets LLVM, there's still a lot to do, and we'd love some help from anyone :)
&gt; Wei Hsu is quick to answer: PHP is extremely popular in China, but relatively slow and not well-suited for large systems. ... In his opinion, Go now plays the role that traditionally belonged to PHP, but Go runs much faster, is type safe, and scales more easily. Now I understand why so many Chinese uses the phpfmt (a gofmt-like tool I did for PHP)
We need more ~~gold~~ type assertions! Declare a few types, one for the each type of response. Make your getJSON() function accept a URL and an interface{} where you would decode a response. type Response struct { ... Field string `json:"name"` ... } func getJSON(url string, v interface{}) error { .... err := json.NewDecoder(body).Decode(v) ... } ... var resp Response err := getJSON(url, &amp;resp) ... 
By the way, cAdvisor exposes [Prometheus](http://prometheus.io) metrics out of the box already, so no external collectors needed for those: https://github.com/google/cadvisor/blob/master/docs/prometheus.md
I've been using it &amp; really enjoying it for the last couple days. Really nice work. Quick question: is RethinkDB pubsub supported? I couldn't find anything in the repo docs. EDIT: I found this which enlightened me: http://rethinkdb.com/blog/go-irc-bot/ Really good work. Thanks again. It's exciting how much easier my app is now configured to scale horizontally. You should add a link to that blog post in your wiki, or maybe import it in as an up to date repo, maybe. Double edit!: I see you have made use of "Changes" in your ToDo example, https://github.com/dancannon/GoRethink_TodoDemo/search?utf8=✓&amp;q=changes [Flattr'd.](http://flattr.com/)
I want to build an authentication microservice. Of course, I could just place the authentication service as a middleware and use Negroni, but it is not accordingly to a modern services. Every part of services have to be separately, for example, for authentication service I need Jwt, session, etc microservices. How to setup an environment for microservices? 
Hey thanks :) You raise a good point about adding some more information to the readme, I will add a feature list over the weekend. I also plan to add a list of helpful blog posts, for example Compose have a great post on their blog https://www.compose.io/articles/go-rethinkdb-and-changefeeds-part-1/. I also suggest having a look at the godoc as there are quite a few examples godoc.org/github.com/dancannon/gorethink. PS. What's Flattr? 
&gt;I don't want to write Go apps. But I want to optimize some parts of my existing infrastructure using a more performant language. so you have to use Rust
Its hard to say without more context but in any case i recommend etcd for config. Its hard to find a case where anything else it better for distrributed config, microservices or not.
Do you even have a problem with the scale yet? Or you know that when you launch you'll hit into a massive load? Do you know what's the performance of the system without micro-services in place? Yes, micro-services are useful, and they definitely sound cool, but the overhead and maintenance increase when using them. Do you need development speed or can you use five servers instead of four?
Seems like some simple string manipulation, if there is no decimals, add two zeros to the string, if there is one decimal place add one zero, if there is two don't add any, then finally remove the period. based on your sample input that should suffice? then you can safely convert from string to Int. also, a question of this level is probably better suited to /r/learnprogramming 
It seems that they want to allow you to choose your own allocator, just like in C, but this appears to be post-1.0. I'm not up to speed on where they've got to exactly. Here are some links: http://smallcultfollowing.com/babysteps/blog/2014/11/14/allocators-in-rust/ https://github.com/rust-lang/rfcs/issues/538 Probably it is best to ask this in /r/rust if you really need an up-to-date answer.
I think you're misunderstanding the "microservices" architecture that's becoming extremely popular(and for good reason). You're right that the microservices architecture makes scaling a lot easier, but it doesn't just scale for you. Your first step is to design and plan the application API. My favorite way to build an app based on microservices is to have the "main" part of the app handle the "edge api" usually this is where I like to handle authentication and roles/permissions. Then this app makes requests to the different microservices for the information it needs. So you might have a microservice that handles sending email notifications... So your main app checks if the user has the permissions needed to send the notification, if this is satisfied the request is sent to the email notification microservice which handles it from there. Just my 2cents to hopefully shed some light on how to design your app. Here is a little talk about how Digital Ocean uses Golang in their stack... Just an example of what I was trying to convey https://m.youtube.com/watch?v=Kx0nUrTItR0
Servers *are* command line applications. :)
http://regex-automaton.com/thompsons_construction.php http://regex-automaton.com/subset_construction.php
At least last time I checked Prometheus doesn't scale well unfortunately.
Awesome; I was hoping somebody would make a port. :) I really want to try to build a GraphQL entry point into [Cayley](http://github.com/google/cayley) -- it seems like a logical thing to do -- but I've only got so much time. So having a parser library makes that a lot easier. I'd say port the tests from the JS version they released as well; then at least we're as close to reference as possible, but even the reference is still a little spotty. Such is life with the early days of projects. And if you'd like to discuss more about making GraphQL work on a graph store, send me an email or ping me on IRC/Freenode!
Is this what you're looking for? https://golang.org/pkg/os/exec/
Another: package main import ( "os" "os/exec" ) func main() { out, _ := exec.Command("/usr/local/bin/clear").Output() os.Stdout.Write(out) } 
I agree. I did want to make sure OP was aware that console drawing abstractions exist, because if you're clearing the console, you're probably trying to update the screen. Ncurses will also deal with odd consoles better than a mostly works byte sequence.
exactly, thanks!
Useful, thanks! 
Woudn't https://github.com/nsf/termbox-go be enough? Wait, it returns to pre-draw state at exit. If I remember my experiments correctly.
Are you unmarshaling the JSON as a float64? If you are, why not just multiply the value by 100 and convert that to an int? If it's unmarshaled as a string, you just need to call strconv.ParseFloat to convert it to a float64 (or preferably update your struct to do the conversion for you) and then do the multiplication and int conversion.
In principle, Prometheus's metric collection scales to a company of Google's size, since it's heavily inspired by Google's monitoring system (Borgmon). Scaling just works a bit differently than in an automatically horizontally scaling system: you either shard servers by function, or you "manually" (of course not really manually, but configured from the outside) shard them horizontally, then build tree-like hierarchies via federation (e.g. many per-jobset Prometheuses being scraped by per-DC Prometheuses, which are then being scraped by a global set of Prometheuses - this would be in environments with tens of datacenters and hundreds of thousands of machines). See also http://prometheus.io/docs/introduction/roadmap/#hierarchical-federation. That feature is now actually implemented in 0.15.0rc1 in an early fashion. Even a single server can do thousands of targets, millions of time series, and hundreds of thousands of ingested samples per second though. What *is* currently one of the last missing pieces is a durable long-term storage. Prometheus is currently good for keeping months of data, but is not meant as a durable "forever" data store. It does have support for writing samples into OpenTSDB and InfluxDB (currently being fixed to work with the latest 0.9.0 stable release). The problem with InfluxDB is that it uses an order of magnitude more disk space for Prometheus-style sample data (see https://groups.google.com/forum/#!msg/influxdb/qxgtzbmCNcY/7fio5GLYJmcJ), so we're still hoping for better long-term storage candidates, or for InfluxDB to improve dramatically.
All you need in windows is package main import ( "os" "os/exec" ) func main() { cmd := exec.Command("cmd", "/c", "cls") cmd.Stdout = os.Stdout cmd.Run() } almost the same!
&gt; what the Go authors meant by systems is different than what the Rust authors meant More like, what the Go authors meant by systems is different than what the rest of the world meant.
Thanks so much /u/gohacker. This is GREAT advice. First though, I'm going to write some tests, then I'll refactor using your advice and re-run the tests. Thanks!
I am not sure I understand. It is already one single binary without any dependancies, why is it being wrapped in Docker? It makes sense for hashicorp stuff since it is all the tools for container farms ecosystem, but why is this guy doing this to godebug?
You are closing the file before unlinking it. &gt; Each time a "defer" statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not invoked. See https://golang.org/ref/spec#Defer_statements
Ah you're right! What a silly mistake. Thanks!
well you can always use runtime.GOOS variable to identify the os if runtime.GOOS == "windows" { fmt.Println("Hello from Windows") }
Umm... http://stackoverflow.com/questions/31212546/systemclear-equivalent-in-go
golang-book.com was written for beginners.
If so, how do they do "net/http/cgi"?
That is just the layout of the directories. Those packages are only related by location.
Simple. Run `mkdir -p $GOPATH/src/cool_package` and then `cd` into that directory. Then, create a file with the package name 'cool_package'. Then, create another directory called 'cool_package_number_two'. Make a file with the package name 'cool_package_number_two'. Now, in order to use 'cool_package_number_two', you'll have to use the import path `$GOPATH/src/cool_package/cool_package_number_two` I'm on my phone, I could describe it better were I on my laptop.
What a n00b move. We thought we trained you better
demo has been released: http://mongolar.org/demo
Rember that by convention (not rule), the name of a package should be the same as the name of the directory that contains it. The full import path is composed by the directory structure relative to the top-level 'src' directory that contains it. So if you had foo.go inside this tree: gopath/ `-- src `-- p1 `-- p2 `-- p3 `-- foo.go The file foo.go should declare itself part of package 'p3': package p3 Any file that wanted to use a symbol exported in that file would use the following import path: import "p1/p2/p3" In that client source file, by default you would refer to all symbols using: p3.DoStuff() 
prerender.io
Not yet. I am not the greatest SEO master. I do know when Google shows how the site will render it shows all the content. I am not sure how much of it is being scraped.
Is the question you're asking: why run go binaries within docker at all? I wanted to make sure I understood before I answer it. 
I "tithe" some money each month into a Flattr account, any GitHub projects that I star then gets a percentage of that money every month. Check it out, you already have three donations waiting to be claimed: https://flattr.com/thing/2809066/dancannongorethink-on-GitHub
Oh wow, thank you very much!
The Changelog has had a few Go-focused episodes: https://www.reddit.com/r/golang/comments/308wg1/the_state_of_go_in_2015_with_andrew_gerrand_the/ See https://www.google.com.au/webhp?q=changelog+podcast+golang
They're not using JavaScript though, they're reading from JSON. They can do exact math on what they reads from JSON if they do things carefully.
The most recent episode is Go-focused! ;)
**UPDATE** Due to much gnashing of teeth http://demo.mongolar.org, no longer requires a login. Content gets reset at 50 minutes past every hour.
login requirement has been removed
I wouldnt call it advertising, this is mostly my understanding of how everything works. I'm just trying to understand what makes GO great. Is it because it's fast? How fast? Is it some cool feature? Does it scale well? Node works great for serving non-CPU heavy tasks to many connections in a short time. Can GO with it's goroutines do a better job? Why shouldn't i keep using Python? Why should people move to Go? From what i know, and i may be wrong, it seems like Go is the clear winner. I'm just trying to get peoples feedback that have previously used these other languages and technologies on huge services to see how everything compares.
&gt; Obviously that description is a hyperbole, but when given regular people "common" programming text-books, they feel the same... i.e. lot's of things are explained but they don't lead anywhere. Maybe they start to make sense eventually in paragraph 10, but at that point the person has already moved on to doing something else. My model was a logic text book. Terse but the necessary material is all there. I don't spend much of any time on process, but program examples and problems become more complex as the book goes on. If someone actually did the problems hopefully they could generalize those to real world programs. (ie I know how to read a number from a user, convert fahrenheit to celsius, then print it back out, so therefore I can build any type of basic conversion program) When you study logic (or math) you learn *how* to do it, but don't spend much time on *why* you are doing it. I see what you are saying and how this can be frustrating for new learners, but I'm not sure there's any way to avoid it. There's a reason this is the process we use for learning most subjects. You've got to learn the nuts and bolts before you can really learn how to use them. (in art you learn technique and copy masters, in math you learn arithmetic before algebra, etc...)
My best answer would be: http://play.golang.org/p/zfrGu4mrIU [edit] hm, that doesn't really address the issue. So no, I don't think that's possible at all in go currently.
Have a look at this project by imgur: https://github.com/Imgur/mandible It is written in Go, has a REST API and you can choose from different storage backends (filesystem, s3, etc). 
O RLY? func copyHash(src hash.Hash) hash.Hash { typ := reflect.TypeOf(src) val := reflect.ValueOf(src) if typ.Kind() == reflect.Ptr { typ = typ.Elem() val = val.Elem() } elem := reflect.New(typ).Elem() elem.Set(val) return elem.Addr().Interface().(hash.Hash) }
May this package can help you: https://godoc.org/code.google.com/p/rog-go/exp/deepcopy ?
You can't just deep-copy arbitrary things and expect them to work right. Making a copy is not part of the hash.Hash interface, and not all hash functions expose a mechanism to copy the internal state.
Code indentation is all fucked up
MessagePack Edit: Huh. There used to be an official JS library but not anymore. 
Gzip+json. These will be implemented natively on C in the browser, but all other protocols will be in Javascript. Benchmark to determine if this isn't fast enough. 
Cap'n proto is a good option. Should be pretty quick on both ends.
Go isn't "super-fast", but it is compared to Python and Node. Go usually benches slightly ahead of Java, which is a respectable place to be. Scalability depends on a lot of factors, most important of which is code quality. If your code is built with it in mind, absolutely Go is scalable. The main reason for which is that goroutines are very easy to manage. Compare the workflow for goroutines with doing threads in python or child processes in Node. In Go, you just hand your function a channel and send it off. In Python, you need to make sure that any variables are instances of threading.local so that you don't get collisions, and then after everything is finished you have to explicitly join all threads. Basically, what it comes down to is that Go has less compulsory boilerplate for basically any given project. There's also the "compiled" aspect. No external libraries make Go programs very easy to deploy. Want to throw your application on a new server? Just move the executable. No need for the target system to install anything. Also, as far as I know the Node runtime is A LOT heavier than the Go runtime (which comes bundled in the compiled executable), so you can cut down on hardware cost by running weaker hardware and getting basically the same results.
FWIW, I'm hoping to work with the Baidu team on a blog post with some details after GopherCon.
Alas, that's not true for JS. Javascript protobuf implementation is in Javascript, while JSON parsing is down with native code. There is a big speed difference.
I tried this, and there are many issues, the bigger one being that there is no sane way to handle the int64/uin64 in Javascript. It gets silently converted into a floating point number which then drops precision so the number... is different :)
&gt; Javascript protobuf implementation is in Javascript, while JSON parsing is down with native code. There is a big speed difference. OP asked for network efficiency. Protobuf is going to be much faster to transfer over the wire, and that's almost certainly going to outweigh the extra cost of parsing.
Yeah, you likely won't find a good fix for that.
Looks fine on firefox.
No, not at all. I am saying that when normal people talk about "system software" and "libraries" they mean the kernel, the drivers, and the assorted infrastructure components that support the actual programs you are trying to run. When Google talks about "system software", they handwave past the part where all their machines are running Ubuntu, because what they mean is the web server and all of its components, and by "application" they really mean "web service". When they talk about their distributed file system project, for example, it's not a file system at all in the sense we are used to thinking of them. There's no kernel module and no mapping to disk; the "filesystem" is really just a distributed web service with a filesystem-like API implemented over HTTP. I was really excited when I went to work there because I told them as clearly as I knew how that I am a system software developer with no interest in web servers, and the responses I got were very encouraging, full of all the usual terms I associate with system software work. Only a few months in did I discover that they have taken all the same names and applied them to elements of the web service stack, and what they are doing has nothing to do with system software at all.
Who even says it doesn't scale?
I've used thrift with great success.
Ever hear that Java doesn't have objects? Explain this Java app - 1000 objects / component. 
I don't know of a non-intrusive __and__ reliable way to test that a given goroutine is not leaked. Goroutines get cleaned up whenever the runtime feels like it. You can off course add some stuff to your code so that you can verify that the last statement of a goroutine was hit, you can even do this reasonably generically by wrapping something that takes a `func()` and wraps tracking around it, but that requires you to do something at least modestly intrusive to your code. However... given the submarine dangers of leaking goroutines if you have a long-running process, you may just have to bite the bullet, declare yourself a "testing" flag, and if the flag is true, wrap all goroutine executions with some tracking code. It's not a very _large_ amount of intrusiveness. If you don't know what I mean by generically wrapping tracking code around goroutines, let me know and I'll elaborate. If you already get it just from the description above, great.
&gt; that's _almost certainly_ going to outweigh the extra cost of parsing. Profile. Profile, profile, profile. Your instinct to qualify that statement was a good start, but doesn't really go far enough. You really need a round-trip profile for the whole system. I'd also suggest to the OP that if you haven't done anything much yet, you won't really know what "good enough" performance is. JSON is probably going to be pretty good.
Someone posted their experience here and the on-the-wire size of protobuffs versus gzipped json is surprisingly marginal: https://blog.wearewizards.io/using-protobuf-instead-of-json-to-communicate-with-a-frontend
The only sure-fire remedy for this that I'm aware of: 1. Never block on a channel read. Use a `select{}`, and consider managing the enclosing goroutine with an additional channel that can signal the goroutine to terminate. 2. For blocking code that concerns things other than channels, use timeouts wherever possible. Network I/O should timeout in a reasonable time, to permit the goroutine to continue. That said, this only works for the code you control. There's nothing keeping any framework or library from doing things that will cause zombies to manifest.
You can do that kinda-sorta painlessly with something like: type jsonInt64 int64 func (i jsonInt64) MarshalJSON() ([]byte, error) { return []byte(`"` + strconv.FormatInt(int64(i), 10) + `"`), nil } func (i *jsonInt64) UnmarshalJSON(data []byte) error { val, err := strconv.ParseInt(string(data[1:len(data)-1]), 10, 64) if err != nil { return err } *i = jsonInt64(val) return nil }
Well or that.
You sure know how to be popular in these parts.
Modern JavaScript engines are pretty smart. When doing int operations (bit shifts and the like) most engines will internally represent these numbers as ints and only promote to floats when a float operation happens. Internally things are complex in the JavaScript world.
Well i would think so since you are saying Go isn't very fast. As opposed to what then? By foundation i mean the internals of a language(including vm, standard interpreter, etc)
Are goroutines and message passing slower than threads trying to access that shared data through a lock/mutex?
We do 450,000 http requests / second at my workplace. I had the same thought, plexing over scheduled GC pauses, but never tried it. I should definitely give it a go.
how many instances?
&gt; Why would you want to use anything but JSON for a JavaScript client? Medium datasets; e.g. 1GB of JSON data is quite problematic in browser - by parsing it into JS Objects you will construct millions of objects which adds GC pressure and has large overhead in object headers.
I passed this tweet on because I thought it was interesting Baidu were a big Go user, and the size of their traffic was given. The reply from a day-job Ruby programmer who also does Haskell, Julia, etc., but not Go, was "Who says Go doesn't scale? That doesn't seem to be a meme." The opening sentence of the tweet is confusing readers and weakening the interesting facts.
Also there are approaches like http://arxiv.org/abs/1504.02578
Dated Aug 30, 2011
&gt; Under these circumstances, the newly-published Go 1.0.3 release came to our attention. kind old? they could update to 1.4.2, massive performance increase for free :P
Something like C or Rust gives you the option of manually managing memory, but that doesn't automatically make your programs faster. Whether your memory is managed by GC or manually you need to pay attention to avoid frequently allocating memory. If GC time becomes a problem you could set up a pool of the frequently used objects and manually manage them. You'd get 90% of the benefits of manual memory management while avoiding memory management bugs in the rest of your code. edit: I just noticed that the [Qihoo 360 and Go](http://blog.golang.org/qihoo) post from today shows the impact of these kinds of optimizations.
Thanks for posting this. I feel that there is a great wealth of knowledge in Go that currently exists in China due to how much adoption it has there. 
Don't use Go for writing GUI applications or rocket software. And yes, there are languages that have other strengths.
15 nodes with 9ms upper-97th response time (1ms average). We could happily cut down to 8 nodes. Each node is a 32 core machine.
Right now our upper-97th is 10ms already... We want max of like, 4ms. Round-robin GC will likely allow us to get that.
Would love to see someone create a rules engine in golang. Like this one: https://github.com/bobthecow/Ruler
I don't want to derail the conversation, just wanted to say that the man in the photo of the post is ~~not~~ the great Groucho Marx, ~~is not [Jose Luís López Vázquez](http://www.imdb.com/name/nm0007023/) although he was a spanish actor.~~
Lots of reasons really. In no particular order: * If you primarily do text processing, Go is fairly slow compared to other languages on this. * If you need a simple MVC web framework. I get pushback on this every-time but I think Sanatra/Flash/Django are much better alternatives if you just need an MVC app. * If you have to share code with team members or are a manager of a team that would have a hard time transitioning out of traditional OO design. * If you want to create a desktop GUI based application. This is a weak spot for the language. * If you're not prepared to adopt some of the more opinionated aspects of managing apps in the language. (Dependency management is one example, compile and store your dependencies is a pretty strongly opinionated position on Go's part, if this kind of thing puts you off, Go isn't a good choice.) * If your use case would call for a lot of mature 3rd party libraries or maturity in the toolset, Go MAY not be for you but you'd have to define your specific needs and do some research to see if this is an actual problem. * If you need speed across the board. Go is improving but some aspects of the language are faster than others . Much of the complaining about Go I don't think is founded as it seems to center on expectations of patterns established by other languages that don't necessarily have inherent value. You mention Generics and that is one example of the kind of thing I mean. Overall you would be better served listing out what you need in terms of a language and doing some specific analysis of Go (and some other languages) to find a good fit. Good luck and let us know what direction you think you'll head. It would be helpful to get your thoughts on what specifically influenced you.
You shouldn't not use Go.
You can shorten most of your boolean Is.. functions by using return and then the condition. return m.OriginalSender != User{}. etc.
&gt;* If you have to share code with team members or are a manager of a team that would have a hard time transitioning out of traditional OO design. Huh? I'm confused, are you saying don't use Go in this case? This is almost exactly what Go was designed for.
This is a good academic question to ask but it's a bit too broad. Should be why u should or shouldn't use go for specific use case scenario. Citing type of project, intended architecture, the type of team working on it (or single person project?), who will support it, is it open source or proprietary.... As well as many other variables can come into play when it comes to your choice in language IMO Edit: word
Are you looking for something that will handle templating for the frontend or a restful API to use with something like angular/backbone/&lt;insert js framework&gt; What's your previous experience? What is your goal, to learn as much as possible or to build something quickly and release it? 
We know that there is a very large and growing population of Go developers in China. We know that both Qihoo 360 and Baidu are using Go extensively. We also know that the team at Qiniu are deploying Go. If you know of other innovative technology companies in China that are using Go, we would love to talk to them. Feel free to message me at /u/jbuberel. 
You probably shouldn't use Go for very small, embedded programs where the amount of memory or storage space you have is heavily restricted. Go produces comparatively large binaries and has a comparatively large runtime.
This was a terrific write-up, well worth taking the time to read.
Sorry if I wasn't clear. I was saying you shouldn't use Go if you have to work on a team that has a hard time thinking outside the traditional OO patterns. Go can be confusing for people coming from traditional inherited OO languages. So if your team can't (or wont) put the time or effort into learning the Go way of doing things I wouldn't use it.
&gt;Rust was created as a language to implement a web rendering engine. There's no good reason Go couldn't be used for this task, and Go programmers shouldn't cede this claim. There is an excellent reason: you can't make a DLL out of a Go-written rendering engine such that a browser shell can embed it. This is explicitly not supported. With Rust, it's trivial.
1.5 added shared library support. But even without it, make a separate program and communicate with IPC. Every tab in Chrome already does this. (https://www.chromium.org/developers/design-documents/inter-process-communication)
That support doesn't include the ability to generate a binary that can be invoked as a loadable library in other processes. The IPC comment makes sense to me, but then you have a rendering engine that cannot be extended by plugins itself.
I think its worth it. Type system and returning error early will save you from large number of production-only raised errors. The import system is also nicer than ruby or python. You always know where things are coming from. The standard library is also surprisingly robust, unlike things that shipped with ruby or python by default. For example database/sql takes care of connection pooling for you. So much to gain, very little to lose. Do it.
This document (https://docs.google.com/document/d/1nr-TQHw_er6GOQRsF6T43GGhFDelrAP0NqSS_00RgZQ/edit?pli=1) says: &gt; Many programs implement a plugin interface in which a shared library may be loaded at runtime. The shared library implements one or more well-known functions that are called using a C style API. In this mode a Go program may be built into a shared library that may be loaded as a plugin. &gt; This mode makes it possible to write Go plugins for existing programs with a plugin interface. I've never tried it so I don't know the limitations. Is it normal to have a rendering engine extended with plugins? Doesn't every new version of Chrome update the whole app?
far more complex type system, buitin package manager and most errors are catch in compile time, even complex ones like data races. 
have a look at elixir with the phoenix phoenixframework.org framework as well for an option. It's a purely functional language with optional types and a syntax inspired by ruby.
Just noticed the slides are from 2012. Don't think 1.4 was around then. Which also makes these 10 things questionable.
For me the whole discussion is just nonsense: All programming languages are competitors to each other (with some small exceptions, when you are are bound to a certain platform for example). Go seems to draw quite many people over from Python or Ruby -&gt; Go is a competitor to Ruby. 
You will probably loose a lot in productivity in go if performance is not a problem. As much as go is advertised as "dynamic productivity, compiled performance" its not true. It doesnt get nowhere near Ruby or Python in terms of expressiveness. On the other hand if not for the performance type safety is always a benefit, but Go's type system in my opinion is definitely not amongst the best ones, but still much better than no types at all... So to answer your question, if im not having performance problems and you arent working in very big teams, sticking with Ruby is probably best. As your team grows Go becomes easier to maintain in my opinion, but pure development turnaround times are still longer than Ruby.
for me is all about the 80-20 rule, with so little effort we can do tons of stuffs in go, this is why guys come from python/ruby (i came from ruby :P).
Meh, not worth it. If ror isn't giving you issues then keep trucking along. Your job is to give your users features, and if golang isn't going to move the needle for you, then don't worry about doing the big switch. 
Ah :) I had forgotten about Python's circular import problem. With Go, you can break circular import by implementing a small interface that implements the needed methods. To break circular import in Python, you have to refactor a much larger surface area.
I switched for the simplicity, the performance is just a really nice perk. 
The wiki is not clear. The `gowiki` directory should be under `src`. That's probably worth a bug report.
wow this is amazing stuff
The gopher's name is The gopher.
Python (and C#, as well as most other languages now I'm sure) use the same algorithm as well these days.
Is this rust or go?
rust
Also, Rust is highly concurrent by design and uses borrow-checking to catch races at runtime, so this whole line of reasoning appears bunkem.
Currently we are not batching writes to S3. We are posting 1 million individual S3 objects every minute. Our payloads are small like you said, some average a few hundred bytes to lower 1Ks. The screenshot rate is not our current, it was right after our deployment. Our network out right now at 3am is about 150MB max network out, it peaks before lunch to over 1GB max network out and 2GB max network in per minute. We don't intend to leave our nodes so hot, we expect to go back to an average of 65-80% CPU, we wanted to experiment with the cluster and see how many servers we could drop from the cluster. We probably gonna run with about 10 servers.
Sorry to bug you once again, but how does one properly use "FilterOpts"? I can't find any examples of its use. This is the only example of "filter" being used that I can find: query := r.Table("items").Filter(r.Row.Field("Status").Eq("active")) What's the correct way to filter for multiple fields?
In the second approach, have you had only one ``StartProcessor`` uploading, or several? I wonder, would it be any better if you had several of them, all receiving from the same Queue.
I figured it out: I neded `export GOPATH=...` I added the `export` and now it works.
Came here to say exactly this :)
rust has a builtin package manager? Last time I checked, cargo wasn't builtin at all (case in point: cargo is still not in debian, months after the release of rust 1.0). On the other hand, the go tool, which I would consider a package manager (others do not) is indeed bundled with the language. So, where am I wrong? :)
I'm also confused... Why can't multiple workers just listen on the JobQueue directly?
Can you explain the `chan chan` code? (I'm still learning Golang and I've never seen that before)
I disagree, that Rust is "highly concurrent by design". Rust heavily buys into a 1:1 thread model, which is too expensive, to be considered "highly concurrent" as a language. I agree, that rust makes it very hard to write incorrect multi-threaded programs, whereas go makes it pretty easy. But what makes go's concurrency support great, is that the language as a whole buys into one concurrency-paradigm (which I happen to believe is the best one): It is totally fine to have blocking operations, the runtime will schedule other work as needed, no need for your code to reflect the asynchronicity of the real operations. *That* is where go shines: No callback-hell, no promises/futures. Just sequential code and the knowledge, that down- and upstream code plays well with this concurrency model as well.
I find it kind of sad, that this article mostly argues from a theoretical standpoint, while pretty much ignoring the real world. Of course in some future version, go's garbage collector will probably be sufficiently concurrent, that I can write a AAA-game with it. But I need to get shit done *today*. And as such, I wouldn't consider go at all, because today it's just not ready yet. Just like rust's web-server and concurrency support will probably be very good in some future version, but today it's just unusable, so I wouln't consider rust *today*, when I need to write a distributed (web) application. In theory, nothing prevents python from competing with C in speed. But today, it just doesn't. &gt; Its not at all obvious that managing your own memory and scheduling your own tasks always leads to superior performance. I have to disagree. If we ignore development-time, it *is* very obvious, that managing your own memory and scheduling your own tasks always leads to at least matching the performance. Because you can "simply" write code that does the same as a theoretically perfect GC/scheduler. The argument here is, that you just can't ignore development-time. It's obviously a tradeoff and it's okay that if you really need to fixate on performance in this tradeoff, that's okay and we should acknowledge, that this is not a goal of go. When, as in firefox' rendering engine, code is executed millions of times per day on millions of machines, getting e.g. 10% of performance-gain for 50% added development time is totally fine (I'm making up these numbers). &gt; You're getting a sophisticated task scheduler merely by running your program in Linux. Which is exactly the argument, rusts developers made: "We don't need an N:M thread model, because the OS support schedules well enough". Overall, this whole section seems quiestionable to me. I agree, that a lot of the functionality of the go runtime is already implemented in lower layers, but that's only an argument to spend additional time on it, isn't it?
Definitely not - you will see why when you've done more Go. Do you have any *real world* (ie. not a for loop) application where that actually makes a measurable difference? If you put up more of your code, we could maybe help you adjust it. 
User input validation and data access are two different things. Trying to merge them together will only lead to more complexity. If you really need something like that, you could just as well use a map.
How can that be between a DFA and an NFA?
Go binaries are statically linked by the reference implementation. `gccgo` produces dynamically linked binaries with much smaller size.
I don't know enough about it, but feel free to read the code!
So basically it's a bidirectional channel?
\#10 makes me uncomfortable. Changing a parameter's value (a channel in this case) to perform flow control in the same scope? Not a best practice in any language, IMO. It's also not a feature of channels per-se; you could probably do that with any reference (i.e. "nil-able") type. Besides, why not just exit the goroutine on `&lt;-quit` ?
Tampa Represent! Great writeup Marcio!
Python 2.x does not but Python 3.x does. Both run faster than Go. CSV was just one example, as another reply pointed out this problem goes deeper than just the CSV parser it extends to regex and other text processing aspects. I don't consider this a deal breaker for Go but text processing isn't it's strongest feature. In the real world you're only going to see this if you do very large amounts of text processing though so, as always, it depends on your use case.
Any help is welcomed! So please fork :) 
Putting "go" in library name is quite annoying (its targeted to everybody who do that, not only to you). I have never faced smth like this in other language. Besides that, keep going :)
It's channels all the way down!
This should stop.
&gt; Are there any AAA games written in Rust? No, but a browser rendering engine, which has similar real-time-requirements. You argue, that you can do that in go too, but I am arguing, that this is a mainly theoretical argument. I won't believe, that you can really do that, until someone does. I do believe, that there will be AAA-games written in rust in the foreseeable future (but yes, that is mainly a theoretical argument). &gt; My argument was not merely theoretical. I gave an example of a popular game written in a language using a garbage collector. Yes, it's an atypically successfull indie-game. I'd claim that Minecraft was a very risky investment and that there is a case to be made for big studios to rather rely on games that concentrate on graphics instead of gameplay/storyline. &gt; perhaps 90% of the code you write for a game could be written in Go Go has pretty substantial overhead for calling into C. &gt; The argument is that managing memory in the way C programmers manage memory doesn't always lead to faster code. I highly doubt that and so far I haven't seen any proof (or even evidence) of this. &gt; Go does provide control over this stuff if you want it. I'm not sure this is 100% true. E.g. by design you can't influence, whether or not something is allocated on the heap or stack. This is a good thing. But there are very obvious cases, where the Compiler can not correctly deduce that something belongs on the stack. &gt; I think a model where most of your code is working with the abstraction and you occasionally dip down for greater control, is a better model than getting rid of the abstraction and always doing the work manually. I agree, that's why go is my first language and will probably stay my first language for a forseeable future. But then again, I don't have to write very performance- or allocation-critical code. Overall, this debate is pretty stupid. I don't understand, what's so difficult to acknowledge, that go will be worse for certain usecases than rust. They have very explicitly different goals.
I think this argument is about as usefull as "Garbage collection isn't always slower than manual memory management".
Okay. I disagree that this is sufficient to call cargo "builtin".
My pet-peeve: Build-times. Building a rust-compiler with stdlib takes about 90m on my machine, building a go-compiler (including a bootstrap go1.4) takes 2m. Building other things compares similarly.
I was wondering the same. 
&gt; Besides, why not just exit the goroutine on `&lt;-quit` ? Because then channel writers would block/hang. The semantics here are that the goroutine continues to read items from the channel once told to stop executing them.
Not a very good article to be honest. It essentially just says "Go is better than Rust".
Cool, the link isn't loading for me so I wasn't sure of the full context and what you were replying to.
Hold on for a sec, what's disgraceful in saying pure Truth?
I agree on that, but in some cases (when you're building a client for example) I see no need to create a fancy name.
It's not. They have different niches. Try writing Servo in Go. Ooh, it'll _work_, just as C++ _works_, but you'll start designing yourself up Rust again. 
Yes. In one of shell's many annoyances, there are local variables and exported variables, and virtually no indication which you have when you look.
Ah, that makes more sense now. Thanks!
Brad, not sure if you saw this: http://godoc.org/github.com/stevvooe/resumable. It integrates pretty well with the standard library without being invasive.
I like your first short-term idea. Your second idea is being addressed in Go 1.5 by first-order support for vendoring, and I guess will continue to evolve from there. re: your last point, I'm hoping to push on this with http://gokit.io. If you have any thoughts to contribute there, I'd love to hear them.
As for vendoring, it's a solid first step, but it's not complete enough for my taste. That said, the proposed recursive `vendor/` directories come with some insidious corner-cases. Consider that NPM turned away from this approach for the most part in the recent V3 release. Everyone else avoids it, and not for any lack of technical prowess either. So, I'm not at all satisfied with the status quo, or the charted direction. I like the idea behind gokit.io. I'll give it a look. :)
Wholeheartedly agree with this post. It's a bit of a hot button issue and I get a lot of flak when I bring this up in reddit. IMO this is one of the biggest factors holding Go back right now. It's not just the toolchain (which is important) but it speaks to the ingrained practices and maturity of the community. pip, npm or whatever isn't just a useful tool, its a big sign that the community is on board with good central best practices and that the community itself isn't going to hinder moving forward in that language. Go not only needs the feature but not having leadership and a community agreement that it's useful is holding us back IMO.
+1 for your Garbage collection on goroutines. I don't think it really can be added to the language as a guarantee, but it would be super-usefull. e.g. concurrent iterators are much harder to write than need be: With garbage collected goroutines you can just return a channel and spawn a goroutine to write to it. Today you need to add a bunch of boilerplate to support cancellation and get a less "neat" API. -1 on the semantic versioning thing, unless you can do it lightweight (e.g. using git-tags) and have tooling to check, that you don't break anything (which is insanely hard to impossible for the general case).
A comment on the blog post mentioned doing the writes concurrently instead of sequentially. I gave a shot at adding concurrency to the standard multiwriter implementation and used the hashing example from the blog to test it. You can check it out [here](https://gist.github.com/alexmullins/1c6cc6dc38a8e83ed2f6). It seems to work. Not sure if it is an idiomatic way of doing it or not. Would like to here anyone's comments on it. Btw really enjoyed your first two posts. Looking forward to more!
Start with http://tour.golang.org
Not really a fan of a catch-all `marshall()` especially since it uses reflection. Why not just have `store.Store` require `String() string`?
Thanks. I did not know it was better to compile the regex. I already had planned to add stalkignore. In a few days I will add it or I will pass it through arguments.
Welcome to the world of code. Opinions about this are probably going to be highly divided. Programming is less about languages (like Go or Python or whatever) and more about writing instructions. Instructions that are clear, correct, and efficient. We simply use languages to encode these instructions in a way that is easy for us to follow but also easy for a machine to perform. The Go tour is good, so you can try it, but it expects that you know basic language constructs like how if statements work and what variables are. To understand that, it's important to know how the machines work on a mechanical level. I don't know your background, but make sure you know the components of a computer - not merely that they exist but also how they work (at a high level). For example, you don't need to know how RAM stores electric charges but you ought to know that memory reads and writes data to addresses and that a variable is a chunk of allocated memory that holds a value. You don't need to know how a transistor works as much as the fact that a general purpose CPU can only do one thing at a time (basically). Things like that. Honestly, a book would be a good way to start. I don't know what's good these days for beginner programmers but find one that doesn't only teach you a language. Sure, languages are important since that is how we represent computations, but to really grasp programming you need to know what your language features are doing. Not understanding this will lead to lots of copying and pasting code. Also, I recommend that you practice typing. Not speed, but rigor. If you are lazy about typing, as most people are, you will expend more energy on fixing silly syntax errors than solving real problems. Be careful about casing, spacing, indentation, punctuation, etc., and be concerned about overall readability. Many of my friends who started programming never continued because it was too hard to type things correctly. It's okay to be slow, but be correct! Choose a good text editor and learn it well. Know it's features and learn keyboard shortcuts. Finally, keep your files organized. Don't get sloppy about where you put things. It will come back to bite you if you do. So have fun. It really is an exciting field. Frustrating, but fun.
Thanks for the response. I actually know what if/then statements and variables are because of dabbling with matlab(recent engineering graduate) and also super super basic python a while back. I definitely need to learn more about how machines and their separate components work though. Also my typing is pretty bad, so I'll work on that. I currently use a text editor called Atom according to what http://www.golang-book.com/ said, which is a pretty good intro to Go. Thanks for the tips!
You should batch writes. You're spending $5/minute on S3 PUT requests and your map reduce will spend $24 per hour of data you download, just from the per-request costs... in the 20 hours since I saw this, you've spent $6k on PUT requests and generated data that will cost $480 just to retrieve... it would be cheaper to spin up a Cassandra cluster and ship SSTables into S3. My coworkers would be disappointed if I didn't say you should just shove all your data into a Kafka cluster :)
Maybe I am missing the point of Ruler, but the example from the main page: $rb = new RuleBuilder; $rule = $rb-&gt;create( $rb-&gt;logicalAnd( $rb['minNumPeople']-&gt;lessThanOrEqualTo($rb['actualNumPeople']), $rb['maxNumPeople']-&gt;greaterThanOrEqualTo($rb['actualNumPeople']) ), function() { echo 'YAY!'; } ); $context = new Context(array( 'minNumPeople' =&gt; 5, 'maxNumPeople' =&gt; 25, 'actualNumPeople' =&gt; function() { return 6; }, )); $rule-&gt;execute($context); // "Yay!" Seems very complex why not just code it in go directly? Same example in golang (did not run it): func getActualNumPeople() int { return 6 } func SayYayRule(minNumPeople int, maxNumPeople int, actualNumPeople func()int) { if minNumPeople &lt;= actualNumPeople() &amp;&amp; maxNumPeople &gt;= actualNumPeople() { fmt.Println("Yay!") } } SayYayRule(5, 25, getActualNumPeople)
Definitely a big danger. You could still have a concise tutorial/example via SQLite or BoltDB, which are thread safe and much more practical.
Are you sure that the Python's CSV parsers aren't actually written in C/C++? &gt; Both run faster than Go. Benchmarks are welcome.
Why not [spipe](http://www.tarsnap.com/spiped.html)? Looks like it achieves the same goal.
Here is a simple example I wrote up: http://play.golang.org/p/aaxXuUZ5YW func main() { items := []string{"one", "two", "three", "four", "five", "six"} items = ToStringStream(items).Each(strings.ToUpper).Filter(isLen(3)).Reverse().ToList() fmt.Printf("%s\n", items) }
Awesome. One thing I was hoping for was for go-plus to integrate with the Atom Linter package. That would be awesome.
&gt; Seems very complex why not just code it in go directly? The kind of examples that truly require the use of a rule engine tend to be too complex to be good examples. That's why you always end up with some contrived nonsense.
Happy to answer any questions people might have about the library or the design motivations behind it.
Just wondering, have you seen Crystal ?
Yep -- we've had [users of Appdash tool run into the same issue.](https://github.com/sourcegraph/appdash/issues/77). You can track on Go issue tracker: https://github.com/golang/go/issues/11307 It seems pretty serious, so I would expect it to be fixed before 1.5 is released most likely.
Rust "doesn't heavily buy into 1:1"; it is just the default. One day it will likely support a M:N runtime again if someone with development time really needs it. But it is never going to be baked into the language like it is in Go. The Rust language aims to be independent of these kinds of choices so you can run it completely stripped down if you wish (e.g. embedded).
Yes, that's my point. Rust gives you the choice, so you will end up not being able to use some particular library, because it made different choices. There's a reason, that rust removed libgreen (and that's not dev-time) and these reasons will make it basically impossible to use something that isn't meant to run with libgreen with it (and the other way around). And that is fine: rust made the tradeoff that they prefer an efficient FFI and runtime-less operation over the advantages of greenthreading which makes it a better choice for applications that need that. I don't understand why people need to deny all the time, that such tradeoffs are being made and that they are fine to make. No language will ever be right for *all* usecases…
With Rust it is helpful to structure all data that you can as shallow trees with a single holding reference at the top. That lets the compiler check everything and has zero runtime overhead. Otherwise you need to use ref-counting or whatever, which has a runtime cost. So to get the best out of Rust means restructuring your data and code to fit what it can prove at compile-time. Also no-one has mentioned lifetimes, which are the annotations which help the compiler prove to itself that what you're doing is safe.
(Rust person, Go aficionado here) you made me spill my hot chocolate laughing, thank you :)
Because Rust (like C) makes so few assumptions about its environment, that makes it ideal for retrofitting green threading, if someone decides to implement that. However, it will never be able to do the stack tricks that Go does, e.g. moving a whole stack and updating all the pointers that point into lower stack frames. So if you like, Go will always have an advantage there. But it doesn't mean that Rust cannot do green threading. And I agree, no language is right for all usecases, and I would happily recommend Go for the things that it is optimised for. (I am personally more interested in Pony, which has an amazing actor-based runtime and the same guarantees as Rust, but for many low-level projects with demanding requirements, Rust looks like it is probably going to be the best choice as it matures.)
Yes, 100% true. Unfortunately /u/jreid42 missed the point completely.
`env` access global, `set` shell variables.
Is there a timeline for the final 1.5 ?
&gt; uses borrow-checking to catch races at runtime Small note: the borrow-checker is entirely a compile-time, no-overhead construct. Data races are caught at compile time.
&gt; months after the release of rust 1.0 It's been seven weeks.
Yeah I still don't really get the point of it. Even if I make the situation 100x more complex I still feel that it will be more expressive in code. Could I see an example of something more complex? Genuinely curious.
The main reason to use a rules engine is when you can predict the *kinds* of logic that you're going to have to execute, but not the logic itself. An e-commerce platform might use a rules engine for promotion codes. The platform would define the environment necessary for the rules engine to operate (i.e. hooks to get information about an order, the customer, the date, …) and invoke it at the appropriate time. However, the platform would also provide an interface allowing administrators to define their own rules without needing to recompile and redeploy. This is why it's silly to use code examples of rules engines. Of *course* it's more verbose and less expressive than coding the rule directly. The key is that rules are a data structure, which means you can construct rules at runtime.
&gt; the platform would also provide an interface allowing administrators to define their own rules without needing to recompile and redeploy Thanks this is what I was missing from my thought process
You seem new to Go, so I will just give you a general code review. I pretty much just skimmed this, so if I'm not making any sense, let me know. I also commented from top to bottom, so some points apply to multiple methods, even if i don't point that out *sorry for not proofreading* * I probably just read it too quickly, but the need for a *manager* wasn't clear to me. When I dial a connection, I expect it to actually dial; I don't expect there to be some cached connection because I can already cache it myself. * You mention contention, but there is no further comment about where this contention comes from. AFAICS, you should have no issue with contention in dialing, etc. because if you're dialing so many connections that it really matters, then I'd assume you already have more interesting problems to worry about. The bad thing about this is that you've complicated to the code by interacting with locks all over the place. *make sure you run your code under the race detector*, I wouldn't be surprised if there was some bug lurking inside the locking spaghetti (see reviews below) * prefer `if ok {` to `if ok == true` and `if !ok {` to `if ok == false`... substitute `ok` for any boolean operation * FormatAddress: - feel free to keep it, but address in go are usually host:port/ip:port so it doesn't seem that useful because noone's going to think twice about how addresses are formatted * StartListening: - does the interface really need to *async*? I'd assume that if I wanted async, I could just start a goroutine myself. - Why does it accept only a port? - You're ignoring the error to net.ResolveTCPAddr(), but more importantly, it's not clear why you don't just use net.Listen(). If you didn't hardcode this to *tcp* I could probably also easily use the pkg with unix domain sockets - AFAIK, when you do multiple logs i.e multiple calls to log.Print*, you open up yourself to log interlieving so your error message might be printed out of context * startListening: - I believe you have a busy loop waiting to happen. AFAICS, you never break out of the infinite loop if Accept() returns an error * handleListenedConn: - Don't do this `headerReadError.Error() != "EOF"` i.e compare errors strings, the error value will be io.EOF so do `headerReadError != io.EOF` - t's hard to understand what's going on here, but loops look like they could be replaced with io.ReadFull - Is there a reason the message length is variable? IMO, you could get rid of all that complexity by just using a fixed number. 8 bytes will allow you to record messages sizes with a 64bit integer, and depending on the real-world uses of this pkg, maybe a unsigned 32-bit int is enough. I highly doubt 4/8 bytes overhead for each message is going to be an issue for you. - I assume those conn.Close() calls are wrong, because I assume that they will leave a broken conn in the manager maps (see the first point about why we need a manager) - In the make()ing of `dataBuffer`, you seem to be opening up your users to easy DoS attacks, both intentionally and via malformed input. If there isn't going to be some way to limit how big a message can be, then it should at least be documented - IMO re:TODO, AFAICS, by the time you call the cb, you've already read the whole message so there's no reason the close the connection if the callback fails - unless that's how the pkg is supposed to work * readFromConnection: - AFAIK, no, this `reader.Read(buffer)` does *not* fill the buffer, if you want such guarantees you'll need to use io.ReadFull - I think you can delete the rest of the function, AFAICT, it does literally nothing that `return bytesLen, err` doesn't do and if you're just going to return, then you might as well just delete the whole function and replace it with io.ReadFull * dialOut: - See the question about why we need a manager earlier. If you're going to check that I haven't already dialled a connection, then why return an error, why not just return the existing conneciton, why am I limited to only 1 connection per address (IIUC)... - If you aren't goingt to provide any context about your errors, it's nice to make the values global variables that one can compare against instead of anonymous errors.New() errors (e.g. io.EOF) - See my previous point about using net.Listen(), the same applies to using net.Dial() - See my previous comment about your locking code. I didn't run any of this code, so I can be only up to 99.9% sure this function contains a race. It also demonstrates a possibly common misuse of RWMutex in the name of performance: you read from `dialedConnections` in `RLock`, then switch to a `Lock` in preparation for an update. But between `RUnlock` and `RLock`, another goroutine could've come along an made the connection. You need to check the map again, or you could just `Lock` for the whole function and forget about `RLock` * closeDialer: - See previous comments about the locking * WriteTo: - I'm not aware of the possibily of a short write without complete connection failure, so the loops don't seem necessary. If I'm missing something please let me know - I think this function is open to write interlieving when you call Write multiple times, if it's possible for multiple goroutines to call it at the same time. I assume it's possible because you have locking inside it - I don't think there's any point in `toWrite`, just Lock the conn to guard against interlieving and write the length and data out to the connection
Making it easy to write mobile applications that use the native widgets, that work well on both Android and iOS. Use an interface designer that has a design per platform, if need be.
Thanks. Up-voted :)
&gt; Because Rust (like C) makes so few assumptions about its environment, that makes it ideal for retrofitting green threading, if someone decides to implement that. There are two caveats here: thread-local variables and blocking I/O. Rust is very big on avoiding global state, but it is possible to have it, and thread-local variables do not play well with green-threads: you need to save/restore them at each context switch, which implies knowing where to find them. Similarly, in Go blocking I/O deschedule's the green thread. Rust however does not provide the necessary hooks for a library to detect that, so it's unclear to me how it could be used with libraries that do blocking I/O without using special green-thread-friendly versions.
It's not clear one needs to win for us (users) to reap the benefits; Rust already "borrowed" the `if let` syntax from Swift and it's sweet.
I think OP recognises nothing is perfect and is just investigating new technologies to see if they better fit OP's use case.
Thanks for the feedback! I'll say that I'm not entirely new to Go, but that doesn't mean I'm necessarily fantastic at writing it. I'll address your points as you laid them out. I likely won't respond to any stylistic nitpicks, not because I don't care to, but simply because I know my go-style is already in need of work and I don't need to respond to each one to say "Yup, I should probably do that". The question of "why" a manager is really just for my personal use case. I had this code that I was writing in a few projects that basically all did the same thing. It wasn't clean though, because who / what managed holding onto the connections for listening and dialing being in different places just "felt" wrong to me. I wanted 1 clean place to keep them all, without having to worry about holding a reference to them myself. I could easily remove this aspect of it, but for how I saw using the library, it fit. Around my worry for "contention", the locks you see relate to storing the connections in a map. Maps are not threadsafe (goroutine-safe?) in go. Since I'm managing the conns, which means handling the lifecycle of adding to / removing from the map, I have to use read locks. Theres no way around this, and if you're not using locks around concurrent write-access to maps, you're going to hit an undefined behavior at some point. Your comment around using a race detector is a solid one, but anecdotally I can tell you that with the current locking code, I have not (yet!) run into one. If you have a suggestion for a race detector tool, please let me know. ### StartListening: * For the cases I had in mind, I wanted to be able to listen on multiple ports, and I didn't want the calling code to have to manage putting it into a go-routine. I wanted it, by design, to be non-blocking and asynchronous. * It only accepts a port because you'd only ever listen on a local port. Is there a real world use case for listening on a port for an address other than local? Or is it more that this VS WriteTo have different interfaces? I'm willing to make that change to keep the two consistent, as yea - that is a little bit of an oversight. * I avoided using the default Listen because I didn't want to use an interface, which net.Conn is, infavor of a direct implementation due to golangs performance issues with interfaces at runtime. I made the conscious choice to limit this, presently, to TCP, although I did originally keep it generic, and have considered moving back to it if need be. * Log Interleaving - likely the case! I'll consolidate those into single Printf statements. It'll be more performant that way, anyways. ### startListening: * Thats by design. If a client connects but it bombs out, I don't want the listener to die. I want it to handle the next connection. There is a possibility the listener is the one that had the issue, so theres something there for me to look into. ### handleListenedConn: * w/r/t io.EOF, I genuinely did not know about this. Thanks! * ReadFull - I had seen that method, and traced it back to where it comes from File in golang, but it seemed less... "natural" I guess? I wanted to use the methods available on the conn itself. Additionally, it seemed like it wasn't actually useful just given this quote from the godocs themselves: "It returns the number of bytes copied and an error if fewer bytes were read". If it can still return less than the desired number, its the same category of problem I'm currently solving for with multiple reads in loops, right? Also, Reader is an interface (unless i'm mistaken?), and I wanted to avoid using interfaces where possible for performance reasons. * MessageLength is variable because I didn't want to artificially impose a limit on someone. A standard default isn't a terrible idea, but I just didn't care to make it a hard limitation. I should put some better docs in place to explain the approach and any limitations and maybe have some smart defaults. Good feedback there, thanks. * The conn.Close() calls might just be poorly documented. Connections incoming from clients are not stored in maps. Thats only for a client using a BuffManager for holding the dialed-out connections that client makes. Incoming conns over a socket are handed to their own goroutine to run until they hit an issue. In this case, if theres a break in the process, I close the client connection and the goroutine exits via return. The client is responsible for re-connecting. ### readFromConnection: * That comment is stale :) That was my old assumption, which was proven false. I'll update that guy, thanks for calling it out. You keep suggesting io.ReadFull, which I'm not ignoring, but my above concern around using it still applies here. * As for deleting the rest of the function... perhaps. All I'll say is, in several "examples" I found for how to properly handle errors from socket reads in go, there was a special case where bytesRead &gt;0 but still an error. Maybe thats just programming by accident and I need to review if I really need that code. ### dialOut: * Thats just the way I chose to design it. I wanted something simple where dialOut didn't let you open a second connection to the same addr/port, and would return an error to short circuit the rest of the method. Perhaps there is a smarter design here, I'm not above trying to improve it (Actually, I know there is - conn pooling. But i chose to not go down that alley now, for the sake of simplicity). * w/r/t errors at the global level: A great tip. Will make this change. * You're right about the potential for a race condition in that code under those conditions. I'll definitely need to change how that works. ### WriteTo: * There is a reason the socket write method returns the # of bytes written. Under certain circumstances, the write will not fully complete. The most likely case I can give you, which is the one that came up during testing, is the effect of TCP Backpressure (or, what seemed like it anyways). When the nic is fairly saturated, you start to see writes only partially complete. It seems to be TCPs way of telling me to back off, without harming the connection itself. * It's possible to interleave, yes. TCPConns in go, from what I read, are themselves threadsafe, thus it is safe to allow them to be used from multiple goroutines. * I'm not sure what you mean about "toWrite", unless you typo-ed "WriteTo"? The point of the method is that it abstracts away all the boilerplate, and lets calling code do 1 simple thing - push bytes to a socket in a unified fashion. ### Closing I appreciate you taking the time to write up all these notes, and I'll definitely take some of them to heart, but at the end of the day it seems like this just isn't a library you agree with on a design level - and that's ok. Maybe some of the designs aren't stellar, or need further iterations (and I know they do), but I built the library to solve a set of problems I had, and wanted to share it with others incase they felt the same way. Again, thanks for taking the time to write this up. EDIT - I don't use reddit much, so i'm trying to clean up my formatting.
GCCGO is the best bet, but there are greater challenges due to the POWER architecture being unsupported. [https://github.com/golang/go/issues/7208](https://github.com/golang/go/issues/7208)
It's a common mistake. I've done it too. 
Do either http://godoc.org/golang.org/x/oauth2/google or http://godoc.org/golang.org/x/oauth2/jwt help? 
The benchmark graph is insane. http://i.imgur.com/R7kOPzh.jpg
Crystal has non blocking io by default
Except the assist time isn't stopping the world, so your application can still be running. As long as you have multiple cores you'll want to make this tradeoff.
That's a valid question - because there is no such thing as a free GC. Here is the first chart to look at: http://i.imgur.com/KzqNcgL.png And the second is: http://i.imgur.com/IVCfC6V.png As I believe Rick said in his talk, there is a tradeoff that is being made here. Absolute throughput is taking a small hit in exchange for nearly eliminating GC pauses. 
Sure, I'll *probably* take 1.5's GC over a stop-the-world any day. But I don't have any data to say "compiling under 1.5 will make our binaries average X% of total pid cpu time, instead of our current average of Y% under the stop-the-world GC." This is especially important since assist time was shown to be 50% of the execution time during a GC. Are GC's longer, now? Am I going to be spending more absolute time in the GC than before, even though I won't ever be entirely stopped? It's just data that helps understand a service.
Thank you! I come to a conclusion that it's very complicated way O_o (not for newbie's level in Go ;) ) 
For what?
Do you know how small the hit is in %?
Does anyone here use App Engine for Go in production? Can you share your experience (cost, performance, maintainabiliy, etc)?
cool project
I believe Plex does this, to a great degree.
&gt; // wraps the Reader object into a new buffered reader to read the files in chunks &gt; // and buffering them for performance. &gt; reader := bufio.NewReaderSize(rd, pagesize) This is non-optimal for several reasons; you just want to pass the `io.Reader` argument unmolested directly into `io.Copy`. First, the memory pagesize (typically 4 kB or 8 kB) is in no way related to the optimal IO blocksize (frequently 64 kB or 128 kB depending on the OS and device). Second, [`io.Copy` is hard coded to use a buffer of 32 kB](https://github.com/golang/go/blob/883bc6ed0ea815293fe6309d66f967ea60630e87/src/io/io.go#L360). Third, and most importantly, by wrapping the `io.Reader` parameter you might hide [any `io.WriterTo` optimization](https://github.com/golang/go/blob/883bc6ed0ea815293fe6309d66f967ea60630e87/src/io/io.go#L351-L355) from working. With your specific wrapping this doesn't happen; `bufio.Reader` somewhat saves you here by implementing `io.WriterTo` itself. That implementation checks if the underlying reader implements `io.WriterTo` and if so, it *completely ignores your buffer size* and [just calls that](https://github.com/golang/go/blob/883bc6ed0ea815293fe6309d66f967ea60630e87/src/bufio/bufio.go#L426-L430). Any sane OS will be doing read ahead on the file anyway so it's not worth doing anything other than just passing the given `io.Reader` straight to `io.Copy`.
I would highly suggest not using app engine for anything. Not even in go. It's expensive and locks you into a platform. It's like coding for windows, it won't work anywhere else. And god forbid if you update one freaking package.
This is something I'd love to know as well. And in pretty picture format, to boot!
/u/hobbified is correct. These are total execution ("wall time") charts in this thread.
I'd have to look at the GC code for Go 1.5 but seeing *write barrier* makes me think they are moving parts of the GC closer to Reference Counting vs Graph Tracing. There's some good papers that explain the various GC techniques, which the Go core team is probably using. They explain some of the advantages and tradeoffs to each. - [Uniprocessor Garbage Collection Techniques](http://www.cs.rice.edu/~javaplt/311/Readings/wilson92uniprocessor.pdf) - [Unified Theory of Garbage Collection](http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon04Unified.pdf)
Go runs the same way on Windows as it does on FreeBSD or Linux (aside from how syscalls work). To run a process in the background you must run it as a Windows service. I use https://github.com/kardianos/service which uses http://godoc.org/golang.org/x/sys/windows/svc . I don't really understand your second paragraph, but it sounds like a Go question, not a windows question.
A happy AppEngine golang user here. My website: http://www.tapirgames.com/ I firstly used python on AppEngine, for one my old website. To get a better runtime performance, I switched the language to Java (At that time, there is no golang). This is proven the worst decision. Java instances on AppEngine need 20+ seconds to restart. And the development speed of Java projects is very slow. That website is almost abandoned for the bad decision now. On the other hand, Golang app instances only need half second to start. And the development speed of Golang projects are very fast. Besides these advantages, Golang apps use much less memory than Python and Java. IMHO, AppEngine is the best PaaS platform, and their free tier allows multiple instances running at the same time. Unless you don't use Java, the experience of AppEngine will be happy. 
You might also want to check this out (Azure-specific, but still) - http://www.wadewegner.com/2014/12/4-simple-steps-to-run-go-language-in-azure-websites/
Linux guy here. I've got an app that I needed cgo for and wanted it to work on Windows, and spent entirely too long getting that to work (note: 32 bit go and 32 bit mingw finally got a result). If you stay away from cgo (and packages that secretly use it), you shouldn't see much difference compared to unix.
It's a Windows question. If I install Go on the Win server, how do I serve out pages from a Go server without interfering with the running PHP site on the same server. You may have partly answered the question with "you must run it as a Windows service" which I don't know anything about but it gives me something to Google for (though I found some on MSDN which are mind-bogglingly difficult to follow and understand).
Your webserver should handle it, like a proxy_pass to the go server on another port like you say in your OP. 
For C10K, I believe it's still manageable, but C10K is boring. There are mobile phones powerful enough to run a C10K server, ... it's no longer the challenge it was. Beyond memory, I wonder how most OS would react to having 1M threads to juggle.
Well if nothing else I gave you the ingredients that made it mostly work for me.
Iirc mingw is what the go docs suggests for building go and maybe also for using cgo.. Even cross compiling from debian with mingw was relatively easy compared with most other build systems i have used.
The text looks blurry on Firefox latest.
Yes I can but the question is about how to set it up on a Windows server, not how to run it.
No, it's just an API thing. Instead of giving you a transaction-type, with Rollback and Commit, the API just takes a func(appengine.Context) error, and basically does func RunInTransaction(c appengine.Context, fn func(appengine.Context) error) { tx := db.Begin() if err := fn(c); err != nil { tx.Rollback() } else { tx.Commit() } }
nice, didn't know about that. thanks :] 
Intrinsics are probably a long way off, but a good way of testing the waters might be to implement an intrinsics-like API yourself using code generation and go:generate, to generate these routines in Go assembly. Eventually could see a lot of users and collaboration, and ultimately lead to a good intrinsics proposal for Go 1.6 or 1.7 or whatever. Just throwing it out there. :)
That's awesome. I'm excited to try it out!
If the site is currently working on PHP, why would you migrate that to Go? If a basic PHP stack is getting the job done, Go seems like overkill, no? Or is this for a separate application that needs to sit alongside the PHP site?
This is exactly what I've wanted to be able to do for the last year. I can't wait to try it out
Not knowing details of the new GC algorithms, it can be relevant to how you read into the benchmarks depending on implementation. For example, if performing a parallel new GC on the JVM, 2ms for a 400MB heap would actually be on the slow side if everything is garbage. High load servers I've worked on collect 3GB of garbage in 2ms when it's all garbage. However, in a generational collector, if nothing is garbage, now things need to be moved and the cost of a GC are much more substantial. Even if this isn't a generational collector, I'd suspect there's a meaningful amount of time difference between traversing every object on the heap (or data structures like cards) vs knowing you don't have to visit entire chunks of memory.
For windows server, just the the provided link and keep it simple. Then to manage open up the services snap in (or look for the services node in Computer Management). To serve under the existing server, you could use FastCGI (if under IIS http://www.iis.net/downloads/microsoft/fastcgi-for-iis ) http://godoc.org/net/http/fcgi or you could serve on a different port and use the existing server as a reverse proxy (IIS URL Rewrite http://weblogs.asp.net/owscott/creating-a-reverse-proxy-with-url-rewrite-for-iis )
Yeah, the resolution can be improve
No, it's pure javascript. It'd be interesting to explore using Gopherjs (https://github.com/gopherjs/gopherjs) though.
There might be a higher-level approach, where you use some kind of vector API where the compiler can determine the width of instructions based on platform, or something, doing more than register allocation. At least you would have code that is much easier for the compiler to vectorize, instead of trying to auto-vectorize arbitrary code. Of course, this all means you take away some control from the user, so it's a delicate balance. It would be exciting to see someone capable put together a proof-of-concept. I would love to look at this kind of thing myself, but my compiler knowledge is next to nothing, so it would be a slow endeavor.
Though that only goes up to 600 MB 
I'm bringing it into the modern world and it's a fairly complex site with ecommerce, subscriptions, video subscriptions and so on. Currently it breaks and gets cracked on a regular basis. So a total rewrite by someone who knows what they're doing. And as someone who knows what they're doing, I won't use PHP (or Windows for that matter).
Your question is incredibly vague. You're getting confused responses because there's nothing to setup. You open a command line prompt and type `go nameofyourapp` and *poof* it's running. It's the same as running on a Go app on any other OS. If you build you Go app to listen on port 8080 it won't interfere with the PHP app. Then open a browser, type in the IP of the server along with port 8080 and you're done, e.g. `http://198.168.1.233:8080`. My hunch is you're confusing "Windows server" with "IIS". [IIS](https://en.wikipedia.org/wiki/Internet_Information_Services) is the Windows equivalent of Apache/Nginx. But you're not asking how to run a Go app through IIS. You're asking how to run it on Windows, and the answer is you run it the same way you would run it on FreeBSD.
If they've given you license for a complete re-build, and this app is the only thing on the server, I don't see why they'd insist on keeping Windows.
One of the main goals of Go is to ensure that people don't do stupid things that cause major headaches in large teams, or in 5 years when looking at old code. Instead of catering to a minority that wants to shoot off an entire leg, Go simply doesn't allow such insane things.
Vendoring is pretty much the best thing ever when building software. We check all of our third party libraries into the code base and only update when necessary. It saves a ton of headaches about misconfigured paths (the project is first in GOPATH, nowhere else to look), makes it super easy to make sure everyone has the right version (git pull/rebase solves everything). I'm kinda surprised that folks are salty about it. Nothing wrong with having obvious, simple, no-additional-tools-required dep management. 
Really well written primer, thanks!
As I know @svaarala will work at JIT in duktape in the near future. Right after basic performance improvements. Can you provide some benchmarks of node/duktape?
That's for the sake of demonstration. The sleep is there to resemble the time it takes to finish one job. Which is of course totally depends on your use case.
Maybe I'm overly influenced by recent experience, and non-Go experience, but it certainly is a major headache when you need to update a third party library, and have a large code base with many developers and that library has multiple paths leading to it. Yeah, it's not ideal design, but it happens. And, often the intricacies of the use of a third party library aren't well covered by test cases, meaning you don't know if it'll break things in live. The solution all too often ends up being either "let's just upgrade and hope for the best" or "you don't really need that new feature in that library.. you can just write your own code to do it." How much easier would it be if you could just hook up a specific version of the third party code to a file and it worked the same until you specifically changed the reference in that module? Yeah, there are intricacies that complicate that, but I'd bet the vast majority are that simple. I would also think it'd actually make removing old libraries and the associated debt easier. You fix the code you're looking at, and don't have to worry about who else is using it and how they're using it. 
&gt; Vendoring is pretty much the best thing ever when building software. Exactly! For *building* software :) For compiling and maintaining large archives of integrated software it is an absolute horror. Vendoring shifts the burdon you are lifting from the developer to the package maintainer -- and I don't think it exactly belongs there, because it also leads to duplication of effort (as there are multiple package maintainers) that can not be resolved downstream (as you are vendoring your package, so a patch to make your software compatible with a newer/older/different version of a package might not be merged). I was (still am) one of the people who argues against vendoring, not because I don't see the advantages for devs, but because I see the disadvantage for distributions. I prefer the "don't break stuff, stupid" approach, even if it doesn't work and people apparently don't understand it :) I would have even preferred making semantic versioning work. Because go is a prime candidate for that. Yes, you can not check if the *semantics* of a package change, but it is pretty simple in go, to define what "backwards compatible" means on an API-level. In the sense of: you can automatically check whether a package maintains compatibility on a minor- and debug-version level. Oh well :)
It's not because the computer is fast enough, it's because the runtime is only using one thread, the goroutine is not performing any action that triggers the runtime to switch goroutines, and because I called Gosched in main (thereby causing the runtime to switch to the goroutine). You are right though that those two operations likely (definitely?) trigger the runtime to switch goroutines (EDIT: which would cause main to exit before they complete).
First of all, I really enjoyed this post. Thank you for making it. &gt; And of course, ideas and improvements on the code are more than welcome :). Maybe in addition to terminating execution after the wait group completes, you could terminate execution after a reasonable amount of time had elapsed (to handle any hung goroutines).
Nice suggestion :), I will look into that!
[**@feross**](https://twitter.com/feross/) &gt; [2014-04-24 09:16 UTC](https://twitter.com/feross/status/459259593630433280) &gt; Facebook's git repo is 54 GB. &gt;[[Attached pic]](http://pbs.twimg.com/media/Bl-eKoEIgAArCc8.jpg) [[Imgur rehost]](http://i.imgur.com/kDnHBuJ.jpg) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
From your perspective, why use a configuration string for each endpoint instead of a struct?
Is there any part of this that's written in Go? 
You haven't been in this business very long, have you? :) Get this. This site was last coded 10 years ago. It uses deprecated PHP. Most of the pages don't have a doctype, use tables for layout, transfer credit card information in plain text ... and they don't see anything wrong with any of that. Now, I'm a high priced developer. I was hired to do this three months ago. Want to know what I've accomplished for them? Zero. Nada. Zilch. What do I do all day? Work on other client's web sites who are also paying me at the same time. I'm practically doubling my salary. Want to know the last time I talked to the guy who hired me? A week and a half ago. Haven't seen him at all. This is the type of place I'm doing work for and you can imagine the mindset. Not that there's anything wrong with that.
Not sure how you would dynamically generate a function at runtime that way
Thanks, that's a good observation. So using a sync queue ensures the shutdown time-to-wait doesn't exceed the time to process one message, but since the number of "messages in flight" is effectively (num workers) + (num buffered) you don't get that to 0 by removing the buffering. Thanks - that's clearer, ta.
Wow will that run node?
Will do. My need would be mostly minor, as I have a severe case of NIH syndrome leaving me with few outside managed libraries. I'll report back if I have issues.
I'm a go newbie with a .NET background. How does this "vendoring" solution compare to the way .NET handles assembly versions? In a nutshell: Every assembly (i.e. DLL) contains a list of dependencies, including their version number and signature. When you run the assembly, the runtime loads only the version you compiled against. Your machine can have dozens of versioned assemblies sitting next to each other, .NET will load the right one. One issue is when two dependencies depend on different versions of the same library: XMLv1, XMLv2. No problem, .NET loads both and they run independently. This works because the version and signature are considered part of the assembly name. 
This is the project you're looking for: https://github.com/robpike/ivy
Let me check with the team if/when that might become possible.
"An error" Jeez, you're really dead-set on being as vague as possible, aren't you? I don't think you have the foggiest idea of what you want to accomplish, and you certainly aren't telling us.
&gt; What about Go? &gt; &gt; [...] &gt; It’s multi-paradigm (imperative, functional, object-oriented) In what way is go functional ? I mean, is there a language in the world still in use that is less functional than go ?
Closures, John.
And the answer is "Not quite ready yet", gated on the lack of keyboard input support: http://golang.org/issue/9361
Yeah, go has closures, so what ? I wouldn't say PHP is a functional language, although it has closures too, but also many built-in basic HOF like map, filter, reduce that are a pain to implement in go. And, without those, you're doomed, because loops are imperative by essence. Marketing go as a functional language is counter-productive.
yay free tier for go deployments
Is this what you are looking for? http://play.golang.org/p/6n0qA5WsaO Take a look at fmt.Stringer and fmt.GoStringer interfaces.
This is actually really helpful to see these functions in use, but not every type actually implements Stringer() or GoStringer() from what I can tell, so sometimes I have to look for another way. Thank you!
This is exactly what I'm looking for! And interesting note about writing data or using streams. I'll try to remember that instead of something dumb like converting to a string and then converting again to something write-ready. Thank you!
They're not marketing Go.
I don't think anyone is marketing Go as a functional language, it's multi-paradigm. Most mainstream languages have become multi-paradigm too. Multi-paradigm means having concepts of different paradigms, not ALL concepts from different paradigms. Closures, Lambdas and Higher-order functions are functional programming concepts. Just because other languages are including them that doesn't make them less functional.
you can pass functions around in variables and create higher order functions (functions taking functions as parameters, or functions returning functions)
Would be nice if you are going to find it out.
It is not tunable. &gt;OTOH, we don't want the crazy tunability of the jvm and the complexity that brings. This is why it's not tunable. :) They'll continue to tune the GC in 1.6 and beyond (based on feedback).
The usual way to do this is grab (glob()) all the templates at once and add them to a map of [string]template one by one. https://elithrar.github.io/article/approximating-html-template-inheritance/ I've tried this and it is easy to understand but I found it somewhat inverted and hard to implement in what I actually wanted to do. Instead I've settled on [github.com/unrolled/render](https://github.com/unrolled/render) since it is simple to add to my projects.
I think this concept would be really interesting if it used code generation and `go generate`. I don't like the reflection piece of this as it moves the computation of the where the REST calls go to the runtime. I would rather pay that cost once when building the application and have my runtime have less work to do.
Coming soon! We have code all over the place and need to organise it so it makes a readable example. Hopefully next week, at least for the iOS code.
In my experience, I've found it best to avoid using cgo when possible. The reasons I might want to use cgo are: * The functionality you want doesn't exist as a go library and implementing it yourself would be too costly. * Your algorithm needs to run faster and you're pushing the go runtime to it's limit. The reasons I don't typically want to use cgo are: * Calling into cgo comes at a very real cost. Cleaning up the stack going into and out of C isn't cheap. * cgo builds are slower. * cgo builds are harder to set up. You introduce components that aren't `go get`-able and you often don't want to build from source. * cgo and concurrency are not friends. Concurrency isn't on by default in C, so you're going to need to think about thread safety and consider that your go functions may jump between threads mid-execution if you don't lock them down. * cgo deployments are harder. You now have to include dynamic libraries. This means you need a real deployment tool and you have to be much more careful in development. It's really easy to use the wrong version of a library on your dev machine. In light of that, I avoid using cgo unless it is *absolutely necessary*.
Which useless with out generics.
 M-x compile go test -v Is what I do. Once you've typed it the first time it is just M-x up return return 
Nice writeup! The author also has written about optimizing your rails specs, an article which I had found very useful when I found it a while back
What if you have to interact with some hardware (on Linux) via a C API/library that exists in user space and talks to a kernel driver? Would you use cgo against the library or instead look at making syscall/ioctl calls from Go?
If the C library were open-source, I'd look at its source and make syscalls from Go. 
Thanks mate. I had toyed with the idea of learning Python and circling back but at the same time I wanted to try just getting down to business - I really want to be proficient in Go and investing time elsewhere seemed a little counterintuitive but I'm not a developer... Its just things like m := map[string]int{"three": 3, "four": 4} I'm often left questioning whats the semi colon and equals there for, why are elements encapsulated into brackets etc. At the same time I'm getting places just stopping and googling really broad topics to get a base understanding. 
Agreed. I love this paper: http://cs.brown.edu/~sk/Publications/Papers/Published/sk-teach-pl-post-linnaean/paper.pdf &gt; Programming language “paradigms” are a moribund and tedious legacy of a bygone age. Modern language designers pay them no respect, so why do our courses slavishly adhere to them? This paper argues that we should abandon this method of teaching languages, offers an alternative, reconciles an important split in programming language education, and describes a textbook that explores these matters. 
No, you don't have to use Datastore. You can use Cloud SQL as well, which is a straight up MySQL database. If you want to migrate your app, switching the database connection string is all you'd need to do for your data layer.
If you're not afraid of advanced material and want to watch someone doing something, this video is really interesting: https://www.youtube.com/watch?v=yG-UaBJXZ80 (brad and andrew writing a HTTP/2 client)
A common one might be if you need to use sqlite
This wasn't the last optimization for sure.
I agree, that it works very well for companies (I interned at Google, so I do know their workflow). But I think that is a very different usecase from FOSS development (an important difference is manpower, but also politics).
I think this argument is about as usefull as "Garbage collection isn't always slower than manual memory management". I could say, that a theoretical future GC will be faster than anything you can write manually (just like compilers today create code that is much faster than anything you can write manually). But today, that's just not a very usefull thing to say if we decide on whether or not to use a GC'ed language.
You seem to forget to take probabilities into account. It's far more likely that an extremely young piece of software that compiles an extremely young language will continue to be improved _by margins_ within the next months or years. In comparison it's very unlikely that further improvements to the JVM GC(s) will give as extreme performance gains in even a span of 30 years. I can accept to use a not-yet-optimized tool when it will probably become better in a peried of time that encompesses only a very few projects, if even one.
I already have various projects I want to build. I know this is kinda the default advice to give. But part of the reason why I want advanced tutorials, is to see things like best practice, thoughts on why they are doing things in a particular way and specific results. Also to short-cut my knowledge. I have deadlines I want to meet. I don't have a month or so to hack at stuff. 
No, you really can't, not without major PITA, fragmentation and headaches. That was my whole point: For that to be a viable solution, you would then need to rely on third-party code to play well. And you can't do that. Code that isn't explicitely meant to be run with green-threads won't include this call and thus become a PITA to use with green threads. And you get the problem, that the language forks into green and non-freen code. Like C-code is basically forked into threadsafe and non-threadsafe code, or code that can integrate with certain concurrency libraries, or code that isn't.
This one. Catch the signals you care about (i.e. SIGINT) and then call `yourDBtype.Close()`. You can never truly guarantee a close (i.e. SIGKILL) but this should be "as good as it gets" under normal conditions.
I'd look out for Rob Pike videos especially on concurrency in Go.
When you don't feel like porting ffmpeg to Go.
&gt; Are you studying for a coding interview? Nope.
Wait, now I'm a bit confused. The call to `defer` happens before the call to `select`. I would expect the deferred function to be executed as the goroutine is killed. If this is not the case, then what is `defer` actually doing?
You mean that to use only one repository and vendoring needs more work from the developers?
We could use more contributors on the [Caddy](https://github.com/mholt/caddy) project - lots of cool stuff in the issues to work on (mostly suggestions, not bug reports!) as well as tests and stuff.
&gt;I'm the case of unexpected halts, defers will not run. I can't recall if that defer would run in the case of reaching the end of main() You're right, those are actually two separate questions! It seems my Python background has bitten me in the ass, here. I was expecting `defer` to act somewhat like Python's context managers. That'll teach me not to bring in baggage from other languages :/ Thanks!
Have you considered using compile time constraints instead of switches to provide platform-specific decisions? Would be a good exercise to learn how to use it.
Actually, if you have no idea why this article contains bad advice, you should use [golang.org/x/crypto/bcrypt](https://godoc.org/golang.org/x/crypto/bcrypt). It is very simple to use: // Hash a password hashed, err := bcrypt.GenerateFromPassword(plaintext, 0) // Check a password; err == nil if password is correct err := CompareHashAndPassword(hashed, plaintext)
It's great to draw attention to these issues, but there are several problems with the suggestions in this article. 1. One round of MD5 is too fast. In the event that the database is stolen, it's too easy to brute force. I would probably use [scrypt](https://godoc.org/golang.org/x/crypto/scrypt) since bcrypt truncates the input at 72 characters for some reason. 2. MD5 has known weaknesses. 3. You should securely generate a unique salt for each user and store that alongside the password hash instead of using one salt for every user. 5. Your query is technically a constant time string comparison of the password hash, so it may be vulnerable to timing attacks. edit: in #4 I meant to say "non-constant-time string comparison" but I will leave it since it's already been quoted.
&gt; But just because they sent an email with your password does not always mean they are persisting it in plaintext in their system What other explanation is there? Except for encryption of course, but that's close enough to plain text to be thrown in the same bucket.
I wouldn't say that. The Hashword code is pretty bad in at least two ways (One: it's too fast. Two: It *tries* to create different hashes for different users, but it fails in that an attacker can still find every user with a particular password by precumputing md5(salt + password) and then append-hash every username in the database). People should just effing use bcrypt. Smart people spend a lot of time with a lot of lessons learned to develop that.
You're right, I misread the sentence. (Must be tired.) I was thinking of emails that are sent right after signup, in which case they could send the email first, then hash and store the password after. If you're able to request your password be sent to you after signup, that is an obvious folly.
Did you not read /u/dominikh's comment and my reply?
Ha, I didn't see your Gosched call :). And you're right that it's not about the computer not being fast enough :). Should've phrased that differently.
The concern is that these processes may take more than a few seconds, likely after the time out. 
Thanks for the discussion guys - I learned a lot. Will update the article. Despite being addressed to programmers, it was written to explain to non-techies how we could avoid storing passwords but it's right that the advice is sound.
Thanks
For something like this had a redis cluster. I pushed the job into redis then pushed its id into a queue. The node doing the job updated its status in redis and would respond to messages to ensure that the node was still alive. The web front end just returns the current status of the job, don't try to do it synchronously as this won't be failure tolerant.
FWIW I wrote a wrapper around Go's scrypt lib that handles salt generation, storage and allows upgrading of scrypt params as needed: https://github.com/elithrar/simple-scrypt I also wouldn't count "truncating at 448 bits" to be a deal-breaker for bcrypt. bcrypt is still very good and that's not functionally its weakness as a) most users won't be generating keys that long or b) if you are using it to derive a key for a block cipher then it will be much shorter than 448 bits! The major reason to use scrypt is that it has a "tunable" memory hardness (e.g. 16MB end-to-end) that can make it very hard to brute force. Even GPUs will be restricted by total RAM and access speed. 
In a system that I'm working on now, we send an AJAX RPC call to the server (looks remarkably like a JSON+REST PUT), the server shoves the request into an in-memory queue (map[string]thingy), and then a go routine picks items off the queue and processes them. Feedback is provided by sending the results to the client using websockets. The user doesn't even need to stay connected and can come back later because of the websockets goodness. Multiple users can use the system at the same time for the same reason. The goroutine trickiness of shoving data into the map, pulling it out, processing it, and then sending feedback requires a single goroutine in this system, and is really straight-forward once it's written. It only takes about 70 lines of code. It took me several hours to get my brain around using goroutines instead of thread-safe queues/collections like you would in Java.
Interesting! Do you know where I could find an example of such as system on GitHub?
You wouldn't transcode images and videos using the same process that's handling HTTP requests. Those should be two different systems, and should eventually run on different servers or in different containers. You don't want a catastrophic crash while transcoding a video taking down your website, and mixing transcoding and HTTP handling doesn't scale. So you need at least two apps. Call them web.go and transcode.go, and you need a way for those apps to communicate with each other. As others have said, you should use a message queue. For small to medium size projects I recommend [beanstalkd](http://kr.github.io/beanstalkd/). ([Go library](https://github.com/nutrun/lentil)) It's easy to install (`sudo apt-get install beanstalkd`), and easy to use. I've been using it for 5+ years to process millions of messages a day, and it hasn't crashed on me even once. When web.go receives an upload, it should save the file to a central location (could be /tmp on a single server), create a database entry for the file, and then insert the row id into beanstalkd. The transcode.go app continuously polls beanstalkd for new messages. When it gets a new message (a row id) it fetches the row from the database, transcodes the video/image, and updates the row to reflect the status of the transcode task, e.g. "success" or "failure". What happens in web.go after inserting the beanstalkd job depends on your needs. You could send a response and close the connection. You could poll the database for the success/failure flag and send a response when the status changes. You could send a response, close the connection, and use ajax/websockets to poll for the status of the transcode job. It depends on what you're trying to do.
I don't. I designed this system myself, but the code is protected by confidentiality agreements. Sorry. :(
Check out how this was accomplished with [Djinn](https://github.com/thrisp/djinn).
I'm using Nitrous as the IDE
More resources and emphasis on getting new programmers to start with Go.
No, I didn't :) There was a delay between "I opened the page" and "I started writing the reply". During this delay, these comments where written :)
Is that speaking from experience, I know Go switched from cooperative scheduling to pre-emptive scheduling some time back; were there specific issue with cooperative scheduling? As far as I know, while pre-emptive scheduling is more flexible, there is necessarily a (minimal) performance impact so cooperative scheduling offers a slightly better throughput and, in our case, does not require changing existing code. I would think that as long as the I/O routines and channels (mutexes/... whatnot) are green-thread aware, you could mix and match code as far as scheduling is concerned. However the Rust experience is that making mutexes green-thread capable as a certain overhead which prevents full performance in the case where green-threads are not used... This is one of the major factors which caused green-threads from being gutted from the language; there was no known way not to take a performance penalty in the non green-threads scenarios, and Rust is all about "you don't pay for what you don't use".
I'm shocked this isn't the very first and top-rated answer.
Yes, use a key-derivative function (bcrypt/scrypt/PBKDF). Note that salt is not not needed with bcrypt for instance. The OP article is wrong in that regard. Checking a password with and without salt takes the same amount of time. And use **dictionaries** to check for weak passwords instead of special character checks: (self-plug warning) [why](http://blog.klauspost.com/password-requirements-done-better/) and a [golang library](https://github.com/klauspost/password) to help you do so.
Maybe worth a look: http://www.golang-book.com/guides/bootcamp
&gt; Therefore you end up with different universes of mutually incompatible code, the one that uses greenthreads and the one that doesn't which is everything but decent concurrency support. Thanks for explaining this so well. This was the point I was trying to make, but you did a far better job making it. I think you're also right about about the ramifications. Rust is still very young, and we'll see how it evolves - maybe it will figure out a way to overcome this problem. But Go's intelligent scheduler is not a zero-cost abstraction, so the entire idea of green threading seems to run counter to the design goals of Rust. Who knows though, maybe it will get something roughly equivalent.
Quit :)
It shouldn't be because it doesn't scale at all especially when doing image or video processing. As /u/headzoo said, it should be separate components communicating over some network protocol.
This is the best way. But I'd even say that `transcode.go` should report results back to an HTTP API provided by `web.go`, not to some DB. This way you have a nicely abstracted interface between both services.
Huh? I only glanced but I looks like a normal MIT license. There's nothing wrong with that. I usually give a license to everything I do, primarily because it allows people to safely use my code.