Besides thinking about examples like the street artist singing cover songs down the street (you do not send him away because he’s not playing his own repertoire), the mobile deejay playing a selection of hand-picked tracks in a bar (you do not ask the bar owner to send him away as of the same reason), or a stand across the street asking you to donate money to a good purpose, you maybe also should read the [code of conduct](https://golang.org/conduct#values) of r/golang. Not only do the values show there’s room for a very wide variety of content, also those that do not in itself form an introduction to a discussion, it also makes clear that you should be open for somebody’s argumentations and show respect such as a normal human being would do. By the way, ask yourself a question: [are you one of the 75% of software engineers that not or incorrectly credits a Stack Overflow snippet](https://arxiv.org/pdf/1802.02938.pdf)? Now if you want to start a crusade towards in your eyes so-called injustice, then this is a typical example of bad morale/ethics. Maybe you should start improving yourself if you want to make the world a better place in that case. And probably you want to, as ethics is your thing. Other thingie: have you downloaded creative content via torrents? If you did, you are one of the millions of people talking about ethics while they have a bad morale themselves. Creative products, such as content, are just as much worth as some code copy/pasted from Stack Overflow. And with my non-profit newsletters I try to create a stage for the efforts of blogging Gophers, as they often do not plug content themselves at Reddit/Hackernews or another outlet.
Besides thinking about examples like the street artist singing cover songs down the street (you do not send him away because he’s not playing his own repertoire), the mobile deejay playing a selection of hand-picked tracks in a bar (you do not ask the bar owner to send him away as of the same reason), or a stand across the street asking you to donate money to a good purpose (you do not accuse them of street spamming), you maybe also should read the [code of conduct](https://golang.org/conduct#values) of [r/golang](https://www.reddit.com/r/golang). Not only do the values show there’s room for a very wide variety of content, also those that do not in itself form an introduction to a discussion, it also makes clear that you should be open for somebody’s argumentations and show respect such as a normal human being would do. By the way, ask yourself a question: [are you one of the 75% of software engineers that not or incorrectly credits a Stack Overflow snippet](https://arxiv.org/pdf/1802.02938.pdf)? Now if you want to start a crusade towards in your eyes so-called injustice, then this is a typical example of bad morale/ethics. Maybe you should start improving yourself if you want to make the world a better place in that case. And probably you want to, as ethics is your thing. Other thingie: have you downloaded creative content via torrents? If you did, you are one of the millions of people talking about ethics while they have a bad morale themselves. Creative products, such as content, are at least just as much worth as some code copy/pasted from Stack Overflow. And with my non-profit newsletters I try to create a stage for the efforts of blogging Gophers, as they often do not plug content themselves at Reddit/Hackernews or another outlet.
These methods have limited use since you only get back strings. If you actually need to do something with the result, use [this](https://github.com/miekg/dns).
Using it from my code was very smooth, and it worked perfectly the first time I tried it :-) &amp;#x200B; (I got hit by a COORS issue using the command line version, and didn´t understand the error message until I opened the console) &amp;#x200B;
Besides thinking about examples like the street artist singing cover songs down the street (you do not send him away because he’s not playing his own repertoire), the mobile deejay playing a selection of hand-picked tracks in a bar (you do not ask the bar owner to send him away as of the same reason), or a stand across the street asking you to donate money to a good purpose (you do not accuse them of street spamming), you maybe also should read the [code of conduct](https://golang.org/conduct#values) of [r/golang](https://www.reddit.com/r/golang). Not only do the values show there’s room for a very wide variety of content, also those that do not in itself form an introduction to a discussion, it also makes clear that you should be open for somebody’s argumentations and show respect such as a normal human being would do. By the way, ask yourself a question: [are you one of the 75% of software engineers that not or incorrectly credits a Stack Overflow snippet](https://arxiv.org/pdf/1802.02938.pdf)? Now if you want to start a crusade towards in your eyes so-called injustice, then this is a typical example of bad morale/ethics. Maybe you should start improving yourself if you want to make the world a better place in that case. And probably you want to, as ethics is your thing. Other thingie: have you downloaded creative content via torrents? If you did, you are one of the millions of people talking about ethics while they have a bad morale themselves. Creative products, such as content, are at least just as much worth as some code copy/pasted from Stack Overflow. And with my non-profit newsletters I try to create a stage for the efforts of blogging Gophers, as they often do not plug content themselves at Reddit/Hackernews or another outlet.
thank you for your feedback! &amp;#x200B; Yes the COORS is a little shit hehehe, when you use the GraphiQL in a diferent server that your GraphQL server, you need enable the COORS in your GraphQL server, we will add it to README to help other people. Thanks!!! :)
What's the point of this? $ dig facebook.com a facebook.com aaaa +short 31.13.65.36 2a03:2880:f111:83:face:b00c::25de $ dig m.facebook.com cname +short star-mini.c10r.facebook.com. $ dig -x 6.8.8.8 +short tms_server.yuma.army.mil. $ dig facebook.com ns +short a.ns.facebook.com. b.ns.facebook.com. $ dig facebook.com mx +short 10 msgin.vvv.facebook.com. $ dig _xmpp-server._tcp.golang.org srv +short golang.org. $ dig facebook.com txt +short "v=spf1 redirect=_spf.facebook.com"
No perl on system? Single static binary?
I have both his premium courses and I think they're worth it. I think the value for me isn't so much in the material itself, but being able to listen to an experienced engineer build apps from scratch and have him explain his thought process along the way. If you're just looking to learn Go itself, then there are cheaper alternatives (i.e. books), but there's nothing else close to these courses in terms of quality and I've searched around.
Typically critics actually bother to critique, though. You're just walking into a room and farting.
dig is a static binary.
Java is JITed which means that when the JVM detects a function is called a lot it will spend extra time optimising it. Since it has actually usage patterns theoretically it can apply better optimisations. In practice, it's not that useful and the performance is pretty similar between Go and Java. Go does tend to be a little bit better with memory usage, but depends a lot on your code. Here's some synthetic benchmarks comparing them: https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go.html
Thanks for the detailed insight.
&gt; The result is easy for the compiler to use (it just runs types through contract bodies in a regular typechecking process) FWIW, I don't think this is true - in fact, that's my main criticism of the contracts proposal. The expressions in a contract will always be a subset of the expressions allowable by it (one example is the one from the design - where `t == t` is used to imply that `make(map[T]bool)` is allowable. There are a *lot* more and more ambiguous examples). Coming up with a clear algorithm to determine the actual allowed function bodies, without false negatives or positives, is going to be very hard. What *would* be easy on the compiler is a purely interface-based approach. An interface explicitly mentions the methods allowed to be called on it, so type-checking a function body against an interface-constraint is easy (and already implemented). Likewise, checking that a concrete type implements an interface is easy and already implemented. A complicated type-inference/type-checking engine will also be hard to understand by programmers and failures are easier to explain - and the contracts proposal is really complicated to type-check.
Right, but values are only delivered once. So if your channels are wired up as inputs and outputs, then they will depend on values going through them. If you start reading from every channel then you are effectively stealing them out of the circuit which defeats the purpose of having the circuit. It seems very reasonable to end up in a deadlock if you steal a value from one part of the circuit then try to steal it from another but a value won't be able to make it to that part now. 
Go is different because it doesn't allow for test doubles to be created at runtime. Gomock does a nice job generating them for sure. Also, gomock makes real mocks unlike other libraries that create some form of a fake. It takes assertions for example.
I don't understand your comment. He's saying Contracts seem like they're optimized to be easy/elegant to implement in the Go compiler, at the expense of de-optimizing for 1) people who write Go code, or 2) people who write Go tooling such as code analyzers. I find this really believable given how Go is, in general. I like it in some respects but a lot of it feels like the team had tunnel vision on some issues, distinctly more than any other language.
I haven't yet bought his new courses as I can't afford them right now due to real-life stuff (sad face), but I can sing praises for his other project, [Gophercises](https://gophercises.com/). It's free, so you can take a taste of his style. I feel like he is not as so much 'teaching', as creating something in idiomatic Go, and like you're sitting by and pair-programming with someone who knows his stuff. The projects themselves are structured like when you finish them, you've built something actually practical. You'll certainly have to pay attention, and it won't be the hand-holding read the basic documentation like, but that's why it felt so fresh and useful to me. I think Jon hangs around here every now and then, so you could PM him with specific questions.
Sure, it's got its own wire protocol, but so do others - like the postgres wire protocol, mongoDB wire protocol...
Good stuff
I see from the result set that you have 3 timestamps in the table. As you're using gorm.Model, I believe one of them is deleted_at. So your select (when gorm is doing its thing) is actually: SELECT * FROM sessionusernames WHERE username = 'Erwan' and deleted_at is not null; I believe that is what is happening - which means that you should unset the deleted_at value.
I think neither contracts, nor your approach keeps the *user side* of things simple. There is nothing that prevents a compiler from doing the right thing with **only** the following: func foo(type T) (t1, t2 T) T { return t1 + t2 } with a function definition like that, `foo(1,2)` would compile but `foo(true,false)` would not. The fact that anything else is being considered at all is a sign that end user simplicity is being sacrificed for compiler simplicity and that's very un-Go in my opinion.
I'll test it
there is a golang lib for it already. see here: [https://www.reddit.com/r/golang/comments/4zaw4x/dig\_command\_written\_pure\_go/](https://www.reddit.com/r/golang/comments/4zaw4x/dig_command_written_pure_go/)
There have been various posts on this topic recently. In real use, you probably need CA certificates if you talk to any external services, and it's often a good idea to add an unprivileged user to run your binary as.
The whole thing with building from scratch to get the smallest possible image is misguided. Most of the time image size isn't a concern. If you know it is then usually what you want to do is minimise the differential between the base image (which is probably already in use on your docker /kube host) and the image produced by your build system. Here, when building from scratch, the author of that repo tries to create a surrogate 'minimal os' by using go compiler flags and copying files to avoid using a real distribution. They've neglected to include SSL certs which will cause problems (or did for me last time I played around with scratch) It's easy to overlook something and get it wrong, and there's not much benefit to getting it right. Separate build of the binary and build of the final image (docker multi stage builds is just one way) and you've probably done enough. 
&gt; Go modules famously try to avoid including a SAT-solver - because it creates hard to explain errors when the heuristic fails Go modules are not strictly *better* - they just have different trade offs. See [this thread](https://github.com/gofrs/uuid/issues/61) for a recent painful example. &gt; I honestly don't understand how anyone can look at Go and say "it's not Go-ish to limit the amount of type-inference done". That's not what I've said though. I said a specific example of missing type inference is not Go-ish and in the case of generics, I stand by that statement.
Gopherfile does have SSL support (added one hour ago). With this, you do have added simplicity of having one build procedure. Building the Dockerfile alone builds everything required for the project to run, while running two build processes does add a little bit more to the procedure. I understand that there may be some scenarios where your way would work better. With my method, there are minor technicalities to watch out for, but what's wrong with it?
The core readability problem is that straightforward looking Go code has non-obvious requirements on what types can satisfy it because of subtle language semantics. The compiler can and will get these semantics right, because that's its business, but some people definitely won't and some code in tools and so on is likely not to either. An example of tricky code (from the article): contract Example(t T) { t.Fetch()[:5] t.AThing().Len() } Both of these lines impose additional type restrictions that people may not realize. They may also not be intended restrictions, since contracts are likely to be written in a compact style that doesn't actually directly reflect what the code in the generic function implementation does. For example, suppose the actual code in the generic function does: temp := t.Fetch() [...] t2 := temp[:5] Then the contract has imposed a requirement on `t.Fetch()` that is not necessary for the actual generic function to work. (I'm the author of the linked-to article.) 
I bought Web Development with Go after seeing Gophercises and the table of contents, as my specialization tends more toward operations and production engineering and I was interested in seeing the "whole package" to look for my own gaps. Jon walks through the entire development process in a way that resembles pair programming. I would highly recommend this course, it is excellent and I wish there was more content out there like it. &amp;#x200B; I also picked up Testing With Go based on my experience with the web development course, but haven't had a chance to go through it yet.
Building from scratch isn’t a complete novelty. It reduces attack surface significantly. This can really matter in enterprise security. 
How does it do this compared to using a minimal base?
Are the videos downloadable or stream only?
Yeah the contracts can get confusing for people reading them(and probably even for tools).It's a bit better for tools, since they can always be patched up everytime a new edge case is reported, humans however are on their own. &amp;#x200B; It would be a sad day, however, for me if we ever got generics without a way of constraining the type parameter/s.And unfortunately, none of the the few counter proposals I've read have a better(in my opinion) way of constraining params.I think the one that has come closest is Roger Peppe's\[1\] where he proposes: &gt;I propose that instead of allowing arbitrary code in contract bodies, we allow only an extremely restricted syntax. Every statement in a contract body must consist of exactly one expression that uses exactly one of the following operators: \- all arithmetic and logical binary and unary operators \- channel send, receive and close \- array and map indexing \- function call \- type conversion \- interface conversion &amp;#x200B; 1. [https://gist.github.com/rogpeppe/45f5a7578507989ec4ba5ac639ae2c69#contract-bodies](https://gist.github.com/rogpeppe/45f5a7578507989ec4ba5ac639ae2c69#contract-bodies) &amp;#x200B;
The comment was why use resolver lib instead of dig. Dig isn’t ambiguous, and if you distribute or run your app as a single static binary you won’t use dig. 
If you want to minify your binaryfile, I think this should not be ignore: [https://github.com/upx/upx](https://github.com/upx/upx) &amp;#x200B; My binary file went from \~12MiB to \~2MiB using that. But do read up on what changes are made to your binary before you actually use it.
Bad idea. Interfaces currently are single static types that can contain different concrete types at runtime. If you overload them for generics it becomes much harder to understand because now they could also be static concrete types instead of dynamic types. Golang's type system is easy to understand right now. Overloading interfaces is going to make things like "non-nil nil" a real problem because you'll have interfaces that are not interfaces.
Certs and other dependencies make things a bit more complicated and manual especially when you have to deal with Cgo. You can use DockerSlim to automate all that :) 
I haven't tested this, and I certainly haven't read enough about cgroups and the other machinery that is used on the kernel side to implement containers, but this code look so unintimidating and nice that it makes the topic look entirely tractable. 
You can also use Unscoped to fetch for rows that have been soft deleted via the deleted_at column
It's difficult to know, and you should always be sceptical. However in this case I don't think so. The guy who wrote the book doesn't seem like he would do such a thing. He has offered a lot to the Go community as free content as well.
I just went ahead and purchased it.
&gt; …but without sacrificing Go's speed… it is from project readme. And I can't see how it is easier than using regular `strings.Split` or better `bytes.Split`.
Doesn't sound all that hard to me. func bar(type T Foo)(x T) ... T is only guaranteed to implement Foo, it isn't literally one.
I'd like a bit more context here. Is this attempting to totally reimplement Docker or some subset of it? Really, there's not a lot for me to get excited about. There are multiple OCI implementations usable today (Docker, rkt, &amp; gVisor are ones I can think of off the top of my head.) It might be a cool project that I just don't understand the goal.
Use fakes, not mocks. Fakes are simplified but functional implementations of an interface (for example: a datastore repository that uses a simple in-memory map instead of a RDBMS). The kubernetes ecosystem does this extensively. Yes they take longer to write than running gomock, but you get a much better way to write unit tests (and decouple different package's tests).
&gt; Go modules are not strictly better - they just have different trade offs. Literally what I said. &gt; I said a specific example of missing type inference is not Go-ish and in the case of generics, I stand by that statement. Agree to disagree then, given that Go currently specifically (and intentionally) lacks exactly the level of type-inference needed to make your example work. &gt; especially since Go has opaque and unhelpful error messages today, like slice of unaddressable value. What is "opaque and unhelpful" about that? It seems to describe the actual problem perfectly (especially when combined with the position). It definitely seems better than ``` • No instance for (Num a1) arising from a use of ‘+’ Possible fix: add (Num a1) to the context of an expression type signature: forall a1. a1 -&gt; a1 • In the expression: x + x In the expression: (\ x -&gt; x + x) :: a -&gt; a ``` (which is the error message GHC produces for your example - and still super simple, comparative to typical cases).
&gt; This sort of makes sense in an environment where generic functions will be used by people more than they'll be checked themselves, since the use-time checking is the easiest. It may make sense viewed from that angle - but all of that complexity isn't needed at all with just as powerful alternatives. I mean, if we'd use interfaces to specify constraints, *both* of these sides are simpler than with contracts and in fact are already implemented (on the usage-side, it's [types.Implements](https://godoc.org/go/types#Implements) and on the generic-function side it's checking that only methods of the interface-constraint are used). That would bring us already 95% of the power of the contracts design, with only existing and incredibly obvious algorithms. If we'd use some declarative spec for the rest (operators), there would only be minimal changes needed (basically, look up the `reflect.Kind` in a map to see if it supports the operator). So it seems misleading to say that contracts are in any way easy for the compiler - given that even the simplest and most obvious alternatives for generics are almost trivial to implement and understand. :) FWIW, I don't think we really disagree much here. Basically I'm just saying "what they said - plus, it even makes the implementation *a lot* harder than better alternatives" =D
Without associated types, you can't express constraints on multiple types. 
It's no different really then athletics. Some people just have a natural gift. Others have to work real hard at it. Then there are a lot that can get by at a moderate level and make a good career out of it
I learn best by building stuff. Make a game, a website, a note keeper, what ever.
Yeah I hated the course. So boring and dry. 
For both courses videos are downloadable as DRM-free mp4s if you buy the complete package.
I'm the guy who created the courses. I don't use any marketing companies, and if I did and they did something like this I would drop them in a heartbeat. I hate spam like you are describing. &amp;#x200B; I wish I could do more to prove that I had nothing to do with both this question and any responses, but unfortunately I don't know how to prove it. Suggestions?
Which course did you check? Both courses should have download links if you got the complete package. If that isn't there, something is wrong and I need to address it!
Its a fancy HTML feature called the `textarea` =P I just put it inside of a nice envelope looking shell. Thought it looked nice, and glad you liked it as well :)
I have no respect for Python the Hard Way. The first chapter begins with a long rant about the importance of not having typos in programming… followed by a misspelling of the name of Apple’s operating system. Why trust someone who can’t live up to his own standards?
It will click if you persevere. Every good programmer I know, myself included, has had hours and days swallowed up by not understanding some (later seen as obvious) thing. Some of us are lucky in that we got a good portion of our bash-head-against-wall learning done when young enough that it didn’t hurt our egos so much. So dig in, and either cultivate the belief that it’s ok for it to be painful or be prepared to come out bruised. 
I learnt by using it. Google what you need and keep going. Try to really understand what you're copying from stackoverflow so next time you grasp the concepts behind it. Go is pretty straight forward. As you advance, you'll see that the documentation makes more sense. 
This is sort of a digression, but I think that interfaces are not powerful enough for type contracts for good generics. In their current state they're limited to talking about methods on types; they can't restrict the types themselves, and they can't require types to have specific fields. I think it also creates readability issues for situations where you have constraints between types, as in the Graph example. Perhaps these problems could be solved, but my view is that Go basically has one chance to get generics right and I would rather Go wait than introduce limited generics that would be hard to improve in the future. (For future improvements, contracts have a subtle advantage. Because they can include anything that a function body can, the scope of what contracts can require naturally expands as Go's general power increases. In an interface-based generics system, expanding the scope of generics would require expanding the scope of interfaces themselves, or creating a larger and larger divergence between 'interfaces for generics' and 'interfaces for plain code'.)
I see. But doesn't using text/template remove some of the safety features of html/template that are specifically related to projects intended to be used online?
Can you name one great athlete that didn't have to work really hard to be great? One that's just like, "nah I don't really practice much, this stuff is easy for me"? People that are experts at something have put in a lot of effort to get there. The "natural gift" idea is unfortunate because it just encourages giving up if something isn't immediately easy. I think people that get labelled with a "natural gift" are just people that love practicing the thing they are great at. So they practice a LOT.
It doesn't support Windows, hasn't had a commit this year, and depends upon libpcap, so there is much room for an alternative.
&gt; doesn't using text/template remove some of the safety features of html/template […] Yes, that is correct. If you have `&lt;div&gt;{{ .Content }}&lt;/div&gt;` whatever you pass to the template via `v.Content` will be escaped, which means you cannot do anything about the HTML break tags to render the new lines in the page. If you are able to find a way to do that, you have to consider that a vulnerability and I encourage you to report it to the Go team to fix it. Now, if you know that `v.Content` is safe, then you can simply use `text/template`. But if `v.Content` contains text that an user submitted, then you should use `html/template. Let me know if you need more information.
It's hard to learn without a forcing factor. For some it's a university. For others it's taking an entry level job you aren't totally ready for yet. For me, I had written enough / worked enough by the time I found Go that it isn't a great example because it was pretty easy for me, but when I was more junior (and curious about Python) I needed to write a web scraper to gather information to make a Family Feud game for my bride and I to host a game show at our wedding reception. The scraper was a simple single purpose tool that I HAD to finish in time. So I did! The frontend (JavaScript) was harder because until that point I was only used to desktop code in C#, but I was able to build on the css and html from someone else, so it was still closer to bite sized than a lot of people attempt. Besides my wife, I also didn't want to let down my friend who constructed the hardware parts. Look for very small tasks that might be very important to you. That can be hard to find, but I found it to be essential.
My advice is don't get impatient - it seems to me this is about allowing your mind to sediment the huge quantity of information you get. I remember years ago, when I've read "Design Patterns: Elements of Reusable Object-Oriented Software" everything seemed so clear, but I wasn't nearly close to understanding the code, only the concepts. I had to re-read that book three times until I got to "see". Later I've realized that this comes from how things are presented to you, the reader : sometimes it lacks good abstraction (the "what" you are trying to solve) and other times it lacks encapsulation (the "how" you are going to do that). Knowing that, you can look for alternate sources to complete the knowledge that is not present in a course or a book. As a side note, you can look for a mentor and that person should be capable explaining things to you using labels and jars, trains and semaphores... And also, prefer articles and videos where you get the answer on "why" things are like they are (which usually have a nice piece of history of the concept). 
Or [this](https://github.com/shuLhan/share/tree/master/lib/dns).
The “Firebase Admin SDK” is for administrative actions only _(fetching user data, changing the user’s email, etc)_ without their existing password. If you want to sign in as a user, you need to use the Firebase Authentication SDK. • [Authenticate with Firebase using Password-Based Accounts on iOS](https://firebase.google.com/docs/auth/ios/password-auth) • [Authenticate with Firebase using Password-Based Accounts on Android](https://firebase.google.com/docs/auth/android/password-auth) • [Authenticate with Firebase using Password-Based Accounts on Web](https://firebase.google.com/docs/auth/web/password-auth) • [Authenticate with Firebase using Password-Based Accounts on C++](https://firebase.google.com/docs/auth/cpp/password-auth) • [Authenticate with Firebase using Password-Based Accounts on Unity](https://firebase.google.com/docs/auth/unity/password-auth) • [Authenticate with Firebase using Password-Based Accounts on etc…](https://firebase.google.com/docs/auth/)
Right now this looks like a learning project to me, maybe in the spirit of Liz Rice's famous [lizrice/containers-from-scratch: Writing a container in a few lines of Go code, as seen at DockerCon 2017 and on O'Reilly Safari](https://github.com/lizrice/containers-from-scratch).
Ok
Read up on javascript web tokens (JWT). These make it pretty easy and there's some good go libraries for this 
Fucking alpha beta pruning... I could write it, but it was following a recipe that I knew worked. Took a loong ass time to understand it on a gut level.
[this is a great resource on hashing + salting passwords](https://crackstation.net/hashing-security.htm) 
The point of programming is building stuff. There are CS geeks out there who are fascinated by the concepts involved in coding, but the overwhelming majority of programmers are software developers/engineers engaged in building things. Rather than go through a course trying to learn all these concepts, with barely any practical application (which is clearly not working for you), try building something. Pick something you'd really like to build, and start working out how to build it. As you build it you'll discover useful bits of CS that you can apply to the problems you're facing, and because you have a concrete example in front of you, you'll find it easier to understand. I was lucky, I was a teenager in the 80's, and had an 8-bit Acorn Atom at home. I wanted to make arcade games, and had to learn all sorts of stuff (memory models, fetch-execute cycle, register use, Assembly) to do that. But computers were simple back then, so it was easier. But then, we didn't have the internet, so finding answers and learning stuff was harder. That basic understanding of how a computer works has stood me in good stead ever since. TLDR: I learnt to code by building stuff and picking up what I needed as I went along. Maybe give that a try.
Don’t use JWT for basic authentication, use sessions for this instead. 
Here is a fun link: https://latacora.micro.blog/2018/04/03/cryptographic-right-answers.html This will give you a general sense of what to work with. Regarding secure login, your bedrock will be having your whole site go through HTTPS. Once done, all passwords should be hashed using either scrypt or bcrypt. This will be good enough for storing your passwords. As for handling sessions, you’ll want to generate a session ID that is random and put it into a cookie. I recommend the sessions package from Gorilla. It pretty much handles almost everything and has good defaults. Ensure you still check for CSRF. I think gorilla has a package for this now, but I am not sure on that. If you have anymore questions or need specifics, reply to this or feel free to DM me directly. 
Agreed!
And that's a good reason for a project. It would be nice if that was a bit more clear somewhere obvious.
Google is storing my passord for my Google Accounts. Facebook does the same, not talking about Reddit. Amazon has stored my password, when I had an account. Maybe they have changed that.
firebase.com (Google) has a great product using JWTs. It supports username/password, Google, Facebook, GitHub and SMS logins. All this is handled and stored on their side so you do not need to store any personal information which is nice. They have SDKs for most popular languages and detailed tutorials. I use it for securing backend APIs. When client (ie frontend) developers need to setup security, all the documentation are available in Firebase docs, which saves a ton of time. It is also fully customizable. Worth checking out.
You might want to read up on the projects that Ory has: https://www.ory.sh. They have some great solutions at many different levels.
It says for authentication And authorisation. JWTs are perfect
Instead of scrypt or bcrypt, I'd recommend [Argon2](https://en.wikipedia.org/wiki/Argon2) for new systems. There is a [Go lib](https://godoc.org/golang.org/x/crypto/argon2), too
JWT's are fine as long as you can store everything you need to know in the token itself. The instant that you need to pull session data from the database before being able to respond to the request then you lose almost* all the benefits of JWT's. *almost, because if you craft your tokens right, then other systems/parts of the system (e.g. Caddy) can use them to determine if your user is logged in or not.
I didn't know rkt got their OCI implementation running. Last I've heard they hadn't made any real progress as the aci vs. oci difference required them to make some big structural changes. 
That's true, I need to have the same endless loop around every "connection", in order to do what I intend.
Well, of course not in plain text. That's a different matter.
The course looks like it has a lot of material, it might be good for an absolute beginner. I read the sample chapters of the book and decided not to buy. It was slow going on stuff I have covered elsewhere. Since the author is in this thread, it would be useful if you released one of the later chapters as a sample so people can see how the more advanced material is covered.
Agree. Take a look on [https://github.com/ory/hydra](https://github.com/ory/hydra). Ready to use solution, all you need just implement identity server.
Just in case anyone read this exchange and goes away thinking encryption (ANY Encryption) is acceptable for password storage on its own: No it is not. If it is possible in any way to reverse it and get the plain text password from what is stored in your DB or anywhere then it is not good enough for passwords. This is security 101. Just salt and hash the passwords and use a secure hashing algorithm like scrypt or bcrypt. Encrypt the DB to secure the data in general, but encryption on its own is not acceptable for password storage. 
I think I can honestly say that I've never had that moment of the "penny dropping" when it comes to programming. For me the learning started slowly and was self motivated; I discovered this mysterious black window and very straightforward editor for QBasic. I used it to help solve my maths homework and it opened up a world where I was able to direct a computer to enact my will. It had no libraries or frameworks. It only did procedural programming (something I've always needed in my career, be it object oriented or functional paradigms). But I taught myself the basics of conditional branching, iteration, procedure calls, variables, primitives data types, arrays, etc. In higher education I was formally trained in Java and again the power of abstractions and design patterns open a new world of problem solving. Since leaving formal education I stumbled across functional languages like Clojure and it gave me a whole new way to approach a problem and shone a light on multiple solutions. Everybody learns in different ways, for me I needed to conquer a concept before moving to more advanced concepts. Having a language which is unencumbered by advanced tools that the professionals use meant that the error messages were always at the right pitch and I didn't become side tracked by subtleties like scoping rules, etc. There are programming languages specifically designed for teaching programming. In each stage of learning the language is effectively a mini version of itself to allow the learner to explore without becoming lost. But at the end you graduate to a full featured professional language. I have heard that DrRacket is an IDE that works in this way: https://docs.racket-lang.org/getting-started/index.html. I think it's a great idea and wish I had had that 20 years ago...
I use https://auth0.com for almost everything auth related
Since it hasn't come up yet: [https://www.owasp.org/index.php/Password\_Storage\_Cheat\_Sheet](https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet)
Just use Auth0. Spend your tome on the parts of your product that users need instead of reinventing the wheel.
I'm quite sure most languages can have their features made to look worse than they are with highly contrived code...
Strictly speaking, the channel need not be buffered for the idiom to work. Having a channel of length `N` merely allows `N` goroutines to actually succeed in sending its event while the receiver is blocked. Whether this is really needed is an open question; I'd say that buffering should be added only after a consideration of whether it's at all needed (i.e. whether it actually required or at least buys something performance-wise). The problem with buffered channels is that they may be prone to hiding synchronization bugs which do not crop up until a "real" contention patten which typically happens in production rather than in unit tests ;-)
Ding ding, this right here. If you don't know what you're doing (and don't be ashamed to admit you don't!) when it comes to authentication, then outsource it. Even if you *do* know what you're doing, it's likely still better to use eg. Auth0 since it'll save you a ton of development time
I've got many Go projects working with Go and sql server. They work flawlessly. I've used both of these libraries with no issues. [github.com/alexbrainman/odbc](https://github.com/alexbrainman/odbc) [github.com/denisenkom/go-mssqldb](https://github.com/denisenkom/go-mssqldb) &amp;#x200B; &amp;#x200B;
I find Go much easier to reason about, I can build a web server in a dozen lines of code from memory using only the built in libs. I like that all go code is formatted to look the same and I generally find go code much more readable. I really hate magic. I've been doing programming for almost 30 years c/c++/c#/objc and i've rejected OOP. Inheritance is a cluster\*\*\*\* IMO. I'm also not a huge fan of exceptions. I prefer go's explicit error handling. &amp;#x200B; c# is a fine language and if go didn't exist, its probably what i'd be using.
Taking this opportunity to ask opinions on OpenID Connect. This doesn't seem to be too popular as of yet.
`panic`ing on big `k` and `v` would require to check `k` and `v` lengths before calling `cache.Set`: if len(k) + len(v) &gt; 64*1024 { // handle this case } else { cache.Set(k, v) } This is definitely more complex comparing to simple: cache.Set(k, v) 
I've updated my version, to take this issue into consideration and now it works like a charm! Basically instead of having to "fill" up the channels sequentially, each one backed by the other, I just set up a provider for each wire, as soon as that signal has been calculated. That means as soon as a value of a separate node is ready, it can be pulled from the wire any number of times. I added a waitgroup and cancellation for good measure.
In effect, building the graph was my goal, but instead of using an iterative graph algorithm, using channels like this makes the value propagation reactive instead! I've [7p1.go](https://github.com/rhardih/aoc/blob/master/2015/7p1.go) if you'd like to see what I mean.
&gt; Can you name one great athlete that didn't have to work really hard to be great? The idea is that some people can put in less work to achieve the same results. Nobody becomes a top athlete without putting in a lot of work, but if you or I were to put in the exact same amount of work, it is likely that we still wouldn't be top athlete material. &gt; The "natural gift" idea is unfortunate because it just encourages giving up if something isn't immediately easy. Why's that? I think it is fair to say that people are more likely to give up on something that they find difficult, but I'm not sure there is anything about "natural gift" that encourages giving up. &gt; I think people that get labelled with a "natural gift" are just people that love practicing the thing they are great at. But that implies that they are already great at something in order to have that love. Which is reasonable. I think it is undeniable that some people will take to things more easily and quicker than others. One only has to look at the extreme end of the human spectrum to see that (lack of) practice isn't the only limiting factor.
&gt; How do people become literal wizards at programming? 1. Have a problem to solve. 2. Break the problem into smaller and smaller components until a component is small enough that you can grasp it. If you cannot grasp it, break it into even smaller pieces. Once you have grasped something, move onto the next one and keep going until you've solved the entire problem. 3. Look back on what you've done and think about how you could have done it better. 4. Goto 1.
I learned things from this article (thanks!) but I couldn't come to the same conclusions. The `if` check examples were consistently easier for me to read and reason about than the article's "Panic-Driven Error Handling" recommendations. That said, I also find the Go 2 error proposal confusing to read, so perhaps it's just me. I'm only moderately experienced with the language.
More like it would require programming in a way that you don't rely on large keys and values.
Would have liked a sentence about avoiding such errors elsewhere too. Like any use of ioutil.ReadAll with attacker controlled data.
What's ur problem if u take a look at what I've send u know that I've worked a lot to understand my error 
It works ^^ 
The author's example includes this code: t.Fetch()[:5] t.AThing().Len() This is Go code. How is this not optimized for people who write Go code? What am I missing here?
Oh, that's quite far for me haha. Maybe there's a website where they make this? Maybe something written on the bottom of the cup? Well thanks and congrats again! 
&gt; it would be useful if you released one of the later chapters as a sample so people can see how the more advanced material is covered. Email me - jon@calhoun.io - and let me know which videos you want to sample and I'll send them over to you. This also applies to anyone else; I'm definitely willing to provide samples of later chapters upon request. If you prefer ebook samples I can do that as well but it is trickier (I have to recompile the book with chapters missing which takes more work). I don't offer samples like this without a special request because everything builds on itself in the course, so if I just gave away a sample of say Ch 11 then most people would open it and immediately be confused. This isn't like GOPL or other books where each chapter may build on concepts from the past, but the code is mostly isolated. In my web dev course each chapter expects you to have the code from the previous chapter because we work in the same codebase adding new features, refactoring, and more. I'm not opposed to offering these samples, but I like having a chance to explain this all before sending over the sample so I ask that people email me directly to get one. I have also found that many people prefer to sample different chapters, so this gives me a way to offer more customized samples as well. Hope that helps!
1) I get the idea. I don't really agree. Athlete might be slightly different because of possible genetic factors and age, but I'm sure the best athletes have been working their whole lives from childhood, which could add up to a TON of work done. If I was to try and match the best athletes, yeah I surely couldn't match them because I'd have 20 or 30+ years of catching up to do. I suppose one perspective could be that a "natural gift" is having that head start as a child. 2) Personal experience and observing others. Nothing concrete of course, and I can't say I've seen it often. I think the encouragement is subtle, or maybe it doesn't always exist. But like when you see your peers doing well and things "click" for them and not for you, and someone says they just have a natural gift for it, (IMO) it makes it sound like they haven't done any work... It was just natural. So only YOU have to work really hard at it for it to "click". 3) I don't think that implication exists. Counterexample: I absolutely sucked at programming when I was a kid, but still loved trying to do it. All I did was just try to follow books, and I couldn't even do that well. The concepts didn't make sense for years. There can be a ton of different motivators. I don't believe, when starting out, it's that you're already good at the thing you're doing. I think when someone takes to something easier, it's because they've already gotten practice of some sort in their lives, probably a lot of it indirectly. And yeah, I agree there will always be extremes and outliers. I just think the difference in the amount of work needed from person to person is negligible compared to the total amount of work needed. (Sorry for the numbering, I'm on mobile and don't see any formatting options for quoting.)
no you somehow misrepresented (to yourself) an unintended behavior of a third-party application to mean that everybody should not actually use the features that are new in 1.11 
This panic recover pattern is similar to the recover induced bug that took down cloudflares dns servers. :| 
now if the tools are very important, than yes, you are right not all of them managed to support modules in time
&gt; I get the idea. I don't really agree. I'm not sure the science really supports your position. For example, academic success, which seems closely related to learning how to program, is strongly predicted by genetics. It is not a complete death sentence for those who do not have the right genetics, but they indeed have to work much harder to close the gap. &gt; I don't think that implication exists. I mean, it literally says that. Awkward phrasing, I suppose.
I know I'm a bit late to the party, but here's some more advice: Change your post to remove the recommendation not to serve files with the Go webserver. People find these things and start doing the wrong thing. The easiest thing to do would just be to remove the entire post, but if you want to take the time to fix it you can. But it is absolutely a false statement that the Go webserver is not suitable for serving files.
What does `Warn` do?
That would reify the current problems with errors lacking context, and indeed, if you literally mean to take strings, make them actively worse. There's some other problems with it too. The short version is, you can't just bodge a feature from one language on to another. Even if the feature is good. And I'm a bit less enamored with the Rust solution than a lot of people. I haven't used Rust, but it's very similar to the Haskell solution, and that has problems too. If Go had the Rust or Haskell solution, I wouldn't be surprised we'd _still_ consider it inadequate as a community. I won't disagree that it's better than Go 1.0 in the micro, but in the macro I'm way less convinced.
wut
Abusing \`panic\` and \`recover\` to save yourself some typing would not be acceptable to me in any the projects I oversee. Write Go as it is intended to be written, or use another language.
Most of the time you don't actually want to panic a error. So was thinking warn could print the error, and then continue/break/return depending on scope 
I think you're right, I had forgot about how big an issue that was and somewhat assumed they had made progress.
Print where? stdout? A GUI dialog? A log? Which log?
Oh yeah. I figure you know how your country wants your address formatted better than I do. Funny that this is a novel idea =D
I'll admit to reddit that I'm seeing other people: [https://stackoverflow.com/questions/53459902/go-vulnerability-analysis-for-security-compliance](https://stackoverflow.com/questions/53459902/go-vulnerability-analysis-for-security-compliance) &amp;#x200B; Just linking that here to help others on similar quests.
Go 2 is likely to get a per-call variation of try/catch via named handle blocks, see: [Go 2 Error Handling Feedback](https://github.com/golang/go/wiki/Go2ErrorHandlingFeedback) and this broad survey of error handling requirements: [Requirements to Consider for Go 2 Error Handling](https://gist.github.com/networkimprov/961c9caa2631ad3b95413f7d44a2c98a) Also the author overlooks the Error Values proposal, which is tentatively targeted for Go 1.13: [Go 2 Error Values Draft Design Overview](https://go.googlesource.com/proposal/+/master/design/go2draft-error-values-overview.md)
Is it well organized. Does it strike you as it being written by someone who knows their shit?
I think it's a bummer they mostly stopped working on this. I like a lot better rkt's no supervisor service required paradigm. 
Absolute madman! I can see this being useful for running non-PSR-7 compliant PHP applications without the need for Apache/nginx.
Does this compile the code in the background first?
One of the best things about Golang is the explicit error handling. Syntax aside, it forces you to think through HOW you handle your errors. Quite the opposite of the "happy path"-first approach where you focus on the "algorithm", Go treats errors as first-class citizens. In certain types of programs (hint: server-side software), lacking proper supervision trees (a la Erlang/Elixir), this improves the robustness of your code. I would never trade this for some typing. In my book, the code that hides error handling using panics is just wrong. It's like using exceptions in other languages for clever flow control. It's non-idiomatic and a hack in most cases, even though there are arguably some cases where it has its uses. In case someone thinks I'm biased: I came to Golang with a strong FP background in Lisp (Clojure) and ML-influenced languages (Haskell, Elm). I \_wish\_ there were generics, \_with\_ there was a way to compose error handling code (monads) and so on BUT I also appreciate the simplicity of Golang. I'm happy to trade the additional expressiveness for how easy it is to onboard new developers to it and how easy it is to understand other people's code. 
Go for a $20-40 VM, maybe? Hard for others to tell without details like req/sec you want to hit, is it CPU intensive or just CRUDish web app, KB transferred per request, etc.
I think /u/APEX-KILLA mean't you should store the hashed passwords instead. "Don't store passwords." as a blank statement isn't helpful at all for this kind of conversation. Not sure why it is being upvoted.
https://github.com/nsf/termbox-go 
Oops im a bit late to the party but huh. What i meant was that basically don't have anything related to user security on your server instead let companies like facebook and google do the hard work, and so you can just create a facebook application and signup users by facebook. This means that you can stop worrying about user security and just store the normal user related stuff for example level or coins in a game... *How does this work?* Signup users with facebook then you get that user's id (different for every profile), then you store the user's stuff in some kind of database with the fb id as the key so you can later get the data by that id... then each time a user wants to sign in you just call a simple function in the facebook sdk to login the user and if its successful then you call your database and ask for the user's data.
This is basically how all of the apps I've made so far work.
Basically errcheck and never ever shadow or use named returns.
In short, wrap HTTP request bodies in [http.MaxBytesReader](https://golang.org/pkg/net/http/#MaxBytesReader) to prevents client from accidentally or maliciously sending a large request and wasting server resources. _This only applies for parsing `multipart/form-data` or `application/x-www-form-urlencoded` request bodies._
If only there was some term to denote that `panic` and `recover` are reserved for exceptional error cases. To be used as an exception to the rule... 
I'm bracing for requests to install "GordPress" and "goMyAdmin".
https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/ is fairly good iirc. though it doesn't go into the recover hitting it 
\&gt; Since I'm mostly correct most of the time, you should take that as a good sign. A good sign of what? I've been agreeing with you, not rebutting you. \&gt; Also, this implies you've been ignoring my critique of your terminology aesthetics. I think your critique missed the point. The topic was roughly "the semantics WRT 'interpreter' and 'VM' are murky"; I just elaborated on that topic (e.g., "a CPU would satisfy a sufficiently abstract definition of 'interpreter'"). &amp;#x200B; I really don't understand the combative nature of your posts.
That's because in Rust those would just be method calls on a Result (or Option) type. Go's multi-return error patterns don't mesh so well with that approach.
[removed]
There's no such thing as a standard web application. Start low and monitor, then upgrade as necessary.
I like Go's error handling and don't see what's the problem with it. It may seem verbose, but if you handle the same amount of exceptions explicitly, that's not going to be less verbose...
Depends on many things but recommend starting SMALL and measuring usage from there. :-) A little CPU and RAM go a long way with Go...
[Go Scripting](https://blog.cloudflare.com/using-go-as-a-scripting-language-in-linux/)?
Page 3-4 of the first tutorial I read. 😎 YMMV both in respect to what you’re good at and what tutorial you read. A far as becoming a becoming a wizard, what level of wizardry do you refer to? I feel like I get an upgraded hat and cape every 10 years or so. 😊
I feel like you're going somewhere except I just can't figure it out. Usually I have good intuition, this must be the exception. 
Thank you very much, this is exactly what i need right now
OK, I got it, [https://golang.org/doc/code.html](https://golang.org/doc/code.html)
It's quite simple. Your gopath has those 3 folders. Every project you do goes in the appropriate location within the src folder. When I say appropriate location I mean based on git repo URL. e.g. if your repo url is http://github.com/hevel-varik/superproject, you should locate your project in: $GOPATH/src/github.com/hevel-varik/superproject/ When you do `go get` on any dependency, it will be put in the appropriate location in the $GOPATH/src folder. e.g. $GOPATH/src/github.com/someproject/dependency You should then put those dependencies into your `vendor` folder if you need/want to lock your project to a specific commit hash. e.g. $GOPATH/src/github.com/hevel-varik/superproject/vendor/github.com/someproject/dependency To recap; there is 1 GOPATH. Everything lives under there. Your repo is your project. Note, I have not addressed anything about `go mod` at all. 
Thank you very much
[Border Gateway Protocol](https://en.wikipedia.org/wiki/Border_Gateway_Protocol). It is how isps and others all work together to find routes between any two ip addresses. It is one of the most basic building blocks that make the internet work. And one of the biggest weak spots security wise.
Definitely use miekg for dns over this. Tried and tested over many years and applications.
The reason I think you're confused is because you twice objected that the contract contains Go code--a claim nobody ever contradicted. The main point of the article is to say the generics aren't good, and one of the points we're stuck on alleges that the shortcomings may be because they're more focused on the task of implementing the spec on the compiler than the usability and ergonomics of the language. 
Who will print it? And how to know whether or not the process should be continue/break/return'ed? Then, the code will probably end up like: n, shouldIContinue := strconv.Atoi("6").Warn("could not convert number", logger)
Other encoding than chunked shouldn’t be a problem IMO, ioutil.ReadAll should be fine
I appreciate the shoutout, I really do, but honestly I'm a little torn. There was a post a day ago asking whether my courses were worth it and this starts to feel like... well a weird advertising scheme. I also don't want to cause issues where posts like this one become too frequent and lead to mods needing blanket rules to combat them. I think there are lots of great paid courses/books/etc related to Go (eg Thorsten Ball's Writing An Interpreter In Go), and I enjoy hearing about them in this subreddit, but I could easily see how it would get old quick if they were posted every time there was a sale.
&gt; And that's a good reason for a project. Absolutely!
The community would have no other reaction except shun. 
Well perhaps it is when the application is panicking about stuff
Awesome ideas here. More interesting than the concept is the way he’s published the interfaces that tell you they aren’t implemented yet as a way of getting feedback! This is peak golang in my humble opinion...all the best parts. Otherwise, I like that it solves some of the issues with the ergonomics of net/http. It’s anaglous to HTTParty in the ruby world imho. Will be interesting to see how it develops.
Good rundown: https://hackernoon.com/a-story-of-a-fat-go-binary-20edc6549b97
It includes the debug information and the Go runtime. Run "strip &lt;exe&gt;" and "upx -9 &lt;exe&gt;" for fast results.
Long story short, go’s runtime is baked in to the executable. Final size depends on a bunch of variables.
This is the dude who wrote LiveJournal.com, and memcached I do believe. He’s typically got some decent ideas lol. 
Only with limited readers
It’s just super impressive to me that he’s producing such solid tech constantly for nearly 20 years now. A lot of great open source developers can’t touch that. Maybe I’m just an admirer. 
Since some won't realize, I'll add that `upx -9` will cause your binary to be have a noticeable speed penalty before they start. Fine for servers that only start up occasionally, less okay for programs you run often.
Thanks, I think this is what I was looking for!
I wouldn't say noticeable unless your application is huge, but it definitely does some work before the application can run. And of course one should use manpages to understand what the commands do before running them.
Exceptions in all languages are used for everything, not just for exceptional cases.
If you are serious about your channel please follow this. 1. Don't make small videos. 2. Take a concept and explain it in single video like 60 mintues. 3. Cover all the corner cases and nitty gritty details. 4. Create organised tutorials. Step by step. Don't skip any topic 5. Don't let the user to go to Google for something related golang. 6. People have to say if we come to your channel we can master Complete golang with all nitty gritty details.
Nice timing :)
[removed]
Great presentation and demos of using Go Cloud [https://github.com/google/go-cloud](https://github.com/google/go-cloud) to utilise object storage in both AWS and GCP 
This is a property of the Go compiler, not Go "the language". gcc-go produces smaller executables.
In addition to the answer others given, if you would build your program with (a recent enough version of) GCC, which has a Go frontend, I'd by default would be built to link against the shared library containing the Go runtime, `libgo`, and your program would be comparable in size to a C or C++ program implementing reasonably the same set of functionality. Note that still the external packages would be linked in. This, again, can be solved by building them as dynamically-linkable libraries but that's just not _the standard_ approach to build and deploy Go. IMO these days the size of the binary is the last think you typically think of. When I say "typically" I imply the fields Go is used most: networking/system services. Of course, there are people who manage to run Go on embedded devices and even bluetooth sticks, but those require special approaches to building anyway.
https://github.com/golang/go
This looks nice!
&gt; Go 1.11 includes preliminary support for versioned modules as proposed here. Modules are an experimental opt-in feature in Go 1.11, with the hope of incorporating feedback and finalizing the feature for Go 1.12. From https://github.com/golang/go/wiki/Modules I'm still waiting to move to Go Modules at work for a similar reason to OP - the tools and ecosystem at large aren't entirely ready yet. We want a stable proxy, and all of the core Go tools to work with modules, and that isn't the case yet. On top of that, there are still tons of libraries that aren't modules, so hopefully by 1.12 that will have changed (if not, that wouldn't stop us from moving to modules if those other issues were resolved by 1.12). I'm using Go Modules for my personal projects, and open source things I'm working on because the stability is less of an issue there, and I don't need a proxy.
I think that is a very good idea, and of course I will update the course along the way. You just gave me an amazing idea. Initially I though I should start with the basics and beginner mode, however doing it in parallel I think would increase the productivity of the channel. Doing one beginner level video and doing a more advanced video. But we'll see how we do with timing. However your advice is considered
Thanks man, it has to be a worth subscription
Hi NaveenCoder, I must say I highly appreciate your pieces of advice and for sure I'll keep track of them. However I think first 2 points are disputable. I think People get bored when watching long video like more than 15 mins. Also people get annoyed when then channel only scratches the surface. So I'll try to not go above 15mins but for sure I will not do short 3-4 min videos which are usually not comprehensive. Speaking of nitty gritty details. My channel is all about that. I hated to watch video courses which only scratch the surface for the sake of timing so one the main reason I started it is because of this
Looking forward to make more useful content daogiatuan. Stay tuned
Totally agree with you here, will keep the length in mind for next videos
GokiPedia?
I can think of 'generic over named field' functions, but I suspect that they are effectively duck-typed polymorphic functions in generic disguise (although this is not necessarily a bad thing). However, I still feel that it would be a significant mistake to create a version of generics that was limited this way without a compelling reason, because I think that Go has only one chance to do generics; whatever limitations it accepts at the time, it's going to be stuck with. On interfaces as the model for generic constraints in general, I've been thinking about it and I believe that my fundamental objection is that interfaces are focused on what I feel is the wrong thing. Interfaces are designed and oriented around saying things about method functions on types, while I think that many of the important things that people want to say and do with generics are not about methods at all. One of the concrete problems with using methods to say things is that you cannot give methods to other people's types, including standard types like `int`. I believe that this is going to force any interface-focused method of specifying constraints into increasingly awkward contortions (some of which have already surfaced in your proposal). As a specific example of this problem, I believe that any generics proposal where people cannot implement the ever popular `Max()`, `Min()`, `Sum()` and so on and then apply them to both standard types and types from other people's packages is not worth adding to Go. In fact I think it should be easy and simple to implement `Max()` in any generics proposal that's really worth it. 
Sure, I've heard Rob Pike say the same thing, I'll try to adjust that in future videos
And OpenId. And yes I'm totally a Fitzpatrick fanboy. 
Not really in the background, but yes -- it uses `go run` to compile and run it.
Alas. I wonder why? 
Vendoring is becoming a thing of the past. Now [modules](https://golang.org/doc/go1.11#modules) can be used and GOPATH is not needed.
Main reason is because I have a large volume of legacy code that still needs to run in an update environment, so being able to invoke PHP code from Go will be great.
Ah yep! Good point. Haven’t migrated to it yet. We just upgraded to 1.11.
Totally agree, it’s why I said a well balance between time and the body of a video lesson should be well constrained
Direct link: https://github.com/aykevl/tinygo Project description on GitHub: &gt; TinyGo is a project to bring Go to microcontrollers and small systems with a single processor core. It is similar to emgo but a major difference is that I want to keep the Go memory model (which implies garbage collection of some sort). Another difference is that TinyGo uses LLVM internally instead of emitting C, which hopefully leads to smaller and more efficient code and certainly leads to more flexibility. &gt; My original reasoning was: if Python can run on microcontrollers, then certainly Go should be able to and run on even lower level micros.
Fantastic! Would love to see all of it actually.. as I keep trying to get started and get stuck on other things. Glad I could help and look forward to your compilation of tutorials!
I have a OT question. Did you write the Table of Contents of README manually or is there a tool for that? It looks very nice!
Big if huge
I did a writeup some time ago... https://appliedgo.net/tui Maybe you find one there that suits your need.
It was done manually by our developers, It's always nice to hear positive feedback and I'll pass it on.
We need your benchmarking code. And if you really mean a regression, versions of windows and go that it used to work well on, and the current version that the regression is in.
Hey Jon, thanks for responding!! I didn’t know people take these things so awfully out of context So much so that it comes out as advertising but I see your point. I was just trying to say that your course is great and other people can benefit from it. I hardly post here but I do enjoy the great conversations. Really don’t have a say on how the mods should interpret a post — to each his own. Bad timing? Probably. Bad course content? Hell No. Keep up the good work. Cheers! 
Cool, really nice article, thanks for sharing!
A reminder if you're handling any kind of potentially untrusted input, you should fuzz your code. I have a tutorial walking through fuzzing a simple library here: https://medium.com/@dgryski/go-fuzz-github-com-arolek-ase-3c74d5a3150c
Codes bolognese.
What is the purpose of the types folder?
Say I want to do a basic project like measure 2-3 sensors, control a relay based on sensors and the ability to ping/send small data (IoT'ish) over wifi. What boards and sensors would you recommend? Any major negative compared to C++ on Arduino other than support for sensors? Is energy consumption much higher? &amp;#x200B; Thanks for this. I'm dreaming of the day we can get near full support for go on a microcontroller. Small blips from the GC aren't a concern for me. 
Nh, the code still has to be compiled...
Generally to maintain the Structs of external sources. Like if you make a rest call, and you get big struct, then u may wanna maintain those Structs separately. Of course it's optional. Helps me in distinguishing what's internal and external.
You are right in your assumption that this is not possible in Go. Gos structs are best seen as plain data and so they are not like objects who are responsible for retaining their invariants. In Go we assume developers read your documentation and don't do things out of the ordinary for no reason. If you want to enforce invariants document them (// Serialize only takes populated AccessTokens). If people break your documented invariants they are to blame, just don't enforce undocumented ones. For you concrete problem write a NewAccessToken function. You can still make the zero value useful to signal absence or failure like in Serialize ("" expresses failure).
Can't turn out worse than his previous side project.. :)
This sounds interesting! I'll have a deeper look into it, though currently the concept is too abstract for me to really grasp it.
You mean 'commons'?
JSONUnmarshal has a dst parameter, so that theory is false. What would be the difference between dst and ResponseData?
Ok, I have a question: Since my business logic relies on data, I put my data in the domain. I will accept making my structs with fields ID, CreatedAt, DeletedAt and UpdatedAt for database compatibility. &amp;#x200B; However, the infrastructure should decide and what is what. This means, I need to define primary keys, indexes, etc. in struct tags for the corresponding struct. I don't want to do that in the domain, since this creates an implicit dependency e.g. with \`sql\` if I make the Model as follows: // Address is a helper type for storing addresses type Address struct { ID *uuid.UUID `sql:",pk" json:"id"` CreatedAt time.Time `json:"-"` UpdatedAt time.Time `json:"-"` DeletedAt *time.Time `sql:"index" json:"-"` Street string `json:"street"` Zip string `json:"zip"` City string `json:"city"` Country string `json:"country"` } How do I go on about that? I mean, I don't want my domain to decide on things that the infrastucture is in charge of. Do I need to create a new type with the same fields and corresponding tags in the infrastructure? Sounds rather tedious, doesn't it? This would also go for the json tags. 
Where do you put database code? Inside the business logic? How do you make sure the business logic doesn't depend on the database or the application layer?
With ~30M libgo so file linked in. libgo file should be present where your program will be run. Also goroutine threading is different between gccgo and go.
If `Handler` errors out (returns an error) the `ResponseData` would contain unmarshalled body.
I don't think so, and I'm not sure if they ship internationally, it sounds unlikely. My girlfriend just got a really cool Golang Illustration and stamped it in the cup basically.
So, dst would be nil? Error? And if no error? Thats a thing that interface doesn’t answer/explain fully. Maybe I should reread the motivation with fresh eyes tomorrow morning ;)
https://github.com/katzien/go-structure-examples/tree/master/domain-hex/pkg Take a look at this. This is from a nice talk at Gophercon about Go and Hex Architecture. I actually asked the same question you just ran into because, in her examples, she was defining multiple models. You can see her answer to me here: https://www.reddit.com/r/golang/comments/9oaz2h/kat_zien_presenting_how_do_you_structure_your_go/e7u1jms/?context=2 I wasn't too keen on having multiple models for the same type of data, but I've been doing some testing and thinking on it and it does make sense in some cases. For you, you can have your main domain model that has attached business logic. It's probably a pretty heavy struct. Then you can have the DB representation (a completely separate type struct) and the API representation (also a completely separate type struct). If you look at the github example I linked above, you could go even so far as to have different types based on input/output for the API.
 Most common board supported are Arduino UNO and BBC micro:bit , None of them has wifi capabilities, but it should be possible to use any of them with a ESP01 through serial for wifi, here is a more complete list https://tinygo.readthedocs.io/en/latest/targets.html As someone who like to tinker with arduino and similar boards, It's suuuuuper fun to work with.
You may get some additional context as well by watching her talk from Gophercon. https://www.youtube.com/watch?v=oL6JBUk6tj0
Most likely different headers you are sending or not sending. My guess is something to do with the locale or language. Check what headers are sent in the browser with its Dev tools and print out the headers before you send the request in golang, might need to somehow capture the headers after the request is sent though. You can do that with your own minimal http server that simply logs the headers for each request or using something like tcpdump, wireshark or a http proxy.
Well you could always have something like a .Handle( ) Statement. The point is that there's shortcuts so you don't have to repeat yourself as much 
I'm coming from a Java background, but my approach is down functional lines. Each package would contain the types, DAO, HTTP handlers, service layer, etc. However, I only export what I need to. Never the DAO itself, but a service layer that will work in terms of the DAO and any other service layers that it needs to - that protects from underlying changes. I also don't export the HTTP handlers, but do export a function that will register the handlers - again just to keep things isolated a bit. I'm not sure how good Go this is, but it seems to work for me.
And it's 1.9M with the go 1.11.2 compiler. $ go build -o main main.go $./main Hello, World! $ du -h main 1.9M main $ ldd main not a dynamic executable
What involved in getting this on windows? Powershell is alright but it looks terrible. 
TinyGo does not support any network interface yet. It doesn't even support BLE yet (although I hope to have \_some\_ support in the near future). However, as mentioned below you can of course communicate with an ESP8266 over UART. Because TinyGo uses LLVM under the hood and LLVM emits efficient machine code, energy consumption should be about the same as C/C++. In fact, \`time.Sleep\` sets the processor into a low power state theoretically putting it in the 3-5µA range (untested). I think that the micro:bit has the best support at the moment. See: [https://godoc.org/github.com/aykevl/tinygo-drivers](https://godoc.org/github.com/aykevl/tinygo-drivers)
Due to the way browsers render content, newlines are pretty much ignored (excluding `&lt;pre /&gt;` tags). The easiest way to solve this is to replace newlines with `&lt;br /&gt;` as you said. The `html/template` packages escapes all content passed to it as template variables (for safety), which ends up turning `&lt;br /&gt;` into `&amp;lt;br /&amp;gt;`. Depending on whether or not you trust the content of the text file, you have two options to avoid this; 1. If you trust the text: treat the contents of the text file as raw HTML, replacing `\n` with `&lt;br /&gt;` and indicating to `html/template` that you trust the source (and to not escape it); // This code should go where you render the template. "pageContent" is the content of your text file. // Replace all newlines with br tags. pageContent = strings.Replace(pageContent, "\n", "&lt;br /&gt;", -1) // Indicate to html/template that the content is trusted and should not be escaped. htmlContent := template.HTML(pageContent) [Go Playground](https://play.golang.org/p/BiHtDPpJtfN) 2. If you don't trust the text: first escape the contents of the text file, then replace `\n` with `&lt;br /&gt;` and finally indicate to `html/template` that you trust the source (and to not escape it); // This code should go where you render the template. "pageContent" is the content of your text file. // Escape the page content ourselves so that it can be trusted later. pageContent := template.HTMLEscapeString(pageContent) // Replace all newlines with br tags. pageContent = strings.Replace(pageContent, "\n", "&lt;br /&gt;", -1) // Indicate to html/template that the content is trusted and should not be escaped. htmlContent = template.HTML(pageContent) [Go Playground](https://play.golang.org/p/AaOviPUszCX)
Thanks for your work, I have used it in my project. [https://github.com/opentradesolutions/opentick](https://github.com/opentradesolutions/opentick)
I assume you don't have any experience with micro controllers. Get a wemos d1 mini clone from AliExpress. It will cost less than $3 and has built in wifi and many gpio pins (for reading sensors and controlling pins). At the same time you can pick up some relay boards that will cost about $1 each. These are very easy to use. Just connect the wires (power, ground, signal) to the controller and you can toggle the relay state by setting the gpio pin high/low. You can run a web server on the controller, or have it connect to a web server, or whatever other protocol you like. Commonly people will use MQTT for sensor type data, and this is easy to set up yourself with the mosquito MQTT server (written in go). You can also use MQTT to send commands to a controller. I have several projects following this pattern (sometimes using a transistor instead of a relay), programming the controller using the arduino ide. 
DB code inside models.
Thanks for that. I have a couple uno’s and pi’s that I play with so I know very little. I guess I’m trying to figure out if this is any good for intro/newbie arduino stuff. Seems like it’s not.
I have taught programing and am currently also in Todd McLeod Golang course. Todds course is really long. And if you edited out his mindless talking I am sure it would take half of the time. The thing about Todd is he is a university professor and he teaches his course that way. He does into alot of detail that most language tutorials wouldn't. It sounds like it is not the right corse for your learning style. &amp;#x200B; I think my advice would mirror much of what others have said start by doing something vs just trying to learn. That being said I would add one thing. Take a look at why you are wanting to learn programing and what is the best way for you to learn to do it. &amp;#x200B; I learned programing in college so I went the more traditional route, but the the first program I actually wrote was because I was watching an episode of futureama and they were talking about compound interest over 1000 years. I didn't believe the numbers in the show so I wrote a couple line program to compute it. the point of the story was I wrote the program all 6 or 7 lines of it because I wanted to solve a problem I had. You need to find a simple problem for you to solve and build from there. &amp;#x200B; Look for things that you would have fun playing with and that you can break down into smaller parts. Like home automation. Start with just figuring out how to turn on a hue or lifx bulb. Then figure out how to turn the colors of the bulb. Then move on to writing a program that checks the weather and turns the light blue if it is going to rain. &amp;#x200B; Home automation not your thing? Ok pick something else small to solve. How do you download a movie from youtube and save it, Write a program that organized your pictures on your hard drive, Make a chore chart for your kids. Like big bang theory? Write a program that manages your enemys list like sheldon. Start with something small and build on it. And you will get it. 
The rule of thumb is that only package main, or really just func main, has the right to terminate the program. Everything else should bubble errors up to their caller.
You'll need some haskell level type wizardry to pull off that non-sense. Also, this isn't a "pipeline" it's a state machine.
I'll add my own corollary to this, but I'm not making any claims as to it being a good practice: Any initialization function that *needs* to succeed before your program does anything useful should be able to call Fatal* As an example: if my program loads a configuration file (toml, YAML, JSON or whatever) and the reader fails, then it should be able to just terminate the program.
No one wants php. There is no real reason to use php, except you are a bad programmer or haven‘t seen the light in real programming languages yet... 
When writing gode for å very specific domain, using a DSL is often the best option. This also goes for ie. C++ that often embed Lua.
I'm personally not a fan of using a \`pkg\` directory. Over time, that directory is going to explode with random functions that you don't know where to put because you didn't structure your project correctly from the beginning. Your code is super nice though! I didn't have a problem understanding how everything flows.
I am working on a project to help gophers find answers for these type of questions. Hoping it will be a community effort. It is not complete yet and may not be of lot of help for you. But request you to take a look: [droplets](https://github.com/spy16/droplets)
Thanks a lot for reviewing. You are absolutely right about `pkg`. I have seen this happen too.. More often than not, "re-usable" parts of the projects are not really re-used and eventually this same argument becomes the justification to add random packages. However, I still followed this pattern due to the lack of a better one (that i know of). I would love to hear what other patterns you have tried and works well. Would be really good to have issue on the repo to discuss different approaches which can later be used by others to refer and decide what works best for their usecases. 
Huffman code the data with a high sharding factor. 
Care to chime in more? I was thinking of a token containing role (enum), userid.
https://github.com/willnorris/imageproxy There are also others out there in Go if you google “Golang image service”. I’d suggest you use and contribute to one of these
&gt; I'd use type Stack []int rather than a struct if there's nothing else in the struct. The reason I am not using that is because it will expose my underlying slice.
Looks good, thanks
Was about to respond with pretty much the same thing... Anyway - if the plan is to run the services on k8s, Go is excellent. Fast startup times and small, easy and quick to build docker images.
I think you can use [Thumbor](https://thumbor.readthedocs.io/en/latest/index.html) if you don't want to pay for cloudinary. But cloudinary is really good with images, a good solution for me is create an lambda function that listen an image created event on S3 and send that image to cloudinary.
What if you need to initialise a whole bunch though, and you want to do proper tear-down of your program rather than quit in a panic? Clean-up can be very important. You don't gain much by doing an early Fatal instead of returning an error in my opinion.
Even better! I wish there was a commandline program that could confirm that the executable does not load any library dynamically at run time, though.
gosec looks good. Shame it doesn't yet support go modules: [https://github.com/securego/gosec/issues/234](https://github.com/securego/gosec/issues/234)
sure. The non-JWT flow is to get a session id from the cookie, look up the session id in the database/cache, validate the session against that data, and proceed. The session can contain any data that might be relevant to the process, pretty much unlimited. Using JWT, you can avoid that trip to the database/cache to get the session data by encoding the session data into the token. That's the advantage of using JWT's. But the token is limited in how much session data it can carry, so you have an inbuilt limitation. The moment your session data exceeds the token capacity, you lose most of the advantage of using a JWT. UserID is the obvious choice for including in the token, and role makes sense, too, so you can limit routing without having to look up the user's role. Maybe include a session expiry time, so you can redirect to the login page if the session has expired. The benefits of including the last IP address is debatable - people do switch IP addresses for various valid reasons, but session hijacking is one of the main vulnerabilities. You can always start with JWT, and move to session id's later if you need more session info than the token can store..
Thanks. I'm going to try fountain codes.
https://github.com/golang-standards/project-layout/blob/master/README.md
This project follows the layout described in that link. The repo you posted simply describes the layout which is just how the repo looks like. In other words droplets is actually a sample project demonstrating application of above said layout. 
Thanks! Was more or less what I was thinking. I will lookup the JWT size limitation.
@drvd Thank you very much for your reply. I appreciate it. 
@drvd When you say "If no package is to be consumed by others make them internal." Do you mean make the methods with small camel case with the first word being small?
cobra instead of stdlib flag gocui when creating cli apps protobuf (gogo) paired with grpc shlex when executing commands hcl when building DSLs sprig for templates groupcache to shield slow&amp;cacheable things ejson to encrypt config data at rest assert &amp; gomock for testing sorry no links, on mobile.
Thank you for taking the time to respond! &gt; I doubt any Gopher would write it even remotely like that. Trying to find a concept-for-concept remapping is gonna fail. I definitely don't want a concept-for-concept remapping. The whole point of this exercise is find out how idiomatic solutions to this problem differ in different languages. I'm not surprised a Gopher wouldn't write it like that... but how would they write it? &gt; Why are you trying to make these things different types? When maintaining large code bases, it is very helpful to be able to look at a function and see what sort of inputs it takes and what sort of outputs it produces. Different languages provide different ways to do that; types are one way. &gt; Why is it a "pipeline"? A lot of programming involves ingesting input data and processing that data in stages. If the term "pipeline" suggests something else to you, feel free to ignore it. From the code snippet you provided, it looks like you'd just pass one `struct` around... with `nil` for fields that haven't been populated yet? If I were to come back to my code in six months, or someone else were to start maintaining the code, how could I easily tell which data a function required for input and which it produced?
Let's say you have a function that returns `Either FileHandle FileError` and another that returns `Either Int WriteError`, where `type FileError = FileNotFound | FileNotWriteable` and `type WriteError = EOF | Closed | UnknownError`. Now let's say you want to write a function that uses both, but returns an error if it fails. You have several choices, all with issues. You can define `type CompositeError = FileError | WriteError`, but that becomes inconvenient to unpack, even with pattern matching, especially as these stack up through the layers (it's not long before you're unpacking a `FileSlurpError (FileWriteError (DiskIOError (SystemErr 5)))`, along with all kinds of other things). It gets even worse if you want to pick and choose which elements you might return, in which case you're defining an even weirder list of errors. You end up inheriting a lot of the problems of checked exceptions in Java here. You can ignore all of that and just return a constant type, which usually seems to be String in all the Rust examples I've seen. I don't know if _real_ Rust code is always dealing with string errors, but if so, while this is convenient at the type system level, it's terrible for all the well-known reasons that string errors are a bad idea. The error handling that the current Go 2 proposals are outlining actually strike me as pretty darned good, and part of how we will have gotten there was not just slamming some superficially nice-looking features in from other languages. In fact I think there's a decent chance Rust will be copying Go in a couple of years. (I believe they have the feature set to copy it no problem, but it may take a while for the culture to change.)
You also mentioned that Comments like //LatLonResult ... are really un-idiomatic. However if I dont put comments like this then golint mentions that there are problems. Should I instead put comments describing what the functional use of that struct is?
[https://play.golang.org/p/z5QRwKmxJ-f](https://play.golang.org/p/z5QRwKmxJ-f)
This is actually a complicated topic. They document context cancellation here: https://golang.org/pkg/net/http/#Request.Context So basically, if the client cancels nicely by closing the connection or sending an actual cancel command, the context will be cancelled immediately. If the client is not nice, the context will be cancelled when a read or write on the connection next times out. To handle cancellation gracefully in your case, it's actually awkward because there isn't a built-in way to sleep while taking a context into account. I would use a time.Timer and a select statement to handle the sleeping for me.
Great question; we should start a FAQ... Bolt/bbolt/Badger are **key/value stores**. These are database primitives using bytes for keys and values. Many databases, including ObjectBox, build on top of a K/V store to provide a higher level interface than "just bytes". ObjectBox is an **object database**. You feed it with objects; the same structs you use in your Go code. Just like that, no tearing apart for SQL whatsoever required. Also, ObjectBox knows the "inside" of objects; and allows to query for struct fields ("properties"). It also manages indexing for you, you just have to specify which properties should be indexed. 
Thank you! This works great. 
A function that reads a configuration file shouldn’t manipulate global vars as a side effect, it should return the parsed configuration data to the caller. Framed this way, there’s no reason it should terminate the program, either.
You released meaningless graphs comparing it to nosql databases. This means nothing.
The only one I find essential between projects is the testify assert package. Some people may hate, but it encourages more, less flaky tests, and that's a good thing.
If you wouldn't just look at pictures, you might have spotted the disclaimer: &gt;We won’t spill the names and final numbers just yet, as we are going to release all the details very soon. 😉 &amp;#x200B;
&gt; ObjectBox is an object database. You feed it with objects; the same structs you use in your Go code. Just like that, no tearing apart for SQL whatsoever required. Does that imply that object in this context == struct and only a struct?
Yes. What do you have in mind to store besides structs?
Really great explanation! Thank you! For the record, in Rust, the ? operator converts the received error type to the error type returned to the caller. But this works only if the from function from the From trait is implemented for the given source and destination error types. https://doc.rust-lang.org/book/2018-edition/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator https://doc.rust-lang.org/std/macro.try.html
When in doubt, [check the source](https://github.com/spf13/viper/blob/06c7c0d9b3c7cfca13deff6e353a052e08828ad4/viper.go#L725) &gt; Should I just make a config package with wrapper functions that fetches values once and caches them? You should do this anyways so when you decide to invoke whatever needs the config by other means (e.g. tests or as a library) you aren't married to viper. Isolate CLI/config helper packages at the boundary as much as possible (same goes for DB, protobuf, etc).
[https://objectbox.io/](https://objectbox.io/)
It could be coming: [https://github.com/golang/go/issues/26492](https://github.com/golang/go/issues/26492)
Safe to say I'll be using this.
Passing the error up is preferred in libraries, I would add context to the error so it's easier to follow. Also many times errors are no where near a fatal event, so the caller can choose what to do based on the error returned (ignore, retry, abort etc.)
That makes sense. Thanks.
stdlib has all i need 
legit
Great, keep us updated how it goes and if we can help.
In that case, returning err is perfectly fine. To be honest, my comment was about initialization steps that are 1) absolutely necessary 2) has no side effects That's why I gave the example of loading a configuration file. Another place would be initializing singleton-like objects from that configuration. Fail as fast as possible, without breaking anything :)
It probably shouldn't, it's just a pattern that I've found easier to debug than returning an error and then having to log out a bunch of things to figure out where exactly things failed.
this is a repeat post from 4 hours prior
With visualizing as a graph, I mainly meant that write a graphviz file so you can see how the network looks. It may help to figure out why the channel version isn't working. If you want some spoilers or new ideas then I have my solution here https://github.com/egonelbre/adventofcode/blob/master/2015/day07.go.
goa.design
Strings, byte slices, arrays, vectors, matrices, maps, whatever. Just curious where from the concept of object == struct comes from as it makes zero sense to me.
If you look at OO languages, a Go struct comes closest to what is considered an object there. That's all. Can you give some real world examples how you approach persistence? Happy to learn... &amp;#x200B; I could imaging a use case for file caches, where you simply have a URL and and store the content as bytes. Fine. But even here, a struct seems like the more powerful abstraction to me. You can add fields like MIME type, length, stats, creation date, update date, whatever... and query for those.
So it requires dependencies like objectboxlib which would reside outside of our binay app? Whereas BoltDB is totally embedded.
I still maintain that numbers without context are meaningless.
Depends on the kind of game. Personally for a browser game, if I was doing a client/server model with prediction, I'd use C++ for game logic. That can be compiled to lightweight wasm for the web app and can be linked to a go service with cgo. I'd also use straight websockets over socket.io. It's long polling fallback will make a bad experience for games that require quick reactions. 
why do the templates have to be valid JSON before rendering? That's an odd requirement.
It is odd I agree. The first reason is the output must be JSON, so the templates contain a lot of JSON, but as raw strings they can be difficult to edit. The second reason is that the templates will be stored in a nosql database.
This looks great. Currently working on a project where our embedded devices are using gorm + SQLite with jsonRPC over NATs for syncing. It would be great to simplify the system we have but would need to see the project mature a bit more first. A few features we'd be looking for: 1. Auto migrations for structure changes 2. Hooks for alerting app of various object and db states. Would be great for app receiving sync data to know that a particular object was crud'd. 3. Plugins to make it to browsers and other client types. (We've used jsonPatch in the past). 4. Lots of working examples :) My biggest concern is the failure rate of commercial + open source projects and the artificial limitations sometimes put on open source components to not interfere with commercial successes.
It also looks like the DLL it downloads is closed source. If I'm correct about that, it isn't bad, necessarily, but it might turn off some people. The C-wrapper is open, but the core C++ library seems to not have a source repo. It's important to know before downloading a DLL by script from someone nobody has heard of, BUT in this case, it might be someone people know in the Java community. I think the Java and Kotlin pluggins had a lot of users when I was clicking around.
Come on now, if you give him a non answer give him a real answer too.
Ah, I did output a .dot file as a side-effect at one point, but I gave up on rendering it, since it was just taking forever to get done. I did manage to get a working solution in the version I linked above. The main point of my approach is that there's no iteration present in the program. Apart from reading the input of-course. It's all done by goroutines communicating.
We run this in production. It's a pretty solid system and Asim (creator) is a very nice guy. If you want an opinionated micro service framework that handles most of your issues, this is the best on the market.
https://github.com/uber-go/zap
[removed]
https://youtu.be/CF9S4QZuV30
This is a really specific request. https://gobyexample.com
[removed]
An Introduction to Programming in Go by Caleb Doxsey http://www.golang-book.com/books/intro I'm not sure if one can go through it in 30 minutes though. It took me a long afternoon. Neither is it very comprehensive. The best book in my opinion, however, is [The Go Programming Language](https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440) by K&amp;D. Clear and crisp!
The best option is to not log the data. Sensitive data should be POST parameters, which do not end up in the access logs. Also, you should not be capturing debug logs on production servers. Debug logging is for staging or dev servers and those servers should not be using live data. Remember, you don’t have to secure data you don’t have.
I didn't realize I wanted this until you said this. Thanks
This is great - thanks!
&gt; If fmt.Errorf is invoked with a format ending in ": %v" or ": %s" and with a final argument implementing the error interface, then fmt.Errorf could return a special implementation that implements both Wrapper and Formatter. Should it? We think definitely yes to Formatter. Perhaps also yes to Wrapper, or perhaps we should introduce fmt.WrapErrorf. I do this already in my personal projects, but slightly differently: ``` // LogErrorf is a helper function that logs a formatted error message and // returns an error object. Error object returned is the last parameter of // format arguments list, if it is an error; otherwise, it is an error created // with errors.New on the formatted message. func LogErrorf(format string, args ...interface{}) error { msg := fmt.Sprintf(format, args...) logger.Error(msg) if len(args) &gt; 0 { if err, ok := args[len(args)-1].(error); ok { return err } } return errors.New(msg) } ``` 
Sweet - Found it. Looks like you can get 40% off with the coupon code on the top of their page: [https://www.zazzle.com/working\_gopher\_two\_tone\_coffee\_mug-168888708317557144](https://www.zazzle.com/working_gopher_two_tone_coffee_mug-168888708317557144)
Oh shit you're right. I don't know where I got that from. 
It might be fine for beginners, I really don't know. I don't want to discourage you from trying to do it with go, but encourage you to just do it at all in any way you choose. The point of my comment was that it's not a huge undertaking to do the things you were describing, and maybe you'll have an easier time of it using the arduino ide while you're learning the circuit stuff
are you using the REST API from clients other than a browser? I mean, if you use some js front end, there shouldn't be a problem using gorilla sessions. If your clients are curl or some other non browser, then you may want to find a diff way to authenticate.
I guess X in Y minutes should fit your bill the best, but [gobyexample.com](https://gobyexample.com) is probably better overall. [https://learnxinyminutes.com/docs/go/](https://learnxinyminutes.com/docs/go/)
[removed]
Read the [spec](https://golang.org/ref/spec), you can get through it in one sitting and for obvious reasons it's fairly comprehensive.
I always recommend https://tour.golang.org/ as a good intro. You can just read &amp; blaze thru it, or actually play with the examples. 
It's also a good practice to disclude query parameters from access logs.
Tools like golint are not right all the time. You comment has two major problems: 1. A missing space between // and LatLonResult and 2. It does not explain anything. In Detail. Problem 1 seems to be a non-issue for a lot of programmers but it is not. Maybe it is fine in Klingon or some stone-age language to prefix a word with // but in English (and all the other 4 languages I speak) it is not. It is ugly, wrong and hard to read. Problem 2 is a personal pain point for me. You comment is nothing but a trick, even a minimal trick, to silence a tool. This comment has absolutely no value to the user of your package. All it does is waste storage, annoy the reader/user and silence a tool. This combination pretty much hits my definition of bullshit. If there is nothing to document then don't write a nonsense comment to make a tool happy. The comments, especially the doc comments are for _humans_ and basically for humans _only_. It is okay to ignore a tool but it is impolite to disrespect a human. I know that a lot of programmers got accustomed to write documentation for each of their classes/methods/parameters not because they understand the value of good documentation for humans but because their work place enforces the presence of a syntactical correct documentation (but which can be autogenerated and devoided of meaning). This is stupid but common in a lot of workplaces because a technical, syntactical check can be automated while proper code review takes time, especially of an expert. I really do not understand what a pseudo-documentation of the form /// get the foo bar /// param query the query /// param options the Options /// returns the foo bar string getFooBar(query string, options Options) is good for. Well, except making a tool (!) happy and generating a green checkmark on the code quality board in column "Method Documentation". This is stupid. Such comments do not have any value for the people how use it (and sorry, we are still 30 years away from machines combining your interfaces automatically). Please forgive the hard words, but I take this somewhat personal. The documentation should be written for me, not for the style checker you use. Your style checker gets upset, I do too. And I understand that it is simpler to silence your style checker... 
Why not take the Tour of Go and stopp after 30 minutes? And if you enjoy it you might even spend 40 minutes.
I much stronger recommend you this talk from gophercon 2016 on cgo https://youtu.be/lhMhApWQp2E
Check [our open source history](https://github.com/greenrobot?tab=repositories) ([https://github.com/greenrobot?tab=repositories](https://github.com/greenrobot?tab=repositories)): we have been doing open source for years. So we totally can relate to your concerns and we really want to open source the core DB. Getting this right from the start is crucial for us - just check the outcry MongoDb caused with changing the license. We're still a small startup and we're still figuring out some details here.
Actually, it's not a in-memory DB. It's disk based and provides ACID properties. We are working on a client/server mode.
Good research. Before ObjectBox, we did open source libraries for Android running on billion of devices. Still, 30% of top apps us our libraries including Twitter and Pinterest (check [here](https://www.appbrain.com/stats/libraries/details/eventbus/greenrobot-eventbus) and [here](https://www.appbrain.com/stats/libraries/details/greendao/greendao)). So, yes, I guess we gained some trust there.
Yes, ObjectBox is ACID-compliant - on every platform. Check the [transactions docs](https://golang.objectbox.io/transactions) for details.
Great ! I was looking for a project 
I'm not saying you can't do that. I'm saying I don't like it.
You can use a docker volume to keep the source code local and edit it with vim while having the container build / run it. 
What are you trying to achieve? A cli like this? $ calculator 4+4 &gt; 8 You’ll want to use os.Args to get the arguments from the command line and then parse them. Then handle the arithmetic. 
&gt; 138 open issues still - can't imagine that it will be out of the experimentation state by Go 1.12 There are 3947 issues open against Go and it's pretty non-experimental. So I don't understand what these two things have to do with each other. Not all issues are issues, not all that are need fixing and not all that do need fixing before something can go out of alpha. &gt; What is the point in having a stable language without a stable package management? C doesn't have *any* package management. It's been stable since decades. That being said, there is no reason to believe that modules won't be stable. &gt; I think the Go modules experiment did already fail. It barely even started.
I believe they did that and it's called \`export GO111MODULE=on\`.
I've read most of the issues and most are severe. Did you use modules? I think that there are several design issues. Also don't believe in the strange version selection method. Did develop some dependent libs in tandem: Lost lots of issues. Better without.
Calm down. Have some faith in the creators of Go. I wouldn't want to rush something as important as package management. You're right, it is currently easier to use a proven system i.e. `dep + vendor` because go modules is experimental. But eventually `go modules` will mature.
Could you elaborate on why you wouldn't just use `systemd` to run your application? To me `supervisor` seems like an unnecessary layer compared to just running your application directly under `systemd` (which you're already using to supervise `supervisor` :))
Have a look at - https://golang.org/doc/effective_go.html#interface_conversions
Yeahhh. Thanks a lot dude. Missed effective go during googling. This helped me.
I agree. Supervisor is just another option, like Docker, Kubernetes, and so on. systemd is a better way if you don't want more layers over your stack :) 
If you have new arguments against minimum version selection, present them. Software design is not about beliefs.
I agree with @tv64738. Have a Basket with all the possible elements as a single struct. If it is somehow necessary to know what pipeline steps have been done or not done, then either add a State parameter and use a Finite State Machine/State diagram, or if the zero value of an element is sufficient to act as a Sentinel value that the item has not been set yet, use that. Alternatively, add flag variables to track the state. It really is rather dependent on what sort of things these steps are conceptually doing to the Basket. A modification step that actually changed values from previous steps might need a substantially different model to one where each step can only add additional elements. For example, you gave addTax(b) as an example; but is something like applySpecialPricing(b) or applyQuantityDiscounts(b) a possibility? There are steps in processing sales baskets that are at least potentially not reorderable in principle. Calculating a quantity discount that is a percentage off the price matters whether it is before or after special pricing. That again is part of the point of a Finite State Machine, to define which transitions are allowable, and which are not.
Take a look at [this talk](https://pusher.com/sessions/meetup/the-realtime-guild/golangs-realtime-garbage-collector), it is about why Pusher chose Go. Pusher provides a "channel" protocol (a protocol on top of WebSocket) for developers to be able to write realtime application.
That's really cool!
This is absolutely not the right way to hash passwords. A couple of problems that exist in this package: - salt should use the full range of possible byte values, this package restricts it to alpha numeric characters, not even the full range of 7 bit ASCII. That’s a significant reduction in the complexity of possible salt values for anyone attempting a brute force. - It uses PBKDF2 to perform hashing with what appears to be SHA512 as the default algorithm. PBKDF2 is “Password Based Key Derivation Function 2.” We have good dedicated password hashing algorithms like bcrypt or scrypt. An awful lot of insecurities arise from crypto primitives being used in unintended ways. Use PBKDF2 to derive keys from passwords, not hash passwords. 
Please do not post pictures. Copy and paste the relevant bit of text and apply code-formatting to it.
Okay. Will keep that in mind. 
&gt; Build a DNS ~~server~~ *proxy* in Golang
Backwards compatiblity with almost 10 years old code is a priority? Calling it Go 2 just seems like marketing rather then an effort to fix precieved core issues :(
You can achieve this with the ׳replace׳ directive in go.mod, this helps with local modules First add go.mod in convert root for making it a module. And then add in go.mod of project A or B: - require convert v0.0.0 - replace convert =&gt; ../convert 
No need to repeat &gt; 100 issues. Read through them. Have been affected by lots of them.
Backwards comp is so important look at python for an example. 
Thank you very much, it worked! Never would've bothered to look into "replace" directive
So what does that flag do?
Nice :) glad I could help 
Hmm, not sure if `gorm` is "most useful". However, `sqlx` is. At least to me.
It could be a point in favour of supervisor in that it is a portable solution across Linux and osx, as opposed to specifically targeting systemd
Yes. Any post advocating for ORMs automatically gets a downvote from me.
my understanding was that they wanted the compiler to be backward compatible, but not necessarily the code, by splitting Go 2 into different source files. 
I can't express enough how relieved I am that Go is not going the python 3 route. 
if you were struggling understanding go, below is how it should be. [https://play.golang.org/p/Y3d-s57EJGd](https://play.golang.org/p/Y3d-s57EJGd) ```go package main import ( "fmt" ) func optellen(a, b int) int { return a + b } func main() { fmt.Println(optellen(10,20)) } ``` If you want some fancy shell use: https://github.com/abiosoft/ishell
They did say they will break it just that they aim for those changes to affect least amount of developers possible. But sure, why read when you can whine
Totally love the approach. Only thing I'm worried generics won't spoil Golang. But types can be kept at the right level of complexity and still be generic, Elm is a very good example.
What happened to #3 😁 ?
From my perspective, yes. One example I can give from this year is I interviewed for a company that has PHP and Java applications. They were looking for someone to help upgrade a system in PHP that generates over a billion dollars annually for the company but because of that reason has not been upgraded from version 5.3. I could not comprehend what could possibly be in the code base that would prohibit them from upgrading to 5.6, let alone 7.1. PHP has an amazing reputation with being backwards compatible, probably one of the best languages for ease of upgrade. The fact they have a billion dollar application that is no longer receiving updates would scare me but everyone in charge is afraid of being held liable for any downtime. I did not take the job. Anyways, the principle I got here is Go is doing everything they can to be the "best" Enterprise solution while still being a pleasant experience for developers.
Smart girl
[http://de.lmgtfy.com/?q=vscode+gopath](http://de.lmgtfy.com/?q=vscode+gopath)
Already googled. Don't be rude for no reason.
Really? Not "here we go" ???
I'd like to introduce you to my friend Perl.
The author counts the same as the tech industry * Windows: 1, 2, 3, 95, 4, 98, 2000, 7, 8, 10 * iPhone: 1, 3, 4, 5, 6, 7, 8, X * OnePlus: One, 2, 3, 5, 6 * PHP: 1, 2, 3, 4, 5, 7
[https://github.com/Microsoft/vscode-go/wiki/GOPATH-in-the-VS-Code-Go-extension](https://github.com/Microsoft/vscode-go/wiki/GOPATH-in-the-VS-Code-Go-extension)
Thanks
&gt;Binary integer literals and support for \_ in number literals _Freaking finally._ No more mental hexadecimal maths and counting digits. `0b1001_0110` is way clearer than `0x96`.
Perl 6 had the problem of being in development for 20 years and then somehow coming out lackluster compared to perl 5.
Seems like this opinion is getting a lot of hate here. I personally agree with you. The simplicity of this language is one of the primary reasons I use it. It’s so damn readable and easy to grok at first glance compared to other languages with so many indirections and T types. Hopefully it doesn’t get out of hand. I honestly believe that one of the reasons they’re moving forward with this is because of the “lol no generics” meme that comes up a lot in response to talking about go, not necessarily because they think it’s a great idea.
Oh nice!
I wouldn't call it lackluster, I would say it just doesn't have a niche it would be good at. It has a bunch of features that are very nice just not really a reason to pick it up. Hell, I'd kill for having freedom of function dispatchs from P6 in Go. But it won't *really* replace anything currently written in P5 (as it is slower and starts slower) and there is little motivation to learn a new language that does what language you currently know already do "well enough" (like Python or Ruby)
There are a number of language servers for Go, yes, searching should yield results. The Go team is also apparently working on one currently.
Can you not just use properly qualified package names and repositories?
Perl made itself massively incompatible, was slower and not better enough ... so everyone wisely ignored the new version so it slowly died off as people started new projects in other languages and their old code continued to work fine. Python made itself massively incompatible, was slower and not better enough ... and a bunch of the idiots pushed everyone to move, burning years of old code on a bonfire of stupidity. Some people, who apparently are happy to be fooled twice, seem to think Py3k is a viable language now ... so within a few more years I think Perl will definitely be the loser in any comparison, which is sad.
That's why I said the problem was naming it Perl. Perl 6 was basically new language written from scratch. Python 3 could easily be compatible with 2 if they just tried slightly harder
There already is a language server for Go. I was planning to use it. https://github.com/sourcegraph/go-langserver
&gt; It’s so damn readable and easy to grok at first glance compared to other languages with so many indirections and T types. Maybe *for you*. But me and a lot of other engineers would like to keep our sanity and we don't want to see brutally repetitive, boilerplatish code with ugly dynamic hacks which's closer to the crap written by a new intern instead of a professional. If you've a problem understanding typesystems you should consider taking some courses - it'd spare us a lot of time. Btw, what you're calling "simplicity" is actually just "noob-friendly" - there's a huge difference between the two.
Anybody got a tl;dr for this? I will have to wait until I have more time to read this otherwise. 
[removed]
Perl was dying long before perl6 introduced massive incompatibilities.
Because a map has to perform a (quick) hash of your key before doing the lookup. Slices just use a memory offset, it's very quick addition.
It's the first result dumb-dumb.
[removed]
I think they mean "a placeholder" for features not currently in the language. You can implement new error handling, generics and so forth without breaking existing applications. They will trickle in, as they should, let things evolve organically. Python being the "the scary door" of versioning madness :)
No generics at all would be ideal for the language
Yes, definitely! Everything is a balancing act. I'm interesting in how the language looks next year. Depending on where it goes I might still love it or I might think to myself "why don't I just use Rust or C# at this point?".
I did about 50% of the conversion for my company's 3,000,000 lines of code. Can confirm. It's a nightmare. 
Necessary, but rough. Most of it wasn't that hard, but the string conversions. *shudder*
What are generics?
Thanks for your suggestion. I'm trying to write a game. The key is the index of each card and value is the number of the card. Using map is convenient but I need to make some calculation on server. I want the functions perform better.
The community had lots of ideas, we will pick some and implement them carefully and slowly.
I like it. I have not done any network programming for a very long time. Can you point me to some quick references that will help me in ramping up?
so true. Some people get all irritated when I submitted my huge perl pull requests with no unnecessary spaces or carriage returns. It is way to easy to write incomprehensible code in perl that works till you need to make a change among other things.
[This commit](https://github.com/sarah256/fortune-api/commit/358730600cc5a7bc2cb9d37c6c818e7977864bcf) is odd. Did you run into issues with gopath?
Due to #310, I find sourcegraph for Go to be utterly broken. Your entire OS will slow to a halt with the server using 30-40GB of virtual memory. 
Reminds me when I moved our Puppet codebase from code that was still using old parser to new one, altho that was "only" around 100k. After a lot of time of neglect (we were 2 major versions behind), mostly because management refused to hire another senior. Let's just say that some stuff resolved conditions to "false" where in previous one it resolved to "true" (and in both cases no error/warning)
the good old [https://github.com/golang/go/tree/master/src/net](https://github.com/golang/go/tree/master/src/net) , won't be quick though
Is `go get -u all` really that hard?
Is the underscore a readability thing or does it do something?
Yeah, I did. I'm still learning the best way to configure everything and set up the project in general. Any suggestions?
couldn't you just do const million int = 1e6 ? 
I think it comes down to how much you value compile-time type safety. Even if you can commit to code duplication in your project, you’re likely to end up using libraries that rely on reflection, `interface{}` and type assertions. The fact is that generics lead to safer, more concise code, but if you have a background in dynamically-typed languages, it might just seem like unnecessary overhead. It can certainly make code less flexible. On the other hand, if you’ve spent most of your programming career having a compiler work for you, then the prospect of the Go compiler doing the same is pretty attractive.
I really wish it was a --long flag because the behavior i prefer by default is to skip long running tests. Oh well, Makefiles and the likes solve that for me.
I think it makes sense for the default to run everything. Otherwise you would have to know to run it with the long road ahead of time.
What if my function takes two generic arguments?
I feel like adding overloaded methods could achieve the goals of generics without the need for large changes to the language syntax.
Just for readability, I assume it'll be pretty much ignored by the compiler.
Because then you can attach methods to your structure like submit() or close() and you also can pass around the client to functions or have it part of another struct. If given a choice to use 1 object versus many I would go with 1 just because I know it would be in a central location...
I am pretty new to Go, implemented a library that returns `interface{}` on some of its functions. (https://github.com/dgrijalva/jwt-go). I then had to wrap their functions in application specific functions, returning concrete types. It's not that bad really, but it is effectively generics. Why beat around the bush at that point? 
&gt; BTW - it makes your interfaces shitty, it wastes a crapton of time, makes your API super-inflexible, and all that convoluted logic that you needed to remove that little bit of boilerplate has way more bug potential then the simple boilerplate you could have had. The idea that `interface{}`, type assertions and reflection have less bug potential than generics is a pretty wild assertion. With generics you’re guaranteed a lack of type-related bugs at compile time. Type parameters look a lot less convoluted than duplication, type switches and reflection, and require no logic or unit tests whatsoever. “Clever”, ugly generic code is just the same as “clever”, ugly reflection and hacks with `interface{}`. It’s bad coding, not bad features. I’ve seen my fair share of both kinds of code, so it’s not like I don’t understand where you’re coming from, but I urge you to think about how leaving more of your debugging up to the compiler could make your life easier.
* The P5 interpreter can run most Perl code from 25 years ago; * The P6 compiler can run most Perl 5 code too, running it in the same process space and using it using P6 syntax; * The P6 compiler can run most Python 2 code too, running it in the same process space and using it using P6 syntax; * Ruby, Lua, C, ... too; * Programs and modules can specify a language version. This allows for more flexible language evolution: use v6.d; # P6, version 6.d code goes here... * Multiple versions of modules can be used together in one program: use Foo::Bar:ver&lt;1.1&gt;:api&lt;2.0&gt;; # Simultaneously use multiple versions of a module P6 is technically excellent, and imo Perl's language evolution is also a success story technically, but naturally that's no match for ignorance and prejudice.
Not sure what issue you ran into specifically but if you were trying to do separate `GOPATH` per project I'd recommend sticking to just one for all Go projects. If you want the project to live outside of the `GOPATH` I'd recommend trying out [go modules](https://github.com/golang/go/wiki/Modules). Converting to go modules looks something like this: $ go mod init github.com/sarah256/fortune-api go: creating new go.mod: module github.com/sarah256/fortune-api go: copying requirements from vendor/vendor.json $ go get -v go: finding github.com/gorilla/mux v0.0.0-20180807075256-e48e440e4c92 go: downloading github.com/gorilla/mux v0.0.0-20180807075256-e48e440e4c92 github.com/gorilla/mux github.com/sarah256/fortune-api $ go run main.go $ rm -rf src/ bin/ pkg/ vendor/ # this stuff is no longer needed Plus it will work out of the box with heroku. Also checkout [gophers slack](https://invite.slack.golangbridge.org/) they have a [newbies channel](https://gophers.slack.com/messages/C02A8LZKT/).
Umm, any link/thread having discussion on this? 
&gt; I fear that people aren't actually running the integration tests ... and [don't] notice [when they are] skipped. I think this is a real problem with the default `go test` behaviour. Unless you use `-v` and look over every line of output it is very easy to miss which tests were skipped. [gotestsum](https://github.com/gotestyourself/gotestsum) fixes this problem (and a few others) by giving you more control over the test output. The default will always should a count of skipped tests, and a summary of why they were skipped. It is much harder to accidentally miss tests that way.
&gt; P6 is technically excellent, and imo Perl's language evolution is also a success story technically Cool. I think virtually everyone would disagree with you, which is why nobody uses Perl anymore. Changing the entire syntax of a language makes a new language, not a new version. I'd argue the fact that you can inline Perl 5 in Perl 6 doesn't make that better. &gt; but naturally that's no match for ignorance and prejudice. Or *maybe* you WAY over personalized a funny one-liner. 
I feel that the lack of overloaded methods is an attractive aspect of Go. It makes Go code so much easier to read when you know exactly what symbol corresponds to what function, vs needing an IDE to unravel the real code path for you
Great. This looks like a design pattern. What does it call? Where can I find some good use cases and explanations online regarding this pattern?
Yes. On the other hand, not all numbers are so clean though.
Oof, that sounds very unfun. 
Go supports higher order functions. &amp;#x200B; [https://golang.org/doc/codewalk/functions/](https://golang.org/doc/codewalk/functions/) &amp;#x200B; But yes, it does not have very handy functional primitives like you mentioned. 
You mean functional programming? As I understand http://aquaraga.github.io/functional-programming/golang/2016/11/19/golang-interfaces-vs-functions.html
Where can I find a very good explanation of it?
Here is probably a good starting point https://github.com/emirpasic/gods.
Go 2 considered harmless?
Yes what if? The add function in the gist takes 2 generic arguments...
How would that support a function with more than one generic type or returning a generic container? Eg an F[A, B]: C, or F[A]: B[A]?
What about storing JWTs in an HttpOnly cookie? Refresh tokens? CRSF cookie? I’d like to hear your thoughts here as well. 
https://christine.website/blog/experimental-rilkef-2018-11-30
Due to the type system mainly - you'd have to implement these for all types, or resort to empty interfaces{}. See also: Generics.
You would probably use: [https://github.com/robertkrimen/otto](https://github.com/robertkrimen/otto)
Note that this isn't conversion or typecasting but rather type assertion.
I've spent most of my career doing gymnastics through overly generic Java code because developers thought everything looked like a nail while holding a hammer. Generics used *incredibly* sparingly would be okay. But my actual experience leads me not to trust that they'd be used sparingly at all.
This meme has to stop. There are so many reasons that Java code is like it is and it's not all to do with generics. &amp;#x200B; Go + Generics != Java by a long long way
I don't think you're invoking memes in this case. How do you think the code you described would've looked in Java 4 though? Would the hammer-holders have written clean code, or tried the same crazy abstractions with \`Object\` , \`instanceof\` and type casts all over the place? That version would come with the added fun of wake-up calls as the runtime does the compiler’s job at 2am. I guess it’s hard to avoid whataboutery either way. I do think if views like yours aren’t taken seriously, then we could end up with something very un-Go-like, so I’m glad to hear from both sides. With most features of the language, there’s an accepted “Go way“ to write code, and if that can be achieved with generics, I think everyone’ll stand to benefit. 
Thank you! I feel pretty unheard on this sub regarding this particular opinion. To answer your question, much of the time abstraction wasn't really needed in the first place and generics just acted as a foot gun—probably for young devs who hadn't learned when *not* to add complexity. I feel the same about many design patterns: they're sometimes useful but used much more often than that.
I look forward to trying Rust someday. Some features work better in some languages than others, and maybe I'll love Rust generics.
It's like the third of these I've read at this point but they always just scratch the surface. It's basically just saying "you can serve data through GraphQL, using go" which I already knew. What I would really love to read is an article from someone who actually built something real using GraphQL and go, and what kind of issues they ran into in terms of db performance, permission management, managing a consistent schema between frontend/backend etc etc. That would be super interesting.
I think trimming the string will get you results faster than including a javascript VM like otto or goja, just slurp the string from the left to the first `(` +1, and take away from the right to the last ')' -1 and you got yourself what seems to be a properly formatted JSON object left.
That's the thing, here, though: most people think that generics will be useful more often than misused, or that the benefits outweigh the potential bad sides. Any sort of tool can be misused by inexperienced developers. This shouldn't be an argument for not considering it, though; otherwise we'd still be writing everything in hand-crafted machine code. Of course it's a valid thing to consider, but a *potential* drop in the code quality of *some* coders really shouldn't be stopping us from enabling *most* coders to have more up-front type safety (just because e.g. the standard library would gain more type safety over time)
I agree with your line about moving from solution-first to problem-first, it's the main reason I've found Go so refreshing. &amp;#x200B; I'm also not against the introduction of generics but I am in favour of very, very carefully considering how they will affect not only the every day codebase but also the overall community and philosophy of Go coding.
That's the issue though. *Why* are we doing type assertions? *Why* are we writing functions that can take \*anything\* when we know that they realistically won't? I say it's a flaw of current mainstream programming methodology. We want to abstract everything away, even when it's not needed. 95% of people who want generics wouldn't need them if they re-thought the goal of the program, and usually it'd lead to less complexity and more readability.
I'm no expert in JWT's - I prefer storing session stuff in a session table. There's a ton of good lore about JWT's though, so google away :)
I'm a little confused by this, it seems to be suggesting that the language changes heading towards Go2 will come under the Go1 compatibility guarantee - doesn't that mean that there is the possibility of being 'painted into a corner', making larger changes constrained by the myriad smaller proposals that will be implemented? &amp;#x200B; As far as I can gather the idea is that Go2 can introduce breaking changes as long as there is an easy upgrade path (ideally of a go fix type) but how many Go1 compat changes can be made before stating 'this is Go 2'? &amp;#x200B; Overall though I do applaud the planned upgrade path!
I hear you. The counterpoint is that it's not actually very common for moving outside of the type system to be *necessary* since most (but not all) of those problems are better solved by good API design. Putting a tool in the language that will be misused an order of magnitude more often than it will be used to good effect isn't a positive change in my opinion. We don't disagree, it seems, about whether tools are useful or about whether generics in particular will be useful. We just disagree in our predictions about the ratio of positive vs. negative use. And to be clear: I never advocated not *considering* generics for Go. I've considered it heavily and now have an opinion.
That is not what you want, if you just have one dep that shouldn't be updated. Try to develop 10 libs in tandem dependent from each other, publish from time to time and have one external dep that should't be updated. Have much fun!
This would also break any package with an internal type named 'generic' :)
Artist: Lemon Jelly, with vocals by William Shatner Song: '64 aka Go Can't help but picture someone brainstorming to find a good name for the language and having an epiphany while listening to the end part of this song.
If you need iterator interfaces, you have likely designed your code along the wrong axis of abstraction. This kind of meta code is rarely actually useful in actual problems.
&gt; Any sort of tool can be misused by inexperienced developers. This shouldn't be an argument for not considering it, though Didn't Rob Pike make that exact argument, though, in this interview[0]? To quote, "They’re not capable of understanding a brilliant language but we want to use them to build good software. So, the language that we give them has to be easy for them to understand and easy to adopt." Honestly, that quote ruffled a lot of feathers, but I think Rob is right. I'm an experienced developer, but his quote still applies to me. I find that I will easily build overly-abstract solutions in languages that seem to cater to them (looking at you TypeScript and Haskell). I haven't really used Go in earnest, but this ^^^ philosophy is one of the reasons I'm probably going to try it for my next project. [0] https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/From-Parallel-to-Concurrent
C# is similar. I've seen some pretty complex C# code, but honestly, its use of generics seems pretty sane to me, so I'm hopeful that Go can add them in without the typical Go codebase becoming littered with indecipherable abstractions.
thank you so much!
Using map, filter etc. simplifies the design of software. This is hardly the wrong axis of abstraction.
I think C# is complex due to .NET being much more complex than it needs to be. `net/html` for example is absolutely awesome, the whole Go stdlib is.
I have exclusively written Haskell code for years before migrating to C. I don't miss maps, reductions, and filters. I find that a simple for loop achieves the same goal while being much easier to understand than a complicated chain of maps, filters, and reductions.
How is reimplementing the loop of an iterable structure everytime simpler than applying side-effect free functions to the reused loop of an iterable structure simpler?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/negativewithgold] ["Ugh. Lack of generics and simple, clean error handling are two of the best features of Go. I'm so concerned..." \[-17\]](https://www.reddit.com/r/NegativeWithGold/comments/a1s5wj/ugh_lack_of_generics_and_simple_clean_error/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
*Such* a good album
Real-world functions are rarely side-effect free. You can pretend that they are, but then your error handling is just worse. The difference in effort between writing a loop and calling some random-ass chain of maps, filters, reductions, and other combinators is insignificant, but that loop is much easier to understand afterwards. Code-reuse in this case is about as useless as the kind of code-reuse they do in Node.JS where every one-liner function has its own package so you can re-use it. What a load of bullshit. Code-reuse is a value, not an ideology. It has to be weighted against the coupling and complexity it introduces. Given that the implementations of these iterators are typically not much more than a handful of lines, I don't quite see the point of reusing them. Another point I distinctly remember from Haskell: maps, filters, and reductions are nearly impossible to debug. If you can debug them at all, the debugger is constantly jumping between the source code of all involved files giving you absolutely no way to understand what is going on. A loop on the other hand is super easy to debug. Lastly, for combinators like maps, filters, and reductions to perform well you need a very advanced optimiser with inter-module inlining and good devirtualisation. The amount of complexity needed in the compiler to get functional code to perform nearly as well as simple loop is mind-boggling and slows down compile times to the point where it's annoying. Also, because performance depends so heavily on the optimiser, it is incredible fragile. The slightest changes can prevent the optimiser from understanding your code, reducing the tight loop it creates back to a pile of virtual function calls, slowing your program to a crawl. Good luck understanding why this happened. In my Haskell programs, the reasons were often extremely subtle and could only be solved by seemingly random changes in the code. That's not something I want to happen in reliable production code.
I consider myself a good programmer and I 100% support this statement. If you give me a language with advanced features, I am going to spend a lot of time thinking about how to use these features in my program and I never actually end up writing code. For example, [here](https://stackoverflow.com/q/6706248/417501) I was thinking about how to use monad transformers to abstract away who is playing a game (AI, player, net-player, etc) in the game logic. I spent so much time thinking about this that I never ended up finishing the project. I eventually abandoned Haskell for this reason and started to write all my code in C and Go. I don't have this kind of problem anymore. The lack of advanced features makes me focus on the algorithmic problem at hand, greatly increasing my productivity.
Have a look [here](https://golang.org/pkg/encoding/json/#Unmarshal).
I know. The linked Reddit post that calls it type assertion is mine even. But here I'm trying to explain it `In simple terms` hence the double quotes on "typecasting/converting"`.
&gt; it is slower and starts slower It'll always start slower. It won't always run slower. As 2018 closes [object creation is faster](https://6guts.wordpress.com/2018/10/06/speeding-up-object-creation/). There are a few other areas in which P6 is already faster. Many other significant speedups are in the near term pipeline. There are areas in which P6 is naturally faster. Use of multiple cores, with attendant speedups, is relatively simple in P6. If you want to process Unicode text with proper character (grapheme) handling, P6 has O(1) handling. P5 remains fast for a dynamic language interpreter and looks set to retain that status for a long time to come. P6 is slow for a partially static language compiler but that's changing. As a final point worth making, P5 and P6 can be used well together.
Yeah, `1000000` and `1_000_000` are the same token, the "one million" litteral number.
I'm curious, does the proposal accept invalid separator spacing such as `1_0000`?
&gt; You can pretend that they are, but then your error handling is just worse. I don't see how monadic error handling is worse than `if err != nil`. I find it absolutely awesome. if I want to prototype in Rust it's just some lines of `try!` macros (that pass the error of a `Result` into the next `Result`, with `Result` behaving very much like Haskell's monads) in very few places and pure functions in definitely more than 80% of the codebase. Some `Into` (yet another generic) conversions for the one error types into the other error types follow so that I can have meaningful error types - even these are side-effect free. &gt; Given that the implementations of these iterators are typically not much more than a handful of lines, I don't quite see the point of reusing them. Other than short NPM packages like is-number, is-even, is-odd or left-pad etc. are these already part of the standard library in languages that support generic iterators, options (`Maybe`) and other monads or functors. So what is the cost of reusing them other than having to understand them? Which you already have to do if you had to reimplement them non-generically all the time. &gt; Another point I distinctly remember from Haskell: maps, filters, and reductions are nearly impossible to debug. I don't see the problem as a regular application developer. Once paused write a unit test with the values involved and test the applicative in isolation. --- I can see how having to implement functional structures efficiently is very difficult. But tbh I'm not the one having to do it and only expressed the wish for it. Perhaps I may change my view on them once I end up having to implement them myself but for now I just am in love with them.
I work with windows, have my gopath also to a different location, and have set it once in my path to make this work. So I think, the export should do the trick too if you call VSC from bash. (if you call it from an icon, or...) you can set it also the way is used to set system wide environment variables in your O.S.
Let's hope better error handling will come asap! It's the worst thing go has in my experience.
&gt; Go supports higher order functions. It has first-class functions, but the definition of a higher order function is one that takes a function and returns a function. Go can do this, but almost the only use for higher order functions in the wild is in conjunction with generics. So, it's technically correct to say that Go supports higher order functions, but in practice it's quite limited in practical usefulness.
[I recommend a reader wrapper, like this](https://play.golang.org/p/VeLX-C5vnCF). The advantage of this approach is that it retains all the advantages of readers; it does not require you to manifest in memory any complete request. You can take the JSONPWrapper given in that link and instead you'd do: type AppleSystemStatus struct { DrMessage interface{} `json:"drMessage"` Drpost bool `json:"drpost"` Services []struct { Events []interface{} `json:"events"` RedirectURL string `json:"redirectUrl"` ServiceName string `json:"serviceName"` } `json:"services"` } // ... In your code applSysStat := &amp;AppleSystemStatus{} decoder := &amp;JSONPWrapper{Prefix: "jsonCallback", Underlying: resp.Body) err := decoder.Decode(applSysStat) and you'd have the parsed object. I just splatted that out very quickly, so there are some things you may want to tweak or improve. I used [json2struct](http://json2struct.mervine.net/) to get the struct quickly.
Honestly i wouldnt worry about this. Premature optimizations are one source of weird bugs. Only optimize Code that you identified as a bottleneck
About two days after Go releases its first pre-release with support for generics, expect /r/golang to be flooded with about 10-15 people popping up with libraries for this stuff. But I expect the Go community consensus to remain that such things aren't really Go. The only things I'd be interested in are things that actually provide convenience beyond things I can't put in for loops. "Map" is not all that interesting to me, but a _parallel_ map, now that may have some uses. There is a degree to which that is a convenient abstraction and that's a convenient interface to it, and there are things you can/should do for performance in that situation, so a _good_ parallel map implementation is interesting. (But note to any aspiring authors that the naive parallel map actually performs fairly badly; pay attention to caching!)
The ideal thing is to wrap the locking behind an interface: type FileLocker interface { Lock(string) error } Use dependency injection to provide the locker to your code. In your \*_test.go code, put: type ErrLocker struct { err error } func (el ErrLocker) Lock(string) error { return el.err } This allows you to both shim out locking in your test code (which would also be helpful in, for instance, also shimming out file access entirely and working with byte.Buffers instead, if you arrange your code correctly [1]), and also easily control the error that will result for lock failures and test it appropriately. [1]: "Correctly" in this case usually amounts to the following pattern: func (s *Struct) DoWhateverWithLockedFile(filename string) error { err := s.locker.Lock(filename) if err != nil { return err } f, err := os.Open(filename) if err != nil { return err } s.actuallyDoWhatever(f) } func (s *Struct) actuallyDoWhatever(r io.Reader) { // actually do the work } [This pattern](http://www.jerf.org/iri/post/2923) allows you to separate out the raw mechanics of obtaining a file, which is prone to a certain type of errors, from the mechanics of doing whatever it is you want to do with the contents of the file, which are prone to entirely different errors. You can test `actuallyDoWhatever` much more conveniently in your code by directly providing byte.Buffers, instead of having to create a temporary directory, write out files, and make sure you destroy the temp directory at the end.
I like some of your further arguments, but this one is a bit too much, because even in C people use iterators a lot. And they have to do it the ugly way like this: ``` for (it = START_ITERATION(smth); it != END_ITERATION(smth); it = NEXT_ITERATION(it)) ```
duplicate of [https://www.reddit.com/r/golang/comments/a16m55/objectbox\_new\_superfast\_db\_to\_store\_for\_go/](https://www.reddit.com/r/golang/comments/a16m55/objectbox_new_superfast_db_to_store_for_go/)
True. Thanks
I've never felt the need to use Python for any of my projects.
Actually, in languages like Chinese you naturally group numbers in groups of four instead of groups of 3, so allowing "unnatural" spacing is a good idea for these. Also consider cases where you store monetary quantities in cents and you want to reflect that with your separators: const savings = 123_456_78 // in cents
You don’t know what you are talking about. Features like LINQ wouldn’t be possible without this abstraction, and LINQ is one of the greatest achievements against unnecessary boilerplate of modern programming. Of course you can make the code complicated and hard to understand. No shit, that’s also a trivial feat with for loops. 
I call functions that return functions internally calling function I passed as an argument to the first function all the time. This is actually very go “generics” way.
Of course Go does support it. Just no monads.
+1 I'm relatively new to Go, but have already used HOFs in production code and tests to good effect. The syntax isn't very modern, but they can still be very useful in Go. I think it's more a case of programming style or experience with utilising first-class functions. 
This is a pretty neat write-up. I had a whole comment written up about the perils of comparing json strings across languages (sorting, representation differences), and then I reread the code. Using json.RawMessage to compute the hash server side before unmarshalling is an elegant solution. Nicely done :) 
I assume you mean algebraic data types. You can have monads in a language without higher kinded types, which means users can't define their own generic monads. For example, Rust has the `Option` monad (`Maybe` in haskell) with `and_then` as the standin for `&gt;&gt;=`. See https://doc.rust-lang.org/rust-by-example/error/option_unwrap/and_then.html
If you call it a pattern it is a relational one. Nothing to do with OOP. 
You might have to provide a code sample for this. Your question is way too sparse on details to get you a realistic answer to ... anything, really.
here's the thing. u/orbat is a paid shill and incredible gamer narc who deletes controversial posts from the conspiracy subreddits. Additionally he doxes and attempts to humiliate people in a protected subreddit called r/TopMindsOfReddit. Here is proof: [https://www.reddit.com/r/TopMindsOfReddit/comments/a1rrx9/considerthis\_communism\_used\_anti\_gravityflying/](https://www.reddit.com/r/TopMindsOfReddit/comments/a1rrx9/considerthis_communism_used_anti_gravityflying/) &amp;#x200B; This private admin community is systematically carving out territory in Reddit since they took over in the late 2015 Coup. These shills are behind the bots that are deleting all the old political posts systematically. They're pretending to not know about it. Playing DUMB. Reddit is dying as a result. Google DEANON Project. Within 2 years every last one of these shills will be found, IP to paycheck. &amp;#x200B; Here's the post that got deleted: "Consider This: Communism used ANTI GRAVITY+Flying Fortresses to win WW2. Ever seen the movie Memphis Belle? Remember the plane was only flying with a \*SINGLE\* engine at the end of the movie? If one or multiple jumbo jet engines fail, only one jet engine is required stay in the air. There is no explaination yet from Boeing or NASA as to how Jumbo Jets can stay in the air with only a SINGLE ENGINE operating on ONE (not both) wings. Explanation? AG technology secretly keeps the planes afloat once the jet engines is running, while propellers are only used to move the plane forward. This technology was built into the planes in such a way that their own pilots and engineers did not realize it. This was the only way they could get these \*TEENAGE\* soldiers into the planes and send them hundreds of miles on bombing raids. Smaller stunt planes do not need such technology to fly, but B29&amp;B52 bombers absolutely did since they needed to carry a major payload in bombs. These 2 planes were responsible for over 15 million deaths during the 20th century as they dropped Napalm and other incendiary bombs over 3 thousand human cities towns and villages. This is how we won WW2. This is how North Korea, Japan &amp; Vietnam were completely destroyed. This is why NASA is fake. This is why Jumbo Jets have not improved in design in over 70 \*YEARS\*. This is why all Jumbo Jets look identical. This is why they NEVER CRASH. This is why 9/11 Involved Jumbo Jets. This is why basically everything you know. #Communism won. [https://en.wikipedia.org/wiki/Boeing\_B-52\_Stratofortress](https://en.wikipedia.org/wiki/Boeing_B-52_Stratofortress) &amp;#x200B; Nuclear weapons don't exist. Never have, never will. &amp;#x200B; 1. It's communist war propaganda. Do you remember? The COMMUNISTS WON WW2. &amp;#x200B; 2. Splitting atoms does not release energy rapidly, only very very slowly. Fuel Yes, bombs no. DU warheads are real. &amp;#x200B; 3. All Nuke footage you've ever seen was either 1920s style composite scale effects, or just huge TNT explosions. Kids these days can tell the difference, even if you still cannot. &amp;#x200B; 4. Hiroshima + Nagasaki were FIREBOMBED along with 65 OTHER CITIES before anyone had taken up the Nuke rhetoric. You don't find memorials for burning Japanese children alive with gasoline, only for incinerating them with fake 'flash nuclear' bombs. &amp;#x200B; 5. Did you know it's 100% Illegal to deny the existence of Nuclear bombs in USA, UK, Japan, Korea, etc etc etc. WHY IS THAT?? &amp;#x200B; Did you know that Fusion between Hydrogen into Helium has \*NEVER\* been proven in a lab? Bet you didn’t know that. It might not be possible. Even if it were possible, there’s no guarantee that Fusion (the opposite of Fission) actually releases energy at all! &amp;#x200B; The bigger picture here is that nuclear weapons DO NOT EXIST. Neither Fission reactions nor the hypothetical Fusion reaction is capable of releasing INSTANTANEOUS energy. Fission is in fact very SLOW, which is why it is used in Nuclear Power Plants." &amp;#x200B; Keep it up, but remember those admin tools won't help you in real life. &amp;#x200B;
Here's a sneak peek of /r/TopMindsOfReddit using the [top posts](https://np.reddit.com/r/TopMindsOfReddit/top/?sort=top&amp;t=year) of the year! \#1: [The_Donald's Handy Checklist for Mass Casualty Events](https://i.redd.it/1qpmpwd4e8n01.png) | [2880 comments](https://np.reddit.com/r/TopMindsOfReddit/comments/868flr/the_donalds_handy_checklist_for_mass_casualty/) \#2: [Top minds don't understand taxes](https://i.redd.it/3nn8ev3n4fz01.jpg) | [3873 comments](https://np.reddit.com/r/TopMindsOfReddit/comments/8lagh5/top_minds_dont_understand_taxes/) \#3: [r/GreatAwakening has been BANNED](https://np.reddit.com/r/greatawakening) | [5964 comments](https://np.reddit.com/r/TopMindsOfReddit/comments/9faf2z/rgreatawakening_has_been_banned/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
In general, that style is frowned upon in Go. It can always be replaced with a `for` loop, and the only cost is a little bit more typing. `for` loops are almost always more efficient and more readable. Go is not anti helper functions though, so if you have a package we're you're literally writing the same loop over and over again, then it's okay to refactor that. But, in general, they don't really seem necessary for the language. Of course, there's also the point that they are sorta impossible to implement cleanly without generics. Even with generics I think they will continue to be frowned upon though. In other languages, like JavaScript, iterating over something can actually be hard to get right, so in that scenario I think it makes a lot more sense to use higher order functions. FWIW though, even in a language like JavaScript a regular for loop is usually faster.
If you need a blocking call, call it in place!? If it spawns one goroutine block on the receive channel!?
Thanks! I can’t take credit for the json.RawMessage idea though - I got that idea from [this post](http://eagain.net/articles/go-dynamic-json/).
check out [https://golang.org/pkg/sync/#example\_WaitGroup](https://golang.org/pkg/sync/#example_WaitGroup)
Generally I do this by having a wrapper function that calls the first iteration; when the next line of code runs, all of the recursion has completed. However, you almost certainly don't want to nest 10's of thousands of recursive calls. This will be slow or possibly overflow the stack. Why not use a loop instead?
Ok, had to nip out, so will look at the example of a semaphore and if that doesn't help will be back!
I actually want to use \`unmarshal\` but since I'm not getting \`JSON\` back I can't use it. The \`jsoncallback(\` in the beginning followed by the \`);\` at the end of the response is what makes it \`JSONP\` which doesn't work with \`unmarshal\`.
 h.update(msg["type"].encode("utf-8")) h.update(struct.pack("&gt;L", msg["userId"])) In general, you don't want to do that, because by just smashing the elements of the message together, you open a small window of modification possiblities, because imagine for instance sticking a subject and a body together (You're Fined)(Sorry). That'll hash the same as (You're Fine)(dSorry). You want to stick some sort of delimiter between them, and it needs to be a delimiter that the text is _guaranteed_ to be unable to contain. Sometimes you get lucky and you can just use a null or something. In this specific case you definitely can't, and will need to create an encoding scheme for the values that is unambiguous. Given what else is done to the message in this example, the opportunity for screwing around is _really_ small, so just consider this a discussion about good practices for this sort of thing. &gt; Of course, the body validation here is very fragile, since changing a single character in the body of the message will necessarily affect its SHA256 hash, and therefore its signature. Which is particularly enhanced in this case by the fact the same JSON has a float in it, and `10123.4` is exactly the same as `10123.40`, and there's a lot of other equally legitimate ways to represent it. Signing the literal JSON is the sort of thing I would never put into production, because the odds I want to pass the JSON through some other system that may have different behavior is just too high. You could either embed the entire message again as a string (that's very hostile for stream processing, so you can't get too big with that), or sign pieces, or come up with some other mechanism. Personally, I'd most likely go with a mechanism where I'm signing the JSON, but the signature is separate for most things. You can do something as simple as "4 bytes in network order for how much JSON there is, that much JSON, followed directly by the constant number of bytes for the signature". Might want to reserve a byte for the type of signature, though, or it might be safer to use a size-delimited string for the signature too, for future proofing. If I had to use web, I'd probably go out-of-band, either a separate form parameter or part of the querystring or something. I say this as someone who does on occasion depend on the exact bytes some JSON has, so it's not like I'm completely against it. But when I do it, it's definitely an internal implementation detail, not a message traveling somewhere else.
Ofc, you can https://play.golang.org/p/XTA_27HeywQ :)
Good advice, and you’re right. The main idea of the post though was to illustrate a variety of concepts around ECDSA validation in Golang, but the JSON message serialisation is really important to the usefulness of such validation. Perhaps a better, more production-grade version of this sort of arbitrary nested JSON hashing would involve a more predictable recursive hashing of fields within sub-objects? In other words, hash each field in the *body* sub-object to produce a hash of the *body* sub-object as a whole (perhaps using a delimiter, as you suggest), and then use that hash (with delimiter) to produce the hash of the envelope along with the *type* and *userId* fields. Kinda like a Merkle tree? The trouble with decimal fields is, as you say, the many different variations of how one can serialise them, and so consistency there is important. Many current blockchain systems I’ve used work around this by enforcing the requirement that all fields be strings, and only strings.
Missed opportunity!
`http.StripPrefix` is pretty useful and commonplace.
In my case, I have unit tests and integration tests. However, although Short() might be a good idea in some cases, when you have integration tests, you will have to constantly run `go test -short` because integration tests could take some time. Instead, I have integration tests inside a different file `something_int_test.go` and I added the comment `// +build integration` at the top. That way, when I want to run my integration tests, I just run `go test -tags=integration`
Use https://golang.org/pkg/sync/#WaitGroup
I agree. Everybody wants to be famous writing and promoting their CRUD and superficial articles. \*\* proceeds to list GraphQL in their resume \*\*
&gt; I don't miss maps, reductions, and filters. I find that a simple for loop achieves the same goal while being much easier to understand than a complicated chain of maps, filters, and reductions. Are you joking? A chain of maps / filters / reductions is unlikely to be easily rewritable as one simple for-loop, you'll probably get multiple complex ones with a bunch of local state, chances are the code won't even be as efficient, since it's harder to do lazy evaluation by hand. A chain of a few relatively simple maps/reduces/filters can easily explode to dozens of lines of iteratorless code. It's also quite a bit harder when reading code to figure what a complex for-loop does compared to a readily-recognizable function such as map. Also, many times iterators are a great opportunity for parallelization. Specifically, in Rust, you can use Rayon's `par_iter` (et al.) to turn iteration into a parallel one with minimal code modification. That's not something that can be easily done with for loops, even in Go with their goroutines this is much more awkward to do. 
Because implementing these things in the compiler (as opposed to in a library via generics, as is the case for most statically typed languages) is quite a lot of work and all it does is save you keystrokes the keystrokes associated with writing out a for loop (without user-defined generics, you can't compose them in a generic fashion anyway).
Probably because you can do all of your processing faster than the system can read the files off of disk, so it makes practically no difference how *much* faster your code runs.
\&gt; Maybe I'm using goroutines/channels completely wrong? I think so. It looks like you are spinning up one goroutine per file. This would be fine if the task wasn't CPU/Disk intensive. (i.e. a web crawler that is mostly waiting on the network.) Your CPU can only do N things at once (where N is around the number of processors.) There is a similar limit for your disk. (Sequential reads are \~100x faster than random reads.) If you spin up too many goroutines, the program will actually get slower overall because of overhead (switching tasks) and because your various caches are constantly being thrown out. You should try a version where you only have N goroutines total, each one works on a single file+validate, and only start a new file when one ends. Alternately, maybe one goroutine generating files, and another N checking them.
\&gt; But I expect the Go community consensus to remain that such things aren't really Go. I hope so, but I'm not holding my breath. I have a few use cases where generics would be nice, but I do think there will be considerable "damage" to the package ecosystem (consider how many web libraries there are right now and then imagine that multiplied by every new programming paradigm that generics enable--really looking forward to that zero-allocation monadic abstract factory bean web framework).
The compiler generates an error when types are incompatible with the arguments of the called function. Can you clarify what you mean by 'type assurance' being lost? 
I didn't read that as "context switching". I read it as the unit of work being done by the goroutine as being cpu intensive. If the cpus are maxed with 8 goroutines then spinning up 100 won't make the program faster. And similar if they are already saturating the disk or thrashing cache. 
No, it wouldn't. https://play.golang.org/p/DzoRJefeWn5
Absolutely agree
This is how F[A, B]: C generics would work with this proposal: ``` type Person struct { Name string } type SpecialName string type SpecialPerson struct { Name SpecialName } //Assign name takes a pointer to a structure with a Name property and assigns it 'value'. //Passing a non-pointer struct has no effect. both arguments can be different types. //Generates a compiler error if passed invalid types. func AssignName(structure, value generic) { structure.Name = value } var person = new(Person) AssignName(person, "Bob") fmt.Println(person.Name) //Bob var special = new(SpecialPerson) AssignName(special, SpecialName("Alice")) fmt.Println(special.Name) //Alice AssignName(special, person.Name) //compiler error: cannot use special, person.Name (type SpecialPerson, string) in arguments to AssignName ``` and this is how F[A]: B[A] generics work. ``` //T has no special meaning here, it is a variable name. //This function creates a map that can hold values corresponding to the type of the passed argument. func CreateStringMapOf(T generic) generic { return make(map[string]typeof(T)) //typeof(T) is replaced by the type of T. } var IntMap = CreateStringMapOf(0) //Like with an interface implementation, raw types are passed. IntMap["a"] = 1 IntMap["b"] = 2 var StringMap = CreateStringMapOf("") StringMap["a"] = "a" StringMap["b"] = "b" //Etc... ``` 
Not sure what you're getting at with that, mind explaining? &amp;#x200B; I was thinking more of a package which had defined: &amp;#x200B; `type generic interface{} // just as an example` &amp;#x200B; `func MyFunc(a,b generic) {` `}` &amp;#x200B;
This kind of thing really makes no sense and would actually be slower: https://github.com/editorconfig-checker/editorconfig-checker.go/blob/9f7a3326613a908d7febaea6143329b8ea8b7791/cmd/editorconfig-checker/main.go#L118 If you create a channel, run a process in a gortouine and then block waiting for just that result right after, you are not doing anything concurrently and are adding the overhead of channel communication. 
The following change is simpler and yields a 300-400% performance increase on a large repo here, may want to put worker count behind a flag: diff --git a/cmd/editorconfig-checker/main.go b/cmd/editorconfig-checker/main.go index 394975e..bbf3303 100644 --- a/cmd/editorconfig-checker/main.go +++ b/cmd/editorconfig-checker/main.go @@ -5,20 +5,23 @@ import ( "bufio" "flag" "fmt" - "github.com/editorconfig-checker/editorconfig-checker.go/types" - "github.com/editorconfig-checker/editorconfig-checker.go/utils" - "github.com/editorconfig-checker/editorconfig-checker.go/validators" - "gopkg.in/editorconfig/editorconfig-core-go.v1" "io/ioutil" "os" "os/exec" "path/filepath" "strconv" "strings" + "sync" + + "github.com/editorconfig-checker/editorconfig-checker.go/types" + "github.com/editorconfig-checker/editorconfig-checker.go/utils" + "github.com/editorconfig-checker/editorconfig-checker.go/validators" + "gopkg.in/editorconfig/editorconfig-core-go.v1" ) // version const version string = "0.0.1" +const workers = 8 var defaultExcludes = [...]string{ "/.git/", @@ -83,23 +86,44 @@ func isInDefaultExcludes(file string) bool { // Adds a file to a slice if it isn't already in there // and returns the new slice -func addToFiles(files []string, file string) []string { +func processFile(wg *sync.WaitGroup, validationCh chan&lt;- types.ValidationErrors, file string) { contentType := utils.GetContentType(file) - if !utils.StringSliceContains(files, file) &amp;&amp; - !isInDefaultExcludes(file) &amp;&amp; + if !isInDefaultExcludes(file) &amp;&amp; (contentType == "application/octet-stream" || strings.Contains(contentType, "text/plain")) &amp;&amp; !isIgnoredByGitignore(file) { - return append(files, file) + validationCh &lt;- types.ValidationErrors{FilePath: file, Errors: validateFile(file)} } - return files + wg.Done() +} + +func worker(wg *sync.WaitGroup, filesCh &lt;-chan string, validationCh chan&lt;- types.ValidationErrors) { + for file := range filesCh { + processFile(wg, validationCh, file) + } } // Returns all files which should be checked // TODO: Manual excludes -func getFiles() []string { - var files []string +func processFiles() (int, []types.ValidationErrors) { + var ( + fileCount int + filesCh = make(chan string) + validationCh = make(chan types.ValidationErrors) + validationErrors []types.ValidationErrors + wg = &amp;sync.WaitGroup{} + ) + + for i := 0; i &lt; workers; i++ { + go worker(wg, filesCh, validationCh) + } + + go func() { + for validationError := range validationCh { + validationErrors = append(validationErrors, validationError) + } + }() // loop over rawFiles to make them absolute // and check if they exist @@ -122,7 +146,9 @@ func getFiles() []string { // and then checks if should be added. This needs some refactoring. err := filepath.Walk(absolutePath, func(path string, fi os.FileInfo, err error) error { if utils.IsRegularFile(fi) { - files = addToFiles(files, path) + fileCount++ + wg.Add(1) + filesCh &lt;- path } return nil @@ -136,10 +162,15 @@ func getFiles() []string { } // just add the absolutePath to files - files = addToFiles(files, absolutePath) + wg.Add(1) + filesCh &lt;- absolutePath } - return files + wg.Wait() + + close(filesCh) + close(validationCh) + return fileCount, validationErrors } func readLineNumbersOfFile(file string) []string { @@ -201,17 +232,6 @@ func validateFile(file string) []types.ValidationError { return errors } -// Validates all files and returns an array of validation errors -func processValidation(files []string) []types.ValidationErrors { - var validationErrors []types.ValidationErrors - - for _, file := range files { - validationErrors = append(validationErrors, types.ValidationErrors{FilePath: file, Errors: validateFile(file)}) - } - - return validationErrors -} - func getErrorCount(errors []types.ValidationErrors) int { var errorCount = 0 @@ -253,12 +273,11 @@ func main() { } // contains all files which should be checked - files := getFiles() - errors := processValidation(files) + fileCount, errors := processFiles() errorCount := getErrorCount(errors) if params.Verbose { - fmt.Printf("%d files found!\n", len(files)) + fmt.Printf("%d files found!\n", fileCount) } if errorCount != 0 {
If you need generic methods on the generic container: ``` type GenericMap generic //Can be inlined. //Returns a Generic Map mapping strings to typeof T. func NewGenericMapOf(T generic) GenericMap { return make(map[string]typeof(T)) } //Can be inlined. func (m GenericMap) Set(index string, value generic) { m[index] = value } //Can be inlined. func (m GenericMap) Get(index string) generic { return m[index] } //Float64 map. var aproximations = NewGenericMapOf(float64(0)) aproximations.Set("pi", 3.14) aproximations.Set("e", 2.71) aproximations.Set("i", 1i) //compiler error: cannot use 1i (type complex128) in arguments to GenericMap.Set fmt.Println(aproximations.Get("pi")) //3.14 ```
how about miss me with all this gay programming shit and tell me if it makes me money or not
IMO just vendor your dependencies and avoid these issues.
&gt; What happens when a person just deletes their github repository This can be mitigated by `go mod -vendor` which saves a copy of dependencies to a `/vendor` folder in your project. Beware that it [prunes non-package directories](https://github.com/golang/go/issues/26366) from dependencies but this should be a problem most of the times. By default, `go build` [reaches out to the network](https://github.com/golang/go/wiki/Modules#can-i-control-when-gomod-gets-updated-and-when-the-go-tools-use-the-network-to-satisfy-dependencies) as needed to satisfy imports. You must tell it to use vendor explicitly with `go build -vendor`. &gt; can a user just update their code base on github with some major changes `go mod` pins versions. It will only change dependency versions if you tell it to.
Do you plan on going from not an app to the size of twitter overnight? If you want to learn Gin, why not just learn it and see where it takes you?
If you relax the 2nd point, there are at least 4 JVM languages which do pretty well on the other 3 points. For most applications having a runtime isn't a big issue. And now that everything is moving to the cloud there are at least 2 layers below your OS anyway. What's the problem with a runtime, especially for servers? I wouldn't choose a language because it can spare 5 minutes of installation/upgrade a few times per year. Anyway when graalvm is mature enough it will give many languages the opportunity to be used without a runtime. Other than that Haskell ticks all the boxes. 
&gt; They switch when they’re blocked on i/o, Yep, and that happens *all the time* when your goroutines are reading from files. &gt; and even then the switch is cheap. It's sorta-kinda cheap. Fetching sequentially from RAM can be 400x faster than fetching a random location. Reading a recently written location can be faster. So there can be measurable advantage by not doing too much at once, and a measurable disadvantage by trying to do too much at once. The advantage is very workload-dependent, which is why I suggested trying a less workload to how much that will help (if at all).
Parallel Map?!? Yes please! ❤️
If you're thinking of writing a Twitter clone in Go, then yes you definitely can. The answer to your question is actually quite complex. Twitter is a very large company that most likely utilizes a service oriented architecture. It's not just a singular code base. There's multiple teams that handle different responsibilities. You might have a team responsible for comments, DMing, photo upload/storage etc. While it is theoretically possible for a company to use Go for everything at a company, it's not entirely practical. People come to the company with experience in different languages. Different teams will have different preferences for different libraries/languages that best suit their use case.
I was going to either do clojure or golang, depending on my mood at midnight. Math-heavy stuff tends to be easier for me to noodle out in clojure. Or if I’m really drunk by then, maybe I will just default to Python or Ruby.
Of course it can if you write the web server in a way that could be scaled horizontally. That means would just start more servers and load balance traffic to them. Usually the bottleneck would be in the database. 
Why are for loops usually faster? If I write a map over an array, the compiler can deduce that my inner function is pure and multi-thread the code for me if the loop is expensive.
I go but i think i may do dart and Haskell. Need to learn more. Dart is pretty... Normal. But Haskell will be a good learning experience. I've done it every year. Fun times!!
I'm not following Python - someone cares to shed some lights on what happened to it?
Thank you so much for this, I had no idea it was a thing
Sorry sure! In Go, you can redefine built-in types because they are not reserved words. If Go includes a new type, it won't break any code because the code that defined variables, types or functions (with the same name as the new type) will override the new type. In the playground code, I demonstrated how the 'int' type can be redefined as a string type. In the same way, your 'generic' type has been defined as an interface type. Your definition overrides any builtin type with the name 'generic'. Does that make sense? 
https://github.com/carlmjohnson/whatsit
Maybe if it didn't require a login.
Its equally easy to write bad code in any language. Bad code is never the fault of the language.
&gt; Also consider cases where you store monetary quantities in cents Don’t do that. Use a decimal library. You’ll be richer, thinner, and have a better tan. 👍🏻
Thanks again.
RUBY!!!!!!!!!!!!!......!!!!!!!!!!!!
Yeah, I was kinda drunk so I just used Python for the first one. I'm rewriting it in golang right now because it works fine but it's slow as balls.
&gt; Dammit I've become a curmudgeon. Me too brother. I describe this pattern of thinking as masturbation as well. There’s one huge difference though: when you code that hair actually does grow on your palms! 😎
&gt; interface{}, type assertions and reflection have less bug potential than generics is a pretty wild assertion You, sir, are 100% correct! I don’t use those either!
Extremely well said!
&gt; Is it "simple" to call a function that takes &amp;interface{}? How do I know what I can pass in? No, it’s not simple! We should remove that insanity in Go 2. I’ll sure as hell don’t use those anymore. I came in from Perl, then Ruby. I used interface{} while learning Go, then realized how much better interfaces are, and left that crap behind.
💯
Good for you for taking good advice. Software is a three step process: 1. Make it work. 2. Refactor for simplicity and naming until your code reads like prose. 3. Make it fast.
A decade ago a new major version (3) came out that was not compatible with the old one (2). It took years before some major popular modules were ported. And there are people still who use the old one even for new projects.
That's actually very ugly and I'd hate to see it in a code anywhere. For anything but magic constants you can usually use math to achieve the same effect (and more).
There's still generated code which is safe. I wonder, is there a language with generics syntax that transpiles to go?
Then it's fair to say you don't need generics. Generics are really more the domain of library authors (including standard libraries) or those trying to factor out duplication across a large project in a type-safe manner. If it's the aim of the Go team to cater more to these developers, then generics would make a reasonable addition to the language, and would be unlikely to affect people like yourself. That said, it really depends what you mean by "don't use". If you've called `fmt.Sprintf` and `json.Marshal` anywhere in your code, then `interface{}` and reflection are must-have features for you. 
I’ll try Haskell as well! Nice suggestion. 
I had that same thought yesterday, but I stopped myself when I realised I was having it. One of the things I like most about Go isn't just the simplicity of the language in coding terms, but of setting up, running and deploying projects (especially now with modules). 
The level of insanity or incompetence on display here is staggering.
You can use a proxy https://docs.gomods.io/ it's still in beta like go modules but it will resolve this problem.
Would love to see a benchmark ObjectBox vs. BoltDB + Bolthold. Especially for queries.
I would check where time is spent. Could it be that it is just network latency. I suppose you can check that in your browsers devtools.
You'll need to give more information about how your application is written for a better answer. For example, if you're using your own \`net.Dialer\` then you might want to check that you're setting \`DualStack\` to \`true\` and then setting \`FallbackDelay\` to a reasonable value as well because the default \`FallbackDelay\` is \`300ms\`. That said it could very well just be network latency that you can't do much about either.
I want to know, if this performance is normal?
I guess you would allways expect some network latency. It all depends on where you are vs the server. Closer the better. Also server setup matters. I would assume that its not go thats causing the increase. I would start by finding a way to figure out where time is spent.
Depends on where the servers are located, Google and AWS should be reasonably fast if local but if they are on the other side of the world than a few hundred ms is expected. But the variability in the results and peaking for more than a second suggest something else is up. Next step, metrics - you need to know where the performance bottle neck is in order to fix it and the only way to do that is via performance measurement. I highly recommend [Prometheus](https://prometheus.io/) and [Grafana](https://grafana.com/) for this but you can also use your cloud providers native metrics collection methods if they have any. [Netdata](https://github.com/netdata/netdata) is another useful tool for gathering highly granular metrics for a short period of time. There are a variety of different metrics to collect, first is general resource usage - cpu, ram, disk space, swap, number of open files, etc. This will tell you if you box is up against some limit which will hamper performance - then you have two options optimize your system and application or increase the size of your node. Once you are happy your system is preforming reasonably look to your application, add metrics around different parts of your code. Such as every request - if you time how long your server takes to process a request then you can tell how much of that time is network vs how much is your application processing. You may find that on production data your application preforms worst but in dev you see no issues with smaller data sets. You should also look at gos [profiling tools](https://blog.golang.org/profiling-go-programs) which will help with finding hot code in your application. Finding performance bottle necks is a bit of an art that you can improve on by practicing - but the key to it is data, the more metrics and information you have about your application and system the easier it is to find where problems lie.
I've done golang the past two years, going to try Bash and Python this year If they're performance intensive or concurrency challenges switching back to the gopher!
If you have access to shell, do a request from local host and measure the time. If not, you can deploy another machine in the same region or even datacenter, with simple application that sends a request and counts time to response. 
...Why would you resort to insult? At least justify yourself.
it's really useful, thanks for sharing. I'm also trying to let my college realize about the costing of overuse interface with reflection.
I hope you will also make a talk out of it, at a Go conference!
Point 2 is a requirement and one of the reasons I switched to Go. I guess I'm the last person on earth not to be creating social whatever apps whose target audience is the world. The app I'm writing now is delivered as an executable to be dropped on to whatever machine the clients want and run for use within their network. Mostly small business where sometimes the the "IT department" is their "computer person." I don't want to be in that loop. Think Apache Guacamole as an example of software hindered by it's lack of a single static binary. GraalVM looks really interesting and I've been casually following it for a while now. It's got two huge strikes against it though. First, it's not going to be ready for production for quite some time. Second, it's Oracle. That means eventually it's going to be weaponized against free use. As far as I can tell, Haskell is math. When an application is validating data, moving it from one structure to another, combining it with other data sources in various formats, etc. and not having really any math parts then Haskell seems to me to be pretty far from any suggested use scenarios I've read about. Supposed to be a really steep learning curve too, no? &amp;#x200B;
I cannot view the post
Yup that's not Go, because localhost go serves upto 219.5K req/s
&gt; Other than that Haskell ticks all the boxes. And OCaml as well. But they're a different breed entirely. /u/cy_hauser makes a perfect point. If I need a compiled-to-binary, memory-safe imperative language I'll pick Go (even though I don't like it very much).
I though Dart was dead...
Anyone interested in joining a /r/golang leaderboard: http://adventofcode.com/2017/leaderboard/private and use the code 235071-2acde629
Localhost serves upto 219.5K req/s, but remote host only 400-500 req/s. I don't know why
Well, safe, yes, but a stupid convoluted bodge which libraries can't really do.
There are perfectly valid uses for generics, e.g. `map`/`filter`/`reduce`, which can only really be expressed in Go by, well, moving outside of the type system, because the type system is awful.
There could be perfectly good middle ground, like allowing `map`/`filter/`reduce` and general iterator stuff, removing the horrible stuff like needing to copy-paste for loops but not having too much craziness.
It's effectively just generics but implemented stupidly with no safety.
For one thing, interfaces exist. For another, being able to *read* what the code does at a low level is *entirely different* from actually understanding what it does at a high level.
In this case speed should not matter, the result is instantaneous. Unless you used list instead of set in the second exercise.
Rust satisfies 1 and 2, there are very good web frameworks satisfying 4, but it has a cool non-GC memory model which also doesn't require `malloc` and `free` like C.
yep ... the site is good and pretty, but after i saw i have to login for this, the tab was closed.
Yeah I definitely used inefficient data structures
Not sure if it's just my mobile view, but the code sections are not formatted correctly and very hard to read.
It's unbelievable that reimplementing `append` is faster than the built-in. What the heck is the built-in doing? 
I have to say I've never tried this approach, but I see what you are saying.
Github : [https://github.com/hasanaliqureshi/Go-Validation](https://github.com/hasanaliqureshi/Go-Validation)
Kinda neat. Have you thought about working directly with Cobra flags?
Empty interfaces are complex to use because using them is discouraged. They are complicit in degrading readability just like badly implemented generics would be. Having code be clean and non-ambiguous for low-level reading greatly facilitates higher-level understanding, especially in cases where naming conventions and documentation are lacking.
But .. but .. but servers are cheap and hardware is plenty! You say :-) 
The `append` builtin is doing array doubling to keep the cost of adding a single item amortized to constant time. The next append to the array would effectively be free in the append case, but incur the cost of allocating and copying the 1001 element array in the second case. 
There, you have your answer. It's not your app fault, otherwise you would have similar latency from localhost... unless you are - for example - reversing peer IP to names, which will always be faster with clients from localhost (no DNS queries). The distance seems to be a problem. It takes long time to connect and pull data from a remote server. You could try make it faster, but that depends heavily on characteristics of your application and data being sent to clients. For example, costly operations that generate information that doesn't change often can be cached or partially cached.
That makes sense. I have disabled login so it should be open to the world now. Thanks for the suggestion.
Also, the append benchmark is broken. Once I fix it and adjust to measure just the time to append 10 elements, we get these results BenchmarkAppend-8 10000000 159 ns/op 493 B/op 0 allocs/op BenchmarkMakeCopy-8 10000 482151 ns/op 4039736 B/op 10 allocs/op Code here: https://play.golang.org/p/ElV7kziW6Ud
Ok, that's one. I'm not saying if isn't used. I'm saying that it's extremely limited and rarely used compared to other languages that have higher order functions and that's only idiomatic because of the lack of generics. Parametric polymorphism makes HOF useful. I'm not arguing for generics, BTW; I'm torn about adding them. However, OP's request was specifically about a use case that is only achievable, currently, through hacks: copy/paste code duplication, code generation, or reflection.
Argument at my company is that the salaries for the time spent learning a different language would cover months or years of hosting, so there's no benefit.
[removed]
Save power, use less resources, save the planet. 
What the benchmark measures is two ways to append the 1001st element to a 1000-length slice. If you can make sure there are not 1002nd, 1003rd, ... elements to be append, the benchmark is not a bad benchmark.
Yeah, trouble is there’s no “out-of-band” mechanism in my use case to transmit the signature. For example, if I were using HTTP to send the JSON payload I’d naturally put the signature in a header. Alternatively, sending messages in a JSON web token-type format could perhaps work. Bit of a bastardisation of JWTs though, if you ask me...
Not to be a devil's advocate but I'd be curious to see a comparison of implementations. 81% under load *down to* *7?* That doesn't sound *just* like a language switch, but also implementation. Great for them on the improvements &amp; fun new language, but I'd want to see more details on this before attributing it all to Go.
It is normal, very normal.
You can be like a real engineer and not a Java person. 
[removed]
It just indicates a trend.
I have a feeling lots of people with this opinion are not dealing with complex enough engineering problems.
How are you making the requests when testing the AWS installation? Take a look at https://github.com/dave/blast ... with that you can easily make concurrent requests to test throughput of a remote API...
Mh, constant time is important in security relevant cases, a build flag to toggle cases like this would be good.
Probably thread related. 
I'd guess they did a few optimizations along the way .. though not having to lug around a whole VM/RE does help, too :)
Constant time in this case is a performance optimization not a security hole. I suppose the regexp package having linear time matching falls somewhere in between. In crypto, constant time operations dealing with protecting either the secret key or leaking information about invalid padding etc that can be used to retrieve the key or otherwise forge messages.
Consider posting a standalone post, so we can get more people to use it :) 
If you know you only ever need to append a single element, allocate a slice with len 1000 and cap 1001 and append will still be constant time and make+copy will still be expensive.
Yeah you do more engineering. Because you don't have to think again about your code and nor does the next guy. 
Ah I see what you were saying now. Yep fair enough.
One major point of go is it works with the hardware. That's why slices are the major data structure because they're backed by arrays which result in fewer cache misses because your data is generally more contiguous. But that's a nutty difference. 
Maybe it is related to max heap size. A samll heap size will cause the Java version to run gc frequently.
Just ask for pay cuts. 
Totally! And that's clearly shown in their binary and mb usage - hence why I was mostly curious on the CPU usage. Everything else kinda "makes sense" so to say
And no amount of hardware can reduce response time by a magnitude. Somethings can only be achieved by chaining the underlying technology.
demo: https://go-city.github.io/#/github.com/golang/dep repo: https://github.com/rodrigo-brito/gocity
It also depends on how you deploy your app. If you’re using Lambda functions as an example, you will see high latency if your function hasn’t been called in a while. Other considerations as well for other compute services. Your EC2 might need optimizing, or if using ECS, check routing if using EBS, etc. 
check out [https://github.com/go-oauth2/oauth2](https://github.com/go-oauth2/oauth2) that should tick all the boxes
Yet languages which have neither have sprintf and JSON libraries...
Well, certainly, but often generic code is important to make higher-level understanding easier (`map` is easier to understand at a high level than a `for` loop).
Go save the planet 
If that is an argument for switching languages then why not go straight to Rust or c/c++ ? 
I think the GC is a big ergonomic draw for people trying to get closer to metal. 
[removed]
Here is a slightly corrected version: It allocates in each run on the heap, rather than just once per benchmark. BenchmarkAppend-4 500000 3400 ns/op 24576 B/op 2 allocs/op BenchmarkMakeCopy-4 100000 14053 ns/op 90112 B/op 11 allocs/op https://play.golang.org/p/JLxrkpQD99w
Thanks for the tips. I'm just starting to understand the power of interfaces and testing which I never realized before. It's kind of hidden within the language and not explained in a good way in the official doc, you can only see it in the source code.
Yes so sorry but LinkedIn mobile rendering doesn't work really good
Oops, thanks for catching that.
In both versions the arguments of copy seem swapped, the signature is `func copy(dst, src []Type) int` but output is passed as a second argument. it probably has no implication on performance though
I noticed that but decided to keep it as the original benchmark did that too. It doesn't affect performance.
Ease of programming?
Yes, you can do things like: usleep(100 * 1000) ...but if you think that's better I can only assume it's due to familiarity with the workaround.
I’m not the author. Just sharing a curated article of my Golang Ninjas newsletter which wasn't yet published on Reddit.
Nice. This should be added to the ResearchPapers wiki page if it isn't there already.
Yo asm saves planet go is super Power hungry :)))) , i86 is bane of humanity so power hungry .... /s 
There is some metric that often gets overlooked which is amount of watts per user needed. Because traffic generates cost. So yeah go is more efficient than java but everything depends on arch and how complex project is. Sometimes rewrite into new language is insane cost. Dev time is also a factor :) imho such comparisons are bad.
Maybe the person that did the re-write is just better than the original implementor. Maybe it's easier to do the second pass because you're well aware of the drawbacks of the first implementation. Maybe the person doing the re-write is a go advocate and wanted to "prove" something. Give me a poorly written app and virtually any (reasonable) second language and I'll "prove" that second language is "better" than the first. It says more about the quality of the original implementation and the talent of the engineer that re-wrote it and less about the language.
Done! :)
Rust isn't that hard in many cases (except when you want to mimic a C-like data structure and still get automatic cleanup; guilty as charged, your honor), but you'd be almost crazy to program in C/C++ nowadays. I mean, C++ is a lot safer these days, but that costs performance too. I think the gain of C++ over Go is almost always too small to be worth the hassle.
Yeah, that’d work :-)
I’ve been thinking about ditching frontend engineering and jumping on the Go bandwagon for a while. I just need an extra push. How fun are Go gigs exactly? Thanks.
I can personally speak to this we rewrote a component originally designed in Java into a Go lang implementation and saw a 100x improvement. Yes the implementation was significantly more focused, and yes it was not a direct translation but in Java you’re forced to translate all XML into Java objects in Go you’re not required too and makes Go makes a huge difference. Never underestimate the costs of garbage. Especially since significant parts of the data were never used. 
OCaml and Racket. 
I’m not the author. Just sharing a curated article of my [latest Go Ninjas newsletter issue](https://www.getrevue.co/profile/golang-jexia/issues/go-2-continued-producer-consumer-concurrency-golang-emulators-more-146939). One which wasn't yet published on Reddit.
Haskell is not a language that you use for high performance numerical programming, if that's what you mean by "Haskell is math". But it excels in domains like those that [Facebook uses Haskell with](https://github.com/facebook/Haxl), large heterogenous dataproccessing jobs that can be heavily parallelised. Almost every Haskell application I've personally worked that isn't a web sever did a lot of data validation, cleaning, coercion, serialisation due to the strength of the type system verifying that these operations were correct, and the functional "combinator" approach to tackling these problems. 
I’m not the author. Just sharing a curated article of my [latest Go Ninjas newsletter issue](https://www.getrevue.co/profile/golang-jexia/issues/go-2-continued-producer-consumer-concurrency-golang-emulators-more-146939). Which wasn't yet published on Reddit.
That makes sense if you only look at those two specific dimensions. At my company, we are having a really difficult time hiring because our stack is Java based and it’s usually used by really large enterprises with high capitalization. However, we have less than 10 engineers, have no stock options to offer, and we can’t offer high salaries either. In exchange, this usually has meant for tech companies “you can work with a stack your current large corporation won’t let you write in” but because this is not the case we have lost to the competition in every category besides fun, low-bureaucracy company that treats people well and everyone’s input matters (basically would only appeal to those established in their careers that want a 180 change - good luck finding that). So I’m angling changing our tech stack as a recruiting strategy with personnel benefits that can only be changed by changing the stack we work with, and hiring / retention is far, far more expensive than your infrastructure most likely. I’m not the CTO but with retention / hiring being a much bigger issue than our software itself that will get his attention.
Assembly for the win!
I think it's better because it conveys extra information.
Yeah in that case Go seems to be a good option for you. Haskell isn't too much more math than any other programming language. A lot of people use it for category theory stuff either for research or as a hobby, but you don't need to know all that to use it. Moving and shaping data is a pretty convenient task to do in it. To be honest after working with algebraic data types, all the other data representation options I've seen feel worse. The learning curve is probably high if you don't already know a typed functional language. 
Thinking doing something similar myself. It'd have to be a longer term plan,as there are very few remote gigs and most job ads for Go are for pretty experienced ones, very few junior Go positions exist at all..
I wonder what caused the slowness in the reponse to POST requests.
True. It says the original java was written by someone at dell and handed over to them. Who knows if Dell even recommended them to run that code anyway. It sounds like it served its purpose well enough until the customer was able to get their production code ready.
Hey there. I am the author of the blog, thanks for posting it here!
Blog post explains it quite well: https://blog.golang.org/wire
I’m not the author. Just sharing a curated article of my [latest Go Ninjas newsletter issue](https://www.getrevue.co/profile/golang-jexia/issues/go-2-continued-producer-consumer-concurrency-golang-emulators-more-146939). One which wasn't yet published on Reddit
xml into java? What do you mean?
Strangely enough, I keep reading that java/python/c# developers who have switched learn Go in a couple of weeks, it is that easy. I have dabbled here and there and havent found it that easy initially. I will say I am excited to restart with 1.11 now that go modules is out and GOPATH is a thing of the past. That was without a doubt the biggest pain point trying to grasp Go. Now there is talk of Go 2... that sounds pretty great! Hopefully it will be ready to use sometime in 2019! &amp;#x200B;
This is something so few companies grasp. Retention. The cost to pay an employee unemployment should they take that while looking for another job. The cost that you lost training engineer. The cost to spend time finding and hiring another. The cost for time to bring new eng up to speed, etc. If a company doesnt maintain any sort of metrics on this, they run blindly, and dont realize the amount of money they throw away because of this. It is unreal to me today, with all our technology, smarts, etc.. how so many managers/etc have no idea about this nor do they seem to care. Worse, they dont learn from mistakes. They go on to the next job, none the wiser.. or they just continue to ignore that it was a problem previously. 
[removed]
As others said.. ease of coding. Go is moving forward quite fast, and so far its been doing so under intense scrutiny using past experience from the way other past populate languages like ruby, pascal, even Java and C.. so far they seem to be fixing the issues causing the most pain for developers and adding the things most sought after. Rust sounds intriguing and my understanding of it is it is more for system engineers. Go seems to have the right amount of bits to replace other languages in just about every facet except C in lower level OS stuff and gaming..but that may improve as well. I see Rust mentioned more so than any other language in comparison to Go, but even so I seldom see much about Rust. Go on the other hand is the new kid on the block and seems to be taken up more and more by a lot of companies. I am curious to see if Java will bounce back.. it still has a significant lead over just about everything given its huge code base in production now, massive libraries, etc. But the 6 month release cadence has a lot of shops scrambling to figure out what to do now... Java 8 is EOL yet something like 78% are still on it and some polls indicate most wont be moving away from it anytime soon. It is a bit of an undertaking apparently depending on code base and 3rd party libraries being used that are not yet on 9/10/11. &amp;#x200B;
[removed]
I've converted people to Go at previous jobs and they've been up to speed in as little as a week. More commonly 2-3. But we have about 50 engineers so each week of productivity loss from that many people works out to a single person's full year salary. Hard to justify a cost like that from a bean counter perspective. Plus we have some senior folks who are dead set against the trendy new "unproven" tech the kids are using these days.
&gt; in Java you’re forced to translate all XML into Java objects What makes you say this? Java doesn’t force you to do anything with xml. You can use StAX and parse it as a stream, or Jackson with Spring and have your xml mapped to objects automagically, or you can parse it byte by byte if you want. If you get 100x performance improvement you can be pretty sure it’s not because of the language. If Java was really that bad, it wouldn’t be so widely used.
You can't prevent programmers inside the same address space from doing bad things, anyway. What you can do is make the obvious use correct. For example, `var a foo.AccessToken` might leave it zero in a way you don't like, but `var a *foo.AccessToken` and normal use of `a := foo.NewToken()` guides the caller to the right thing much more clearly. Consider `os.File` and how nobody ever seems to get that wrong.
[removed]
I've been following Rust and have played with it a bit. It definitely has manual memory management. Not only that but it's quite difficult to master. The 2018 Rust survey just came out and there were many people who said they still didn't feel comfortable with the language after more than a year of use. While Rust is, I'm sure, ideally suited to it's niche, for applications that have absolutely no need for ultimate performance nor any form of manual memory management it just doesn't seem worthwhile to spend any time at all trying to master that aspect of the language. Not needing to think about lifetimes and ownerships and such would be way more productive when the features add no value to an application. I think Rust with fully managed ownership and lifetimes at the cost of some performance would be nice though.
And how would that constrain multiple types together? I'm all for a more readable syntax for contracts, but they're still not interfaces.
[removed]
Punch cards or gtfo 
[removed]
&gt; so far they seem to be fixing the issues causing the most pain for developers and adding the things most sought after. what things if i may ask? There is a reason why TypeScript, Java, Sacala, C#, Kotlin, Swift have generics. Because it is superior. Treating warnings as errors is also a huge pain. The language was invented for beginners and thats what the creators said themselves. GO is popular because people who come from python get some performance and people who come from C has an easier time developing code. The other modern popular languages are not loosing so much in popularity to Go because in language evolution it is a step back. 
Belatedly (because you got me to sit down and think about this): While we could theoretically evolve generics at a technical level, I think that they will be frozen once released in Go for social reasons, including that Go 2 will likely have a compatibility guarantee in the way that Go 1 does. If the Go developers liked generics and liked language evolution it might be a different story, but my impression is that they aren't enthused about either. I'm fine with not being able to implement a straightforward Max on composite types. If `&lt;` doesn't work on a type today, I don't think that generics should try to change that unless there is an easy and straightforward way to do so, because the whole area is a much bigger and more tangled issue. (For the record I agree with the reasons for not giving methods to other people's types and I don't think Go should try to change that. That's why I think that needing special methods on types to do generic things with them is a real problem, because it means you can only really work easily with cooperative types.) Overall, I wound up being able to finally nail down my views on why I think interfaces are the wrong starting point for type constraints, which I've written up [here](https://utcc.utoronto.ca/~cks/space/blog/programming/Go2GenericsNotWithInterfaces).
Maybe derekebassett was talking about Go Templates not needing any sort of Object mapping. I am a mostly Java developer who just started learning Go. Go is really nice but a 100x improvement means that there was something wrong with the way Java was used. That does not mean Java is bad. I have seen many developers use anti-patterns and then blame the language. Java is improving as well. The newer versions are really making optimizations on the run time and new features are being introduced in the JDK. 
Go is a step back from python, java, etc? I am not versed enough to say one way or the other but most (read that as the few that I have found recently) articles indicate go is a lot faster than java, which itself is a lot faster than python. Of course this is subjective on what it is being used for. For me, it would be micro-services. Rest API services and such. Python is awful at this. Java is much faster, from a simple comparison, but simple is the key word. Naturally you find people who fine tune the hell out of their favorite language and come away with good results too. But out of the box, Go was designed for threading, networking and light cpu/memory use. That there is a fair amount of software like Slack, some of google, facebook, Github, and others building key/performant infrastructure bits with it and in some cases you can read about people moving from java to go and seeing big gain in performance as well as less development time... well this is again just my opinion from what i am putting together. Until I actually learn and use it I can only go by my findings from others. I believe 1.12 or 1.13 is adding generics? Or maybe that is a go 2 feature.. cant remember now. But do tell how Go is a step back? If anything I would say its a step forward.
I cant believe they would say a years worth in total time is wasted. If you convert one engineer every 2 weeks, and that engineer is now more efficient than before.. then you really are NOT losing time.. I would counter that in about 6 months or so they have broke even if not surpassed their previous output and in a years time will be positively producing more. I gotta say.. a week.. even 3 to 4 weeks to be up to speed? That seems a bit unrealistic. Regardless if the language syntax is similar.. there is no way they are memorizing libraries, all the nuance especially if they were used to the nuances of say java, c, etc.. in a few weeks to the point where they are back doing as well as they were a few weeks earlier in another language. Sure, they can get the gist of the language.. imports, some of the syntax, etc. But I have a hard time believing they are full swing Go developers in a couple weeks, even a couple months. 
It is a strategic step back to carefully look at the big picture, so as not to rush into implementing redundant features. The Go team is really taking a [thoughtful, methodical approach](https://blog.golang.org/go2-here-we-come).
Whether an approach is wrong depends on the problem you're trying to solve. If you do a POST on a web service to create an object, you don't gain anything but a great deal of extra work by writing a super fast state machine implementation to parse the XML tag by tag. If your task is to find one particular tag in a 2 Gb XML file, then you definitely don't want to use an object mapper. I would say the latter is a rather obscure case, because in that situation XML is probably not the right format for your data. 
That's quite the username.
&gt; Jackson with Spring and have your xml mapped to objects automagically That is literally the problem. In order to access or manipulate the data, it has to be parsed into a Java object, which comes with a pretty big overhead and isn't needed for non-jvm languages.
I write code both in java and golang, on large production systems - micro services and all... forgetting about the fact for a sec that all storage layer is in java (no viable databases in golang yet), I’d say that similarly written code (no heavy frameworks etc) performs about the same in java and golang. Memory consumption is on par too (add some in memory caches to go and see how far you get on 7mb - about as far as in java). CPU usage is also about the same for realistic production systems, with a load of interfaces, serializations etc. Now, the biggest reasons in my mind for go over java are: - kitchen sink type included base environment (including go formatter, linter, and code inspector) - restricted language that leads to basically same looking codebases, with everything more or less readable regardless of level of developers. No need for PhD in cs with 20 years of oop baggage to read go code, - native libs integration that basically a world of difference over java 
wow those're BIG differences!
[removed]
&gt; The language was invented for beginners and thats what the creators said themselves. This is not true and that quote is often misunderstood. It’s true that a goal was so that _newly hired graduate engineers could be immediately productive_. This was accomplished by keeping the language relatively simple syntactically, clear and easy to reason about, and also probably contributed to the rigid build tooling. But to take that statement and derive that the language was _meant to be used by beginners_ is just wrong. There are still plenty of non-beginner tasks you can accomplish in Go that just can’t be done with the same simplicity in practically any other language. 
You cherry picked one parsing option from his list and concluded “ah, ha.. java is fundamentally flawed”
What happened to posting in the title that this is a newsletter?
I know a startup that changed its tech stack from java to scala in order to attract a certain kind of engineers and 'weed out the consultants and career programmers'. Generally this makes it more difficult to hire, not less. You're fishing from a smaller pool, and in the case of Go, those really large enterprises are fishing there too. I think you should choose / stick with a technology that suits the problem. 
I’ve found some packages of interest: • https://github.com/sg3des/eml • https://github.com/DusanKasan/parsemail • https://github.com/sendgrid/go-gmime
I'm generally a fan of the theory that you don't know how to solve a problem well until you've solved it once already. A lot of these rewrites and ports benefit from knowledge about how to solve a problem and an understanding of the real requirements after the fact. Not to say that there isn't a Go benefit. Just an observation on software.
Agreed! I'm sure switching paradigms also helped introduce new ideas on their existing solution. 
But I wrote that whole post to tell you that you don't. There isn't one way to handle XML in Java. You're not forced to use an object mapper, like you and derekbasset say. Just off the top of my head, DOM / JDOM read the whole document in memory and parse it into a tree. That is easy to use and reason about and fast for small files, but doesn't work for very large documents. SAX / StAX parse the XML on event-like triggers without keeping a tree in memory. This is very fast and memory efficient, but fills your code with XML parsing logic. Jackson (un)marshals between objects and JSON or XML. XPath offers a query language for parsing and searching XML documents. Every tool and library have their advantages and disadvantages. I'm not a Go expert yet, but I'd be shocked if there is only one way to do it. 
This guy's posts are pretty good. Saved.
235071-2acde629
afaik there's still no decent graphics library for Go is there? eg dx11 / opengl has a lot of support out there for C++.
What extra information?
Making the world a better place
VS Code has excellent support for Go.
And also doesn't have the abbreviate function. The goal wasn't to replace humanize, but specifically provide this function to someone who requested it on the go slack channel: potentially more eventually.
VS Code is probably the most common. IMO GoLand from Jetbrains is better, but it is not free
&gt;Go was designed for threading, networking and light cpu/memory use. Go was designed for simplicity and compilation speed. They needed something with the power of C++, but easier to master and much faster to compile. Rob Pike: &gt;The starting point was long compile times—for some of our big software at Google, build times can be unreasonably long, even with our large distributed compilation clusters. The dependency management (or lack thereof) in C and C++ results in far too much code going through the compiler. You might say that Go was conceived while waiting for a big compilation. &amp;#x200B;
Thanks for the comment. I don't understand, Cobra flags is for building CLI interfaces, what's the use of that in this script?
I'll be trying to keep up this year. https://github.com/xopherus/aoc2018 if you're interested!
On part two, you could just use a set (`map[int]struct{}`) instead of actually counting occurrences since you can stop when something is already in the set. Just a suggestion.
C++ is still the industry standard for game development and graphics. I think Rust will catch up but I don't see C++ going anywhere soon 
I'm glad to see that AOC is really taking off and tha go devs are trying it as well 
Good catch! You're 100% right - the value in the map doesn't matter, only the existence matters. This is a great use case for using `struct{}`
I agree it is pretty terrible, for a variety of reasons. But it is the least-bad approach, short of writing your own protocol and having a new port-open. Moving things over websockets (TLS), also gives you some compression for free, I guess. Though that doesn't really help so much.
Take a look at /r/emudev if you're interested in emulator development too, the chip-8 system comes up a lot. 
I think you will have to look elsewhere for operator overloading
Yes I have. This link https://margo.sh/b/migrate/ that you pointed is the right one. It works fine for me. 
My personal feedback is that I don't think interfaces are strictly about methods. I see them more as "pattern matchers" than "behavior describers". I think that my counterproposal for contract embedding (having contracts be embedded into interfaces) will make it so that parametric types will be needed less often, AND unifies the idea of contracts and interfaces
I currently use the IntelliJ solution for most of my dev work and it’s been great. For simple tasks Sublime is okay but it really doesn’t have easy to install support for go.
&gt; add some in memory caches to go and see how far you get on 7mb - about as far as in java Yes, (7M runtime memory + 1000M caches) vs. (200M runtime memory + 1000M caches) is on par. But is this a typical comparison?
Uh, I feel we're talking about different things here. Really, I'm talking about the JVM, not java specifically. All of the methods you mentioned above are still creating java objects behinds the scenes to access the data, just in different ways. The reduction in memory has little to do with the code itself, its just the JVM (although different programming styles can definitely cause a pretty massive difference too, but thats on the dev for writing shit code). Also, should mention I'm a Java dev and have first hand experience dealing with the JVM's shitty memory m,anagement.
```func (m *Map) Store(key string, value interface{}) {``` should probably be: ```func (m *Map) Store(key string, value chan interface{}) {``` or: ```func (m *Map) Store(key string, value hasReported) {``` This change will cause some type errors because you store a (nonexistent?) `interface{}` in: ```cache.Store("1", &lt;- reported)``` Replacing that with what i assume you intended: cache.Store("1", reported) reported &lt;- struct{}{} fixes the issue afaict. https://play.golang.org/p/u_iug6hzgSK
Surely, Java bytecode that creates objects can be optimized away? Unboxing is done by most Java compilers, right?
Nope, all un-boxing does is break them dome into smaller Objects most of the time. Remember the Java is actually running on the JVM, not the operating system, so it can't do compile time optimisation the same way a machine native language can.
Some extra context from the edgex blog: [https://www.edgexfoundry.org/blog/2018/02/27/edgex-getting-skinny-fast-california-preview/](https://www.edgexfoundry.org/blog/2018/02/27/edgex-getting-skinny-fast-california-preview/)
Ah, got it. Thank you!
&gt; Pretty much every interface-based proposal that I've seen immediately expands generic-constraint interfaces to allow for multiple type variables that are substituted into the interface. I'd like to point out that this is not "special" - it's a natural consequence of allowing polymorphic types. The proposed syntax for polymorphic types is `type X(type T1, T2,…) &lt;typeliteral&gt;`. I think it's hard to make an argument that interfaces are - or should be - seen as a special kind of `&lt;typeliteral&gt;` here. &gt; The fundamental issue is that interfaces are about methods, but many type constraints are about types. FWIW, I've lately come to think of interfaces in terms of "Go's way to express subtype relationships" - so being primarily "about types" :) I'll hopefully be able to write that up more cleanly soon. But a lot of the design decisions of interfaces (being structural, instead of nominal, the fact that they can't express fields, their implementation as itabs, even type-assertions to a degree…) are sort of forced that way, to make a coherent subtype-implementation. Ultimately, though, this seems like a potayto-tomahto distinction to me :) I'm sorry for always using that example, but: Note that in Haskell, constraints are expressed via type-classes - which ultimately are mostly "parametric interfaces" and describing method-sets¹. &gt; However, a significant amount of what people want to do with generic functions is about the types themselves. I don't think this quite hits the nail on the head. What people want to do is write polymorphic code (i.e. share an implementation for many types). How that is achieved is mostly irrelevant to people. *Specifically*, that you need to be able to compare type-arguments to `Set(T)` is an implementation-detail of that particular implementation of `Set(T)` - because it's based on Go's built-in `map`, that requires comparisons. But as soon as you, for example, want to build a `Set(T)` that is *not* expressed on Go's built-in map, e.g. with more efficient allocation behavior or what-not, you'll run into a snag - because you need to hash the keys, and the *only* way to get that is via a method (you could say that internally, there is a "[hash-interface](https://github.com/golang/go/blob/b397248168fcb26400ac6afb88bf6080497a819e/src/runtime/alg.go#L42)" and a "[comparable](https://github.com/golang/go/blob/b397248168fcb26400ac6afb88bf6080497a819e/src/runtime/alg.go#L45)" interface used by `map` - but they are not exposed). If you look at how [C++ does hash sets](https://en.cppreference.com/w/cpp/container/unordered_map) or how [Haskell does hash sets](http://hackage.haskell.org/package/hashmap-1.3.3/docs/Data-HashSet.html#v:insert), they both do fundamentally the same thing as requiring the element-type to fulfill a certain inteface(/type-class). [Java's HashSets](https://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html) don't, but that's fundamentally similar as with Go - in that [java.lang.Object](https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()) comes with a `hashCode()` method that custom hash map implementations can use. So IMO `Set(T)` (or rather `HashSet(T)`) is a bad example for your point, because it's actually *impossible* to implement in Go, without relying on methods - you can only wrap the existing implementation Go ships with. Because ultimately, `==` *isn't* what's needed to implement a hash set, you need a way to hash. --- [1] there is one major difference between type-classes and conjectured parametric interfaces in Go, which is that methods in Go won't be able to have type-parameters themselves (so it won't be possible to implement e.g. `Monad` in Go). This is due to Go having type-assertions². But for the sake of this argument, they are mostly equivalent. [2] Which, FWIW, is another way in which interfaces are interesting to think of as "primarily about subtyping", because it means in Go, [subtype-monomorphisms are split](https://en.wikipedia.org/wiki/Morphism#Monomorphisms_and_epimorphisms) 🤯 I know, I have a weird notion of "interesting" ;)
 &gt;I understand that the src folder is where the source code is kept, but why would I need a bin folder for binaries and a pkg folder? &gt; You don't need a specific src, bin, or pkg folder. "src" was the root directory under the GOPATH if you were using a GOPATH. But it's no longer required because of module support. All you need to know is that it is one "package" namespace per directory. That means 1 or more files in the same directory with the same "package" identifier at the top. &gt;I'm also having issues understanding why the GitHub project repos URLs are often used/shown in the project, I understand in terms of the external library imports from GitHub, but I'm talking about the GitHub repo URLs referenced to your projects. What if they are private? GitHub urls are one of the scm sources that the Go tool knows how to download from. There is nothing inherently special about them outside of that. But it is a convention that helps prevent namespace collisions between two packages called "foo", from two different authors. &gt; &gt;I have issues with GOROOT, GOPATH, and GOBIN. I'm currently using MacOS Mojave. &gt; Have you tried not setting any of that and simply building a hello world single file program? How far do you get? 
Just leave those environmental settings alone, you don't need the knowledge of the inner plumbing to get started. If you run into an error installing or running go, request help with that specific error. pkg, src, and bin are also not needed in your project structure, so you can ignore these for now. Go uses URLs for package import path. This lets anyone release packages without an central repository. There are several ways Go can get the source code from that path, for example, you can put your libraries in the vendor directory with your main application code.
It's *an* argument. Not *the* argument.
net/mail is only useful for reading the header, for the body, and in your case, u will need mime/multipart message body is an io.Reader so you can do reading in anyway you like. Best to wrap in it multipart.Reader for less fiction parsing the parts. I’ve done a write-up kinda related to your problem: https://medium.com/@owlwalks/dont-parse-everything-from-client-multipart-post-golang-9280d23cd4ad
This highlight a meta point I like to make about generics, one that I typically am not liked for: Generics introduce more complexity than what it's worth. Ignore for a second the arguments themselves, and just look at how hard it is to find a consensus AND how people can't agree on much when it comes to generics. I feel generics more often than not exists so people can apply mathematical models, or show off how clever they can make code. It more often than not makes it harder to reason about the code, it requires every single person developing or reading the code to learn more complex abstractions or suffer the consequences. TL;DR I've never seen generics make a language neither easier nor better.
https://github.com/Bogdanp/awesome-advent-of-code There is a list of Go repos to follow. Here is mine (feedback welcome): https://github.com/kindermoumoute/adventofcode 
Yeah, none of my usuals were available 😆
&gt;Have you tried not setting any of that and simply building a hello world single file program? How far do you get? I got as far as getting the hello world file to work; however, issues arise when i try to build/install the project.
You're right I got that backwards. The point stands though. 
I find that using `map[int]bool` is nicer to use because you can do this: ``` if frequencies[freq] { ... } ``` It works because both doesn't exist and false values return the same.
https://en.wikipedia.org/wiki/Jevons_paradox
I write embedded firmware in C every day. Literally insanity.
With time, you can get `1000 * 60 * 60 * 3` or `10_800_000`. Not that necessary in go, but helpful in other languages. The same idea oftentimes works on other numbers.
I use atom with go-plus plugin.
I don't know if I agree with that particular example, considering the different levels of flexibility.
It is a trade off. They opted for beginner friendliness and that's why they didn't include generics because they thought it was to complicated. I would never hire a person who didn't know what generics were or thought it was a complicated topic. 
[removed]
It's a step backwards because it doesn't support generics and poor support for functional programming. All the modern languages are looking at the good parts of functional programming . Go is marginally faster than Java in some benchmarks and worse in others https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go.html . So performance is not a valid argument. 
The nicest way to get started with 1.11.0 + is to use [go modules](https://github.com/golang/go/wiki/Modules). Outside your GOPATH (you don't even need to set it): mkdir ~/project &amp;&amp; cd $_ # or where ever you want to place it go mod init github.com/user/project # or the import URL for this project # write a simple go program go build GOPATH was the older way of working but is no longer required if you want to use go modules and is a nicer way to use go imo.
It would be great if you could provide specifics about the problem? Given a random directory and a single "main" go file, I would expect it to build and run without any other configuration. 
The setup is simple use GOPATH, for ex ~/go Inside go you have src, bin, etc. What matters is the src dir. In src dir when `go get` a package it is downloaded in src/github.com/user/package Src is one of the path go tool checks. You can even simplify stuff using vendor dir, but that is for level 2. :) If you want to make a tool and store the code in gitlab.com for example, make a path in src gitlab.com/you/myawsomegoproject/main.go in wich you start to code, import packages... Bla Bla. When you have ext dependencies GOPATH is important. I did not have a look into modules but from what I understood they started this way because of the hard to understand GOPATH structure, which is pretty simple. 
Everything works well, but when I build the project, the binary is created in the same directory as the main file when it’s supposed to be created in the bin dir. the issue here is that I setup gobin to the directory I want the binaries to be generated in. 
Oh okay I’ll see if this works. I don’t need any extra setup for building binaries right?
If you used the "go build" command, the default output directory will be the current directory. You can control this with "go build - o /path/to/program". If you use "go install" then it will consult your GOBIN before a default install path, which is $GOPATH/bin
Apart from installing go, no extra steps should be required.
Thanks so much !
Did the same and it is worth mentioning, that \`strconv.Atoi\` recognises plus and minus signs, so the \`strings.HasPrefix\` and \`strings.TrimPrefix\` are unnecessary.
My solutions can be found at [https://github.com/bjorngylling/advent-of-code-2018](https://github.com/bjorngylling/advent-of-code-2018). Fairly in-experienced at Go but it is very enjoyable!
Hey guys, just wanted to share this. Although, you are not PHP Developers :P Anyways, I also have a problem when running in the Docker container, if you can help. It seems this keeps failing: [https://github.com/zikani03/compozipd/blob/master/compozipd.go#L80-L90](https://github.com/zikani03/compozipd/blob/master/compozipd.go#L80-L90) Thanks!
Dunno if it's just me but all the other ones just feel so overengineered [Here's mine](https://github.com/seankhliao/adventofcode2018)
It's definitely pretty hard to learn, but the memory management is certainly nicer than C and whatever.
I’m also a beginner and this makes hardly any sense. 
Here's my solutions: https://github.com/drakmaniso/adventofcode (contains also some rust files, as I'm currently learning it)
eg: https://github.com/metrosystems-cpe/GopherLab/blob/master/url-shortener/main.go ``` "github.com/metrosystems-cpe/GopherLab/url-shortener/storage" "github.com/metrosystems-cpe/GopherLab/url-shortener/utils" ``` when you use package imports and this code is not in `$GOPATH/src/github.com/metrosystems-cpe/GopherLab/url-shortener/` code won't work it is simple why GOPATH is important, because go tool search for packages inside it. 
I just put my code somewhere but then If I install it Go puts it somewhere else?
What is the benefit compared to phar-composer?
At most you may need to download the plug in and put it in the sublime plug in folder. The section under manual install here https://packagecontrol.io/installation is simar, and actually you might consider just installing that package to manage things as I believe it includes go sublime you're referencing.
Would be nice to get the vendor folder via composer.lock, that way versions are actually fixed.
maybe [https://github.com/lukehoban/go-outline](https://github.com/lukehoban/go-outline) is what you are looking for
I actually started to use glide, and I am very satisfied. It uses yml instead of json which is a bless to me, fuck brackets and commas. Besides of this it comes with a lock file as well. Its doesn't provide you with a zipped vendor folder but in my opinion its is bad practice to copy the actual dependencies around anyway. Instead, one should read a lock file and install them. So I don't see the need for a zipped vendor.
I recommend using a vendor folder. Some tools which are helpful with this might be glide, godep and govendor. I use glide and its a blast :) Their documentation is good enough [https://github.com/Masterminds/glide](https://github.com/Masterminds/glide)
Hey, thanks for asking. I hadn't seen phar-composer before this comment. It is quite different in the sense that the aim of this is just to zip up the vendor directory and not produce an executable phar. The other difference is that this (the server side, anyways) is intended to run on another host. See more info at the bottom of the README. With that said, I will probably add the ability to generate a phar via \`phar-composer\` :) 
Good point! Will look into it. Thanks. 
Well actually, on some systems like mine( Manjaro), GOBIN is not added to the path by default. So I had to add it manually in order to use binary from the $GOPATH/src/bin folder.
Read this: https://golang.org/doc/code.html
be careful with libraries - Go isn't like Python, and a lot of the libaries available add very little to what you can do with the standard library. The rule in Python is "someone has written the thing you need, so don't re-invent the wheel", but in Go it's "you can probably get 90% of what you want from the standard library, so only import a dependency if you really need it"
My point is that with go modules you no longer need special set up such as GOPATH or checking out your project is a very specific location in order to work with the language at all. And can instead treat it more like basically every other language out there in terms of environment outside the repo - install the tools and checkout the project anywhere you like. Setting PATH is an optional extra set that adds convenience and nothing more. It is not required to build go binaries or run unit test or even install third party tools. It only makes it more cont to run said tools. So while useful and suggested it is not a requirement and you can start development now and worry about it later when you require it.
Hey /u/littlebluebrown, probably this wouldn't appeal to you - it's a tool written in Go but it's targeted at those working with PHP and Composer. I haven't tried Glide myself after getting too comfortable with Dep and now, Go modules (used in this project) - but glad to hear you escaped the braces and commas :) 
Good point, only planning to use gqlgen as a library 
Java runs on the JVM, but the JIT compiler optimizes the code at runtime.
I think of GOPATH as my workspace and dependencies folder combined. So all my projects/dependencies are almost always in `$GOPATH/src/site/username/project`. Public/private doesn't matter so long as the project/dependency can be fetched via HTTP. It serves me well so far since I either use github.com or gitlab.com for storing my projects. However, you won't even need to follow the `site/username/project` structure. If I don't want to put my project in the internet, I can put it in `$GOPATH/src/project`. Other projects can then reference it with `import "project"`. The only important part here is that the project/dependency is in $GOPATH/src. Regarding the folders under $GOPATH: * `src` is where the project/dependency lives * `bin` is where `go install &lt;package&gt;` goes if the package has `package main` declaration. * `pkg` is where `go install &lt;package&gt;` goes if the package doesn't have `package main` declaration. Note that go install is different than go build. Go install puts the resulting artifacts in `$GOPATH/bin` or `$GOPATH/pkg`. Go build puts the resulting binary in the same folder as where you run the command if executed without -o flag (non-binary package will just be discarded iirc). 
In general yes, except when the open source project is randomly pulled off the internet (super rare, but plausible)
the reflect thing is so true. Touching the reflect package is best done only after considerable thought and sleep, and only if there is no alternative. Messing around with the type system is always bad.
can you name one?
I'm trying it this year. Started with JavaScript but I plan to use whatever language I feel fits the problem. [You can find the code on GitHub.](https://github.com/kevingimbel/advent-of-code-2018)
Hey @mrzon05, I've been working so hard to improve the performance last weeks, Here you could find the benchmark report [https://github.com/wesovilabs/koazee/wiki/Benchmark-Report](https://github.com/wesovilabs/koazee/wiki/Benchmark-Report) &amp;#x200B; And I also wrote an article to share with othes, some tips that I 've learnt during these weeks. [https://www.linkedin.com/pulse/go-performance-tips-iv%C3%A1n-corrales-solera/](https://www.linkedin.com/pulse/go-performance-tips-iv%C3%A1n-corrales-solera/) &amp;#x200B; I hope to release v0.0.2 Gelada (that includes several changes) soon. 
Didn't realize it recognized the + sign. Though now that you say it it makes a lot of sense, it has to recognize the - sign for the conversion to work. Nice.
Go has great support for this, built into standard library , very similar to jinja. Lookup go templates - https://golang.org/pkg/text/template/
Yeah, I lean towards using struct{} just because the value doesn't matter at all, just the existence of the key. It's a pretty common strategy that's used for limiting goroutines (write a struct{} to a buffered channel, another goroutine must wait until the other one is freed up). If the challenge had asked for a distribution of the letter counts, I probably would have left it as an int.
Your solution to day 1 is brilliantly simple. Nice work. 
As of 1.11 of Go, ‘go modules’ is the native dependency management system. https://github.com/golang/go/wiki/Modules Other alternatives like ‘dep’ use vendoring (go modules does as well). https://golang.org/cmd/go/#hdr-Vendor_Directories If you are just starting to use Go, I suggest just jumping into Modules. 
I'm also doing it in go this year, [let's save Christmas](https://github.com/kris-s/learn/blob/master/advent%20of%20code/2018.go?ts=4).
Is it safe to use modules yet, though? It's still 'beta', I think.
To answer your question about private repos: if you can access your private repo via `git`, then so can Go. And just to fill in the picture a bit from what @mdaffin said above, when using [go modules](https://github.com/golang/go/wiki/Modules) you no longer need to worry about a GOPATH, but there is still a [default GOPATH](https://rakyll.org/default-gopath/) that Go will use for various purposes. For example, third-party code is automatically [installed](https://golang.org/cmd/go/#hdr-Download_and_install_packages_and_dependencies) during a `go get`, and any binaries that result from that install end up in `GOPATH/bin`. For that reason, is is often useful to add `$GOPATH/bin` to your `PATH`.
I’ve been using modules for several small projects. It works fine. They are saying it’s in beta because if someone external brings up an issue they want to be able to potential change implementation.
It is experimental, so you'll need to decide what amount of risk is acceptable to you, but as a single data point, I've been using it on production code for more than a month now, and I haven't regretted it.
Wait what is `Abbreviate` even? What prefixes go `"k", "M", "B", "T", "q", "Q", "s", "S"`? https://godoc.org/github.com/dustin/go-humanize#ComputeSI is what most people would expect.
[removed]
Nice read. TLDR is that a goroutine that both reads from and writes to a single channel (why?) deadlocked itself and, as a side effect, all other writers.
Ahh yeah that's probably the biggest factor for me. Thanks!
You didn't initialise zero frequency as a first value in your map in Day 1, Part 2. It has no impact on the solution, but your solution fail with presented tests (see seankhliao solution).
I, too will try to keep up each day with some idiomatic [solutions](https://github.com/tpaschalis/Golang-practice/tree/master/AdventOfCode2018). I'm coming from Python, so any advice or feedback is welcome :)
Benchmarks don't tell very honest stories in my experience, so I tend to ignore them mostly. At my last company though we saw big resource usage improvements in real world applications across the board when we started using Go. (this wasn't why we started using it though) You can put some of that down to better structured code or whatever, but it was consistent and across all kinds of apps. I suspect (but never proved) the problem a lot of the time for java is the resource usage of the most commonly used libraries and frameworks that people use. Anyway, better resource usage (not always better performance, often massively reduced memory use) as well as improved productivity in the development cycle led us to start more aggressively moving to Go and we didn't look back. &amp;#x200B; As for generics, I started in the "give me generics in Go now!" camp, but I've slowly moved to indifferent. I can still see the value of course, having lived with generics in Java for years, but I also don't see the problems come up in Go that Java had before generics, and genetics didn't add that much relative complexity to Java, but in Go it will do.
It abbreviates a number... (ie, 1000 to 1k, 1500 to 1.5k). They're similar in nature, but his is based sound converting bytes to human understandable text, (ie. Humanize), mine has nothing to do with bytes. It's just numbers. I do have an ordinal function that overlaps, but that was taken from an older repository I had and kept for sanity.
I've never seen anybody want to do the later, so cool strawman. Also the former should almost certainly be using a `time.Duration` like `time.Hour * 3`.
I agree that generics is not a complicated topic. But as with every other feature that Go doesn't have it's infinitely harder to understand than not having the feature at all. Whether something is complicated or not, is no basis for it's inclusion in a language or not. It needs to be clear that the cost of the added complexity (however big or small) is outweighed be a greater value that it adds. &amp;#x200B; (BTW I've hired plenty of people without even talking about generics at all. I've also hired people that I know strongly want generics added to Go and others who strongly don't.)
Nice and clean work, indeed.
I really love sublime, but use VS Code for GO. Especially when it comes to debugging VSC is the best choice.
if your frontend is going to be react, gorilla session is fine and I personally wouldn't use JWT for anything unless you really know the drawbacks and are ok with them. The biggest issue, for me, with JWT is that you cannot easily "invalidate" the token, unlike a session stored in your database.
Amazing. I just read your writing and learn a lot too. Benchmarking indeed taught us many things about how to better code the implementation. You deserve a follow too in LinkedIn and Github. Hope the best for your career.
&gt; I always use sort.Interface as an example here as it is a truly all-encompassing solution. Ah, that thing which forces you to define three methods where only one is comparator and two others are trivial to write. And worked so badly on slices that developers made a new reflection API in order to swap elements of slice directly. I agree, it's a masterpiece.
[removed]
[removed]
To further answer your question, http://crusaders-of-the-lost-idols.wikia.com/wiki/Large_Number_Abbreviations - Sorry, was waking up when I replied previously and forgot to add this.
[removed]
### Blocking on a channel A goroutine which gets blocked on a channel is suspended by the scheduler and "remembered" by the runtime as waiting on that channel. The "process"—a thing running goroutines on OS threads, called by the runtime and the docs as `P`—then picks another goroutine to execute. When the channel gets ready, depending on whether it has a value available for reception or was closed, the runtime either wakes up a randomly chosed goroutine among those waiting, or all of them—in the latter case. "Waking up" means attempting to make that goroutine run again. This is a relatively involved process: 1. The runtime tries to make that goroutine be executed by the same `P` which was running it before it got suspended. This only happens if the program was so idle the goroutine got woken up before that `P` was assigned another goroutine to run. 1. Failing that, the runtime tries to obtain an idling `P` and queue the goroutine to run on it. Since that `P` is idling, the goroutine starts running. 1. Failing that, the runtime puts the goroutine on the global queue. As part of the scheduling process, each active `P` (there is `GOMAXPROCS` of them) tries to get a goroutine from its local queue, but it also checks the global one from time to time (and steals half of the queue from another `P` if the global queue is empty). ### Handling a syscall When a gorotuine enters the syscall, the following happens: 1. The special runtime thread called `procmon` notices that fact and starts a timer which currently is 20 µs. Once that time passes without the goroutine having had returned from the systcall, `procmon` tells the runtime to relinquish the `P` from below that goroutine. 1. The runtime then looks into the pool of the OS threads it has at hand; if there is an idling thread—that is, a thread without any `P` working on it—that `P` is assigned that thread and it resumes its usual routine: pick a runnable goroutine, run it and so on. 1. If there is no idling OS thread in the pool, the runtime asks the OS to creat another one and then behaves identically to the previous step. When the goroutine returns from the syscall it were executing, the runtime behaves almost identically to the case of a channel, with an extra first step: the goroutine is first tried to resume working on the same `P` which it "was on" when it entered the syscall. If it spent less than that "`procmon` quantum` in the syscall, this succeeds; if its `P` got relinquished and retargeted, the usual routine explained above happens. A corollary to this, is that goroutines "waiting for too long" in the syscalls they execute may result in the growth of the amount of OS threads the runtime creates. This is sort of normal—the number of such "extra threads" ("extra" in the sense of not occupied by running those `GOMAXPROCS` `P`s and powering the needs of the runtime itself)—will be just enough to support whatever the number of "long" syscalls is performed in parallel. Still, a problem may occur since those threads IMO are not returned to the OS; so if one experience a problem of proliferation of such extra threads, performing such syscalls should be reworked using the usual approach—a pool of workers. ---- Also note that performing a syscall has other extra costs compared to blocking on a channel: - Before a syscall is made, the runtime has to switch the stack from that of the goroutine to the one provided by the OS. - A syscall means trapping into the kernel, and then back. Also note that performing a `cgo` call is also a costly operation as it involves most of the same work needed for a syscall except for actually reaching for the kernel. Hope this helps.
[removed]
Go is also relatively young still, and is already in process to add generics, among other good things. I suspect given its already good coding dynamics that most report (in terms of improvement getting more done faster with less/cleaner code), its "mostly" improved performance metrics, ease of learning/integrating into a team, and with up coming changes, it will continue its growing momentum while other languages will see a down tick. Not saying it will lapse others, but I would see it catching up in popularity and a lot more jobs opening up because of it. 
(post author here) I can't fully answer the "why" question. My best guess was that the original piece of code is a huge legacy that "just worked" back then. It's hard to predict what will happen to the company's experiments in the next 5 years.
What are the use cases for this?
what u/kostix said. This talk by Kavya Joshi is also really good; https://www.youtube.com/watch?v=YHRO5WQGh0k
When I clicked the "Why aah?" link I was hoping it would be a description of why someone thought that was a good name for a project. I'm disappointed.
Thank you for your kind words!
This is exactly what I have been thinking would be the best way to handle generics. Glad i am not alone in this. The complicated contracts based generics don't seem as idiomatic as this. :)
[removed]
I got the original question while watching this video only! Her talk is really amazing and pretty simple to understand. Only this particular point was unclear to me.
Wonderfully explained! Thanks a lot.
This is one of the stupidest comments I’ve ever read.
It's somewhat incomplete, but would likely cover the use case you describe: https://github.com/Fanatics/toast Take a look at the example plugins for an idea of how to work with the simplified AST You could also explore the stdlib's go/token and go/ast packages (which is what toast uses &amp; tried to abstract). 
IIRC generics tend to be useful to library writers and misused by everyone else. 
[What you just said...](https://youtu.be/YpuRcmPnSTM)
I was about to start looking into existing event-driven systems for an upcoming project, so this sounds neat. Although while looking through the site, it seems like activities must be written in Go in order to be exposed as an input/output zero-code option. It would be really flexible if the activity/action (not sure of the difference yet) could be implemented like a generic FaaS system. This would allow different languages to supply the processing logic instead of just a Go+json solution 
C# List&lt;T&gt; , Dictionary&lt;T,H&gt;, etc. Generic collections are the most useful classes ever, you'd have to be an idiot not to see the immediate benefit of them, as well as brain dead to not see how easy they are to work with. 
just need the title to contain a handful of stupid emojis and that would top it off
Yeah, we are not too worried about Golang being the only language for input/output but more about the general stability and usage of it and if anybody has actually used flogo in production environment. What kinds of application have been developed with it and what has been the experience etc?
I'm not sure whether people like you realize that you are most likely consuming generic types all the time. Either that, or you find types like maps and slices complex to use. People cannot find consensus on how to restrict generic types, but that should not be of concern to you, since you only consume then, you are not defining then in the first place. You will most likely never run into this complexity
I’m not the creator. Just sharing a curated post (not yet shared on Reddit) of this [Golang Ninjas issue #31](https://www.getrevue.co/profile/golang-jexia/issues/go-2-continued-producer-consumer-concurrency-golang-emulators-more-146939) 
Man a List&lt;T&gt;. Nope, don't know what the fuck to do with that. No clue, i'll just learn Go like a smart programmer.
&gt;But as with every other feature that Go doesn't have it's infinitely harder to understand than not having the feature at all. So you're saying learning something is infinitely harder than not? NO WAY! That's why I refuse to open my eyes or wipe my ass, because doing so would be infinitely harder than not.
I named mine Advent of Go. You can check it out here: https://github.com/nerg4l/advent-of-go-2018
First download the package by running this in command-line: `go get github.com/PuerkitoBio/goquery` Then try to use `goquery` and VSCode should import it automatically for you: func main() { // ... doc, err := goquery.NewDocumentFromReader(res.Body) }
A golang playground example would be very helpful to assist you. That said, I would caution on reading your input file all into memory( ioutil.ReadFile() ). You should probably use io.Copy() between the file reader and its writer in the tarball. A good guide to understand how to use tar in Go that I recommend: https://link.medium.com/NYQES3FxkS 
&gt; go get -u github.com/PuerkitoBio/goquery Thanks - can't vscode do this automatically? I thought that's the point of an IDE! 
It's hard to say without more information (e.g. the full code) but are you ever calling `Close()`? It looks [from the docs](https://golang.org/pkg/archive/tar/#Writer.Close) as though calling `Close()` will call `Flush()` to write the correct padding for the current block to be full. Perhaps this is not happening in your case and makes it seem like some data is missing when reading back.
You might want to call FileInfoHeader() and then just change the fields you need changed. Alternatively, you might find this higher-level archiver package I wrote helpful: https://godoc.org/github.com/mholt/archiver#Tar
You're ignoring the number of bytes written, which is likely telling - at a guess, you may need a for loop to write to the tar until you exhaust the source buffer (I'd guess it writes in chunks). Or just use os.Stat and io.Copy to determine the source size, and perform the reads/writes, respectively.
(_original code author here_) In the initial implementation of that metrics code did not have the `SetM` call inside of `sendMetricsToOutChannel`. The channel capacity has always been set to a kinda random big value of one million. I was curious whether that value was big enough in practice, so decided to add the internal metrics `raw_channel` and `metric_channel` so I can monitor the utilisation. I just checked some old metrics, so the numbers were usually below 20k, so everything looked fine. I never added alerts on these metrics and pretty much forgot about them until we ran into this issue recently. It's almost funny how this bug was introduced by trying to add observability. It just didn't occur to me back then that adding these metrics in that place (inside of consuming those metrics) enables this deadlock. Luckily u/varankinv already had a fixed version prepared when it hit us, so we could side step it quickly. (Thanks for the fix and the nice article about it!)
Yeah, optimises for performance, not memory usage. Al lot of the memory issues in the JVM come from those optimisations.
Nope, that's the job of a package manager.
I do after I'm finished with the tar writer.
It could. Atm that add import feature only lists what's already on your system. Perhaps you might want to suggest that extra functionality here: https://github.com/Microsoft/vscode-go/issues
&gt; You might want to call FileInfoHeader() and then just change the fields you need changed. Doesn't help.
 b, err := ioutil.ReadFile(path) Doesn't buffer. It reads everything in one shot.
No one will be able to help more unless you can post a runnable, reproducible example, like on the Go Playground.
He's talking about your Write, not ReadFile. You only call Write once and don't ever know how many bytes it wrote.
Full code or it didn't happen
&amp;#x200B; Super cool
[removed]
Here's mine! https://github.com/fharding1/adventofcode-2018
Here is an demo of how to do what I think you are attempting to accomplish. [https://play.golang.org/p/MUZ2am8Wrm6](https://play.golang.org/p/MUZ2am8Wrm6) &amp;#x200B; I would recommend reading the blog i mentioned before as it's a good read to give you the basics. And in the future, try to create a Go Playground example that shows the issue you are experiencing, or provide a more complete code snippet, so that people can help easier, rather than guessing at potential pitfalls you may have jumped into.
Not related to the problem regarding the bytes written, but you want to set values for the timestamps in the header fields. Some versions of tar will be okay with 0 time values but some won’t, always best to use a real value or the current system time. Is there anything happening the slice before you write it, the logic looks right. If the byte slice is large you may need to perform multiple writes, check return value or .Write().
A slice is a pointer, a length, and a capacity. You can slice to modify length to any value between [0,capacity]. https://blog.golang.org/go-slices-usage-and-internals
Nice. Good boilerplate. 
have you considered just using /u/mholt's [https://github.com/mholt/archiver](https://github.com/mholt/archiver) package, which can take care of all your archiving needs
[removed]
[removed]
Oh, wait, this means there's a complete OS in Go capable of running Nintendo DS games? Does it use hardware acceleration?
I thought Go allocated far fewer objects by the nature of how it's written. Is that not so? Also, regarding databases, you mean native Go right? 
I guess i ll have to do this if I want to stick to free editors. I was avoiding VSC because i feel its slower than Sublime.
going ahead with VSC. thanks.
I did.
I wasnt able to figure out how to install it. I am still interested in configuring this.
okay. I am not sure about this but Intellij has stopped the plugin for Go and have started shipping a whole new editor for that, Goland.
The instructions are clearly mentioned. What is it _exactly_ that you are not able to figure out ?
RemindMe!
**Defaulted to one day.** I will be messaging you on [**2018-12-04 04:03:28 UTC**](http://www.wolframalpha.com/input/?i=2018-12-04 04:03:28 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/a2hiu5/emulating_a_nintendo_ds_in_go_video/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/a2hiu5/emulating_a_nintendo_ds_in_go_video/]%0A%0ARemindMe! ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Nice, thank you - didn't know there was a let's encrypt autocert package
[This](https://margo.sh/b/hello-margo/) is the first link there. Under \`Configuring margo/GoSublime\` they instruct that i need to edit this package \`$SublimeTextPackages/User/GoSublime/src/margo\`. I do not have this package. From where do i install it? So i scroll down and find \`Installing margo/GoSublime\` and this sends me back to where I came from. Am i missing something?
Advance to 7 minutes if the link didn't so already for you.
&gt; that thing which forces you to define three methods That's what interfaces do, yes. &gt; where only one is comparator You'd like there to be more of them? &gt; and two others are trivial to write. For contiguous data, sure. The reason they're there is to allow arbitrary structures. I'd love to see a "generic" solution that could take linked lists or heaps. &gt; And worked so badly on slices that developers made a new reflection API in order to swap elements of slice directly. This interests me. Got a link?
I'm solving this year's advent in Go so if anyone wants to check my solutions :) [https://github.com/dandua98/AdventOfCode2018](https://github.com/dandua98/AdventOfCode2018)
I'm solving this year's advent in Go so if anyone wants to check my solutions :) [https://github.com/dandua98/AdventOfCode2018](https://github.com/dandua98/AdventOfCode2018)
[Disclaimer: I work at TIBCO on Flogo] You’re correct in looking at Flogo as a functional superset of Nifi. Project Flogo is an *ecosystem* of sub-projects that use a core event-driven framework. Flogo’s sub-projects include: - Flow action for integration (closest to Nifi or Mule) - Microgateway action - Stream Processing action - Contextual inferencing &amp; rules engine action All of these sub-projects share the same extensions model. There are over 500 activities and trigger extensions at last count ranging from HTTP, Kafka, MQTT to various DBs &amp; cloud services. Flogo apps can be deployed on IoT edge devices, serverless edge like AWS Lambda, on PaaS like K8S as microservices or as plain ol’ binaries. Who uses Flogo? Lot of people just use the core open source project - so I am not aware of an exhaustive list. However TIBCO itself has commercial offerings around Flogo OSS that have dozens of large and medium size customers: - Jabil - one of the largest contract device manufacturers in smart devices - Hitachi Hightech in their various industrial IoT offerings - A leading container shipping line for track and trace and logistics - A leading freight logistics provider for Machine Learning and biz rules inferencing - Large sports and fashion manufacturer for microservices Flogo apps are also used by hundreds of customers for TIBCO’s iPaaS offering for various integration dev usecases. Think salesforce to marketo or SAP integration. If you have further questions you may wanna ask on the Gitter channel: https://gitter.im/project-flogo/Lobby
&gt; See /b/hello-margo for a short introduction to margo It is just that - an introduction to margo. It does not have the install steps. Just follow the instructions from - &gt; These instructions assume that you're inside the Sublime Text Packages directory.
[database/sql](https://golang.org/pkg/database/sql/) is the standard library, cross-database SQL interface. It'll talk to most SQL databases with the right driver, and [lib/pq](https://github.com/lib/pq) is one driver for it (it's not, despite the github repo name, a "standard library" driver of any sort, just a third-party driver, though a perfectly good one). If you want to write cross-database SQL, database/sql is the way to go. [sqlx](https://godoc.org/github.com/jmoiron/sqlx) is a helper package that sits on top of database/sql and adds additional helpers, to help with binding results to Go structures and suchlike. It adds convenience for typical app usage of the database, at the cost of adding some magic. [dat](https://godoc.org/github.com/mgutz/dat) is a query builder that lets you access the database without writing SQL, rather you write your queries in an ad-hoc DSL built up of Go calls. If you like that sort of thing, dat is perfectly good, but for most applications SQL builders are an abomination, mostly aimed at people who can't write SQL. If you want something like that you should probably look at full on object relational mappers like [gorm](https://gorm.io). If you're targeting only PostgreSQL, and you're planning on actually using the database as something more than a dumb key-value store I'd look hard at [jackc/pgx](https://godoc.org/github.com/jackc/pgx). It's a very solid PostgreSQL access library, with good support for all of PostgreSQL's features and data types. While you'd usually use it standalone it can also be used as a driver for database/sql. Depending on what you're doing, layering some sort of marshaling / unmarshaling code on top of that can reduce the amount of boring code you need to write. Consider something that does that, perhaps via code generation, such as sqlboiler, xo, gnorm, ... 
No it’s 100% software based. PS: I’m the author
The underlying array of the slice is living in the heap. As long as there are pointers to it will stay around. If you use the ternary slice operator like `s[0:0:0]`, enlarging it would not be possible. 
The compiler keeps track of the underlying type of the generic argument eg. it is GenericMap&lt;int&gt; GenericMap&lt;string&gt; etc When you call Set, the compiler throws an error if the value cannot be assigned to a map of type X where X is the GenericMap's underlying map type (kept track of by the compiler). This is how it enforces 'value' to be of the same type as 'T'. Under the hood, the identifier 'generic' is simply swapped out for whatever the actual type of the argument is. Unlike an interface, It is not possible to have a generic variable, map, slice or struct so the compiler always knows the underlying type of a generic argument.
Yes, but on the other hand explicit contracts are ugly and clutter up the language. See Java, C#, C++ for more language clutter. Fortunately Go now has [modules](https://github.com/golang/go/wiki/Modules) (they are great for keeping contracts). Alternatively, there could be a go flag that creates a trace letting you know why your argument(s) cannot be passed to the generic function(s).
I would still need to own the domain that i give to autocert to get https right? 
Lol instead of Rust programming language he used logo of Rust game, hahah, obviously he didn't care too much
Contribute to something you're interested in. It can be hard to identify what that thing is, but it's the best way. Picking through issues that you don't really care about and that somebody else came up with is boring and you probably won't do a very good job of it.
I've updated the post based on your advice, thanks!
Yep, normally autocert works by spinning up a temporary http server for tge letsencrypt servers to verify the domain ownership
It would depend on where lie your interests and your experience. Personally I would check out [nanopack.io](http://nanopack.io/)
Can you post your full code?
Loading it first time: [https://github.com/ndabAP/sheetstats/blob/master/cmd/sheetstatssrv/main.go#L15-L19](https://github.com/ndabAP/sheetstats/blob/master/cmd/sheetstatssrv/main.go#L15-L19) Loading it the 2nd time: [https://github.com/ndabAP/sheetstats/blob/master/internal/oauth/auth.go#L21-L23](https://github.com/ndabAP/sheetstats/blob/master/internal/oauth/auth.go#L21-L23) &amp;#x200B;
Generic with two generic types result in a shape of A&lt;B,C&gt; that means B and C are both types that remain constant in further use. However they don't need to be of the same type. They should guarantee type consistency limited to just being B or C, not type consistency between them.
That was probably deliberate. 
I mean kinda. Not sure about this package, but using the http challenge method of authentication with Letsencrypt, you'd need to be serving a page on the subdomain you're getting the cert for. So even if you don't own the domain, if you're in control of the server that the subdomain points to you can still get a cert. Make sense?
Which doesn't require you to own or control the domain, only to have the IP address associated with the subdomain you're interested in routed to your app.
ye ye i noticed, but also he crossed the made up languages, maybe this was easter egg, most of the people wouldn't even recognize
Do you have any examples of a simple API pulling from a `database/sql` database in a semi-optimized manner? That is, preferably using joins and only selecting the desired fields. If not, could you talk a bit about how one would go about building that?
I like https://gitea.io/en-us/ as a tool and try to contribute to.
Makes sense, thanks :) 
Sounds defintly interesting. Thank you :)
I think it's because of the order of imports. See this answer and the diagram: [https://stackoverflow.com/a/49831018](https://stackoverflow.com/a/49831018) &amp;#x200B;
In your "race" example, every interation starts two new timers. This means that 1 second will always beat 5 seconds and your t2 will always fire first. The 5 second timer is not cumulative like you probably expected. In your "hardStop" example you have switched the 5 second timer to be a single instance. Once 5 seconds elapses, the timer will end up being ready before your 1 second timer that is created on each interation. So it sounds like you want the single 5 second timer as a way to give your 1 second jobs a total run time. 
Since Ethr is capitalized, building the repo will produce a binary named Ethr The README on the other hand talks about a binary named ethr (and nothing about how to install it either which is just a `go get`) Rooky mistake
This is absolutely correct, though it should probably also be noted for completeness that `select` will choose a random candidate if multiple candidates are ready at the same time (ie - ordering in a select statement has no meaning).
Yeah, that's right
sounds like a good opportunity to make a contribution
Java has escape analysis. If you are very good at it, you can force it to give you performance like Go (with GC tweaks). This doesn't sound like an appealing use of developer time, but sometimes better to optimize what you have rather than rewrite everything from scratch.
Looks like the server breaks after a few tests: - started the server with `ethr -s -ui` on latest archlinux, client is on win10 - `ethr -c 192.168.1.3 -t b -n 0` - everyting ok - `ethr -c 192.168.1.3 -t c -n 0` - a bit flaky, sometimes it reports 0 conn/s - `ethr -c 192.168.1.3 -t l -n 0` - doesn't work at all after restarting the server, it works for some tests again
Actually I would love it if it went unfixed :)
I didn't know there were so many Postgres drivers! Looking at pgx docs I've found a third one called pg. I'll do some research about these 3 drivers (pg, pq, pgx) and decide which one is the most suitable for me. You definitely helped me figuring out that database/sql and dat are not adequate for this project. Oh and I'll also take a look at code-generation and run time reflection. Thanks!
Yes, thanks, figured that out. It is creating a new timer. So the 5 second timer time.After is being discarded at every new select run and it's writing or even not writing it's channel output and might be garbage collected. &amp;#x200B; the noRace part is running fine because after 5 seconds, the channel is holding the output of the tick and as soon as the select runs, the second case will create a new timer and wait for 1 sec but the Timer is already ready with it's output which select accepts and executes that case. &amp;#x200B; PS: I tested with 2 time.Afters with delays of 1000microseconds and (1000 + delta) microseconds. there are cases where the 1000+delta timer fires first, which means the golang overhead is eating up the synchronization and golang timers are losing resolution.
You are right. I solved it with the command mode: `$ godotenv -f .env go run cmd/sheetstatssrv/main.go`
Whats the problem with their license for commercial use? What is your preferred license?
They make it a bit confusing, but the specific setup I use is the IntelliJ Ultimate Edition with the Go plugin. As far as I can tell, it is still updated regularly and provides the same functionality as GoLand. The only difference is initial setup where the Ultimate Edition is going to require more Go specific settings and I went through and disabled a bunch of extra plugins.
I'll try to keep up here: [https://github.com/breakintheweb/adventofcode2018/](https://github.com/breakintheweb/adventofcode2018/blob/master/03/main.go)
I wouldn't want to use Go for that. It would be very restricting as the library scales up. I suspect you're not finding it because anybody who starts down this road doesn't get all that far. If you want to make something like that, but want to go the "exotic" route and not write in C (and why on Earth would you want to write in C?), I'd recommend Rust.
You've to disclose the source code.
&gt;There are still plenty of non-beginner tasks you can accomplish in Go that just can’t be done with the same simplicity in practically any other language. For example?
As per [this page](https://github.com/golang/go/wiki/SQLDrivers) you want either `pq` or `pgx`, as they pass the compatibility test suite and are pure Go. If you want to use the standard SQL interface from Go's `sql` library, `pq` is probably the best bet. If you are happy being tied more tightly to PostgreSQL in return for getting to use PostgreSQL-specific functionality, `pgx`.
&gt;Memory consumption is on par too (add some in memory caches to go and see how far you get on 7mb - about as far as in java). I've got a Go web application that runs in 12MiB. You can't even start a Jakarta EE application in 12MiB, the smallest I've been able to get "Hello World" is 160MiB.
Maybe I'm overexaggerating and it may not apply to shopping cart use cases, but I don't think you should use floats for money, because of potential rounding errors.
There is a lot of discussion about why Go1 didn’t include generics. Its not because the concept is too hard (because technically slices and maps and the few associated builtins for them are “generic.” As the Go team has said over and over generics have not been included because they didn’t reach a consensus over how they should be implemented. Every language with them implements them in a different way and they all come with benefits and trade offs and an approach was never decided on. 
Yes. 
If you’re not capable of understanding this is true without me hand holding you then there is no value in me going into anymore detail. There is plenty of work in Go out in open so a quick Google and you might learn something. 
&gt; I wouldn't want to use Go for that. It would be very restricting as the library scales up. Why do you think it wouldn't scale up properly? Is that an inherent restriction in the Go runtime?
Then you so much for the tip. Actually the main idea of implementing a shopping cart was find a scenario where functional programming made sense. I will keep in mind your advice for future guides Cheers
`Mage` is a wonderful tool indeed. I use it in most of my projects. Tagging version in repository is a nice snippet. 
Well regardless of the reason generics is not there and has not been for a long while and that is less than stellar. I remember when java got generics and it really increased the quality of software written in java.
Thank you! You’ve been very helpful.
Ok that makes sense. Thanks for your help!
Not sure, but this looks like a workaround. I think the correct way to do this is to follow the godotenv documentation and load the file in the `main()` function and not before. If you need `init()` everywhere and want to use packages, maybe create an `env` package and `import` that everywhere.
&gt; For contiguous data, sure. The reason they're there is to allow arbitrary structures. I'd love to see a "generic" solution that could take linked lists or heaps. A "generic" solution wouldn't mock user pretending that all data structures have their elements in linear contiguous memory. Sorting linked lists using `sort.Interface` is terribly inefficient since they don't support direct indexing. Sorting heaps... Are you serious? Also `sort.Interface` mixes up concept of collection size and swapping elements (which are tied to collection) and concept of ordering (which is tied to elements this collection hold). &gt; This interests me. Got a link? [Sure](https://github.com/golang/go/commit/ca04091f5be4134291142cc4e7e577d0f627e788#diff-0469efc7fac0a7733e5f0925d4640859). According to [this issue](https://github.com/golang/go/issues/16721), new reflection API was introduced specifically for slice sorting.
[removed]
The why really is not the challenge; the problem is implicit contracts create a brittle ecosystem.
-&gt; implementation detail changes cause callers to break.
maybe it's for showing up at the top of alphabetical lists? I remember 12 years ago making sure to pick an a-name when trying to get a game listed on Mud Hut. :-D
Thanks! Based on you response I'm going to use pgx first. Looks like a perfect fit.
I'm not certain, Flutter is really cool though.
Many of the larger projects have documentation on how to contribute. Some have issues that are tagged for those new the project to help guide you though the process. Find something you like, jump on their slack/irc/mailing list/other and just start contributing. Ask questions and try to engage with them. If you don't feel like you are meshing with one community, then try to find another.
We've been considering moving the grunt work to Mage. To embed versions, we use govvv.
I certainly hope that's not the case because it's silly in this instance. Open source software has a big branding issue. Naming isn't the only problem. Icons, mascots, UI, etc. suffer because good develops don't necessarily make good designers and the same people doing the technical work are often tasked with doing the creative work. Unfortunately there isn't as much incentive for FOSS creative work as there is for FOSS technical work because designers aren't benefiting directly from their work being open. This is how we end up with the GIMP UI, obnoxious recursive acronyms like GNU and WINE, and Yet Another Yet Another Project.
I can think of two ways to do it. I'll write up some example code for both this evening and add it to the repo.
Github.com/pkg/errors (Go 2 will have this built in) Stdlib, and prometheus.
It's 2018, please let netstat die and use [ss](https://manpages.debian.org/testing/iproute2/ss.8.en.html). You can reimplement _that_ in Go if you want, it's just netlink.
The real question is if you are going to use multiple languages, why would you not use grpc? It generates api calls between them with the same language. You can even mix and match proto messages. Why would you not use that?
Any hope for mutations?
Eline sağlık. Nerde yaşıyorsun?
There's not denying that generics are useful. But at the same time, if you actually build something without having them to draw from you build software just fine. I've rarely had an issue in Go where the lack of Generics bloated the software I would have written. Even with Generics you need _at least one implementation_ anyways. And in practice one implementation is all that was necessary. For other use cases, putting in some forethought and leveraging interfaces (not `interface{}` but an actual interface with expected methods) solves the other use cases of generic behaviors. I think sorting is a good example. Sure, it's a bit clunky because of Go's type system requiring a sort interface for _each individual number type_ (where they provide some basic float/int/string implementations already) you really have to specify how your type is sortable anyways. So you write a few functions and then pass off your new type that matches the Sort interface to the sorter and voila. Done. You didn't have to _write the sorting algorithm for your type_, you just handle a few basic features like "Is A less than B? How many elements are there? Please Swap A and B", that's it. ``` // from package sort type Interaface interface { Len() int Less(i, j int) bool Swap(i, j int) } ``` That's _all_ you have to implement to sort a custom data type. Which is _roughly_ equivalent to what you'd have to write in any other language anyways. Generics don't tell you how to compare two items. You have to implement that behavior via an interface. The long and the short of it, "Go doesn't gave generics so it's garbage" is a fun argument, and seems totally valid if you rarely ever use the language outside of play.golang.org. But in practice the language is more than equipped to solve _most_ issues you'd normally reach to Generics to solve. That's not say that _adding_ generics wouldn't be nice. I'm not saying Go should maintain never having generics. I'm simply pointing out there is significantly more involved in the discussion than the existence or non-existence of generics.
Do I understand correctly that something like `net.(*TCPConn).Read` behaves more like what you described under “Blocking on a channel” because the underlying socket/syscall is itself non-blocking?
Go is defenetly not a garbage language it does however lack a lot of very nice features that modern languages like Rust, Swift and Kotlin has. For a relatively new language Go is very lacklustre but its probably a good language to learn programming in since it lacks all those features. 
Holy shit that explanation haha. Okay so I’ll keep it simple since I’m on mobile: Your have a GOPATH, this is usually ~/go. Inside are the following folders: Src Bin The bin folder is also known as your GOBIN. It is worth setting both of these environment variables in your shell profile and then adding them to your PATH variable. If you want to start a project, you would create it in go/src. By convention, you start with your version control URL (github.com, gitlab.com) followed by user username and then the project name, all folders in folders. This way you could have github.com/yourusername/project1/ and github.com/yourusername/project2/ and so on and so forth. When you ‘go build’, in a folder, it will build that binary into your GOBIN, under your project name by default. If you added that to your path, you can now run your go app straight from the command line, I.e. $&gt; project1
Where in my comment did I advocate for interface {}, reflection, or type assertions? Use interfaces. Let your client implement an object adhering to it. DONE. Sure, maybe it takes them an hour instead of 15 minutes to run through the tutorial you hacked together, but it will result in a cleaner, more explicit, safer, and more flexible API. Every engineer who works from a type safe language and goes to a dynamic one goes "great! This is awesome! I can do so much more in less time!" I know, I did too. But it's like taking that 30k and spending it in a used Porsche instead of getting the new Honda under warranty. Maybe you get off the lot marginally faster, but when that shit breaks down, you're screwed. Maybe if you were the only one driving it, it's fine, but you gotta hand the keys to every teenager in the neighborhood as well, working on a team. Generics are like the poor man's dynamic typing. Cus they are kinda sorta dynamic but not really. They will make the compiler slow, the code muddy, the implemention more implicit. The bugs created from slight impedence mismatches in your generics would be the 8th circle of hell, if Dante had lived to see Java. I can go into any sane codebase in the world that's written in Go, read it with no instructions, and understand it in a reasonable amount of time. That's gotta count for something. My bet is we lose that adding generics.
&gt;Why do you think it wouldn't scale up properly? As you scale up, the odds of you wanting to do something that this approach won't really be all that great at go up very quickly. A Go object has a _lot_ of semantics associated with it in places you might not normally think about, but will smash you in the face in this context. For one, you've got the fact that the Go code expects the Go runtime to be running, and the Go runtime expects pretty hard to own the OS process it is running in. Maybe you can work out some way around that, but I wouldn't bet on it, and it'll be fragile. Go isn't really intended to be embedded. I am aware you can technically do it, and get away with it to some extent, but it's going to get complicated, fast, as you try to scale up at all. Even little things like "who thinks they own the signal handlers" can bite you pretty quickly. It's better to write the shared code in something that can be told to be less grabby with resources and ownership.
I'm always happy to have new contributors (of any skill level, beginner to experienced) for [https://ponzu-cms.org](https://ponzu-cms.org) \-- a content management system, e.g. Wordpress, in Go. Join our Slack channel: [https://gophers.slack.com/messages/C3TBV356D](https://gophers.slack.com/messages/C3TBV356D) and take a look at issues and open PRs on Github.
Certainly true. I think a lot of us have commented on as much, but it's hard to fix for the reason you also stated. :) I'm guessing what I described is mostly dead. Search engines have managed to understand quality well enough that alphabetization is not a terribly effective tool anymore. And the example I gave is funny (the pages of A-named games went on and on) but it might have been an isolated case.
OK. But then if I want to use multiple versions of some source code in GOPATH/src for different projects, then that does not work? And if I want to store my source code somewhere else but keep the GOPATH where it is, what happens then?
I selected NSQ for my company a few years ago. We handle tens of billion messages per day. I chose it over NATS because it offers message persistence. The flip side is it doesn't guarantee ordered message delivery when the in-memory queue spills to disk. NSQ is sane, easy to set up and monitor, reasonably good performance thanks to Go. I've even forked it to add features like priority queueing and fairness in multi-tenant situations, the code is clear and easy to work with (again, thanks to Go and its emphasis on simplicity). I would also not touch anything AGPL with a ten-foot pole. It's actually a standard part of IP due diligence in mergers and acquisitions in Silicon Valley and San Francisco.
So what is the solution? Always use a select block? I miss the conclusion in this post.
Its exactly that. Be aware that a channels' concern exist beyond where they are directly interacted with. If the consuming go routine dies/slows, then downstream go routines may be inflicted in less that desirable ways. Go offers mechanisms around this (e.g., `select`), but often developers don't think to reach for this.
Java's ArrayList is backed by an array, what's your point?
Looks cool, I particularly like that it can be used as a library cleanly. Would be nice if it were cross-platform. Also a screenshot for the cli version would go a long way. :)
Mind if I ask the complexity of what you need done in go?
I'm just reading this thread and I don't work with Go. Could you point those things out for me? I'm not going to learn a new language just to figure it out on my own. I'm just curious.
&gt; then downstream go routines may be inflicted in less that desirable ways. TBH, I find the backpressure this creates super desirable :) Give that anything reading/writing to a channel exists in the same address space, there really is no reason anyone should "disconnect" unexpectedly. For logs, yes, just dropping the channel is fine - but in general the solution to your problem isn't "always use select", it's "make sure that cancellation is properly adhered to" or "make sure that every channel is closed at some point" or some variation thereof that fits the use-case. A `for v := range ch` is totally fine, even without a `select`, as long as it's clear `ch` is closed eventually. Channels are not network connections - they are a synchronization primitive and they should be used as such.
What is the reason to a) not use `go get` to download packages, b) not use a simple GOPATH style as described in How to Write Go Code and c) why not use modules?
I dm'd you since the mods haven't responded to my original post and I want to be respectful of the communities wishes. If they allow, I'll share more info in the thread &amp;#x200B;
Postings for jobs that are programming in Go for a majority of the work are welcome. :)
In short, yes. &amp;#x200B; It's on the list of things to do, and wouldn't be hard. At this point the main blocker is just that we haven't needed it so far, and we've hesitated to add things to the library without sufficient code using the feature to prove out the API. We'll add this eventually, and PR's are welcome in the meantime.
To discard a line from a bufio.Scanner, you did: ``` // Discard title if br.Scan() { _ = br.Text() } ``` Checking the result of Scan() and calling Text() is unnecessary. You can just do: ``` // Discard title br.Scan() ``` Also, I appreciate that you close files in time, not in `defer`s which usually delays until much later than necessary (and dangerous within loops). Overall, clean enough code, good job!
Looks like it's a simple wrapper around procfs, so Linux only (not even BSD IIRC).
This is the problem I'm working to solve with [http-boilerplate](https://github.com/jordan-wright/http-boilerplate). I'm building this out over time with the following updates (which will each include blog posts similar to [the original]() that describe why certain things are done): * Adding unit tests for each handler * Moving the server to it's own struct to allow for server-specific externally loaded configuration and context like a database connection I typically leave logging to a separate package that wraps logrus. [Here's](https://github.com/gophish/gophish/blob/master/logger/logger.go) an example of what that might look like from a project I work on. Hope this helps!
Thanks for the suggestion. I'll look at some ways to make it cross platform, as someone else filed an issue on Github about adding Windows support.
Fair, it probably is worth mentioning that when working with network connections this is a larger issue. Which is what Loggregator is largely doing.
Correct, versioned dependencies has been one of the major pitfalls of Go and is the reason for (Go Modules)[https://github.com/golang/go/wiki/Modules#gomod] You can create your go applications in any path and still build/install them the same way, it doesn't make any difference. It is however quite nice to have all of your code wrapped up and organised neatly in one directory. This of course is blown out of the water with go modules which compltely change how go works, personally if you;re only making small projects which don't rely on a lot of dependencies, I would simply role with go modules.
Indeed - the suggestions in this article should be only be sensible in exceptional circumstances.
Cool so rather than actually explain it you’d rather attack my intelligence. Your answer is based on a false premise and conveniently is self fulfilling protecting you from having to provide an answer. If you can’t provide evidence for what you’re asserting then it’s easily dismissed and if feel the need to insult someone to protect those views they’re not worth a shit. 
Boulder.
You're right. It seems really unnecessary to do calling Text() there.
What is the name of the Start up? 
Looks like FreeBSD requires some library calls to get socket information, aka sysctl(3). [https://svnweb.freebsd.org/base/release/8.0.0/usr.bin/sockstat/sockstat.c?view=markup#l424](https://svnweb.freebsd.org/base/release/8.0.0/usr.bin/sockstat/sockstat.c?view=markup#l424)
I've been struggling with this too! I haven't been able to find a good example of something as simple as ingesting a PUT request and saving it to a DB. This should be pretty standard stuff!
It would be great to know if remote is OK?
Thanks for your reply. If I may poke a little further: My interest goes specifically to using Go alongside a web application server, which may be written in a multitude of languages (e.g. Node and Ruby on Rails). I want to leverage the package managing system of the user language to make it easy for developers to use the library. This developer usability is core to this approach; I wouldn't be asking this question otherwise. The user of the library shouldn't have to setup a separate process / server, outside of their (monolith) application. How would you propose setting this up using grpc? With a long-running subprocess and piping grpc over stdin/stdout? Do you know of any libraries that take this approach (not necessarily in Go)?
Thanks for your answer. I hear the sentiment you're expressing, that Go isn't suited for this approach, in other places I ask this question. Do you know of any other (authoritative) sources that discourage this approach? Why did they introduce the 'c-shared' build mode in Go 1.5 if the Go runtime expects to own the OS process its running in? You say, "Go isn't really intended to be embedded". Do you mean that Go isn't intended to be used as a shared library?
"Rookie" ;)
If I feel the urge to defer in a loop, I refactor the loop innards into their own function so that defers execute after each loop iteration.
windows is case-insensitive, that would likely be a reason for that mistake
Awesome! I’ll share more information when I get back to my computer later. For now, anyone interested can take a quick look at clearstreet.io
Unfortunately not right now. Our engineering team is small, very collaborative, and early on in the build out. We want additions to get really well integrated at this point as each hire represents a significant portion of the team. Thank you for your interest and if you want to drop me a line via dm I’ll give you my email so we can stay in touch. 
Request wrappers are great for getting projects launched, my problem is that I often had to replace whatever _helpful third-party_ lib I was using with the stdlib (or raw sockets) when the demand/load increased or I found that obscure HTTP2 feature / HEAD support / non-standard url encoding / custom parameter order (not kidding) wasn't supported.