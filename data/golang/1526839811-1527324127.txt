Hashing doesn't mean irreversible. In fact encryption is largely considered irreversible while hashing isn't. People like bcrypt because it allows you to verify properties about the data without exposing the original data, which is maybe what you meant by "can't be reversed". It's not that it can't be reversed, rather it doesn't have to be reversed before use. To transmit a bcrypted password across a network you'll still encrypt it because the hash is vulnerable.
&gt; * Where do I convert user input into bcrypt, in the client side? On the server side, always. Transmit the password via HTTPS to the server, and then bcrypt it on the server before storing in the database. HTTPS protects the plaintext password from being sniffed by attackers who control the network between the client and servre. Bcrypt protects your users from an attacker who can read from the database. &gt; * Also if on backend then I should do it in my app(go) or in the database (assuming DB has some way to do this I use postgres) Do it in your app. Use a standard library for this. &gt; What other good practices you guys use in your apps gor storing user credentials in DBs. I'd just start with the above. If you wanted to do some more, you could try incorporating a pepper into your hashing scheme. The pepper would be stored in a separate database. Peppers act as a salt but they are stored separately - most attacks that can dump passwords can only really do it against a single database, so by storing an additional secret in another db you can protect users even in the event of a db dump.
&gt; `// len(myChannel) is decremented at this point (from my observation)` Not in the general case. It can be different by some delta, negative, zero or positive. There are some cases where `len(ch)` provides useful information. However, one has always remember that's it's always information about the past. It says - in almost all common cases - _nothing_ about the current value. &gt; What's the "Go way" to prevent this race condition? Ranging the channel is race-free - provided proper design ensures the channel is closed and closed only once.
So of just a goto number to throw in there based on personal experience as a good starting place. As always worry about performance only after the code itself is correct. 
Scala and Go
Maybe they should instead move away from Docker.
you can't get the original input from the output of a hash function. That's their whole purpose.
Maybe they shouldn't deploy at all.
# go errors ## pros - implemented using interfaces, allowing for reuse of any interface knowledge - force users to acknowledge that each individual function could fail - no extra syntax or "baggage"; we could all switch to a new error interface and remain compatible ## cons - loose definition means it's often hard to interpret errors when you need different behavior based on the actual error - sometimes an error return is added to functions that will never fail just so they match an interface - using errors _and_ panics can mean you have twice as much error handling code to work on the same amount of information # checked exceptions ## pros - focus on identifying exactly what error occurred - being part of the language means better ide support - people are forced by the language to not ignore errors ## cons - people are forced by the language to not ignore errors - it can force people to wrap exceptions over and over again just to satisfy type signatures, possibly introducing a lot of overhead - it exacerbates the problem of people saying a function can return an error when it's actually impossible, just to satisfy an interface - requires a lot of other language features, like generics, to really be effective; not a deal breaker, but it does make the whole language tremendously more complicated
[removed]
That would be by design then. If I am storing, for example, 4 letter codes, I could hash them by creating a single int that is the ASCII value of each "concatted" together. This is a hash, but is also reversible
Let me see if I can come up with a repro. There's a (good) chance I'm way off on diagnosing this behavior. Should have that repro in a few hours. I appreciate the info on len'ing a channel!
&gt; Hashing doesn't mean irreversible. No? You generally hash into a smaller space than the plaintext space. Every value of the has function _should_ correspond to multiple point from the domain. That literally means that it's irreversible — even if you find something that hashes to the value you're looking at, you don't know if that's what was the other person's input. One _might_ be able to find a collision, though in a good hash that should be very hard.
The whole point of hashing passwords is to harden them in case of direct access by attacker (DB dump access, for example).
Not sure if it was posted already, but I was looking for something online to search for golang packages. Ideally, I would have liked something like mvn repository website or even the brew search online. But this is what I found so far. If you know of something better to explore go packages, please post as well!
&gt; I thought I fixed the start stop? You are still creating a new Server instance on every call to that function. When you call it the first time to start it, you create a local scope Server and start it blocking in a goroutine. You now no longer have a reference to that Server. Later when it is called again to stop it, you call Shutdown on a new and different Server. So your original goroutine continues running the Server. If you then tried to run start again, it would fail on the port already being bound. But you don't see any of this because you don't check it. 
Glad you liked the idea :D Any ideas to improve it?
And my recommendation is to create a single Server instance, and then have a callback that calls Shutdown on the same one that was started. To be honest, I don't really understand the design of having these functions that take string verbs to do one thing or another. Why not just create a Server struct that can save your state (like the private http.Server instance) and have methods like Start, Stop, HandleLogin, AddLogin, RemoveLogin. Having these string verbs seems error prone and messy. 
Good article on bcrypt hashes: https://www.engineyard.com/blog/password-security-part-3
True but then there is json RPC and then frontend remote functions. Seems all simple till you try to build your own types for all this stuff. Let alone doing it right.
Thanks! I wasn't sure how to format those, actually. Each individual flag argument (e.g. the `&lt;url&gt;`s in `-u &lt;url1&gt; -u &lt;url2&gt;`) is indeed a single value, it just accumulates all values in a slice instead of overwriting a single value. I've also added `*CSV` types (that really do accept multiple, comma-separated, values), perhaps it's clearer now?
Cool, thanks! I've added types for `net.{TCP,UDP,Unix}Addr` now :)
Yes, part of the reason I don't want to use Oauth is ease of use. Another idea I had was to encrypt the API key using a passphrase and writing it to a dot directory. When the user wants to run the CLI utility, I can make them provide the passphrase and run it in interactive mode e.g. like a command line SQL client. While they have their CLI session running they don't need to provide the passphrase and can run commands to the heart's content. That's a bit more complicated but not too bad, there are some Go libraries available which handle most of the heavy lifting there.
I'm not quite sure what you are suggesting, but if you can clarify I'm happy to discuss further after I grab some food :)
It is not a misconception. Using JSON API assumes you are building a relatively thick JS front-end, which includes JS navigation and all that jazz. Classic Web application requires different approach to structuring your URLs and building navigation (if you can arrive on a certain page from multiple locations, each should be posting consistent set of values). It is not necessarily worse or better, just different, sometimes vastly. 
&gt; It's a tremendous amount of work for something that companies like Google and Facebook will offer for free via OAuth You don't want to rely on Google or Facebook Oauth to manage your users either, especially in the era of GDPR, because you don't know when and how Google or Facebook will change their policy when it comes to federated login. This is not a save bet.
I've never needed any counters around elements in a channel (for synchronization specifically) after years of writing Go, so I imagine you just need a small adjustment in your design. If you post your code in a play I can give you a head start there, but the way you explain the problem makes it sound like you are trying to synchronize a close operation from outside the senders goroutine. This is almost always the wrong design because it brings the pain you're facing here, the better solution is to always have your sender close, i.e.: myChan := make(chan int) go func(myChan chan&lt;- int) { defer close(myChan) // when goroutine exits, channel is closed. for i := 0; i &lt; myCount; i++ { myChan &lt;- i; } }(myChan) for i := range myChan { fmt.Println(i) } // will break when sender is done. This general rule can be adjusted for when you have multiple senders too by fan-out &amp; fan-in, for a good example of that check out [Go Concurrency Patterns: Pipelines and cancellation](https://blog.golang.org/pipelines).
That was very helpful to me
Well I just started this stuff today cause this lib came out for JavaScript. https://github.com/lindell/remote-function So then I had to dig into how to utilize it in go. A few expressos later... https://www.smashingmagazine.com/2016/09/understanding-rest-and-rpc-for-http-apis Then I finally found some gold. http://www.ryannedolan.info/teaching/cs4830/examples/go-examples And yeah they are not the same thing. But made me think now I gotta rethink apis. Cause RPC is for "verbs" (method calls) and well go types work well with interfaces so I'm thinking you can build a really nice type with these RPC methods + the "rpc" package. But as for doing it right... Idk but just kinda blows my mind you can have a server like instance on the frontend talk to the server on the backend that calls methods on the backend. My only beef is all these resources on using gorilla mux and not as easy break down with the go "rpc" package instead. New stuff hurts my head and I think I drank too much caffeine today trying to consume it all. But that's I guess what I'm referring to. 
I was just going to suggest this myself. The standard library’s JSON code is nearly a reference standard in terms of expected behavior but definitely not in performance. I look forward to Go updating its standard library JSON code to something more performant, but for now folks should use either a different protocol, such as MessagePack, or use a faster library, such as gojay.
Just to chime in.. If you're not an expert at authentication systems and security, consider using one designed created to give you a best practices experience out of the box. Authentication isn't the problem your app is trying to solve. https://github.com/volatiletech/authboss 
[Here's the repro (GitHub gist)](https://gist.github.com/trstringer/6251ddf62faff41cfa7358e46eea8d85). The output is commented below the code snippet. The important part to note is the undesired output of missing an item: Initial item count: 10 Final item count: 9 I think I can refactor `WaitGroup.Done()` to the processing goroutine, and that should effectively fix it. But is that the only other glaring problem here with my approach?
Thanks for thoughts! [Here is the repro (GitHub gist)](https://gist.github.com/trstringer/6251ddf62faff41cfa7358e46eea8d85). I think the way to refactor this would be to move the `WaitGroup.Done()` invocation from the producer goroutines to the processing goroutine. Other than that, is there a better more massive overhaul that would make this nicer?
Thanks. Added this to my list. Here are a few other lists/databases I know about. Some are searchable, some not. * https://golanglibs.com/ * https://awesome-go.com/ * https://go.libhunt.com/ * https://goreportcard.com/ * http://libs.club/golang/
I don't know why this function (which I've lovingly stolen from DBIx::Class) isn't standard: type TxnFunc func(*sql.Tx) error func TxnDo(db *sql.DB, f TxnFunc) (err error) { var tx *sql.Tx tx, err = db.Begin() if err != nil { return } defer func() { if p := recover(); p != nil { tx.Rollback() panic(p) } else if err != nil { tx.Rollback() } else { err = tx.Commit() } }() return f(tx) } (possibly with cleverer handling of an error thrown by `Rollback`, but that would bloat the example). Basically it lets you call err := TxnDo(db, func(tx *sql.Tx) error { // do some work with tx }) and know that either the work will return success and the DB changes within will be committed, or it will return an error and the changes will be rolled back. If you're careful about the side effects of the inner function it's *very* powerful and convenient. 
I used to, but since I switched to using dep I haven't had a need for it. Contra many people's whining about Go's dependency management, I actually kinda like the combination of using `go get` without much thought, then nailing down the exact dependencies of something only once I'm ready to get serious. It's the best of both worlds of casual hacking around and production-quality dependency specification. Prior to dep, I used two directories to keep a clean partition between the "stuff I just downloaded at some point" and "stuff I'm actually depending on in production". Also in the "stuff I just downloaded" were tools like goimports and gometalinter and such.
You are correct. Thanks I'll fix it tonight or tomorrow. The correct link is in the context section (the pitfalls of context values article)
The point is the application logic - everything specific to your domain - is the same regardless of what format requests or responses are written. So, yes, you may need different semantics or even endpoints, but a Widget is still a Widget. In general, it is good to keep logic and I/O separate, no matter what type of application you're building.
Honestly I'm not incredibly familiar with the remote function stuff you linked, so I can't speak to how much it might affect the server side architecture right now :(
Hardly believable. At my company nearly every single app on production is "containerized" with Docker to be deployed on kubernetes. The dockerfiles are usually just 5 lines long, starting from an alpine image, copying and running the go binary. Also, on our golang applications, we often have really low memory usages, in which our deployments usually request only from 50MB to 150MB of memory on deployment manifests. I'd say that memory leaks 99.5% of the times happen at the application level and docker would seldom have anything to do with it. Sounds kind of like blaming the network for sending you that 500 error.
Thank you.
/u/styluss, thank you very much for sharing this :\)
Just seems like extra work to encode as a string for no reason.
1. You can use WaitGroup to close the channel after the last producer finishes. https://play.golang.org/p/iSMdOc26Zsv 2. You need to wait for the consumer to finish. PS: run your code with race-detector enabled.
How is this a common misconception?
So what causes memory leak in golang?
Just like in most garbage\-collected languages, memory leaks can happen if you needlessly copy data around instead of reusing it by reference, or if you keep your objects referenced for longer than needed so that the garbage collector can't do its job. This has nothing to do with the language but with how well you write your software.
What's wrong in not using a wrapper if it's causing the leak? There are many reports about Docker bugs.
&gt;worry about performance only after the code itself is correct \(thumbsup\)
Thanks!
[removed]
You've posted this link 11 times just in this sub. https://www.reddit.com/user/hsluoyc/posts/ https://www.reddit.com/user/hsluoyz/posts/ Is this a new account because your previous one is banned? We appreciate creating a good library, but please, stop spamming it here again and again.
I interact with a ton of people learning Go with minimal or no backend experience who all feel like learning to build a web app is an outdated skill and they constantly insist that they should be learning to build a JSON API instead.
Question. What use case managing multiple transactions?
Let me know if I'm doing something obviously insecure and wrong.
&gt; Don't ever use an encryption algorithm on passwords This is good advice if your handling the authentication, but poor advice if you need to store the password for a user, e.g. if a service your consumer needs doesn't support persistent logins and expecting the user to enter it in every time is unreasonable. Encryption is better than plaintext, and hashing is better than encryption when it comes to authentication.
Wow, I think you got this exactly wrong, though there might be some truth *somewhere* in here.
frankly the best way to find go packages/tools is to just to use google. you can use the "site:.\*" trick to limit your search a single domain.
What? According to CPP guidelines and industry best practices. Watch cpp cons from last years, read /r/cpp, cpp google groups and [CppCoreGuidelines](https://github.com/isocpp/CppCoreGuidelines).
&gt; The language lets them do this because while exceptions may be used like conditions, they don't have to be and thus will never share the same clarity as conditional control flow found in if, switch etc. IMO, exceptions work well for actual *exceptional* conditions but developers misuse them as flow-control devices.
`strings.Join`
&gt; I would argue that if you aren't a security expert, you shouldn't be building an app that stores a user's password for any services that doesn't offer OAuth (or something similar) Those are the requirements of the project. To be fair, these are internal services. I work in the security space, so we integrate with security systems (cameras, VMSs, etc) that tend to use really outdated security. These devices are typically on an internal-only network, and we use TLS where available to transmit credentials, so it's not *terrible*. &gt; you shouldn't EVER store passwords in a reversible manner - plaintext, encrypted, or any other way ... *if* there's a better option. If there's no alternative and the choice is between providing a service that users find valuable and not providing the service, I'll provide the service and make it as safe as I can, while working with the insecure services to fix the situation. In our case, the decision is between password security and physical security, and we believe our product does a better job at providing physical security than the systems they have in place. Rarely are absolutes correct in any field. The rule of thumb should be (in order of preference): 1. Use established best practices, such as OAuth 2. Hash passwords with a secure, slow hash and preferably offer two-factor authentication 3. Encrypt with a salt and protect access to the database Everyone can do the third option, and it's far better than what a lot of people do, so if the first two simply aren't options, then the third is likely better than not providing a service at all, especially if the benefits outweigh the risks.
_Who_ is going to decide what's idiomatic, reputable, respected?
Sure, PWAs are here to stay, but learning PWAs + a JSON API as your very first technology is like learning calculus before you've learned basic trig. It might work for a few people, but most are going to fail miserably at the overwhelming amount of information and complexity. I would also argue that things like PWAs are overused and overhyped in the tech community. Most applications built DO NOT need to be a PWA, especially in their early iterations, and we force this added complexity onto apps to our dismay. Using another metaphor - it is like spending months coming up with a way to make pens work in space when we could have just used a damn pencil and moved on. Sure, if it is a learning exercise it is great, but is this really the most effective use of our time when there are planets like Mars to focus on getting to? I believe this is a bigger problem in the tech community as a whole. We convince beginners that they should start by learning to build what FB is now ignoring the fact that FB took years of trial and error and thousands of engineers to get where they are. FB never started out as a PWA. It was a simple PHP app when it first came out, and evolved over many years with the input of thousands of engineers to become what it is now. If anything, it should be a testament that we can start off with something simple and iterate on it rather than trying to build the massively complex final version from the onset and likely getting it wrong in many ways. I get not everyone is going to agree with this, but I strongly believe that we should teach beginners foundational knowledge with simpler applications, then help them learn to start understanding why JSON APIs and PWAs came to be, then start showing them how to adapt what they have to become a JSON API + PWA. Without doing this we end up with an entire generation of developers who don't necessarily understand everything they are doing and mindlessly advocate for building PWAs that are more complex, harder to maintain, and slower to create than they likely need to be. If it helps at all, I don't say this all blindly; I have been teaching people web development, Go, and other related topics for some time now and I can say with absolute confidence that once I convince someone to try my approach - learn the foundational knowledge first, then learn to build the more complex things like JSON APIs + SPAs/PWAs - they are more successful and end up agreeing with my approach.
Where would I find some help actually dissecting this, because all of the tutorials I've seen online don't involve a MVC (model/view/controller) format and they don't go over what everything means or how the syntax works, they sort of just expect you to know all of this. Plus, I'm working on a project in progress and my mother explicitly said she wouldn't help me understand what the syntax means and that I would have to find out myself. I'm not sure where to start. Is there a slack channel or something where I can get real time help on this?
That's a good question. I'm not sure how to answer that. Probably anything that Rob Pike says, or appears in "Effective Go" is idiomatic, but about the rest... I'll look through examples from Dave Cheney, Fransesc Campoy, Dmitri Shuralyov, etc.
Thanks for sharing this, I am in the same boat as you, building a bot which runs on lambda with dynamodb as a database and golang. I am thoroughly enjoying it.
By comparison, anyone tried Twerp? Thoughts?
&gt; Rarely are absolutes correct in any field. You are right, but I still agree with what I said. Let's look at this from another perspective - when we teach people how to spell we teach them "i before e" despite knowing there are exceptions to this rule. We do this because until they grasp spelling enough, introducing these weird exceptions isn't going to help them, and it might in fact hinder their ability to spell accurately. Only after they learn the basics of spelling do we start to introduce these exceptions to the rule. Password security is similar; we should tell people "Don't ever use an encryption algorithm on passwords" until they have learned enough about security practices to truly evaluate what they are doing. At that time they might start to learn about exceptions to this rule, risks of those exceptions, ways to mitigate those risks, and more, but the average developer shouldn't ever be using encryption on passwords. I, and many others, say "don't ever..." it so emphatically because everyone loves to believe they are the exception to the rule when 99% of the time they are not and we are trying to give them pause so that they second and third guess their decision before actually deciding if they are that exception. &gt; Those are the requirements of the project. And I'm sure T-Mobile had similar requirements when they stored user passwords (at least part of them) in plain text. That doesn't mean what they did was either right or secure. I'm not trying to suggest the risks of your project don't outweigh the benefits - they very well might - but I don't think, "those are the requirements" is an acceptable excuse by itself.
How does a bot run on lambda? What triggers lambda invocations?
This is actually google hangouts bot. It responds to webhook events. Even slack allows a bot which responds to webhook events. Basically they POST a message to the configured endpoint whenever this bot is mentioned and now the http service can return a response which controls what gets rendered.
It is interesting to think about what you get with go vs. node over time when you consider it is possible to remove the `GOMAXPROCS` limitation and utilize all the cores, whereas with node.js you'd need to include a clustering mechanism. I imagine there are tools like multiprocessing in python that work functionally the same in node.js, so it is not a ton of work, but when you consider sharing any state you need to understand clearly where the bounds are between the processes in terms of data. Point being, that even though the benchmark reveals how node.js can be faster, I suspect over time go's attention to building large software projects becomes a better choice in terms of development time because you don't have to manage the code necessary to use more than one core, be that via a clustering library or operating using multiple processes. 
This is a brilliant explanation. 
I completely agree that you should start with the easy bits first. What I was trying to say is that they *are* beginners and you should trust your own judgement when they &gt; feel like learning to build a web app is an outdated skill Sorry if it came out wrong, I was typing on the go. P.S. saw your other comment about RPCs, you should definitely check gRPC out. It'd make for a fun lesson I think. They feel a lot like local methods on the client side and they have streaming capabilities built in like websockets, with the added benefit of being strictly typed. So, no nil exception errors ;\) 
Ah, makes sense. Have you noticed problems with lambda warm up time?
&gt;gRPC instead of REST APIs. Care to explain what you mean here?
If you are struggling with syntax, start with something easier. See if [tour of go](https://tour.golang.org/welcome/1) is helpful to you. What's your general experience? What do you know/are familiar with? Such examples are there for people with experience to quickly get to know how things work. It will not teach you syntax or basics. 
There are third party libraries that make it work like [grpc-web](https://github.com/improbable-eng/grpc-web/tree/master/go/grpcweb) but I agree, it's not a great experience. I only brought up gRPC because he said his students felt building web apps is outdated, hence the back-end assumption.
I was referring ONLY to the fact that google does not use exceptions. AFAICT this is still true. When google recently launched absiel, https://abseil.io/about/compatibility they had this to say: &gt; Although Google is part of the minority of the C++ community that doesn’t use exceptions, 
Prefixed with a big IMHO; These days I feel if you're handling the logging to the file directly you're doing it wrong. + systemd on linux can take a process stdout and handle the log file stuff for you. + you could always wrap it in supervisord to do the same thing on systems that don't use systemd. + logging in docker containers is best done to stdout so that the logs can be routed correctly to whatever system you use to process them. So, the above stuff handles the logging, probably feeding it eventually into logstash to then shove into elasticsearch, or greylog2. As for log formats, I prefer to use JSON log format as that can be trivially consumed by logstash and I can add more keys to it as I see fit. Pick a logging framework, like github.com/uber/zap or something like that, and just use that. It'll do the right thing, I think.
I know other languages like C#, a bit of C++, HTML, a tiny bit of Javascript, and a tiny bit of Ruby. And I just looked through the tour of Go and I'm getting a slight grasp on things. In fact, I basically commented out a bunch of routes and methods and only have the one method in my user controller here: package controllers import ( "github.com/revel/revel" "appname/app/models" ) type Users struct { App } func (c Users) Index() revel.Result { var users []*models.User return c.Render(users) } and this ends up working fine. However, now I need help figuring out how I can actually test the api with the database, because in the terminal, it says "Database connected", so I know it works, but I just don't know how to access it at all.
I’m glad that you like it!
Not really, response times are around 900ms pre warm up and &lt;10 ms after warm up.
Go then C#/.NET then Python then Java. Not a fan of Java in general. Love .NET, especially the new Core.
Password hashes are meant to be slow. This means if somebody steals a copy of your database, they can't immediately bruteforce all the passwords. However I note the example you're following uses a cost of 14. You can set the cost as low as 10 (or as high as 31): https://godoc.org/golang.org/x/crypto/bcrypt#GenerateFromPassword Here's a good StackOverflow answer about bcrypt costs: https://security.stackexchange.com/a/83382
Thank you! Would it be a bad idea to have the hashed passwords and their values in redis? Or would this make it basically just like storing plaintext passwords?
What do you mean by "and their values"? You only want to be storing the password hash (output of bcrypt.GenerateFromPassword) in your database (redis or whatever).
&gt; this is something users will probably doing quite often No, usually they only do it once per device or once per session.
Probably true, though I have personally run into a memory leak in .Net Core (solved in version 2) while talking to sequel server from Docker. In the case of Go, I would assume a lower incident rate of running into errors specific to Linux implementations of libraries since more Go is getting deployed to Linux than C# (which has the majority of deployments happening on Windows). In the end, errors with core functionality of major languages tends to be small enough that you don't need to worry about them much. I certainly didn't stop writing C# on that team and we did not migrate all of our code to Go to avoid the memory leak.
No, use sessions. It requires running bcrypt only when they login. The user logs in (and it takes more than a second) and gets a cryptographicly [random session token](https://golang.org/pkg/crypto/rand/) which you can store in redis maped to their id, session expiration time, etc. In further requests, they just send the session token which you validate against your data in redis. This will be relatively very fast.
[removed]
This! \^\^Don't even roll\-your\-own token; that's exactly what JWT was designed for. There are several good libraries for Go. * User logs in * Service issues JWT token \(usually in cookies, but whatever works for you\) * token is used to validate any further requests until it expires, when the user will need to log in again Just make sure you're only sending them over a secure channel \(TLS\).
When you say "hashed passwords and their values" that sounds like you plan to store the hashes and the plaintext passwords. Do not store plaintext passwords anywhere, ever. Once you have the hash you can always recompute it and compare when the user logs in.
That is a terrible example. Do not implement password management yourself! You are virtually guaranteed to do it incorrectly! If you insist on implementing it yourself, at least look at the OWASP wiki instead of some notes from a random unvetted person on the internet.
This guy Ewan always has inciteful Go posts that shows reader how to do practical, useful things with the language. One can only stand to look at Go posts about syntax or theory for so long right? :)
The modern way to do logging is to just write to stdout or stderr (whichever you prefer) and let another specialized tool figure out what to do with the data. It is okay to log in a separate goroutine if you want. It's probably better to wait until you actually have a bottleneck before doing that though. You can wrap an http handler with another http handler that does logging for you. Check out https://medium.com/statuscode/how-i-write-go-http-services-after-seven-years-37c208122831 for a lot of ideas on how to organize it.
I guess my feedback is that when I read the README.md or the godoc, I still don't even know what this is supposed to be or what it is supposed to do. This makes it difficult to give any deeper feedback.
# That's great! :D If you have any ideas to implement, please share them. :)
Looking pretty good so far! Here's a few points: ```createUserHandler(w http.ResponseWriter, r *http.Request)``` Why does this take a w, r? You should be able to call it once, and the returned http.Handler is what gets called? ```if err := json.NewDecoder(r).Decode(&amp;reqUser); err != nil {``` What I've come to love is having a central "ErrorFilter" for all your domain errors. Basically, instead of checking the error, you do something like `if Problem(json.NewDecoder(r).Decode(&amp;reqUser)) { http.Error.... }`. Centralizing your error filter just encourages re-use, as stuff like "DatabaseError" or "RequestError" are always things you want to kill the request, but maybe you want to only log certain errors, etc. The `Problem` function returns a bool indicating whether to quit what you're doing, but you can also have whatever options you like, such as "Retry". ```if err == s.store.User.ErrUserExists {``` This should, as far as I can tell, be more like `if _, ok := err.(s.store.User.ErrUserExists); ok {`, as `error` is an interface, equality on it should not work how you expect. Just try to assert it as the error type you're looking for. Which brings me to my next point: ```userExists = ResponseError{"That username is already in use.", 5},``` These errors are so static. I'd recommend a way of being able to specify metadata - for example, if the user exists, the error you return should actually be the ErrUserExists struct, which when called `.Error() string` would return something like "username &lt;x&gt; is taken". Don't forget, errors can *contain* meta-information, and can construct a human-readable error message on the fly! Errors are more than just strings. ```hashedPassword, err := bcrypt.GenerateFromPassword([]byte(reqUser.Password), bcrypt.DefaultCost)``` Create the User struct first, then if the "else" part you can assign user.HashedPassword = string(hashedPassword). You don't need another closure variable, it seems like you couldn't find the right way to do that one so I'm letting you know. In general, your requests will always come down to a "take input, built output or fail". Keep this in mind, as your functions should all end up beginning like this: var reqUser requestUser var newUser user.User if !usernameValid(reqUser.Username) { fail() return } newUser.Username = reqUser.Username // keep building newUser bit by bit, as it's easier to add/remove new fields/features/steps this way respond.Ok() 
But don't *just* hash on client-side, do another (quicker) hash of that hash on server-side. Otherwise, technically, the plaintext password is being sent over the wire and into the database... It just so happens that the password is now a hash string.
Serverless: it is just someone else's cloud.
It sure is!
"Then the user needs to log in again". Or use a refresh token.
Oh. I did not think about that. Thank you for that. I have made the changes. :) This tool (complies and) executes a program and gives the output with a given input. My hope is that it can be used to build an web IDE or an online judge. But my main goal is to learn go. So I am more interested in the code quality rather than the specific library usage. I am still a new comer to web technologies.
This is meant to replace stuff like mpd, but because I find ncmpcpp hard to use and I don't like how iTunes is getting progressively bloated, I decided to write my own music player. Currently it just searches for mp3 files recursively in a directory and plays them.
How a start-up do this with a private repo?
Hi _nippleshredder_, Serverless uses your AWS secure keys, rather than git or ssh, so you can just use a private repo the same way 
What is online judge??
Yes, it is likely coincidence; not sure why those other comments are deleted, but there are major link-time differences with MinGW-w64 that I have to resolve, mostly having to do with either a mismatched exception model or a single missing import from comctl32.dll whose patch (which I wrote) did not seem to get applied universally. https://github.com/andlabs/ui/issues/281 has more info.
Before you do, I want to make sure that libui and ui have consistent documentation, something I don't know sure how I will actually accomplish yet...
Yea. Didn't read the question or answer properly. I thought the opinion was about whether things should be transmitted encrypted or just hashed across the network. So I was taking a PoV of an attacker being able or not able _reverse_ the data. Left it up because it seemed like people were having a good time bashing me, and as a lesson to not Reddit first thing in the morning :P
Yeah, it happens to all of us. Keep on keeping on!
1. Oops, that wasn't actually a running snippet, just forgot to remove that. 2. I like that. 3. I like that, it would be nice to have more descriptive errors like that. 4. Ok. 5. I like that! Thank you for the advice! I especially like using types for errors instead of just fmt.Errorf so I can have more descriptive errors.
Seems like a lot of people are not happy about that...
Highly recommend the gotk3 binding with glade, there's a tutorial here: https://github.com/mrccnt/gotk3-glade-example You can minimise the amount of GTK calls you make pretty significantly by loading in a layout and just mapping signals to your api. Keep in mind you cannot modify the UI from a go routine without it crashing. I've found running a ticker and notifying completion with a channel gives you an easy way to add synchronous operations without completely locking the application: // While task is running set status indicator and update the UI for { select { case &lt;-t.C: setStatus(bldr, "saving") gtk.MainIterationDo(false) case &lt;-d: t.Stop() setStatus(bldr, "") switchView(bldr, "stack", "main_view") return } }
Also seems most unhappy folks waited to air their views on proposal till proposal was accepted. Sam was supposed to write detailed shortcomings of vgo but it seems he remain too busy with his day job to write that series.
Alright, not sure how to do the server stuff you mentioned, but will seperate the functions. I am going to address errors very clearly next release. Thanks!
Just a vocal minority. Pretty much everyone is happy about this.
I'm happy it doesn't include any of these: - version ranges and sigils (~ ^ @) - json, yaml or toml - SAT solver 
If you provide an exact position I've taken in this thread or my [other post](https://www.reddit.com/r/golang/comments/8kscen/how_is_returning_an_error_betterdifferent_than/dzaakfp/) that you disagree with I may have more to add, for now I'm unsure what you are arguing against, sorry. My best interpretation is that you believe one may create high quality code with checked exceptions through proper design, I don't disagree. My core assertion here is that checked exceptions give developers the ability to produce less concise, thus lower quality code than the value based error handling found in Go. I've already covered why I believe this in my other post more in depth so feel free to argue against my points there otherwise I'll be moving on, happy coding.
Ultimately the people in the Go team at Google decide. The Go project isn't a democracy nor that open. Nobody knew about vgo 3 month ago... everybody thought dep would be the way forward. This is the same thing as "alias", opponents outside google like Dave Cheney were ultimately ignored as alias solved a real problem @appengine for instance.
&gt; 1. The proposal will require people to change some of their practices around using and releasing libraries. &gt; 2. The proposal fails to provide a technical solution to all possible scenarios that might arise involving incompatibilities.
Official Go dependency management.
&gt; Nobody knew about vgo 3 month ago... everybody thought dep would be the way forward. I have said this elsewhere, but: Yes, it is unfortunate that this impression existed. But it is unfair to blame this solely on the Go team. Russ has been [pretty clear](https://groups.google.com/d/msg/golang-nuts/PaGu2s9knao/Bq4vmFh7AgAJ) that this expectation is not the intention. Relatively shortly before Sam went out and announced dep as the future and *created this impression* you are talking about. Meanwhile, none of the arguments against vgo where made public - *until now* pretty much (I have trouble counting Sam's first post in his series as an argument, TBH, because it is far too vague). This makes it incredibly hard to create consensus or evaluate the merits of the criticism. Yes, there clearly was a failure to communicate here. But communication [involves at least two parties](https://xkcd.com/1984/).
Rsc knew a bunch of people were working their ass off on dep. People working on dep knew nothing about vgo. There is no debate, one party didn't do its job of communicating. I'm not sure why you still defend Russ here. Russ could have said:"we are working on a solution internally, don't waste your time".
You are assuming that `dep` was a failure and that it didn't influence rsc or `vgo` at all which i think isn't the case. Russ and Sam met regularly during this time. It could be that in working with `dep` meant that we got `vgo` as it is today and `dep` shouldn't be looked at as a failure at all.
That's a lot to digest at once. I don't know why, but I was quite happy with the way Go currently works.
To be fair, it was published three months ago and there have been extensive discussions in the proposal issue, slack, the mailing lists and here on reddit :) It's an interesting read, but I also don't think it's terribly important to do now, if you are not explicitly interested in how this is going to work in the future. I expect there to be a more easily digestible, practical introduction to vgo near it's release.
Yeah, and I imagine Go is used in context where you particularly want that.
Definitely show me when you've made some changes! :)
That’s nice. I thought about just adding that feature. Thanks!!
Posting/replying at top\-level for visibility... \&gt; You are assuming that dep was a failure and that it didn't influence rsc or vgo at all which i think isn't the case. Russ and Sam met regularly during this time. It could be that in working with dep meant that we got vgo as it is today and dep shouldn't be looked at as a failure at all. \- u/nemith Though I'm currently a fan of the course vgo would have us on, it seems evident to me that u/sdboyer is a hero in this matter, and I am thoroughly humbled by his contributions and continued advocacy for what he believes is a stable path forward. While I trust that the Go team has given consideration to Sam's concerns, I think it would have been healthier for the community to have had his objections filter through many more minds and conversations before this formal acceptance.
i would characterize it more as, "rsc has heard the words I've said, and simply decided that they don't apply because they're not convenient." folks will be able to judge for themselves in a couple hours, when the next post in my series is up. 
I greatly hope you're mischaracterizing his handling of this. Nonetheless, you have my full attention \(however little that's worth\).
it's just my perspective, of course, but sadly, that's my feeling. everyone's feels and attention on this matter! this is more than just another tool or language change - it's a ruleset for community interaction.
https://github.com/seriousnerve/Licensing-System/blob/master/Server.go#L100 You create the Server in the local scope of the function call, every time.
Yes, that context would be any organization with more than a dozen engineers/applications.
Would SQLite work? It's a DB, but it stores everything in a file. 
https://github.com/boltdb/bolt would an option as well, if you'd like to stay pure go
Literally just a username and hash? Why not just store the username on one line and the hash on the next line... It starts getting blurry what is and isn't a "DB" at some point.
Consider something like this: https://play.golang.org/p/41Gow_JZ7wa The Server manages the life of the same underlying http.Server. So when you start it, you save it. And when you shut it down, you are shutting down the actual server that is running.
Well, does it use SQL query's and such. I want to stay pure go, no DB.
Yes, well I did that and got flamed about how strings.contains isn't secure and I need to use json and maps. I tried the json maps strategy but can't seem to get it to work. Thanks!
You should definitely use a KV store like [Bolt](https://github.com/coreos/bbolt) or [Badger](https://github.com/dgraph-io/badger).
I do not want to use SQL statements of any kind. I am learning go, I do not want to learn SQL right now. If I can just store create a json file database, I would rather do that.
Uhh well JSON and maps have nothing to do with security; they are not any more secure than other kinds of plaintext. Just set good permissions on the file and you're good.
But...it would very unfortunate if they decided to go forward with dep because of the political concerns. In fact, I think that would be an easier route for the decision maker personally. 
I just want something that works. Our needs: - Per project GOPATH (or no GOPATH at all!). Vendoring is at the top level (ie under src/ - there is an open issue with dep to support this, but I cannot switch until it's resolved). - Repeatable builds (I was using one of the dependency managers that downloaded without vendoring that broke our build when google code shutdown and a sub dependency moved to github). At the time I looked around, gb did both of those in a 'good enough' way (and indeed still does - it's a shame it got abandoned) that sort of kind of inter-operates with the rest of the go tooling. To me (very much looking from the outside in), vgo works very much the way gb does, but in a 'officially sanctioned' way. Switching to it will be very easy for us (to be clear we have a rather small code base, just one project/exectuable with a number of sub commands so switching to another solution will not be a terrible ordeal) On the other hand, I could see switching to dep too, it was just a matter of which one gains momentum/acceptance (and before rsc's posts I would have said that was dep - the announcement of vgo was kind of left field, to me anyways). I remember Rails development before Gems were an accepted thing and bundler didn't even exist. The early days (years!) of bundler were turbulent to say the least and when it breaks even today it's painful to resolve, usually involving careful constraints being added or removed that to me seem like black magic.
There is no SQL involved in my suggestions.
For technical reasons or just because? If it's a technical reason well need more details. If you're choosing to limit your options (for what ever reason) then I can't really help. 
Yeah, it seems to me using TOML would let you easily read/write mod files programmatically in any language with TOML support. And it’s one fewer spec to learn. 
After reading the follow-up post, I think the argument is simply this: dep failing in scenario 2 is a feature not a shortcoming. This is the first time I have grokked this argument and it might also be what Sam has been trying to communicate. It makes me wonder if maximum constraints could somehow easily be worked into MVS and the go.mod file.
Some of us are only happy about some of it. Being able to work outside of a gopath will be awesome. Having a clean way to write "replacement" paths is great. Being forced to use inappropriate tags in source control is not great. Deciding that the nodejs leftpad insanity is where go should head is not great. Deciding that developers should not even be able to build the same source code twice and be sure of the same result is not great. Deciding that "build" should require network access is not great. Waving your hands and saying "corporations can go write some proxies and maintain them forever if they want to use go" is not great. Saying "open source projects are out of luck if they don't use Github" is not great. I'm a great fan of what folks are trying to do. I'm just exceedingly frustrated with some of the implementation details. 
[removed]
The case is to connect to a few database.
[removed]
I have a lot of respect for the work you did with dep and how you inspired the community to get involved. Just as a disclaimer :) With that in mind, I don't feel that your concerns with vgo were made as public as perhaps they should have been. It seems like most of your input happened behind closed doors and so there wasn't a chance for anybody in the community to back it up or perhaps even provide counterpoints. I can see that you're addressing this with the series of blog posts on vgo that you have been working on, but if the acceptance of this proposal is any indication, it was too late. I don't personally feel that the one post that _did_ make it out before this decision added enough to the discussion. I voiced my opinion on that blog post [here](https://www.reddit.com/r/golang/comments/8jappi/an_analysis_of_vgo_sdboyerio/dz0xfcz). I wonder if things would have been different if your discussions with Russ happened in a more public forum.
I've made some of the changes, the only one I'm a bit iffy about is the Problem() function. https://gist.github.com/fharding1/f4a0ccb06d0de90ff971ad3c02ed6b80
Agreed, but at the risk of getting caught up in semantics \-\- refresh tokens are an OAuth2 concept and it would be another roll\-your\-own thing\-\-which is what we are trying to avoid\-\-unless implementing OAuth2. That said, setting up an OAuth2 provider is not exactly the easiest thing in the world, and refreshing a token wouldn't be the riskiest thing since we are already assuming valid auth, so... do what you need to do, OP.
Yeah, that guy has no idea what he's talking about.
It's part of the fork. Given type S struct { X int `protobuf:"varint,1"` T time.Time `protobuf:"bytes,2"` } and import "githib.com/mistsys/protobuf3/protobuf3" fmt.Println(protobuf3.AsProtobufFull(reflect.TypeOf(&amp;S{}))) emits // protobuf definitions generated by protobuf3.AsProtobufFull(main.S) syntax = "proto3"; package main; import "google/protobuf/timestamp.proto"; message S { int64 x = 1; google.protobuf.Timestamp t = 2; } which can you can feed into protoc. Since it's all derived from google's code, it's public.
Either you should motivate people or shut your mouth off. Someone may not know something, that does not mean the end of the world.
I fixed your code [1] the program writes the credentials into a file called _"database.db"_. {"admin":{"Username":"admin","Password":"eWMLR/8rxVPuV9EvjJ+Ejki/qg4d8mOjGLKjXoVat2I="}} [1] https://pastebin.com/raw/3BE61d72
Ah, many of us did not. But it does not appear that there was any meaningful discussion about the proposal, just a sales pitch trying to convince people to accept it. There are plenty of posts discussing it, but most aren't "complaining", because there was an expectation at that time that problems would be worked out, not kinda steamrolled. I haven't seen any objections since the acceptance that I did not see before. 
You can thank or blame me for this. I just added Dep to our swagger generation template today. 
There was so much wrong with that, I don't even know where to start.
Developed it!! See https://github.com/Code-Hex/sqlx-transactionmanager/tree/master/tm
You make good points and I did engage in a bit of hyperbole. (Downvoters, stop it, he's contributing to the discussion. He doesn't have to agree with me.) I'll break down my biggest concerns: Inappropriate tags: Long term projects already have tags. In some cases, they already have a versioning scheme. vgo requires semantic versioning, which may not be the strategy these projects have used in the past. Not only will they be effectively required to use semantic versioning in the future, but their past version numbers are now a problem. Leftpad: Leftpad-syndrome is an extreme pathological case. But the basic problem is tons of small libraries that depend on each other. I mostly agree with Pike when he says "a little copying is better than a little dependency". The "download it from the internet"–style of build tends to lend itself to a little dependency. As long as we don't slide down the slope, it's not a major issue, but I still can't really approve of greasing it. Build the same source code twice: This is a *huge* issue, though. If you build the software once, it will download the sources from the Internet. However, it assumes that those sources cannot change. They obviously can, though. Another person who downloads your code and builds it later can wind up with a totally different version of the code. This is unlikely to happen normally, but rather as the result of a malefactor who gains control of the source code repo. Critically, at no point is there a way to validate the code. Build requires a network: CI servers should not generally have upline internet access. It's a security vulnerability and it should generally be unnecessary. And even if they have it, it shouldn't be a requirement. It should be reasonable to provide a folder full of code and expect that it builds. Corporations need to write proxies: I exaggerate slightly here. I suspect that the community will provide a high-quality caching proxy that works nicely. But my point about hosting stands. The code has to live somewhere. If we are encouraging folks to not vendor code in their repos, the caching proxy has to survive for as long as you want your code to compile. And if your network team has an outage, you can't build anymore. Open source and Github: Again, I exaggerate a bit. But the proposal will require a go-specific hosting regime not provided by ordinary source control. Github will surely provide the required format, as long as you obey some rules about how you structure and tag your code. But folks that have their code served via straight git or, for reasons probably beyond their control, are still using svn. Those folks will need to stand up a server with the required package format and maintain that server indefinitely. Open source projects often have very few resources, so this is something of a burden. (Some open source projects are also not comfortable requiring that contributors relinquish the freedoms that Github requires that they relinquish. I can respect that.) There are some partial answers to some of those, but mostly I've been hearing, "Your use cases are not majority use cases, so your use cases don't matter." I understand that that may be how it is, but people should realize how it can be frustrating.
Vendoring dependencies is still going to be possible though, so you can vendor and get 100% reproduceable builds without an external proxy or network access.
Version ranges and sigils are a pain to manage. The proposal didn't use them, favouring instead a system that derives the semantics from the import path. That system has its weaknesses, but it does avoid complicated package definitions that very often create conflicts. json has no comments and isn't great for people. yaml is deeply annoying to parse and has way more features than it needs. toml isn't too bad, imo, but I can see how it would be annoying to have yet another format. SAT solver... If the compiler requires a SAT solver to figure out what your dependencies are, you have effectively no hope of figuring them out yourself by looking at the code.
Well, goJay is 66&amp;#37; faster \(1194096 \* 100 / 1802579 = 66\), but does result in more allocs in this case. Regarding the Encoder, there is a lot of room for optimisation in goojay, for which I will work on. May I have an example of the JSON?
&gt; @appengine for instance. That is false. I'm a library maintainer and AppEngine still holds me back from using aliases.
Are you sure you know what a hash is? https://en.wikipedia.org/wiki/Cryptographic_hash_function
Cool :)
Fwiw, I believe “proposal accepted” doesn’t mean “this is 100% going to happen”. Afaict, it means “go ahead, this is now the plan, but we’ll see if it works out in the implementation phase”. 
Really sorry you're feeling ignored, Sam :( . I know how hard you've worked, and I know you believe dep is the better solution. From what I've seen, it feels like there's misunderstandings on both sides of the fence. Both sides seem to be complaining that the other one can break when a new dependency is added to a working system. Which, yes, is absolutely true. That's unavoidable. From watching Russ' talks, he says "look, dep takes the newest and things break!" all the time... but in practice, dep uses a lock file, and doesn't take the newest of anything except when you first add a dependency, at which point, you have to choose a version, and after that, it's locked. And yes, at that first introduction of a new dependency, things can break, but.... so? That's true of any dependency management system. From looking at posts arguing against MVS, the explanation goes that you can't define a maximum version you work with... but you don't need to, vgo uses the minimum applicable version. That'll always be the same unless you add a new dependency that defines a higher minimum version that happens to break with something existing. But again, this only happens when you change dependencies. It can't "just happen" (and I think it's really unfair of Russ to characterize dep as failing this way). So, I see these two failures as very much the same. Someone goes to add a new dependency or update an existing one and stuff breaks. The "easy" way to fix that is to not add the new dependency. It introduces incompatibilities... that has to get resolved somehow, and that means a human. I guess the hard part comes if the breakage isn't obvious until later (which is certainly possible with subtle behavior changes). But again, this seems like the same problem for both systems... the software is using what it thinks is the correct version, but there's a breakage. Some human has to fix that. There's no automatic way to do it. There's a final thing that I think is kind of funny - SIV semantic import versioning. This is just GOPATH repackaged with a new name. It behaves exactly like `go get` in this way... every unique import path is a unique package. I saw one of your criticisms of SIV that two versions of the same package could get imported and cause problems... but that can happen today, by the exact same mechanism. you can import gopkg.in/yaml.v1 and gopkg.in/yaml.v2. There's absolutely no way to fix this problem, and we shouldn't even try. A package manager can't know that v1 conflicts with v2. A package manager can't even know that v1 is the "same" package as v2. By definition, they're different. Hell, who's to say someone didn't rename their package for v2, so it's foo.v1 and myfoo.v2? But then again, I've always said that versioning was not that big of a deal using GOPATH, since each package import path was logically a completely different package, just as foo/v2 is different from foo/v1 in vgo. The main problem was locking down a repeatable build, which is what godep did way back in the day. The added feature of having a minimum version is necessary, since you can always add functionality to the same package. However, clearly, you've thought about this more than almost anyone else, and I await your next blog post with bated breath.
haven't really had time to digest this because I've been heads down know gdpr work. I'm sure I'm not the only one.
"mirror them internally". That doesn't work in an open source project. Not really. Your only real option is full vendoring, which means losing all tool access to things like updating your dependencies. Stuff that godep does nicely now. Right now, there are a number of options for managing your vendored directories. vgo is starting off by killing them all in a single stroke by prohibiting vendor directories in library and application folders. You get a single version of each library at the module level. And yes, this is still the best solution. I just wish the best solution wasn't such a pain.
One thing I think I might disagree with you on is that lockfiles are effective for showing what they should show. In my experience, a third of a team adds them to ignore, someone might add to assume unchanged, and most the rest will resolve merge conflicts with the remote version. And some projects (even Google's Material Design) will do tags out of order or take a tag back. It doesn't mean I don't like lockfiles, but it means I can appreciate both friends and foes of them.
It’s easy to mirror for the sale of preventing a rogue actor from modifying. Just fork the repo and keep it on GitHub or Gitlab or wherever else you’re hosting your project and reference that version. Then if you want to update, pull the upstream and push to your fork. It doesn’t really have to be “internal”, but just in your control. 
Right. I don't really like lockfiles either, but they definitely solve some problems. I would prefer to see a robust set of tools for full-source vendoring. I'm exceedingly concerned about the "download it silently from the internet" solution that doesn't show you diffs. If someone silently replaces a previous version of something with the exact same number, there is no way for go to know and alert you.
Dep was not getting any closer to usable. It was so slow that I was unable to involve it in any workflows, and it was full of non standard library dependencies, so I knew it couldn't be merged anytime soon, but issues asking about plans for that were unanswered. I personally saw vgo as an answer to lessons learned from dep not really being better than npm--and perhaps worse. Go is unique, and this is an interesting way to make it stand out. Dep was okay, but it wasn't a waste. If it had been fantstic, it would be the actual solution now.
&gt; Inappropriate tags ... Not only will they be effectively required to use semantic versioning in the future, but their past version numbers are now a problem. For the first part: standardising on a single tag format is good, not bad. And for the second part: just add semver tags in addition to the existing tags. &gt; Leftpad ... As long as we don't slide down the slope, it's not a major issue, but I still can't really approve of greasing it. How does vgo make this situation worse? &gt; Critically, at no point is there a way to validate the code. [Yes there is](https://research.swtch.com/vgo-repro): &gt; When vgo downloads each module, it computes a hash of the file tree corresponding to that module. That hash is also included in the binary, alongside the version information, and goversion -mh prints it. &gt; Build requires a network ... &gt; Corporations need to write proxies ... vgo supports vendor directories. &gt; Open source and Github ... the proposal will require a go-specific hosting regime not provided by ordinary source control Not true. vgo still supports vcs. 
Right. And that kinda works. It at least gives you diffs of updates. However, vgo doesn't work off of source control, it works off of magic zip files hosted in a particular way. It's expected that github will update to support it, but other systems like gitlab and svn may not. So sure, if you use one specific tool, you'll probably have an option there. Though practically, storing those zip files on a server somewhere accomplishes the same thing.
Ah! Yea. That could make it more of a pain. 
Yeah, there's an awful lot of code in some libraries, and just as humans lose the ability to understand all the dependencies they are compiling together, hackers have had a grand time exploring how source code might be able to hide little surprises.
If you make a buggy release, just tag it +deprecated, and the tools will handle it. https://github.com/golang/go/issues/24031
Right. And even with diffs, it's quite possible for a hacker to slip something in. But at the moment, you have a fighting chance. When vgo automatically downloads transitive dependencies, if one of those dependencies comes from a server that has been compromised, you'll silently get a compromised copy of the source, even though the version number is identical to a version that might have been carefully tested and vetted.
Yes, The reason for using multiple DB is for both scale and SPOF measures. Some of the recent cloud-based technologies automatically do them. But, since not all services that are always running are in an environment that supports automatic scaling, there are cases where processing for switching DB is performed on their own.
You could also just add an "exclude" on that version to your go.mod.
It might make it cleaner to have the README show only the lastest news item and link to a NEWS.md file for older news. After that, if you decide upon a format for something and need help, we can help fill things in. 😎
Official? What about dep?
Not sure what you're referring to with standard tools not working with vendoring - worst case you can always delete it, use that tooling, and revendor. On vendoring for libraries, lack of support for it isn't a design decision unique to dep. Ultimately the application should have the last word on what versions of dependencies they want, with libraries in an advisory capacity. &gt; And if you do write a bug, you're required to drop everything fix it, even if it's not the top of your priority list at the moment. If you don't do this, library authors cannot depend on you More specifically, if you write a regression - not just any bug. And if you can't do it, you're right, library authors can't depend on you if you release regressions and don't fix them in a timely fashion, keeping in mind that maybe the fix is to just pull that release.
https://www.youtube.com/watch?v=XdofmoYcJNE
&gt; if one of those dependencies comes from a server that has been compromised, you'll silently get a compromised copy of the source, even though the version number is identical to a version that might have been carefully tested and vetted. No, that's what vgo's build verification step prevents by comparing the hashes: https://research.swtch.com/vgo-repro
&gt; Another person who downloads your code and builds it later can wind up with a totally different version of the code. This is unlikely to happen normally, but rather as the result of a malefactor who gains control of the source code repo. Critically, at no point is there a way to validate the code. Actually, having dealt with a lot of vendor versioning, in most cases this is not malicious. In most cases it's some single developer not understanding versioning or "oh, I'll just fix that because it's ugly and release as the same version". In the world of shared libraries on unixy systems this happens all the time. So much so that some systems that roll their own packages have entirely given up following the vendors version numbers and use their own. This is my biggest problem with vgo. The fact that semantic versioning is seen as some kind of solution while it's nothing more than wishful thinking that everyone should be better people. If a project has the discipline to follow semantic versioning correctly they probably also have sufficient experience to know from their own pain why it matters and sufficient experience to know what major and minor changes actually mean. Because of that those projects are also rarely a problem when being a dependency. Semantic (or any other) versioning on a large scale doesn't work unless there is a third party arbitrator. 
Oh yeah, thank!
Only if you explicitly add the modverify file, and then only if it isn't a newly added dependency, especially a transitive one. 
Anecdotally: Before vgo and all the drama, it was my genuine impression that Dep was an official tool. Same goes for all of my Go-proficient colleagues (of which I'm counting at least 4). We all thought Dep was the future. We were all looking forward to the day when Dep would be finished and part of Go. Now, I'm someone who doesn't read the Go mailing lists. I have no particular insight into the development process of Go or of Dep. I don't read Sam Boyer's blog, either. I don't know about my colleagues, but I suspect it's the same for them. We just use Go. So the fact that *we all had this impression* must mean something. You will find a lot of people in these recent threads that have the same reaction. It's pretty evident, without assigning blame, that everyone's messaging has been unclear. It's also apparent that the Go team was not aware of how muddled their messaging was, or didn't care enough to discourage people from thinking Dep was an official tool. The mailing list exchanges I'm now reading are surprising to me. 
Serverless: it is just someone else's cgi server.
&gt; It’s also a really bad idea from a security perspective to always pull HEAD of a library direct from a source. If you don't trust HEAD of your fork, what can you trust? If you haven't forked a library, you're not really using the tools as they were intended. Although it is understandable why you might not want to do that.
I think Dep was experimental. They took a lot of what they learned from Dep and created this proposal.
I believe he was just trying to help. Feel free to ping me if you continue to have issues with exec, I just went through a fairly rough time trying to deal with some nuisances with ffmpeg and backgrounding exec. Honestly though, there's no need for the hostility, we're all here to help man.
They have said that they migration should be easy. Vgo will happily read your dep files to work out dependencies, along with other formats.
A prototype that lead to vgo.
Do I need to create an issue at github.com or can i send my 'ideas' to you by directly? :)
Thanks! Today I tried of /uber/zap and found that a tasty :) If I understood correctly the main paradigm of Golang is looks like: 'Stay away from direct I/O'. Is it a right?
You may like this [one.](https://github.com/shuLhan/beku)
&gt; Per project GOPATH (or no GOPATH at all!). I built a tool for above use case. I am quiet unhappy using `go get` and `go clean`. I can't see what depends on what when using `go get`, and not all dependencies automatically removed when using `go clean`. So, [here it is.](https://github.com/shuLhan/beku)
I think your doing yourself a disservice by starting with a framework. There are lots of fantastic libraries you can add incrementally, understanding ech bit as you go. Start with basic http server and maybe gorp or one of the other orms. Add code reload with gin, more expressive routing with chi, handle sessions with gorilla. Have the problem first and find the best of breed way to solve it. revel jumps you in at the end and it's hard to know what's happening or which docs to read when it breaks. Enjoy the clarity of knowing what your server is doing all the way from main to response in a way that only go provides well.
&gt; conf loading I always use a dedicated function for it, is your code too monolithic to make it possible?
While true, TOML isn't part of the standard library, and I think it would be slightly more complex to pull into the standard library than writing the new, fairly small, custom syntax. I'm not the biggest fan of TOML in general, but it's use in dep was totally fine, and not ugly, like TOML can end up. I would've been fine seeing TOML be the format for vgo, but ultimately it's a minor issue, and I can understand the reasoning behind the choice not to use TOML too.
I meant more in the sense of utilizing the config. A separate package loads the config. It's stored in something a bit more complex, but imagine a map. Now when using it, you want to fail gracefully, so each use of the config becomes something like `confValue, ok := getConfValue(confKey)` then check for OK, some fail, ... call some setup with that value (e.g. logger), that can fail, add a check, etc.. 300+ might be too big, it's more in the area of 100 for me, but I definitely need to turn off gocyclo for main.
&gt; Sam basically said that dep was going to be part of the toolchain. Exactly. &gt; By that point work on vgo had to have already started so... was Sam being kept in the dark or did he know and just went on stage and said "dep is the future" anyway? [According to Sam himself](https://sdboyer.io/blog/vgo-and-dep/), he has been meeting regularly with Russ since December.
&gt; You can't add upper bounds without introducing SAT. That is untrue. You can introduce upper bounds, ignore them for the actual solving, but croak if the solution violates the constraints (instead of back-tracking and trying something else, which is where the SAT solving comes in). So it's totally possible to get this supposed feature with MVS, if you want to.
I found an interesting solution for my landscape. It's 'gorilla/handlers' package. I updated of my sources by two lines \(without an 'import' section\) :\) But I wish to write something self\-contained.
I'll admit, when I read your other comment I thought you were talking nonsense, but you do have valid points here. That being said, I think as you already can tell, most of these issues are not too likely to be a problem. I hope that we do have a central repository at some point to get packages from; one that keeps any version that is submitted permanently, even if re-tagged - I think that would solve a few problems there to start with. I also think people will find their way around CI servers requiring internet access, internal proxies could help, but you could also package up the place where vgo caches the packages too.
Without going into any security related debate, the "best" way surely depends on your scenario. I made very pleasant experiences using the built-in gob package: https://blog.golang.org/gobs-of-data. No database, no JSON mapping, no nothing. Extremely fast, which should not matter in your case retrieving just a username and a hash.
This is one of those days when I think a lot of people forget Go is free, as in, you don't have to pay for it. It is important to a lot of people that Go and vgo are easy to use, but it doesn't seem worth getting upset about them choosing a different algorithm than what people might be used to. I mean, if it ends up being horrible, we can always change it to use sdboyer's suggestion later.
Even if we assume it's going to be just as fast and easy to use, you still have the issue that is maintaining extra tens of thousands of lines of code for the solver. I'm not saying it's a dealbreaker, but it's a major disadvantage in my book.
[removed]
You can do either :D
What you are leaving out is the context of why folks criticised your implementation. The problem was that you stored an unstructured file format of multiple username and hashed password combinations, but your security check consisted of seeing if the username is anywhere in the file, and the hash is anywhere in the file, with no correlation, or even word boundaries. The suggestion to use a map with json encoding was the smallest change you could make to improve your check. At least with a map you can check an exact key to an exact value. 
The confusion with the word "security" is seemingly meant to be about making sure the exact username and password combination match, as opposed to the less secure approach that isn't really referenced in this post 
Can you implement of sending a content if the file will been changed by size? In my minds that can be easy implemented by gonna get of file size at starting application with the next comparison after some time. This trick can creates a new space for usage of your software for notifications :D
Thanks chewxy. I'll see what I can do with your recommendations.
On an online judge (in easiest terms) is used to check and grade contests' answers in a competitive programming contest.
Russ gave a talk on vgo. I would watch that. 
I think that dep failing is indeed the feature, at least with a minimal implementation. If there are conflicting version requirements, you can't build a working system; the only question is whether the build tooling tells you or just generates something that doesn't actually work. Having the tooling tell you up front is more friendly.
There's another case, similar to case 2: helm is being used in your project, and another dependency in your project requires grpc &gt;= v1.4.0. The difference here is that the developers of helm have no chance to detect this situation on their own because it doesn't exist within helm's own scope. In this situation their publication of a maximum grpc version is a note to everyone else saying 'don't put this together with ..., the result is broken'. 
We should stop speaking about "the community", nobody represent "the community". Being part of "the community" I'm a lot more confident with vgo's proposal than dep-cargo approach. Worse is better (tm). I believe without Dep Vgo will never be, but now stop the fud and let's work on the implementation of vgo and let the peaceful time to think about a future proposal for versioning in Go 2.
I think the vgo situation is better. In both cases, your code is broken until you reconcile Helm to the new gRPC, but in the vgo case you'll only have the \&gt;1.8 requirement if you explicitly add it at some other level, so it's less likely to happen in the first place.
FWIW, I've had [dep silently fail and make unbuildable solution](https://github.com/baltimore-sun-data/voter-guide-2018/commits/022d8e0e1e77a8f52aeb75e02ad6d654e4c863e8/Gopkg.lock) before. In that case, I think it was because Hugo changed its URL and dep got confused by it.
He didn't say multiple.
You didn't get flamed because of the string working, but because your usage of hashes and usernames was not secure.
I agree (I didn't understand this point at the time). Note, that you can still do the rollback, though. FWIW, I'm still skeptical whether this is going to cause significant pain in practice, given that it would require my project to do a release with `grpc &gt;= v1.4.0` *after* helm discovers the incompatibility but *before* they or grpc have a chance to fix it. And should it turn out to cause pain in practice, [we can still retrofit upper bounds](https://github.com/golang/go/issues/24301#issuecomment-390926169) to vgo with MVS.
&gt; The slowness doesn't manifest as visible or problematic for users. I disagree. I personally had problems with the SAT solver in apt, for example.
Oh, forgot to mention it since I only use OSX. I've placed it in the README now. Thanks!
&gt; if you could get gRPC to release a new version identifier That's a mighty big *if*, and I think this is one of the things that makes people nervous when it comes to vgo: vgo seems to require pushing more of the version management problem into the human sphere, and that presents a unique set of problems that ripple out through chains of dependency maintainers and consumers that haven't been faced before at scale.
They also are generally assumed to fall under the Go 1 compatibility guarantee (if maybe a slightly weakened one), so the issue is generally less pressing.
&gt; Deciding that the nodejs leftpad insanity is where go should head is not great. What do you mean by this? &gt; Deciding that developers should not even be able to build the same source code twice and be sure of the same result is not great. That is the opposite of what vgo is doing. Reproducible builds are one of the main features of vgo. &gt; Deciding that "build" should require network access is not great. This seems super nit-picky. At best, it's an issue of wording. You *will* be able to build Go software without network access, if you have all the sources available, just as you can now. &gt; Waving your hands and saying "corporations can go write some proxies and maintain them forever if they want to use go" is not great. Saying "open source projects are out of luck if they don't use Github" is not great. Neither of those is being said.
&gt; But it does not appear that there was any meaningful discussion about the proposal, just a sales pitch trying to convince people to accept it. I disagree with that sentiment. All the criticism has been discussed at great length and some changes where made. It's unfortunate that *new* criticism is surfaces now, months after the proposal has been published. But you can't just straight out claim that there was no discussion, because you are unhappy with its outcome.
We should all just accept the fact that no solution will make everyone 100% happy. Everyone's pretty opinionated when it comes to dependency management, but just because vgo was accepted that doesn't mean you have to stop using other tools. Personally, I'm excited for vgo (although I still don't understand all the details as I haven't read much about it since the initial blog post from Russ) mainly because I dislike dep.
There's nothing really to change it to (though there might be [one day](https://github.com/golang/go/issues/20982)). If you want to use CGo (which that lib uses) you have to use gcc. Install http://tdm-gcc.tdragon.net/ and make sure gcc.exe is on your PATH is one way.
&gt;Also seems most unhappy folks waited to air their views on proposal till proposal was accepted. When vgo was announced apparently out of nowhere, blowing dep out of the water, I concluded that Google was going to ignore the community and do whatever they wanted. So I haven't wasted my time offering feedback on vgo, I'll just deal with whatever they've decided when they ship it.
What are the key differences? 
Thanks! How will it be different?
If I have gcc.exe in my environment variables PATH, I should be able to run gcc.exe in cmd.exe no matter where I am in the console? Isn't that the point of environment variables haha
good stuff
URL changed to [https://www.elliotdwright.com/2018/02/27/how\-i\-structure\-some\-of\-my\-projects/](https://www.elliotdwright.com/2018/02/27/how-i-structure-some-of-my-projects/)
Reading the vgo-intro I concluded exactly the opposite ! I'm at ease that the Go team came back to the Go community instead of followed the community around Cargo's like approach. Lets try it at least.
I think the best thing to do is try to do take the tour of vgo and play around with it yourself. The posts that Russ wrote about vgo are really informative and well written (but a bit verbose perhaps): https://research.swtch.com/vgo
refactoring
One issue is that you are attempting to connect to a postgres database but specifying Mysql specific options. postgres doesn't have an InnoDB database type. 
I would think that if I set up my PATH correctly I could type gcc in the console and get some feedback anywhere in the OS, that wasn't the case and it may be because I added an entry to the path that wasn't the directory gcc is in, but gcc.exe itself e.g., C:/Mingw/bin/gcc.exe instead of C:/Mingw/bin/ . I'll try this out when I get home and let you know how it goes :) thank you
hmm no, since go 1.9 is now supported by appengine. alias is not your problem https://cloud.google.com/appengine/docs/standard/go/release-notes
Yes, dep was a failure and didn't influence vgo at all. And the debate around vgo when it went public was a joke, there was no debate, only a sell pitch and marketers like TheMerovius.
[removed]
we'll still be using glide because TFS hosts git repos in a completely different format than what Go expects and the new tools don't provide a reasonable way to override the repo location with the import path.
This is a really sad day. Your work is exceptional for dep (part from the name 😆) - I will submit a proposal to rename Go to GoRSC
Yes rename, also move, introduce variable. GoLand will also automatically will import. But really JetBrain's "idea" IDEs refactoring is the main reason to use them. quick google search result: https://blog.jetbrains.com/go/2018/02/15/goland-2018-1-eap-3-move-refactoring-better-test-runner-go-build-quickdoc-and-more/ As time goes by, they will add more of the refactoring tools they have in Java. In Java you can extract a class from a method, adjust the function parameter order (I think you can do this in GoLand), implement missing interface methods (I think you can also do this in GoLand). At work I'm not allowed to use IntelliJ because it costs money, and I haven't done any personal go projects for a few months, so I'm not an expert. But the reason I would use GoLand instead of VS Code is if I were working every day in go and I wanted the nice refactoring tools. (And my boss wasn't such a cheapskate)
I like how the sample image is for a song called "Suck It and See"..... lol
Is that why the Map_Tables() function doesn't seem to work? Cause here's what I got in the User model right now. It's in the same package as this init so it should be able to access the global dbmap variable: func FindUser(number int) (*User) { var user *User obj, err := dbmap.Get(User{}, number) user = obj.(*User) if err != nil { log.Print("ERROR findUser: ") log.Println(err) } return user } Yet the problem stems from the fact that `dbmap.Get` has a nil in the `User{}`, despite me adding that table in the `Map_Tables()` function in the init model.
Vim go can do most of this. It's amazing how much you can get from a free text editor and use so little ram. Not for everyone I'll admit
/r/golang is not your personal Windows support channel.
No ... not sure where you get that idea from. I think the trick is to not re-invent the wheel.
All blog posts from this guy are duplicates from the original docs
It's a tool for Go developers and this is a subreddit for Go developers.
What is /r/golang for if it's not for asking Windows questions related to Go?
it's a "commercial tool" for Go developers. It's an ad.
&gt; Is that why the Map_Tables() function doesn't seem to work? Yes. You're opening a connection with a postgres database but telling gorp you're using MySQL.You should be doing something like the following if you're using gorp with a postgres database: dbmap = &amp;gorp.DbMap{Db: db, Dialect: gorp.PostgresDialect{}}
You're trying to cast obj to a *User before checking the error. dbmap.Get is returning nil for obj and an error in err. Make the err != nil conditional to right after the dbmap.Get call.
&gt; Just look at the imports. Oh, the imports, who gives a fuck? do you think rsc coded vgo in 3 days?
duplicate of https://www.reddit.com/r/golang/comments/8lbbxw/runtime_support_for_debugger_function_calls/
[removed]
So you're saying hash it just to make sure a clever user didn't post a non-hash?
Yeah, I agree they post very often, but they're adding new features very quickly, and I think something like vgo support is worth a post. Disclaimer: I'm a sworn VS Code user.
Okay, now I'm getting another error I already got last time in my controller. I changed the FindUser function to this: func FindUser(number int) (*User) { var user *User obj, err := dbmap.Get("users", number) if err != nil { log.Println(err) } else { user = obj.(*User) } if err != nil { log.Print("ERROR findUser: ") log.Println(err) } return user } Now my Index() function in the user controller is acting up and giving me this error: `runtime error: invalid memory address or nil pointer dereference` This is the Index() function: func (c Users) Show(id int) revel.Result { user := *models.FindUser(id) // error happens here return c.RenderJSON(user) }
I personally posted one link to the IDE blog last week as I thought that having support for vgo in an editor would be something that people would be interested in. I cannot control what other Reddit users posts and when.
Yes, we make money by selling the IDE, but that helps us bring features that users want and need to use for their day to day work. Considering a lot of people also do get paid work with Go, or work on projects that make money, I don't see how this is any different. We do offer the IDE for free for students, teachers, user groups, open-source contributors, and so on. As a sign of respect to the community, I've tried to limit my posting habits only to useful links (outside of the IDE itself) or very rarely. In fact, the vgo post was my first one about the IDE in the last six months, you can see my history here: https://www.reddit.com/user/dlsniper/posts/. I hoped that the post would be relevant to the community given that it also happens that it's the first editor to integrate with vgo and allow more people to explore it. If you have any suggestions on how to make the posting I publish more relevant to the community, I'm happy to hear. Otherwise, I cannot control what other Reddit users choose to share and when. Thank you.
[removed]
It's only my suggestion based on mine littlr experience of observing communities of Golang developers at Github.com. IMHO, most of developers follow by ideas of cloudian integration avoiding of features by a platform (OS in this case).
I'm a newbie :)
Sorry!! my bad:( Should I remove it ?
Is the next post up yet? :)
GopherCon promises to be very interesting this year.....
Eagerly waiting, take your time and please do move forward with your idea of package management. Dont let this discourage you. I believe it will eventually find its way, if not today. Keep up the great work!
You're asking about environment variables in Windows shell. Only coincidental that go is related. For future reference: http://www.catb.org/esr/faqs/smart-questions.html
Great work! I'm not an expert, but I guess this optimization could benefit reverse proxies implemented in Go. This includes very popular projects like Caddy and Traefik.
Seems like a conflict of interest. If they want to make money from an ad they should pay for the ad like everyone else. I would rather see things like I made this in golang, stuff people made in golang. I don't care for every feature of every ide popping up on every programming language sub I'm subscribed to. 
You are trying to use Go but you don't even know the basics. Learn the basics. var user *User this is wrong because you didn't assign any value to user. replace it with user := &amp;User{} or user := new(User) But anyway learn the basics before using ORM and shit because you can't even correct basic errors.
&gt; This is one of those days when I think a lot of people forget Go is free, as in, you don't have to pay for it. It is important to a lot of people that Go and vgo are easy to use, but it doesn't seem worth getting upset about them choosing a different algorithm than what people might be used to. I mean, if it ends up being horrible, we can always change it to use sdboyer's suggestion later. I don't pay for Java, PHP, Ruby, Python,Node JS either. And I don't need to constantly lick asses of the core teams like they are doing me a favour because "it's free". Go core teams doesn't work for free, they work at google and are well paid.
Well again, I'm trying to learn this as I go from an already semi-established project someone gave me to finish. Plus, I already got that error down and now I can actually access the database without any errors. Well, besides one really weird one, but it had nothing to do with what you said here. I didn't have to change the `var user *User` at all and it still runs. I did that because declaring that var there helped fix another error I had when I just did this: `user := obj.(*User)` where the return statement didn't know what user was cause it was declared inside the if statement (or at least I think that's why it couldn't find it). 
This obviously omits and misinforms the casual reader about the reality. About 4-5 months before the GopherCon moment mentioned in the blog post, Russ clearly communicated that dep won't be merged in the main Go tree. Furthermore, he asked Sam, and everyone else to stop spreading this misinformation. As a result, all the community was mislead by the GopherCon talk and, later, by the FOSDEM 2018, talk on dependency management. It's all public here https://groups.google.com/d/msg/golang-nuts/PaGu2s9knao/Bq4vmFh7AgAJ and has been for a while. More over, according to someone that worked in this special dep team, the code for dep was published internally just 2 weeks before the public release. And the signs were clear that a SAT solver/gps is being pushed forward despite all calls for not doing so. It's shameful that this became a political argument and people try to divider the community and spread only half truths.
&gt; This, and tools like dep can still exist alongside versioned Go if that doesn't change. no because vendoring is going away.
[removed]
I don't think that's true any more. I think that was proposed and then everyone made a big fuss and Russ realized vendor can be very useful for open source projects, and so I *believe* it can still exist. Possibly only at the top level... which, honestly, if you have multiple vendor directories, you're a masochist.
I spoke with Russ about the state of dependency management back then and he never even alluded to anything as described here: "He made a comment that he could do better if he went off on his own and built something.". I don't know him personally but he never gave me the impression he would say that. This is a pointless attack on a person, it's a shame. If vgo/MVS are so bad, why weren't the previous posts made the second day vgo became public?
I'm the one creating FUD not this innaccurate post and all the attacks that have been made in the past 24 hours? All I'm saying is read that post from way before GopherCon 2017 happened and make your own mind on reality. This is not the leadership example I'm expecting from people I respect.
&gt; This is not the leadership example I'm expecting from people I respect. On this point we are in complete agreement.
https://github.com/golang/proposal/blob/master/design/24301-versioned-go.md &gt; Disallow use of vendor directories, except in one limited use: a vendor directory at the top of the file tree of the top-level module being built is still applied to the build, to continue to allow self-contained application repositories. (Ignoring other vendor directories ensures that Go returns to builds in which each import path has the same meaning throughout the build and establishes that only one copy of a package with a given import path is used in a given build.) 
[removed]
&gt;I can say authoritatively that this is a fundamentally incorrect retelling of history Linked email thread looks like the authoritative source. [https://www.youtube.com/watch?v=5LtMb090AZI](https://www.youtube.com/watch?v=5LtMb090AZI) is also public. Can you provide sources to support your argument? Can we move from emotion\-based post\-truth to facts? &gt;Please stop commenting on this topic, you are spreading FUD and creating conflict. There are so many things wrong with that segment that I don't even know where to start. Typically, I would report this, but you are one of the moderators. Is it a patient, thoughtful, respectful and charitable behavior, or is it a destructive one?
literally read the next 4 words, dude &gt; except in one limited use
[removed]
Interesting quote by RSC: &gt; In particular, I agree strongly with all of these decisions in dep: &gt; &gt;- Manifest file listing version requirements. &gt;- Lock file listing exact versions for a reproducible build. &gt;- Version control repo as project granularity is good. &gt;- Calling the group of packages released as a unit a "project" is a good name to establish. &gt;- Implementing coordination with the build by populating vendor is clearly the right implementation. Seems like in March 2017, he hadn't thought of MVS yet, so he was still onboard with lock files. I think the long and the short of it is that by mid-2017 it was clear dep was never going to become 1-to-1 a `go dep` subcommand. The code quality wasn't there and the Go team (ironically) wasn't comfortable with vendoring in a bunch of things like TOML decoders in the core Go tool. So dep was going to be rewritten to some degree. The surprising thing is the degree to which the inevitable dep replacement has tossed some core dep features like the GPS SAT solver and the lockfile while introducing new experiments like MVS and SIV. Honestly, I think there is too much drama around this at the moment, and it would probably be better for vgo to wait for Go 1.12 than to piss off the community by rushing things into Go 1.11. Still, I don't think it's fair for vgo critics to act like there was no indication that dep wouldn't just be rolled into the go command. 
I think that merging vgo as experimental is in line with the previous experiment, the vendor experiment. This allows pushing more package authors to version their releases, which is going to be good for the community, regardless of the thing they'll use to get their dependencies. We would also have more time to test and understand this while using it in real cases rather than in toy examples of what obviously works or what obviously breaks. Go 1.12 as a final version acceptance can be moved later on, much like we had vendoring change spread over 3 Go releases. I understand that there are pros/cons to MVS, gps, apparently gps2, and whatever else may come along. But I think that after 1 year of testing dep, we can also give vgo a chance, no?
But interesting not the one built into the standard library via `net/http/httputil`
[removed]
So the situation is Helm is working fine with gRPC until gRPC releases 1.5, which breaks Helm. In the dep world they'd change their depenencies to require gRPC &lt;=1.4 and cut a new release. In the vgo world they'd report the bug to gRPC and either gRPC would fix it and release 1.5.1 or Helm would fix their code and cut a release. Either way it is broken when gRPC is released. Either way there is an obvious path to what needs to be done. Either way the only workaround to avoid issues in the time-span with broken builds is to vendor your dependencies. 
Why doesn't vgo support two-digit versions, such as `v1.2` instead of `v1.2.0`? Seems easy to add and more intuitive and practical to me.
There are some interesting notes from /u/rsc in the blog post comments.
[removed]
[removed]
`dep` failed, admit it for the god sake!
This was a useful submission, of interest to many Go developers. I would have missed this announcement if it wasn't posted here. Try to be less of an idiot.
5. Increase compilation time 6. Profit (jk I love Go)
This is called bootstrapping https://en.m.wikipedia.org/wiki/Bootstrapping_(compilers) (In the case of Go, version 1.4 was mainly written in C and is used to compile later versions of the Go compiler which is mainly written in Go)
The Go project doesn't even do .0. They went 1.10, then 1.10.1.
"laziness" I agree to some extent. On the other hand, no need to revinvent the wheel. "sloppiness" I'm not sure I follow. 🤔
I know that following semver forbids using two-digit versions for libraries. However, they could make `vgo` more lenient with little extra cost. Leaving out the `.0` is quite common, why do we have to be so pedantic about the three-digits?
Because then the solver would basically pointless and you’d end up with the same package installed at four different random versions. 
Yeah, it seems like that would ease the transition. 
It was like watching a slow-motion train-wreck ever sense that post on golang-nuts. I think this is a case where something like more Linus-style blutness could have been helpful. rsc's response was both too nice and too long; it got lost for all but careful readers. Sam and others were able to continue believing dep would be merged into the official toolchain, and a lot of unecessary confusion and disappointment resulted. I think if rsc had just said, "Hey, don't say this. dep is not going to become the official tool. Stop saying or implying that. &lt;paragraph&gt; Here are some reasons..." ultimately things would've gone a lot smoother. (Maybe...)
Thank you for saying this. The investment is real.
I've been looking into this for my Flutter application. Maybe it'll help you out? It's available on pub as well. https://github.com/jonsaw/amazon-cognito-identity-dart/tree/master/example https://pub.dartlang.org/packages/amazon_cognito_identity_dart
To ensure a completly ordered set. If you have tags `v1.2` and `v1.2.0` which goes first? MVS requires an ordered set of tags, and accepting makes it more ambiguous as to what will be sorted first in the algorithm. 
Because they will blindly point at the "standard" rather than actually thinking about the correct decision.
The scenario posited is that the developer of the app has requested gRPC 1.8 - dep will bail explaining that the requested constraints could not be solved. The app developer can, if they wish, select a version of gRPC that is compatible and continue on. With vgo, the app is just broken, but the developer doesn't even know it, until they find out at run-time (or maybe they don't notice for some time, because the bug is subtle), and have to go hunting down why. I like a lot of what vgo brings to the table, but it seems like we're rushing full-throttle towards it without adequate critical examination of how it (and MVS in particular) will impact the ecosystem.
because what do you do if there's v2 and v2.0 and v2.0.0? Tags are trivial to fix. You could make a tool to update tags to add necessary trailing zeros in an hour. It's a very minor pain exactly once.
I really just want to sick pure go because I do not know a lot about SQL and want to stay focused on go. I know there is a secure approach to store data and check data against the file.
Not even gonna address this. You must think when I say secure I mean about the hash. I mean when checking the hash and username. I need a way to store data securely that can later be retrieved and checked.
Can the data file have multiple usernames and hashes. I am starting to think my approach is not very good but I don't wanna use a SQL DB.
How was it not secure. I was under the impression using strings.contain was not a secure way to check data from a file. What would you recommend I do with the hashes and username? no sql
I meant to... My file will hold many username and hashes for each individual user.
Yes, but the way I check my data with strings.contain apparently isn't secure, so they suggested this method.
Yes, it should, will look into it. Thanks albatros
This code does not work. I have been able to achieve this, but it overwrites the file every time. It needs to store multiple accounts. Also, how would I check if the username and password exists?
Can someone chime in on why this change was made? I thought dep is the way forward. Don’t tell me there is something else now!
With that particular approach, yea. You would read it in, decode it to a map, check it, or add a value and encode it back out again. You could also avoid reading it every time if you read it once into memory at startup, and then on add/remove you update your in memory map and write it back out. 
The fact that this doesn't recommend git submodules as the de-facto implementation of storing references to dependencies is IMO, absurd. They're a perfectly good way to store references to specific versions of other git trees, without adding a new file, parser for that file, etc... In the worst case scenario, their new tooling could wrap the git submodule functionality so that people afraid of using the `git` tool manually could use their new interface but leave the pros to be most efficient in git.
It is meant to overwrite the file every time with a completely new map containing all of the user login items. Each key is the username. The idea is that you read in your big map and look up the details by user 
Indeed, I'm not pointing fingers at anyone in particular. Maybe it's the Go team's fault for not discouraging Sam Boyer. Or Boyer's fault for seeing encouragement where there was none. Just explaining that the foul-crying from the *users* is warranted.
Not everyone uses git. A lot of people use Mercurial. 
The correct decision is the one that leaves no room for ambiguity. Given 2 2.0 2.0.0 tell me what wins and why.
http://i0.kym-cdn.com/photos/images/original/001/356/487/ef9.png
Precision is not the same thing as accuracy.
Given RSC's sensibilities as demonstrated by his choice of a regex algorithm optimizated for the worst case, a NP complete version selection algorithm was never going to fly, no matter how many times one said “I want my pony”.
Major versions for major public/breaking changes, minor versions for internal changes and new features, patch versions for non-impacting changes/bug fixes. I didn't even have to look at the document--that is just the most intuitive and clear versioning scheme to me. Do you have a better scheme in mind?
Also, projects vanish from internet time\-to\-time.
That's fine. In the same way that `go get` supports git and mercurial, this could too-- using git submodules for git, and whatever the equivalent in mercurial is for those users.
Look man, it's A standard. You shouldn't half-way implement a standard for something as meaningless as putting .0 at the end
https://www.mercurial-scm.org/wiki/Subrepository
The link of this survey: [https://www.perl.com/article/the\-2018\-perl\-developer\-survey\-results/](https://www.perl.com/article/the-2018-perl-developer-survey-results/)
[removed]
Yeah. I will just do it for the next release. Boy have I missed a lot by not visiting this fine sub recently.
[removed]
The choice of using .zip files was specifically chosen to avoid supporting various version control programs. This was to simplify tooling and the work any need to do to programically interact with go dependencies. 
v1.2 goes first because its patch version is nil.
No, I don't think that's going to be possible with this alone. I could be wrong.
I disagree with this like the other commenter. There is value in knowing what will/won't cause breaking changes. It can also be used as a proxy for how volatile a projects API is. It they're on version 8.1.0, I'd be more hesitant to use that dep vs one that doesn't break things as much. In practice it's harder, and people break it all the time so you can't *really* know. Especially on sub 1.0 projects but that part is expected. This is where tooling to assist in enforcing this comes into play. It probably won't be perfect but will be better than nothing.
Your mother was a human. How can one human create another human?
[removed]
This also shows where the common misconception (pun not intended) lies. And its answer. Yes, we use a human to create another human (2 in fact). But where did the first human come from? Kind of a chicken and an egg problem. And of course the answer is that the first human came from evolution. Before the first human was the last homo erectus, and before that the last homo habilis. To translate our analogy backwards. Before go was written in go, it was written in C. And before C was written in C, it was written in Assembly. 
If it helps to further understand. Go 1.10 isn't written in go 1.10. Its written in go 1.4. When you compile go it will grab 1.4 and compile that first, and use it. You can also provide your own preinstalled go 1.4 for it to use.
Just check your messages
Thanks!
I try to use context and cancel it to clean up resources.
Does 'orchid' support of trackers music such as it, xm und mod? Can I build of 'orchid' for Fedora 28 by painless? /Last ten years I used of 'cmus' but latest releases have a troubles with the stable. /
There's more to the story. After go 1.4, the last version written in C, they used a transpiler chat translated the C into Go. I'm sure the Go was awkward and inefficient at first, but I'm sure most of that was ironed out shortly after. I'm sure some of the remaining 14% is Go assembly. And maybe build scripts. This isn't new. C/C++ compilers are written in C/C++. GHC is written in Haskell. Pypy is written in Python. All languages should be written in themselves to prove their worth. The weird ones are assemblers written in C, a relatively high level language.
By this I mean some audio which created by the music sequencer software. The music is represented as discrete musical notes. In most cases files have an extension like a 'it', 'mod' or 's3m'. This comes from time of 'Commandor 64', 'Amigo', IBM/XT (in my case). 
at the moment - there is no much difference to be honest. refactorings are still really basic
Ah. No, orchid only plays MP3 files.
yep. also this: ``` func (m *Map) Close() error { close(m.done) return nil } ``` will probably panic if ppl do the usual: ``` m := ttl.NewMap(...) defer m.Close() // to make sure it is eventually called // ... do some work ... if err := m.Close(); err != nil { /// handle it... } ``` which is the usual pattern with, say, files used to be written to.
If you just care about your local dev env, then you are right. But what about your CI system , build box where you download things on the fly. Where do you get the submodule when the original project is gone?
Both Amazon and Azure has features you can use to achieve this.
Oh yeah, finally.
With vgo+athens in 2019 Go will outweigh Python ;-)
Lol 
But. I think it's a great idea! :\) Thank you for your work.
I'm not too up2date. When will vgo be production ready or is it already?
This is ridiculous. I just convinced people at work to switch to dep, and they loved it when they did. Is this real?
&gt; But nobody uses that, it's obsolete. you'd be surprised...
You don't even necessarily need to do that. 1.11 is going to be the "beta" cycle, per the proposal. If dep is working for you, use it until it's declared stable. Given some of the discussions going on around MSV, I have a sneaky suspicion that there are going to be some pretty significant issues arise that require some adjustment.
Thanks for making it free for students. It's a pleasure to work with the IDE's!
Go 1.12 is the aim for when it should be stable. 1.11 is for the preview, sort of like how the vendor experiment worked.
My father had an Altair and it had a bunch of toggle switches and LEDs you used to input binary for the program. His father never believed that the LEDs lighting up really represented moves on a checker board (he had input some checkers “AI” program at one point). His father also told him to stop screwing around with the dumb things because it will never make him money. He didn’t listen and obviously was able to turn it into a career. Because of that, he instilled the idea into me at a very young age (early 1980s) to get interested and learn about computer science very early. It’s worked out well for me.
[removed]
Just lots of people butthurt that they're not getting npm for Go.
You're right on. For some reason programmers like to over-specify things and group together around what should be "in" and "out" of the agreed practice. REST is an interesting idea but too often becomes the focus of API development instead of a guide.
Thank u Now it all make sense
Lol Gitsubmodules suck for some use cases why should golang care about Git. What if in 10 years or 5 Git is no longer used. 
Go + Vue..... awesome! Always happy to see something other than the usual React or Angular frontend.
Where to you aware that vgo was actually a proposal candidate as golangs default package manager. Seems like your team should be more aware of the go ecosystem 
My team owns around 20 applications written in several languages, and no one’s hiring new developers here. We’re doing our best. All of the developers that convinced management to use Go have either quit or moved organizations. Maybe your favorite language should be a little more stable?
Either your progressbar import path needs a v2, or import as a hash version for now. In the future the go command will backport a fix to allow vX path segments and still build. Until then use the hash version.
You can build Go `1.M` with Go `1.N` of any `N` in the range `[4…M-1]`. The Go devs actually explcitily encourage using the previous version of Go to build the next one—in the hope the more recent the compiler the more effective code it (typically) is able to generate.
Gotcha - the above poster said 1.4, I thought there was a reason for that. Thanks for the clarification
There is no a chicken and an egg problem. Egg came first when there were lizards and no birds yet. I had an interesting experience with early computers built on Zylog processors where to bootsrap C compiler one had to enter CPU bytecode (hexadecimal codes) of a primitive compiler, then build a more complex version of it, and then a full version. To build Go now one needs Go compiler. What if there is not one for a platform? Cross compilation is used to bootstrap Go for a new platform.
This is wrong on so many levels...
JavaScript and Node.js as two different lines? Perl 6 is a different language. The controversy! I would put moving to Python or Ruby into the "whatever pays" line because I don't see advantages to the move technology wise. When I need a quick tool on *nix that cannot be done in shell, I'd still use Perl rather than Go. If the tool is to become permanent, I might rewrite it in Go to carry around. If it's a complex tool, the language of choice is, typically, what you know best.
Pretty cool! Two things though: 1. Package names in Go should consist only of lower\-case letters. 2. Use gofmt. 3. `MixedList.MixedList` or `mixedlist.MixedList` is too verbose and repetitive. How about `mixed.List`?
Thanks! I'm refactoring right now! Yeah 'mixed.List' feels alot better!
I just wish people just use Rust due to its excellent package manager and be done with it.
First off, you may not be aware of GoDS: https://github.com/emirpasic/gods/blob/master/lists/arraylist/arraylist.go Style notes (usual style tools will warn about these is vscode etc): * don't use mixed case for package. * don't repeat Eg. MixedList.MixedList should be mixedlist.List
I know the feeling. I feel like it was only yesterday that I was moving projects from glide to godep, and from godep to dep. I'm sticking with dep until it is either no longer supported, or something breaks unless I use vgo.
FWIW I think mixed is too generic for the package name, even if you'll use mixed.List() and that's clear ... and even if you had a set or map in there. YMMV.
[removed]
It also seems like it should be easy to integrate CopyFileRange() into io.Copy ... is there an issue open for that?
Gonna sit down this weekend and try this. Been dying to sit down and try docker, this guide seems to be explaining stuff well! 
ELI5: How to do line breaks and code blocks using the android app?
For years I was a heavy perl dev and I did what you did. Too annoying to do in bash, do it in perl (up to a limit). But lately with the rise of containers and container optimized OSes you rarely see interpreters, so that fancy perl script you would just scp up to the host to do that thing you wanted to do just no longer works without a bunch of extra package installs. So now I just write things in go so I can compile them quickly for the destination platform.
If I am reading that correctly, go build will try to download code? I think that's a horrible design decision. If the code isn't available locally it should just fail to build. I would like to think that go build is just the "compiler" and nothing else. 
I would be very suprised if Caddy didn't use vmsplice already on Linux. It's standard optimization in every proxy out there (haproxy, nginx etc).
Thanks. It's all clear now. I just wasn't able to spot the difference.
C and A are not "assignable to each other", they are [the same type](https://play.golang.org/p/TG9kFY2AfU1). I wouldn't even say two names for the same type; the type has one name, package.A for whatever package is. C is just an alias you can use in the source code. What's important is that alias is exportable as a type as well, but it's not creating new types as it goes.
You have two options: Use a [type assertion](https://golang.org/ref/spec#Type_assertions) or a [type switch](https://golang.org/ref/spec#Type_switches) to get the underlying type out, or add a method to the interface that returns the desired common data and use the interface directly. Which is preferable depends on really a lot of details, mostly involving visibility. Broadly speaking, I would only use the type assertion or switch if the interface is closed and I know there will never be any new types I didn't expect implementing it, and even then, if the code is exactly the same in each "switch case" I might still just put it in the interface. If the interface is open, and certainly if you _expect_ new implementations, your only practical choice is to add a method to the interface that exposes the data you want.
See also [this](https://golang.org/doc/go1.5#build) and [this](https://golang.org/doc/go1.5#c).
If there's a criticism I have for Go, it's this. I appreciate the drive to be pragmatic and elide cruft, but it's become a bit eggregious and vain and it tends to get us into places we can't easily back out of. Like why did we have to go halfway with vgo at all when there is Cargo which is universally beloved?
Have they made it easier to mock tests yet, or interact with a database without using interface{}? Genuinely curious.
More: - all except "type C" (it doesn't really exist) can have methods defined on them in their declaring package - type D and "C" directly expose the methods of A, whereas B doesn't: would have to be "converted" to A to access them (same for `some type`'s methods when you have an A) btw. I don't think all conversions are as "overheady/copyish" as one-number-to-another or string-to-bytes or vice versa. Surely wouldn't hope so when it comes to type synonyms such as `type M map[string]interface{}` or `type S myStruct` and the likes. 
&gt;I know that following semver forbids using two-digit versions for libraries. Where do you get that from? I can't find anything on https://semver.org/.
[Mocking tests was never hard in Go][0]; the standard library SQL functions still take `interface{}` params. [0]: https://stackoverflow.com/questions/19167970/mock-functions-in-go/19168875#19168875
Okay, this is what we do today. So there still isn’t a mocking framework, and I still have to write my own mock methods?
There are frameworks, but they're more trouble than they're worth, just like in Python, etc. If this is a pain point for you, I'd suggest taking a look at how you use mocks.
It’s more that I don’t want to spend time writing all new mock functions. I would like to see something like Mockito or Spock mocks in Go that will generate mocks given an interface. We tried gomock, and we didn’t really like it in the end.
Thank you! I didn't know this was a thing. I toyed with adding a method to the interface as well but it is closed, so a type switch is just what I was looking for - I just didn't know the terminology!
They show Go code at min 6:35 and I think it doesn't look good. In the original post under /r/programming, I shared what I believe would a more elegant API -- https://www.reddit.com/r/programming/comments/8lke8q/a_retrospective_on_moving_from_go_to_clojure/dzgj77f/
I have a hard time imagining a framework or code generator that saves time. Doesn't it take longer to invoke the code generator (or wire it into your build scripts) than it takes to write the mock methods? Seriously, I have a handful of mocks (at most) per package. This is at the bottom of my list of pain points.
I'm not sure the value of your comment. I agree that it looks like C. But that makes sense, it's done using syscalls. How would do the same without syscalls? periph.io also uses syscalls to wait for events, see https://github.com/google/periph/blob/master/host/fs/fs_linux.go
It takes less time to write Thing thing = Mock(Thing) than implementing several mock methods. Also, I was writing Go before Java in production. We’re just trying to follow the standards our team has set for unit tests.
Agreed. That's some horribly complicated over-engineered code right there.
Fair point; not sure about Mockito, but in Python this is the source of a lot of pain for us because the default mocking behavior is often wrong, and the time you take specifying the right behavior is about the same as it takes to write out the right method, and that's not to speak about the time you spend trying to figure out what broke in the first place. How does Java solve this problem?
The [progressbar](https://github.com/schollz/progressbar) does have a v2.0.0 and v2.1.0 \(I want the latest one, v2.1.0\). I can do as you say and switch to the latest hash (`github.com/schollz/progressbar v0.0.0-20180522233429-ddf577279716`), but after I do a `vgo get -u` it still reverts it to v1.0.0.
That's a good point. I might implement that if I have some time.
I've never used that app but generally on Reddit you use 4 leading spaces before each line of your code: This line has 4 spaces in front and it displays as code. The spaces are hidden in the rendered text.
[removed]
Your code needs to import "github.com/schollz/progressbar/v2"
LOL! Oh... Wait, you are serious :P
Thanks! Forgot about that. It still doesn't work though: ``` $ vgo build -v vgo: resolving import "github.com/schollz/progressbar/v2" vgo: finding github.com/schollz/progressbar (latest) vgo: adding github.com/schollz/progressbar v1.0.0 vgo: import "github.com/schollz/croc" -&gt; import "github.com/schollz/progressbar/v2" [/home/zns/work/src/v/github.com/schollz/progressbar@v1.0.0/v2]: open /home/zns/work/src/v/github.com/schollz/progressbar@v1.0.0/v2: no such file or directory ``` 
How much watts?
While "I return an interface" is pretty clear I prefer the "Please return me an interface" func PleaseReturnMeAnInterface() (whatever) simply because the function is written just once while it probably is called multiple times and curtesy during function calls is just nice. Back to serious: No `I` here please.
DI doesn't solve that problem, but I agree that codegen results in fewer lines of code (loc isn't a good indication of developer efficiency, however).
There's some documentation on this very subject in the repo: https://github.com/grpc/grpc-go/blob/master/Documentation/rpc-errors.md
I followed it all, until this line: &gt; 13 runtime.KeepAlive(&amp;bs) // this line is essential. I'd think that bs is kept alive by sliceHdr. Maybe the article could explain line 13.
Unfortunately they don't detail the error code example I made, which is my first concern. Error codes are so handy here, but I'm not sure if we're expected to stick to the official codes or not.
[Sample code showing the differences](https://play.golang.org/p/3V0K_RhBMd8).
It just won't ever end, won't it? I love how they took all the bad parts from the first CoC iteration (that they removed after enough people complained) and shoved them back in! I guess they figured out people can't keep fighting forever, but Google sure can; they can just hire someone else to do the job(like they have just done)! Of course the lack of any democratic process or input from non-Google is typical behavior here. 
Well, true. You were right about every single point you made. BTW, the last point, you never gave me a search on how to actually check the data. You said read, decode, decrypt but never check. Anyway, I fixed the issue. I was creating a new map every time AddInfo is called, saving only the most recent data. Thanks for commenting and offering help.
It's aligning Go's code of conduct with the one covering the rest of Google's open source projects.
Ah, so because others do it, it's okay. 
I guess I'm OOTL, what were the complaints about the first CoC?
In this case, yes. The Contributor Covenant has been adopted by a huge number of projects. Everybody needs reasonable expectations of behavior, and this is one way to reduce misunderstandings.
Does it not mock the interface, and the mock gets passed by the user to the object it depends on? Like instantiating an object with a mock passed to the constructor? Regardless of LOC being an indicator of productivity or not, it’s less of a burden when you don’t have to reimplement an interface.
Many things, you might want to search both the mailing lists and this reddit if you are interested. But the main point of contention was the fact that the 0th iteration claimed sovereignty over the entire world, not just what they decided to label as "Go spaces". People complained and they removed that clause, and after even more complains this reddit was pulled out of the list of official Go spaces. But it seems it was a simple setback, and we're just where we started. 
Although note that the Reddit discussion was filled with anti-CoC trolls from Kotaku In Action, so I wouldn't give too much weight to most of the complaints.
[removed]
And regular Windows
Yipee, more ideological possession. Just what I need more of in my life.
I'm here for the outrage. I want to be outraged. What am I outraging about? Nothing at all. This looks completely fine? Just because you _can_ reduce it to the oversimplified "don't be a jerk", doesn't mean that such an oversimplification is sensible. 
Read it in. Update it with values. Write the whole thing back out.
The same way you are doing it right now. If you end up doing a json, then you use this: https://golang.org/pkg/encoding/json/#NewDecoder So, start with a map in memory. Guard access to it with a RWMutex, since you will mostly being doing reads. Every time you start up your app you will read the map from your local json file. Every time you need to add or remove an entry, also write the updated map back to the file (with a lock, or to a temporary file that you move over the original). At this point, you are basically replicating an embedded key/value database like BoltDB. If you used bolt, you end up with a file-backed key/value store that is pure Go and embedded in your app.
&gt; Does it not mock the interface, and the mock gets passed by the user to the object it depends on? Like instantiating an object with a mock passed to the constructor? Yes, but it often implements the interface _incorrectly_, so you need to manually fix it. For example, if you need specific behavior from the mock, you need some way of specifying it. Often, specifying this behavior is as much work as implementing the interface manually, but it's harder to troubleshoot when something goes wrong. In Python, this is compounded by the dynamic typing, which means it's not even really implementing an interface, but rather supporting any method that gets called on the object (except for methods that start and end with a double-underscore, apparently--in this case you need a different kind of mock object for some reason).
I'm a KiA reader/poster, anti-CoC _and_ a prolific Go developer. Just because someone has different politics than you don't assume that they're just "trolls" parachuting into a conversation they know nothing about. There are many well known issues with CoCs and this new language to add non-project spaces to those policed is very disturbing. Look no further that [Opalgate](https://github.com/opal/opal/issues/941) to see this type of thing being used to bully maintainers by project outsiders. In fact that incident was created by Coraline Ada, the creator of the Contributor Covevenant the Go CoC is based on! Please do consider the voices of those other than those of your friends on this issue.
I haven’t had the same experience as you with mocking. I have had to mock tests for Java, Python, Ruby, Go, JavaScript, Clojure, and Erlang, and I’ve found Go to be the most tedious and cumbersome language to do it in. My fellow coworkers tend to agree. That’s not to say you don’t bring up good points, and I totally respect your opinion. All I was really trying to say was I wish there was an easier way to handle this aspect of Go. The issues I have with Go are more like death by a thousand cuts than anything. I browse this community to try to stay up to date on the language to support my projects at work, and it’s frustrating when people here speak authoritatively about problems they have no experience with dealing with in a production system. You seem to not be one of these people, so I have no problem agreeing to disagree with you amicably.
From looking at the posting history of many of the people commenting in the reddit threads at the time, it was clear these were not "concerned members of the community", but were in fact brigading form KiA. They took over the discussion here, much as they did in proggit and other programming subreddits as PHP, Ruby, and other languages were introducting codes of conduct. I will update my post to remove the word "trolls", but I believe my comment still stands.
For great good!
I'm totally ok with this. --- Like the vast majority gophers, this code of conduct change won't directly affect me in the slightest (just like the previous code of conduct, and the lack of a code of conduct before that). Indirectly, I may be affected by a small change in the community discourse and membership, but I can't stress enough how little an impact this will have in practice on most gophers. The way I see it, all of us fall into one of these 4 groups. --- **Group A:** very few legitimately bigoted people may be pushed out of the community **Group B:** many legitimately good people will feel significantly more welcome in a community that stood up to Group A **Group C:** some legitimately well-meaning people with reasonable ideological stances against code of conducts will be annoyed. Most of them will grumble and then go on with their lives. Some small fraction of them will leave. **Group D:** people like me who aren't affected and mostly don't care. I strongly suspect this group is a silent majority. I'd like to address each of these groups directly: --- Group A, good riddance! Group B, welcome! Group C, I sympathize with you. I really do. You make some really valid points, and this authority (like all authority) could be abused. In theory, I agree with a lot of your concerns. However, in practice, you’re defending bigotry, and that's where I draw the line. Group D: If you made it this far (which seems unlikely), then please speak up. And for the love of god, please save me from the downvotes.
To be honest, that "community process" scared the shit out of me. Let's build a committee to assemble a committee tasked with the initial design of some package management thing. Predictably, the committee work resulted in the stated intent to support every single use-case and workflow under the sun. The workings of that committee were also awfully opaque, as they chose to work mostly outside of publicly-archived lists. The go-pm mailing list got the occasional summary but not much else. Things got better when dep became a thing. Sam and other contributors did some awesome work there. It quickly became clear though that wholesale merging of dep into the mainline toolchain was nothing more than a pipe dream. The dep stewards weren't determined enough to say "no" to new features and ever-expanding scope. Not a good fit for the existing Go tools which pride themselves for their simplicity. Vgo, in contast, is opinionated, and is able to throw lots of complexity overboard because of this. Let's see if it can get away with that.
You should treat the error returned by grpc server methods to be protocol-specific. That is, return `status.Errorf` with a `code.Code`. This allows generic infrastructure, like service mashes, load balancers, monitoring… to react appropriately to errors. We communicate application-specific errors as fields in the response. So, if we have e.g. a request `BuildRequest`, the `BuildResponse` message would contain a `string error_message` field. If the build fails, we would return a gRPC-level success, but populate the error_message field. Though depending on the semantics of `Build`, a failed build might also indicate a protocol-level response (e.g. the requested project doesn't exist), in which case we would return that. It's a case-by-case decision, which is more appropriate. I would refrain from using custom error codes directly, though.
&gt; I guess they figured out people can't keep fighting forever Or, if we don't devolve into paranoia and name-calling and return to assume good intent, they realized that they actually needed those rules based on experiences made.
&gt; But the main point of contention was the fact that the 0th iteration claimed sovereignty over the entire world, This is factually incorrect and it's inflammatory and you are well aware of that. "claiming sovereignty" would imply that people believe they can enforce their ideas of appropriate conducts in external spaces. What they actually did, was taking behavior in external spaces into account when enforcing their ideas in their own spaces. And it's this kind of language that makes it *so* hard to take any of the CoC-criticism serious.
Much to my (pleasant) surprise, Reddit's search function was able to dig up the old Reddit threads for when a CoC was first proposed and when it was last updated in a big way. The most-upvoted comment on ["A Code of Conduct for the Go community"](https://www.reddit.com/r/golang/comments/3abyva/a_code_of_conduct_for_the_go_community/) and the ensuing discussion in both it and in sibling comments might explain things. A little while later, a [second proposal](https://www.reddit.com/r/golang/comments/3t82mt/code_of_conduct_proposal_2/) was floated. Reddit Search was able to find other threads, but the signal/noise ratio is lower in them. If you'd like to spend some time looking at other people discussing codes of conduct that are similar to the Contributor Covenant, have a look at [the discussion that the Ruby project had](https://bugs.ruby-lang.org/issues/12004).
I don't use software that doesn't have a nice big COC :)
You overlook **Group E**, bigoted people who use frameworks like this as cover to dog people they ideologically view as opponents in these spaces, going over their entire online history trying to find something to pin on them and castigate them. Group E thrives in an environment like this and its members attempt to reform project spaces in this way specifically to exclude others on the basis of superficial ideological labels. Once they've codified a sentiment like this, their members use it as a means to bully specific targets. By that point the problem is systemic and attempts to hold members of Group E to their own rules face uphill battles. That's what Group C is so concerned about- the rules are not designed to be fairly applied, they're designed for wide censure of specific viewpoints, and consistently that's exactly how we see them being used, to no surprise.
&gt; "claiming sovereignty" would imply that people believe they can enforce their ideas of appropriate conducts in external spaces. No, it would not imply any such thing because such a thing would be impossible. "Sovereign", if we exclude purely definitions about nations, means "autonomous", "self-determining", while "sovereignty" used as a noun mean "jurisdiction". This precisely describes the CoC enforcement group. They believe they are autonomous (not under other party's control), self-determining (they make their own policy without having to answer to anyone, hence this very CoC update), and they believe they have jurisdiction over some space (now they believe they have jurisdiction over *every* space, further proving that the grave words that I used are perfectly accurate). &gt; What they actually did, was taking behavior in external spaces into account when enforcing their ideas in their own spaces. This is literally what sovereign states do. They jail you in *their own country*, even if the alleged crime took place in some other country (assuming they think you did something bad enough to warrant international prosecution). They won't jail you in *some other country's jail*. &gt; And it's this kind of language that makes it so hard to take any of the CoC-criticism serious. Which language? Accurate language?
We're starting to get repetitive comments from posters who are not active participants of /r/golang. This suggests that people are being directed here to push a particular message. That is not an appropriate use of this thread. The goal is not to stifle communication, but to keep discussion civil. Please keep this in mind while posting here.
&gt; in their honest words and opinions in other spaces without retaliation in your space. If I consider your "honest words" offensive, it is my prerogative to exclude you from my space, no matter where you spoke them.
&gt; No, it would not imply any such thing because such a thing would be impossible. Which is exactly my point. You are using inflammatory and factually incorrect language. Which is making it so hard to take you serious.
&gt; You are using inflammatory and factually incorrect language. I have been using words according to their literal dictionary meaning (which I have kindly provided) while you have been simply attacking and mocking me (which you are still continuing to do). What one takes seriously or not is not under my control, but I have serious doubts that in this conversation my posts would be the ones not taken seriously... 
&gt; The goal is not to stifle communication, but to keep discussion civil. Then why did you (or some other moderator) delete [these perfectly thoughtful, civil and innocuous posts](https://i.imgur.com/VXZtBSC.png), and why (exactly for what offense) did you ban /u/gildedlink? At this moment I must assume the moderators of this reddit are not acting in good faith. 
&gt; I'm a KiA reader/poster, anti-CoC and a prolific Go developer And yet this is the first time you've posted on r/golang... hmm.
It sure sounds like you are being intentionally inflammatory. I would encourage anyone concerned about overreach to read the actual text at https://golang.org/conduct. One thing you will learn is that the Go project has no jails (unless you count [gVisor](https://cloudplatform.googleblog.com/2018/05/Open-sourcing-gVisor-a-sandboxed-container-runtime.html)). 
Trolls coming into this subreddit to stir up trouble will not be tolerated. The banned user was removed because he had never posted to r/golang before (despite being a prolific commenter elsewhere on reddit).
[removed]
So if I tweet in support of Trump, I'm going to be prevented from contributing to Go (or, more realistically, from participating in its communities)?
[removed]
I dont think that’s a good reason to ban people. 
No, and that would be clear if you read the Code of Conduct. If you harass someone on Twitter, it might get you banned from the various Go community spaces.
I'd prefer to say "fuck semver" and only use those components of the version number that actually matter. Besides the major version (obviously), you need one additional number that increments on compatible releases. The minor vs. patch distinction is not useful enough to justify its existence, even if different people would all apply it consistently (which they do not).
I get that. But why did it expand to include spaces outside the Go community? For lack of a better example, consider Brendan Eich. Should he be prevented from contributing because he supported Prop 8?
I work as a react developer and many of my colleagues work with go. Despite this I rarely, if ever post on either technologies' subreddits. However if something newsworthy were to come up surrounding something I am exposed to on a day to day basis I would certainly consider speaking my mind to the community. I try to assume good faith in any conversation that isn't maliciously attacking people. Everyone has to make a first post somewhere. Why are divisive topics off limits assuming posters are respectful? For the record, I don't really have a stance on this at this point in time but I am interested in seeing the community discuss it.
People who come here just to argue about codes of conduct in general and have never contributed to the reddit golang community are not a good addition to the subreddit. This is not r/CodeOfConduct. I'm happy to have Go developers and other people who participate in the Go community discuss the Go code of conduct... but I have little interest in having people outside the community come in and turn this post into a flamewar.
That's literally my job as moderator.
You just proved the existence of Group E by going over someone's history and pinning something (lack of visible activity on this subreddit) on them.
You're not coming here to stir up trouble (as far as I can tell). That was not true of some other posters. We've had threads about the Code of Conduct before and they turn into a mess real quick. Most of that is piling on of people new to the subreddit that just want to argue about codes of conduct. Usually, a person's post history makes it pretty clear whether that is the case or not.
&gt; If you give me six lines written by the hand of the most honest of men, I will find something in them which will hang him. -- Cardinal Richelieu Just imagine what years of Twitter history could enable. All we can do is hope that it's applied evenly and consistently.
[removed]
[removed]
There's several people on this thread who are first time posters that have not been banned. You're one of them. I am attempting to give everyone the benefit of the doubt. But I don't have much confidence that if someone's first post in r/golang is to complain in long rants about the Code of Conduct, that they are coming here in good faith.
Bans and post deletions might be a bit heavy handed, but on the other hand, [calls to arms from activism focused subreddits](https://www.reddit.com/r/KotakuInAction/comments/8lnqw1/google_expands_code_of_conduct_for_go_to_include/) are problematic. This is a conversation that really needs to happen between existing members of the community. Letting people outside of our community have an equal voice in this discussion is like letting Russians vote in American elections. If reddit had a way to feature to flag discussions as "for pre-existing members only", this would be an ideal use case. Alternatively, a feature for moderators to tag comments as "from non-members" so we could take their comments with a grain of salt. But since those features don't exist, manual post deletions and bans are kinda the only way to prevent outside forces from polluting the discussion. 
As an example, if someone posts truly horrible anti-semetic things to their twitter account, do you think someone who is Jewish would feel comfortable hanging out with them at Gophercon? This is just about taking responsibility for ones own actions. If someone says terrible things in public, they have to be ready for the repercussions. Someone can't act like a horrible person in one room, then step into the next room and expect everyone to treat them like the Pope in the other room. 
If I assault someone at Pycon, should the CoC be able to be applied to ban me from Gophercon? Of course. You don't stop being who you are when you switch subreddits or conventions.
[removed]
I 100&amp;#37; support there, people on both reddit and SO are turning into absolute elitist asshats and have been giving new comers all kinds of hard time.
[removed]
[removed]
because casting a vote is the same as assaulting someone at a convention
Should any celebrity developer get special treatment?
We have different definitions of excellent. There's a big difference between "I think atheists are idiots" and "we should burn all atheists at the stake". Both criticize atheists. The former is merely a tactless statement of opinion, the latter cross a line into threatening behavior. If you said the former, I probably wouldn't want to talk to you about religion. If you said the latter, I might not feel comfortable taking a cab home from the bar with you. People always blow these things up like someone is going to say "I hate movies" and get banned from golang-nuts because Russ is a movie buff. That's not going to happen. It's frankly ridiculous. 
you mean you literally just threw out nonsense and expected no one to call you on it. 
The type of sliceHdr.Data is uintptr, so it will not keep the underlying bytes of bs alive.
I was not in any way comparing the two. My apologies. I tried to give an example of why the CoC needs to extend beyond Go communities. 
[removed]
Fair enough. You seems to have a whole lot more experience in this area than I do so I won’t continue to argue. Thanks for sharing your side. 
No, but neither does Linus since AFAIK Linux kernel development does not have a CoC.
There really are vanishingly few incidents I'm aware of that required a vigorous debate on that front. The Adria Richards one is probably the only example I can recall where I feel like there was any sort of honest disagreement among well-meaning actors. I think there's not much danger in the "we know it when we see it" approach.
Agreed, kinda in the middle of group C and D. Neither the less it's all good. Hats off to the mods for keeping the toxic / problematic people out. 
&gt;I think there's not much danger in the "we know it when we see it" approach. Except that is subjective, and depends on what the 'reviewer(s)' deem appropriate or not.
While that may make them uncomfortable, I would suggest simply not hanging out with people who have views you consider detestable. And I do think people should be expelled for vocalizing intolerant views within the community, but so long as someone is able to separate their personal views from their professional lives, I see no reason to discriminate against them. Are you really changing any views by banning people from your community? Is the world a better place because of it? Is the community genuinely healthier? In my opinion, it is not. The only way to change minds is to show people a better way, and answering discrimination with discrimination is about as likely to stop them as using a flamethrower on a house fire. I just don’t see the gain in banning people who haven’t done anything against the community yet. I’m all for giving people a chance to prove that they can rise above, and maybe have the opportunity to prove to them that their views may be flawed.
No one says "being offended" is a reason to ban people. But there's a line. If someone said to a jew "I think you should be dragged behind a horse until your arms are ripped off", then yeah, I think that person should probably be banned from gophercon. Notably.. it's basically never just a single statement. It's a pattern of behavior. If someone said what I quoted above, in public, chances are they've said that before, and you'll be able to find more instances if you look. 
&gt; people who participate in any kind of harassment or inappropriate behavior, even outside our project spaces, are not welcome in our project spaces Ah, cool. At least I'm just a small-time dev, so I'll never have to deal with this stupidity.
We'll put.
So are all ex-cons banned from contributing to Go?
&gt; Group A: a very few legitimately bigoted people who will be pushed out of the community Rewind to a few years back and instead of "legitimately bigoted people", you'd have written "legitimately gay/black people"...
Brigading is against the rules, but CoC discussions get trampled anyway. The people only care about advancing their point that it's the CoCs that are toxic.
&gt; Jumping into a community discussion about the CoC when you aren't part of that community is very similar. That's a terrible point. A community that only caters to it's **current** members won't ever be "inclusive".
Notably this is how our legal system also works. Judges and juries are just people trying to be objective.
I'd like to say, I find a lot to disagree with in your post, but the whole "defending bigotry" thing is one of the most unfair and ugly things I've read in a while.
There is already an analog for this. Ever seen a form that says "have you been convicted of a felony" or had to pass a criminal background check?
Someone who is clearly NOT part of the Go community shouldn't be deciding on things like the CoC, and we don't need to have a clearly defined line to differentiate who those people are. Think of it like the border of a country - you don't necessarily need to see the exact borderline to know that 100 steps one direction is in country A, and 100 steps in another is country B. Somewhere in the middle a person crosses the border, but defining it exactly isn't necessary.
It has a "Code of Conflict": https://www.kernel.org/doc/html/v4.12/process/code-of-conflict.html
I haven't attacked anyone. But if you harass people, yes, I'll ban you and not feel sorry about it. 
Sure, but the CoC is not a set a rules for the sub, by this sub, pertaining only to this sub. It's devised by Google, applies to the "Go community" (which hasn't been defined as per my questions), and encompasses behavior on this sub and outside. I'd even go as far as saying that it's precisely because it is so encompassing in its scope that redditors who are not regular posters are perfectly entitled to come here and discuss it.
&gt;and at least assume that you'll get the rape threats and unsolicited dick pics under control Things like rape threats and dick pics are hardly something you need a CoC for, the former is illegal, and the original CoC already covered this. The extension here is that now any statements you make anywhere can result in you being banned, and what it takes is that the current committee find them inappropriate, again entirely subjective, and thus subject to current political views held by said committee.
Welcome to the world of changing societal norms.
The difference between a core dev and an occasional poster on this sub to you is akin to "100 steps in one direction"? You haven't answered my questions at all. Who is "clearly NOT part of the Go community"? Am I? If you're going to decide who can and can't talk about it, there needs to be some sort of a standard.
Great write up. Is it common/idiomatic in Go projects for docker directories to be located alongside the code directories like this?
he's saying that your frontend should receive events from the server separately from issuing commands. right now, it sounds like you are issuing the command and waiting for a response. web sockets were implemented to solve exactly the problem you are describing.
I write a lot of Go and quite enjoy the language. Am I not allowed to post here?
So people who hold intolerant views can’t also be interested in just talking about Go? Are we really just going to reduce people with views we don’t like to a single dimension? I’m not agreeing with them, but I do think it’s possible to be a racist or an anti-Semite and still be interested in Go. &gt; And I don't ban people that haven't done anything. Against the Go community or in general? If it’s the Go community, then why have the rule? If it’s not, how is assuming that they can’t contribute meaningfully any different than their assumption about whoever they’re bigoted against? I’m all for banning people who are dragging the community down, but the purpose of this rule is to prevent people from even having a chance. Even beyond speaking about people with actually bigotries, the chilling effect this has is frankly abhorrent to me. It sends the message that you either fall in line, or get shut out of the community, and that’s frankly not a message that I want to support. 
The point is it's not about you, nor is it about a single developer in isolation. For the health of the community, and what point do you exclude a disruptive person? The code tries to make it clear under what circumstances this might happen.
You have not been banned.
No but the moderator of this sub is implying that I'm here to cause trouble, which I'm not.
If you've never posted to r/golang and yet are quite active on Reddit otherwise, I find that surprising. But regardless, choosing this discussion as your first appearance on the subreddit is a bad choice. We have no way of knowing you have any investment in the Go community. So you appear to be someone who just wants to argue about CoC snd doesn't actually care about Go. 
The Go community exists outside Reddit as well, and that means making decisions that may upset a small minority of an online forum.
I don't know what to tell you. That's how the world works. If the HR department for my employer thinks I've crossed a line, I'll be fired. There's a handbook, but it's academic because the handbook isn't and can't be exhaustive. Ultimately, someone makes a judgement call as to whether or not my actions constitute a violation of section 3.3.4 or whatever. These CoCs don't change the fact that a project can get rid of you. If the people sponsoring qnd running a project feel you're a detriment, you don't really get a vote. The CoC states up front what the expectations are, but the expectations are there either way, and just like my employee handbook, you don't get to insist they enumerate all possible ways you don't get to behave.
I am also a moderator here. And you'll notice that I responded to you, even knowing you had no reasonable presence in this sub *and* had posted the new CoC thread to /r/KotakuInAction.
In the given scenario, the problematic statements have been made outside of the Go community, so they wouldn't be disruptive at all.
Absolutely, which is why I find ignoring people unless they meet a certain threshold of activity on this particular sub ridiculous. They could very well be active Go users and contributors elsewhere. It reeks of gatekeeping.
And I appreciate that.
As a Googler, I know it would be discouraged internally. If we needed a new class (not sub-type) of errors, it would require quite a bit of work. For the most part the existing codes aren't meant to convey specific error codes, but classes of codes. In much the same way HTTP 403 means Forbidden, but you might be forbidden for any number of reasons. The server would return a 403 and possibly a body to explain the sub-type of the error. If a system doesn't understand the details they should be able to act on the category alone. If you are unsure of the code to choose, pick status code that triggers the behavior you want from dumb clients and work from there.
&gt; You can consider Linus Torvald's behavior toxic, but what is virtually every web server running right now? &gt; You can consider Steve Job's behavior toxic, but who almost toppled a complete monopoly on the OS market? One could also argue that these products were so great that they survived *in spite of*, not because of their toxicity. You don't have to be an asshole to be a visionary and change the world.
As /u/natefinch pointed out, it's odd when somebody who is otherwise active on reddit and but doesn't seem to be posting in /r/golang or even other programming subs chooses *this* particular thread to pipe up and come out against codes of conduct. We have to make a call, and sometimes we'll be wrong.
No, you don't have to be an asshole. I truly believe you can. But ultimately, the code is more important than feelings. You have to actually give a shit, and if you do, it stands to reason you will be passionate, and passionate people can sometimes makes mistakes, be politically incorrect, but they know what they're doing, and ultimately with no negative reinforcement, all projects will go to shit. It can be excessive sometimes, and mistakes can be made, but those mistakes are no worse than the fuckups in the actual code that cause millions of people harm and loss of productivity.~~~~
neat! now do it with the Pixel 2d opengl library. It's very easy to work with
`delete` only works on maps, but your global variable has lock and unlock methods, so I don’t think it’s a map. Also, you don’t seem to be using the word “database” correctly. 
The CoC won't affect your day to day life unless you harass people. I wasn't attacking you, I was making an observation. It was an observation that applies to many people who seem to be coming just to talk about this thread.
Who says the terrible person writes code better than the 100 not terrible people that avoid coding because of him?
No, that's just bad reasoning attempting to disregard reasonable debate. You're asserting both that go related bigotry is happening and that allowing the CoC to be unchallenged is the only solution. Part 1 is debatable (any proof of Class A existing? A link to an example of a Go community member would be really helpful, I'm sure there are lots to choose from since policy is being written about it) and Part 2 is just insanity. Maybe you're familiar with the Politician's Fallacy? Something must be done, this is something, therefore we must do this. In reality, writing bad policy if often worse than not writing policy at all. Suggesting that debating that policy is "defending bigotry" deserves more colorful language than I'd like to use this late at night. To your imperfect analogy, guilt by association (ad hominem) is another well documented logical fallacy. But at this point, we're not even debating the CoC, we're debating the ability to debate the CoC. I think the subjectiveness of the rules and what I expect was intentional vagueness is just too broad for rules that might apply to anything you've ever said or done in public. That doesn't make me a defender of bigotry.
The chilling effect of not banning bad people is far worse than the chilling effect of banning bad people. The only "fall in line" is "don't harass people". So... yeah, if that's your definition of "fall in line" then sure.
What do you infer that from?
&gt;I don't know what to tell you. That's how the world works. The world has been working fine without people being banned for views which have nothing to do with the software project they are contributing code towards. Accepting code from people who has views you don't like has worked all these years before (IMO) overreaching CoCs like these, now there will be a committee who will oversee complaints about your views/statements even if they are made in a totally different context with no direct connection to the project this committee is overseeing, it's hard to see this as anything but thought-policing.
Can someone define "Go spaces" ? I could not find any well defined text about it.
Look at it instead as community curation: What can be done to ensure that we are a welcoming environment. If that means excluding somebody whose comments and consistent harassment of groups make 1000 people not want to participate, then for some people that's a fair trade-off.
Is it not well defined, but it is assumed to be the various forums, mailing lists, meetups and conferences, GitHub issue trackers and wikis.
Do what you have to do, you're the mod. As for me, I think discussion forums should have a code of conduct, and programming languages should not. And I think the aim of code of conducts should be to provide a standard so the rules are known and apply to everyone, not to make a community "safe" or "inclusive" (which I think they never do, and sometimes undo).
I really like the tutorial. However I would advocate for separate Dockerfiles for each service.
YAGNI
That's nice.
Well that's where we disagree, I don't think that people's views or comments outside of a project environment should affect their eligibility within said project, assuming they refrain from voicing them there where they don't belong. If those views/comments are illegal then they will be dealt with on a legal basis, if they are 'controversial/offensive' then it's up to the venue where they actually made the comments to decide if they are allowed.
I would like to suggest one tweak. The part that says: &gt;Diversity is critical to the project; for Go to be successful, it needs contributors and users from all backgrounds. I think it's better stated that Go should welcome and support contributors from all backgrounds. I don't think having contributors that are not of the same or similar background (or gender) should be a hard requirement because it violates other portions of the code of conduct. Too often I see people look at homogeneous groups that are often Asian, White, and male and say "This is not an acceptable racial or gender makeup for this group of people". I think despite the fact that the people saying that may mean well and may mean we should be doing more to welcome people outside those demographics I think telling white and asian males that their gender and race is somehow now an acceptable trait is itself a massive violation of what a code of conduct should try to accomplish. &gt;Be friendly and welcoming good &gt;Be respectful good &gt;Avoid destructive behavior Good Saying groups should welcome and encourage diversity is one thing but to say a group MUST be diverse or crosses the line into being unwelcome and disrespectful of the people within that group. Examples of unacceptable behavior: &gt;Trolling, insulting/derogatory comments, and personal or political attacks I would say the requirement to have diverse groups of people (rather than just being welcome to all people) is essentially a quota and therefore takes a very specific political position. Chartering a political ideology right into the code of conduct is a pretty hostile stance of people politically to the center or to the right. For that reason I feel the hard requirement for diversity causes the code of conduct to stand in conflict with itself. People should welcome all contributors where ever they come from even if those contributors are happen to be a majority white, Asian, or male. I also feel [this person](https://lobste.rs/s/4znygr/updating_go_code_conduct#c_xeohob) raises a good point. Religions are ideologies based on ideas. Ideas can be wrong and as such people should have every right to disagree with religions (or lack thereof) outside official project spaces without fearing professional repercussions within projects. One could argue for an LGBT person the mere acceptance of religious contributors is already an acceptance of people with highly offensive views on gays to contribute professionally and be treated kindly as a peer. I think swearing on a charter (religious or not) that advocates death penalty for individuals is a far far greater problem than people who happen to oppose those views publicly. I think people have a moral right to stand against hateful views posed by Islam or other religions for the same reason they have a moral right to oppose hate speech. Religion and hate speech have exactly the same rights and protections. If someone feels burkas are often used in societies as a tool to oppress women is that person good or bad? Are they an acceptable contributor to a community or not? I feel that it's difficult to hold people accountable for views expressed outside a project or professional environment without committing to taking sides on difficult and complex issues and I don't see such a thing as the responsibility of Go. In order to welcome people with diverse religions you must welcome people with diverse views (even where you disagree with said religion or views). Code of conducts like this one often underestimate the value of free speech in society. At points in history topics like gay rights, equality for women, or freedom for people of all races were considered offensive topics and thankfully what was considered offensive at those times in history were not codified into law prohibiting people from speaking. To punish free speech outside projects is to make the naive mistake of assuming despite continued failures to get it right though all of human history that somehow we are too enlightened to be wrong and all who have differing views should reap punishment. Professional retaliation against peoples personal views and beliefs expressed outside a project should be highly discouraged and be considered the same as excluding people or retaliating against them for their personal religious beliefs.
I came here because this popped up on my front page, and I remember the FreeBSD code of conduct situation. This is the only comment I made. Not everything is false narrative pushing. Plenty of it, certainly. Not all though.
Why am I not surprised this comment beers into abject bigotry midway?
&gt;Calling it stupidity is not respectful or welcoming feedback. Even though this view was expressed outside a project space in keeping with the code of conduct it mandates that you be removed as a contributor for all Go projects even the ones you are employed to contribute to. &gt;Your employer was notified and you are now on paid leaf pending review of your employment. Goodbye. Not really but I can see some issues with enforcing this too strongly. Like many things weather your input is considered hostile or harassing or not is going to depend largely on if someone complains about it or not. Rather than curb your behavior the policy could serve as a double edged sword to shape who you chose to communicate with rather than the tone you communicate in.
If I look at this thread, I see people outraged at the mere possibility of being held responsible for their behavior. I say it’s already working. 
Please elaborate what part of my comment veers into bigotry. Keep in mind that calling me a bigot is not very respectful and not being respectful is a violation of the code of conduct. 
The way we do it is by finding the grpc error code that best matches the error. Then we put json in the message of the error. This json contains both an actual message and custom error code so we can easily differentiate.
If you go into a library, they have a code of conduct. If you go into a friend's house, they have a code of conduct. In both cases you are free to disagree with the code, but if you want to be welcome, you follow the code. It's rarely difficult, and can, in most cases, be summed up as "Don't be a dick". If you enter a community, and the community has a code of conduct, then don't be a dick. You don't walk into the library and start loudly claiming your right to free speech, because the conditions of being in a library would mean that you were being a dick. Same thing with your friend's house. Same thing with the go community. 
One small comment; in Go the idiom is to capitalise initialisms, so `FromCsv` and `FromJson` would idiomatically be `FromCSV` and `FromJSON`.
They are not going to be policed by internet randos. They are going to be subject to actions by community leaders, same as always. The CoC just spells out what is considered acceptable behavior and what is not. You might want to read it again. 
I've seen a few op-eds that claim that voting against X is violence against people who want X to pass. Because of this, I couldn't be too sure what you meant and didn't mean.
Your threat of using the CoC against me is hollow. That’s not how this works. 
(I’m uninvolved in this argument and legitimately not trying to start arguments) But, the whole point the user you’re replying to is making is that by the CoC’s standards, you don’t have to be harassing anyone. You simply need to have said the opinion somewhere, ever. If I tweeted at nobody directly something offensive, should I be permanently uninvited from Go events? Even if I’d never said a word of negativity to anyone in the community?
Are you equating being bigoted with being gay or black? Should we start a "bigot's rights" movement and see how that goes? 
Every law and every moral code is based on community standards. In real life these standards emerge naturally over time and are codified democratically. While I have no problem with the code of conduct, I could see how someone might, just on the basis that they're being given an ultimatum to follow rules that they had no input in, no vote, and no voice. There's also an implication here that we need these rules or we would all be assholes or creeps instead of the mature, professional adults that 99.9999% of us are. I'm genuinely interested: how big of a problem have troublesome behaviors been? The announcement alluded to "a few" incidents as justification for broadening the scope of the code and registered the need for a project steward by setting, "the demands required to enforce the code of conduct place too heavy of a burden on volunteers." What is meant by this? Is the community so toxic that the time demands are too high for volunteers? Is it an emotional drain or distraction for the volunteers? How effective has the code of conduct been in addressing these behaviors? I know when I dictate rules to the kids with an "or else" consequence, their behavior often remains unchanged, leaving me the unenviable task of defining a suitable result. I've not had any bad experiences personally, but I guess I mostly keep to myself and focus on the work. I'm a gopher, but maybe my experience being so nontoxic means I'm not actually a part of the community?
A public library isn't going to ban anyone for holding an unpoular political view or calling someone an idiot on Twitter.
PS. I like that the CoC says \*interpret the arguments of others in good faith, do not seek to disagree\* and: \&gt; People are complicated. You should expect to be misunderstood and to misunderstand others; when this inevitably occurs, resist the urge to be defensive or assign blame. Try not to take offense where no offense was intended. Give people the benefit of the doubt. Even if the intent was to provoke, do not rise to it. It is the responsibility of *all parties* to de\-escalate conflict when it arises. I just find it ironic that they are buried in a document that encourages the exact opposite behavior.
**There is a lack of trust.** Many folks, including myself, are disconcerted with these changes, not because we disagree with the premise, but because we are skeptical and/or distrusting of whomever may be granted new powers to excommunicate from the Go community. Clearly, the Code of Conduct is subject to interpretation, and it would appear that the authority to interpret and enforce is withheld to a small subset of the Go community that likely share many of the same biases and ideals (this is a mutable assumption). What mechanisms are there to prevent groupthink and tribalism? Additionally, I have observed members of the inner Go community publicly take very strong, divisive stances on topics that lack an objective right and wrong. As a unimportant, unknown Gopher of the community, I am legitimately concerned about accidentally offending the wrong Gopher, one of particular sensitivities and connections. These are not unfounded concerns. Personally, I have been berated at length on Twitter for accidentally offending a fellow Gopher due to a combination of misunderstanding and a sensitive topic. Bridges were burnt, not built, and I hated it. I think you have done great things with Go, and I trust you with Go. I do not trust you to with the power to excommunicate from the Go community.
Even worse: &gt;This Code of Conduct also applies outside the project spaces when the Project Steward has a reasonable belief that an individual’s behavior may have a negative impact on the project or its community. Therefore, I could be banned from the community based on a subjective opinion of a single person \(notice the word "belief"\). 
Very good questions. I am also curious about the context and perceived need of these changes.
Call the police.
Not to mention their contribution to the discussion was both respectful and on point. They may not post here but they have active posts in related technical spaces like /r/programming, /r/webdev, r/linuxmasterrace, and /r/sysadmin This seems like textbook deplatforming of someone just for having an opposing viewpoint. The fact that we are digging through their post history rather than just weighing the value of what they had to say is ridiculous and a really really clear example of exactly why the CoC is a problem. We are really going to tell someone their valid contributions are not welcome because they have a bunch of contributions on reddit to gaming subs? really? What doe the CoC say about false sensorship and exclusion of people who don't happen to back your personal ideologies? Are the mods who censored him going to relinquish their role in the Go community over this? Isn't that what's called for? 
[gota](https://github.com/kniren/gota) is also a good tool for manipulating dataframes. Ideally it would be great if both projects could merge to avoid duplicating the work.
[removed]
[removed]
&gt;They are not going to be policed by internet randos. They are going to be subject to actions by community leaders, same as always. Did you see [this post](https://old.reddit.com/r/golang/comments/8ln14a/updating_the_go_code_of_conduct/dzh59jd/) about one of the contributers to the thread whos comments were deleted and the user was banned? Can you elaborate on why his behavior is unacceptable for us? 
Yes, I'm aware of Gota \(I've linked it from the README\) and it's certainly nice but the design of it has not been done with performance in mind \(there are a lot of interfaces and abstractions causing a lot of indirection at very low levels\). For my use case I needed something faster. Redesigning Gota to do that would essentially be the same as writing a new data frame implementation \(which was what I opted for instead\).
Generally, the toxic ones are the folks who want to police other people's behavior outside the project. If you were advocating banning those sorts of people you might have a case.
Very good points. Thank you for articulating a lot of my thoughts better than I could. It seems like many people commenting share your concerns. 
(laughs) You're a real piece of work, sometimes.
I find it quite harassing by accusing people for being trolls by digging through their reddit history. Go ahead... dig mine too. The thing that people mostly point at this thread is involvement of personal attitudes in Go's CoC. The fact that someone can be banned from community on the basis of subjective opinion of project steward. The fact that things might turn into "a witch hunt". Digging through someone twits in order to find something that "Project Steward" won't like so that he/she can decide to kick you out.
Was there a big problem in the Go community with rape threats and dick pics?
That's ridiculous
Yes cos you're toxic /s
I really don't trust that to be the case. The wording is to ambiguous and will be abused and intentionally misconstrued to exclude people.
[removed]
It's a good way to decrease the amount of code committed and watch a project fade into obscurity
You are moving the goal posts on me. He was banned by moderator action (ie. community leaders). “Internet randos” have zero bearing on it. I’m not a spokesperson for the mod team. 
I don't see how anyone will be able to offer much help based on only that snippet. Can you provide information about what the encode and decode functions are doing to the global map? What results are you seeing? 
Nobody will be offended if you state that you think Color should be written Colour in the API or that you think MVS in vgo is damned to fail because of whatever reason or whatever. These are technical discussions and different viewpoints are okay. Sometimes it os okay to disagree. Someone might be offended if you assert bad taste, lack of knowledge, missing talent or a personality disorder because you dislike the person's english used to write comments. Such an attack tells more about your maturity than about the offended person. I doubt that such childish behaviour will trigger immediate bans. Any halfway polite and decent person doesn't show such behaviour, so no need to worry. Everybody will be offended whenever you demand someone to be lynched because you dislike his nose or her way of dressing. There are things which cannot be tolerated. This is about sane people preventing insane behavior. Why do all arguments against the CoC rotate about "but what if the stewards turn into evil, cripple minded zombies hunting anybody who is not worshiping them"? 
&gt; They are enforcing their CoC in external spaces. If you want to be part of the Go community, Exactly. If you are bigoted, I won't let you into my home - *no matter* where you are spewing your hatred normally and whether you plan to do it on my party. That's my prerogative. &gt; Put it another way, what’s the point of that section if the goal isnt to enforce that CoC in external spaces? To make people feel safe. A lot of people don't feel safe in the presence of people who - for example - publicly refute their right to be their or even their right to existence. No matter how these people are behaving right now. But, TBH, all of this has been discussed at length then, there isn't anything new going to come up here.
[removed]
&gt; Why do all arguments against the CoC rotate about "but what if the stewards turn into evil, cripple minded zombies hunting anybody who is not worshiping them"? Because power corrupts?
&gt; The most-upvoted comment Ethics is not a popularity contest.
I'd like to suggest this as an alternative: https://github.com/domgetter/NCoC Let's just stop taking things so seriously all the time. It's okay to joke around with people and not take offense on behalf of others.
It's sad when a *programming language* even has to consider this. I miss the days of geeks just shooting the shit without ever really having to worry about stepping on some over sensitive toes.
I understand your point. The reason is that I do not want direct communication between Sender and Receiver. I want the code on the Sender and Receiver to remain the same \(Sender and Receiver having different channels of course\) while the Proxy goroutine takes care of hiding the fact that Sender and Receiver are not communicating directly. So I want something in the line of : func Sender(ch chan int) { ch &lt;- 42 } fun Receiver(ch chan int) { &lt;-ch } func Proxy(senderChan chan int, receiverChan chan int) { for { msg := read from senderChan without consuming receiverChan &lt;- msg // relay message to Receiver &lt;-senderChan // consume message to unblock Sender } } func main() { senderChan, receiverChan := make(chan int), make(chan int) go Sender(senderChan) go Receiver(receiverChan) Proxy(senderChan,receiverChan) } 
[https://golang.org/conduct#scope](https://golang.org/conduct#scope) reads: &gt; This Code of Conduct applies both within project spaces and in public spaces **when an individual is representing the project or its community**. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. That's hardly universal jurisdiction. For example, when someone says "good Muslim women should wear a Niqāb" on Twitter in some random thread, I don't think they represent project or community. Now I understand that this open to different interpretations, but let's see how Project Steward will interpret them in practice.​ 
[removed]
The CoC is excluding people that behave in a way that One Man ^^^(tm) disagrees with. It's arbitrary, and I think it should be illegal. Imagine your company restricting how you dress out of work hours. Or how you eat. What you watch. Your hobbies. Your politics. Sure, we have protected classes, and that came about because, just like this new era of CoC's, the employers are being idiots about their control. I am hoping that CoC's become so ridiculous that we can finally take them to court and make them illegal.
There is a committee to figure it out because you can’t make rules that equal don’t be a jerk. 
There’s two variables there, LoginInfo (which can be indexed like a map) and LoginInfoLock (which is probably a mutex)
Can you explain why the obvious approach doesn’t work for you? msg := &lt;- senderChan // Do what ever the proxy is mean to do here. receiverChan &lt;- msg
You really think more people would be coding if not for Linus Torvalds?
I am trying to implement synchronous distributed channels and have them behave as local channels. \[The code I added is just an example of Proxy being a level of indirection\] If the message is consumed, the Sender is unblocked and I do not want that since I want Sender to block until Receiver has received the message.
I've not so much had pain with mocking, but have still used tools like this: https://github.com/vektra/mockery to generate mocks from interfaces before. I'm not sure that this tool supports type aliases, but there are others like it for Testify's mocking library. The most painful thing about it has been that testify's mocking library gives you some really cryptic error messages sometimes. Like for example, if you change an interface, and then update your mocks to match, let's say you removed a return value, it'll panic and give you a bit of a weird error - not simply tell you which test was missing a return value, or even which type it happened on. I might look into making a PR for that actually at some point.
I don't think it would be that easy, without adding new API or special-casing io.Copy too much. `copy_file_range` doesn't need help from the network poller, since file I/O is blocking. The `os` package gives you just enough to be able to use it from outside the standard library. You call `Fd()` on both `*os.File`s, use offsets if you need them, then use `x/sys/unix` to call `CopyFIleRange`.
Synchronous distributed channels are impossible. Channels are an exactly-once delivery mechanism, in the strongest sense of that term, and those can not be distributed. I've got a longer version of a proof I can link when I'm not on a phone, but the short proof is: Such a thing would be highly desirable, Go is now over a decade old, and you can't get a library to do it. That's not because nobody wants it. It's because it's mathematically impossible.
Fair enough. I went for the quick one liner there, and the extreme ends of the spectrum may be pretty rare. But in complete earnestness, I bet most women in the go community deal with some form of behavior that I think is fair game to be called out and curtailed. I don't imagine the go community is worse than average, but the average isn't great. However, I would also throw out there that you can't really have it both ways. If no one in the go world is sending dick pics, then it should be fine to prohibit sending them. Not everything needs to be the free speech hill you choose to die on.
It's literally in the next sentence after ou stopped quoting: &gt; This Code of Conduct also applies outside the project spaces when the Project Steward has a reasonable belief that an individual’s behavior may have a negative impact on the project or its community. This directly and absolutely negates any assumptions you could make from the part you quoted, and extends the scope to infinity.
That’s cool man. I’ll have to check it out. Anything to improve the experience. I assume the mocks generated are editable? That way we could dig into any problems we have with them.
It all comes to Project Steward, and I think I addressed that with the last sentence, didn't I? I \_absolutely could\_ make assumptions about Cassandra in good faith.
I've never had to manually edit the mocks it's generated, but you always could do. I usually have a script in the repo that generates the mocks for me, and I treat it in a similar way to other generated code like ProtoBuf (i.e. you'll lose your changes in the future if you want to regenerate them).
I generally only lurk on /r/golang but have been a gopher for a long time. Just because I don't post here often, does not mean that I am less a part of this community. I find the CoC has 0 place in open source projects and is often more harmful than useful when you consider the pure health of the code. People are less likely to engage if they don't feel safe and things like "micro\-aggressions" are a way of preventing people from giving honest feedback, ergo making them feel unsafe to do so.
If it does the job, that’s all that really matters. That and it’s maintained. I don’t want to have to fork a third party library and maintain it. Already done that a few times.
I don't think you are going to be able to achieve this without making some kind of code change to the way senders and receivers communicate. As you said, once your proxy receives from the sender, the sender unblocks, regardless of where you are going to forward that data. Are you able to make changes to the sender and receiver semantics? If so, you could send messages that contain a reply channel. So a sender would have to wait for a done reply on the message after it unblocks. Any number of proxy receivers can pass along the values, and the real receiver will notify the done channel. 
Please link the proof whenever you are able to.
Ultimately, you don't own the project. Someone else does, in some cases legally (as in IP right around names and logos) and in other cases just morally as in "I started this project and got it off the ground and I have the moral authority to claim that leadership role" (think Linus or GvR here). They get to make the rules for how their project is run. And if you publicly behave in a way that makes them not want to be associated with you, they get to do that. Again, I'll compare it to employment. If I show up on the news tonight dressed as a Klansman at my local Wal-Mart, my employer will fire me. You have no right to dictate the terms of someone's else's need to put up with your crap. Whether or not there's a CoC in place is irrelevant. The CoC is just notification of what they could have done anyway. In the rare case that someone is being punished for saying, "you know, that Donald Trump is a handsome man with the best hair", then I'd agree with you in saying that community standard has left the tracks and is just beating up on people for not being sufficient liberal. But that's a problem with the specific people, not with the idea of a CoC, and I don't think it's a huge problem in practice.
It doesn’t seem that odd. Go is inherentenly deaigned to be simple, which does not leave much to say about it other than some tired comment about generics that nobody wants to read, or write. The CoC is complex, leaving potentially many things to say about it. 
Can you clarify how you define "pre\-existing member" and "non\-member"? Is it about this subreddit specific or the Go Community as a whole? Is it enough if someone mostly reads discussions here or do you disallow the silent majority from speaking up in these instances? Will I get banned if I try to voice my opinion here?
Are you a rust user? If you are not and you have never been to the rust forum then I agree, but why shouldn't users of a language discuss the CoC even when they might have been mostly just reading the discussions so far?
Interesting! Thanks for sharing
What I'm saying is that the entire part you quotes, including the part you put in bolt text, is refuted by the part you didn't quote. I don't feel that your post took it into account, as "open to different interpretations" is still using the invalidated clause. I'm glad you have faith in Cassandra. What about her as yet unnamed replacement? This document does not empower Cassandra, it empowers the position. And Cassandra is not a lone actor, she is an employee of Google, with all of the baggage that implies.
&gt;But in complete earnestness, I bet most women in the go community deal with some form of behavior that I think is fair game to be called out and curtailed. Don't you think it would be a good idea to know what that is *before* writing a policy to solve it?
I've never understood why programming needs to be diverse. I don't care if the letters on my screen, or the program I'm running were from a black person or a white person, or any other race for that matter. Google is so far up it's own butt on social justice issues, they can't see the light of day
Because people get offended when you have conservative views these days
Studies have shown diverse groups perform better. A more open and welcoming community expands the number of people willing to contribute. 
I've filed [https://github.com/tobgu/qframe/pull/3](https://github.com/tobgu/qframe/pull/3)
Google was aware, although the details of the reports to the committee have not be made public. I know personally three women Gophers who have said "Fuck this place" and stopped being involved in the community due to harassment on Reddit and Twitter.
I've filed [https://github.com/tobgu/qframe/pull/3](https://github.com/tobgu/qframe/pull/3)
Citation needed on "everybody needs reasonable explanations of behavior", this seems like another opinion. 
https://github.com/nagadomi/lbpcascade_animeface/blob/master/README.md
Rekognition does not support face detection on cartoons.
Attack the arguments, not the person.
Neither is the go community.
I'd use a [B-tree](https://github.com/cznic/b). It sorts and deduplicates in the same time.
Thanks! I'll have a look later.
You need to call SetHeader() before a call to WriteHeader(), otherwise the header won't be set.
The official Reddit app is terrible. I use Reddit is Fun. There is a formatting bar it ssdlty it doesn't include code. :( 
That's not how it works. You're acting like the tiniest of infractions incurs the greatest of penalties, and that's not true. Most of the time there will probably be no "penalty" other than someone saying "hey, please don't say that".
This is explained [here](https://github.com/golang/dep/blob/master/docs/FAQ.md#concepts-1)
Exactly. Thank you.
The first amendment doesn't work that way. This isn't a public building. Also, we're not your employer. This is a reddit forum.
This is highly unlikely. Just as in the criminal justice system, the severity of the crime determines the severity of the penalty. If you're just being a jerk, all that's going to happen is that someone might tell you to cut it out. If you're making death threats against someone, yeah, you might get banned or fired. I don't know why everyone assumes that the tiniest infraction is going to incur the maximum penalty.
&gt; Why do all arguments against the CoC rotate about "but what if the stewards turn into evil, cripple minded zombies hunting anybody who is not worshiping them"? Because that's the *very* obvious problem with the whole thing. Google has a reputation of having something of an SJW culture internally. There's a very real possibility that the Steward's position may at some point be occupied by such an SJW whose priority is politicising everything and ostracising people for using the "wrong" pronouns or other such irrelevant bunk. 
It's not about who wrote what, but the technical perspectives from a diverse group of people that matter. People from different ethnic groups, race or gender have different perspectives and that's important to acknowledge when building a community.
Kind of a wild approach but you could use a set of constantly updated bloom filters to reduce the memory consumption in larger data sets. 
&gt; who you chose to communicate with rather than the tone you communicate in. Perhaps, but it seems to me that if the communication is (semi-)public, anyone not actually involved in the conversation can take offence at it and complain about you. Apart from the many people who are genuinely so thin-skinned they're emotional butterfly children, there is significant scope for abuse. 
[removed]
You don't think that is a bit of a stretch?
It's good to set clear expectations for behavior. However, if the project owners can declare a set of rules and demand that they be followed, they could just as easily keep these rules to themselves and correct behaviours they, in their sole discretion, deem toxic. That is how behavior is policed in the workplace in the United States. This code of conduct is the community equivalent of writing an employee handbook to give yourself just cause to fire someone for being an asshole, even though they're an at-will employee and you can fire them at your discretion (provided that the reason is not discriminatory).
[removed]
Sounds good - appreciate the response. I agree, this seems most clean. I already planned on not using the protobuf classes outside of the grpc implementations, even if it results in some struct duplication, I didn't like coupling my rpc choices with the actual libraries/etc. As such, as unfriendly as it feels it would make sense to include `error_code` / `error_message` style information in the actual protocol success response. This can, of course, be abstracted in that rpc-&gt;lib translation layer to create an actually `error` from the `error_code/message` stuffs. Thanks for the insight!
While this is definitely possible, some of us \(like me\) are lurkers. 
Agreed. Keep on trucking!
Hey, at least we are in agreement over the examples you listed. That's good. Your last comment however doesn't read as much more than an attempt to delegitimize other Gophers by characterizing our concerns as ridiculous or paranoid, which honestly provides legitimacy to our concerns. As Gophers, we explicitly handle our errors when we code. Assuming a function will always perform as expected, despite the contrary being possible, is bad practice. Edge cases should be considered and handled.
Nobody is being banned for having a different point of view.
&gt; Studies have shown diverse groups perform better That does not support the conclusion that "diversity is critical to the project". "Desirable", yes. "Critical", no. 
I don't agree that this is a good idea, however there are quite a few libs that people have written to do just what you are trying to do. [https://medium.com/@matryer/introducing\-vice\-go\-channels\-across\-many\-machines\-bcac1147d7e2](https://medium.com/@matryer/introducing-vice-go-channels-across-many-machines-bcac1147d7e2) is one example.
[removed]
they do this so the go tools and unix utilities are present to aid in debugging
The Alpine overhead is small. Less than 5MB? With Alpine you can start a shell in the container for diagnoses. And it also includes the files to verify SSL certificates for HTTPS and so on.
I think it's interesting how the Go team requires [experience reports](https://github.com/golang/go/wiki/ExperienceReports) to give evidence that a problem exists, is a valid problem to try to solve, and is better solved by changing the language than by using a different approach.... ... but for the CoC, none of this has happened. I'm sure the core Go team has their hands tied on this. They have a boss they report to, and something like a CoC is not their area of interest or expertise and not a hill they'd choose to die on. Honestly, I feel bad for you guys having to spend your energy on this stuff... But that doesn't mean it gets to go unchallenged. There's a lot of us who use Go daily and are seriously invested in the success of the language and the community. We truly do want everyone to be excellent to each other, but that's not really what the CoC is about, is it? The CoC is a semi-formal document providing a mechanism to exclude people based on vague terms and impossible scope that would make a HOA cringe. From a practical standpoint, the change of scope is the biggest concern I have. Giving community leaders this sort of carte blanche discretion to decide someone can be excluded because of something they said some other time in some other place on some other topic, that's just silly talk. And not to sound all Chicken Little, but let's not pretend there haven't been headlines about exactly that sort of thing happening. People losing their jobs because of decade old tweets that reflected mainstream public opinion at the time, that's scary. Hell, just commenting that this CoC may not be the pure and true way could be enough to convince people I'm toxic. So I'm politely requesting experience reports that justify the change of CoC. I'd like to hear from people who have felt unwelcome in the Go community because of other members' conduct. Let's discuss the validity of it, determine if it's a problem that needs to be solved, and debate if a change to the CoC is a better option than taking a different approach. 
What makes you think there haven't been experience reports? The linked article specifically said there were such instances. I don't think they need to be made public to be believed. For every instance of someone losing their job due to a decades old tweet (which I very much doubt actually happened more than possibly once), there's literally 10,000 people being harassed every day, with very little recourse in most cases.
Lux is fine
How can I know the sun will rise tomorrow? I can't. But given what I know about celestial physics and the Go community, I think both are a fairly safe assumption. I do know definitively that I will not ban anyone for calling someone an idiot on Twitter. I won't even ban someone for calling someone an idiot right here. I will remove that post and tell them not to do it again. And if they keep doing it *then* I may well ban them. People are just people, man. We all just want to go talk about goroutines and joke about generics and argue about the merits of vgo downloading code when you run go build. Nobody is out to get anyone. And if they are, it's usually really friggin' obvious. We're not idiots. You can't just say "that person offended me" and expect them to get banned. I've been a moderator in r/golang for quite some time now, and I can tell you, the number of times I've had anyone ask me to ban someone is zero. The number of times I've had someone ask me to even remove a post is zero. Posts honestly don't even get reported that often. 
[removed]
I think you're missing his point regarding methodology. Imagine saying, "Look, there's literally 10,000 use cases for generics encountered everyday. I don't think we need to make them public to be believed. Maybe there's one reason to not add them (which I doubt)." What's good for the goose is good for the gander. If there's so many problems with the existing CoC (which I'm not even disputing), can't we discuss that as a community and work with facts and data? It does kind of feel like this is getting ram-rodded through, which really hurts the "just trust us" stance. Is it really 10,000 to 1? Eh. We'll never know because the discussion didn't happen. I have a hard time seeing some of these mod comments and believing they're written in good faith. And for what it's worth, I'm a lurker, but the last time I commented here a couple years ago, I said good things about the CoC.
https://github.com/coreos/bbolt
Because if you don't want to turn an open source project into a political arena, that's the best they can do. They are there to work, they understand there will be cases of rudeness, but they ultimately know that people enter the project to work and that the community will sort themselves.
* sqlite * https://github.com/siddontang/ledisdb * https://github.com/boltdb/bolt Or for a bigger list, https://github.com/gostor/awesome-go-storage
Why is the onus on me to provide an exhaustive list of ways to be an asshole? I fail to see the problem with saying, "hey everybody, don't be an asshole". I see a long history of people being assholes, and almost no examples of people using "don't be an asshole" policy to discriminate against people for bad faith or disagreeable reasons. The subjectivity here feels like a pretty harmless things to me.
This kind of thinking doesn't achieve anything. This CoC makes people shut up. That's it. It doesn't stop toxic people from thinking a certain way. &gt; do you think someone who is Jewish would feel comfortable hanging out with them at Gophercon? At least the Jewish person knows who to avoid. By shutting people down you lose that advantage and will never no idea of who you are interacting with, since they can't say what's on their mind. So this CoC achieves two things: it encourages the toxic people to hide their thoughts, and give power to CoC enforcers to subjectively punish anyone both good and bad.
I don't think anyone said microaggressions == harassment. I didn't mean there are 10,000 people suffering microaggressions, there are 10,000 people suffering real, serious, targeted harassment... death threats and dogpiling and more. There's probably way more than that suffering from just people being jerks. Anyone is welcome to file a complaint against me. I'm not worried about it, because I know there's a real human reviewing the complaints who will look at the exact content of my comments and the context in which they took place, and the rest of my behavior in general... and if they decide that I crossed a line, they'll probably just talk to me and ask me to maybe cool it a little. I'm not sure why everyone reads it as "if you do the least of these things rarely, we'll treat it as if you've done the worst of these things over and over". 
[removed]
[removed]
[removed]
This is a reddit forum (mind you, it's not *your* reddit forum, as you seem to think it is), but the greater Go community (for which this CoC applies) is not a reddit forum. 
It really depends on what you need. If the application is write heavy, I would suggest leveldb or rocksdb. These are lsm tree based which makes the writes fast at the cost for a simplistic key value scan based query interface. If the workload is read heavy, boltdb or lmdb would be a good choice. These are primarily btree based. Finally, if a rich query interface is a priority, the storm library for boltdb and sqlite are probably a good choice. TLDR; understand your workload. Simple key value - leveldb, rocksdb, boltdb or lmdb. SQL interface - sqlite
This isn't the actual name of the function. It's just an example.
[removed]
[removed]
Sorry, I think I was unclear. I meant, there's 10,000 people suffering serious harassment in general. Not in the Go community. I don't have any hard numbers about the Go community, but I have definitely seen harassment of people in the Go community.
I use chi and wrap it with https://github.com/apex/gateway
Seconding this, no need to give in to the hype and use some poorly tested database engine when there's SQLite if it would work well. If you use `PRAGMA journal_mode=WAL` to enable read/write concurrency, it won't be as slow as some people say it is. Of course there's still a lock to serialize writes, so in case there are multiple processes often writing to the same database at the same time, SQLite wouldn't be a good solution. Otherwise, as long as writes are done in batches as much as possible, performance can be really good.
Thanks for your reply. (and all the others as well) What would be your thoughts regarding one more consideration I did not list before and that is the ability for a malicious user to tamper with the data embedded in the db? Are there any pros/cons among the choices you listed with regards to that consideration? 
this.
[removed]
This likely has little to do with the DB you choose, and more to do with your security practices. You'll want to make sure your application's memory and the DB file are protected.
Nice! I looked these over and will try them out.
[removed]
You could try [Bow](https://github.com/zippoxer/bow) if you're looking to persist structures rather than raw bytes. Bow implements buckets and serialization on top of BadgerDB which is [pretty](https://blog.dgraph.io/post/badger/) [fast](https://blog.dgraph.io/post/badger-lmdb-boltdb/). Disclaimer: I wrote it, and it's still in early stages.
It's all well and good until you start using cgo. It can be done but behind those doors lie dragons.
It gets completely optimized away. https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go
/u/dgryski: why has /u/4ad been banned?
/u/4ad has not been banned.
Awesome, so then you agree this is unnecessary since there isn't a problem. Really though this is only going to serve to reduce contributions and encourage witch hunts, not actually prevent issues sadly. Clearly the mods have managed to handle things without such draconian measures without issue.
Then why can't I post? 
I would try it with a giant map/set with a single sort at the end, see how fast that is. If it's fast enough then you didn't waste any time. If I was pretty sure that wouldn't be good enough, I'd probably look at the problem as a variant of tape drive merge/sort. https://en.wikipedia.org/wiki/Merge_sort#Use_with_tape_drives 
\[This post of his\]\([https://www.reddit.com/r/golang/comments/8ln14a/updating\_the\_go\_code\_of\_conduct/dzifatt/](https://www.reddit.com/r/golang/comments/8ln14a/updating_the_go_code_of_conduct/dzifatt/)\) did not appear on this page until 5 minutes ago, but it was on his chronology. I do see it now.
The mods currently ban people and delete comments for completely arbitrary reasons so this code of conduct simply codifies thier current behavior in writing.
&gt; any proof of Class A existing?... All you have to do is actually read the announcement. &gt; There were a few reported incidents where actions took place outside of project spaces but the impact was felt inside our community. To be fair, that isn't "proof", and not having seen the evidence myself, I can't say with 100% certainty that these instances were necessarily what I would call bigotry. "impact was felt within the community" is pretty vague, and I would have appreciated a bit more specificity there. But lets be real. If you haven't seen bigotry on the internet, then I don't what what bubble you've been living in. Furthermore, it's preposterous to assume that programmers (of any language or project) are somehow immune from bigotry. Group A is inevitable and it only takes this simple logic with a bit of statistics: *If some fraction of people are bigoted, and programmers can be bigoted, then there exists a size N such that programming communities larger than n are extremely likely to have at least 1 bigoted member.* In other words, if we don't have a "Group A" yet, we will eventually if we keep growing without moderation. We could argue about how big or small N really is and if Go has crossed that line yet or not, but the existence of the "reported incidents" above leads me to believe that we are beyond it. Either way, it's something we'll have to deal with sooner or later whether you like it or not. All that said, I do agree that not having real proof makes is much harder for us to have this debate, but in this case, real proof would be making the "reported incidents" public and that's a terrible idea. You yourself raised concerns about how we should avoid ruining people's careers over this. To quote you directly &gt; WRT people losing their job over tweets, how many ruined careers would you say is the number we should be targeting? I'm assuming that was a rhetorical question and the answer is 0, and I totally agree with you here. Whenever possible, the Code of Conduct should be enforced in private whenever possible so that people don't get broadly blacklisted in the industry. **CoCs should never be used for witch hunts.** If anything, they help avoid them by outlining a non-public process for mediation. Witch hunts happen in cases like Opalgate precisely because there wasn't an established private process (like the Go CoC provides) in which to air those grievances. To be clear, I'm not saying that everything should be secret and you should just trust that everything will be find. If someone thinks they were unjustly ousted from a community and wants to come forward with their story, that's good. They have every right to shed their anonymity and make their case publicly. It's another thing entirely if the CoC working group publicizes details of a case and causes a witch hunt just to prove a point. So don't hold your breath for "proof of Group A". Long story short, you can't have it both ways. You can't demand proof that would hurt people's careers and at the same time argue that we should avoid hurting people's carees. I do wish they'd given a little more info than they did. There's probably a middle ground somewhere between "there were reported incidents that affected the community" and "we've made these reports fully transparent. Grab a pitchfork!", but it's a fine line. Reporters, bloggers, and [reddit in general](https://www.reddit.com/r/OutOfTheLoop/comments/2r3d54/what_happened_with_reddit_and_the_boston_marathon/) are all amazingly good at finding scapegoats. Releasing as few details as possible hurts the discussion, but is arguably better than risking a witch hunt.
[removed]
&gt; You're acting like the tiniest of infractions incurs the greatest of penalties, and that's not true. Prove it.
"Freedom of speech" does not mean "Freedom from consequences of that speech".
[removed]
[removed]
Few ideas on making things more composable: // filtering f := f.Filter(qframe.Or{ qframe.LessThan{qframe.Column("Col1"), qframe.Int(2)}, qframe.Equal{qframe.Column("Col1"), qframe.Str("a")}, }) // grouping f = f.GroupBy("Col2", "Col3").With("Col1", qframe.Sum{qframe.Elements("Col1")}) // manipulation f = f.With("Col3", qframe.Concat{qframe.Column("Col1"), qframe.Column("Col2")})
Not in the least. Freedom of speech **is not** freedom from consequences. It's a subtle difference, but it's important. Let me try to make it simpler. Freedom of speech means that Alice can call her black neighbor Steve the N-word and not get arrested. However, when Alice's friends tell her that they like Steve, and they don't want her coming around to their parties anymore, that's also within their rights. Alice can talk till she's blue in the face about freedom of speech, but it doesn't protect her from the consequences of her actions. I will fight for anyone's right to say anything that is protected by the 1st amendment. I will also fight for the rights of a private social group like the go community to self-moderate it's membership as it sees fit. These two things are not mutually exclusive. 
I agree. When people say they want to take someone to court to call something illegal, that's usually what they mean, though.
I am a Go user, and lurker of this sub. I am also white and male. If you are worried about pushing out the next Linus Torvalds, or other great programmer who enjoys majority status in the community, then you similarly should be aware of the fact that non-majority programmers of high skill HAVE been lost to communities for decades. I see it as implicit belief held by those opposed to CoC that the spaces being governed are inherently meritocracies and free of any social issue. However, this is plainly untrue. I highly recommend anyone who is feels the CoC attacks them to not throw out their complaints, but rather consider them while exploring the experiences of those who are marginalized. I do not think the experiences of others are easily understood or digested, and their place in this is often not bridged into this discussion. Hypothetical worry should be tempered by consideration of concrete issues that the CoC attempts to address. Listen to marginalized programmers or read the experiences of others with an eye not to how it affects yourself, but how you would feel experiencing that same situation. The fear in this thread shows that you all have pretty good imaginations. Use them in an empathetic manner to put yourself in the experience of others. There are dozens of blogs and books written by the affected, but I think they tend to only reach those who are already sympathetic. Look for open letters from programmers leaving major companies. There is a recent book, *Broad Band* by Claire Evans which also serves as a good chronicle to women who have made a big impact on tech, and the issues they have dealt with. It is funny - I think a lot of the actual day-to-day struggles read like the worst fears of CoC-dissenters in this thread. Including extremely talented programmers being lost to communities, with those communities suffering as a result. You may find that it turns out that the fear of persecution is brought about for the benefit of people who are ACTUALLY facing persecution, often silently, for **your** comfort on a daily basis. 
[removed]
[removed]
It's not obvious, but this would actually be equivalent to insertion sort, which would be inefficient.
Using Alpine as the base image was a fad for a while, because it can create smaller images. However, it has a lot of quirks, like a different C library (with requires a lot of libraries to be recomplied). In practice, because of Docker's support for caching, it's usually better to just use the Ubuntu image as a base since it'll probably be pulled in by another docker image anyway.
[removed]
It was probably removed because the mods are only human, and tired, and trying to reduce the rapidly expanding tire fire this thread (and literally every other CoC thread on reddit) has turned into. I've put it back.
Perhaps your definition of "being an asshole" turns out to not actually cover the behaviors which are harming the community and its members, so now your policing apparatus is aimed at the wrong problem. I mean... knowing the nature and prevalence of the problem you are trying to solve would seem to be the obvious first step.
Sorry for the confusion, I meant private in the "not publicly funded" sense. Not the "invite only" sense.
I hope we can get a suitable track from [XTC's album](https://en.wikipedia.org/wiki/Go_2) used for the launch party.
[removed]
[removed]
It's called [the paradox of tolerance](https://en.wikipedia.org/wiki/Paradox_of_tolerance).
Thank you for this insight. If I understand correctly, the key point is that distributed synchronous Go channels could not be guaranteed to synchronize because of network delivery failures. \[apart from the lack of capability of peeking into a channel\] However, think of this scenario \[assuming we can peek into a channel\] . A **Sender** goroutine that runs on a machine and **a Receiv**er goroutine that runs on another machine after a network connection between the two programs has been established. A message sent t**o Send**er's channel is intercepted by a library that through the use of TCP sends the message to the library instance used b**y Receiv**er. The library instance used b**y Receiv**er then adds the message to the channe**l Receiv**er is listening on and then acknowledges that the message was delivered. Th**e Send**er is then unblocked by the library. TCP guarantees that if data is delivered it is correct and in correct order. If something goes wrong in delivery, the result with the scenario above would be that **Sender** and **Receiver** would block forever. I assume you would say that this behavior is not in accordance with the "exactly\-once" delivery mechanism. Other than that, if there are no network failures the behavior would be the same with local Go channels. P.S. In your first reply you mentioned that synchronous distributed channels are impossible to implement. Then, is it the case that asynchronous distributed channels can be implemented?
&gt; Apropos That green blob looks really unhealthy.
Alright, but have enough confidence right now to think it's appropriate to make a decision, run with it, and recover later if it turns out we're solving the wrong problem. That's an appropriate risk given what I know to be true.
[removed]
Make sure you're happy with false positives. You also need to make sure you need it in the first place. Bloom filters are cool and all, but they require multiple hashings of a number and multiple reads or writes of random memory for every use.
From Brad Fitzpatrick's [twitter](https://twitter.com/bradfitz/status/999729098074112000): &gt; Personally, I'm rooting for generics &amp; better error handling.🤞 
I think we have to agree to disagree on what should be specific and what should be vague. There's value in vagueness in that it allows a static document that cannot predict the future to let reasonable humans to make value judgments that look at the context and then put the spirit of the document (which in this case is just "try to treat people with respect") over the letter of the document. Vagueness is bad if you expect an abuse of power, but it's good when the people with that power are acting in good faith. I have had the benefit of briefly meeting Cassandra Salisbury (the new project steward) at GothamGo last year, and I can assure you that she isn't in Group E. She's a good and reasonable person, but don't take my word for it. Get yourself to a conference and meet her for yourself. I'm sure it would allay a few of your concerns. The thing about Group E is that 1) they're roughly as small as Group A, and 2) they aren't a problem as long as the official mediator/arbitrator is a reasonable person (which she is). The CoC is very clearly reserves the right to not take action on unreasonable reports. You act like a single inadvertant microagression would result in an insta-ban. That couldn't be further from the truth. The whole point of this exercise is to help grow the community. Waving the banhammer around willy-nilly would be exactly the opposite of that. Lastly, /u/deong summed up the value of subjectivity so well, that i'll just refer you to his comment elsewhere in this thread https://www.reddit.com/r/golang/comments/8ln14a/updating_the_go_code_of_conduct/dzhe64o/
Also: &gt; Don't worry, we don't make design decisions based on internet comment sections. 😄 👍
Are you familiar with versioning in other languages? It allows you to "lock" the version of a library you're using so it's in sync across a team or different environments.
Yes, that's a good thing considering how a lot of this sub considers even the slightest suggestion of change a personal insult.
Besides generics (which I am happy to see on the list, but skeptical whether they will be implemented, nevermind implemented in my preferred way), I am very excited to see that the standard library may be versioned and allowed to be used separate from the Go release it was created for. Our team prefers to keep compatibility with the two most recent Go releases just in case there's a bad compiler bug in the latest release with no immediate fix, and this would allow us to use the latest standard library features sooner.
[removed]
[removed]
"Conservatism" is just being offended by different shit. You're offended by national/cultural integration/diversity. You're offended by taking pitifully small percentages of corporate profits to improve society. You're offended by homosexuals. You're offended by labour rights. 
[removed]
\- Sum Types \- Matching on Sum Types \(with exhaustiveness check\) It's borderline criminal not to have these in a statically typed language, given how much it amps up robustness by forcing you to handle edge cases.
And before the symbolic notation was written, it existed in the neural network of a human brain... and before that human brain, there was a homo habilis brain.
Please don't talk to me like you know me.
&gt; (and literally every other CoC thread on reddit) It seems as though there are a lot of people who don't feel their concerns are being met in most CoC's. 
Thanks for replying. So you're saying that when the gc follows the sliceHdr pointer that the gc is not aware that the object it is scanning is in fact of type `string` ? That seems weird. Wouldn't that imply that storing things-containing-pointers in an unsafe.Pointer would cause gc to miss those contained pointers? When I look at how `atomic.StorePointer` is used in the standard library it looks like gc knows the memory's type even when the code has lost track of it. For example in [sync.Pool.pinSlow](https://github.com/golang/go/blob/master/src/sync/pool.go#L213) a `*poolLocal`, which itself contains pointers (it contains interfaces), is stored long-term in a field of type `unsafe.Pointer`. 
I don’t have an answer but I’m interested to hear some. Best of luck with your search.
Is this to make programming better or to reduce the mouth-foam in Go threads over at /r/programming? Maybe both?
Whoops, you are right, a B\-tree would get you O\(n \* lg\(n\)\).
It will be totally fine to keep using dep, at least for a couple of months. Right now anyone writing executables should probably wait until more libraries convert to vgo.
Yeah, they make decisions based on internal discussions and use cases. Nevermind the community.
It could also seem that there's a concerted effort from the denizens of Kotaku In Action and related subreddits to discredit all attempts to enforce any standards of behavior. But we'll never know.
https://github.com/revel/revel/issues/1270
This literally doesn't help me at all, because the general format that the commenter gave is exactly what I have basically, minus the pointer to the struct. And even if I remove the pointer, the `log.Println(body)` is still `{}` so nothing has changed.
&gt; Version 0.16 started automatically capturing request containing a json body (specified by the request header) and placed that into the c.Params.JSON object
Idk I just use these. Might have to look up others. https://www.vividcortex.com/resources/the-ultimate-guide-to-building-database-driven-apps-with-go http://www.alexedwards.net/blog/organising-database-access Tutorials - http://go-database-sql.org/index.html https://github.com/golang/go/wiki/SQLInterface Structs to tables - https://github.com/samonzeweb/godb/blob/master/README.md
The history of things and people is something I find interesting. This CoC is based on the [Contributor Covenant](https://www.contributor-covenant.org/version/1/4/code-of-conduct.html) - created by Ehmke., Though the scope has been widened with the addition of *This Code of Conduct also applies outside the project spaces...*. It sounds like this authoring Contributor Covenant potentially contributed in part to Ehmke getting hired at Github for a while in their Community &amp; Safety team - she tells her fascinating story here: https://where.coraline.codes/blog/my-year-at-github/ She also triggered an interesting exchange with the Opal project, one contributor tweeted on their person twitter feed a statement some found offensive and Ehmke called for said contributor to be removed from the Opal project, this all unfolded here: https://github.com/opal/opal/issues/941 So I guess what I'm trying to communicate, is if eventually people get removed from the Go community for their ill considered personal social media interactions not connected with Go, I won't be terribly surprised. It is after all what the original writer of the CoC would have done.
the creators of the language seem to think some of the proposed changes (i.e. generics) are an insult.
So the context package has been a source of contention for our company. Doesn't seem like Rob Pike really like it.Do you think they will get rid of it?
What exactly is the request that you are submitting?
You missed the talking point about the Ruby code of conduct proposal: https://bugs.ruby-lang.org/issues/12004
From the garbage collection view, unsafe.Pointers is not different from safe pointers. But the type of sliceHdr.Data is uintptr. Uintptr is different from pointers.
Sadly I feel context is here to stay.
I was more worried about the size of the container itself, not the speed of pulling/building images. Smaller size helps especially if you running on cloud platform with pay-what-you-use model. But I think I am clear now about pros and cons between the 2 choices. Thanks guys.
I hope simplicity won’t take a hit. It’s my favorite feature.
There's a lot of that attitude in the Go community, I find. I hate this mentality that people are stupid or are bad programmers for wanting features that every other modern language has. "You don't *need* generics, you just *want* them". Sure, I also don't need functions if I have `goto`, and I don't need a division operator if I have subtraction and a `for` loop. It's a terrible rebuttal to a legitimate argument, but I see it a lot.
right, the docs say `Params.JSON` is a byte slice. you're never changing `u`, so that's not going to contain anything. According to https://revel.github.io/manual/parameters.html &gt; JSON data will be automatically unmarshalled to the first structure or map that is encountered in the Action Argument. but your `Create()` function does not take any arguments. It also seems to say that if you do not do that, you could also use `BindJSON`.
I used both VSCode, vim as well as GoLand to code Go so here is my 3 cents: - In GoLand, I have the least amount of time having to spend on terminal. Support for GoDep, Vgo, code lint, build, debug came out of the box with little/minimal setup required. - I also dont need much additional software to connect to other services such as MySQL database. Because inside JetBrain IDE its built in. - Support for file structure view. (In vscode you only have a dropdown menu which will disappear if you were to alt-tab. - MacOS Hotkey system of GoLand is subjectively to me better than VSCode However, I still switch between editors frequently. Main reason is that I feel like GoLand is too heavy for some of the smaller tools/projects i have been working on. VSCode, despite being electron, to me still much better than a whole JVM needed for GoLand. And since most of my GoLang project are small tools and services, lightweight editor is still a heavy favor for me. the bigger the project(especially the ones involved RPC schema such as protobuff and flatbuffers), the harder it is to navigate and GoLand is a lot more favorable.
Have you tried SVGo? https://github.com/ajstarks/svgo Here’s the presentation from GothamGo this year, amazing stuff. https://speakerdeck.com/ajstarks/go-for-information-displays-gotham-go-2018-edition 
Sure, I agree that just suggesting or wanting a feature isn't enough to warrant adding it. I was only trying to make the point that just because some feature isn't "100% necessary" by someone else's standard, or because it's a creature comfort, that doesn't make it bad or not worth considering, and it doesn't necessarily mean someone is wrong to want it, but I see that exact argument a lot. Also, I wasn't trying to advocate for `goto` or removing the division operator, I was using that as sort of an extreme "logical conclusion" to that flawed argument.
That's not true. Ian and Robert (two of the original 4 creators) are the two most thinking about generics. Ian has been wanting and thinking about them forever, AFAICT. 
No, it won't be removed. If anything it'll become more pervasive in APIs but also maybe promoted to be a more first-class (and often implicit or automatic) part of the language, so it's not so burdensome, but still there when you need it. 
This movie might be helpful... There's something already that do what you mention, but seeing Brad and adg building it is fun. https://youtu.be/1rZ-JorHJEY
https://godoc.org/golang.org/x/tools/cmd/tip is the source code.
Any plan to remove the GC LOL
Some thoughts: * It would be nice to have a schema for the JSON API: swagger/openapi. * You could create or codegen structs that consume/produce the API JSON, and map that to internal structs * I like the "completely different approach", all fields exposed, document the fields about its use * long parameter list is fine, it actually helps debugging panics * \`NewFoo\` with only writeable is an easy helper function * I have not seen \`UpdateFoo\` approach before but seems ok * the google protobuf library uses the convention XXX\_ to denote internal fields, which I don't really like, but it is a popular library
I hope the designers consider updating the sql value interface. At the moment it's \`scan\` and \`value\`. It would be nice if it followed the rest of the convention of MarshalSQL &amp; UnmarshalSQL. Also a logging interface.
I'm not sure if you're joking or serious due to the random LOL in the middle of your post.
How about joking seriously.
Manually freeing heap allocations opens the door to use-after-free exploits.
I wonder how generics would affect the built\-in maps and slices. Will we get some kind of extra functionality added to `make` for instantiating specialized containers? Will it be removed? Will it just stay the same and keep the built\-in maps and slices the way they are? It'd be weird to have built\-in maps and slices with pseudo\-generic functionality and a library of containers with full generic functionality. Granted, in the 10\+ years Go has been out, only one specialized container was added to the standard library AFAIK.
Or maybe just suggest an object can be freed so GC won't need to scan all objects? Maybe it was an bad idea :\
I could easily live without generics. I don’t mind err != nil that much and if you have too many it might be a sign you need to clean things up. I also don’t see it as any more verbose than try/catch or throws. However, more detailed or typed errors would be useful.
I've been turning down speaking opportunities at the moment. Too busy with family and job to think about writing a talk. I will be in Denver though.
Go's error handling is a god\-send when you want to have clarity of what will actually happen when an error is thrown. In Java and other languages it can be pretty unclear what'when/where the error originated, etc.
It seems odd to me to say "if I wanted generics..". You should want generics. They aren't a horrendously complex feature and would clean up the interfaces of libraries you use as well as your own code. The language will get more complex as a result, but I'd argue the complexity added is less than the inherent complexity go code has in *not* having them. Go does not provide alternatives to the problems generics solve. People have to work around the problem in ways that are unarguably less powerful (code duplication, code generation, `interface {}`, etc). Go getting generics and cleaner error handling (possibly like Rust) would make it incredibly powerful. It will bring new people into the community and give the language more momentum which benefits everyone. 
&gt; From the garbage collection view, unsafe.Pointers are not different from safe pointers After calling f() below: var p unsafe.Pointer // global func f() { s := "abc" p = unsafe.Pointer(&amp;s) } is the array of 3 bytes containing { 'a', 'b', 'c' } which `s` pointed to reachable by gc or not?
I don't use go professionally, but here in London I'm regularly getting pinged about jobs working with it. It seems pretty popular and growing.
Smells like a reduced counting sort: let's call it Seen-Sort which is just a large bitmap with bit n set for every integer n returned. Should work because your problem doesn't sound like the numbers are unbound. Seen sort doesn't need to filter duplicates because it even doesn't know about duplicates. It also doesn't need any sorting (like counting sort), the data is always sorted and you even can return the current state while still adding new data.
It will leak file descriptors, or in other words, it will keep OS resources allocated that don't need to be. That's bad. `defer` helps ensure that `Close()` (or whatever is deferred) is called no matter what path your code takes when it returns from the function. If you don't close, you will eventually run out of resources.
Been working in Go as the primary language for around 4 years now (west coast, us). The demand for experienced go programmers is at the highest level I’ve seen in a while. With that said, I’m sure the Bay area is not representative of the majority of the industry so take this with a grain of salt.
That's great, if you break it open an issue on github please :\)
If you haven't been closing file descriptors in Python, you should probably go and fix all your Python code.
Use code generators such as counterfeiter - ezpz.
In addition to what was mentioned, think about anywhere in Python you may have used the `with` statement to leverage a context managers `__enter__` and `__exit__` methods, for example you may have opened files using: with open("filename.txt") as f: f.read() Behind the scenes what is happening is drastically different of course but it has the same affect- when the `with` code block exits the f.close method is called. 
Plenty of openings.... Over 150 at https://stackoverflow.com/jobs/developer-jobs-using-go May find it more frequently used in backend systems, but plenty of full stack web positions too.
[removed]
agreed, just to add to what you write with open\("file.txt"\) as f: f.readlines\(\) This is the recommended approach in python. This is very similar to defer in Go.
We're hiring at SendGrid in Denver, Irvine, and Redwood City, and go is one of the main languages we use.
There are exceptions (the error you get from failing to open a file is often clear enough on its own) but generally, this is a code smell: if err != nil { return nil, err } I would instead expect to see added context at the very least: if err != nil { return nil, fmt.Errorf("failed to charge the flux capacitor: %v", err) }
If you have a long running process, like a server, it will eventually run out of file descriptors and crash. If you're running a script that reads like one file and quickly exits, it probably doesn't honestly matter because they will be cleaned up by the OS when the process exits.
Just to be clear though, one thing that might be confusing to a newcomer is whether they need to close a channel and the answer is no. Nothing gets leaked if you don't close a channel. The only reason you would close a channel is to signal to whoever is listening that nothing more will be sent on the channel.
&gt; In Golang, I have to close most of the things. Umm.. you have to do this in Python too. :D
I'm guessing you mean for live visualization and not drawing images. It's probably the best choice to use something that builds on opengl \(for perfomance\). This will however never be pure Go. You could checkout \[Pixel\]\([https://github.com/faiface/pixel](https://github.com/faiface/pixel)\). It's originally made for games but you can also use it for visualizations. It's a great framework. Especially have a look at the \[IMDraw\]\([https://github.com/faiface/pixel/wiki/Drawing\-shapes\-with\-IMDraw](https://github.com/faiface/pixel/wiki/Drawing-shapes-with-IMDraw)\) package for drawing basic shapes. I recommended this instead of some lower level opengl library such as GLFW because you seemed to be interested in a more productive solution.
surely, it is reachable.
There's a big about this with quite a lot of comments. I suggest you take a look at it, and maybe add to it if you have anything constructive to add. I would personally like to see sum types in 2.0
File descriptors close themselves in their finalizers. Perhaps other resources do to. So while it is bad to not close your resources, it's not catastrophic
Good idea! What kind of indicies are involved, especially with regard to nested fields?
Given the editorialized title, it's perhaps best to read Mark's [initial tweets](https://twitter.com/markbates/status/998881710535266304) that started this whole thing for more context.
I've been working with Go for the past 2 years in cryptocurrencies and some before that as backend dev. My notion is that the demand has increased in the last years, particularly for backend.
&gt; suspect it will depend on the duplicate ratio and density. But radix sort and then merge dedupe would be my starting point. I will give this a shot and report back. Thanks!
Sounds very promising! Can you please elobrate with an example if you have some time. Sorry for being a n00b:)
Might give this a go! Looks interesting.
Along // Storing bitset = all zero for n in everything sent e.g. by url1: set bit n in bistset to 1 // Reading for n in all bits in bitset: if bit n is set in bitset: output n
Thanks for the feedback. The API above is quite different from the current one. Could you please elaborate on what composability issues exist in the current API that the above would solve? I'm not sure I fully understand.
Yep, you're right. I was a bit loose with terminology. Thanks!
I use it alongside C# for server API apps. Though Norway being on the very outskirts of the civilized world, I can't say I've seen a single posting for anyone seeking Go devs around here. Plenty of Java and C#, plus a smattering of Python. So I've had to sneak it into production through the back. Letting Go play a supporting role to take some of the load off our main C# API.
Huh, that seems easy. 
Looks like they loose all CSS formatting sadly. Is there anyway to keep this?
BTW this awesome idea \- using Views \- is not mine, but came from CouchDB.
Bam!
Note that https://golang.org/pkg/encoding/json/ lists these concrete types of errors related to unmarshaling: type InvalidUTF8Error type InvalidUnmarshalError type SyntaxError type UnmarshalFieldError type UnmarshalTypeError Note that each of these types implements the `Error() string` method, which makes them all implement the `error` interface; in fact, even though `json.Unmarshal` is defined to return `error`, in case of an error, it returns a value which is (a pointer to) one of these concrete types. And these types is what provides context, where possible. What you have seen is the result of calling `Error()` on the value of one of those types. If you want to have more detailed control, you may use a type assertion (or a type switch) to pull more data of of an error, like in if err != nil { switch e := err.(type) { case json.UnmarshalFieldError: return fmt.Errorf("%v (details: %s of %s, %#v)", e, e.Key, e.Type.Name(), e.Field) case UnmarshalTypeError: // and so on ... } return err }
My take, not an SWE/dev: I was in a Python or Java is standard sorta place. Started doing things in Go, adoption grew. Went pretty well. Best tool for the job and all that, was better suited for CLIs and simple microservices IMHO. Never worked anywhere that enforced language choice, long as you rolled with something someone else in the team knew that was arguably well suited to the problem.
I’m in the process of hiring Go developers and pushing it an official option for developers within the company. Right now, it’s C# or Java, but forcing a VM on to a hosting platform is expensive in a lot of ways, including financially. Plus, you have things like CLI tools to consider. Not everyone wants to install Java on their workstations. This is in both the Omaha and Hartford areas, but I interview a lot of Java developers looking to make a change and expand their careers. I’ve found that most Java developers that have used other languages, such as Python for example, tend to pick up Go pretty quickly and appreciate the simplicity of not only the language, but the tool sets. For those of you that are in charge of hiring, don’t get frustrated if you don’t see “Go” listed on resumes. Good developers can learn new things quickly. 
The comparison being asked about here however is to scratch.
This to me is the perfect answer. Going without a shell or https support wood narrow the cases where I would want to use something. Even if you don't think you will need SSL, at some point you will probably call *out* to an external API with SSL.
Python has reference counting and destructors thus. you can use RAII type patterns.
[removed]
[removed]
Using pointers will remove the clunk, map[string]*myStructT 
As I said before this is standard optimization in proxy development world on Linux and in many other applications. And as I said before we have different standards, that's why probably I use haproxy and nginx and not some caddy which you proved does not prioritize on efficiency/performance.
VSCode
Depends what you mean by 'complete package', really. Most editors have good plugins for the common languages which can help a lot. As well as vim, you might look at: * Visual Studio Code: https://code.visualstudio.com/ (Free) * Atom: https://atom.io/ (Free) * Sublime Text: https://www.sublimetext.com/3 (Free evaluation, cheapish licence)
vim with vim-go plugin
GoLand from Jetbrains , https://www.jetbrains.com/go/
i mean, easy to use interface, auto-completion, showing errors, tools that can help newbies like me.
The plugins for any of the above editors will help with auto-complete, error highlighting, linting and so on.
I would hope that generics would result in changes to standard library APIs. Otherwise you end up with a situation like Java, where major APIs still use Vector and Object because they predate collection classes and generics.
Yes, just ask Russ to do it. Russ as a service should be a thing :D
I feel like Context the timeout handling system and Context the HTTP request parameter passing system could usefully be split into separate things.
As an aside, what's with the format of `go.mod`? Why not a toml or w/e? Is mod a well known / expected format?
This is talking about having some way to run Go 1 code from within Go 2, i.e. packages could either be Go 1 or Go 2 packages and Go 2 could import and run Go 1 packages. That's it.
You can try on the Gophers slack channel #golang-jobs
I will, thanks.
Just ask nicely on Twitter.
\+1
You can find the idea here https://research.swtch.com/vgo-module in "The go.mod File" chapter. 
I invite people to look at the tweet to see what's "nicely".
&gt; he talks about coming at all new community recommended features with skepticism Isn't that a good thing? In my opinion, one of the best things about Go's design process is that they ^(usually) don't add features unless they're absolutely certain that they like them. Even back before it went open source, they only added features of all four of the original developers agreed not just on the idea, but the specific implementation. Personally, I'd really like to avoid Rust's 'Ooh, that's neat. Let's add it.' situation. ^(Disclaimer: This may be an unfair characterization of Rust's design cycle; I'm not that familiar with it. It's sure what it looks like from the outside, though.)
I really like how errors are mostly just strings that change depending on your OS, and can't be differentiated in an API.
+ 1000000
Unfortunately, it's not always as simple. :( Many of my projects depend on `github.com/docker/docker/client`, and whether or not I let vgo read out my old `Gopkg.lock`, it decides to start going backwards through time over all of the Docker "releases" and then some, which effectively means that it never terminates or generates a `go.mod` file. (That and vgo also pulls in test dependencies and unused packages, which I believe is intended, but for Docker this means an ungodly number of random repos to do with AWS/Microsoft/prometheus/etc.) I don't think I'm going to be able to test vgo on anything complicated for a while...
The error type is a interface not a string. 
I don't know if Russ will have time to personally go thru all the issues, but given this is about Docker, maybe you can ping him with an example of this? More cases that are complex will help the tool to mature quicker. I've seen at least 4-5 changes going in vgo today, so it's definitely improving.
It is a solid choice and I share your sentiment on Node. We built a platform (secretly) in Python which got more frustrating as it grew, did another in Node and started feeling the pain right away. This time, it’s a bunch of micro services all written in Go that just run. Starting that conversation about bringing Go in to the company for general use was met with some resistance until I shared the fact that the largest, and most reliable product used in the company internally was all in Go. A lot of the open source tools they are using today, written in Go. Even the platform many of our services run on: Go. There were a lot of shocked people that day. They went into that meeting with a plan to shut down the use of Go because “why do we need another approved language”. They left with a mandate from senior leaders to allow it to happen, because it’s already here and even questioned as to why it took so long for someone to start these conversations. Needless to say, a few arrogant folks got the slap in the face they needed. 
Reading over the github readme and the website I still don't know what this does. I see react, protobuff, headless, user handling, API endpoints, and bolt. What is Ketchup? You need to be more direct about the use-case.
We need a CoC because people disagree with the need for a CoC?
You can also try https://www.moonlightwork.com/
I used to write scripts in Python with JetBrains pycharm, then switched to Atom. Now that I'm coding in golang fulltime I've been using VS Code and I have grown to really appreciate it. In the beginning while setting up my gopath vscode seemed to be modifying my files and I was about to drop using it. however, the built in features drastically speed up my development as far as intellisense and showing errors while I'm writing. I still 'go run' from the command line though so I can choose my.go file with the main entry point. I guess vscode supports this with build tasks, just haven't investigated yet. short answer: vscode. chosen by current $client
&gt;You may find that it turns out that the fear of persecution is brought about for the benefit of people who are ACTUALLY facing persecution, often silently, for &gt; &gt;your &gt; &gt; comfort on a daily basis. This CoC applies to all Google OSS projects. So I don't know if the Go team could change that. [https://opensource.google.com/docs/releasing/template/CODE\_OF\_CONDUCT/](https://opensource.google.com/docs/releasing/template/CODE_OF_CONDUCT/)
The best IDE for Go is any POSIX OS. I realize this is not exactly a popular opinion.
As long as git (or other VCS of choice) can access your repo, it works fine. I've been using vgo on private repos since its release and it's worked perfectly well.
I'm pretty sure when people ask what's a good IDE they mean features like intelligent autocompletion, visual debugging and possibly refactoring tools. I'm as much of a neckbeard as the next nerd who's been using Linux since Slackware and Vim for over a decade, and I'd argue that Windows with VS Code is a better IDE than plain a plain POSIX with plain vim.
I've noticed that the jobs that are pure Go are less frequent than those that have Go as a part of a suite of other required languages for the job. That said, those pure Go jobs are out there, especially on the u.s. west coast. To keep an eye on the kinds of Go work coming up, I have alerts set up on popular job boards (e.g. Indeed.com) for the keyword. As things get posted, I get to see what employers are generally looking for. Best of luck in your search.
The files will stay open until your program exits.
It depends on what it is. By default, if you make a struct with a close method, that method won't automatically get called when an instance of the struct is garbage collected. There is however a way to implement your stuct so that it does this, but it's not good practice to rely on this behavior. See https://stackoverflow.com/questions/8595457/which-objects-are-finalized-in-go-by-default-and-what-are-some-of-the-pitfalls-o for more info.
In addition to this, vgo also has proxy support (see Proxy Servers section of https://research.swtch.com/vgo-module)
In order for this to be true, you must assume people aren't capable of discerning whether toxic behavior is bad, and thus that bad behavior will spread more than courtesy and good manners. That assumption is wrong.
Sure, personally I use VS Code on Mac (although probably moving back to Linux). What I meant to say is that having a capable IDE like VS Code, even when having the handicap of being on pure Windows, is a better experience than having to run your tests by hand on the console and not getting autocompletion/linting.
[removed]
Reassuring to hear, thanks. :)
Sorry my leaders are the ones who get the best code committed. You don't get to tell me who my leader is; my leader is definitely not the person doing CoC enforcement.
You know, a lot of the resistance to CoCs is that they let a "victim" decide when they are offended. You should try some of that on yourself: accept that Bunandfun thinks you attacked him. The *worst* part of a CoC is the selective enforcement, and you're demonstrating how you're blind to that.
Have you tried creating a go.mod file with just the module name and a requirement on github.com/docker/docker/client with a commit hash, then getting vgo to do the rest? It will turn the commit hash into a pseudo-version for you automatically and it won't search for versions if you've already specified one.
If you straight up new, I would not recommend vim. It has a learning curve of itself. The choice is either between VSCode and GoLand. While GoLand is a much better, completed experience in my book, VSCode offer a 'lean' coding experience. You dont get the extra stuffs thus you are more focus on learning the language itself. Go with VSCode. Checkout Just for Func on youtube, a series about learning golang where the author also uses VSCode.
I've just tried it, providing hashes for the docker repos I asked dep to force to master, but vgo is doing it for every other dependency I have as well. I've been running it for a good half hour with no end in sight, and it's currently trying to give me dependencies from 2014. I'm curious to see what it finishes with, if it finishes at all.
Why is that anymore implementation specific than `with`? Generally I agree with you, but Python is built in such a way that half _(if not much more)_ of the language is fucking magic *(I don't like it lol)*, and that magic is "implementation specific details". It's just the nature of magic languages. To that same degree, sometimes you don't even have a choice. What if the implementation told you explicitly that their deconstruction will release connections/etc. Are you supposed to do it anyway because "relying on implementation-specific behavior is bad"? Of course not. Just because the language does something doesn't mean you can or should change it.
[removed]
I wouldn't go with SQLite. At some point, you'll end up with SQLITE_B USY error code, and that will be a real pain in the neck, which will cause huge performance issues on write.
A library that has out dated dependencies really don't belong anywhere in an active project. Diamond dependencies cross projects and depend on unstable code is also a bad idea. Either break up the libraries to do less and not overlap in features, used dependency injection, or stabilise commonly shared code. Build infrastructure shouldn't and can't patch up bad code.
[removed]
My two cents: depends on where you are coming from and what your price point is. Goland is good, like anything else JetBrains produces, but to be honest it doesn't provide enough for me to justify the price over VSCode. So, I'd rank them like this: 1) VSCode: free, great functionality, pretty responsive. Doesn't provide super advanced features, but it provides enough through third party tools (like code navigation, "implement interface", "rename symbol", great linting, etc.). Using vgo right now is a bit of a hack. 2) Goland: adds some refactoring help on top of VSCode, and now has support for vgo, but it costs money and it's pretty damn slow. It has great potential but it's light years away from providing the same amazing support they have for Java, Kotlin and Python. 3) Vim with vim-go: amazingly responsive, provides most of the functionality of VSCode, but everything is a bit more manual and you have to be used to the "Vim way". The debugger is great but pretty clunky if you are coming from the world of Visual Studio or any other "point and click" debugger. I'd recommend this the least for someone who isn't used to Vim, even though the vim-go plugin is an amazing achievement.
[removed]
&gt; offer a 'lean' coding experience. Hi, could you please help me understand where do you think GoLand doesn't offer such a "lean" experience? I'd like to know where we could do better. Thank you.
Not sure what you're responding to there, really. None of what is in this post entails "bad code." It doesn't even entail "honest mistakes." 
Having a destructor is part of the language and not the implementation. It is similar to C++ having destructors and cleaning up resources via RAII. If a file objects closes when it's destructor is called, and in some other python implementation that has no garbage collector you don't trigger the destructor, well then you have more to worry about because you are generally leaking memory.
[Already posted](https://www.reddit.com/r/golang/comments/8m2zro/vgo_analysis_failure_modes/)
No they don't depend on libc \(unless they used cgo\)
You usually get a static binary unless you use something like the user or net package (?). But you can tell the Go build to use the pure Go implementation via `go build - tags netgo` or by setting `CGO_ENABLED=0` in your env. By default you will also get a dynamic binary if you link against go packaged that use cgo, and you don't explicitly static link them. 
Basically, I don't see the examples used been typical of what I encounter, or something that should be solved by tooling.
you're saying you've never encountered a diamond dependency, or an incompatibility in your deps? 
Depending on experimental code that you don't control in production is bad. Depending in libraries that depends on experimental code is worth. Depending on multiple libraries that depends on the same experimental code is unthinkable for me.
Depends on what you're trying to achieve. They will depend on it by default, but you can just use the following command to generate a static library (I usually do that with musl on Alpine, the binaries are quite small then): ```go build --ldflags '-linkmode external -extldflags "-static"'```
And aside from simplifying it by using a pointer, in the current implementation I don't think the explicit delete from the map is necessary. Once you assign a new struct value to the hash key, the old struct will garbage collect 
I also tend to think the cost of switching from MVS to GPS2 if the need arises won't be that high, so we can try out MVS for a year or two and see how it goes.
Deep rooted dependency should be more stable than what it depends on. Import a library that has complex dependencies must be carefully evaluated. If possible, I choose a more simple library or create a different application just for my usage of that library. 
The tool doesn't punish them. That's one of the key points. It punishes consumers of those libs, on the expectation that they will then go and punish the "bad" authors. Lest we forget, those same "bad" people are "good experimenters" when it's pre v1. vgo still doesn't help you, though. IMO, the fact that both of the comments I've responded to here immediately went to talking about "bad" and "punishment" when neither of those words appears in this post to describe a package or person suggests we're already on the path to the breakdown in cooperation.
+ this saves money for buying a mouse, win-win
Depends on the libc you use. musl libc allows fully static compilation, glibc doesn't (since it needs dynamic linking to allow nsswitch to work, a feature musl doesn't have).
Way to miss the point, champ.
Sam, I believe I understand your argument and it is an interesting tack, but I'm just not sure it is as serious as you pose it. Admittedly perhaps my projects aren't big enough and I do tend to pick my dependencies carefully, but the world I live in is one where I pin every dependency until I have some reason not to. And when I do that I expect to have to do a bit of work now and then to fix incompatibilities. I'm ok with that generally, though if I was doing this and noticed the same package making things difficult for me over and over I might first ask them to stop breaking semantic versioning and then it that continued start looking elsewhere. I think that's an acceptable pressure for the ecosystem to put on package authors. (and I say this as a package maintainer myself) I realize there are theoretical downsides to MVS but I just don't believe them to be that big in the real world. As I said, we'll see, it will be an interesting experiment, and I for one welcome it. PS. That said, thank you for all the work on dep! Just because I prefer the vgo approach does not mean I did not like the dep approach!
thanks. decided to go on other route anyway. 
That bug seems fixed.
Thanks for PS 🙂 The system of incentives is there to make this all happen. i agree that it may not in practice, but Also, as I've tried to emphasize at various points, the argument here is not "just use/merge dep." the argument i am working towards is a successor - gps2 - which doesn't have all these harmful misalignments of interests and toilsome work. there are a lot of great ideas in vgo - it's just that MVS carries them to an extreme. to be fair, I'm also implicitly arguing against a number of the points Russ has made in our discussions - he had explicitly focused on the discussion about an asymptotic future. /me considers updating the intro with this context - it's easy to forget when I'm running game models out to their conclusions. 
Unrelated, but why are you doing this: for i := range in { h = sha1.New() io.WriteString(h, in[i].name) hash = fmt.Sprintf("%x", h.Sum(nil)) s = in[i] out[hash] = s } instead of just for _, person := range in { out[person.name] = person } 
we just introduced golangci\-lint \- tool for development environment [https://github.com/golangci/golangci\-lint](https://github.com/golangci/golangci-lint)
[removed]
I am using a map, like makeshift\_mike said LoginInfo is a map and LoginInfoLock is a mutex.
Ya, understood that you are talking about gps2, and I'm sure this isn't the case, but framing vgo vs it comes off a bit weird. I know you acknowledged that in the first of your articles, but even with that I'm just not sure there's any way you can present your arguments against a theoretical thing and not come off badly. If I may, I can feel your passion for all of this in your posts, but I feel like maybe you just need to take some time off for a bit from the package management world and just watch for a bit. For better or worse the ship has probably sailed in vgo making it as an experimental feature in the next six months and from that a lot will be learned. Maybe it will be a disaster and incredibly painful, and if so then maybe that's your cue to propose gps2 or maybe it will have struck the right balance of good enough and that'll be that for a while. But you have to realize when things are out of your control and in those cases just step away for a bit for your own sanity. You have contributed in an enormous way to the Go ecosystem and we all appreciate it! Relax, grab some popcorn and see where it goes instead of being the locomotive as you have for the past few years. There is plenty more to do in time, including package management if this experiment fails.
it's git but it doesn't work, do you have an example?
ioutil doesn't require a defer.close(). I researched this a bit and while I couldn't find documentation to back this up it's what I heard from somone that appeared like they knew what the f they were talking about.
&gt; The upside is you didn't get a 400 line XML stack trace. I don't mind a 400 line stack trace, as long as the part that's in your code stands out somehow. 
One problem I have with the first set of examples is that it's about breaking changes between v0.x.y and v1.a.b. Were it between any other pair of major versions (v1.x.y and v2.a.b, v14.x.y and v15.a.b, etc), Semantic Import Versioning (SIV) would prevent the diamond dependency problem. That problem can only occur in this manner between v0 and v1 in vgo. A package that depends on a v0.x.y (excluding pseudo-versions that look like v0.x.y) of another package is on very shaky ground and it's a code smell that's fairly easy to spot. If we make the (not unreasonable, I believe) decision not to depend on packages that have experimental dependencies, this category of problem generally goes away. Additionally, once versioning becomes default in the Go community, pseudo-versions will hopefully become pretty rare, so even they may become either a code smell or at least something to investigate. Once we reach that point, everything becomes fairly straightforward semver, where both vgo and dep are on a pretty even footing (apart from vgo's ability to have multiple major versions of a package being present in a module).
Not OP but presumably they mean that a full-featured IDE such as GoLand may just overload newbies with information. I am familiar with PyCharm so for me GoLand has been a breeze so far.
The magic trick is that Go's runtime maintains a map that tells it what bits of objects in memory contain pointers (and how large they are). It can recover this information regardless of where it got the address of an object from, so a type-less unsafe.Pointer is no different than a regular pointer; both give the runtime an address, which it looks up in its map and then does further garbage collection processing on. This magic could work with uintptr as well, but the Go runtime doesn't use them as sources of addresses of live objects. As a result, it's valid for a uintptr to contain a number that is not the address of a real object, where it is not valid for an unsafe.Pointer to do so (if the Go runtime ever finds such an unsafe.Pointer, it will panic; all pointer types must always point to valid objects).
That specific bug is fixed (not being able to handle the canonical paths + redirects), it was fixed last month. I didn't intend to say it wasn't, just that it was my minimal example. I can't make it build, unless it's supposed to take ages (which I don't intend to wait on after my last 2-hour attempt). I have the latest vgo, and did exactly the same thing as you posted in that issue, though in a Docker container instead instead of GCE. All I'm seeing is vgo picking ridiculous versions for things (surely a 2015 commit of x/net is not the right thing to do), and still going down and down for different commits of the same repos over and over again.
What I suggest is to look at your snippet from the perspective of not knowing anything else about the implementation. As a reader of your post, I would want to know specifically what errors or wrong behavior you are seeing. And I would want to know what your encode and decode functions are. We can only assume that those variables are a global map and a global lock. Low quality source material will result in low quality answers. 
Its a media server \+ a mobile app. The experience is like using Netflix \(but with your own movie collection\): [https://plex.tv](https://plex.tv)
Unless you have an unusual definition of "native" you can't have a "native GUI" without C bindings for the simple reason that the native GUIs of Windows and MacOS are ***written in C*** (and C++/Obj-C).
Liteide is quite good on Linux too
Is there no such thing as not making win32api syscalls and being able to have a native gui? What you are saying makes sense, I was just curious. Thanks!
Kafka, used in production for years, not considered experimental, was on version &lt; 1.0.0 up until last year. apparently using Kafka 0.11 isncodr smell?
I opened an issue here: [https://github.com/golang/go/issues/25527#issuecomment\-391854583](https://github.com/golang/go/issues/25527#issuecomment-391854583) It seems it might be fixed \(I haven't tried yet though\)
Honestly, yes. A v0 means you make no commitments to stability, consistency, or reliability. That's absolutely fine when the project importing it is also a v0, but once you get to something serious, it's a serious concern. At the very least, you would need to be much more careful and thorough when performing updates, as they're far more likely to have unintended and unexpected consequences. That is why I don't think they make sense for _a general case example_ of how dependency management tools should be compared. The vast majority case usage of these tools are not in depending on v0 projects but on v1 and above, where SIV has a dramatic positive effect on dependency management.
Offer a "lite" mode where only the most barebones features are offered, sorta like the training mode for spiderman's suit that it was in for most of homecoming! I'm only half kidding
[removed]
Everything has to link to glibc at some point in traditional GNU/Linux, otherwise it can't run.
Something wacky is going on. That linked post didn't show for 2 hours. I posted around the same time and mine still doesn't show. Meanwhile this post went up afterwards and was shown in \`\`\`\`\`\`\`\`'new' right away.
Highly objective but VSCode \+ vscode\-go is what I've been using for the last 2 years, it's great.
I have a question about that pointer-are-here table gc is using. What source of type info does it use? Is it the type when the memory is allocated? When `unsafe` in involved the type when the memory is allocated isn't always its final type. For example: func f() **int { s := make([]byte, unsafe.Sizeof((*int)(nil))) // enough memory to hold a pointer pp := (**int)(unsafe.Pointer(&amp;s[0])) x := 123 *pp = &amp;x return pp } is x reachable only by following a pointer which is stored in something which was allocated as a []byte. Does that hide it from gc? It appears to work [on play.golang.org](https://play.golang.org/p/0i2V-odv6pX) but that's no proof it's safe.
This link is in at least 2 other comment threads in this post, but it keeps being the right response https://www.wikipedia.org/wiki/Paradox_of_tolerance
That was my initial thought as well. Hopefully the changes are either small enough to make updates less painful or to get the API changes upstreamed. 
That's not true, you can write pure assembly code that has access to syscalls through int 0x80.
Thank you for that. There is now plenty to discuss. I will just give you notes across the whole file. First let me start with the parts most relevant to your original question. There are issues with the way you are handling your encoder/decoder and the global map. Consider this example: [https://play.golang.org/p/FLeGIUQx4nt](https://play.golang.org/p/FLeGIUQx4nt) Notice how the first time the existing map object is used as the target to decode the input string, nothing happens to the values of the map. See that commented out part? It is illustrating the difference between checking errors and not checking errors. Your code doesn't check errors \(something I have seen mentioned about your posted issues in the past\). If it did check errors, it would find that your decode is failing because you aren't passing in a pointer to your map. So, please make sure to check your errors. You will then see the use of `File.Seek()`. This is illustrating another problem in your code with the way you keep 2 global file handles open and reuse them for reads and writes. When you encode and decode \(if they were actually working\) you are advancing the position on the file handle. What you are really going to end up doing is streaming multiple maps into the file and reading them back. I would rethink this whole design and get rid of the global file descriptors. If you want to stay with them, then you would need to seek them back to start after each read and write. Otherwise you can simplify and just use [`ioutil.{ReadFile,WriteFile}`](https://godoc.org/io/ioutil) in combination with \[`json.{Marshal,Unmarshal}`\([https://godoc.org/encoding/json#Marshal](https://godoc.org/encoding/json#Marshal)\). That way you don't keep globals and just locally read and write byte slices. Furthermore, you could just read the file into the map once on startup and never read it again. All of your lookup calls would just deal with the map. And all of your update/delete calls would update the map and write it to a file. Moving on to some other issues, your `Init()` function is using `os.Create` on the file which is going to truncate an existing one. Do you want that to happen to your stored data from the last run of the server? I'm guessing you just want to open an existing one for reading and not lose your old data? Lastly some things about naming conventions. Your local variables and function parameters should be lower case. Using them upper case is a convention that is meant to indicate exported symbols like public functions, types and classes. Also, your use of a named return value like `func AddInfo(Username, Password string) (Error error)` is usually unneccesary in your code, because you end up just creating new local scope errors variables that shadow the one that was already allocated. You could just be writing `func AddInfo(Username, Password string) error` Hope this gets your going again.
seems like a comment i'd expect from u/impractical_lem , tbh
It has a bit more than what a beginner need I think. For example database connection would came right out of the box, which you would think that is a convenience but its a big distraction for new learner. I am also not very happy with color scheme of GoLand coming out of the box. Dracula is nice but it doesnt highlight as much as Atom Dark In my experience. Finally, comparing VSCode Ctrl+Shift+P against GoLand Ctrl + Shift + A, I think VSCode is a lot more clean and organized for me to find basic commands. Goland is bloated with fuzzy search over every possible attribute of system settings which is not very friendly. At the end of the day, I still like GoLand for a big project. But VSCode and Sublime offers a clean, light experience for smaller projects in my mind.
Acme
I'm sorry you think I'm spreading FUD. I was sharing my experience trying to use the official Docker client with vgo, which I don't feel has been positive. I just haven't found vgo to be very friendly/intuitive for my use cases, and the reason I had even commented on this post was because I had gotten the impression that more complicated projects were starting to work well. My point of comparison is dep/govendor, what I've used in the past, which don't take that long to resolve even with Docker's large repo size (never been an issue before) and generally pick new revisions. I'm not really sure how that Azure library version is getting pulled in (and the latest versions come with Gopkg files that eliminate those limitations), but I guess I'll need to inspect the repos to figure that out. I let mine build, and it took 23 minutes. I hope you can understand why I think that's a really long time. I also ended up with v1.13.1 (when just doing `touch go.mod`). I'll have to try manually specifying hashes directly to get the latest code, but as I've said before in the other thread, I gave up after 2 hours of letting it churn on my main personal project. It's frustrating that I don't seem to be able to share my negative experiences without backlash. I guess I'll go back to lurking.
Tested this today on some projects. Way better then gometalinter in my opinion. McAfee would normally kill gometalinter after 90 seconds, but it actually lets golangci-lint finish and return results. Easy integration with IntelliJ now too. 
oh and, to be clear - what Ian articulated doesn't "solve" anything in vgo. It can, at most, be equivalent to what i outlined in the article, with the same limitations - it turns into a toilsome walk through warnings.
So… do you think the VSCode extension will use this one day?
&gt; That problem can only occur in this manner between v0 and v1 in vgo. It _should_ only occur. Very different from _can_. The compatibility post - next planned in the series - explains this in detail. As to the other points, see https://sdboyer.io/vgo/failure-modes#mvs-and-experimentation . If we never use anything for serious purposes until it hits v1, then it doesn't get the exposure that it needs to really battle-test what its promises are, which means potentially a series of SIV mappings, which can be quite costly and error-prone (focus of the fourth post). It is a nice-sounding crutch to believe that we should all only ever depend on stable packages, but this is the same problematic reasoning that drives vgo itself: only allow the ideal state, without making space for any of the messy stuff in between that lets us REACH the ideal state.
This is interesting to me. Could you explain how this works? I was pretty much taught glibc is the main interface programs need to run in Linux
It's fine if you are using it directly and willing to keep up with it. I have used a js framework once that had big changes going to v1. So I'm really careful of failing into the same trap again. If you are using someone else's library that is dependenting on experimental code, and there is no guarantee of future maintenance. Don't depend on it unless you are willing to fork and maintain it yourself.
In principle I agree, but is it really that bad to try? I had a few non trivial projects on glide, and moved them to dep in an afternoon. I haven't converted all to vgo yet but the few tests I've done so far have been pretty straightforward. In some ways the criticisms about vgo are largely based on differing thoughts on how likely certain problems will occur in the wild and how the community will react to those challenges, ie the game theory ideas presented by Sam in this post. But the truth is these are theories, we don't really know, the community may adapt in great ways or it might be a clusterfuck. I think the switching cost is overstated. I don't know, maybe it's because we just went through GDPR madness, but changing to a superior package manager than vgo in 12 months if it all goes south doesn't sound like the end of the world. Sometimes you just have to try and see.
&gt;If someone said to a jew "I think you should be dragged behind a horse until your arms are ripped off", then yeah, I think that person should probably be banned from gophercon. So I say something mean to a person I don't like, and I'm banned because he was Jewish? Its this kind of shit that turns every mean word into a hate crime. 
[removed]
[removed]
&gt;In a earlier thread, you said to just read and decode into map on startup and encode map and save on exit, you said to use json.decoder. Why decoder vs umarshal? Actually what I had said was to read the existing one from disk when you start up, and then serve all your reads out of that map that is in memory for the rest of the application. And to encode and save the map from memory back to disk only on adds, updates, and deletes. The map in memory should always be up to date, and if you restart your server, you will just read back in the last state of the map. And this is basically what something like BoltDB would do for you. &gt;Second, I used os.create because it is a io.writer which is what was required by the encoder. I felt as if I was doing this right, as I couldn't find a io writer other than one in the os package. What should I have done? io.Writer is required, but that doesn't mean you have to use os.Create to get one. The behaviour of os.Create is going to truncate the existing file for writing. If you were to keep it the same logic, you would need to read in the map once before you truncate it with the other file handle. Or you need to open the existing one for reading and writing, read it, and then seek back to start for writing. Just really think about the file object as having a little pointer to the position and what happens when you read and write. I suggested switching to the Marshal/Unmarshal to make it easier for you to just deal with reading and writing byte slices in and out of a file at the moment you need it instead of worrying about maintaining a global read and write file handle. &gt;Lastly, should my functions be named: addInfo or Addinfo or AddInfo? I was always a bit confused with the proper casing. [Effective Go](https://golang.org/doc/effective_go.html#formatting) details this answer. For a main application, it doesn't always matter since nothing else is usually importing you as a package and making calls. But generally it would be `AddInfo` if you were defining a function that is meant to be exported to other packages.
I was using sublime text for a long time until I couldn't stand having to open command line in a separate window, and no sublime plugins seemed to have fixed this sufficiently. I watch the justforfunc videos and Francesc is always using vs code. I was always wary of using an IDE since they create other artifacts \(e.g. .idea folder\) that I don't want. I decided to give VSCode a shot. 1000 times YES. Use VSCode!!!
Pretty much the only interface Linux the kernel exposes to user space is the system call interface, which is kept extremely stable. Glibc is just a (very fancy) wrapper around the system call interface that implements the functions required by the standard. Alternate implementations of these functions exist, such as musl. As another comment suggested, you could have C code that doesn't use libc and solely talks to the OS using assembly to invoke system calls.
So glibc is just another library, albeit a massive one and Linux is just one of the systems it supports. I find myself digging through it every few years for some reason or another, usually to find size / alignment or just general reference for an architecture I don't have access to. Which last I counted it supported something like 45 architectures which is pretty impressive, even for a 30 year old code base. Thinking about it if you ever have some time to kill check it out from `git://sourceware.org/git/glibc.git` and head to `./sysdeps/unix/sysv/linux` from there to get a view of what a fully implemented system call interface interface looks like. It makes it clear why Go only implements the bare minimum system calls it needs because it's a real pain to implement them, and Go only supports a small subset of popular architectures. It's actually not very difficult to make system calls to the Linux kernel on amd64, all of the effort comes from the nuances of architecture specific details. POSIX structure padding, alignment, endianness and specific system calls that may have a subtle divergence from POSIX due to some bug being immortalized due to importance of ABI. Maybe glibc had a bug the kernel worked around or maybe vice versa, who knows, but some times it just doesn't make sense why something is the way it is. But it got that way some how and I think it's neat, lol. Go actually piggybacks off all the effort of glibc, even though it doesn't _need_ to link to it directly to run. I discovered when I wanted some additional structures (posix signal.h) that the Go syscall package actually fires up a docker container and generates all the structures for each platform using clang, which is pretty clever. But it still can leave a good bit of manual hacking to take in a fresh posix header. This is turning into a wall of text considering you asked a simple question, sort of. **tldr;** System calls to Linux are simple while portability is not, given Go is less portable it has less crusty stuff, making it a great place to observe user&lt;-&gt;kernel space interaction.
This is helpful feedback, thanks! I'll take a look and work on improving the messaging on the site.
I submitted a PR for support: https://github.com/Microsoft/vscode-go/pull/1692
Thank you for clarifying!
I tried it earlier, and completely failed out too. Dug into the source a bit, got lost in the code to check out repos. When I noticed it wasn't just a clone or invocation of the existing go get code, I switched to dep and now I'm just waiting to see how it all shakes out. Because right now, dep suits all I've needed. YMMV.
Excuse me if my answer is outdated, as I haven't used App Engine in over a year. You can actually put the package anywhere you'd like. I usually put it in /appengine/. You then want the first line of the file to be \`// \+build appengine\` and declare this as \`package main\`. You can then wire everything up in \`main\(\)\`, and don't forget to call \`appengine.Main\(\)\` from the \`[google.golang.org/appengine\`](https://google.golang.org/appengine`) package.
VSCode. Here's why: It will auto recommend the go plugin you want. Just install it and open a go file. It's not as fast as sublime text or vim, but it's not as slow as Atom, either. The slightly longer startup is a price worth paying for the incredibly easy configuration. Settings are documented and easy to work with. Oh yeah, it's also free .
you are being idealistic with your thoughts. In reality, I have encountered several BIG projects (100+ active devs from multiple countries, timezone, background) with many SOA-like architecture. Diamond dependency is a nightmare, not because its hard to fix... which often its not, but because its a hard to communicate that "we need a fix" to all the relevant people. The bigger a team or a project is, these delegation of responsibility from tooling to human is backward and counter intuitive. It makes collaboration harder, not easier. If the tool gona make it officially as part of the language, and that the language is expected to grow to a wider audience, then I think these factors need to be taken into serious consideration.
System calls are the main interface for programs in Linux.
Most of changes were small, and upstreaming of changes is planned.
Thank you!
I think I have explained it twice in this thread. The reason is sliceHdr.Data is not a pointer.
thank you for this integration! we will add information about it into README.
My minimal Docker example, no constraints: * vgo (`touch go.mod`) - 23 minutes. * dep (empty `Gopkg.toml`) - 16 seconds. My minimal example, forcing revision `9c2c887b` (latest master: * vgo (with an initial require line of `github.com/docker/docker 9c2c887b`) - 1 hour 44 minutes. [Yes, I let this one run.](https://i.imgur.com/R8FSKsF.png) * dep (with `branch = "master"`) - 12 seconds. And if we're timing `go get` here, I temporarily moved my $GOPATH and did `go get github.com/docker/docker/client`, which took 29 seconds. [Screenshot.](https://i.imgur.com/R8FSKsF.png) I don't particularly care what "resolve" is defined as. I'm just frustrated that I need to let my laptop sit for nearly 2 hours chugging away to get the revision of Docker I wanted to work with. There's "slower internet", and then there's this.
you can also just install their go plugin on IntelliJ
Please don't put advertisements in the main usage loop of your program. I don't care about whatever CI nonsense you're pushing here, but you're forever inconveniencing me to either put a flag every time to disable it, or copy a config file around (because as far as I can tell there's no way to have a global configuration file).
a) syscalls are, in general, to communicate with the kernel, not the windowing/desktop system and b) Windows/MacOS don't provide stable syscall APIs, AFAIK, but instead provide the stable kernel APIs as C-libraries which gets released in lock-step with the kernel.
Thank you for feedback, we've removed it, please update it by &gt;go get \-u github.com/golangci/golangci\-lint/cmd/golangci\-lint
Glad to hear. And feedback like this is valuable as we can explore possible ways to improve the experience not just for existing users but for new users as well.
Thank you for your feedback!
I don't know why your comment isn't higher. By default programs compiled on Linux will link against some version of glibc (this includes go programs). You have to try very hard to get a proper statically linked binary these days. Honestly the only things I have seen which have statically compiled recently were codes compiled specifically with musl libc or old Fortran codes compiled with the Intel Fortran compiler.
&gt; I am still not convinced technology can solve social problems. It does however. Technology in fact has been heavily influencing social life. Telephone, TV, Internet, Facebook, Slack... they all reshaped the industry heavily. Git, Jira are great example of tools that helped reshaping software development communications. For once management layer can quantify communication effectiveness, identify bottleneck in workflow and optimize it. Obviously vgo will only have a small impact compare to those examples above. But its still something to think about.
Problem might be with dbconnection pool. Simply after some time of idle your pool might close the connection to dB and next time you got server it needs to obtain it again.
i like the approach alot. The views and queries architecture is alot like couchdb. The one thing i woudl like to see in an embedded DB is a sync function to reconcile the data with other servers. couch uses LWW, but recently the CRDT tools are getting to the point where you can do merging on jsons docs with no fuss. This is one good one: [https://github.com/automerge/automerge](https://github.com/automerge/automerge) anyway my main point is data sync is needed these days 
So what is the solution?
&gt;&gt; That problem can only occur in this manner between v0 and v1 in vgo. &gt;It should only occur. Very different from can. I'm sorry, I should have been more clear. What I meant here was that this is the only time a major version change can occur ambiguously. It's the only time you can accidentally change the major version of a dependency's dependency with SIV. &gt;If we never use anything for serious purposes until it hits v1, then it doesn't get the exposure that it needs to really battle-test what its promises are, ... But a v0 package makes no promises. The reason why v0 is an exception to SIV is that every single v0 version is essentially a different major version. You could solve that problem by having the full v0 version name in the import path, but it would be as ugly as sin. &gt;It is a nice-sounding crutch to believe that we should all only ever depend on stable packages, but this is the same problematic reasoning that drives vgo itself: only allow the ideal state, without making space for any of the messy stuff in between that lets us REACH the ideal state. I'm not saying that we should never use v0 packages, just that we should handle them with serious caution. Just as a v0 package can have breaking changes in what looks like a minor version change, v0 versions are probably significantly more likely to contain (more) bugs. Again, that doesn't mean we don't use them, it just means we put more thorough tests around them and use them with more caution than more battle-proven dependencies. This means both that we are more likely to identify bugs and that we are more likely to handle them cleanly and robustly. It _also_ means that we're more likely to identify breaking changes, be that when changing from a v0 to a v1 (which was my original discussion point), or when changing to a different v0 version.
You can statically link most libcs. Notable exception being glibc.
Hm, a wrapper for libui, which itself is written in C: [https://github.com/andlabs/ui/issues](https://github.com/andlabs/ui/issues) Comes with precompiled .a files for the platforms afaik.
Emacs. What else? Why even ask?
As a matter of fact you can still have SSL support and at the same time use the scratch image. You just need to copy the root certificates to the image itself. It is only one file. Regarding the shell, it is useful to have it while testing but later on in many cases it is irrelevant since you have the backtrace and other ways of logging. Security wise it is better though to use the scratch image.
[removed]