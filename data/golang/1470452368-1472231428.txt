At least in Go, each request is handled by its own goroutine, so requests don't block one other (unless you explicitly block them with a lock or anther sync. method). Each of the requests in question would only block 5 seconds from the time of request.
You've made a huge assumption that I don't know what I'm talking about. I've worked through numerous security audits and certifications. No system I've designed, administered or been responsible for has ever been breached. Knock on wood on that -- I know it can happen and work hard to make it as unlikely as possible. I never said encryption was all you need to do, that security ended there, or anything else you imply I think or don't understand. Your points are all on point -- security is subtle, manifold, and layered. You mentioned internal controls being critical, but the best internal controls, and the easiest to certify, are those that are automated. If you think libraries and code are unreliable, you haven't worked with enough people...who despite our best efforts are demonstrably unreliable in nearly every way. What I find most amusing is that you seem to believe that titles, regulations, forms and checkboxes are either the basis of security, or at a minimum, the gold seal of impenetrability. It seems once a day a major system designed, built, certified and credentialed in the ways you discuss are compromised. &gt; Requiring encryption in places that are at very low risk greatly incrincreases attack surface for very little reward This is what I was looking for detail in. Not seeing it, I'm in complete disagreement here. Sure encryption is simply a prophylactic around data transfer, but eliminating it removes a critical aspect of secrecy that at a minimum can reduce the ways they information can be leaked. 
Wow, great reply with lots of good considerations to keep in mind! I've definitely been bitten by the expired cert problem. "Are you SURE it's updated EVERYWHERE?" 
I really can't figure out how to do this. 
I would like one too, actually. 😅 Someday, I want to replace the screenshot on the website with a real example.
Undergoing development :) Caddy is currently 0.9 and dynamic proxies should make it in before 1.0.
Sorry you had a hard time with kube docs. we're working on it. How about: $ sed 's/PORT/7070/' file.yaml | kubectl create -f - $ sed 's/PORT/8080/' file.yaml | kubectl create -f - $ sed 's/PORT/9090/' file.yaml | kubectl create -f - or: $ kubectl run c1 --image=alpine --env=7070 -- sh -c 'nc -l -p $PORT' $ kubectl run c2 --image=alpine --env=8080 -- sh -c 'nc -l -p $PORT' $ kubectl run c3 --image=alpine --env=9090 -- sh -c 'nc -l -p $PORT' or simpler yet: $ kubectl run c1 --image=alpine -- sh -c 'nc -l -p 7070' $ kubectl run c2 --image=alpine -- sh -c 'nc -l -p 8080' $ kubectl run c3 --image=alpine -- sh -c 'nc -l -p 9090' or for more fun: $ kubectl run hostnames --image=busybox --replicas=10 -- sh -c 'while true; do hostname | nc -l -p 8080' $ kubectl expose deployment hostnames $ kubectl get service hostnames
You have mail :)
To expand a tiny bit on djherbis's reply: the OP is talking about sending a request, you're talking about handling a request. Opposite sides of the coin.
Could you explain what dynamic proxies would mean in that context for someone not too familiar with them? Thanks! 
go build -v -x -work From that you'll have a better idea of what's going on. You should be using go1.7rc5 now.
Golang is actually easy to pick up. I am now telling people to learn it over Python.
Looks interesting. Any plans to integrate with [golang.org/x/text/language](https://godoc.org/golang.org/x/text/language)? You could have it return a language.Tag rather than a string.
Performance seems like the simplest and most effective benefit of a native driver approach instead of using an HTTP pipe, even locally.
path.Split and path/filepath.Split
Another wave with a mostly different center: https://hadoopecosystemtable.github.io/
I point everyone with any past programming experience at the [tour](https://tour.golang.org/) ahead of any other resource.
API looks similiar to apex/log but I am not sure about the integrations with Zap and the other logging tools. But as I see the logging libraries are growing fast like web rest frameworks.
Its better to make go tour from the website, setup editor properly to jump into the func and packages easily in case if you dont understand something. While you are reading the sources from std libraries you will learn the basic ideas how to struct your code.
That was very informative and probably one of the best explanations on algorithm complexity I've ever read.
The go answer for you is definitely code generation. It's a little more work for the programmer than language level generics, but it give you type safety and the performance characteristics of C++ templates. I've heard good things about [gen](https://clipperhouse.github.io/gen/) and [genny](https://github.com/cheekybits/genny), but there are others and the community hasn't settled on a single solution.
I prefer not to fuck up my code with a shitton of useless boilerplate.
I just pushed through an updated checking `d.actors[an] != nil || d.actors[an].Value != nil`. I'll update with information as time progresses.
Hi /u/alexandrkorsak, I'm not sure what you mean by "not sure about the integrations...". Are you familiar with [SLF4J](http://www.slf4j.org/)? The point of Gournal is to wrangle the list of logging libraries so ultimately they don't matter. If you use Gournal you can replace one library with another and 99% of your logging code doesn't have to change. Things like hooks or initialization code might, but not any of the actual log entry statements.
Hi /u/greatfrost, So I just pushed [a branch](https://github.com/akutz/gournal/tree/feature/google-app-engine) to my fork with GAE support. I've not opened a PR yet because the GAE tests are incomplete. Since the GAE API requires a Context derived from the GAE API (either via appengine.NewContext|BackgroundContext or aetest.NewContext), I have to either run the test on an AppEngine app or with the Dev server. I don't have time at the moment to do either. However, the GAE implementation I provided should work without a problem as long as the GAE context is provided to Gournal's log methods. 
The problem ends up being the transition to the language data types from the wire. At some point that becomes a bottleneck you can't remove from Python. When you add the deployment pain over time, go becomes a great option. As a Python developer, go came very naturally as well.
Nice work! I've been thinking about things like this recently while reminiscing the days of writing games for the C64, and thinking about hacking on a few of them in Go.
But first you have to take the red pill.
Just start writing it day-to-day. When you read about arbitrary language features, it can be hard to know when to use them. But when you are in the thick of it, you start to figure out when to pull out the various features. Luckily, Go is a *very* small language compared to something like Ruby. Also, spend time to learn the tooling (benchmarking, race detection, linting, vendoring, etc.) And just because there is a library for something (say HTTP routing), doesn't mean you need one. Start with the standard library and see how far it gets you.
this is my first time trying Go so i expect there to be non-standard, beginner mistakes scattered within. i'd be very grateful if someone had suggestions on how to write better, idiomatic Go.
I think the React part should have been enough to answer the question. 
Thanks everyone for the helpful hints and tips. I'm starting to work on it today. So far it's pretty straight forward and less of a deep language than Ruby which I'm very well versed in. This is all helpful stuff guys and gals!
You did that very good! Looking forward to the next article.
Currently, I don't have any plan to support MySQL, and sqlite.
What about all the other operating systems that Go supports (e.g. FreeBSD, NetBSD, OpenBSD, NetBSD, dragonfly, Solaris, plan9, etc)?? Shouldn't all the UNIX ones (and Linux) just look at `os.Getenv("LANG")`? You should write [package documentation](https://godoc.org/github.com/jacobmarshall/go-locale) before posting a reddit link to a new package. Prefixing the package name with `go_` is a bad idea.
That isn't unlocking instantly, that is unlocking when the function ends.
Thank you for your feedback. I will add a LICENSE right away. About the error handling - is there some elegant way to do that in my example? Or should I IF every line? I ignored the errors there, because the Middleware "catches" all panics, and knows how to recover from them. But yes - that's a temp solution only if you use the middleware. And I will definitely check the "type assert" approach, instead of the map[]map[]... configuration.
&gt; luckily, I live right near the beach and I have a luxury opportunity of having sunbath and swimming in the sea before going to work every day. Envyness intensifies.
/u/1Gijs, Fair enough! I thought of that too FWIW :) Also, note this is a facade, not a framework. I'm not trying to replace anybody's favorite logger -- merely make it easy for developers to switch between them with minimal effort.
Thanks for the prompt, that was a fun challenge. I implemented a BST using interface{} and custom sort function if anyone wants to check this out. https://github.com/jseely/bst
Oh, I see. I haven't thought about it that way, thanks. I was more thinking that a user could just run `go get &lt;package&gt;` without thinking about which flags to pass since s/he may not know which ones are necessary. Like `CGO_ENABLED=0` is required for a static build in linux since the application is using the `net` package, but I don't expect users to know that the application is using the `net` package. Similarly `ldflags` is nice to reduce the binary size and actually I'm not sure why it is not the default option for release builds. I didn't know that such an option existed before I became aware of it. Anyway, this doesn't seem to be a big deal. At the worst case I can just document the full go get command as you wrote.
Do you have any performance and memory benchmarks? If you'd like some sample code, I have some benchmark code here: https://github.com/EricLagergren/bloom/blob/1246b48cf0f3775a6fa31d23c29704c192e70df7/bloom_test.go (taken from a bloom filter I wrote a while back)
FWIW it's much more idiomatic to use TestMain: https://golang.org/pkg/testing/#hdr-Main I'm unsure why I used init. Probably just habit.
Sweet, thanks for the feedback. You're right about the LANG env var, I must have missed that in the original Node.js implementation, which I based this on. I appreciate the feedback.
Some people package entire python interpreters into their binaries. Kind of crazy, but just because you have a single binary doesn't mean there's no overhead and vice versa. If you think about it, Go still requires a runtime, which it is bundling into all those binaries. It's a tradeoff between ease of deployment and duplication of the runtime. Go programs will often be faster than similar Java programs, but that's due to lack of abstraction and use of AOT compilation, rather than deployment strategies. 
Definitely true. And yes, Go has some extra overhead in the form of binary size because of that. Your point is exactly right, I should have been more clear about what I meant as overhead initially, and the way that I meant it was more related to dependencies and deployment. It really does just come down to which tradeoff you want to make, and in my experience deployment has been a nightmare at almost every company I've worked at no matter what language they use, and I've always wanted to keep that as simple as I possibly can. It's definitely a personal bias at this point. And as an anecdote though, I've seen people package many different combinations of interpreters inside other applications, and once I saw a junior developer package ruby, python, and lua into a web application and then had to explain why that was a terrible idea.
&gt; is there some elegant way to do that in my example You could wrap the error, kind of like `fmt.Errorf("Authentication error: %v", err)`, or even something like this: http://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully &gt; Middleware "catches" all panics It's not good Go practice. Catching panics in middleware is to prevent an accidental panic (such as an out of bounds index) from causing the webserver to implode. Always have a proper error path. BTW I had a glance at your recent commits, looks good!
Been meaning to blog about this (effective net/http usage without needing a bunch of deps). I have a few things which aren't available yet and maybe something that is I'll have to check. EDIT: turns out the server code available is gin or echo. I'll have to dig harder to find my net/http JSON service code and which project it's in. (These are paid projects, not hobby experimentation though i have those too).
Nice one. If anything more than `go get` is needed, I usually end up supplying a Makefile. It acts as documentation in a way as well.
That's really awesome to see Go hit the top 20 list! Go Go!!
I rarely hit situations where I'm working with dynamic keys. I know some scenarios are unavoidable, but you should be able to plan what data is coming in and out of your service. For those situations where best practice is not possible, you can use map[string]interface{}
So is it a research project or something you would enjoy having others use? If the latter I think first thing up would be .. tests! In present form it would not be useful to a real world Go program because it is not safe to be used by multiple Go routines. Normally with a lot of libs this doesn't matter, the user will just guard it in a way natural to their program, I.e. channels or mutexs. But you don't get that luxury! Since it's a structure designed and used for speed the locking needs to happen in the library since it can ensure the lowest times of contention. But that would be a good bit of effort and tests would ensure you don't implement undesired bugs along the way. Just something to think about, either way good job.
Happy to see positive press, but I don't think their methodology is sound if it was ranked #115 in May 2015.
I wouldn't put too much trust in this, though a lot of programmers seem to. This index is based on popularity but I found it silly that it ranked Go so low (#122 in May 2015) when Go was popular. Now when its ranked higher, I haven't changed my opinion. It seems arbitrary and no serious person should base their decision on which language to learn or choose for a project based on this. If you're a programmer, you should either look at what offers the most jobs or what's fun to use (depending on the programmer). If you're a tech lead you should look at other trade-offs like resource footprint, tooling, development time or ease of hiring developers. If you're looking for the general opinion of programmers, you're still better off ignoring TIOBE and looking at the StackOverflow survey ([2015](https://stackoverflow.com/research/developer-survey-2015), [2016](https://stackoverflow.com/research/developer-survey-2016)).
Yeah once I saw how they ranked Go I never went there again lol 
golang,go ahead
docker? https://github.com/docker/docker/tree/master/api/server
They're using Gorilla's mux.
Could you do an explanation of how to create a balanced binary tree? This explanation was great :)
Got it, thanks.
Sorry I should have mentioned, Gorilla's mux is ok :) I more care about doing the non router stuff.
http://redmonk.com/sogrady/2016/07/20/language-rankings-6-16/ http://spectrum.ieee.org/computing/software/the-2016-top-programming-languages 
You're trying to tell me that * Rust (created for making a browser, a traditional application if there ever was one) * Swift (used in making iOS apps) * VB (almost entirely Windows apps) * Matlab (good for doing math) * Python (widely used in science fields) are all for web development?
Yes. I'm saying that these are mostly used for web development.
There's really a payments company called Slut? https://slut.io/ 
Well for one, why are you even luanching a goroutine here? This is single threaded code that you have shoved an extra thread into, and then continued to force it to be single threaded. Additionally, you Add(5) to the waitgroup, but only call .Done() once, so your .Wait() at the end will never return. You have deadlocked.
They are gorilla specific route vars IIRC... 
But at that point, it's pretty much an IP-&gt;bool lookup mechanism, right? Not even taking a `net.Addr`/`net.IP`, it's not very convenient to use in a `net.Listener` `Accept` loop. I mean, geoip is neat and an IP ACL can be useful, but "ip filter" tends to mean actual firewalls (https://en.wikipedia.org/wiki/IPFilter) so I was actually surprised to see a HTTP handler wrapper.
Yeah the go routine part was only for performance issues kinda i just wanted the initStatements part to be faster so i tried to make as parallel as possible , it doesn't really need to be there The Add(5) its from the original code i forgot to edit that part out sorry Overall, is it a good solution?
Cool stuff, but I was hoping to get better insight into string encodings from this article... The relationship between []byte and string has to involve encoding, but as far as I can tell it defaults to UTF-8 encoding? How does one be more specific about their encodings? Like what if I wanted to use UTF-16 for storing strings?
Fair enough, it internally uses net.IP and exposes this publicly as NetIPToCountry. Will also add NetAllowed / AllowedNet. I was going for firewall-like behaviour within Go applications, and although it's currently not suitable for routers, maybe it will be one day...
Sorta. A string is just an immutable slice of bytes without a capacity. *However*, strings are interpreted as runes. For example: for i, r := range "hello, world!" { ... } `r` is a rune. 
I'm sure it could probably be extended to do that :) These looks like perfectly acceptable D&amp;D dungeons to me. No monsters or treasure or anything, but just the layout is nice to do, too (especially since monster &amp; treasure choice is kinda rough to do automatically). Seems like you should be able to take the output and convert it into something printable for D&amp;D maps, perhaps even full-size.
Also, [check out this recent thread](https://www.reddit.com/r/golang/comments/4v5rs0/should_simple_db_statements_be_prepared_at/) -- the SQL statements you are carefully preparing might get invalidated by Go's management of the SQL connection pool. You shouldn't try to keep prepared statements around for the lifetime of a long-lived application.
I just noted that you had made the changes on GitHub. And you're right about adding providers.
The way it is now, it won't be any faster, though. If anything, it will be slower, because it will have to take the time to spawn a goroutine.
Thanks for the feedback. Go strings are always interpreted as UTF-8 encoded when using a for loop or functions in the "strings" package. There is a [unicode/utf16](https://golang.org/pkg/unicode/utf16/) package you can use for some conversion but I have not used it before. There are also additional character encodings within the [text/encoding](https://godoc.org/golang.org/x/text/encoding) subpackages but, again, I haven't had to use those either.
MessagePack worked fine, thanks!
I am guessing you have not really looked into PostgREST. NOT treating the database as a "dumb" store is exactly what it's doing. "resource not mapping ..." - that's what views and RPCs are for
Includes the obligatory date/time fix for Sierra? Phew.
To answer this issue, I went for: type UserOP struct { Exec func(*User) error Close func() } func SelectUserByID(db sql.DB) (*UserOP, error) { stmt, err := db.Prepare("SELECT...") if err != nil { return nil, err } return &amp;UserOP{ Exec: func(u *User) error { res, err := stmt.Exec(u.ID) if err != nil { return err } return nil }, Close: func() { stmt.Close() }, }, nil }
I think programmers know it's not a terribly useful rating to them, but to a manager deciding whether or not to allow you to write a service in Go, it might be unduly important, and then it becomes important to the developer.
Great reply, thank you! Just to make sure i understood correctly, in your example, from my `baz` library I'd then `import "github.com/tobiassjosten/spam/eggs" ` and use its `eggs.Whatever()`?
This article will probably solve all your questions: [Five suggestions for setting up a Go project](http://dave.cheney.net/2014/12/01/five-suggestions-for-setting-up-a-go-project)
Not work? Try to change the address port. Some ISP blocks it.
you can refer this post: https://zhuanlan.zhihu.com/p/20010926 main idea is to convert []byte and struct. type MyStruct struct { A int B int } var sizeOfMyStruct = int(unsafe.Sizeof(MyStruct{})) func MyStructToBytes(s *MyStruct) []byte { var x reflect.SliceHeader x.Len = sizeOfMyStruct x.Cap = sizeOfMyStruct x.Data = uintptr(unsafe.Pointer(s)) return *(*[]byte)(unsafe.Pointer(&amp;x)) } func BytesToMyStruct(b []byte) *MyStruct { return (*MyStruct)(unsafe.Pointer( (*reflect.SliceHeader)(unsafe.Pointer(&amp;b)).Data, )) } 作者：达达 链接：https://zhuanlan.zhihu.com/p/20010926 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
well, if you use an "interface{}" it is not type safe...but if you use an actual interface (type interface) it is type safe
Good news for ya. VS Code has tabs now and a more conventional workflow.
Thanks! I've been using it for the last couple of days and its been great!
holy god! rob pike responded!
"looked over" is the key part :). One more question to ask yourself, are you primarily (maybe always) developing with MySQL? If the answer is yes then i understand why you did not really get the setup. PostgREST power comes from the power/featureset of PostgreSQL and if you rarely/never work with views/triggers/stored procedures/custom data types, (behaviour which is a tradition in mysql webdev community) then it's easy to look over and miss the point of postgrest (especially since the docs are VERY lacking).With PostgREST you never expose your core data tables, you expose a single schema containing just views (+ some stored procedures for super custom stuff), views that let you present to the world the exact data you want to show, in the form you want (not the raw structure of your data tables) Sure there are APIs that might be a pain to implement with postgrest, but most of the time everything is just CRUD, the only semi-interesting part in the api is the "R" (reports/statistics on the collected data) and for that you use views and in rare cases stored procedures. It's like wordpress, you can't implement facebook with wordpress but for every example of such a case, there are 100 that are way easier/faster to do it with that (if you have really good knowledge of PostgreSQL featureset). Think of what it means to be able to implement a complete working REST API for something like Basecamp in 2-3 days vs spending the next few months doing that with a ORM framework (i have built both cases so it's not just hypothetical) and in the end having the ORM thing being less expressive/powerful and also slower. You are right in one aspect, "time to learn a new tool" vs "time to implement the system with the old tool". And this depends a lot of the size of the API. If you expose 2-3 very custom endpoints then sure it is easy to use the old way but if you have like 30-50 tables then writing bolierplate code to expose them gets time-consuming and very error prone. I'd rather have a tool that gives me 95% of what i need then work to bend it for the last 5% (with stored procedures that i can write even in JS) then have to implement everything from scratch all the time. PS: using "framework" in reference to PostgREST is not really correct since it is a "binary/executable" PS2: if i sounded rude in any way above i am sorry, i was just trying to get you to give the tool a second look and correct your statement that is offers just "dumb data access" and "sunshine path". While grossly oversimplified the following statement is somewhat true "PostgREST is as flexible as PostgreSQL" 
Looks great. Thanks!
If you want render "index.html" file there are several ways. One way is using the fmt.Fprint(), this function accept two parameters: First, an io.Writer but accept a http.ResponseWriter. Second parameter accept a string. For make your fmt.Fprint you can use io/ioutil package for read "index.html". Finally you need create a handle for serve the static files. An example: //if index.html is into static dir http.Handle("/static/", http.StripPrefix("/static/", http.FileServer(http.Dir("static")))) //Your handler func getIndex(w http.ResponseWriter, r *http.Request) { readed, err := ioutil.ReadFile("static/index.html) if err!=nil{ panic(err) } fmt.Fprint(w, string(readed)) } //... You have more info in: [ioutil package] (https://golang.org/pkg/io/ioutil/) [Question in stack overflow] (http://stackoverflow.com/questions/13302020/rendering-css-in-a-go-web-application) 
Do strip, but avoid UPX. What you're saving in disk space you're wasting in RAM and optimizations you may be losing from having an irregular load mechanism (like sharing memory when running the application more than once).
What was the problem with Sierra?
Hey everyone, This is my first blog post of any kind, ever. After working with Go for around 10 months, I wanted a place where I could talk about some projects I've been doing, and some I hope to be working on soon. I picked up Hugo, and I have to say I'm super impressed. Feedback is appreciated, Thanks!
`strip -s` works under Linux with go1.7rc6, so it’s probably a macOS specific problem.
Go for rust then. 
Hmm I see. What will make it easier to understand? Removing the negative sign? maybe better wording in the column header? 
done, thanks!
That's a respective c code/library problem, not go. And it will cause the same issue whichever language/platform uses that c library. Try using c code that builds with musl rather than libc.
Because if you called `gettimeofday` using, e.g., C you'd use the `gettimeofday` function which internally uses the system call, much like Go is doing. It's opaque to user-facing programs, not so much to languages or libraries using the system call itself.
"Package tls partially implements TLS 1.2, as specified in RFC 5246." It's from the official doc.
The Go bug tracker is a better place for this. 
It sounds like you're trying to marshal that as a single `Encode` call. That's a pretty bad way to go, and might even mean you're building the file contents in a `[]byte` first and only then writing them to disk. The trick is to do multiple `Encode` &amp; `Decode` calls; there should be no size limit that way. Alternatively, use something that manages the disk files for you, and access your data through it: https://github.com/boltdb/bolt or https://github.com/mattn/go-sqlite3 etc.
Awesome thanks! Sorry for the late reply, my boss went to ask me something when I was writing a reply last time, and then I have been busy since then. Also yeah I always use Golang, but even so I am pretty bad googler when it comes to searching for something that I don't know the name of. That being said, Go is still a better name than Play!(Scala framework) which always gets confused with Android, or playstation or anything really. Thanks.
Thanks! Personally, I added SSL because it aside from the certificate being free from Amazon, there are actual reasons to [have HTTPS on a static site](https://www.netlify.com/blog/2014/10/03/five-reasons-you-want-https-for-your-static-site)
Thanks for the article. I'm gonna do it.
There are some libraries like https://github.com/disintegration/gift that do some similar things, but I couldn't find anything with an anywhere-near-complete or well-documented API for OpenCV 2+.
The change is impressive. I am getting better than is shown. Example: From: go1.6.3 -&gt; go1.7rc6 485890(bytes) -&gt; 239628(bytes) For what it is worth: AMD Phenom(tm) II X6 1055T Processor Ubuntu 14.04.5 LTS 
Odd, same exact code in http://go-talks.appspot.com/github.com/tcnksm/talks/2016/08/go1.7/go1.7.slide#33
interesting, I forgot about Bolt. Thanks for you suggestions.
Check out the boltdb GitHub page for documentation and examples. It's an excellent database and it's quite easy to work with. Good luck!
So, when I tried to use this, it would hang at linking, with 100% CPU forever on a 2016 MBP 15" (I gave it 2 hours). Eventually I bailed, assuming it's due to CGo being different for Go 1.6 than Go 1.3 (the one in that project's Dockerfile). For now I'm using C++14, which isn't bad, but I think Go is perfect for this. 
it really is! thank you for sharing!
This is something I've done a good bit of, you may create global keyboard hooks pretty easily in Windows. Might be worth making the event handling in C# and printing the events to stdout and firing that process up with os exec and converting them that way. Certainly can be done in pure Go I imagine, but would be simpler in C# if you are just looking to knock it out and go back to getting shit done. https://github.com/cstockton/gaming-lol-crutch/blob/master/LoLCrutch/Keyboard.cs That's an example of global keyboard hooks. They work in any context but directx, those require a bit more work for external processes but it can be done.
How critical is performance? You can take a look at approach by [Per Vognsen](https://www.youtube.com/watch?v=qZM2B4D7hZs) for a zero-copy asset format. With some effort this [can be used in Go](https://github.com/egonelbre/exp/blob/master/asset-format/main.go), however the code there isn't production quality. This however means you cannot use map types, unless you implement them yourself. Alternatively you can write them on disk in some order, and after loading the file, do a second pass and rebuild the map from an array. When you don't have much indirection you probably can implement something easier.
No, you are not right. People should read manuals. Manual is a way to share knowledge. README is a ”must read" for every one who has interest in project. If man didn't read README, he doesn't respect neither author of project, nor other members of community. Why the hell should I respect a man who does not respect anyone? So, RTFM is legal answer to a anyone, who didn't read even README.
You could make a (global) variable for that function and choose your "brand" function at the start of the program. [Something like this.](https://play.golang.org/p/yVfYhKz6dK)
Non-scripting languages allow you to *load* pre-compiled code at runtime. Or you can even compile code on the fly before loading it.
Thanks for that, really useful! Starting to like golang more and more each day, just trying to get out of "Ruby" mode!
The first is mentioned as "an official plugin mechanism" and the second is mentioned as "use something like hashicorp/go-plugin".
Hey thanks for the links, but this post was more pertaining towards Linux (My bad, should have specified it in the post title)
RC6 is out, use that :).
a bit more of search would save you a hour
Yes I have. AWS CLI is awesome. One of the reasons I did it was because it was something I could use to learn. I love writing little utility tools in Go. Also, if I ever want to move my site somewhere else, I could just add the functions to do it. I plan on having interfaces that allow the publish to be pluggable.
I'm a little confused here, where does the double-virtualisation come in when using Docker on Linux? The actual application themselves in Docker don't use a VM, they use namespaces, cgroups, and a union filesystem, all from the host machine. The combination of these is orchestrated by the Docker Engine (usually via libcontainer, previously LXC IIRC). Quote from the "[What is Docker?][1]" page on their website: &gt; Containers include the application and all of its dependencies --but share the kernel with other containers, running as isolated processes in user space on the host operating system. On the other hand, it sounds like boxfuse actually _does_ use Virtualization (at least when using VirtualBox?) I might just be missing the point entirely here; I'm just trying to understand why you'd using Boxfuse over something like Docker (not to imply Docker is some almighty perfect piece of software, just genuinely want to see some reasons for it)? [1]: https://www.docker.com/what-docker
So basically it's a wrapper around `go install`. Why not use `go build -i` instead?
No matter what you do, you won't get anything like the rails experience in Go -&gt; use rails for what it's great at, use Go for what it's great at, and don't try to force one to be the other 
Rails is not a language - and has a vastly different set of goals than Go, which is a language. It's unreasonable to expect every language to be the same 
I wasn't asking if vanilla Go can do all these things.... &gt; wondering what packages are out there could be put together to try to get as close to the rails experience (tm) as possible.
&gt; Why can't Go be good at what rails is good at? (providing a great developer experience and convention over configuration). &gt; Any language should be able to provide that. :-\ Go can provide a great user experience, but you have to glue together the pieces you need. Using things like gorilla/mux, spf13/viper, jmoiron/sqlx and a few other things will give you an unmatched degree of flexibility and control. What Go cannot to do out of the box like all the dynamic languages (Ruby, PHP, etc.) is give you a generic framework to stuff everything in and hope for the best. That approach doesn't work particularly well because of the type system (which is inflexible for this particular case) and the fact that Go users prefer type safety and explicit dependencies vs ambiguity.
This discussion wasn't about Docker in general, but Docker on AWS, hence the double virtualization with Xen+Docker. On bare metal you are absolutely correct that this of course doesn't apply. Boxfuse itself is squarely targeted at AWS, albeit with the ability to iterate quickly on your local machine using VirtualBox. If you do use AWS, Boxfuse strips away many layers of complexity: * Image provisioning is dead easy (one command) * The security attack surface of those images is the smallest possible * You have a built-in secure image repository in the cloud * Boxfuse orchestrates zero-downtime blue/green deployments for you (regardless whether you choose to run behind an elastic IP or an ELB) with one command * Auto-scaling and auto-recovery are trivial * Databases are automatically provisioned if desired * And much more... Think of it as a very polished vertically integrated workflow that removes infrastructure headaches to let you focus fully on developing your app. I am not implying that those things can't be achieved with Docker with enough time and effort. All I am saying is that if you do value your productivity, Boxfuse lets you hit the ground running.
distkv is a distributed K/V store library for Go powered by the raft consensus algorithm. Values are only changed when a majority of nodes in the cluster agree on the operation. Internal communication is secured and powered by the SSH protocol. It ensures confidentiality and security by enforcing asymmetric authentication and encryption using the SSH protocol. A custom built interface leveraging the protocols features (TCP/IP forwarding and out-of-band requests) secures all raft and control communication. SSH was chosen over TLS because it provides strong, battle tested security without needing centralized trust authorities or certificate generation. This makes it a good fit for distributed systems like distkv. I developed this recently and would love some community feedback. After some applications, this is my first reusable OSS Go library. 
If your interfaces each have distinct IPs, then DialIP and ListenIP should do the job: https://golang.org/pkg/net/#DialIP
Hello, I'm one of the upper-db authors, we're running a special playground to demonstrate db, see this example: https://demo.upper.io/p/37ff41cfe1d9fb4c26239627722ed6cc4a9155b6, more examples here: https://upper.io/db.v2/examples Thanks!
this is exactly the response I was looking for, thanks! I'm aware of how typed Go is, and I have experience with middlewars (asp.net, express.js). I think the *ideals* of rails are possible in any language. Of course the way things are done is going to be different, but that doesn't mean I can't have conventions or developer ergonomics. It just means they're different. Thanks for the info, I think when I find time, I'll see if I can build an app prototype that fits my requirements.
thanks!
I'm from Rails and starting to play with Go. I found that you'll need to combine specific libraries, like using pg for the as an ORM for Postgres as opposed to using something general like ActiveRecord. I've been liking gin for the web server and routing, it's very similar to Sinatra. I've just using the builtin Go templates for the HTML responses. I think revel, might be the closest to Rails with a lot of functionality. I haven't tried it yet. 
That should really be configured at the OS level via the routing tables and ECMP.
At Boxfuse we believe in productivity and don't want our users to fight subtle compatibility issues. We therefore leverage mature standards wherever we can instead of building our own. At its base a Boxfuse image has a Linux kernel and an ultra-minimal user space. There is a posix filesystem and you can run any regular Linux x64 process. As compatibility and stability are more important to us than squeezing the last few kilobytes out of the image (at this scale the returns are purely academic anyway), we opted for glibc. With Go or the JVM openssl usually isn't needed, but any regular Linux x64 binary or .so will run just fine if its dependencies are met. 
Oh man, this looks sweet. Is there going to be a tool for generating your structs from an existing db?
Oh, you're right about paths, I always forget that there's no function for fully splitting. I guess they intend for programmers to use `strings` for a full split and use `path.Split` for efficiency's sake when all that is needed are the file and directory names (since it searches backwards from the end of the string).
Thanks! you can use maps instead of structs too if you want, this Metadata() function you're proposing could return a map. However, the recommended way of using upper-db at this time is with structs. Upper-db does not provide automatic relationships like full-featured ORMs do, it also does not support the features you're mentioning (I'm sorry, but we have no plans to add them in the near future either. They can be built on top of upper-db, tho). Upper-db focuses only on the mapping between Go and the database and on providing tools for the user to write custom SQL whenever required.
Thanks, I think we have some tools that already do that, like https://github.com/kisielk/sqlstruct, but I personally haven't used it. Please, feel free to open an issue (https://github.com/upper/db/issues) and start a discussion if you think this could be useful for other users. 
Right, but you seemed to offer either scripting languages or workarounds in Go, whereas I am saying that there are other tools that might be better suited than Go if dynamic code loading is involved. But, maybe using Go is a requirement in OP's case, and you are indeed giving interesting options. Note that your link to hashicorp/go-plugin is invalid, it should probably be https://github.com/hashicorp/go-plugin. It reminds me a little of CORBA and co. (not saying this is bad, though). 
Resumable download tools for the command line are pretty established already, see wget's or aria2's --continue for example. Currently, it looks like it handles a subset of aria2's capabilities, the multiple progress bars look nice though ;)
aria2c has been resuming downloads on the command line for many years.
&gt; I don't think this is go-specific though, I don't think any language can do anything special to allow this, because the things happen on the OS layer. I never actually did this, but AFAIK you can easily `bind()` before a `connect()` and that should do the trick. Not calling `bind()` before `connect()` lets the kernel choose appropriate values instead of manually defining them, but I'm pretty sure nothing mandates this "shortcut". Point in case: Ruby's `TCPSocket.new(remote_host, remote_port, local_host=nil, local_port=nil)` with documentation: &gt; Opens a TCP connection to remote_host on remote_port. If local_host and local_port are specified, then those parameters are used on the local end to establish the connection.
Nice! Im going to be using this, thanks!
Nice - how does this compare to axel? http://axel.alioth.debian.org/
Take a look at gb. https://getgb.io I think it covers your requirements with a project based approach
Oh cool. I didn't know about sqlstruct. I'll have to check it out. Thanks!
Wow, TIL, thanks, that is really useful to know :) I didn't expect that /u/twek with what /u/tashbarg said, I wrote a thing that does what you want using syscalls. Then I discovered that there actually [already is a thing in net](https://godoc.org/net#DialTCP) and came up with [this](https://play.golang.org/p/_SCQLNJB2M) to run against [this server](https://play.golang.org/p/y33XTJes4u) and got a full success :)
As a corollary to /u/dinkumator's statement, there's also a [`DialTCP()`](https://www.godoc.org/net#DialTCP) function.
You can use the LocalAddr from net.Dialer in conjunction with net.IterfaceByName. Small example: https://gist.github.com/creack/43ee6542ddc6fe0da8c02bd723d5cc53
Whoa, for a second I thought that I posted this question 3 weeks ago. Anyways, I tried what you are trying to do and realized it was too complicated so I will show you a solution I made that operates **like** socket.io. **below** is the web socket object: const OpenWebsocket = () =&gt; { const theSocketUrl = window.location.protocol !== "https:" ? "ws://damp-beyond-64138.herokuapp.com/ws" : "wss://damp-beyond-64138.herokuapp.com/ws"; const SOCKET = new WebSocket(theSocketUrl); SOCKET.on = {}; SOCKET.watchedFeeds = {} SOCKET.dispatchEvent = ((SOCKET) =&gt; { return (name, callback) =&gt; { SOCKET.on[name] = callback; } })(SOCKET); SOCKET.onmessage = function(event) { let theData = JSON.parse(event.data); if (!SOCKET.watchedFeeds[theData.symb]) { SOCKET.watchedFeeds[theData.symb] = true; SOCKET.on.liveFeedStarted(theData.symb); } SOCKET.on[theData.symb](theData); } return SOCKET; } module.exports = OpenWebsocket; how it works: On the SOCKET I added an object called on: SOCKET.on = {}; Then I create a closure function that creates a function that takes a key: "name", and the callback to be called. This way I can now add a callback to any key wherever I want. For example in my app I have the **SOCKET** object added to a REACT component called **dbSource** . An example from my App below: //this.feedWatch is the key this.dbSource.dispatchEvent(this.feedWatch, (details) =&gt; this.liveUpdate( details )); If SOCKET was a global object though it would be the same as doing this: SOCKET.dispatchEvent(theKey, function(data){ console.log(data); }); What this does is when the web socket gets and on message event, it parses the data and assuming you have a named **key** convention, (mine is **symb**) it plot the key into SOCKET.on[theKey](parsedData) SOCKET.onmessage = function(event) { let theData = JSON.parse(event.data); if (!SOCKET.watchedFeeds[theData.symb]) { SOCKET.watchedFeeds[theData.symb] = true; SOCKET.on.liveFeedStarted(theData.symb); } SOCKET.on[theData.symb](theData); } So this way you can dynamically add a key listener and have functions called anywhere, while the data is only parsed once and then dispatched. **EDIT:** Oh yeah here is the source code of the examples I just gave you: GoWebsocket module: [here](https://github.com/MKwenhua/real-time-charts/blob/master/public/js/components/data/gowebsocket.js) In CanvasChart is where is subscribe to a "feed", **this.dbSource** is the pointer to the object: [here](https://github.com/MKwenhua/real-time-charts/blob/master/public/js/components/micro/canvaschart.js) Also on the Golang micro service I have a little "test" page, where I do the same thing, it may be easier to read and understand this way: [here](https://github.com/MKwenhua/market-feed-sim/blob/master/index.html)
As my very first Go project I've ported the Hjson parser/serializer. Hjson is a JSON variant for config files. Feedback welcome!
Thanks for giving it a go anyway, and for the multiple-short-surveys idea. We are getting lots of completed surveys, but it's true that it takes some time to go through, and not everyone finishes it.
Compile with `go build -ldflags=-s` instead of using `strip`.
"Standard" is a bit too strong of a word, but when you have the kind of app that revolves around a lot of "business logic", Ben ain't wrong.
I'm coming from Rails and Goa is a good stepping stone to learn from how to structure an application and plugin any libraries. It will create controllers, types you can use for serialization in requests and responses, a swagger file, an example Javascript client, authentication (JWT, OAuth, others as well). It uses a DSL which isn't that hard to grok after staring at it long enough, haha. The small amount of code you write in the DSL it generates some very nice idiomatic Go code. All you have to do after is either use Gorma or plugin your own database (SQLX, Gorp, Xorm, whatever you like). The outputted code is easy to follow and understand and you can always re-generate. Even the Goa code itself is easy to understand and small enough a beginner like me can get in their and dirty or write plugins using the DSL.
Keep in mind a lot of people likely don't even start when it says 20 minutes. Anyways I'll try to find time over weekend since you mean well. Glad you are getting results regardless.
I know the micro service is written in go using gorilla [see here](https://github.com/MKwenhua/market-feed-sim/blob/master/web.go). What I was saying is the amount of set up to get the Go server would take quite a long time(and research), so I thought creating a client side object that can do the same things as **socket.io**, but work with any web socket service seemed easier. The code I showed you is for the client side in browser code. Anyways, I had a similar problem before wanting to create a "socket.io" experience in go, here is the question i [asked](https://www.reddit.com/r/golang/comments/4ulbba/using_gorilla_how_should_i_go_about_creating)
Hm, actually -s doesn't make much of a difference but -w does (omits DWARF table, i.e. debug info). 
or DialUDP if we're really going all-out
While using the encoding/json package.
This is a small part of the codebase I'm working on today: ------------------------------------------------------------------------------- Language files blank comment code ------------------------------------------------------------------------------- Go 180 3923 4219 22310 C/C++ Header 38 2292 3564 8959 Assembly 113 838 1030 3496 Amount of reflect used? 0. Turns out if you use go:generate and interfaces cleverly, you don't need reflection at all
I try to use reflection as little as possible. Usually only when dealing with JSON
Vendoring packages means no breaking changes for me until I care to update a package. Keeps it really super simple. Not taking any time to fill your survey.
I use the reflect package a decent amount (probably more than the average Go programmer). Generally it's when I want code to take arbitrary values and do something intelligent with the information about what type those values are. For example, in [gopack](https://github.com/joshlf/gopack), a bit-packing package, the code inspects what type is being passed in order to determine how many bits each struct field requires to represent, whether each struct field has a tag that instructs the package to alter its behavior, etc. You can see a similar use in the encoding/json package - take a look around the source of that package to see how they use it.
I just love your blog posts. They teach me so much. Things which are really hard to learn / find out from other sources. Thanks ben!
Believe it or not but YAML isn't liked by everyone. There are a lot of projects using JSON for configs even though it's not suited for this purpose.
Codecs and smart mappings seem to be the most common use. For my work, I have only used reflect once, and indirectly at that: to make a [smart web scraping extractor based on struct tag CSS queries](https://github.com/cathalgarvey/sqrape). Dealing with reflect, even with the friendly tools I used to minimise my exposure, wasn't fun.
cool project! 
Thanks for the input. That's cool stuff. That makes perfect sense!
I used it to write a library that transformed the aws-sdk into their actual types using metatags. It greatly sped up my development process when I was working with DynamoDB.
On linux probably yes, on other platforms you will have to OS filtering out packets from addresses that you haven't sent anything to, hence why there are different syscalls for that - one for sending, one for receiving.
Haha, I meant I did not understand your explanation. So, UDP packets are actively tracked by OS for where they were sent? o_O Which OS would that be? But I read another reply from /u/nsd433 which explains it. Note to self - Coding in C for 14 long years make you dumb. 
So talking from experience, if you do a connect equivalent on a udp socket on Windows, windows will filter out any traffic comming not from the connect address.
Very nice, I've been doing some transpiler experiments so probably will give this a try.
Whats wrong with having a `Makefile` for your project? You probably have a few other tasks that you want to do on a regular basis.
Usually only when needing to extract information or converting information from one form to another and need to dynamically handle unknown types, and even then that info is cached the first time to avoid slowdowns. Good examples: - Go`s STD RPC package - Go's STD json package - [form](https://github.com/go-playground/form) - [validator](https://github.com/go-playground/validator)
having a `Makefile` doesn't mean a Go package or command won't be go-gettable. it just means that a given workflow is properly documented :)
It looks attractive to use, BUT backward compatibility for json config files is not part of hjson. I'll give you an example. Certain python packages only generate .json output configuration files. python doesn't seem to have hjson. That implies a doubling of effort to introduce hjson. Effort to read in json and then save it as hjson AND effort to save yet again as json if you change the configuration. You'll be managing two configuration files from that point: json and hjson. With all that said, I looked at the hjson format and it looks very cool and easier to use that json at first glance. If all the languages adopted hjson there would be strong argument to use it, but legacy apps/libs would require maintaining the json alongside. I would use hjson if I could, but I can't (python json dependencies) so I won't. 
Thanks, I'm glad you like it! :)
I like it, I think this sounds good. While we map structs to columns when using special methods like Insert or Update we currently don't do something like that for raw queries. I added an issue for this https://github.com/upper/db/issues/223 
I'd be interested if anyone finds anything, I have been looking into this for quite some time now, ended up using the rust bindings for OpenCV, though that is currently the only service I am working on not written in go
&gt; with a specific source IP, or that goes through a specific network port/interface? If you want to make a connection from a specific source IP, the net package has a bunch of features here (as people have mentioned): you have DialTCP(), DialIP(), and t Yeah I probably should have phased that better, I did just want a specific source IP address, to get around port exhaustion, DialTCP works thanks! 
How can the VERSION file work for the patch number? Every single time there is a minor change in code base, someone needs to manually bump 1.0.123 to 1.0.124. A big pain in the bum, unless I'm missing something here?
Looks great! How does this fair up to https://github.com/buger/jsonparser performance wise?
Uhh... https://www.reddit.com/r/golang/comments/4wsfxa/go_17rc6_released/
I just gave this a test in a small project, performance boost is fantastic without even taking full advantage of features yet. Well done on this, will be using it from now on.
That's great to hear. :)
Since you responded politely and I work in the security sector I figured I would audit your code since I'm laying here sick.. blah! Anyways, I'm glad I did because I found a very serious vulnerability after follow the lead of my earlier suspicions. &gt; Vulnerability info: &gt; Susceptible to removing the users entire home DIR due to unsafe handling of links mixed with the os.RemoveAll usage in main.go. This is particularly dangerous with this tool since it follows redirects. There are likely permutations of this exploit that could have much more serious consequences in a targeted attack (elevation). I.e.: hget http://domain.com/file.txt (web server) 302 -&gt; http://domain.com/.. # Results in -&gt; os.RemoveAll("/home/$USER") Please do not run hget on the url **http://domain.com/..** to "test" this.. you will lose your home directory. Suggestion: Do not construct paths in this way, in code.. ever! Always use a deterministic method for building paths using paradigms known to mitigate directory traversal attempts. In your case changing all instances where you build paths, such as *FolderOf* to use a basic hash function derived from the URL. The key here is to not attempt to derive any file system operations from the file name. i.e.: &gt; func FolderOf(url string) string { &gt; return filepath.Join(os.Getenv("HOME"), dataFolder, sha1.Sum([]byte(url))) &gt; }
That's not true - not if you want to be able to inspect arbitrary types. You can't, for example, have a type switch with a case for a type you aren't aware exists (like one that a consumer of your package has defined). For example, take a look at [this function](https://github.com/joshlf/gopack/blob/overhaul/pack.go#L71), which is used to do the pre-processing necessary to be able to pack or unpack a given type. It switches on the *kind* of the type so that it can handle things like structs and arrays, and also so that it recognizes types such as **type foo int** as an integer type.
At issue is the fact that the go community is a positive and welcoming community. It makes a very conscious effort to do so. This means, at a minimum, being polite. Criticizing or ridiculing for not knowing something, even something basic, is the entry way to becoming the cesspool of negative feedback and one-upmanship that is most open source projects. I love the Go community. I like the fact that I can post code and reasonably expect to not be insulted for imperfections. I like the fact that people regard helping others as an opportunity rather than a burden. And without the community helping to enforce this culture, it will disappear. So "RTFM" which is quite literally cursing at somebody, is not acceptable even though the same message "The answer to your question was in the README" is a good and helpful answer. So don't pretend that all questions are equally important or intelligent. But don't respond to any question in a disrespectful tone. That does no favors to anybody, including yourself.
&gt; Why can't Go be good at what rails is good at? There's absolutely no reason it can't be. I'm writing similar apps to those I write in Rails (or have written, mostly writing Go now) with few problems. It's certainly possible and there are lots of useful libraries available for most of the things that Rails provides out of the box, particularly for writing APIs. 
Great article / tutorial. It really brought about understanding the gap between theory and code- hope I stated that correctly. 
As long as err == nil. If err is nil, t is assumed to be ok.
You've got a few bugs in this new benchmark. Makes a significant difference: benchmark old ns/op new ns/op delta BenchmarkJSONParserGet-4 1006 786 -21.87% I'm not sure why it's *slower*, but you were asking it for the nil key three times in a row. gjson $ git diff diff --git a/gjson_test.go b/gjson_test.go index 1aec401..2bfaa33 100644 --- a/gjson_test.go +++ b/gjson_test.go @@ -495,15 +495,15 @@ func BenchmarkEasyJSONLexer(t *testing.B) { func BenchmarkJSONParserGet(t *testing.B) { data := []byte(exampleJSON) - keys := make([][]string, len(benchPaths)) + var keys [][]string for i := 0; i &lt; len(benchPaths); i++ { keys = append(keys, strings.Split(benchPaths[i], ".")) } t.ResetTimer() t.ReportAllocs() for i := 0; i &lt; t.N; i++ { - for j := 0; j &lt; len(benchPaths); j++ { - _, _, _, err := jsonparser.Get(data, keys[j]...) + for _, k := range keys { + _, _, _, err := jsonparser.Get(data, k...) if err != nil { t.Fatal("did not find the value") } 
Great points. go-jsonpointer looks like a pretty cool project. I just posted an update to gjson that provides basic escape characters. You can now get a key with dots by using a slash such as "points\\.bean\\.pointsBase". The purpose of gjson is to provide quick indexing to in-memory blocks of json. Streaming API and well-formed documents are lower priority for now. Thanks for the excellent feedback.
You did. I thought the same thing. There is similar exercise in the Go Tour that I never finished. I'll give it another "go" now that I understand it a bit more.
Sure, my jsonpointer implementation was written for [seriesly](http://dustin.sallings.org/2012/09/09/seriesly.html). I don't have an instance running anymore, but I ran a lot of data through it. See also the [internals doc](http://dustin.sallings.org/2012/09/13/inside-seriesly.html).
Neat! It'd be cool if you could implement property existence checking. I wrote a simple package in https://github.com/WatchBeam/hasOwnProperty which does that, bootstrapping on EasyJSON, but if your package can do it faster that would be awesome :)
If it's HTTP 1.1 it should be case insensitive, so instead of making workarounds, pestering Amazon to fix it would be the "correct" way to handle it. https://tools.ietf.org/html/rfc7230#section-3.2
The article's author already [posted this some days ago](https://www.reddit.com/r/golang/comments/4whb6v/a_binary_search_tree_applied_go/), more comments there.
Contribute to the standard library. Give database/sql some love because it needs it. But "moving" the package to /x/ and breaking the API? Please don't do that. The Go 1 compatibility promise, albeit restrictive, is one of the strongest features of Go because we know that our code will keep working with each new version. EDIT: Added quotes on moving.
The existing standard library package won't be moved. The proposal is about freezing it and moving *development* to a new package under /x/.
That's what I meant. It would have been more obvious if I had used double quotes on the word moving. I am gonna fix it I guess.
Agreed I like your second example. It's legible and doesn't hurt my eyes to look upon. 
I mean, you're right, but this broke production code. I have customers that I am accountable to. I'm glad I found an easy workaround and didn't have to wait for AWS to fix it. I (and others) did pester Amazon. Looks like they fixed it a few hours ago. https://forums.aws.amazon.com/thread.jspa?threadID=237153&amp;tstart=0
Yeah, I get that. In retrospect it was an unnecessary remark.
The only reason I suggest this is I don't see how to fix the SQL package without breaking API. Suggestions welcome.
While not Go specific, you could use Google Analytics for that. https://developers.google.com/analytics/solutions/google-analytics-super-proxy
&gt; bradfitz: "I'd rather improve the one we've got instead." &gt; &gt; kardianos: "I'm willing to work on it either way." Kardianos MVP!
Hi, this pattern is represented cleanly in text.Scanner if you are the one designing the API. It places the err check outside the loop. If you are consuming another API it doesn't matter much Ralph has it covered in his post.
really? how can socket.io exist without a client? I mean if you're doing server-server why not use something like Redis PubSub. Anyways, the question is gone, so I can't re-read it. 
An IP address is fundamentally a list of bytes. IPv4 is a [4]byte and IPv6 is a [16]byte. For example 192.168.2.3 is literally []byte{192, 168, 2, 3}. You should also note that if you do: m := make(map[string]bool) m[string([]byte{1,2,3,4})] = true The string conversion is special case and doesn't allocate (I'm fairly sure anyway).
I believe _all_ header field names need to be lower-cased for HTTP/2. Also, AWS does support HTTP/2: https://aws.amazon.com/blogs/aws/new-aws-application-load-balancer/
i get that -- but string is *also* a list of bytes. the only difference between string and []byte in Go is that []byte is mutable and string is not -- hence, why string can be used as a map key and []byte cannot. it seems like the having net.IP be mutable is a not useful. regarding the special case for map[string(bytes)] lookup: (1) no big deal in this case and (2) yes, is Go smart enough to recognize and not do any allocation. (there's a bug thread online about this, that resolves in the optimization getting committed.) but it doesn't help you with composite types: var key net.UDPAddr someMap[key] // what now?
But strings can be seen as "textual representation of data", and byte arrays are "binary representation of data". take the above example of IP 1.2.3.4 - as a string it's not even printable as anything meaningful. so it's definitely not a textual representation of that IP.
I just yesterday found out that a crappy client I have to connect to is case sensitive with its headers. So it goes, no one follows the spec…
maybe it would be easier as uint64 with either 4 bytes or 6 bytes set, and the rest set to 0.
IPv6 is 128 bits though (16 bytes, which doesn't fit in an uint64, and there's no uint128)
IP addresses are better placed in a sorted slice.. or for ranges using IPNetwork. If you are trying to associate values to them maybe use a simple btree or better yet any prefix (radix) tree is particularly more suited for up addresses 
&gt; what now? Now you're talking about something entirely different. Conversion between `[]byte` and `string` is an explicit, sensible optimization. What does that have to do with a struct type?
Thanks I'll take a look at it.
No, I'm talking about exactly my original question. If IP were defined to be type IP string then you'd be able to use types like UDPAddr as keys in a map. The casting trick works great if you've just got a raw net.IP, but it doesn't work for types that contain net.IP.
I am not suggesting that you store the ip address as "1.2.3.4", I'm suggesting that you store it as string([]byte{1, 2, 3, 4}). string is just a collection of bytes. it can contain any byte values. cc /u/nhooyr Maybe this is the answer to my question -- it's too weird to store "not textual strings" inside string. But again, from a technical perspective, []byte and string are exactly the same, except []byte is mutable and string is immutable. mutating IP is not something you need to do.
Sometimes you just want the convenience of a map, though.
I dunno, sounds like an inconvenience to use data structures that don't fit the problem. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [to RTFM or not to RTFM ?](https://np.reddit.com/r/programming/comments/4xhuup/to_rtfm_or_not_to_rtfm/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
At least his example worked :)
&gt; panic("TODO") Give it some time and we'll see if something significant will come of this. One thing I am curious about though is how well Go will lends itself to the type of hardware this "Fuchsia" OS will run on. I sort of think Go is like an evolution of C and for the embedded space I'm excited as to what might happen. 
Google very long term plan could be to ditch Java away from Android, VR and IoT products line. It is something probably will never announce till the very last moment to not panic the developers and partner community. They dodged a nuke last time at court.
People write all these nice tools in Go that are potentially useful for all kinds of other people including developers who are primarily using other languages or even people from other fields like network engineers and so on. Yet most of these tools are only posted in this subreddit where only a tiny fraction of potential users will find them. On top of that the installation instructions rarely contain any other way than `go get ...` which assumes users have a Go environment set up. So here's my question: why are you guys hiding these nice tools from the rest of us?
Author here. I will be monitoring this thread after lunch. Feel free to share bugs/ideas or just call it a NIH.
This is something I've had on my TODO list for a while, thanks, I'll definitely be keeping eye on it.
Glad to hear that.
Interesting. I've thought for a while that the command line is a great way to do stuff, but a terrible way to explore a file system. `cd` to a directory, `ls` the files (oops, `ll` the files; oops, this is superuser, so `ls -al` the files), and finally `cat` the one you're interested in (oops, should have used `less`) is _very_ inefficient compared to a GUI. OTOH, most GUIs don't know how to meaningfully interact with text files. I've installed Midnight Commander to try and get the best of both worlds, but for whatever reason, it never clicked with me. It's cool to see someone else working in the space. Looking at the screenshots made me realize that more than moving, renaming, copying, or deleting, what I want is something with a macOS Finder column-view look with the ability to look into a file's contents. (A syntax highlighter would be good too.)
FYI: The general idea is called [Miller columns](https://en.wikipedia.org/wiki/Miller_columns) and dates back to NeXTSTEP stuff (and Smalltalk browser). I've always been quite surprised that it never got wider recognition all these years. When hut first announced ranger few years ago, I was like "finally!" :-). EDIT: BTW: Your color scheme looks surprisingly similar to mine ;-). Some flavour of solarized, perhaps?
The driver registering to its vendored copy of `database/sql`, while user of the library imports the non-vendored `database/sql`. I'm sorry but this is a perfect example of why libraries shouldn't vendor -- you're actively trying to understand the problem, and it's still too subtle. Now imagine someone who isn't even aware of the implications.
I agree. In my case, my focus is on golang and I don't know anywhere else to share my projects. I would welcome suggections! For this particular project, after reading your comment I uploaded binary releases for a few OSes at https://github.com/siadat/benchttp/releases I hope it is useful. Let me know if there is another way to make it easier to install/try. :-)
I think even for a non-Go programmer, `go get` is easier to use than, e.g., a `Makefile`. For example, I made a [get-headers](https://github.com/carlmjohnson/get-headers) tool in Go. The README says, &gt; ##Installation &gt; &gt; First install [Go](https://golang.org). &gt; &gt; If you just want to install the binary to your current directory and don't care about the source code, run &gt; &gt; GOBIN=$(pwd) GOPATH=/tmp/gobuild go get github.com/carlmjohnson/get-headers I think that's much easier than "git clone, now ./configure, now install npm, now npm install, now make, now guess why this binary is broken, now make install, now _sudo_ make install…" My project has no dependencies, but if it did, they'd all be handled in the temporary GOPATH, which is handy too.
For something so critical, it would be prudent to write unit tests.
Great. I had to change some stuff in my application to handle the bytes.Buffer (i send this byte array to a piece of hardware at my house). But this is working well. Looking at all these examples I may have been over complicating in the beginning. Thanks again.
The kernel is here: https://fuchsia.googlesource.com/magenta/+/master
I agree there aren't enough tests. At some point I had some tests for parsing as well, but then I removed it while doing some refactoring. I'm hoping to add them back when I'm cleaning the parser code. Other than that it is not very obvious how to test the rest of the code. Even if I mock the filesystem somehow it is very difficult to test the evaluator, ui and the rest, at least with just unit testing. I feel like it would be much of a burden to maintain the tests themselves and I don't think they would serve to reduce the danger of the software. Warning in the readme might be a little bit an overstatement though. It shouldn't be much more dangerous than the shell itself. I have been using it for a while and haven't got any accidents so far other than deadlocks in the evaluator. I just want people to be cautious.
Yea, I don't know both "this things", me dumb. I'm still learning the basics. One day I'll be a hobbyist developer who debates against industry professionals for self validation, but not today. I pity you. Cya.
&gt; Isn't our industry called information technology by the way? Doesn't it mean we should first of all be competent in finding and reading the information? We should be. But when we encounter someone who is not, should we sacrifice the community people have worked so hard to create? The negativity is the thing I have the problem with, not correcting the offending behavior in a respectful manner, or simply staying silent. Even if you encounter an idiot, don't be rude.
You could provide a docker image Or cross-compile to various OS's so people can just download a binary. Go makes both of these options very easy, see my one https://github.com/quii/mockingjay-server/wiki/Installing
You could use `UDPAddr`'s `String` method. Sure, it doesn't have the memory optimization, but I think it's a fair trade-off for having `IP` be `[]byte` since that's a much nicer format for manipulating the IP.
Nice, aside from the lack of tests. You don't have to test everything. But some tests are useful to demonstrate how testable your codebase is. Test a few routes, that's all, even if it results in 5% code coverage. I have no opinion about the use of Gin it's at least some code you won't have to test yourself.
Thank you very much for this feedback. I do have one question: &gt; And the quit chan is disposable. Can you clarify what you mean here? The point of the quit chan is to make sure that the goroutine exits before the main thread. Would you recommend something like [sync.WaitGroup](https://golang.org/pkg/sync/#WaitGroup) instead? **EDIT**: I think I understand what you mean now. The quit chan is not needed if the goroutine is the client's responsibility. I've updated the library and the [example code in the README](https://github.com/davidscholberg/go-i3barjson#usage). **EDIT 2**: I decided to dispense with the status channel altogether and opt for an Update function to send messages to i3bar. This eliminates the need for a goroutine entirely, and makes error handling much simpler.
I have a Go package that retrieves kernel statistics from Solaris/Illumos/OmniOS kernels. Most of these stats are exported in various fixed forms that are known in advance so I can provide specific functions to retrieve them, but the kernel can also export what are essentially arbitrary C structs. A user of my package may want to get such an arbitrary statistic that my code doesn't currently know about, so I provide an API where the user says 'here is a Go structure, fill it from kernel statistic &lt;X&gt;, I know what I'm doing here'. (Such specialized raw-struct kstats might be exported by eg a specialized driver that the user is dealing with.) The underlying implementation of this uses reflection both to copy the actual data from the kernel into the Go structure and to validate that the Go structure doesn't contain anything obviously dangerous (no pointers, no maps, no slices, etc). I'm not sure if this API is a good idea, or if I should force the user to do the unsafe copying themselves (I also have an API where you get the statistic as a `[]byte` block and you can do whatever unsafe things you want with it). (The curious can see the code in [raw_solaris.go](https://github.com/siebenmann/go-kstat/blob/master/raw_solaris.go).) 
Why is that many links in this subreddit are heavily downvoted?
Much simpler now. But the marshalIndent returns the plain error text on error, instead of a json object. I don't know the consumer's input handling, but returning a json wouldn't be bad. Like fmt.Sprintf("{"error":%q}", err.Error()) The other thing is that you use a global jsonWriter, without concurrent access protection. Either document that concurrent calls are forbidden, or use a sync.Mutex.
Here is a list I just shared with my team - https://gobyexample.com - http://openmymind.net/The-Little-Go-Book/ - https://golang.org/doc/effective_go.html - http://golangweekly.com/ (one of the few emails newsletters I actually look at) - ... /r/golang (you are here!) is active has a healthy community :) 
 var ba = []byte{ 56, 66, 73, 77 } var value int32 value |= int32(ba[0]) value |= int32(ba[1]) &lt;&lt; 8 value |= int32(ba[2]) &lt;&lt; 16 value |= int32(ba[3]) &lt;&lt; 24 reverse the indexing order to switch between big and little endian.
Use [io.ReadFull](http://godoc.org/io#ReadFull), whenever you need to actually fill the slice. Short reads are [allowed](http://godoc.org/io#Reader).
Thanks, the 4th one is what I've never heard of. Now subscribe completed.
* http://jordanorelli.com/ * http://www.dotnetperls.com/go * https://www.goinggo.net/ * https://www.nada.kth.se/~snilsson/concurrency/ * https://divan.github.io/
Well being nice is ok. And I see nothing negative in pointing the harmful consequences of polluting with noise places. It is like when you go in the forest and you tell someone that is spilling his/her trash to pick them up. We all have noticed that even when said nicely the offender always find it negative. Negativity is often not in what is said, but in the feeling of the offender. Well, that is the same here. Most of people don't like to be told they misbehave they take it personally, but like for trekking, on the overall you prefer to favor the state of the forest than the feeling of an offender that if not told may do it again. Sometimes common interest are more worthy than personal feelings of oversensitive persons. Education is important. And, education sometimes comes with bruising slightly the feeling of the person that comes to ask you for it. I am repeating: the guy comes to you for education and may not like what he is hearing. When you ask for a favor be prepared that people may not comply with your demand. Beggers are not choosers.
The last two look interesting. Thanks!
u're welcome.
There are definitely Go programmers in Hong Kong.
Author of Applied Go here. I am delighted to hear that you like my blog. It is only a few weeks old, that's why there is not much content yet. But I try to keep the content coming, at least once every two weeks. In addition to the sites and blogs that others have already listed here: **Blogs** (some of them are not pure Go blogs but still worth following IMHO): https://gocodecloud.com https://jacobmartins.com https://blog.filippo.io http://learngowith.me http://www.goin5minutes.com (screencasts) **Other sites:** https://leanpub.com/GoNotebook/read https://nanxiao.gitbooks.io/golang-101-hacks/content The definite (printed) book on Go is "The Go Programming Language" by Alan A. A. Donovan and Brian W. Kernighan. If this feels too heavy, you might want to give ["Learn Go"](https://www.manning.com/books/learn-go) a try. It is still a work in progress (18 of 24 chapters completed) but is accessible via an "Early Access" program. 
https://golang.org/src/encoding/binary/binary.go#L142 Looks like you need to, there's no case for []byte.
No. 1. This is not related to go. 2. You are asking someone to do something illegal which is against Reddit's rules: https://www.reddit.com/help/contentpolicy/. 3. Don't like a site or their management? Leave. Don't give them the attention they want and don't try to 'fix' the situation because in 99% of cases you'll only make it worse. Additionally, responding like this is borderline childish. 
Thanks. I found a couple of these bookmark worthy. 
Hack the planet
well then thanks for the advice
danke
When I look on Google Trends map, it looks like GO popularity is spreading from HK ;) https://www.google.com/trends/explore?date=all&amp;q=golang (zoom in on China)
That's quite the function. https://github.com/tidwall/gjson/blob/e865d89fc77021ef6ecfdd34df1b546a87d58799/gjson.go#L123-L491
Lol you still are trying to save face here? Man you have some issues dude. You have to be super young or just some sort of mental issue. Here's me submitting performance improvements to google/btree months before you "began looking at a little c++" https://github.com/google/btree/pull/1 What don't you understand about me working as a developer for 12 years? 2008 I was working on a language VM using llvm: http://markmail.org/message/wlwz5adqwhilgre7 Do you really think that I was working on compilers 8 years and some how still don't the difference between a map and a binary tree? Are you that delusional? The entire point of my reply is to show how you took a casual comment with more than one solution picked the one that suited your needs to begin an opposing argument for self validation. My point as that this time you chose to argue with someone who has much much more experience than you and you just made yourself look dumb to me. You irritated me and I was hoping this entire thing would teach you a lesson and help you grow a little as a developer. But I read even until this last minute, your still desperately searching for a way to make yourself feel like you won. It's just not really humorous to me anymore nor irritating, it's just sad and I regret feeding into you since it provided no value and I don't feel better for venting. Anyways, I got nothing else to say here, if you want to think you're superior to me go right ahead, I don't care. I'm inferior to so many developers out their adding one isn't changing anything. I learn every day and the subject matter I'm an expert on is avoing set of intersections because I'm human and my interests change over time. Good luck asserting your expettise in everything you talk about to everyone in every domain, it must be exhausting all the googling you do for little to no benefit. Take care.
Good stuff!
If another goroutine tries to call mutex.lock it will block until the first calls unlock.
You're confused on what a mutex does. Locking a mutex prevents another goroutine from locking it as well. So when another goroutine wants to lock the same mutex, the call is blocked until `mutex.Unlock` is called.
[This](http://www.alexedwards.net/blog/understanding-mutexes) is one explanation with examples. Also a good analogy is this: &gt;When I am having a big heated discussion at work, I use a rubber chicken which I keep in my desk for just such occasions. The person holding the chicken is the only person who is allowed to talk. If you don't hold the chicken you cannot speak. You can only indicate that you want the chicken and wait until you get it before you speak. Once you have finished speaking, you can hand the chicken back to the moderator who will hand it to the next person to speak. This ensures that people do not speak over each other, and also have their own space to talk. &gt;Replace Chicken with Mutex and person with thread and you basically have the concept of a mutex. From [here](http://stackoverflow.com/questions/34524/what-is-a-mutex)
Thank you
Thank you! 
Hmm interesting, it seems byte is en alias for uint8 in some way https://play.golang.org/p/0QoqdZIvdJ Golang spec says "byte alias for uint8" In https://github.com/golang/go/blob/master/src/go/types/type.go: Byte = Uint8 Good to know!
"PS. Binary search will not help you when inserting and deleting from sorted slice moron. That's why you use hash map because you have O(1) guarantee." No one said anything about inserting or deleting, until you created it to funnel into a position where you felt you were right. Again, you are ignoring my original comment. for the 1000th time where I say: &gt; **or better yet any prefix (radix) tree is particularly more suited for _ip_ addresses** &gt; **or better yet any prefix (radix) tree is particularly more suited for _ip_ addresses** &gt; **or better yet any prefix (radix) tree is particularly more suited for _ip_ addresses** &gt; **or better yet any prefix (radix) tree is particularly more suited for _ip_ addresses** &gt; **or better yet any prefix (radix) tree is particularly more suited for _ip_ addresses** &gt; **or better yet any prefix (radix) tree is particularly more suited for _ip_ addresses** &gt; **or better yet any prefix (radix) tree is particularly more suited for _ip_ addresses** &gt; **or better yet any prefix (radix) tree is particularly more suited for _ip_ addresses** &gt; **or better yet any prefix (radix) tree is particularly more suited for _ip_ addresses** &gt; **or better yet any prefix (radix) tree is particularly more suited for _ip_ addresses** &gt; **or better yet any prefix (radix) tree is particularly more suited for _ip_ addresses** &gt; **or better yet any prefix (radix) tree is particularly more suited for _ip_ addresses** &gt; **or better yet any prefix (radix) tree is particularly more suited for _ip_ addresses** Want to argue with that too? Here is a Radix tree (general implementation of one I haven't reviewed) verses your map for MILLION records. &gt; https://play.golang.org/p/vwTw_xiMyA BenchmarkStructures/patricia/inserts-24 100 22776302 ns/op BenchmarkStructures/patricia/misses-24 2000000 944 ns/op BenchmarkStructures/patricia/hits-24 10000000 201 ns/op BenchmarkStructures/patricia/deletes-24 30000 46637 ns/op BenchmarkStructures/map/inserts-24 200 8604816 ns/op BenchmarkStructures/map/misses-24 1000000 1130 ns/op BenchmarkStructures/map/hits-24 2000000 667 ns/op BenchmarkStructures/map/deletes-24 300 4195421 ns/op Are you done being proved wrong yet? Have you not learned?
Cringe.
&gt;&gt; echo $GOPATH &gt; and it's fine. Try running: export GOPATH It is possible it is set in your shell, but not being inherited by forked processes.
In IntelliJ you need to add that to the configuration of the plugin or launch the IDE from the console. The environment variable is not going to be passed from bashrc or zshrc to the application, that's just how POSIX works. Note that it might not be passed by the ~/.profile either on some systems. See this https://github.com/go-lang-plugin-org/go-lang-idea-plugin/wiki/Documentation#changing-the-go-libraries-go-packagesfor how to set it and please ping me or open an issue if you need any more help. Hope it works.
See my other reply. The terminal in IntelliJ runs a proper terminal session, that's why it's working.
Yea, I have that in my .bashrc :\ and it's there right after startup. Thanks anyway.
Go with visual code - much better. Still have to launch from the command line for $GOPATH to be picked up (AFAIR) but much better than atom.
Happy it worked. And maybe you'll give IntelliJ a try after you check out Atom? :) Enjoy Go and if you want to network with more Gophers, there's also this Slack channel: https://gophers.slack.com/ (invite here: https://invite.slack.golangbridge.org/ )
Are you on a Mac?
Cool thanks. Didn't now it had Go support. It does seem better than atom. Got it working without launching it through the terminal by doing the exports in .bashrc(which I already had) AND .profile AND .bash_profile. Don't know which one of the two helped but I don't care now. Last thing left is vim-go autocomplete...
Awesome! Glad to help :)
I already proved what you wrote was wrong. You can pivot positions all you want. You pretentiously made a baseless assertion that I had no familiarity with the data structures we were speaking of. I made an in depth counter point proving I was much more experienced than you. This is a fact. Period. You can't refute it. You also tried to say map was a superior data structure. I proved you wrong though benchmarks. Instead of accept this you pivot again, taking a position that I "invested more time" in my replies and you just took thirty seconds each time. Again trying to make yourself feel better that someone more experienced schooled you. Again. Lick your wounds and move on, your not saving face here. There's no one watching but me and you. We are at the tail of a dead topic deeply nested. You are safe little buddy. No one too impress or will "know your secret", why can't you just read what I wrote, learn and reflect? Why take it personal and make it personal? (Attack my experience)? What outcome could you have possibly expected? I really hope you learned something from this, even if you don't admit it openly here. Happy coding you little turd.
There's a package for atom that properly sets environmental variables, but I cannot for the life of me remember the name. If only I had atom on my phone, I could check.
You will likely have to write your own function, I am the author of [validator](https://github.com/go-playground/validator) and I can say I have had the same question asked allot. I would say that it isn't the library's job to return a formatted error message, but rather all the information needed to create one; the main reason is context, the message that you wish to return greatly depends on context of what's going on in your application, of which the validation library has no knowledge. This also becomes an even bigger issue once getting into translating into other languages and having to comply with plural rules. I would recommend creating a common function that accepts the returned validation errors and returns a set of human readable and translated errors and then use the json package to Marshal that data and write it back on the http response.
It's "tiny."
better yet, run go env from your editor environment to be sure that the GOPATH is set for the editor. When I was setting up Sublime on a particular machine, for some reason it didn't pick up my .bash_profile settings ([.bashrc vs .bash_profile?](http://apple.stackexchange.com/questions/51036/what-is-the-difference-between-bash-profile-and-bashrc) now I know!). So I had to put the GOPATH in the go config.
Practice bite-size exercises in Go, and get valuable feedback: http://exercism.io/languages/go
This is definitely the problem OP is having. I made the same foolish mistake in some networking code a while back and it caused me no end of trouble. And by "no end" I mean "just a little, til I realized my mistake."
&gt;Last thing left is vim-go autocomplete... vim-plug vim-go YouCompleteMe and you're done. If you want YouCompleteMe to build automatically on PlugUpdate or PlugInstall, use this vim-plug instruction: Plug 'Valloric/YouCompleteMe', { 'do': './install.py --system-libclang --clang-completer --omnisharp-completer --gocode-completer --tern-completer' } Feel free to remove some of the command arguments if you don't need them. And I added --system-libclang because it worked better in Arch but that's optional.
Just a technical point... while the mutex does not in-and-of-itself prevent unsafe access to the variables "behind it", it's not quite true that a mutex is just an interesting variable, as is being hinted at... "In a modern computer there may be dozens of processors, each with its own local cache of the main memory. For efficiency, writes to memory are buffered within each processor and flushed out to main memory only when necessary. [...] Synchonization primitives like channel communications **and mutex operations** cause the processor to flush out and commit all its accumulated writes so that the effects of goroutine execution up to that point are guaranteed to be visible to goroutines running on other processors." -- Donovan &amp; Kernighan: *The Go Programming Language*, p267
Visual Studio Code has a great golang plugin. Simple to install and has a working debugger!
Its a complicated answer, but the short of it is that it isn't polling in the traditional sense. Every process is scheduled by the process scheduler in your kernel. Processes are scheduled by pretty complex algorithms, but its actually pretty sufficient to think of it as "iterate over list of all processes -&gt; if process is ready to do work -&gt; give process time to do work". In simple terms. The kernel is also aware of any mutexes it gives out. So one of the preconditions of "if process is ready to do work" would be "is another process holding a mutex that this process is waiting on". If yes -&gt; do not schedule. The reality is that none of this is really that true for Go, due to its greenthreading model. Goroutines are scheduled by the go runtime, not the kernel. Mutuex are, then, handed out by the go runtime, not the kernel. But the same basic concept applies; just replace "process" with "goroutine" and "kernel" with "go runtime". And realize that its probably a pretty complex combination of both go runtime mutexes and system mutexes if you have a go app that spans multiple processes. 
There has been a regression for users of zsh on OS X with the latest patch releases of Atom. I identified this and fixed it in https://github.com/atom/atom/pull/12396, but it has not yet been released in a subsequent patch release. This only affects users who launch Atom from Dock, Finder, or Spotlight rather than the terminal.
I was thinking more if it can replace C in the larger context. I guess this isn't an OS written in Go so it's a bit of a mute point though I feel as if the resemblance between Go and C is very strong and hope to some degree that Go will surpass and possibly replace C but to do that it needs a functional runtime at its core. It's an interesting problem but maybe not something worthwhile. The best argument for that I can think of is security. Since Go is a managed memory environment.
Can you tell me what you have found?
Looks like it has some convenience methods and/or increased expressiveness that the standard lib does not provide. And there is also some flexibility built in by being able to create custom "provider" objects to your liking. I am not sure if I ever need more than the std lib's log, but for people who want a different approach to logging this lib could be a good option.
thanks that clear up alot
You can use gorename instead of that sed expression.
[removed]
What is the use case of `goto` and `label` ? It look like a terrible idea to use
A1: The map `providers` must be Registered statically.Do it on purpose. A2: The `Write` method invoked in a channel: logger.writeQueue.
[Donald Knuth - Structured Programming with goto statements]( http://www.univasf.edu.br/~marcus.ramos/pc-2008-2/p261-knuth.pdf)
Rewrite [text/scanner/Scan](https://tip.golang.org/src/text/scanner/scanner.go?s=14320:14349#L528) and avoid goto.
I will still keep custom-based handler definitions as far as I am concerned. I prefer to see the context object apparent in the signature because the rule should be one context per goroutine and it's not visible with the way context is hidden within the request object. Too easy to share a context object across goroutines by mistake. A little feedback otherwise: your Chain type could have implemented the http.Handler interface.
I've never seen anybody recommend global maps over using context. Where is this mentioned? Regarding your last point, yes, I agree 100%.
Why was this voted down? It looks like a reasonable pattern.
Good question. It seems there's a handful of people here (at least) that like to downvote just about everything.
Maybe I am missing completely what you ask for but any slice has indices from 0 to len(slice)-1 so `i&lt;len(slice)` does what you ask for, is just a few keystrokes and very readable...
I did not downvote, but it may be due to the exceptionally annoying reversing of args in the handler functions. It bothers me. A lot. To be honest, I might downvote later.
Go rename can handle it all.
Those two things are not mutually exclusive.
You probably want [ReadAtLeast](https://golang.org/pkg/io/#ReadAtLeast) (combined with regular file opening, which is in the os package). Check out the whole io package for more things like this.
Thanks, I'll take a look on that.
Please don't. Use [io.ReadFull](http://godoc.org/io#ReadFull). [Short reads are allowed](https://golang.org/pkg/io/#Reader), so above code has a subtle bug that might only trigger on certain system configurations. It also has a not-so-subtle bug if your file size isn't a multiple of 4K. [edit] ~~The correct code is probably something like this~~ no it's not
Thanks, I understand now
Read can return an EOF with a partial read, so it should be something more like for { n, err := file.Read(buffer) if err != io.EOF { log.Fatal(err) // or something more appropriate... } // do something with the buffer up to the number of bytes read. Don't use anything past n because it might be scratch. fmt.Print(string(buffer[:n])) if err == io.EOF { break } } Also you can wrap the whole thing using bufio.
Yes. As the link in the docs explains, `io.Reader` is an interface, i.e. everything with a `Read(b []byte) (n int, err error)` method. [os.File](http://godoc.org/os#File) fulfills that criterion :) If any of this confuses you, I'd suggest starting with the go tour or some other introductory material to go :)
Yes, files are io.Readers.
Hey Gophers! Brooce is a language-agnostic job queue I made in Go. I built it because I like to work on personal projects in a variety of languages, and I want to be able to use the same job queue regardless of what language I'm writing in. I like a lot about Resque, but it has the same flaw as many others: you're all-but-forced to write jobs in its preferred language, Ruby. Therefore, I built a job queue system where the jobs themselves are just shell commands. It's really simple to get started: you just grab the brooce binary and run it on any Linux system. You then use redis to LPUSH some shell commands to a queue, and then brooce will run them in sequence. That's really all you need to know to use it, but there are some advanced features under the hood. There's a resque-inspired web interface, multi-threaded job execution, locking, and automatically scheduled cron-like jobs. All features are baked into a single binary that runs on any Linux platform, and can be deployed on an unlimited number of servers. If they can all access the same redis database, they'll all coordinate amongst themselves to work on jobs. I've been personally relying on brooce with great results! If you try it out, I would welcome your feedback! Check out the github page for the documentation: https://github.com/SergeyTsalkov/brooce
If you look at [io.Reader](https://golang.org/pkg/io/#Reader). A reader can read bytes and still return an EOF (think about what happens when you use a buffer length that is not a factor of the file size). This way if there is a stub of bytes at the end, it is still handled. That being said the os.File reader *does* only produce an EOF when everything has already been read and n is zero, but that won't extend to all readers. So kind of no, it isn't necessary, but it is a good habit to program against the reader interface rather than the os.File implementation I think.
It's hard to know what that snippet is trying to accomplish. The point is just that it isn't doing anything useful. If the goroutine needs access to mutex-protected resources, is should be locking/unlocking the mutex itself. The only way I could see this making any sense is if, instead, you had: mutex.Lock() slice := A() waitgroup.Add(len(slice)) for _, v := range slice { v := v go func() { B(v) waitgroup.Done() }() } waitgroup.Wait() mutex.Unlock() where, for some reason, the mutex needs to be held continuously for the call to `A` and all calls to `B`. The [`WaitGroup`](https://golang.org/pkg/sync/#WaitGroup) just ensures that all the goroutines are done before the lock is released.
Intellij has a free version, Community Edition, which is open source as well. Android Studio also works with the Go plugin. 
Ironic that my question was also downvoted...
So what is the advantge of this over vscode/intellij?
If you split the method into more appropriately sized chunks, goto wouldn't be necessary in the first place.
Reversing of args? What did I mess up?!
https://golang.org/pkg/net/http/#Handler The http.ResponseWriter parameter goes first. 
Sigh, updated. In my actual code it's the correct way around.
Great read! (But this is something I'm already familiar with.)
Go 1.7 is Go 1.7 RC6, no code changes. 😎
waiting for brew formula
Wow. You didn't lie. I just needed to wait a few minutes more to find out about it.
One reason I don't use IntelliJ for go development is I eradicated Java from my computers. But that's for personal reasons. Last time I tried go plugin for IntelliJ it did not support vendor environment variable and folder. I realize that it probably caught up on that but it was unusable at the time. Now I built my workflow around VS Code. It is hard to create a plugin for IntelliJ (one needs full JDK and experience in Java development). I can easily create plugins for VS Code and I used to write a lot of elisp (Emacs Lisp) in the past. So I consider VS Code and Emacs most developer-friendly for my case. But when it comes to editors and IDEs everyone picks their own religion. 
https://github.com/Homebrew/homebrew-core/pull/3921
I have reinstalled IntelliJ and set everything up again. Now it seems to work better. Still the debugging issue is present. The variables take ~1.5-2 seconds to load regardless in which view. I'll add some later infos when I am sober again. 
Been brewing for 3 hours now. Not ready yet :(
It's ready now!
If the rest of your toolchain is built around brew. And maybe some other reasons.
I think its pertinent to note that the article acknowledges that external dependencies are unavoidable. It simply suggests that 'some' 'mature' external dependencies (eg. gorilla or /x/*) are 'ok', where as other dependencies are not. Because Reasons. Unfortunately, you can't have you cake and eat it too. Either, you accept that dependencies are inevitable and support that, *or* you make dependencies persona-non-grata and require everyone depends on nothing but the standard library. What counts as a 'blessed' package which it is ok to use? How about amazon's S3 package? It's pretty rubbish... but, you kind of need it right? What about bolt? Is that an ok dependency? It's kind of commonly used, but it's not super popular... does it make the list? I mean, Spotify use it, so.. on the list yeah? Basically this sounds to me like poorly thought out push-back on the packaging story. Hi! We've been doing this for 5 years now and the maintainers have officially acknowledged the status quo is a no-go. Here's an idea: rather than 'no packaging!', how about you suggest a way *forward* that allows us to use dependencies in a common consistent manner *and* avoid the 'everything is a dependency' npm hell. Can you figure it out? I don't have a solution off the top of my head either, but I think we're now beyond the point where we can pretend there is 'no problem here'. 
Goto is much faster than defer statements. I use defer unless I'm writing a high performance library, then I'll use GOTOs
That's not the issue. A request may well be launching a task with a duration that outlasts a http request but the user may want to identify those longer tasks by keeping the info from the original request. You can copy it. Or part of it. But the context object needs to be different for soundness of the cancellation signalling. edit: and even if this is a task that doesn't outlast the request, you don't want to spawn a goroutine with the initial context but rather a sort of "sub" context. It is already confusing a few people, so I'd rather the distinction between request handling and context be made explicit. A request may spawn goroutines for handling. But a context is tied to a goroutine, not a request.
Thanks for all the hard work.
I like installing dev tools via Brew. Is there any reason not to use Brew to install the Go tools? Does it update well? I've found updating Go to be a bit of a pain and I could a package manager might not do it "properly".
Initial tests certainly show an anecdotal build time improvement on a few tests I've run, haven't compared the binary sizes yet. Nice release!
just do it
Any benefits to upgrading? Im using Ubuntu repo packages 1.6. Not sure if they get upgraded or back ported. 
One good reason is if you want to install delve (debugger) via Homebrew, since Homebrew's version of Go is a dependency.
One of the binaries I recompiled was 64% the size. Even after zipping the binaries, there was a noticeable half-a-MB difference. Pretty nice to see.
Saving 512k in the day where online storage is like $.02 / gig. Super important! Compile and execution times are huge wins though
IMO they are all big wins. Size isn't just about storage space, it's also about download times and bandwidth used.
Surely you can't be serious about this question given that you literally have the features of this release linked as the topic... 
Binary size or code size actually makes a performance difference to. Code bloat (large function bodies for comparatively small functions) are less efficient. It's all really good news. And given the track record of past releases I expect to see a small trend of further improvements being made on top of this release. Storage is cheap but you want your executable to be sitting in the L1 instruction cache. Which is somewhere between 32K and 64K on modern x86 CPUs...
Are you on LTS or 6 monthly cycle for Ubuntu? Go brings security fixes to current release -1 normally as well as current. You should be fine as long as you keep your version of 1.6 up to date.
&gt; A1: The map providers must be Registered statically.Do it on purpose. I don't know what `statically` means here, but your examples encourage me to call Register during my initialization meaning that even if I use your pkg correctly, there's still a risk if another package I depend on also decides to use it correctly.
The setup "trouble" for me is downloading the tar file, unpack, remove /usr/local/go and moving the unpacked version there. That's it. What do you mean you have repo packages installed? How do you install these said packages? If they contain the source code, then it's not a problem at all.
Damn it, here I was, thinking that we're talking about a beer recipe designer written in Go.
"Trouble" setting up Go 1.7: # Install Go on Linux. curl -L https://golang.org/dl/go1.7.linux-amd64.tar.gz | sudo tar zx -C /usr/local/ # Add to ~/.bash_profile. export GOPATH=$HOME/GoWork export PATH="$PATH:/usr/local/go/bin:$GOPATH/bin" gocd() { cd $(go list -f '{{.Dir}}' $1 | grep -v /vendor/); }
Shouldn't then delve formula be fixed to use system Go instead if available? (by system I meant existing one)
&gt; "One good test is worth a thousand expert opinions." &gt; &gt; (Wernher von Braun)
Without looking into the repo: Could it be possible that this change affects the output of "go version"? :D
The solution is just to write *all* your code in Go as a busy box so you only pay once for static linking. :-)
can confirm, up to 30% reduction in binary size when compiling 1.7 instead of 1.6
Hey, thanks to you too!
Then you need that info from the original request as key, not the request itself. Either way, once request is over the key based on it is orphaned and useless. Generate tokens, pass them in request/response roundtrip, key tasks on these tokens. Context is made for a very specific purpose stated in documentation. Yes, one needs to learn how to use it, which does not make it any less useful. It can also be repurposed. Go does not have ownership and borrowing model like Rust so copying objects might be leaky and dangerous. There are tools to troubleshoot that. 
Ugh, now to rework all my xhandler.HandlerC code back into http.Handler + req.Context(). I don't suppose anyone's written an automatic tool to do the transformations? Edit: [Found the other thread about that](https://www.reddit.com/r/golang/comments/4xzf9j/ctxfix_provides_rudimentary_rewriting_to_assist/). Excellent.
Available from Manning Publications https://yng.mn/learngolang.
I use LiteIDE because it's designed for Go, it is super FAST (Qt/C++ no Java/Node nonsense) and lightweight. It has support for autocomplete, goimports, gofmt, GOPATH management, multiple build configurations (including cross platform). It used to have a debugger support but I am not sure what's the story there ATM. I've tried Sublime Text but it was missing too many build management features compared to LiteIDE so I switched back.
Thanks for sharing, at the moment what I want to implement is a deduplication layer that sits between the application and the storage device (file system, object storage like s3. etc). So, what I'm trying to do is to split the files into small blocks, hash them and store only the new ones, seems easy but in practice is quite difficult. And I decided to write this in go just to learn a new language while doing something fun :) 
Wouldn't Rust be better for embedded systems? 
Yeah golang is a lot of fun. I am doing the same thing by creating a web app to get up to speed with the language. In my code I replace the string with a empty space. You could leave the string, but just return the slice of the file and format it to a object. Then you could store it in object storage. 
It's not even just an issue of library stability. It's entirely possible to write code which works with version x.y.z of a library, and find that because of bugs being fixed and new bugs being introduced your code suddenly fails with version x.y.z+1 of the same library. I've had this happen to me in Java. Fortunately I vendor my Java dependencies, so I just rolled back the build to use a previous version of the library jar until I could establish what the problem was, whose fault it was, and how to fix it. You absolutely need to vendor library dependencies in order to have reproducible builds on demand. And you need reproducible builds on demand if you're going to be able to turn around fixes to bugs in your own code on a reasonable timescale.
It's so easy! If only someone would create a script to automate it.... Why do manually what can be automated? I understand the reasoning to want to install things yourself: You get a better understanding of how it works and how it's set up, you know better how to troubleshoot and repair. But once you know that, why bother doing the work yourself? Let tools automate it when you can.
That wasn't what the person asked. They asked "does it update well" and the answer is yes. Of course there is some slight value to using Homebrew.
It's true that Go binary size is already small, but in general, small binary size is important when provisioning 1 app per container/VM
More anecdotal, but the [gonum](https://travis-ci.org/gonum) compile and test CI runs look about 10-30% faster. Nice work!
Does it have integrated debugging?
Faster? Nah. Many optimizations result in larger binaries. Size and performance are loosely related at best.
I meant that smaller binaries result in faster downloads
I am trying to learn go via the gopl.io book. It is pretty straigth forward and i learned a lot. Still it is kinda lacking some go to examples. What should i build now. Somehow the interest to fully understand pointers dropped, when i couldn find an application (i am capable to build) where i would use pointers. Are in this book more examples and exercises ?
Didn't Intel create the Xeon Phi for faster SSA execution? &lt;/s&gt;
I have seen your attitude in the Python community. "It makes no sense to me, thus it makes no sense at all", which is one of the reasons the language sucks. Don't bring that attitude here.
Actually, there are much faster dynamic template engines without Go gen exist - see [jet](https://github.com/CloudyKit/jet) as an example.
"Soon" (They're working on it.)
I thought I made it super clear when I said large for comparatively small amount of "something". C++ templates are a good example of this. Template instantiation can lead to a ridiculous code/binary size. Too much inlining will slow things down to. Like you said it's a complex problem. I only made the comment in reference to the size argument. Nothing more.
I don't use Intellij for Go, but use Intellij at my day job (java developer EWW I know, but it pays the bills). For Go I use Vim ( my own vim config of course ) and vim-go and I find that to be the most productive workflow possible for myself personally. Now that the obligatory learn VIM is out the way, InteliJ is great, especially if you like the less keyboard centric full featured IDE environment. It's very intuitive and the plugin support is the best of any IDE in my opinion apart from Visual Studio for c#, but that's a different beast. If you were to use an IDE I would hands down to InteliJ products for whatever I was doing, unless it was c#. VSCode isn't a full featured IDE, it's more like sublime text or Atom, and slower than both of them, but the Plugins are quite solid. Really it boils down to personal choice, but you can't go wrong with a good Vim workflow, it's painful for a month, but after that you won't want to work any other way. 
C++ templates are actually the opposite example you are trying to make. The reason C++ templates explodes things is because it is making new functions for every type. While compilation time goes up, runtime goes way down doing this. This is because the compiler doesn't have to insert type checks and conversions into the runtime. Further, templates allow the compiler to avoid things like virtual tables and can result in some of the specific methods getting smaller in some cases. CPU instruction caches are smart. They aren't just blindly loading blobs of code that is near the instruction pointer, they are loading up code based on the call sites in the current method and the instruction pointer. Data caches have to be a little dumber because it is very hard for them to know exactly where in data the program is going to next. However, where the instructions are going next (or could go next) fall out pretty naturally. It is a problem that already has to be solved for branch prediction.
You are intentionally trying to misunderstand me.
What am I misunderstanding? &gt; Binary size or code size actually makes a performance difference to. You are saying that code and binary size is correlated with performance. I'm not sure I agree with this. &gt; Code bloat (large function bodies for comparatively small functions) are less efficient. Here you are saying that if you have a large function and a small function doing the same thing, the large function will be slower. Correct? If so, then that is not true. Look at inlining and loop unrolling as counter examples. &gt; Storage is cheap but you want your executable to be sitting in the L1 instruction cache. Which is somewhere between 32K and 64K on modern x86 CPUs... Here you are saying your entire executable should fit in L1 cache. Again, not true. Having an executable that is larger than L1 cache and one that is smaller than L1 cache won't have major impacts on performance because the CPU is going to work hard to make sure L1 is populated with instructions that are relevant to the current execution. There is little to no benefit in shooting for small executable size. Especially since the CPU instruction caches are really pretty smart. For an application that is 1mb vs 20kb in size doing the same thing, there will be no real performance difference due to the size difference. &gt; I thought I made it super clear when I said large for comparatively small amount of "something". C++ templates are a good example of this. Template instantiation can lead to a ridiculous code/binary size. You are trying to make the point that templates will increase the size of the executable which will ultimately harm performance. That is nonsense. I don't misunderstand you, you are simply wrong. Executable size has nothing to do with execution performance. End of story. Further, Templates don't result in larger functions (which is what you imply). Rather, they result in lots of small functions. What am I misunderstanding?
I agree. If generics were added this would be so trivial.
That's the GIF I was looking for!!
The part that makes me wonder is where he talks about implementation. &gt;For speed, this would not be purely reflect-based (except for one call to to get the slice length). The implementation would generate a custom swapper as needed for the type of the slice elements such that it's compatible with the GC &amp; write barriers. I have no idea what this really means. Is he using reflect to make a custom function at runtime? Is he using some kind of voodoo that is not available to the rest of us with assembly or runtime internals or something? Is this another instance of "we can do generics, but you can't"? 
&gt; what's the point of a compiler if you need another one to actually compile your program? You only need go gen to _update_ the program. It is not needed for compilation. For sorting, the interface is fixed by the sort package, it is ok (not perfect). 
Currently it has only string type support but looking forward to expanding it to other primitive types (int, int32, uint, float32, etc) which should be pretty easy. Would love feedback on the API and if you feel this pattern would make validating data in your structs easier. 
Just remember who suggested you play around with Vulkan a bit when you were testing your C binding generator. ;-)
Why
Nope, you're right. I didn't expect that people were using Go in embedded and ship-to-customer packages. Thats my bad
Who was it?
Mmhmm! That post should be tagged as NSFW for gophers.
i can't agree more. This post is more for my curiosity than anything else. 
First, get comfortable with the language. How can you tell others they should use it if even you don't fully understand its nuances? Second, understand the alternative languages your team might be looking in to. Be prepared to define the advantages (and disadvantages) of using Go. Third, go through your software requirements/criteria and figure out where Go fits in here. This goes back to my first point - you need to know how the language operates and what its strengths are. Also - whats the pre-existing stack your team already develops? Wouldn't make since to jump for Go if everything else is C# WCF. Lastly... Software Engineering is allllll about reusability and teamwork. If you're only adopting Go for one tiny piece and only a few people are working on it, chances are it'll get tossed out down the road and re-written in the preffered languahe of your team/company. They don't know the language, so it comes down to either A) do I learn this language JUST to maintain this small service or B) do i just go with what I know and am most comfortable with? Hope this helps a little.
That sounds about reasonable. The PHP7 code is fully interpreted while Go only needs to interprete and reflect on the template code, which should slow it down a bit but the rest gives it sufficient boost over PHP.
/u/bradfitz that's pretty much the reason why I use your library slice
i would be interested in seeing some of them.
Hi, thanks for the feedback, seems interesting the approach of having a constant that way I could avoid the use of type casting but can't fully understand it, could you please elaborate more, for example how to populate the map and reset the constant for all new request, and also how to retrieve the map in the handler side. 
I mentioned you in the announce on golang-nuts. Also you haven't checked your skype ;)
It's a binding generator, I'm going to open source it as soon as documentation would be ready. Both android ndk and vulkan bindings spoiled many bugs. If I released it too early, I'd be very ashamed. By the way, you don't need to run Makefile in order to use that package.
Interesting, I've had totally the opposite community experience, but that could be just this sub. I can see how Pythonistas would object to your attitude if you call Python a "toy" though. It's ome of the most important "toys" outbthere if you consider machine learning, text mining, data science, not to mention its incredible role in encouraging new programmers. Calling it a "toy" sounds like sour grapes, TBH.
Looks awesome. Take your time on the windows version because my MD would have us stealth install it for every user...
Your gripes are pretty close to mine. 1. Dogshit when it comes to concurrency or parallelism. Emphasizes higher-level constructs such as multiprocessing, but end up using os.fork() and some form of low-level IPC because it's faster and circumvents the fragile interfaces. 2. Syntax appears nice but doesn't really add much value. 3. C bindings can make things extremely fast, but good luck making the code multithreaded/reentrant. 4. Python 3 breaks everything. 5. Python stdlib is shit. I find myself replacing lots of "batteries included" modules with 3rd party versions that suck less. 6. Python advocates a coding standard but rarely in the stdlib do you see any adherence. There's probably more gripes, but those come off the top of my head.
It requires more precisely an additional type qualification. Besides being comparable, types need to be orderable. And that's for the primitives types. For more complex (composite) types, there will be different ordering possibilities. (multiple relations of order) It would require some changes to go/types.
&gt; Also, who does go build not automatically include generate... Because that would a) destroy the compile-time benefits, as now everyone would do arbitrarily complicated things during compile time and b) means that everyone who wants to build stuff now needs all the tools needed to generate things, which will lead to the whole build-dependency-hell you have in other languages.
&gt; what's the point of a compiler if you need another one to actually compile your program ? But, with go generate, you don't. go generate is supposed to be run at commit-time, not compile-time. i.e. on a fresh checkout, go generate should be a nop. &gt; I just can't understand how in the world people would think Go generate is a good idea. Code generation in the vein of go generate is used in all languages I can think of (for example, you don't actually *write* C bindings anymore, you generate them). go generate just works around the lack of Makefiles and the need for compile-time dependencies and duplication of work, by embedding the necessary instructions into the source code instead and running the code generation at commit-time. I agree that go generate is a very bad substitute for generics, but it is a very good idea to exist and be used as it's supposed to.
Just do it!
I was assuming the function you pass in must accept a member of the slice you give, and return some number of "primitive" types. If you don't return things it knows how to sort, it wouldn't work.
Both Python and Go were far easier for me to learn than what I spend my workday doing (C# and all its massive frameworks), and it isn't hard for me to find time to hobby around in both. Both have such a different feel that it's very hard to compare. If you look at only one type of application, you might be able to compare a little... For parsing through a lot of text and optionally transforming it, I find Python to be a favorite. For web apps there are great reasons to use either one. I would probably use Go for something with a higher need for accuracy and robustness. I'd probably use Flask in Python for a web app that has under a thousand lines of code and isn't mission critical. For mobile, I'd probably want to use Python's Kivy. For your other list of "typical backends" it probably doesn't really matter much. If you were to do build tools, maintenance scripts, and admin consoles in Python while making the core apps in Go, you might have a nice sweet spot, but overall the choice you make won't make or break you. :) Good luck and have fun!
This is totally correct. The only other option is to do what my most senior peer did after the fact: "So today I'm demoing this application I wrote in F#." Now, we're a .NET shop on one hand, but on the other hand, F# is more uncommon than Go. If you aren't the most senior person around, you might not do so well with the "just do it!" approach.
Looks like you should fill an issue for `forin` case. It is clear degradation. On other hand, `forin` is absolutely meaningless, cause it does not change content of `bodies` . Still, response from go-authors is desirable.
In the thread linked he mentions that his library isn't meant to be used for the 1.5+ GC. Not sure why because I'm not a Bradfitz myself, but I'm sure it's something important.
Well done, Go team, well done... After the six years of fighting against common sense, we are slowly heading towards generics.
I like to embed the mutex directly into the struct. For the example from the blog post: type Processor struct { sync.Mutex sum int } // so you can do: p.Lock() defer p.Unlock() 
&gt;go's type system offers me a ton more flexibility and I don't have to fight the type system as much to make the compiler happy explain?
Because nothing in go is "private"/"public", it's "unexported"/"exported". It might seem like an unimportant difference but this is exactly why. What is the use case? One use case is to only expose a Smart Constructor that doesn't let you create a struct with meaningless or uninitialized values. But it is frowned upon by tools like golint
I like this too as long as it applies to all fields of the struct.
Oh dude! I haven't logged on skype in ages. I'll log in to I can catch up with you.
No. Structure on stack is mutable. And it is same variable in all iterations (cause of language specification). No need to allocate anything on heap. It is clear regression despite test is meaningless.
do you mean `--benchmem`? its `0 B/op` and `0 allocs/op`
Thanks for the feedback. I am plan to work on it a bit more this weekend. 
See [encoding/binary](https://godoc.org/encoding/binary#pkg-variables) for an example of how exposing unexported types can be useful.
That unexported type could satisfy a visible interface.
I've always found Go's type system one of its major weaknesses (ad hoc syntax and lack of generics (of course) being the main offenders).
work with Java/C# for 5 years, then switch to go. No explaining required.
I don't know how you reached these conclusions. - Python community is one of the most helpful around. - Python 3.5 is gaining good traction and a lot of important projects have expressed support for only Python3. - Concurrency is not the only thing you do when you write a webservice and with improvements in async it's not that bad either. - High performance applications? I guess you are unaware that many high performance apps (instagram, pinterest etc.) are written on Python. The thing is if you write shit code in any language performance will suffer. Mostly the bottleneck is the person is himself. - Python Index has many useful libraries and mostly very high quality. - Virtual environments are great running applications with different dependencies. Let me know how could you isolate different version of golang on same machine in a saner way that is not overly complex. - Not sure if you know, type hints have also made it's way to Python-3.5.2 and also available to Python2 via typings modules. It does add great support for writing more type correct code. It also makes IDE integration much better and refactoring easy. - Metaclasses are great and so are interfaces but if you abuse then you are going to bite dust. - I have personally written high traffic API that has been running pretty nicely and scaling as we grow. It totally depends upon how your architecture is, how your DB queries are. If you are writing Pythonic code which is performant or not. Just because you didn't wrote it well enough doesn't mean it is not possible to write good performing APIs in Python. Golang is good language and has it own strengths and use cases where it shines. So when you criticize a language, give good solid reasons not some biased bullshit that has no base. 
I would suggest that you learn both of them. Python is one of the most used languages around and it is going to stick for a long time. Great thing about Go is that it has excellent tooling and it is not that difficult to learn the language in very less time. Go and Python advocates different philosophy. Go has excellent stdlib, so you won't find much high quality frameworks here but people make excellent application using just stdlib. But when you are under time pressure and you want to avoid boilerplates, you might want to use Python(maybe Django, Flask) under that circumstance. You might need to understand that with both languages there are certain tradeoffs(more boilerplating with Go, sometimes too much ORM magic with Python[Django]), and need to figure out which one you should choose. So if I were you, if a project is big enough I would select Python, maybe create different services in Python using flask/Django and then see if I could replace one of the service using Go(something that requires high and easy concurrency). But in order to reach that state, you really need to reach that scale and that many users and it is a good problem to solve. So keep an open mind, try to get to bottom of the problem and select the right tool for the job. No language in the world automagically solves all your problems.
If you want to convince your team, maybe you need to show them a POC written in Go. Maybe right the same POC in your current language and in Go and show them the numbers. If will also help you get a better grab of the language and understand Go's strength and weakness. Writing a service in Go is not going to make it faster and better on it's own but architecting it correctly and using Go strength to your advantage will. So figure out where Go might help you with that.
Yes, you're definitely right. Not sure why I decided to link ReadAtLeast...
What is wrong with the default error handling?
The fact that this happily runs arbitrary commands scares me. You can replace this with `runtime.Goexit`: https://github.com/SergeyTsalkov/brooce/blob/aaf4db907c48396075099ddca1da647d446be3cd/src/brooce/brooce.go#L87 Doesn't look go gettable: https://github.com/SergeyTsalkov/brooce/blob/aaf4db907c48396075099ddca1da647d446be3cd/src/brooce/redis/redis.go#L8
Take a quick look at how [(context.Context).Value() works](https://github.com/golang/go/blob/master/src/context/context.go#L468). It's not using a hash map, it uses an iterative key-value comparison. That means that it's slow for more than a small number of keys. Instead, you should store request-scoped data in another structure within the context. For example: params := r.Context().Value(violetear.ParamsKey) uuid, foo, bar := params["uuid"], params["foo"], params["bar"] What is the ParamsKey? Another thing about storing data in a context is that you want to be really sure that your key never collides with anyone else's key. If you use a string, it might collide, even if you think it's unlikely ("violetear__private__ParamsKey__super_secret"). Instead, use a private type, like this: type key int const ParamsKey key = 0 (see https://blog.golang.org/context for more info) To initialize the parameters in the router's request handler, you'd do something like this: params := map[string]string{} ...fill in params... r = r.WithContext(context.WithValue(r.Context(), ParamsKey, params))
Why would you start a new cgo Kafka client, when the excellent, mature, and pure-Go [Shopify/sarama](https://github.com/Shopify/sarama) client exists?
The manual pages for Context explicitly talk about not using the context to store data like that.
I experience what's reported here: https://www.spotxchange.com/resources/blog/product-pulse/productpulse-why-we-must-move-past-cookies-on-mobile/ "Persistent cookies on the other hand remain in a user’s browser until the cookie expires or the user deletes the cookie. Mobile cookies, however, fail to persist and are deleted whenever a user shuts down the operation of their mobile browser or restarts, shuts down or switches their mobile device." Every time I open the browser app I have to login with Oauth again. Is there a way to circumvent that and persist the session until it's expiration date or logout?
thanks
librdkafka is a lot more performant compared to the pure go library.
Are you sure it's not a joke?
`defer` is expensive. It should be used only if operation under lock is more expensive, or if logic too tangled to maintain every place for `Unlock`.
Yes sorry, I updated it
I will safely put both in my group of main languages for the coming years. To me choice of language(s) should be made on a per project requiremetns basis.
I agree. Go's simple type system gets 80% cases working perfectly. 20% complicated cases including generics is not a hard problem with go generate.
Don't. Write by yourself a smaller tool. Make it work and then people will see the benefits of it... Having said that you need to be really comfortable. This is the way I did it 
The new GC is allowed to move values around in memory in order to prevent fragmentation. Extra care needs to be taken to ensure that memory addresses are never stored in non-pointer form and then converted back into pointers, since this can prevent the runtime from keeping the address up-to-date if the GC moves the backing value. The new rules are detailed in the documentation for [`unsafe.Pointer`](https://golang.org/pkg/unsafe/#Pointer).
Go is my current primary language but I really don't enjoy the community (sorry ya'll). People cargo cult Rob Pike way too hard and I think it's made the community closed-minded. I sort of get it: Go is great because of its stdlib; the stdlib is good because it's consistent, opinionated, and, well, *good*. It sets the standard for how people should write go libraries. The result is that the community at large adopts these standards, and eventually you end up with an ecosystem of very predictable libraries and interfaces (similar to OTP (erlang)). So, it's in the communities best interest to defend that philosophy. But at the same time, people are so goddamn hostile to anything that dares deviate away from the gospel. Oh, your error handling is just a little too clever? Bad. Tried writing map in go? Bad. Your library is actually complicated? Bad. *Syntax highlighting?* Bad! Seriously, the guy who got me into go no longer uses syntax highlighting. 
What's wrong with the Cheney guy? Just curious.
Pretty sure your tags are just wrong. type Rss2 struct { XMLName xml.Name `xml:"rss"` Version string `xml:"version,attr"` XmlnsContent string `xml:"xmlns:content,attr"` XmlnsAtom string `xml:"xmlns:atom,attr"` Title string `xml:"channel&gt;title"` }
Yeah, We already use Sarama. We even built go libs for Schema Registry and Kafka-Rest-Proxy(should be open source soon). I was looking at confluent repo for some kafka-stream stuff and saw this. So shared, but yeah cgo (shrug).
Does librdkafka support consumer groups?
I'm sorry the Go community has stockholm syndrome and must downvote opinions they disagree with.
[That is brilliant!](https://play.golang.org/p/sbSA1ZdZUh) Thank you! You don't know how much pain xmlns reproduction has caused me. I never thought about using `:` in the tags because they differ in marshaling and un-marshaling.
As an aside, you can press Cmd-K Cmd-I to trigger the hover tooltip by keyboard in VSCode. There is also Cmd-Shift-Space to trigger the parameter hints. Hopefully it will help you see the documentation quicker.
Seems way too verbose with no considerable upsides
The `_` is prepended by [this code](https://github.com/golang/go/blob/master/src/encoding/xml/marshal.go#L341-L344) which checks if your prefix starts with xml. 
I think I wrote this on mobile very late and possibly sounded a bit more harsh than I had intended. Regarding the community experience, I find that Python has reached a critical mass where bureaucracy takes hold. I think it's just different personality types between the communities. I deeply admire the Go communities ability to cut through the human component and focus on very low level problems. Conversely, I find the python community to be very SJW. The last time I was looking for help on freenode, I found out that they have a bot who's purpose is to harass you in msg if you type 'lol'. Apparently, the string 'lol' in any context is somehow in opposition to their code of conduct. I've never been reprimanded for appending 'lol' to an on topic sentence. Perhaps 'toy' has a negative connotation. I personally didn't mean it to sound so harsh. The reality is Python has emerged as a leader for 'scientific' computing. This doesn't make it the most suitable language for solving computationally complex problems. It makes it the most suitable for becoming involved in data science. Python has an amazing ability to lower the barrier of entry for programmers of all skill levels working in areas that are new to them. RE: community, what I find truly important about engineering; Go suits me very well. Perhaps I've had great interactions in the Go community because the folks I've interacted with are like minded. RE: Toy. Harsh language, probably not the best choice. Go is undeniably more performant than python for a variety of work loads. Python has very different strengths than Go. 
What's your role in the team? If you have some form of senior role, maybe you can take the same approach I did. "We're doing this in Go." I had joined a new team and was still fairly new to Go. The team had never used it and Java was the 99.9% language of choice. I had push back but my mindset was "they'll get over it. If they were coding it they could choose whatever language they want." We have 4 day sprints, I worked with a (new) jr dev, designed the contract, and coded up a few endpoints. We were using 1/10th system resources and -- worst case -- if it had to be redone it would only take another sprint. Fast forward a year and most of our back end development is now in Go. Pairing really helped get others on board and keeping the contracts well defined makes it so if we all quit tomorrow a new team could rewrite them in their preferred language in a short span. Middle management doesn't worry too much about that level of risk and I've found it far more maintainable than my previous preference (node).
Possibly the most ridiculous "helper" function I've seen in this sub
I tried and it ran into the same issue
I don't want to repeat myself but I did a more direct reply a few comments up. TL/DR; I basically just mashed the keyboard late on a mobile and my reply perhaps reads more harshly than my intent. It was not my intention to upset a bunch of people. - My interactions with the Python community have been largely stifled by community guidelines that I find overbearing. The keyword 'lol' is a forbidden word in python support channels. Freenode has a bot dedicated to harassing you each time you use the word 'lol'. I don't find censorship and control of free speach helpful in any way. - Python 3 is not gaining good traction. I think you may be overlooking the fact that it was released 8 years ago. Go 1.7 has been out for 2 days and there are companies who have been running it in production for months already. Further, as of today, I've upgraded my companies code base to Go 1.7. Number of lines changed in order to upgrade? 0! In my adventures as an engineer, these types of facts are critical to making sound technical decisions. - Concurrency is the ONLY thing you do when you write a webservice. Before the request flow reaches you the developers handlers, you are going through a great deal of concurrency oriented code. In any language, especially python, the form/function/speed of your controllers is inconsequential if it is bottle necked by the upstreams ability to handle socket IO. If you bench mark a Go app against any python app fronted by gunicorn, uwsgi, tornado, or raw gevent; Go will win every time (I'm guessing uwsgi is the only contender). This type of assertion holds true throughout the entire request cycle. There is a large degree of complexity in Python applications around non-blocking IO for things like DB drivers to service web requests. Simply put, the fact that the time to market is quicker with python due to it's syntax, does not make it superior to more modern languages. It just makes it different. - Instagram, pinterest etc have become polyglot's in recent years. I find that Instagram is a particular point of pride for the Python community. Undeniably, Instagram serves a lot of traffic; but there is actually very little computation complexity in Instagram outside of image processing and database IO. You are confusing their massive horizontal scale with programatic speed. Conversely there are a litany of public companies like Iron IO, that are able to perform extremely computationally expensive operations at scale in a fraction of the infrastructure footprint of Instagram. Whats further, many of the things Instagram has pioneered are now not really considered normal or best practices. A very good example of this is Instagrams old blog posts describing their implementation of 'RedisHash' to make their caching layers more efficient. Today, this is pretty uncommon. IMHO, Instagram contributed much more to the startup community with the way they implemented data sharding within postgresql. At the time, the only company we knew of that was operating this way at scale was Facebook and Youtube. - Python index suffered a catastrophic outage 2 nights ago. It is a critical point of failure for the entire ecosystem. Further, the python index suffers from a high degree of code rott. Sure, theres great modules there! Thats not up for debate at all. But it suffers from a myriad of issues from naming conflicts to dependency resolution challenges. The ironic thing to me has always been that the truly excellent modules in the python ecosystem are little more than C FFI's. Please evaluate your requirements.txt file very carefully. Speaking to a cassandra DB? Blist, a C module is recommended. Want to operate on data frames easily? You guessed it, low level language under the hood. I hope this reminds many interpreted language developers that *we* are all standing on the shoulders of giants. - Virtual environments are an absolute nightmare. Virtual environments have an extreme burden on portability and build time. They are error prone, and they rely on a lot of dirty mechanics under the hood like stripping bang lines from entry_point's and replacing them with the virtualenv's interpreter. For a code base the size of instagram or pinterest, the deploy time footprint is likely in the neighborhood of half a gig. Instead of having one artifact to deploy, you now have hundreds or thousands. Virtualenv is not a convenience it is a necessity. It was a band aid to painful dependency management, and a band aid to include path collisions for systems rendered unusable when python 2 and python3 are installed in tandem. Yum and apparmor suffer from a LOT of bugs due to these issues. Further, there are literally hundreds of attempts to solve these problems. The only mildly successful one is pex. The rest is a cludge. Check out dh-virtualenv if you ever want to regret liking virtualenvs. As a last point, think about a code base implemented as a series of microservices. What happens when their requirements deviate? You'll likely say switch between virtualenv's etc. Cool! Now multiply the development team by 20 and bugs emerge because of the logistical complexity associated with virtualenvs. To answer your clearly sarcastic question about equivalent behavior in Go, the answer is to repoint $GOPATH to the directory containing the version you'd like. For comparison, virtualenv is manipulating several more env vars (including PS1... wtf), AND rewriting pieces of pythons site config to play nicely. Why does it do this? The C api behind python is complex and inconsistent. - Type hints are not the same as static typing. This counter point is nonsense. Under the hood, the way python types are implemented are somewhat flawed IMHO. Overall I think this typing module will have a very positive impact on the python community, if anything just to make developers more aware of types. Side note, there is a very long list of python type hacks out there. Things you can do to trick the interpreter into doing what you want. I've come to view these hacks as a waste of time. If the language allows you to express a type, you become more productive because you stop spending a bunch of time validating inputs. - Metaclasses are interesting. Granted they are capable of strange and interesting things, their practical use is usually around implementing interfaces. Go has accomplished this in a much more straight forward way. - Congratulations on your successful API. I'm willing to bet we have VERY different ideas of what constitutes high traffic. If you feel that my responses are unfair or inaccurate, I'd love for you to send me some raw stack frames from sys.signal and I'll gladly produce a flame graph we can review together. What you will find is your high traffic python API is likely spending a lot of time on CPU doing things that are seemingly innocent in python. For example, use of deep clone is rampant in python web code. What occurs is extreme waste of resources. 
&gt;degradation I think regression is a more common term
&gt;a very simple benchmark that shows difference between go 1.6 and 1.7 *Prints version number* ^^^^^/s
I mean.. it must be, right? 
Use of recover is a really bad practice. It should be avoided at any price, unless it is really unavoidable. But you are right. I'm telling, that use of defer should be justified. There is no point to use defer for Unlock if you increment counter, append to slice or assign value to slice/map element. `defer` should not be used just because it is cool thing, cause it has its runtime penalty. For comparison: @finally in Objective-C and destructors in C++ has no runtime penalty if no exception were raised.
The main downside of a JWT is that it cannot easily be revoked. If the users have te able to control (view or revoke) active sessions, it's much easier to use an accees token persisted in the database, which is verified per request. Then it's simply a matter of marking the token in db as revoked.
&gt; `resp, err := http.NewRequest("GET", url, nil)` Following [the best practices](https://github.com/Droogans/unmaintainable-code)? I fail to see how user agent is responsible for this. The only explanation that comes to mind is what u/afhtech said. Are you invoking the program repeatedly? What it says if you open https://reddit.com/r/golang/top.json in a browser?
Lol this has to be a fucking troll. The exact opposite is true of almost every piece of bullshit you just spewed
&gt; Golang authors confessed auto recover in net/http were mistake. I think you might be ignoring the reasons why *they* think it was a mistake.
No.
idk, something like `shortcircuit err` would be pretty cool but only if it is available in the language directly. Not as a third party library.
1. Very often you want to do something specific with the error rather than just returning it. Logging is one case that lib seems to have taken into consideration, but there are others. Maybe you retry, or use a default value, or whatever. Errors as values are extremely useful. 2. The library you link is a bit dangerous. The method is called "**Return**IfErrorNotNil", but in fact it uses a panic/recover mechanism to do that. Forget to put the defer in? Crashed program. Have other defers in your function? Now ordering matters. What is the performance hit in every single method now of using this way? 3. I understand sort of where you are coming from if there was a language feature or keyword to shortcut this. Problem is it would still need return values for each of the returns. The (x,y,error) pattern is really more of a convention than a language rule. How does the compiler know what your return values mean? It may be able to substitute in empty values for all but the last error return, but again, what if you want to return partial results **and** the error? It is hard to settle on an acceptable default in this case, so the "magic" shortcut still takes almost all of the explicit attention that the original way does. 4. Who the hell thinks it is a good idea to use a font that turns `!=` into `≠`? 5. Go has typically stayed away from "sugar" features, that add no value other than slightly more compact code. I like it that way. Yes, the if statement takes 3 lines. Those are 3 lines I can type automatically, and which my brain parses immediately and without thought when reading other people's code. This deferred panic recovery nonsense is not simple or intuitive.
i was thinking that too, a keyword like defer that monitors variables (a feature of the parser)... ^but ^thats ^a ^macro defererror(@err, @anothererrvar) (error e) { return _, e } v,err := foo() val,anothererrvar := bar() return val*v
It's hard to argue against any of your points. I wouldn't use this package. But I do feel that there is a need for the language to help replace the most commonly used error handlers with some sort of a shorthand. It'd make reading code (not writing) must easier. Edit: I can't stress enough that this needs to be a language construct, a standard and not a third party package. 
I didn't know that Go had macros. I'll have to look into that
Lots of people agree with you, most of the community disagrees. As I'm putting it: it's not go's error handling that's hard, it's just error handling, that's hard. go's solution is far from perfect, but it's much closer ~~to~~ *than* other approaches I know of (like exceptions or errno).
I'd argue that a try-catch block is better than Go's error handling. With a try-catch, you can see all the errors that the function expects and how they are handled. When reading the body of the try-catch block, you can focus on what the code is actually doing in the happy path. The disadvantage of try-catch is that if a function is too large then it becomes hard to determine the source of the exception just by glancing at the code. However, if a function is small (as almost every language suggests they should be) then a try-catch just makes it more readable.
Fortunately, `if err != nil { return err }` will not survive a call to `go fmt` as a one-liner.
It doesn't.
1. `if err != nil` is perfect for these cases 2. agreed that this is an issue 3. agreed that this is not a simple issue 4. It's just some visual sugar in the editor. Why judge that? :) 5. It wouldn't hurt to have some sugar for something as widely prevalent as: ``` if err != nil { return err } ```
&gt; Golang authors confessed auto recover in net/http were mistake. Yes, but I'm pretty sure that's because the library's user should be doing that, not the library itself. It's a little inconsistent for it to secretly recover panics. I never mentioned auto-recover. &gt; If you use things just because they are cool, you are User. If you use things cause they compose to right thing, you are Composer. I have no idea what this is supposed to mean, or what it has to do with this conversation.
I think something like Swift's try expression would be very very nice, and basically achieves what you want. Unlike Swift, I don't think any of the other error management mechanisms it uses are necessary or desirable in Go. [Here's](https://gist.github.com/alecthomas/73172a9d50889836a0ce) a (real world) example. And here's your example converted: try b.WriteByte('{') try b.WriteString("\"path\":") { s := match.Path try b.Write(try json.Marshal(s)) } try b.WriteByte(',') It also improves Go's support for function composition, which its error handling typically make quite difficult. The logic of the `try` operator is that if the last return value of the function call on the right-hand-side is a non-nil error, it will be returned as the error of the current function. If there is no error, all other return values will replace the result (you can see that in the use of `json.Marshal()` above.
&gt; I'd argue that a try-catch block is better than Go's error handling. With a try-catch, you can see all the errors that the function expects and how they are handled. When reading the body of the try-catch block, you can focus on what the code is actually doing in the happy path. I disagree. A try-catch block is completely equivalent to an if-block. But the real issue is, that exceptions tend to *not* be caught, which obscures the control flow. And if you mistakenly not handle an exception, your program just crashes, which is *really* frustrating (I recently had an occasion where a java data processing job crashed after running for a week because some second-party-code threw an unchecked exception. That's just… no). If you catch all of them, however, you degenerate to explicit error checking. Basically, what is touted as the advantage of exceptions (i.e. you don't have to handle them explicitly) is everything that is *horrific* about them. Anyway, my first point still stands. There are many arguments to be made for or against exceptions and all of them have been made, multiple times. There isn't really any hope that one side is going to convince the other at this point, so I don't really see any value in discussing it further. Just accept that go doesn't have them and try to live with it, or move on.
This is quite nifty!
Your code hasn't logged into reddit. type RedditResponse struct { Json struct { Errors [][]string Data struct { Modhash string Url string Id string Name string } } } .... loginURL := fmt.Sprintf("%sapi/login/%s", s.rootURL, username) data := url.Values{ "user": {username}, "passwd": {password}, "api_type": {"json"}, } request, err := http.NewRequest("POST", loginURL, bytes.NewBufferString(data.Encode())) if err != nil { return fmt.Errorf("Failed to create a request. err %s\n", err) } request.Header.Set("User-Agent", s.defaultUserAgent) response, err := http.DefaultClient.Do(request) if err != nil { return fmt.Errorf("Failed to get the response. %s\n", err) } defer response.Body.Close() if response.StatusCode != http.StatusOK { return fmt.Errorf("Failed to get the login response: %v\n", response.Status) } redditResponse := &amp;RedditResponse{} err = json.NewDecoder(response.Body).Decode(redditResponse) if err != nil { respbytes, _ := ioutil.ReadAll(response.Body) return fmt.Errorf("Failed to decode the json. err %s. '%v'\n", err, string(respbytes)) }
&gt; it's also a fact that I could retire and live a leisurely life if I had a penny for every time I saw if err != nil { return err } The article claims otherwise: &gt; We recently scanned all the open source projects we could find and discovered that this snippet occurs only once per page or two, less often than some would have you believe. Yet I decided to do some quick research myself because you could be right. So: What percentage of the Go source (1.7) is `if err != nil {` VS what percentage of the Java source (JDK8) is `} catch`? Results: * Java: 0.725% * Go: 0.620% As you can see the numbers disagree with your perception.
I think your metric isn't fair. You should grep for `if .*err != nil {` or something like that (to catch the case of `if err := Foo(); err != nil {`)
It depends how young - my two (under 10) like Minecraft, and python is the go to language there. They are still learning scratch because of the immediacy there. Teens I would say use Go with them as they will probably already have the basics down.
IMHO, Go would be a great first language to learn with, as long as you start them off with just the basic features; leave goroutines and sending-values-by-reference for when they are already comfortable with the rest of the language.
This is interesting. Can you share details of the code that you checked this against? My perception is based on reading code of various packages that I use (self written and external) and I'd be keen to know if this is a misplaced perception.
The people in this thread saying "errors are just values, so there shouldn't be convenience features" are just wrong. Errors as values is a great thing, but that has no bearing on whether or not common patterns should be reduced. Take a look at Rust's error handling for error values done right. Go just doesn't have DRY as one of its principles, and for some reason the community chooses to uphold language decisions as dogma rather than being critical. For example if you complain about lack of generics you'll be told "it's not that hard to rewrite a data structure every time you need it", or "just use interface {}, it's not like you're using this language because it's statically typed" Go is a pretty good language that does some things well, but I've given up on hoping for any sort of ergonomics or for the community to push the language to be better. 
Yes, the Go community is very resistant to change. If you want new language features, Go will disappoint you. The flipside of that is that Go won't change underneath you. I have been a Pythonista for something like ten years, and I think many of the recent changes (`async def`, yet another string formatter, ugh) have been for the worse. With Go, I don't have to worry that they're going to add some terrible misfeature when I'm not paying attention.
Say "gophercon videos" one more time. I dare you. I double dare you.
I've seen comments like these a few times, but never explaining why. What's the problem with cgo?
&gt; I would use Ruby Why?
It wasn't when OP posted this.
This is really a problem that I see quite often in the code that I read. At least I think I do. I'm doing a quick check against the trending Go repos in Github to see if what I perceive is really a problem. I'll post my results here if you're interested in knowing them. **Edit:** Results from a quick grep on the go files in the docker repo. - 9071 instances of `if err != nil` - 1864 (roughly 20%) instances are `if err != nil { return err }` - 3593 (roughly 40%) instances are like `if err != nil { return (nil, )* err }`
I don't see how this helps with revocation of the JWT tokens?
Here are results from a quick grep on the go files in the docker repo. - 9071 instances of `if err != nil` - 1864 (roughly 20%) instances are `if err != nil { return err }` - 3593 (roughly 40%) instances are like `if err != nil { return (nil, )* err }
I've looked into it. Reddit requires you to `Set` the `Host` header, too. No need to log in, as the users /u/fungussa and /u/0x6B claim. req.Header.Set("User-Agent", "linux:go-postgrabber:v0.1 (by /u/ineedmorealts)") req.Header.Set("Host", "reddit.com") 
I am currently teaching a handful of early teens and pre-teens programming. I have chosen to start them on Javascript because combined with HTML/CSS they are able to have the immediacy of creating something very useful to themselves and others. I told all of them initially that there are far more details of programming that they can see at the moment. My current approach is that: 1. I will teach them how to build things 2. I'll teach them how to run it (basically an intro to being a sysadmin) 3. I'll teach them how to break it 4. After the first three steps we will go further in-depth in the areas that they find the most interesting. I personally think that golang would be just find to start with as long as their attention spans and personal ambition is strong enough to overcome the initial slower pace.
Windows only so not really suitable for me.
I am not fond of Javascript either but as you say it's easy to get set up and ubiquitous. Seems like no matter what you do you need some javascript.
For the love of god, dont teach them Ruby. You can definitely teach them go. Go is a very straight forward language. The first language I learned was C. Just start them off slowly to get the concept of what a Variable, String, Array, Function ect.. and how the computer changes the stuff you write into binary 0's and 1's using a compiler. This stuff will be the same in every language.
I didn't need to set the host. Although I had encountered the 429 error code when I hadn't set the User-Agent header
The things you'd need to learn Go fit in one page so yes, Go is a great language to teach programming. Since you can teach/learn the syntax so quickly, you can start solving problems much sooner and with lesser 'language related problems'
whats the difference
I've alway's loved JS for exactly this. It's not a great language, but it is so accessible and easy to share.
There are a couple: * calling into a C library with cgo is not free (can't recall the specifics but it has to do with the C stack that is not the same as the Go stack I think ?) * it makes cross-compiling a pain, because now you can't cross-compile with just Go, you need the C cross-compiling toolchain too. For example, cross-compiling a Go app that uses go-sqlite for Windows is gonna be a pain in the ass. * you don't always have the toolchain, even without cross-compiling. I develop on Windows sometimes, and I'm not gonna install gcc just to be able to compile a Go library. Sometimes you don't have a choice (for opengl stuff for example) but usually I favor libraries that don't use cgo for these reasons.
The afternoon sessions were 50 minutes.
For the pre-teens I'd actually start with Logo or Scratch, just to get to something interesting and visual in as little time as possible. Another possibility would be Minecraft + ScriptCraft (JavaScript). It's more important to get their interest than to use a language you would personally do serious software engineering in. I think Go needs a bit too much side-knowledge of things like memory layout, pointers, bit widths and other architectural low-level details of computers. The lack of good cross-platform GUI support could be an issue too. It'd be a good second language though. You could avoid a lot of the ugliness of setting up a working Ruby system by using JRuby, maybe with some [turtle graphics](https://github.com/rbedia/tugaturtle). Unfortunately the [KidsRuby](http://kidsruby.com/) project seems to have stalled.
go does have sum-types, it has interfaces, which are suggested for exactly that use and there is precedence (e.g. in [go/ast](http://godoc.org/go/ast)). (And yes, I know the difference between interfaces in go and variant types in other languages, it just is immaterial for the things said in the article) go also does encourage direct struct access in favor of getters and setters *if that's their only purpose*. i.e. if consistency-properties depend on the values of those structs being changed in concert (as is the case here), you, of course, should use getters and setters. There is also lots of precedence for this, e.g. [bufio.Reader](http://godoc.org/bufio#Reader) doesn't expose any struct fields and [reflect.Value](http://godoc.org/reflect#Value) demonstrates how one type can represent lots of different things with getters and setters. There clearly has been some misunderstanding about those suggestions, if the people at cockroach labs believe their usage was as encouraged.
You could [look at my code](https://github.com/lpar/jwtauth). I haven't written up a tutorial yet, though. Edit: [This article](http://dghubble.com/blog/posts/json-web-tokens-and-go/) looks pretty good to me.
I hope it doesnt take 4 months to finish the rest even tho they're longer sessions
You're right, and that's most probably what /u/daveddev was referring to. However, if you want your user to be able to manage active sessions, like you can on Facebook or Gmail or Telegram, it's harder to do this with JWTs as those tokens cannot be revoked. Sure, you could keep a list of revoked tokens in the database, and then cross-reference that table on each request, but that would defeat the purpose of JWT (as it's signed so you don't have to do an extra call to the db).
Yes, really - verbose. &gt;val, err := someFunction(args...) &gt;eh.CallFunctionAndReturnIfErrorNotNil(err, log.Println, "An error occurred:", err) &gt;// or eh.CR(err, log.Println, "An error occurred:", err) Call function and return if error not nil? Come the fuck on
Do they owe you something?
No need to apologize, just wanted to make sure we're on the same page! Here is a good read about [revoking JWTs](https://www.dinochiesa.net/?p=1388).
If you're going to [redefine nil](https://youtu.be/ynoY2xz-F8s?t=9m15s) in Go, do it right. var nil = errors.New("¯\\_(ツ)_/¯") or var nil = errors.New(`¯\_(ツ)_/¯`) No hostility intended :p
I read something like this on Rob Pike's blog post but it just doesn't feel right. All the `WriteIfOk` calls will be executed even if there's an error after the first call. 
I've taught one of my sons about programming off and on using Go. He was in 1st or 2nd grade at the time and the language wasn't a barrier at all. It allowed me to get right to a lesson without worrying about setup etc that would lose his attention. If we start it up again I will stick with Go for teaching most likely.
Google Apps Script also uses Javascript syntax so if they want to leverage powerful stuff in Google Drive and other things in the Google ecosystem, it's great!
The screenshot seems to come from a generated go package: https://raw.githubusercontent.com/Debian/dcs/master/cmd/dcs-web/writejson.go 
Well, if you want real security and defense against replay attacks you need to give your JWTs a `jti` value to prevent re-use, which means you have to have some server state, but you _can_ revoke tokens. And at that point at least your server-side state is just a bunch of UUIDs rather than something more complicated.
instead of complaining only I want to tell that the videos are awesome and the sound quality. Thank you very much for the presenter and the people who er preparing the videos. I'm just hyper excited to watch them thats why my previous comment was not written ideally. Sorry!
The videos are now here. What is your problem?
"screwit" ha! but yeah, looks good enough for me.
&gt; Anyone can do it, it's just that it requires writing unsafe code. But not everyone can write that unsafe code. There is a PoC-CL linked further down in the issue discussion where you can see why this needs cooperation from the runtime to actually be safe. And if you can write it, you'll need to update it for every new go version and guard it appropriately with build tags (so no one unintentionally introduces a memory corruption into their code). You might be able to write it, but it'll require you to release your stuff in lockstep with go. This is basically the best argument you could wish for, for why using unsafe is a bad idea; if this breaks, it'll break very subtly (so you will probably not catch it with testing) but at the same time catastrophically enough that you might be thrown back into C-world in regards to vulnerabilities and stuff (as you might be wildly writing into random heap locations).
The program makes just make 1 request per run 
If I were in a situation like this, I'd choose statically typed language but would prefer Java/C/C++ over Go. It's mainly because first three are unfortunately still more popular and there are more learning resources written from complete programming beginner POV.
&gt; Check out dh-virtualenv if you ever want to regret liking virtualenvs. I would say dh-virtualenv actually makes debian packaging sane despite the hacky way it goes about things.
1. Ugly syntax (compared to Nim). 2. Missing boilerplate-reducing features (compared to Nim), especially lack of exception handling (without which your code can be 4x the length when you just want default "print error message and fail behavior"). 3. Lack of secure and coherent package management (compared to pip, npm, nimble, cabal, etc, etc, etc).
Why does int63 make any sense?
That's true. What I was really trying to get at is the lack of type safety associated with using empty interfaces. Coming from a functional background (Haskell), it just seems weird to throw information away.
Because the sign bit has some possibly undesirable consequences for the distribution. For example it'll have a negative bias (however slight that may be). And if you are really sure you want it, you can always generate a uint64 and cast that to int64. I am not an author of go, so I don't know why this particular choice was made, but I always assumed it'll be something along those lines.
Sorry, it appeared to fix the issue for me, but now it doesn't. Even setting the same set of headers wget sets doesn't help. But wget never gets 429. Most strange. Perhaps it's somehow related to the issue 4800. Try to change `reddit.com` to `www.reddit.com`: url := fmt.Sprintf("https://www.reddit.com/r/%s/top.json", os.Args[1])`
As repeated everywhere: `interface{}` is perfectly type safe, it just moves the type checks to runtime, which is literally it's point.
(A): My main gripe: you can't currently refer lexically to a type. I end up doing horrible stuff like this: var TypeBaseNode = reflect.TypeOf((*BaseNode)(nil)).Elem() if typ == TypeBaseNode { doSomething() This is obviously silly. You should be able to do something like: if typ == type(BaseNode) // or if typ == BaseNode.type Somebody opened an issue: https://github.com/golang/go/issues/7112 (B) Not so much a language issue as a stdlib gripe: the sql package doesn't allow you to get the types of returned columns (only the column names). This kinda precludes using the package to build generic database tools. (C) I'll think of something...
What's wrong with saying GopherCon videos?
That seems to have fixed it! I still want to do a but more testing to make sure but it seems to be fixed. Thanks!
I think for teenagers being able to create something fun early on is pretty important. Python is good for this because of libraries such as Pygame and (for younger students) Turtle. It's also good as a starting language because when they learn the basics they could actually use it for things that they might actually want to do, using Minecraft and RaspberryPi libraries. Go is a younger language, and I'm not aware of many libraries that could get young kids to start playing around with it beyond making command line apps, which I suspect they don't really see much point in. That being said, I believe Go could be beginner friendly with the right instruction. Input and output would be harder to teach than in python, though. Python's input() and print() are simple, but powerful enough for most things a beginner would want to do. I'd rather teach young students i = int(input("Number: ")) than var i int fmt.Print("Number: ") fmt.Scan(&amp;i) But, if you think you can make it "fun" or at least engaging early on, I don't see the language itself being too difficult to start with, but not as simple as Python might be.
Sorting. You have to have a type and three (!) methods to do the sorting. Hopefully this will be fixed ([issue 16721](https://github.com/golang/go/issues/16721)).
You are correct, however I think people just mean compile-time type safety when they say it like OP did. Sure, the runtime will catch it, but that might be two months down the road when your web app crashes. 
My app not only reads from, but also writes to Reddit, and I was encountering the same 429 error code. It was only after I'd set the User-Agent header, during the login request, that the 429 error was resolved. With your app, since it only reads from Reddit, I wouldn't thought that logging in wouldn't be necessary
1. Type rigidity. (However, I also like this.) For example: type foo byte f := foo(1) b := []byte{byte(f)} Sometimes I wish I could remove that last ugly conversation from type foo to type byte. 2. How variadic arguments work. I know _why_ it is the way it is, of course, but sometimes I dislike having to manually allocate a new slice of T. For example: // func Query(string, ...interface{}) query := "SELECT * FROM..." foo := "some_id" ids := []int{1,2,3,4,5} Query(query, foo, ids...) // oops, gotta make a new slice of interfaces On the other hand, AFAIK the only way to do this is how Go currently does it—the variadic args are actually a slice—and I don't want the language performing potentially large allocations without informing me. So, like #1, I see it both ways. 3. No "read only" variables. (`const` isn't exactly what I'm talking about.) Sometimes you can get better performance and/or it's more logical for a package to have a global variable like a map or array (e.g., a static lookup table). However, all it takes is one 2 AM programming session to accidentally assign to it and mess everything up. Plus, the compiler could possibly do more if it knew the program was contractually guaranteed never to modify the variable after a certain time (for instance, outside of init). 
I'm not sure what you mean. The challenge here is that the code only needs to execute once except in one nested case. Breaking the code into more functions wouldn't change this. Putting it in a for loop would provide the wrong default, obscuring the fact that it usually doesn't need to iterate and making changing the code error prone, since each new case added would have to remember to break the loop. This is similar to how C switch statements provide the wrong default (fallthrough instead of break) which is a common stumbling block that was specifically addressed in Go.
Which is completely reasonable when op offers no explanation for WHY he doesn't like it.
Explain?
Have you seen http://github.com/maxbrunsfeld/counterfeiter ? 
Hi there, The difference between the two versions is as follows: In the version x,y = y, x+y both variables are assigned the value "at the same time". Therefore x will not have the value of y for the assignment y = x+y. In the second version, x is first assigned the value of y, then y is assigned the new value of x plus y. Hope this clarifies things for you. 
Also Go is heavily (and correctly) opinionated . Python is great for starters, once you are comfortable in Python Go is a great language for building webapps and APIs
I am a self taught programmer and I followed this path 1. css (not exactly a language) 2. html 3. C 4. c++/Java 5. Python 6. Go The thing is, Go was not created as a generic language, it is built for one goal, to manage codebase with large (possibly distributed) teams. It is a modern language as in problems Google had faced while building the apps for the future. This doesn't mean one can't start programming in Go, but it is crucial to understand that Go doesn't follow the _standards_, it goes in the totally opposite direction as in it enforces many things which Python/others keep open for the programmer to choose. I'd say better start with Python and then switch to Go.
This section of the go documentation explains how go get can use different protocols to fetch packages: https://golang.org/cmd/go/#hdr-Remote_import_paths As a first step, it's requesting the URL http://howett.net/plist?go-get=1 then it is looking for a "go-import" meta tag, which in this case points to a git repo go get can clone from.
Thank you! That really helped clear things up.
This: &gt; we didn’t place the check in the common normalization function; instead the code using the struct was responsible for checking whether subscripts were accepted or not. And this: &gt; And all the “simple uses” of QualifiedName we had written throughout CockroachDB’s source code were actually all missing a check that subscript notation wasn’t used. Go encourages bad practices because you did not validate the data you are using and blamed direct access for it? C'mon.
My problems with python is the environment and tooling. Every time I attempt to run a python app on my mac I have to suffer through pyenv and pip incompatibilities and conflicts with the system python etc. Aside from that I just don't want to deal with explaining significant white space to a kid especially since I am not a fan of it. 
Downvote reasons: * The code needs polishing: * rewriteTopLevelIdent -&gt; I don't even begin to calculate cyclomatic complexity of this thing * RewritePackage -&gt; Way. Too. Damn. Long. * def.go ``` package method type Type int type Type2 int ``` * This is not generics. Just some queue stuff with ugly type casting with rules in COMMENTS! * Comments???? Come on. :) I don't think anything that needs rules setup in COMMENTS should be considered 'most elegant way.'. Go doesn't have generics for a reason. Hate, like it, doesn't matter. I get what you are trying to do, but I think you went in the wrong way with it. 'A' for effort though. And the readme is very nicely put together. I don't want to discourage you in writing stuff of course, quite the opposite. I would like to encourage you. Just like in chess Emanuel Lasker said: "If you find a good move, look for a better one."
&gt; gopl.io I've been sort of learning from Todd Mcleods course. Rather insightful really.
You should try (void*) pointers in C. They completely throw away the type safety and compiler check.
also there is "go run ..." which feels the same as running a script
When you said Go doesn't have generics for a reason, can you elaborate on that ? Go, however, does have generics, but its generics is a dynamic one. That can be achieved by combining interfaces and static type casting. What people always wanted was a static type generics. I think the reason why Go 1.x does not have it right now is because introducing generics to Go would bring a huge structural change to the compiler. We can hope that static generics will be introduced in the later releases, probably Go 2. It takes months... 
Why? Must everybody be a programmer? Why not give them realistic feelings about what to expect instead of trapping them into thinking they are great programmers when in reality they have to learn so much more? Until they understand that programming is not for them they already wasted a lot of time.
&gt;Why not give them realistic feelings about what to expect instead of trapping them into thinking they are great programmers when in reality they have to learn so much more? You're not special because your a programmer. You just learn it, They are obviously there because they're interested. I guarantee you if the first thing you learned was about pointers, closures, or concurrency, you've said fuck this.
The whole talk is great, but skip to 21m23s to have your mind blown.
It's like one of the top 10 questions we get in #go-nuts
As a Golang noob this video really helped validate my decision to learn this language. I'm not a programmer by trade just hardcore linux user and hobbyist. So c and assembly have pretty much been my sword and dagger. If this video is indeed indicative of where go is going - couldn't help it - the language should see an explosive increase in adoption. Just my opinion. Edit : correct autocorrect. Edit : looking forward to posting of more videos..Surely there's more than seven. 
There's no clear unifying principle in the syntax for types, each type is its own special case. For example, in normal code, `foo bar` is a syntax error; in a type `chan foo` is fine. The role of space as separator is broken in types. Why are brackets used in the map type syntax, why is it `map[key] value`? It would be much better to just have one consistent notation for all types. For example, if it were prefix notation, we could have: - `map key value` - `[] value` - `chan value` Although, to be consistent with the expression-level syntax, this should really be something like: - `map(key,value)` - `[](value)` - `chan(value)` With the lack of generics, I don't think I really need to explain. It just means you end up writing boilerplate and doing type assertions. See the stdlib `List` type, it uses `interface{}` everywhere, so this means you can have heterogeneous lists and there's no way of knowing what the type of an element is. You have the same problem with any container type you implement yourself. No static type safety at all!
Congratulations, you just found your next unit test.
I loved this talk. One of my favorite details is how one of the inventors of unix advocates for converting binaries connected by text-pipes into libraries connected by binary data and function calls. :)
&gt; Just some queue stuff with ugly type casting with rules in COMMENTS! (Queue is an example, and there is no type casting.) I disagree that putting things in comments is not a good approach. godoc, go generate, ..etc all use comments to consume additional useful information in order to let the tool work. I want you to think that this is the current best way to generics in go1 when go2 is still far away. One can avoid this tool by using other approaches in the README, but one will have other issues like code readability and performance. 
This is a really cool tool. Feel free to ignore the following criticism, but for some reason it bugs me you log the message "Runned"
Can you elaborate? Are you suggesting I write tests in lieu of doc.go?
A little bit of a nitpick, but the concern: &gt; Go’s JSON parser wants you to know the structure of the data you’re parsing ahead of time. doesn't really make sense to me, for two reasons: - unmarshaling into `interface{}` lets you work with arbitrary types, though it can be cumbersome. Packages like [jsonq](https://github.com/jmoiron/jsonq) and [gjson](https://github.com/tidwall/gjson) make that nicer. - are there really that many cases where one deals with an unknown json structure? Libraries meant to generically deal with json (like jsonq etc) are the only ones I can really think of as commonly practical. In delivering or consuming an API, you're always dealing with a set of specific structures, and so even in those loosely typed situations, you're doing stuff like: ``` $obj = json_parse('{"some": "json"}'); if (array_key_exists("some", $obj)) { // blah } ``` which is really just a more verbose way of needing to know the structure ahead of time.
There are more than 7 and all will be posted. This was just the first batch.
sure, instead of putting commented out code in doc.go, you can create a test file (by appending "_test.go") for example, to test main.go you create an additional file called main_test.go then at command line, just run "go test *.go" to run the tests. You use fmt.Println to output data, followed by a comment in a specific format to check whether or not the assertion passed. This way, instead of just static documented file (doc.go) you have a living test, that can be run whenever you make a change (the way it should be!) More here: https://golang.org/pkg/testing/ 
I write all my personal CLI utilities in Go now so this awesome news! Always pleased with the clarity and comprehensiveness of all the blog posts.
since the interface to this program is primarily stdin and the execution environment it seems a little awkward to test. I'd welcome a refactor that makes it more testable if it doesn't introduce too much complexity.
Author here. The post is a little rough around the edges, but I wanted to get something out since I haven't published anything in a while. Any feedback is appreciated!
:(
It's out now, so you are free from that burden my friend.
Yes, but that's still harder than just unpacking a downloaded zip file and updating your path.
it's not a technical criticism -- just that the word "Runned" doesn't exist in the english language. Proper tense would be "Ran" or "Has been run"
Craziest, most amazing feature I've heard of this year: parsing an architecture's assembler manual and making Go's compiler and linker know what to do to compile to said architecture **without having to read a single line of said manual**! EDIT: Mispelling
Go is excellent on the backend, it's dead simple to get up and running, the deployment story is best-in-class, great tooling, strong ecosystem, etc. Our organization started with Mongo and Python + CoffeeScript. We ditched Mongo because it turns out that the unstructured approach doesn't scale well as your application becomes more complex and your engineering organization grows beyond a small team. Python and CoffeeScript scale a little better, but the dynamic typing poses the same problem as NoSQL--the lack of structure makes it hard to communicate as your team and application complexity grow (never mind the classes of errors that are entirely precluded). Basically by foregoing static typing, you lose a lot of tooling functionality--goto definition, intelligent autocomplete, all sorts of static analysis, etc. I really recommend you use a SQL database or at least plan to migrate early. Similarly, just use static languages out the gate.
&gt; Your metric is using MySQL 5.7's InnoDB engine, single-core, non-sharded, non-distributed. InnoDB: That's so that we're comparing like with like. single-core: One of the things MySQL is often criticized for is making poor use of multiple cores, which is why people go for sharding. By looking at single core benchmarks you can cut that out of the equation. non-distributed: Well, you can scale anything if you throw enough instances at it. But I'd be interested to see some benchmarks for comparable sharded distributed setups, if you've got 'em. &gt; Uber just made the switch from PostgreSQL to MySQL for better scaling Yes, but Uber's move back to MySQL from PostgreSQL was news because most stories are about going in the other direction -- including their own story a couple of years previously. Since the Uber article some [have argued that they were mistaken on many of their reasons](http://blog.2ndquadrant.com/thoughts-on-ubers-list-of-postgres-limitations/) for the re-migration. Also, they [still use postgres](https://news.ycombinator.com/item?id=12217179), just not for that particular table. Anyway, I would say that PostgreSQL is a better _general purpose relational_ database. Once you get into massively scaling particular narrow problems, you're generally going to need to evaluate needs very carefully, and there won't be one easy answer. You might even end up with one of the big commercial databases. &gt; Fortunately, changing database engines is trivial pre-beta. My biggest problem with MySQL is the laxness of error checking and lack of standards compliance, making migration away from it less trivial than it should be.
Indeed. I was sitting there during the talk and was stunned. Amazing work by the Go team!
A no-nag flag would be cool. Not sure how to discourage its use though. 
Is he proposing or working on a "abstracted assemble language" that would cross architecture? Or is that how Go works already?
&gt;You don't really need to "teach" significant whitespace since you should be teaching proper indentation anyways and the significant whitespace falls out of that naturally. I disagree. There is no real reason to be that much of a stickler on significant whitespace because most editors will format your code automatically. With python it's impossible for a beginner to simply cut and paste some snippet in place and make it work. They have to spend time getting the snippet indented properly within the code (paste doesn't always work as is) and then within the larger program itself. My experience is that beginners are annoyed by this in the "why the fuck do I have to care about this" way. &gt;I don't know how easy it is to do global library installs on mac (brew?). On Linux every marginally popular python library usually comes as a system package. Just yesterday I was installing the aws-cli tools which are written in python. Following the instructions on their website I ran into several problems. One was that somehow the python installed from brew wasn't working right so I uninstalled it and used the system python instead. Then I ran into another problem because the directory I downloaded it into was inside of a directory hierarchy whose top level was a symlink. So it was ln -s ~/Documents/Google Drive/source ~/Documents/source The python install tools changed the directory to the Google Drive directory and failed because the directory had a space in it. The solution was to to move the source code to a directory without spaces in it's path and install it from there. Why should a beginner have to put up with crap like that? 
I use [entr](http://entrproject.org).
Glide is probably the only one I would consider using. The only thing that I think is missing from `go get` is the ability to specify branches. Glide fills that gap.
&gt; especially when pushing to production - no more forgetting to make SQL schema updates. what on earth are you doing that this is an issue??
Nice sister tool to the original JSON version I wrote! FYI, you forgot to rename the "SmartyStreets API" text on the web page from the original page you took that from: https://mholt.github.io/json-to-go/ 😉
May I add that "Done" might be more natural, depending on the context of course.
Looking forward to 2 and 3!
3! = 6 _____________________ ^(I'm a work in progress bot.)
Inspired by another package doing the same. So maybe you can add what is different in this package ? 
1. select, or how hard it is to get select right. Deceptively simple, but hard to actually understand and test. 2. range, only work for buildins, should also take an interface. 3. chan's edge cases: send on a closed chan panics, and send on a chan with no receiver blocks. So there is no simple way to close a chan preemptively from the receiver size. And a missing feature, separate types for nil-able and non-nil-able pointers. This moves nil pointer exception from a run time error to compile time type error. Also removes the need for defensive nil checks when unnecessary.
Thanks for the loads of information you provided me :) I found Memecached really exciting. I think ill write a small prototype using it with MySql and golang to get a feeling for it. Some of you talked about scaling the system using a cluster of servers rather than just a single server instance. Our team currently works with AppEngine to get a MVP done fast and easy. When i understood the concept of AppEngine or other hosting providers like AWS or Heroku correct, they take care on load balancing, fail- saveness rather then letting the developer deal with this. Does the same apply for Memecached solutions, or do i miss any basic concept behind this?
Go simplified how it handles the multiple architectures it supports by using a pseudo assembler language that is translated to the real assembler language using only simple tables to translate the code. Now they are trying to create those translation tables for a new architecture automatically from its assembler instruction manual (a PDF file). IMHO, this could be used by any language to easily support as many processor architectures as they want. Anyway, it is a really cool hack.
I am not sure there are other languages (which produce native binaries) that can compete with Go's portability and easiness of cross compilation.
I've kept reading that the `enconding/json` is very slow and I've seen quite a few 3rd party json packages popping which claim that they are much faster. People always seem excited to use them as well. I suppose that might have given me the impression that the 3rd party toml packages are also oh high quality.
Small point, it's not "Google Go", it's just "Go", "the Go programming language", or "golang" when you're searching, tagging, etc. Perhaps this should be in the Go FAQ.
They are called font ligatures and are features of fonts like First Code. I've mostly only seen them preferred with operator heavy languages like Haskell. 
&gt; portability and easiness of cross compilation C for example? The language itself has pretty much no dependencies. C++ is not far away from that. Rust can be ran on bare metal too.
Go brings a level of structure that is completely optional in php or JavaScript. It slightly raises the bar of effort for trivial size code, but really pays off as soon as the program size gets above a page. Most of what you need to do is considered good practice regardless of language, but ignored by tinkerers and languages that appeal to them.
ah, I see. Isn't this a bug of Go(lang)? ;-) Thanks for helping! :-)
I don't think that you can easily cross compile C or C++. They should be pretty portable though.
You are using `:=` happily? If you've a particular example of the quandary over whether to use a pointer, ask that.
Yes, I still catch myself writing `fmt.Println(...)` in JS and `console.log()` in Go...
Have you ever tried TypeScript? It's my happy medium - the safety of types when you want them with the flexibility of JavaScript. Love it!
With a couple wrappers in the respective languages, you could use them that way :P
What makes this possible?
I'm guessing they are referring to using this: https://github.com/gopherjs/gopherjs
Go was designed for this.
My extent of pointer comprehension is knowing that a function that receives a pointer as argument will modify the object instead of creating a copy if the object to work with. Is there anything else I should know?
I dont find Go hard to work with because of loose vs strict typing.
He is not asking for our ~~opinion~~ permission, he is asking for an opinion from people that probably have more experience in the language. And comparing the most upvoted comment in this thread that says _"Go was designed for this"_ written ~60 minutes ago while yours was written 45 minutes later, I wonder why you decided to reply saying _"[...] Go is too slow"_, you could at least have backed your opinion with some technical details.
Rust also has a mode that lets you strip out the StdLib I believe. As far as I understand (never tried it) this lets you write embedded Rust that wouldn't even need an OS to power it. Complete lack of StdLib would be a real challenge, though. I can't imagine it being a very productive work environment.
Named returns can be a source of bugs in longer functions and I could do without them in the language.
&gt; Is GO fast enough for infrastructure programming? [Yes.](https://groups.google.com/forum/#!msg/golang-nuts/BNUNbKSypE0/E4qSfpx9qI8J) &gt; trying to break into infrastructure programming I am confused by this comment. You make it sound like Infrastructure Programming is a cabal that you break into. Instead, you should think of it as a skill that you learn. Infrastructure programming requires more knowledge than typical programming. &gt; I'd like to develop infrastructure components such as loadbalancers, caches, Again, that's an odd thing to want. Do you have someone lined up to pay you to develop that? If not, your target should be to _learn_ about infrastructure components. It's much more likely that companies will pay you to [grab ](https://github.com/vulcand/vulcand) one [off](https://github.com/mholt/caddy) the [shelf](https://github.com/golang/groupcache) instead of re-inventing the wheel. Don't get me wrong, I'm not saying you shouldn't write those programs. Just that writing those is not an end, it's a means to an end of understanding infrastructure. If you have to ask others if a language is any good, you are too much of a novice to write the next great load balancer. But learning infrastructure programming will make you a better programmer.
I write ES6, where let, const, etc give block scoping. The new idiomatic JS is converging toward more traditional languages. Sometimes I with Javascript has multiple return values (though object literals are fine) or wish Go's type system made some functional things like map/reduce or monads a little less awkward. Also, promises don't help mitigate callback hell as well as channels do.
If anyone can't figure out how to get rid of the debugging panel, ctrl+k, then ctrl+g. Took me a while to figure it out, embarrassingly. 
Thanks for the response. Rust is definitely under consideration but it seems to not have that much proliferation in the tech space. The only guys that I see using it are Mozilla themselves. This doesn't necessarily mean it's not worth wild, but community is a big deal with these things. I realllyyyy like the idea of rust but I'm wondering if I can achieve the same thing with go whether that's a better route to take.
Also take a look at xmlpath [v1](https://godoc.org/gopkg.in/xmlpath.v1) or [v2](https://godoc.org/gopkg.in/xmlpath.v2). I've used it a while ago to do some stuff I sadly couldn't do with the standard library. It's well-written.
The empty interface would be the first on my list. It wouldn't that bad if we would have variant types as well. Using the empty interface should be the last resort(i.e. if you can't use variants). go/ast is a good example of how ugly it is.
GC languages were not designed for game development unless your game is something like 'angry birds'. I love Go but there is no good reason to use it for games/signal processing or other fields where performance is critical. I hope one day we will get a Go-like(or even a Go fork) language without GC. Edit: It seems that this got a lot of undeserved down-votes. Just to make it clear: I agree that games that don't have high performance requirements are doable in GC languages but still it's the wrong tool for the job. Now the latest gig in gaming is AR/VR. I don't think we will see a AR/VR engine developed in a GC language(i.e. go) any time soon. Of course a simple game with low performance requirements in doable in any kind of language. The other category of games(mobile games) would also suffer due the fact that GC languages require more memory than non-GC languages so it's not good for mobile games either(again unless your game has low performance requirements). 
&gt; GC languages were not designed for game development Many games have been written in Java including some extremely successful ones (Minecraft).
OK, perhaps i don't agree with your assessment of what infrastructure software is then. If you mean real-time software,then, essentially thats just software with deadlines for processing events. And if real-time is what you meant, then Vitess absolutely falls into your bracket. I would say that any software that manages the run state of an application (and that definitely includes scheduling, monitoring and logging) **is** infrastructure software
Yes. Assuming a have a function that adds all the elements of an array and returns a long string. If my array has billions of values it would be better to use a pointer instead of creating a copy of such a big object. Is that what u mean by efficiency or are there other cases?
My go guru configuration for GNU Emacs: (use-package go-guru :bind (:map go-mode-map ("M-." . go-guru-definition) ("C-M-g c s" . go-guru-callees) ("C-M-g c r" . go-guru-callers) ("C-M-g c k" . go-guru-callstack) ("C-M-g d f" . go-guru-definition) ("C-M-g d b" . go-guru-describe) ("C-M-g f v" . go-guru-freevars) ("C-M-g f r" . go-guru-referrers) ("C-M-g p e" . go-guru-peers) ("C-M-g p p" . go-guru-pointsto) ("C-M-g i" . go-guru-implements) ("C-M-g w e" . go-guru-whicherrs)) :if (executable-find "guru") :config (add-hook 'go-mode-hook #'go-guru-hl-identifier-mode) (add-hook 'go-mode-hook (lambda () (when projectile-project-p (set (make-local-variable 'go-guru-scope) (concat (projectile-project-root) "...")))))) I have `C-M-g` free on `go-mode-map` but you can change that to whatever you want.
What about contributing to open source infra projects, such as kubernetes, docker, hashicorp stuff and many other open source infrastructure. All written in go btw I think those would be a better foot in the door to those positions than writing your own from scratch. 
I understand what you're saying here. And I think you're correct. I'm coming from a heavy 'network infrastructure' perspective, where I'm worried about the ability to handle packet rates of data. Which I typically see done in C. I'm biasing these questions and examples on my perspective. I think these are all valid points. My intention was not to downplay go's current projects. 
I'd like to avoid C if possible. I'm coming into this with little C experience and I feel the ramp up to write C code that could actually be released into production would be rather long compared to a safe language. 
I am a big fan of the Caddy webserver, which is in Go. Look at their benchmarks, it's really really fast. Like nearly Nginx fast. I think it's certainly fast enough for systems where the bulk of the waiting is in network communication.
Great example project! Thanks a ton. 
Dropbox is using rust now for part of their storage backend.
Experience and simplicity. If you haven't, I recommend watching Simple Made Easy by Rich Hickey also while not as good Leslie Lamport has a talk Writing for Programmers which I think is important. None of these are specific to web development. I don't think there's a shortcut specific to web development.
Go back to your cave you crawled out of just to be a dick. It's much better suited for you lol. 
I can completely understand that. SquareSpace right now has a very awesome job posting for "Edge Infrastructure" engineer. That is a perfect description of what I'd like to be doing in year or so as I get my skills up. https://www.squarespace.com/about/careers/?gh_jid=245517 I actually currently have a DevOps title. 
I just completed a game engine written entirely in C#. There are no performance issues. Countless games are written in C# and other languages with a GC.
Sounds useful to me if it fixes dependency tree and versioning issues. To put it short, I wish for a package manager as good as npm or gem/bundler
I just started https://github.com/anacrolix/goproxy this morning because HAProxy has terrible defaults and was more trouble than it's worth to set up again on a new box. So far it's working great. I also have a lot of custom tools that do all the things typically some from C.
I am one such platform engineer who write Caches and load balancers and geofencing aggregators and distributors and such stuff in C. Given a choice I would rewrite a lot if stuff in Go or C++. It is in C because legacy reasons . Here is what I learnt over a period of time. Measure every god damn thing, do not trust what you read on Internet, it is just a ball park figure, measure it yourself. Every single thing you need, test it for your use case. Only move when you understand the tradeoffs. Oh and also, performance is subjective and very easily misinterpreted. Beware of it.
Caddy is nowhere close to nginx. Why do you say so?
&gt; no platform for publishing actual packages to I said it before, I say it again: The decentralized nature of import path based fetching is a *strength*, not a weakness. &gt; Does this sound like it would be useful? I'm sorry, but no, it doesn't. The last thing go needs is another island-solution "package-manager", which this is bound to become, promises or not. There are almost as many package managers as http routers. And they completely worthless if everyone uses a different one (and from what you said as properties, I can promise you that your's won't be the one to rule them all, there are too many people who disagree with the choices you made). If you want to change the packaging landscape of go (and I still see no need for that, but that is just my opinion), participate in the debate around problems and solutions currently going on, because that might actually end up creating something useful to the majority.
As /u/shadowmint mentioned, there is a working group to try and solve this problem now. There is no perfect solution but I'm looking forward to what the working group comes up with. &gt;One of the first things I'm going to be releasing is a service similar to gopkg.in, but it will actually allow you to specify any semantic version tag (v0.1.2, v0.2.1, v1.3.4, etc) for the repo endpoint What do you mean by this? Do you mean I can specify an explicit version number and I'll get that version? If so, that means every time a dependency is updated the version number has to be updated - that doesn't really add much on top of the existing tools for pinning to a particular revision. The whole point of semver is that the version number indicates compatibility with previous versions such that a dependency list doesn't need to be updated. If instead, hitting https://foo.com/package@1.2.5 gives you the highest semantically equivalent package then this is quite strange behaviour. What if package `A` depends on package `B` and package `C`, B asks for `D@^1.0.0` and `C` asks for `D@1.2.0`, you now have to do version constraint resolution which is especially complex with Go as you don't know the dependencies of your dependencies until you've installed them (unlike other languages that have a file to explicitly list them). It is for these reasons that I actually quite like the current state of affairs with Go: - plain old `go get`ting works 99% of the time and has approximately zero complexity - it creates strong incentives to properly think about what you export from a package as breaking backwards compatibility is difficult - `vendoring` means that if you have more complex requirements then these can be achieved by something external which can then stuff the result into the vendor directory.
Awesome!
not golang :-) people get mad at you when you call it as golang.
Are you sure using a wrapper like gorm is a good thing? I mean I had done a bit of ORM in Django, and there was no way to get the "current user" for the request to fetch the particular items from the db, without writing some serious stuff. Just curious how to handle db in a scalable way. ORM or no ORM?
Yes, and that would have saved me an awful lot of time!
Great piece.
I really appreciate this! I've been looking for a group dedicated to solving this issue, so this might be exactly what I need!
I've found it to be in the same performance tier as Nginx, and it looks like others do too. See the Caddy FAQ, near the bottom. From the FAQ: How does Caddy perform compared to nginx or Apache? It's fast. If your site only serves tens of thousands of requests per second on good hardware, then don't worry about it. In our tests—which have been confirmed by multiple trial runs on different hardware, verified independently by different developers—we've found that Caddy and nginx generally perform similarly for most static file needs, a notch above Apache. But this depends on many factors including system environment, hardware capabilities, network, software tuning, etc. We've also seen some tests where Apache performs better than nginx. Given the high degree of variance among these factors combined with your own needs and configurations, we'd rather you discover Caddy's performance for yourself. If you require extremely high throughput and you know what you're doing, do your own benchmarks. If you verify that Caddy is a bottleneck, we welcome your pull request to make it faster. 
I definitely see your reasoning (as well as some of the Go team/community), but what some think is a solution to dependency management is actually a hindrance. There are no guarantees in SemVer that allow someone to fully trust all packages &gt;= 1.x, and this is why other package managers don't limit your specification. There are always bugs that make it through testing, and by not allowing you to lock your dependencies at a specific MAJOR.MINOR.PATCH version, you are opening yourself to the possibility of your code breaking due to someone else's release. I'm not saying you should have this functionality, because you should, but I am saying that you should be able to circumvent it if you so desire. **This is one of the biggest reasons Go authors don't like to consume third-party packages.** &gt;What if package A depends on package B and package C, B asks for D@\^1.0.0 and C asks for D@1.2.0 This isn't exactly a new problem, and many other package managers attack it in many different ways. The idea of installing both versions isn't a bad one necessarily, but I wouldn't go the route of a nested dependency tree like NPM did.
Bundler is one of my main influences! :)
And what makes you say this? How can a problem that has been solved in so many other languages be unsolvable?
A somewhat harsh response to a not-so-harsh question/statement, but I expected as much. Do you truly believe that Go package management is fine where it currently sits? I fully intend to start interacting with the working group, and even they seem to be expressing issues very similar to what I'm saying. The nature of not being able to lock dependencies (without including them in the repo itself) and update them when you're ready and have tested the update is a step back in development. 
Glad to hear it!
Another look at it is this. With package managers like nix and guix you can fetch packages (source or compiled packages) with their cryptographic hashes. This means you have the exact version of a package you need, including all dependencies with their exact versions. This calls for compiling with a recipe file outside of the language. Then you just say "directory.xyz is modulename1" in the recipe file. It's just an idea but I think it's worth to let the OS package manager do the package management instead of the language especially with exact package managers like nix and guix.
I don't. NPM drives me nuts. (Though it has been getting better. Flattening the node_modules structure and removing peer dependencies was a big plus.) The thing that (still) drives me nuts is the fact that NPM allows you to update versions without changing the version number. A number of javascript libraries (including react, which I hate them for) like to update the dependencies in a single version, so that even if you have the version numbers locked down, you still end up having a different product that will suddenly fail to build when you don't have access to the registry. Having a commit build one day and fail the next because of an update in NPM makes my blood boil.
Thank you! This is great to hear from someone with experience. I understand the problems with performance analysis, I've spent years now tracking down performance issues, understanding the synergy between different components and so on. But I find it highly valuable to still ask and get responses like yours. 
&gt; Do you truly believe that Go package management is fine where it currently sits? Mostly, yeah. I don't believe what we need is better package management, but if anything, better tooling around finding the API version we need. go get checks out git (or whatever) repositories, you can put them at any version that you want, there really is no deeper need to talk about "packaging". go repositories should just be repos. It is annoying if things stop building, but you can work around that pretty well, IMHO, by looking at the set of repos in your GOPATH and then having a tool that determines a set of commits that will make everything build just fine. There is a valid concern about reproducible builds, but that, again, doesn't really need "packages", it just needs a description of the state of your GOPATH (and that doesn't need to be put into the repo, it's fine distributing it along with the ready-built binaries that you release and sign, for people to verify that their artifact is identical and you didn't cheat). There is a valid concern about upstream repos becoming unavailable, but, again, the solution isn't "packaging" (lest alone a central repository of packages, which will make things *less* reliable, not more), but maintaining mirrors. People complain about GOPATH making it impossible to fork packages, but that is simply untrue; you get a git-repository in your GOPATH, just add your own repo as a separate remote, commit there, push, make a PR, it's business as usual, as with every other language too. You can't have a long-term maintained fork under the same package name, without major import-path rewriting, but again, *that's a good thing*. If it's a different package, it *should* have a different name. Import paths as an identifier and location are a *great* solution, because you a) get automatic consensus over who owns a package, enforced by an external system (DNS) and b) everyone has complete control over their namespace (as opposed to a centralized repo, where things can just get taken offline on a whim, see the whole left-pad scenario for an example). So, in the end, any "central repository" will just end up implementing *the same* notion of more-or-less-url-based identifiers and at that point you simply get what I said above: A mirror. I *do* see issues with go-package management (as opposed to "go package-management"), but the solution is not to clone the horrifically broken npm/gem/whatever. &gt; even they seem to be expressing issues very similar to what I'm saying. I didn't say my opinion was mainstream, but it *is* my opinion and you asked for that :) &gt; The nature of not being able to lock dependencies (without including them in the repo itself) and update them when you're ready and have tested the update is a step back in development. There never was any of my dependencies updated without my express action, so… And yes, you shouldn't release untested code into your production environment, but that's an operational and release management concern, not a developmental. In particular, it's not something that upstream can or should solve; They won't know what you are running in production and how it looks like and it's unfeasible to expect them to accommodate that.
I wish more people understood this. It's not just about the language, it's the whole lifecycle. 
I was using Goop, but I'd seems to be I maintained now. No support for current vendoring.
there's some point I think the library can improve 1. commands should be keep as []byte instead of string, convert all of them into string is not necessary 2. sometimes we need to store client state, current API seem did not support it.
It's like by writing those few more lines your palms die of exhaustion. Duplication of code in Golang is nothing in comparison what plumbing you have to do in other languages to achieve same thing.
I'm still waiting for Go to make guarantees about the behavior of safe code (in the presence of data races).
There are problems with both micro and macro code reuse in Go. Sure your quip applies to some the micro problems, but my point was that not all the issues with code re-use are just one liners repeated over and over.
You could just use destructuring, which is strictly more powerful than Go style multiple return types. &gt; function foo(x){ return [x, x*2]; } &gt; let [a, b] = foo(4);
Hey no problem.
Redcon is not for recreating Redis, but for custom server implementations such as the Tile38 project, proxying services, and microservices that might need to use the RESP protocol. 
Thanks for the feedback. 
Redcon is framework that allows for embedding a Redis-like server in a Go application. Persistence is something that could be added at the higher application level. 
Go will never do that, though. It's up to you to use either locks or channels to make your own guarantees. This is true for all languages with side-effects (not true for Haskell, F# etc.).
Try catch? Aren't we talking about Golang? Additionally, try/catch is quite slow. You should take some time to look into the inner workings of the JavaScript vm
1. Import/variables not used compiler error when prototyping. I'd wish to make them simple warnings with a flag. 2. No time.Duration Unmarshal (not really a feature, but a lack of feature). Otherwise I'll say no function overloading or support for optional parameters and default values. 3. No package manager. The effort is pushed to project maintainers to work on their repos like a textbook example and releasing every major version on a separate repo (who does that? Tagging and branch exist). Alternatively, you need to version control your dependencies and include them with your project. It sounds more like a workaround to me.
&gt; How can a problem that has been solved in so many other languages be unsolvable? I (and I assume /u/drvd) disagree with your premise that it has been "solved in other languages". As an example, I am avoiding ruby software, because the constant breakages and the whole version fubar is just not bearable to deal with. And gem is usually touted as a good example of how it's done. And then you ask someone doing ruby and they'll be like "yeah, well, obviously you want to use rvm" and at that point it's just a table-flip. [edit] also don't forget npm, which is the other thing touted as having "solved" that problem and look at the whole left-pad disaster for proof that it actually hasn't solved anything…
It could go the Rust route and use the type system to prevent data races. Admittedly, that would require having a non trivial type system, and there's no nice way to make that backwards compatible with Go as it is today.
Do you even database/sql bro?
Because go build is a separate process from go generate, code generator (the tool) is less likely to fragment "the language". Go compiler builds any valid go code; it really does not matter whether the file is written by human or a tool. So I think what might fragment the language is not the code generation tool, but the decision to solve the problem with code generation. This decision is justifiable to gain type-safety and performance at this point, and fortunately in most cases the problem can be solved before making this decision.
I think it will be extremely difficult to add *anything* to the stdlib at this point. If it is not needed for any of the "core" packages, they have shown extreme reluctance to even consider it. I could see a high quality toml lib going into the /x repo someday though. 
Go may be fast enough, but C is what people are already using and where the jobs will be. Also I would suspect that if you do find that type of work where they may be switching to Go or something, I bet they'd expect you to also know C. 
the go path, I push something to cloud hosting, "Can't find GoPath", or I open the a project and the GoPath is set to another project. Issues with importing extra files has caused me to pile more and more code into one file. But I am sure there is a valid reason why the GoPath is the way it is. 
Wait is that why I had a hard time using timestamps I generated in Go on my apps client side? My go service produces timestamps on sets of data I push to the client, but I realized that something was messed up so I just decided to create a new Date object in JS instead. I have since ignored it, but I maybe that could've been the reason. 
Gorm
Gorm is painfully slow. sqlx is tolerable though. The fact that database/sql is so poor for SELECT queries though says a lot about the practical limitations of the language in its current state. Not everything should be solved with reflection.
Can you elaborate on what is annoying about it?
Older ticket, so not sure if still relevant, but gorm appears at best half the speed of database/sql for certain tasks: https://github.com/jinzhu/gorm/issues/298 The broader point though is that working with data structures is a pain in the rump with Go. God forbid a project needs to use the same tree functions on multiple data types.
&gt; A lack of generics certainly leads duplicate code [citation needed]
Mainly I am not very competent in terminal commands, so setting up bash profiles or configuring paths takes me a long time. I have only really learned what was needed in order to get things done, and I have yet to invest my time into learning the commands. Also I always have a fear that I will accidentally overwrite some other bash command. What normally happens for me is when I use the terminal a lot it becomes second nature. . . until I go off and work on something else for a few weeks and think to myself(wait, where did I put it?). This is more my own failing, i'm like a kid with a calculator(GUI) unable to do simple mental math(finding things via the command line). 
I see. I've never had issues with it but I'm comfortable in the terminal. If you only want to use one static gopath it should just need to be setup once. 
Java guarantees that while data races may lead to surprising results, the behavior is still well defined. The worst you can get is to read one value when you might have expected to read a different one. Or in other words, you can have logic bugs, but not memory corruption. With Go on the other hand, a data race is undefined behavior and can easily lead to memory corruption. Mess up one lock and hackers can potentially take over your computer. One notable difference between Java and Go is that in Java, references are all just native pointers. Go has multi-word reference types (string, interface, slice, etc.) so offering memory safety would be more expensive.
you can also use go generate if you really don't want to type those "hundreds" of lines.
&gt; At this point it's clear that choosing to not include generics in the official Go release is a choice of form over function. You are misinformed. The Go creators have stated that they are willing to add generics if they are able to work out a good implementation that plays orthogonaly with the other parts of the language.
So basically you are saying that I should implement generics with go generate rather than have it directly integrated into go build? Turns out that people are desperate enough for generics that one of those implementations I previously mentioned did just that. It still doesn't make sense for it to remain outside the core build system though. The way it is right now just causes fragmentation in the ecosystem similar to how vendoring used to be. Basically nobody uses it because they don't want their builds to be brittle.
I mean if the solution really is to not use Go for ambitious library development, then so be it. I have yet to see a good excuse for the lack of generics though. It seems to me that some highly-respected maintainers took a hard stance and are just waiting for things to cool down before reversing their decision. Mark my words, it'll happen officially sooner-or-later!
I'm well aware of the tease. How many months has it been now? 6? A year? I've lost track. All just to talk about the possibility too! The reality is that a few highly respected maintainers aren't particularly enthusiastic about it. Eventually it'll get added one way or another due to being major omission, but I wouldn't hold my breath. It is very much so stuck in red tape land right now.
Thanks for pointing out. Now run "go read 'Go Is a Shop-built Jig'" =))
Sure, but with exceptions they don't need to be added to every stack frame.
Python is great because you can do math stuff easily like thensorflaw 
Of course, exceptions are propagated for you, creating incentive not to care about proper errors handling. [Recent study](http://plg.uwaterloo.ca/~migod/846/current/projects/09-NakshatriHegdeThandra-report.pdf) on real-world usage of exceptions in Java confirmed this. Go is gently forcing you to care about errors, and I find it priceless in the long run.
v0.1.20 of go-debug is released which makes the debug panel *not* visible by default (initially); requiring you to toggle it on if needed.
I'm loving all these in depth articles on low level optimization. Go has come a long way, and when it was finally able to be compiled by itself, it opened up the doors for even better optimization. I am stoked about the future of Go, finally getting to smaller binary sizes and even faster execution!
&gt; What do you mean by "The Go team"? Core team members. &gt; but has the leadership brought forward any solutions themselves that I'm not aware of? I am not sure if they have published full blown implementation ideas but I remember plenty of conversations in the golang user group. I can't be bothered to dig those up but I think Russ Cox summarized the generics problem pretty well here: ["I'm sorry, but no: Generics _are_ a technical issue and _are not_ a political one."](https://news.ycombinator.com/item?id=9622417) They seem to have done (and probably still be doing) extensive research on the issue internally. The fact that we still haven't seen anything concrete published yet doesn't necessarily mean that they are not working on it or that they do not care for that matter. For example, did you know that the Go team [had/has plans for a debugger](https://www.youtube.com/watch?v=VoS7DsT1rdM&amp;feature=youtu.be&amp;t=46m11s)?
&gt; One citied all over the place is error handling. The try/catch model is no magic bullet only because doing error handling properly is just hard. I think people like try/catch because it gives the illusion of error handling made simple. But over the years I have seen far to much code that looks like this to know try/catch has it's own issues: void DoSomethingThatCanFail() { try { ...... } catch (Exception) { // exception silently ignored } // always works even when it fails!!!!!! } 
Oh yeah for sure it can be done with external tooling. I saw an implementation that uses go generate a while ago actually, so I don't think it's an issue of people not trying to solve it. I just think it belongs in go build. As a general rule of thumb, I avoid 3rd-party transpilers because they make things brittle. It's basically the same reason I avoided vendoring tools before it got rolled into the core build system. In fact, I used one once, now it's gone, and I can't build that project as-is anymore.
I guess that depends on what you mean by a "serious generics implementation". When I think of a generics implementation that would solve the majority of my issues, I imagine it looking something a bit like code duplication... Perhaps because manually duplicating code is the "solution" right now.
GOPATH is one of the things I love about Go the most, all my code is officially present in one folder, goodbye to the `code` folder, which contains -&gt; `python`, `bash`, `html` and each folder like python contains python projects. $GOPATH/src/github.com/thewhitetulip contains all my Go code, I am even thinking to put all my code inside it Go or otherwise. It is hard to start with commandline, but trust me, once you get comfortable with it, there is nothing like it.
A slight misunderstanding here... /u/iends wrote that Go programmers use IDE snippets for error handling. /u/divan0 replied aksing if [programmers in other languages] don't use IDE snippets as well, to insert try/catch blocks. So the try/catch comment was directed towards languages other than Go. Side node: As I write this, the comment I answer to has already -18 points, meaning that at least 18 people have downvoted the comment. Sadly, none of these 18+ persons considered taking some seconds of their time to help sorting out the misunderstanding.
&gt; But over the years I have seen far to much code that looks like this 100% agreed. That's also my experience from seeing tons of JavaScript code within the last 15 years. I suspect that one reason is the pressure to deliver working code within a certain time - especially a problem for technical consultants with short-term contracts. But then, the programmer who is used to ignoring exceptions will, when turning towards Go, ignore error handling in Go as well. 
&gt; the programmer who is used to ignoring exceptions will, when turning towards Go, ignore error handling in Go as well. I guess the Go advocates would say this is not such a problem as it is obvious (by just reading the code) when a programmer is writing code that ignores errors. With try /catch code it is not always as clear what the programmer is doing, only because the actual catch might be in a totally different source file or many lines away from where the error was generated. FWIW I've used both models of error handling and I'm generally happy using either model. I think both have their pros and cons. 
Okay man, seriously I don't know what experience you have, but don't make bold statements without proper knowledge. For a while now docker uses its own container technology, so you might wanna take a look at that and think about the wrapper thingy.
I could never understand the purpose of different logging levels. You either log or you do not. A well-written command produces no logging on success. "No news is good news". I believe that the design of the standard `log` package emphasizes that idea but still allows for flexibility via `log.New` which should be sufficient for the majority of cases.
I personally like my logging levels, especially for debugging. Of course, the warning level is basically useless; I follow the example of the go compiler, it's either an error or it's not. But otherwise I like to have the log levels `Debug`, `Info`, `Error` and `Fatal`. (And please don't os.Exit on Fatal, I want my cleanup pls, that's my task, not the logger's) It's certainly not a bad start, tho I'll probably just `fmt.Printf` in my libraries like always...
As a sysadmin logs are fundamental. Logs telling you what a process was doing when it was working as expected in the lead-up to a failure can be invaluable. If a process is mis-behaving, enabling more verbose logging to get more diagnostic information is valuable. It can always be turned down when the process is operating normally.
Very true. I would also add that language specification/immutability and backward compatibility is very important too. There are some fine new languages in last 15+ years but most of them lack GUI's, tools, good standard library or stability (they keep changing specs and breaking syntax or design). They keep saying "but we added cool new feature X no other language has" and act surprised when popularity isn't going up after 10 years. I for one wouldn't use for anything serious language "with cool new feature X" if it can't give me full package for whole product life cycle and good maintainability.
Um cutesy? The author is just using the tools that have been made available to him. This is the kind of negativity I'm talking about.
my approach to legacy is: "don't" Though I guess if there is no choice in that department there is no way around warnings or maintaining legacy branches.
Why not revoke token? Give every token an id, put id in a collection of revoked tokens, token revoked?
That helped me a lot too. Thanks.
thanks for the reference.
Remember to add your community to https://github.com/golang/go/wiki/GoUserGroups
Not everything is a simple command. The main project I work on (Kubernetes) is large and complex, and it is frequently necessary to ask a user to increase logging to get sufficient info to diagnose a problem, but leaving that enabled all the time would be too noisy.
Being numeric means you can define it yourself, and it doesn't limit you to just one trace level. I frequently want to enable increasing levels of verbosity when tracing something hard. The loss of semantic meaning is what I find interesting
Still I don't think you find top games in Java. Minecraft doesn't really have high performance requirements.
For special cases like Kubernetes, using a more powerful 3rd party logging package might pay off. Even better if you write your own and avoid an extra dependency. But for the majority of cases I truly believe that the standard `log` package is more than sufficient and flexible enough. Yet somehow I see people easily dismissing it as worthless and "half-baked" which is something I cannot understand.
I don't follow it. If you write idiomatic Go you will eventually create garbage so you end-up with extra latency and extra memory requirements (that you wouldn't have in a non-GC language). As I said some games are doable in GC languages but that doesn't make GC a good fit for high performance games same as GC languages are not a good fit for embedded devices or signal processing. 
Off the top of my head: Minecraft, Fez, Bastion, and Axiom Verge. Several game engines are written entirely in C#. Also: https://unity3d.com/showcase/gallery In languages like C#, the GC only runs during allocation and allocation is easily avoided. In addition, the memory "wasted" by the GC is negligible. 
Some docstrings in your godoc to help teach us how to use the library would be great.
Thanks, I didn't know about that list. The Montreal Go meetup group was missing, so I added it.
&gt; Off the top of my head: Minecraft, Fez, Bastion, and Axiom Verge. It seems we disagree about what are games high performance requirements. I meant something like World of Warcraft or Assassin’s Creed rather than Minecraft or Fez. Now the latest bling in games is AR/VR. I fail to see a GC language in the AR/VR world where latency is quite "visible". &gt; In addition, the memory "wasted" by the GC is negligible. Apparently some people disagree, especially on devices(i.e. mobile devices) where memory is not cheap.[0] [0] https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009422.html
 context was not designed for this purpose. You can't stop people doing stupid things(unless you are willing to accept a big chunk of extra complexity). The information stored in context should be scoped/read only but Go doesn't have anything to enforce such rules.
No comments on Unity? You also seem to be confusing GPU and CPU performance requirements. Games like Minecraft have high CPU performance requirements. 2D games, especially those with physics, also tend to have high CPU performance requirements. Regarding your link, it's assuming that the GC is continuously running. Games made in languages that use a GC are not written like this. While performing my own performance benchmarks I have found the differences between C++ and C# memory consumption to be relatively insignificant, including mobile.
~~It's not wrong. However,~~ it's not easily tested, and it obscures the flow of data. ~~In small apps, it might make sense. In larger apps,~~ composing your types so that dependencies are made clear makes APIs and the code itself easier to consume. Edit to add: /u/quiI answered more directly regarding placing a pointer to a DB within the context type, and is correct. Don't do that in any size of project. I had answered as though the question was regarding a global pointer.
The biggest difference is that groupcache is a library, whereas Olivia aims to be a standalone application. I'll go a bit more into a difference and a similarity, though. So, from a cursory glance, it seems that groupcache functions similarly to Olivia, there's just a few differences: groupcache intermittently stores keys from remote nodes into its local cache. My goal in Olivia was to not implement something like this until I had an actual consensus algorithm in place--I'm currently leaning toward Raft--currently Olivia relies on key retrievals from remote nodes. However, once consensus can be established, each node will store the same data which will improve key retrieval speed. A similarity is that both seem to only store immutable objects and don't allow for updates (this will be changed in Olivia in 0.2.0 release). I may be incorrect about this for groupcache, but from what I saw this rings true.
&gt; Note: the use of the reflect library in Go is a touchy subject. On one hand it makes generic runtime encoders such as encoding/json possible and on the other hand it can be abused by developers who use it instead of using static type checking constructs. I find the use of reflect at the application level to generally be a poor choice. *mic drop*
No, I think it was initially an oversight.
Nice article, but I don't seem to spot anything for my library package. I'm pretty sure there are bound checks in the code, but it shows nothing. Does this only work for `main` packages?
Now ponder what guaranteeing atomic writes for interfaces would force to happen, underneath. Or, for full reductio ad absurdum, ponder atomic writes to a `var v [9000000]byte`.
Use the type analyzer of godoc: https://golang.org/lib/godoc/analysis/help.html
I did not know about this 😳
Yes, that's typically what you do, using the jti field. However, it requires some server-side state, which loses one of the key benefits of JWT.
Yes. 1) It's `Request.context`. Semantically, a mongodb connection isn't a part of a HTTP request. It has nothing to do with HTTP whatsoever. I see all this nastiness (`req.myDB`) in node.js codebases and it drives me crazy. 2) It's harder to test 3) It's unclear what the dependencies are to your server just from looking at the definition of it. You are relying on type casting to get your dependencies, which means you're throwing the compiler away. Do this type MyServer struct{ DepA mongo DepB redis } Now you can easily switch in dependencies, see what they are and the compiler can make sure you wired things up correctly. 
Well, the `io.Reader` interface is a) so small and b) so common that one can expect you to memorize it and recognize it.
E.g. conflicting diamond dependencies need manual resolution. And: Stuff like "requires at least 2.7.8 but not 2.9.1" is no guarantee that 2.9.7 won't break. The problem is "solvable" only by handpicking a global set of version of all packages, thoroughly test testing them all in combination and declaring victory for now.
That makes no sense. I have no idea why the golang team, working mostly at Google, would prefer not to have a product named Oracle.
ya, I get the reason. But then again, I really liked the old name of Go Ogle too (the old debugging tool name). But that's just me - I like names that play on other words 
You shouldn't care about the implementation,that's the point of interfaces. &gt; Likewise, os.File does not mention that it implements io.Reader you can use guru, check on google.
I even changed all my code! :)
I don't have an answer about code, but I have a caution in general. Watch out when parsing Received:, because although there's a sort of standard in the RFCs, in practice there is a wide variation in what information MTAs put in and how they do it. To write a robust parser you need to collect a message corpus (either a general one or for messages that you care about) and then test it against your code. You'll almost certainly find a lot of variation even among regular MTAs, never mind spammers (assuming you're dealing with general Internet email instead of something more predictable and controlled). This is a problem with all email message headers, of course, as there is all sorts of terrible software out there, but it's a larger than normal problem with Received: because it's generally not parsed by mail clients and so on. If an MTA does odd things with From: or Subject: or so on, people notice and complain, which limits the amount of creativity that programs exercise for those headers.
Me too. :)
I think wasm is absolutely the future, and I'm very excited to be able to go there! However, here's the roadmap. wasm itself is still a work in progress, and they are currently on the "MVP" part of their plan. They have made great progress in the last years, and there was recently an update where Chrome and Firefox (with an experimental feature flag enabled) can run an Angry Bots demo: https://webassembly.github.io/demo/ That said, they're still not done. See the "Roadmap" section on https://webassembly.github.io/ page. As you can see, a critical component for a garbage-collected language like Go to be able to be supported by wasm is named "GC/DOM integration" and is currently located in the "Future versions" section, after the "after MVP" section. As soon as that gets closer to reality, I absolutely think it will be a great time to start adding a wasm compile target to Go. However, as you can get a sense from that roadmap and the current status, it still seems to be some months/years away. Until then, I think GopherJS is our best to be able to start writing and experimenting with Go for frontend. It's already so complete and functional, and it lets you get a head start. So I cannot wait for wasm to make further progress, eventually leading to Go having it as a viable supported compile target. wasm has the backing of basically all major browsers, so I don't think it needs my individual help as much. Instead, I contribute to GopherJS which I think is our best bet intermediate solution.
https://twitter.com/enneff/status/752497537186091009
I've wondered about this too. You'd really think that there would be some online docs for this. "Here's the list of types that implement the X interface." "Here's the list of interfaces that the Y type implements."
I've only seen the robot one in the presentation: you might be able to extract it from the PDF: https://github.com/gophercon/2016-talks/blob/master/ReneeFrench-TheGoGopherACharacterStudy/gopherconfinal.pdf The punchcard / paper-tape one is from the "Go 5 Years" blog post: https://blog.golang.org/5years/gophers5th.jpg The gopher portrait (first image) is from https://reneefrench.blogspot.nl/2011/07/blog-post_31.html You could also ask her on Twitter: https://twitter.com/reneefrench
Ok, i might be missing something major here, but what are the benefits again? Don't get me wrong, i'd love to code frontend in GO, but don't i have to know JS in the first place anyways? So why not just code in JS? I mean...when i see something as simple as document.write("Hello world!"); translates to js.Global.Get("document").Call("write", "Hello world!") i'm wondering what exactly i'm gaining by writing it in Go instead of JS, which every web-dev should know anyways. Can someone shed in some light? Regards
There are 2 big categories where the benefits are clear. If you: - want to run existing Go code in the browser - want to share/reuse common functionality between backend and frontend, such as input validation, routing, page rendering But in addition to that, some people prefer the Go tooling (goimports), the familiar Go standard library, readable blocking code instead of callbacks, concurrency (not parallelism), the nice and clean documentation for packages, ability to write normal Go tests and benchmarks, compiler error messages, type safety (making it much easier to refactor Go code with confidence), etc. Yes, using the `github.com/gopherjs/gopherjs/js` package to interact with JavaScript APIs is slightly unpleasant, very similar to how using cgo and the "C" pseudo package isn't the nicest. But luckily that can be abstracted away by binding packages that expose nice high level idiomatic Go interfaces. Some examples: - WebSocket has `Dial` that exposes `net.Conn` interface: https://godoc.org/github.com/gopherjs/websocket - WebGL (isomorphic library): https://godoc.org/github.com/goxjs/gl - localStorage API: https://godoc.org/github.com/go-humble/locstor Finally, if you want to make an XHR request, the `net/http` package supports the HTTP client, so you can just do the usual `resp, err := http.Get(url)`. And if your browser supports Fetch API, then it can even do streaming response bodies. I hope that gives you some ideas! I'm sure there are many other cool uses we haven't discovered yet.
&gt; Yup, cool - no coupling between package A and B. IMO, the coupling still exists. All that happened was that it became implicit and hidden. You can add yet more code into your own package to avoid importing another, but you can't reasonably expect that to work without knowledge of the other package. I'd even go so far as to say it's actually worse than the original problem because now that the meaning of the error is implicit, you're left relying on your knowledge of the package's implementation.
`io.Reader` was just an example. He's asking for a general solution to this problem.
Wouldn't be feasible to compile the runtime/GOGC to wasm(until wasm gets GC support)? The size of the payload would increase but that may not be a big problem if it's cached (i.e. using a CDN source). GopherJS creates large payloads anyway. Concerning the DOM, that's an ugly truth but as far as I understood it is possible to use a thin JS proxy to access the DOM even before wasm gets native access to it. 
Thank You! I will take a look.
That's useless considering that I need to parse specific SMTP headers(i.e. Received) not the headers provided by net/mail(RFC 5322).
Would be possible to generate these bindings from WebIDL[1] files/definitions instead to actually manually develop them? Mozilla seems to use that kind of approach[0](I don't know about other vendors) and as far as I understand WebAssembly will use the WebIDL as well to expose the DOM/Web APIs(whenever that happens) [0] http://gecko.readthedocs.io/en/latest/dom/bindings/webidl/ [1] https://en.wikipedia.org/wiki/Web_IDL
I thought you were merely trying to get your hands on the 'received' header, which is exactly what the code I provided will allow you to do. Example: https://play.golang.org/p/SxefKNZ9Dk If you request "RFC822.HEADER" as a part of your IMAP fetch request, it will be there. When it comes to actually parsing the header itself, cks is right, MTA servers across the world are not very good at sticking to the RFCs.
&gt;&gt; I thought you were merely trying to get your hands on the 'received' header No, I already know how to do that. &gt;&gt; When it comes to actually parsing the header itself, cks is right, MTA servers across the world are not very good at sticking to the RFCs. I understand, though I hoped there was a reference implementation that I can use. At least the MDA would comply with the RFC as I control it so I could still make use of some data.
Time to build some micro services.
RubyGems alone will give you version breakages, yes, because it fetches the latest versions. What you want is [bundler](http://bundler.io/) + RubyGems. And what I want in Go packaging is something like bundler.
Good. I just want bundler but for Go, using the existing `vendor` directory support, with no goddamn YAML to write.
Dave's talk made me really think. He presented some new ideas that are interesting. Errors that indicate behaviour to the caller, such as retrying. But it isn't clear that I should abandon the approach used in the standard library for something new. I haven't changed any of my libraries as I wasn't sold on this either. Certainly his errors package has some handy features like wrap and unwrap -- and with stack traces too.
Learn Go is aiming at new programmers who haven't used compiled languages like C before. It builds up incrementally, only using language features once they are introduced. It doesn't go in depth on advanced topics like concurrency (see Go in Action) or reflection and cgo (see The Go Programming Language). It could also be a fun book for an experienced programmer to walk through with a son or daughter who is interested in programming.
Another cute acrostic to consider when doing code reviews is DRY. I don't think there will be 500,000 developers working in Go 1.x, without significant improvements to the ecosystem. The tooling is spectacular if you are optimizing for performance, but most people aren't. Instead they are optimizing for time to market, and Go isn't the best tool for the job here.
&gt; I'm sure you would need half of that if it would be written in C or C++. So we went from "Minecraft doesn't really have high performance requirements" to "If it was written in C++ it would need half the requirements"... I see ... &gt; The success of the game doesn't say much about the technology Obviously not but this is a reply to you saying "I don't think you find top games in Java". So as you can see, Minecraft is the definition of top and still written in Java. &gt; So if you get in the games development I think it makes sense to use the best tools that you can carry on based on the requirements I agree on that but here we are talking about virgin territory (Game development in Go). Dismissing it without sufficient proof except that (it has gc so nope) is not very helpful. I think we can all agree here that Go is a success on the problem domain that it was designed for. The majority of gophers prefer writing Go because of it's simplicity, robustness, safety, portability, easiness of cross compilation, concurrency, great tooling, readability etc. Bringing the great strengths of Go in game development would be amazing and not just for gophers.
Version hell isn't caused by the existence of tools allowing you to install specific versions of things. It's caused by a culture of demanding bleeding-edge versions of everything, or special cherry-picked versions, rather than attempting to be robust. It's largely specific to the Ruby on Rails community -- I went through the entire Ruby 1.x to 2.x transition without anything significant breaking outside of Rails applications. It also makes a difference how big the community is. Go has already had some significant churn around http Handlers, what with multiple frameworks extending Handlers, then Context being introduced, and now a new Context-enabled Handler to replace the third party extended Handler interfaces. As the language becomes more popular we'll probably see more of that, which will tend to cause version conflicts.
Hiding the error behind an implicit non compile check behavior seems well error prone. If we added the error behaviors to the package as public then we get more API surface, but at least its compiler checked. We're asking for informal consensus on a set of names, that is a hard problem to solve. Formal is pretty bureaucratic (dns,icann). I don't have any better ideas about it, but I'd think having the error interfaces specified is better then not.
I'm currently writing a book that uses The Go Playground for the first 23 chapters. A web browser is all you need when just starting out. https://yng.mn/learngolang
&lt;&lt; So we went from "Minecraft doesn't really have high performance requirements" to "If it was written in C++ it would need half the requirements"... I see ... The point is that Minecraft affords to waste resources because it doesn't have high performance requirements. I don't know how else to say it. Written in a non-GC language (i.e. C++, C, Rust whatever) it would require less resources. However if its requirements are minimal doubling them is not a problem. &lt;&lt; Obviously not but this is a reply to you saying "I don't think you find top games in Java". So as you can see, Minecraft is the definition of top and still written in Java. If Minecraft is the pinnacle of game dev for you I'm sure you can find top games in JavaScript and perhaps few years ago you could find few in Flash too. &lt;&lt; I agree on that but here we are talking about virgin territory (Game development in Go). Dismissing it without sufficient proof except that (it has gc so nope) is not very helpful. I think some tasks are just not a good fit for GC languages so efforts to promote them as solutions seem wrong to me. Development of high performance games is one of these tasks. Go is a GC language so it's not really virgin territory. You can throw more resources to coupe with the GC inefficiency(Minecraft's case) but that doesn't make it a best practice/good solution. Chances are that you start the development with a GC language to find out later that you need to switch to a more efficient/non-GC language and that may ruin your project/business. If there was a way to eschew the garbage collection I would have no problem to recommend Go(i.e. use GC most of the time and disable/eschew it on critical parts) but it's not the case. To sum it up: If you are fine with extra latency and inefficiency introduced by the GC then Go may work for you. 
Actually unrelated. We have little contact with the gRPC product managers. 
Too bad there is no _pure_ (rest-ish) json over http solution built on grcp. There is the grcp-gateway project, but it's a json http layer in front of grcp, need opening 2 ports, one for grcp and one for http, instead of directly calling the generated code.
I suspect DRY causes more damage than good.
I work in the gRPC team and was not aware of this proposal until it was published. :)
When taken to the extreme it gets really stupid really fast. This is not unique to DRY, by the way, or even to programming. It seems to be the case for any simple basic (good) idea. It's a general "rule" of the universe that I have observed (exceptions may apply, but thus far I haven't seen any).
I will never understand how one big try/catch block around a bunch of code is a good idea. If you handle each type of exception with its own catch then you haven't saved that much typing over the if err... I prefer that nothing short of a panic interrupt my code flow and that I explicitly decide what happens on an error. 
What is so bad about python? I find python much more enjoyable than ruby or javascript.
&gt; The most obvious use case for parth is when working with http.Request.URL.Path within an http.Handler. parth is fast enough that it can be used 20+ times when compared to similar router-parameter/Context usage. Why pass data that is already being passed? The request type holds URL data and parth loves handling it! Additionally, parth takes care of parsing segments into the types actually needed. It's not only fast, it does more, and requires less code. Obviously, if the data is needed within the Context instance, it's simple enough to pass it in. This approach also simplifies testing relative to the other options.
Hmm... I totally agree with you, dependencies break your neck. But often, the dependency is there anyways. If you copied the code, it's a hidden dependency - if you refactored out a commonly used class/module/library/whatever, it's at least made explicit. What you describe sounds like if the software's architecture had some other problems. Usually, in a clean architecture, one shouldn't be able to introduce so many dependencies without breaking the architectures principles...? (Dependency Inversion is a good example of how to avoid such tight coupling between different parts of the software.)
That's a myth. The license itself says no such thing, neither does the case law.
You don't need two ports. See my blog post and code: https://coreos.com/blog/gRPC-protobufs-swagger.html
Mods, Why was the content of my question removed?
Have you completed [Go tour](https://tour.golang.org/welcome/1)?
I've come to really love this feature, though it bugged me initially. What I've done (I'm using IntelliJ) is to set up a FileWatcher that calls goimports on save. Works like a dream. http://jen20.com/2015/09/14/gofmt-or-goimports-in-intellij.html
The way you're receiving the channels is incorrect. `select` is used to check if any channel is available in a list of channels. You're using the same channel to write in `HTTPHandling`, which is satisfied by the first select, which then again calls `HTTPHandling`. Few things to remember, * channels don't care how many people are listening. The first one to receive wins. In this case, the first one is always winning ``` select { case queryResult := &lt;- c1: log.Println(queryResult) HTTPHandling(queryResult, c1) ``` * You should use two different channels to communicate. * When using multiple channels, beware that writing to channel is blocking. So if another side can't read then it will block. Instead use buffered channels. * Use a exit channel so your go-routines can shut down resources Not related but, * Try and return `error` for methods that hit DBs e.g. `UpdatePosted` * code blocks that hit external resources will panic. try and capture that via `defer` so you can take appropriate actions (either re raise panic, log or graceful shutdown) Here is a pseudo code based off of your code (with comments) https://play.golang.org/p/KlLHu1Fqj7 
The Go tour was already mentioned. There's also the Go exercises on [Excercism.io](http://exercism.io) (which has the benefit of getting feedback to your solutions), and [Go Koans](https://github.com/cdarwin/go-koans). Were you looking for something different?
The project as a whole goes way beyond just dig functionality: https://github.com/mehrdadrad/mylg This is cool, thanks for sharing!
Thank you very much! Is it safe to say that buffered channels restrict the number of concurrent calls to the DB/http requests (respectively) to one? That seems nifty. As far as exiting, I think you're right. log.Fatal() seemed a bit excessive. If I were to use an exit channel with the worker, how might the exit channel actually stop the worker? It's part of the reason I used log.Fatal(), but I'm having a hard time seeing how passing something to an exit channel would stop a given worker's goroutine. Also, your repo is really sweet. For newer folks, having a sense of concurrency patterns is really helpful; those videos are a bit handwave-y sometimes (which is good), but it is hard for them to have this level of documentation/exercise. 
awesome work. Great that it can be called programatically or via CLI
&gt; I don't know very many people who want rcp these days. He was making a joke about the misspelling "rcp", which could meaning [anything](https://en.wikipedia.org/wiki/RCP) really.
Operation Go: http://gocode.io
In the di link they don't just embed the interface in a struct like you did with geometry. They add a field to the struct of that type. This allows that particular field to hold any concrete type that satisfies the interface type.
&gt; Dig command What is that, and how is it used? 
Each goroutine has its own stack. That means it has an exclusive piece of memory only it can access. That's where arguments and local variables of functions running inside that goroutine are stored. So when you create a goroutine with `go func(x, y, z T) { ... }(x, y, z)`, x, y, and z are _copied_ to the new goroutine's stack. Also, all goroutines have access to the heap, which is a piece of memory shared throughout the whole process (in the OS sense of "process"). So if you do this: a := new(int) go func() { *a = 123 }() go func() { *a = 456 }() go func() { fmt.Println(*a) }() `a` is then a pointer to an int in the heap, and all three new goroutines read and write to the same piece of memory. That's generally unsafe, though, because if goroutines read and write to the same location at the same time bad things can happen. You avoid that either by using [package sync](https://godoc.org/sync), or, rather than accessing common memory directly, communicate references to it through channels. Channels are a built-in, special kind of reference that enable a model of concurrency not that different to Erlang's model, and you can most of the time arrange higher-level designs with them so that these concerns are abstracted away. But you still can get into trouble if you send via channels references that several goroutines can mutate concurrently. So the key difference from Erlang is that there is a common heap that doesn't belong to any particular goroutine, and you have to arrange things so that goroutines use it safely. Hope this answered your question.
Seems like a whole lot of setup before you get to a workable config management solution. Etcd seems like a very heavy dependency for something like this. Getting etcd set up in a cluster is kind of a pain in the ass and something I would use config management to do rather than it be a prerequisite to get my config manager running. As much as I like the idea of using a real programming language for the config recipe rather than yaml, one thing ansible got right from a first-run experience point of view was using SSH to push config out and no bootstrapping required to install agents, etcd, or anything else. 
Oh man, pRPC can change my life. I searched all related terms in google, all I got was grpc-gateway. **There is even no mention of pRPC in that blog.** It seems like a neat project. Is it a dead project? The github seem alive. if pRPC exists, why do we even have grpc-gateway?
How is it compared to pRPC discussed here? https://www.reddit.com/r/golang/comments/4z7kcp/grpc_is_now_officially_ready_for_production_use/d6tsfso Why should I choose grpc-gateway over prpc?
Standalone mode does not require anything in order to use it. Just run `gructl apply` and pass it a Lua module to execute. What you say about Ansible is true, although eventually you end up installing various Python modules or tools on the target systems in order to use some functionality. For an agent-less system it does come with some requirements as well, so I don't think that's way too different than other agent-based systems.
Thanks
DRY is an important principle, indeed but it is not the only important principle. The tendency I've notice is the invention of a solely technical abstraction for the sake of DRY. I think it is very important to not repeat application logic, but I find abstractions of purely technical nature more than I find abstractions of real application logic. Often times these abstractions serve only to reduce the readability of your application logic and create unwarranted dependencies. Go isn't a language that promotes DRY technical abstractions. That's honestly one of the things I love most about Go, with the lack of generics, the state of dependency management it makes you think about how the application should function, and less about what libraries, abstractions and ... you should use. -- edit removed off topic thought --
I've built a similar prototype without using docker: https://github.com/shazow/go-selfcompile
No problem, Go Luck Have Fun
these focus only on the things that can trip you up and as such can be rather convoluted. consider visiting this site last: http://go-traps.appspot.com/
(In the US) copyright exists whether you state so or not. The idea of putting a header comment in every single source file dates from the era of RCS/CVS `$Id$` headers, writing a changelog in the file too (`$Log$`), and people regularly printing source code for reading.
I think it's also worth mentioning that a goroutine's stack is much smaller than a normal OS thread stack (that's why you can have so many of them). If more stack is needed for a particular routine it's my understanding that more memory for it will be allocated on demand. The drawback to this is that you can have a lot of churn if your routines frequently exceed the initial stack size. I believe this initial size is tunable at least :)
For old Unix nerds, "rcp" specifically means the "remote copy" program that was part of the rsh suite of tools — unencrypted, often unauthenticated remote login and file transfer, basically insecure for any practical purpose.
You have to realize that *virtualenv* or *rvm* were created to correct an existing problem. They are band-aids slapped on to address flaws in the design of the language/versioning/packaging they support. This is important to consider, because go's package management and api design strategy is crafted to avoid having to worry about this. Just run the latest go. It's fully backwards compatible by design. There's no need for multiple versions of go to be installed. So far, each new release entirely obsoletes the previous release. Use go's path structure properly, put your stuff in the right places, and you won't have problems. [edit: clarity]
Minecraft clones written in C++ don't have significantly better performance. The two biggest game engines on the planet have a GC. How do games running at 4K 120fps not have "near real-time requirements"?
See https://play.golang.org/p/iLUQYHRJ4L https://mholt.github.io/json-to-go/ Is really helpful when you have JSON and need to quickly declare the struct. You can refactor the output as you want in your code then. Here is the source in case the link ever dies: package main import ( "encoding/json" "fmt" ) type AutoGenerated struct { RequestProcessingTime int `json:"requestProcessingTime"` Transactions []struct { Transaction string `json:"transaction"` Attachment struct { Message string `json:"message"` } `json:"attachment"` } `json:"transactions"` } func main() { jStr := `{"requestProcessingTime":1,"transactions":[{"transaction":"1111111111","attachment":{"message":"text of message"}},{"transaction":"2222222222","attachment":{"message":"text of message"}}]}` var ag AutoGenerated if err := json.Unmarshal([]byte(jStr), &amp;ag); err != nil { fmt.Println(err) } fmt.Println(ag) for _, t := range ag.Transactions { fmt.Println(t.Transaction) fmt.Println(t.Attachment.Message) } } Looking at what you provided, it sounds like you were trying to do `for _, t := range transactions` instead of `for _, t := range transactions.Transactions` in your code.
&gt;&gt;Looking at what you provided, it sounds like you were trying to do for _, t := range transactions instead of for _, t := range transactions.Transactions in your code. Yes, I did exactly that and it didn't iterate. Silly mistake but I am getting used to Golang. Thank you for the links.
Whenever anyone uses a lot of reflection, it probably means they're trying to use Go the way they use some other language. There's probably (not always, but often) a better way to do it. In general, you shouldn't ever care what *type* something is. It seems like you should be able to do whatever it is you're doing with interfaces, and just reversing where you put the logic about choosing which values to act on.... but of course it's impossible for me to really understand without seeing the code. 
No problem. Glad it helped!
I now got two other problems in the neighboring thread :)
But the games built on it are written in C#.
Both Unreal and Unity are written in C++. There is no built-in GC in C++ so whatever Unreal provides it's only a half baked GC(most likely using smart pointers).
thank you, it worked but I had to explicitly set length to 0, compiler complained of length missing data := make([]map[string]string, 0) and data = append(data, make(map[string]string)) these did the trick, the error of undefined 'data' is gone too.
Well I guess you can write games in any language then but you have all the drawbacks FFI/wrapping such additional performance penalty to access the API through a wrapper/FFI and suboptimal development experience. On top of that you also have the GC performance penalty of the client language(i.e. C#) as well. Go on mobile is a good example of these drawbacks. To close this I would just quote the OP and replace "Go" with any GC language "Go is probably not (at least yet) an ideal language for AAA 3D game development, however, it's very suitable for lower-budget 2D (or sometimes 3D) games."
&gt; Are there benchmarks? Maybe the implementation was really bad but it's no secret that GC languages are less efficient than non-gc languages(unless you misuse them). There are but I'm too lazy to find them. If the performance was significantly better in any meaningful way then those games would have gained a lot of traction by now. &gt; Which are these these game engines? As far as I know all the top game engines are written in C/C++. If you consider smart pointers being a GC then we have a apple vs oranges comparison. You should also be aware that while on C++ you can use smart pointers to get a kind of GC you can't disable GC in Go to get deterministic performance. Both Unity and Unreal have a GC. Unity games are written in C# and C# has a GC. Unreal has an optional GC (not smart pointers). Unreal also uses Blueprints, a VSL. &gt; Is 120fps a constant? How can you do that if the garbage collection takes let's say a 40ms pause every x seconds? Because it doesn't. Most games written in C# will not allocate during gameplay and as a result the GC will never run. In addition, stalls created by the GC are heavily dependent on the size and complexity of the ephemeral segment. Even if a game performs small allocations between frames, the GC will only suspend threads for less than a millisecond.
Oh right. I updated my code to reflect the proper code (sorry about the bug)
Sent a private message
You could also not use `make` at all. Just `var data []map[string]string`. It gets zeroed, so it's nil, and appending to a `nil` slice is pretty much the same as appending to a zero-length slice.
This should be in everyone's bookmarks.
If you have projects with incompatible dependency versions, then `godeps` (or vendoring) seems to be the de facto tool to manage that situation. But, just for Go versions, as /u/linotype says they are mostly backwards-compatible (I have been hit by one breaking change, but they seem very rare).
This starts off as a useful catalog of gotchas and devolves into a set of code riddles. Also the significance of the color-coded bullets is not clear.
I believe a zero value for an array is an empty array, not nil. Otherwise you are correct, you could just declare the variable instead of using make. 
&gt; I believe a zero value for an array is an empty array, not nil. Otherwise you are correct, you could just declare the variable instead of using make. But it's not an *array*, it's a *slice* as indicated by the absence of a number between the square brackets in `var data []...`. https://blog.golang.org/go-slices-usage-and-internals
Hopefully this informs some that didn't know, but this was released a while ago
Why comments? This could be driven from a test.
&gt;&gt; Even if a game performs small allocations between frames, the GC will only suspend threads for less than a millisecond. What makes you think GC suspends threads for less than a millisecond? Each GC language has its own algorithm which makes a trade between latency and throughput. For example I've experienced even 500 ms latency on previous Go GC releases. What makes you think Unity would prevent the Go GC to take a 500 ms pause? &gt;&gt; Most games written in C# will not allocate during gameplay and as a result the GC will never run. So the solution for a GC language is to use globals and never allocate during game-play...someone should have told me that from the beginning. 
&gt; What makes you think GC suspends threads for less than a millisecond? I'm debugging a game right now and watching it happen. &gt; Each GC language I'm specifically talking about C# game development. &gt; use globals You don't need globals. You just don't allocate during gameplay.
Yes! Just switched from Godep to Glide recently. I will be using this all the time. 
To me this sounds like a stateful use of https://godoc.org/testing/quick#CheckEqual where the generated args to `f` and `g` would be what method to call with what arguments.
For someone who claims it's striding for beautiful code you sure do miss the point of having a much more readable code without the else block. But I guess beauty is in the eyes of the beholder. 
Yeah, fairly easy to find non-containerized solutions to this. However, I won't touch a project without a docker container setup these days. It's so easy to use and gives you close to a real world scenario than just running everything locally.
&gt; It's just I am curious if maybe one day I can download a newer version, recompile my source code and have a even speedier service. Like when you had Go 1.6 and you downloaded Go 1.7? SSA was added but it's only one of many optimizations that is used also in other languages. You can count that this will happen again many times. There is a LOT of space for more optimizations.
Why don't you just look at the release notes for the recently-released 1.7 version of the compiler: https://tip.golang.org/doc/go1.7#performance
I still like haproxy for this. shutting down is worry-free when you know the app is no longer receiving traffic (and has completed pending connections)
Which compiler? There are already two. If Go is successful in the long run, I expect to see many compilers for it eventually. Small natively compiled languages are not like large bytecode languages which are often tied to a specific implementation in practice. To answer your question, Go's reference compiler has had continual performance improvements since the first release. 
Go Guru (https://godoc.org/golang.org/x/tools/cmd/guru) used to be called Go Oracle. Both were/are "slow", but afaik nothing horrid. Might you try to find a Go Guru package for emacs? Here's something: https://github.com/golang/tools/blob/master/cmd/guru/go-guru.el
FYI: The language is called Go. Not Golang or GoLang.
Thank you, I'll try first.
This may not be reasoning about it correctly, but I used a button on the web app that POSTed and killed everything, which seemed to work okay. 
Interesting, I was just working on this a while back and decided to shelve it exactly because Windows was being a pain. I'm probably not going to pick it up any time soon but I'll keep a watch on your repository to see if you ever manage to make Windows play nice.
ohdeargodwhy?
A well-thought out article on lessons from debugging a programming error around Go's idiomatic way of error handling. Still, I think the problem is not if versus if/else. Rather, it is if err != nil { // error handling } // depending on the error handling, possibly execute this versus if err != nil { // error handling return } // if and only if there isn't an error, execute this In making the `return` statement within the error handling block optional, you create a situation where the "if and only if" assertion does not hold anymore. Then you call if/else to the rescue, which is a valid option but IMHO the "if error then return" logic is as correct as if/else.
Infinite power. &lt;click&gt; Muahahaharharrrrharrrrr! Die you evil server processes!
Generally a good article, go has it's good sides and bad sides. Tho I'd like to tack onto the stackframe issue; I personally frown upon recursion. IMO it's better to iterate at a slight performance penalty than to recurse. Usually the former has a rather static/minimal memory need while recursion likes to use a lot of memory (partly caused by so many stack-frames) Go encourages iteration by limiting debugging to 100 stack frames and as a side effect, you don't get the usual java-problem of being 2000 frames deep into the callstack when errors are handled, go progams will be relatively flat.
I'm fairly sure nothing there is hostile nor humiliating, maybe condescending at best, if you want to assume evil intent from me. And yes, correct code should be a priority, that not questionable. Beauty (as described/understood by me), however, is.
You might wanna try https://github.com/dz0ny/gobu#example-starting-new-project. It setups env for you (you can also try different versions of go) and from there you can use any other tool, like govendor, glide ... edit: tools follows all current go practises, just to clarify that
I use https://github.com/facebookgo/grace
I'd also use signal.Notify -&gt; http://pastebin.com/Mqd7xE8b
What's wrong with a RESTful API done in Go and dirty checking it using ajax?
I vouch for that
Playing around, I made this - https://github.com/daved/gracefulex
The article makes good points about correctness, though. Escaping from the error handling block is definitely a non-negligible source of bugs. For single "return" statements, it won't matter much, but I can totally imagine a bug like "goto fail" happen is practice.
I don't understand how one would authenticate someone with a QR, shouldn't it be the user who provides the QR code instead ? 
You encode an URL with a login-code into the QR code, the phone visits that URL and that triggers the authentication workflow. Then it's a matter of frontend-whatever to make browser refresh itself (e.g. via websockets or the like) and are done. The problem isn't terribly go-specfic. From the go-side, you just need a way to generate the image and then have a simple web-app that shows the image and listens for the login-sidechannel.
How about a nonce comment or const? _ = "asdfjkl;" // Invalidates playground cache, please ignore.
This is a little known project by Google built for CI of Chromium. Despite targeting a specific project, it's a general project to be used for any GAE Go project. This is an idiomatic equivalent of python ndb. I really like functionalities like assigning the ID automatically (who wouldn't want that?): type CoolStruct struct { ID `gae:"$id"` Value string } Or, that you can have entity level cache control like: - `gae:"$dscache.enable,&lt;true|false&gt;"` - whether or not this entity should be cached at all. If ommitted, dscache defaults to true. - `gae:"$dscache.expiration,#seconds"` - the number of seconds of persistance to use when this item is cached. 0 is infinite. If omitted, defaults to 0.
check the user history. Two posts, both pictures - no comments. Dud
I believe it is at https://www.udemy.com/ultimate-go-programming-tutorial/
It's a love/hate relationship.
The thing that makes this particular problem hard is that QR codes only have a capacity of a few hundred bytes. My suggestion would be to look at the [OpenID Connect standard](https://openid.net/specs/openid-connect-core-1_0.html), to see how that works. It's built on OAuth2, but OAuth itself offers way too many options and not enough guidance. As part of the flow, the server sends the client a [successful authentication response](https://openid.net/specs/openid-connect-core-1_0.html#AuthResponse) via GET or POST. The response contains a one-time code and state, which are short enough to encode as QR. (The state value is to protect against CSRF.) The client can then use the code and state to make a web service request against a TLS-verified endpoint, and get issued a full size JWT authentication token, which in practice would be too large for a QR code. You would basically have your web site verify the user, then issue a code and state value pair as a QR code. The client would then treat those exactly as if it had received them as an HTTP GET, and perform the rest of the flow to receive a JWT token it could then use for future requests. There are Go libraries for JWT, including signing and encryption of tokens. The actual QR code image could be generated using a JavaScript library in the browser, to make that easy. That just leaves you with the problem of understanding OAuth flows :-)
alternatively: http://labix.org/gopkg.in
Probably your ideal way to handle this would be to write incoming data to some type of aggregator that does have push capability in addition to just writing it to MSSQL. A go app (or any other) with a websocket could then handle pushing the data out in real time.
I didn't know it, thank you for the information :) It's good to see a good design for this kind of stuff!
Not that I know, but you can create one and become famous.
Me neither, it just didn't match my expectations based on the title.
Actually I used Gore Today at work to test some time parsing methods. I actually like to use the REPL sometimes
&gt; There is a LOT of space for more optimizations. What may be the next low hanging fruits so far?
Also check [gvt](https://github.com/FiloSottile/gvt). Their functionality is similar but gvt also works for symbolic links that I tend to use to access my projects faster.
do you have links to the definition of the protocol you used to write it? I'll give it a go
Is that all it takes to become famous? thank you! My eyes are shiny with possibilities!! 
Check https://github.com/avelino/awesome-go#command-line Some libraries in the Advanced Console UIs are quite impressive.
&gt; REPLs are an awfully poor fit for a static, compiled language wtf?..have you heard about scala,haskell,f#...if the languages is static compiled or not is totally unimportant
I have one for you. Build an agent that runs as a service / daemon. Should be possible to run in a slave / master mode. From master mode try to transfer files to the agent ... optimize. Make a selfupdate feature so an agent can poll a new version of self from the master
Yes - it works. I have a version of my web tools that is backed by an Oracle 11 database.
Google's banking on the community to see how far we can go\^H\^H run with this, and create our own swag. jk, bring back the Gopher plushies. 
Why jk? Why not [make your own gopher](https://oylenshpeegul.wordpress.com/2013/10/07/go-gopher/)? Or [Glenda](https://oylenshpeegul.wordpress.com/2013/10/13/glenda-the-plan-9-bunny/)? Or [dancing gopher](https://oylenshpeegul.wordpress.com/2013/10/16/all-yarn-gopher/)?
Yeah I agree. Sure, you can dislike the fact that there's no assertion or the way the stack trace is printed but 1) one's opinion is not superior to any other, let many others who really know what they're doing 2) there are others languages out there 3) the the author is just childish about it 4) the author actually miss out the while point of Go: those choices were made in line with Go's philosophy. (I can draw a comparison to a very frequent complaint in another language: If you find yourself whining about NodeJs asynchronous nature and the fact there's only one thread, you're working against the language!)
 if g, e := uppercase("bar"), "BAR"; g != e { t.Errorf("wrong uppercase: %q != %q", g, e) } 
Original plushies in limited supply? Time to start gophercoin! Rent a VM in the cloud for 0.04 gophers per month!
When a simple loop will do, why bother adding a complicated implementation feature?
I would love if I got something Go related in India. Everything seems to be US only.
Wow. This is helpful thanks. I do understand OAuth flow and I was actually thinking of powering the whole using using OAuth under the hood and QR just being a part of that system. I'm much familiar with OpenID standard, I'll definitely take a look at that.
Whoa! I just mentally len()'d your name. Did you come up with that or see that somewhere? In the case of the former, you're weird and I dig it! 😀
I'm learning by making a web application with the eventual goal of building a bot for Discord. I'm digging it so far, just need more time to devote to it.
Find something in your life you do that you know is automatable or something a tool can greatly increase your quality of life, and just make it :). I find learning languages with small projects I'm passionate about actually finishing to be the best way to make me learn the language since I actually want to make a thing and have it done quickly and simple. I.e for me I was admining a game server that consistantly gets Hackers and I just made the logs print everything and made a tool to communicate to the rcon in its protocol over udp and read the log files as they change and did pattern matching to detect hacks so I didn't have to do anything anymore, put a big smile on my face xD and I still work on it and add more features and rewrite it as I learn more about golang. 
You could try some coding challenges, like https://projecteuler.net/ or http://adventofcode.com/ Advent of Code is actually how I got my feet wet in go. It is great. 
It was stupid the first time it was shared, and still is.
https://atom.io/packages/godoc might be what you're looking for 
This wasn't the one I was referring to, but this definitely looks helpful. I can settle for this if no one else has any idea what I'm talking about :P Thank you.
TennTenn has [awesome images](https://github.com/tenntenn/gopher-stickers) under CC3-Attributions. However, not quite sure what the proper way to attribute would be, if you want to print it onto a T-Shirt. Maybe put "by tenntenn" near the image? I guess the safest way is just to ask what the author prefers. Original Gopher images by Renee French are in [Go repository](https://github.com/golang/go/tree/master/doc/gopher) are under CC3-Attribution. Of course, buy their merchandise/art directly, if you are able to... that way you support the artists. I have some images [here](https://github.com/egonelbre/gophers), look for `.svg` files, those should be good for t-shirts. Colors are adjustable. You can use those to create a t-shirt near a local shop of your preference. List of some of my svgs at the time of posting: [ballet](https://github.com/egonelbre/gophers/blob/master/arts/ballet.svg), [hugging-docker](https://github.com/egonelbre/gophers/blob/master/friends/hugging-docker.svg), [power-to-the-masses](https://github.com/egonelbre/gophers/blob/master/science/power-to-the-masses.svg), [rocket](https://github.com/egonelbre/gophers/blob/master/science/rocket.svg). I haven't yet, updated the collage. *(There are also hand-drawings that I haven't had time to vectorize, but drop a note on issues/twitter, so I can prioritize "most wanted")*
That's the one! Thank you! On that note, have you tried it, is it any good?
There is no "problem".
I think the masses have spoken loudly about this. If the People In Charge were to release Gopher plushies , tees and stickers, then the money made could quite happily be sent to some worthwhile charity. (MSF, UNHCR etc.) If this happens I will happily buy one of each color gopher plushy, one t-shirt, and a few stickers. They need to be available world wide, not just in the US.
I'd heard that https://github.com/braintree/manners was a decent package for this.
The last few versions of the Go compiler have included a complete re-write from C to Go, an initial clean up of the (machine generated) compiler code, and a change to SSA. The fruits are not so low hanging. The compiler is now at the point where the Go authors can start *really* looking at the bottlenecks. I'd expect that the next couple of versions will have improvements in compile time, binary size, and code performance. The fact that there is room for improvement across all of these metrics, despite all of them being pretty damn good to begin with, is absolutely amazing. We end up with small binaries, fast compile times, and great performance. This is holy grail territory for those of us who've been dealing with other languages for the last few decades :-)_
If you have a credit card get a T1.micro instance from Amazon, 1 year for free.
use heroku.com if you don't have any operational experience 
go is usually not used in a SaaS environment like PHP is. You can find either PaaS environments (like, for example, [Google App Engine](https://cloud.google.com/appengine) or heroku) or IaaS environments (like [Google Compute Engine](https://cloud.google.com/compute) or Amazon EC2). The best choice depends on your requirements.
https://run.pivotal.io/ has a go-buildpack
Interesting point, although from my experience when you recommend any practice you risk people getting dogmatic about it. Exactly why we need responses like yours :) Out of interest, what do you mean by "bike shedding"? I've never heard that term before.
When using recursion, you can use single assignment variables (and in theory be more mathematically pure, without side effects, easier debugging, etc). With iteration, at least your counter is going to be modified. Of course, Golang is not a language where you would like to practice the former.
This won't be terribly exciting or advanced... But here's what I do Pipeline: run tests/build every commit. Changes to `develop` deploys to a test environment, `master` to prod. Tags generate all the binaries and add them to the github release Platform: cloud foundry (very similar to heroku). Using the binary buildpack DB: Postgres or MySQL. Hosted remotely. 12 factor makes "where" unimportant - just read connection info from the environment Migrations: at application start. Can be via .sh or the binary Environment: used as arguments instead of the app doing `os.Getenv`. For example `./app serve --db "${DB_HOST}" --port "${PORT}" State sync: none. Make conscious effort to be as stateless as possible. If you need to share info real time use a queue. Try to make sure each running instance doesn't know about any other instances
Very nice. The provably fair number generation seems like it could be a bit cleaner. Have you seen this? https://dicesites.com/provably-fair I wrote a very simple example in Go if you're interested: https://github.com/tyler-smith/provablyfair-dice 