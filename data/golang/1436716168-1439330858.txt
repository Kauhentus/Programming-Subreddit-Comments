&gt; One thing I would keep in mind is what happens if the web.go crashes or gets restarted. Are success/failure messages lost while it's down? Should transcode.go be tied up trying to send a response to web.go while it's unreachable? That's a good point. I guess trying to send the request until it gets a 200 could work. Or you send the result to another task system that retries sending the request every minute or so until it's successful. 
Disclaimer: I work for AWS, and I work with the maintainers of aws/aws-sdk-go I recommend the AWS SDK for Go (https://github.com/aws/aws-sdk-go). The caution on the README is warning that they are in a developer preview and there may be changes from now until a stable 1.0 release. That said, it has the broadest service coverage, is updated when service update, is sponsored by AWS, and is well tested.
I've used aws/aws-sdk-go and I recommend, for the moment the only must is that you vendor it. I've tried all others from Canonical, etc, the Amazon one is the official one, the one that supports more services and utilities, and it's also aiming to be idiomatic and polished.
First of all, thanks for a detailed explanation. And now that I understand your outlook, allow me to offer a rebuttal :) I think that since Rust already features pre-emptive scheduling through its native threads support, it needs not support pre-emptive scheduling (or stronly co-operative as Go) in its green threads. Pre-emptive scheduling is only really required, as far as I know: - to ensure fair scheduling of computations - to ensure the ability to arbitrarily suspend any ongoing computation (if it's gone haywire for example) There are various ramifications (such as on the median latency of computations), which are also affected, but I will ignore them for now. What matters to me is that Rust already supports those two cases through native threads, and therefore the case of introducing green-threads in Rust is slightly different: it's more about an optimization opportunity, such as getting the benefit from non-blocking I/O without callback hell. In this context thus, with computations specifically scheduled for I/O, cooperative scheduling seems sufficient to my inexperienced self. Of course, it means that heavy-duty computations will hog one CPU, so for latency-sensitive computations it is important to work with work-stealing queues, but such already exist in Servo (I believe it's a Chase-Lev deque). As for the risk of splitting the ecosystem, I suppose there will be a split on I/O, however given the emphasis in writing generic functions, the ease of doing so, and the ability of trait implementation to transparently introduce cooperative scheduling friendly I/O, I do not see such a split in the making. Actually, I have been working in a similar framework for close to 8 years now, and while it does force you to carefully consider which services to serve with which thread-pool (not mixing potentially heady-duty computations with latency-sensitive computations) which has a certain "brain" overhead, it otherwise works very well. Not as free a lunch as in Go, obviously, but with potentially a better throughput once fine-tuned and without a penalty for those not requiring the functionality, it seems like a good fit for Rust.
What UI toolkit does it use? google/gxui?
IIRC rsc said calling C from Go is roughly equipment to 9 function calls. I'll dig up the gonuts thread in a bit. M
And Ivy on the Apple App Store for iOS: https://appsto.re/us/-V6u8.i
You don't put copyright on your works, it is put on your works automatically, by law, whether you want it or not. What the author did was relax the restrictions of copyright by releasing the work under a permissive open source license. That is a noble deed, whether you or anyone else wants to use the code or not.
I don't think that's the code for the Android app, just the Ivy core which is a toy language/parser created by Pike a while ago. Its part of the android app, but not the whole thing.
Demo works. After clicking demo, hit enter a bunch. Watch the magic.
So now we can build Android apps in Go ?
Yes, both apps share essentially the same Go backend code, written in Go. The UIs for each are based on platform-native widgetry.
Click on the main output area to get the focus away from the input field, then you can hide the kbd
No, both the Android and the iOS versions use native UI toolkits. We're planning to publish the source to both shortly - stay tuned. The actual APL interpreter is shared Go code.
I've bee using the official SDK for a few months &amp; it works fine, although sometimes they made breaking changes for APIs, so you may wanna do vendor works by yourself.
I recommend the aws-sdk-go library as well, as they did the right thing^tm about pointers for unset values in the API. Also - as it's mostly generated, it maps very closely to the http API docs amazon has.
I did that once. My result was about a 100x slowdown. That was the point where I decided to just say "no" to functional tools in go :)
Manually freeing up memory can become quickly equivalent to drying out a flooded room without turning the taps off, as we say in Dutch: dweilen met de kraan open.
Yeah it should be an `interface{}` and the thing returned an actual `[]int` then you can cast it: `filter(...).([]int)`
If your web servers are horizontally scalable, is there any reason to prefer an MQ over goroutines launched by the web server? The only downside I can think of is that you'd lose some jobs if the web server went down. But you can lose jobs in an MQ too. I'm not convinced the complexity of adding an MQ cluster is worth it.
Echoing @usernameliteral, why not use the std lib net/http?
I second this. I wrote a client library recently https://github.com/whitby/vcapi and you don't need anything beyond 'net/http' The godo client library for DigitalOcean is a great reference for how to create your own. https://github.com/digitalocean/godo 
json as a spec doesn't define streams at all. json.Encode always encodes exactly one json value. Even if it's a list, it has to eventually terminate. json isn't designed to represent streams of data, it's designed to represent a single structure. with that said, it is possible to represent streams of untyped data with json, and Go can handle it quite easily. This should be possible in any programming language; there's nothing in the json spec that precludes you from using this technique. A json string may not contain an unescaped newline; the newline must be represented as `\n`, or it's technically not json. So long as you generate all json with no newlines at all (this is the default behavior of json.Encode, so it's trivial), you can represent a stream by just having newline-separated json elements. encoding/json will handle marshaling and unmarshaling streams of objects quite readily in this fashion. Here's an example of how to use json to represent streams of data: http://play.golang.org/p/Ur0GdGd8Hd except for one quirk: if you're reading off of a network socket, io.EOF doesn't necessarily mean that you'll never see any more input again, so you wouldn't use the same error handling. Nevertheless, the possibility to handle json streams is illustrated. It's worth noting that json is not particularly well-suited to this example; you have to encode and decode the keys for every single record, even though they're the same every single time. You're better off using gob if you're communicating between Go programs, or protobuf/thrift/avro in the general case. But if you're stuck with javascript then a json stream is going to be the sanest option, even though it's a fairly space-inefficient way of representing data. A json stream over a websocket seems pretty normal. 
&gt; Luckily, there are some community packages that can help. Here we'll look at two __suck__ packages with differing feature sets. OK, I don't normally complain about typos, but this one really ought to be fixed. :)
&gt; Note that salt is not not needed with bcrypt for instance. Just to be clear, a salt is still needed/used, it's just that bcrypt is handling it for you and you don't need to (and probably shouldn't) explicitly provide/remember one (like the article mistakenly does). I.e. [`bcrypt.GenerateFromPassword`](https://godoc.org/golang.org/x/crypto/bcrypt/#GenerateFromPassword) uses [`crypto/rand`](https://golang.org/pkg/crypto/rand/) to generate a salt and encodes it into the returned "hash"; then [`bcrypt.CompareHashAndPassword`](https://godoc.org/golang.org/x/crypto/bcrypt/#CompareHashAndPassword) reads the salt that is encoded within the hash.
Will be these apps released as open-source?
I would say net/http, except it lacks in the routing department, so suggest httprouter (https://github.com/julienschmidt/httprouter) + a lightweight middleware package (https://github.com/laicosly/restiful) 
&gt; This [`if instance == nil` data race] is a better approach, but still is **not** perfect. If by not perfect you mean completely wrong in that it's undefined and [*anything* can happen](https://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong). IMO it helps no one in any way to refer to data-races as anything other completely wrong; or in any way imply that it might ever be okay (to many "not perfect" implies "may be okay, could be improved" rather than "wrong/broken").
Good point. There's also going to be some buffering in the HTTP package to send the body. I'll update the title and clarify that. The point was that you can avoid *another* buffer in your own code, which can be helpful.
https://github.com/AdRoll/goamz is the way to go. mitchell's and crowdmob were the main ones and goamz was an attempt to merge the two of them. It has now been replaced by AdRoll's one. the Aws-Sdk-Go can be cumbersome to use.
people always complain about lack of generics in go. idk what they're talking about tho..loops are generic Kappa
I met Dalton (sling author) at the recent Gophercon. He seems to have his head on straight and is very intelligent. If net/http isn't convenient in your case, I'd start with sling and consider others if I wasn't finding what I needed. ... so long as it's understood that you're generally trading one person's opinion of ease (and a dependency) for simplicity. In other words, you're layering over the standard library with some complexity/boilerplate in order to access an alternate (easier?) API which may or may not decrease development/maintenance time. The best approach is to know exactly why you're using a framework, server or client. If you don't know exactly why, favor the standard library. I encourage you to compare the code yourself: http://www.freenerd.de/accessing-the-github-api-with-golang/ https://github.com/dghubble/sling/blob/master/README.md#usage There are trade-offs to be keenly aware of. Make your own judgment carefully and enjoy working in a great language. If you need help, someone is usually available on #go-nuts, but be prepared with, preferably, running code on http://play.golang.org.
if your REST service is over http, there's net/http plus hypermedia parser of your choice. Which hypermedia are you using for representation?
thanks for sharing this! I enjoy the technical detail that you put into this and your other articles (the Atom one is still open on my browser).
/u/zemo and others pointed out why this approach isn't a good fit for JSON encoding. But I have a question about this technique in general. If GOMAXPROCS is 1, I feel like this could result in inefficient context-thrashing when a large amount of data is sent through the pipe with a small buffer. Is that correct?
Correct. 
Also agree, I just started a piece of work interacting with a rest api. Initially I tried one of the libraries but it didn't really make things that much easier SSSI switched back to just net/http, also don't forget there is a cookie jar available too if you need it, really helped me out.
And this separate processes could launch goroutines.
I've always defined a base template name const base = "base.tmpl" Then I use ioutil.ReadDir to look into my templates directory and iterate over them. if !v.IsDir() &amp;&amp; v.Name() != Base { var err error Templates[v.Name()], err = template.ParseFiles(filepath.Join("templates", v.Name()), filepath,Join("templates", Base)) ... Check error ... } Not the best if you need to have more than one base template. But it works for me.
Not sure if there are any. This might be different for you, but for me the best way to learn is just by encountering the problem and try to solve it when it occurs. Always has been, always will be. That's because you've got a concrete understanding of the matter at hand. But you could make your own exercise, for example: Resize all images in a certain folder sequentially and write them to another folder. After that try to do this concurrent, utilizing the amount of CPUs your computer have. It should speed the process up. And if you need some feedback, you won't be the first, nor the last to ask some feedback on their github repo. Document it, and some people actually might have a use case for using a simple CLI tool that does this for you. Allow to set the input and ouput directories using flags for example. It's no exercise with tests, but I hope it helps :).
It's Ivy, a Go implementation of APL by Rob Pike.
Yeah, the Go backend already is and the UI specific code will be soon.
html/template does escaping. The generated html code is safe. It's slower. https://golang.org/pkg/html/template/
[Here it is](http://pastebin.com/fZXvnt7r) No additional packages or templating engines, just a simple router and manual escaping of what I really need (perhaps in this case I don't even need it, added to test if things go bad).
seems to be the popular choice - thanks. I guess I'm used to other languages where the std libs are lacking. net/http doesn't look hard to use - just more boiler plate.
Doing tmpl.Execute(w, p) instead of tmpl.ExecuteTemplate(w, "index.html", p) avoids a lock and makes the benchmark finish (in my case).
Although it may not be the root cause, there is a big difference between what PHP's `htmlspecialchars` does and what Go's `html/template` does - see here: http://js-quasis-libraries-and-repl.googlecode.com/svn/trunk/safetemplate.html#problem_definition (/u/pierrrre touched on this in another comment)
Tl;dr, I trust the security model of this package but it seems a bit overwhelming, especially when I feel some data should be defined as known-safe. As for now, using text/template produces roughly the same result as PHP does (70k+, though tbh, latest PHP7 benchmarks raised its' result up to 90k+ but that doesn't matter since it's already not those 5k for Go - probably there's some other, more lightweight way to fill this array like in PHP because at first sight, in Go, it was a bit hard for me to fill it without knowing the language, but building structs was a total fun).
I tried to set Title, Content as template.HTML in my Post struct but everything seems the same. Is this a right way to explicitly set a variable as known-safe while still using html/template or I'm doing it wrong again? ...
It looks like an interesting project. I'll go over it later tonight and will hit you up to get more info on contributing to it.
Your "hyde" theme customization is awesome. Forked it. Thanks.
You continue to use EMR because of legacy reasons? Why not EC2? Am I missing something?
I'm glad the Go based solution is working well for the original poster, but the overuse of interface{} for situations where you already know the type seems odd, and probably causes some performance to be left on the table. It might be "fast enough". Also, some of the code dealing with maps could be greatly simplified. 
Yes, that's the right way
&gt; anything can happen Well, you can rule out the possibility of it offering you a cup of coffee.
We were using mitcellh's goamz package (and contributed too it). But once the aws-sdk-go was released, we started to move to it slowly (not completely yet). It has his quirks and things can break, so I recommend to vendor to it. The defacto aws library will be aws-sdk-go in the future, so I also suggest to invest to it, nothing to loose here.
You showed your example of parsing your file by lines. bufio.Scanner is a very powerful abstraction that's made for this use, among others, and can look like: s := bufio.NewScanner(file) for s.Scan() { line := s.Text() // ignore any meta comments on top of JSON file if strings.HasPrefix(line, "#") == true { continue } // add each json line to our enumeration channel output &lt;- line } We've also used it with custom split functions for parsing binary protocols such as bson and the Gearman protcol.
Welcome, glad you like it. Honestly, I probably should have done it a different way - you can override the default theme stuff in your own site's code, which is a cleaner way to do it.... but I was new, and I'm not much of a web guy, so I just did it as expediently as possible, which meant editing the theme directly.
Without generics or something similar I don't think It would be good to use it for Android programming. You end up rewriting so much code. I think Golang is really powerful for Network stuff and I enjoy using it for It but for application programming I would really rage alot. Also thinking about alot of Go models ... does every application benefit from the concurrency??? No obvisously not some application wont benefit from It and Go will make the performance worse. I think this Article has almost close to zero arguments to use go. While I also think a nice workflow is required we should also face the problems for Android we got bad batterys so we need efficient apps not apps wasting resources. I don't think Go is at that state to offer this now.
Bookmarking as well, I was just thinking about dusting off my ideas for a websocket based web app. I'd be considering using node.js just because it seems better suited for this type of thing but I really would prefer to use go.
Just a note on your mentioning of the need for efficient apps: Go's execution speed is similar or better than Java in most cases (despite the fact that Java is 4 times as old as Go) while also boasting a much lower memory footprint (I'm talking orders of magnitude, which is ultimately due to Java paying the cost of its VM). The only clear advantage Java has is a better garbage collector, so Java will be the clear winner in heap allocation-heavy benchmarks such as those involving large trees. The fact that Go is already on par with Java in many ways given its relatively early age is an indicator that it has more potential in creating efficient Android apps, at least imo.
I agree with you here, but there's not only Golang as replacement available. But I think golang requirs more development to be succesful for application development. If this happens I see a good way for Go to succeed with Android.
gorilla/websocket works fine in my experience, also, Glue is based on it.
The GC is getting a lot better with Go v1.5 so even that advantage may not be so clear anymore.
Why would you need generics to do Android programming?
Yes, this does require better documentation -- feel free to contribute.
Seems to me this has just become a default statement whenever Go is presented as an option in a new arena. An app is going to have a type domain so I don't see why you'd need to be that concerned about handling types generically. It's the folks that want to write cross app libraries that would have a problem.
&gt;Namely in mentioning that Google Dart is set to replace JavaScript - I thought Dart was losing a lot of traction/never really took off in the first place? You're absolutely right. That being said, things are looking better now that Dart has a [JS compiler](https://www.dartlang.org/tools/dart2js/) and now that the Dart team is focusing their effort more on it and have pretty much dropped the DartVM. [Source](http://news.dartlang.org/2015/03/dart-for-entire-web.html).
Did you ever worked with generics? Sounds to me like you dont know how to benefit from them.
Generally, the only benefit of generics is writing cross app libraries for containers. So I can play this game too, sounds like you rely on generics too much. 
Uhh... The type system works just fine. 
Dart since almost day 1 has had a js compiler. Also, the VM isn't going anywhere, it is still going to exist for the long haul (server side dart). What has changed is they are no longer trying to integrate the VM into chrome or other browsers.
Go may even be faster on android than java is since dalvik and ART are not OpenJDK/Hotspot JVMs. AFAIK, there are some performance issues with dalvik and I think ART (though I haven't read much about there being problems with ART) that don't exist in the current JVMs. Ultimately, the thing go is competing with is the Java ecosystem (IMO). Performance is nice, but it isn't necessarily the reason people choose java. The thing that drives people to java IMO is the tooling and ecosystem. There aren't many other languages have Java's level of libraries, IDEs, and static analysis tools. Java is preferred not because the language is great (it isn't), but because the tooling and libraries are fantastic.
Already posted: https://www.reddit.com/r/golang/comments/3d8m8t/bruce_eckel_go_seems_like_it_could_be_a_much/.
I suspect that with the arrival of web assembly the need for dart to have it's own VM will start to diminish.
Thanks for the link
Seems to me that on the server side if I can't do a regular Read() to read from the socket, but there is just that OnRead() event that is called when there is data to read, I'm stuck having to write state machines to handle complex communications instead of just reading and writing normally to a socket. This feels a bit like one is programming in Node, but with Go. There is a little event loop there for reads already on top of the runtime's event loop. I understand that it might be needed because of the keep alive management, but maybe the OnNewSocket should expose an io.Reader for reads (and the event loop can use an io.Pipe() to provide it)
I dont't know dalvik/art/androidjava that well but since java in general drops generics at the compiler level it should at least be possible to provide other mechanisms in place of it while keeping the same low level semantics. We might now know what these alternatives are but it's strange to say it won't work without generics before we know how alternatives looks.
Sure, I also edited my post a bunch with other examples of packages that do it different ways. I'll admit though, none of these are as dev friendly as generics.
In many cases generics are for people who don't know how to use interfaces.
Hm, actually it seems to be true. In my benchmarks duktape was 5 times slower than node.js. The main problem with v8worker is it not go get'able but go-duktape is. And there is no bridge between Golang and javscript contexts. 
You are just a bad developer then. If the type system is so bad, Google wouldn't be replacing core services with go backends nor would any of these other companies. Relying on generics is a caveat of failure.
You are tossing out jargon.
Not sure why you keep referring to in memory structures. I currently work on a system written in Go that handles all its data in memory and this hasn't brought about the need for generics. Nor is there any copied code. In fact we've been pretty happy with how DRY this solution has been vs the previous non-Go solution. Sounds like you're just using generics because.... generics.
I just had a chat with Ian from DeferPanic earlier today - they're really a solid company building cool stuff for Go users. I'm excited to play with AOP for testing/debugging code that a) I don't control and b) that I don't feel requires "dedicated" debug handlers in the actual code itself. The possibilities here are endless.
Discussing this with me? I called you out because you were asking to be called out. &gt; So you tell me I'm 'tossing out jargon'. Your statements are the utter definition of either misinformation or misunderstanding. Let's begin. &gt;Without generics or something similar I don't think It would be good to use it for Android programming. You end up rewriting so much code. What the fuck are you writing that generating can't fix? A single list? Using a single generic list for every single thing that needs a list is not pragmatic at all. &gt; I think Golang is really powerful for Network stuff and I enjoy using it for It but for application programming I would really rage alot. ... You just explicitly stated how you know fuck all about using Go in app development. &gt; Also thinking about alot of Go models ... does every application benefit from the concurrency??? No obvisously not some application wont benefit from It and Go will make the performance worse. Go offers more than just builtin concurrency. In fact, as a user has already mentioned, there are plenty of instances where goes is as fast--or faster than--Java. &gt;I think this Article has almost close to zero arguments to use go. Of course it doesn't. &gt; While I also think a nice workflow is required we should also face the problems for Android we got bad batterys so we need efficient apps not apps wasting resources. I don't think Go is at that state to offer this now. What the fuck are you even talking about? Android's battery life is fine. What is bad are the apps that instantiate wakelocks. It's up to the developer to code well not for the language to shove the developer in a cradle and not allow you to always invoke GPS. &gt;I doubt any developer would like to create Apps with just slices(Well you can create other datastructures on top of slices). I don't even know how to answer this one... &gt;Apps require lots of different datastructures stored in memory and you got several different types you may want to use. nor this one... &gt;Also why should the whole math logic work with slow floating point numbers when you only need non floating point results. nor this one... &gt;I never released a complete one. But I'm working with C++/QT on some kind of a calender app. Shows how fuck all you know again. If you want to be serious about this app discussion lets talk about how you are not using Java to write such a bullshit and trivial app. Hell, why aren't you using Titanium? Is it because you want to 'learn the hard way'? Even so, don't go spewing shit that isn't right. &gt;It's not just a plain calender app It offers lots of logical parts I don't want to go into detail too much but I rely there on custom ways to access my data and I want to reuse stuff I written once. Calling bullshit on this one too. There is no possible way that this couldn't be implemented in go easily. Until you give specifics, you are wrong. &gt; So how can you deny it that you often use in-memory structures in an app. I'm not talking about an app where you just drag you webview widget there and load a page and say It's an app. You what? You realize that pretty much all data structures are 'in-memory'; unless you are talking about full caching, in that case it can still be easily adapted through memoizating or just storing it in memory. &gt;I bring valid arguments you just rephrase something which attacks me Didn't rephrase anything. You asked to be called out. &gt; So you either show me the opposite side and convince me or I just won this. 1v1 me.
There is a difference between criticism and spewing nonsense. 
Professional anti-Go troll above. Always one of the first one to jump on some sort of generics or type system bandwagon while folks write software just fine with the language as is.
I don't even know how to describe this person as other than a tried and true troll. Even the world's most evangelist anti-go programmer should know what facts are. Then again, this is the internet... 
What's your "domain of choice"? Web/HTTP? CLI apps? Something else entirely? I might be able to recommend something but otherwise I'm just guessing. Looking through the most popular Go repos (in order) on GitHub and hunting for a low-hanging issue you can fix is also a good way to start.
&gt;Your statements are the utter definition of either misinformation or misunderstanding. Let's begin. No they aren't I'm well informed &gt;What the fuck are you writing that generating can't fix? A single list? Using a single generic list for every single thing that needs a list is not pragmatic at all. We don't talk about list! Everyone knows you should avoid a list unless you got a real reason for it. It's super slow. I don't want to write thousands of trees(mostly) and other ways to access my data based on its behaviour really fast and so on just because go doesnt offer something like generic. The Java solution is also super ugly and slow. &gt;... You just explicitly stated how you know fuck all about using Go in app development. I know enough because I tried It. &gt;Go offers more than just builtin concurrency. In fact, as a user has already mentioned, there are plenty of instances where goes is as fast--or faster than--Java. Men you don't seem to get that goroutines and the whole predeclared runtime have a major performance drawback if you don't use their power. It's a perfect example for this. &gt;What the fuck are you even talking about? Android's battery life is fine. What is bad are the apps that instantiate wakelocks. It's up to the developer to code well not for the language to shove the developer in a cradle and not allow you to always invoke GPS. Exactly but if the Language doesn't offer the tools for this It's annoying. We don't talk about enabling Gps. I almost never use any location services on my smartphone and my battery still drains really fast. &gt;Shows how fuck all you know again. If you want to be serious about this app discussion lets talk about how you are not using Java to write such a bullshit and trivial app. Hell, why aren't you using Titanium? Is it because you want to 'learn the hard way'? Even so, don't go spewing shit that isn't right. You are an idiot saying this 'trivial' and 'bullshit'. Seriously are you a javascript kiddy or what? Sorry that I'm not one of those :(. I don't learn It the hard way I do stuff where I think It's useful instead of creating plain simple stuff. &gt;I don't even know how to answer this one... You should answer all 3 of them. First of all as I said you need various container types for your app not just slices what is so hard to understand??? It's no mystery you deal with alot in memory data in an app. When I go with web development I use sql alot or a cache like redis for various reason but here I don't want to nor I have to. &gt;Calling bullshit on this one too. There is no possible way that this couldn't be implemented in go easily. Until you give specifics, you are wrong. Ofcouse I won't go in detail before It is released. My idea is great and I won't share It so someone like you with more free time just make a clone because It's a neat idea. Think off a proper calendar app if you can think that far and see what you need to make it GOOD you'll notice It's more than trivial and requirs several concepts. We cann't say java offers this at a good level. Just look at the Java generics go could do this as Java did but It would be slow. But you should also face Go has some predefined overhead(when you don't benefit from it) and It still misses abit to reach a proper level of App development. But If google plans to replace java they want a real upgrade. Go would allow an upgrade in some ways but also has some downgrading in it. Maybe we write completly different apps but most software I released was kinda liked by the user and It works really neat so I doubt I do anything wrong here.
You just invited a "muh generics" discussion.
I'll give another shot to github. I previously tried looking at Hugo. I personally didn't find the problem scope to be very interesting. I also looked at Bleve. I couldn't find any issues of importance that needed work done. I've peeked into the source of Docker and Vitess. Those seem a bit large for someone who is just starting. I also looked at camlistore, but have no idea how to approach the issues. I guess I'm looking to dip my feet in more shallow waters. EDIT: So to actually answer your question, I like all sorts of things and don't mind contributing in multiple areas so long as there is something interesting being produced.
sad but true :(
I agree that some of the code duplication can be somewhat annoying. otoh it's not that bad duplicating some code here and there.. If ever come to a point where I'm thinking "oh man, now I need these functions with signatures for these 20 types" I would consider reflection if performance wasnt an issue or otherwise just generate code. It's not elgant, but java is also kind of awful, Lisp is a much more elegant language than both java and go. It has a simpler syntax than both languages and is more powerful at the same time.
It's what drives me away from java. I hate hate hate hate dealing with Java's enterprise everything IDEs and culture, but you have essentially no choice because the language and runtime designs are actively hostile to just using a text editor. That's a slight exaggeration, but not nearly enough of one.
Yeah. The only real duplication I can recall is when creating more or less identical copies is related to maps. 
Have you used Go's tooling? It's fucking fantastic! And most of it is built into the language. No installing a massive IDE, no needing to standardize on a formatting guideline, no need to choose a testing framework or a package manager or any of that shit, its already there.
&gt;Some kind of abstraction is useful. Yes, write an API-specific client with `net/http`. I don't see how a adding another layer of general HTTP client functionality is going to help you. If you find yourself repeating a lot of code in the calls to each API, write a function—it'll do exactly what you want and no more.
&gt; Also, Go doesn't have any sort of JIT. JITs are typically reserved for languages that aren't compiled to machine code.
My point was that the JVM's JIT gives it a pretty solid leg-up.
Look for Keyword Table-driven test on golang blog
I found one compiled html template engine http://hackersome.com/p/mgutz/razor . Try it. It should be much faster. Other options to try https://github.com/avelino/awesome-go#template-engines ~~Other reason why php is fast: it renders html almost directly to socket (i.e. it doesn't buffer whole result by default).~~
https://github.com/benbjohnson/ego
I think if you have a server serving images to another server - ie you're passing images between servers - you're probably doing something wrong. A database table with paths is fine. In fact, you might split hostname/root path from the file name, to give you some flexibility on moving images around. But, service-wise what you're describing sounds like it has more moving parts than you'd likely need.
My first real effort in building something in Go. I ended up taking a Python package that I wrote (nameparts) and ported it to Go - making some improvements along the way. As I'm still trying to get acquainted with the proper idioms any critique is welcome. Otherwise I hope someone else finds it to be a useful package.
I want to use a database because I need to store additional information like a title (up to 100 characters), a description (up to 400), who uploaded it and all its comments. But /u/google_you and /u/tlianza might be right, just as you. I'd probably be better off using Apache or nginx at least for the image server. And as I said to /u/google_you: "I really don't just want to fetch them from the file system because the service is supposed to offer and share thousands of images between people who can upload them, etc."
Interesting, have you looked at https://github.com/mailgun/oxy also?
gtf out
I won't tell you anything about gb or godep as a solution to dependency versioning (as they're not built in golang), but... &gt; Take for example a very simple math problem: a(b) + 5 * b(c). To render that out in Golang, you need to define each variable as a modifier of the other. In other words, your code ends up looking like this: (snip) really? http://play.golang.org/p/Q-Icn7dHA8
I just woke up but noticed a couple of other things that smelled funny, too.
Amazon S3 is a viable solution. You'd store the images there and save the url's. Also it can support multiple intances(web severs).
The JIT gives it a leg up on other languages that are either interpreted or compiled to some VM code rather than native machine code. It does not give it a fundamental leg up on languages compiled to native machine code. You may claim that the JIT compiler has better optimizations than the Go compiler, and I won't argue because it's not something I know the details about.
Many people suggested Amazon S3 to me already, but I don't really want to rely on external services. I'm still in school and have time to learn to write things like this myself (I guess).
Well, it looks like I am completely mistaken: Template.Execute accepts io.Writer, so that it writes to the socket.
Great, thanks for the confirmation.
Author here, the library provides a framework for creating a work/worker system. This library takes care of thinks like worker registration/authentication, queueing, etc. More info on the GitHub page.
Author here. That was a restriction imposed by the encryption functions used, will be addressed at a later date :)
What do you say to, within the function, filtering out the meaningless errors before returning them?
What do you mean by meaningless? The err is returned because in some situations a dynamic, user provided secret may be used and an err is returned in case it isn't infact 32 characters as expected.
Well at the end of the day it's up to the developer of the application, if they want to ignore it they can, if they want to check it they can. But honestly, does it matter that much? :)
Thanks! Gonna test in a few hours.
For more dramatic comparison. Upgraded test machine to 2 cores and 4 gb RAM. Tested on same "blog". Results for PHP7: - 295k out of 300k successful responses over 1 min (5k cc/s), average latency 300ms Go (using GOMAXPROCS=2, and using text/template this time cause it fails to deliver with html/template): - 120k, average latency 4000ms **UPD.** See my [comment](https://www.reddit.com/r/golang/comments/3d6j42/why_is_htmltemplate_so_slow/ct4s9oi) after using compiled templates.
I'm already doing like that in all recent tests, no gain at all.
No confusion at all; we're in complete agreement here.
Nice! I wrote something similar a while ago: https://github.com/goware/errorx except my primary objective was to provide configurable verbosity levels replicating PostgreSQL errors, while making sure it's still a drop-in replacement for `error`. 
Right, but why would I use this over rabbitmq?
I guess not, but it happens to be the very first thing on your GitHub page! I happened to notice it also. Why not just do proper error handling on the library side and return an error only when actually necessary?
He means only returning an error when there actually is an error. Instead of simply documenting the fact that sometimes the errors matter and sometimes they don't.
Alas, I have changed the wording of the comment. https://github.com/ryanskidmore/GoWork/commit/275088622c8ce773e322c2471e7826e654a21c5f :)
Perhaps it is simply the wording on your page, but what you wrote implies that sometimes an error will be returned even for a valid secret. My suggestion would be to handle this for the user and throw your own error (import errors and call errors.New("invalid secret key") ).
Much more clear :) 
This feels like a bit of an advert for StableLib, albeit a solid selection of packages. Would you mind explaining StableLib a little better than the homepage, as in do I pay $20/month to use the packages that you maintain or would I be paying to have you maintain my package?
A summary isn't necessary. A rewrite is. The author of this article hid their points in so much text that the cost/benefit of reading this is not worth the read. :\ I'm skimming it now though and will probably post a summary of the big points that I pulled from it.
can this be used in combination with the Nest api to bridge the Nest thermostats with homekit?
Stealing from the article: &gt; Documentation: any information that demonstrates the usage of a particular piece of software to a potential user. . &gt; Comes in 4 types: &gt; * Specifications (white-papers and other technical data) &gt; * Reference Material (class definitions and function signatures) &gt; * Manuals (installation and other bootstrapping instructions) &gt; * Tutorials (how-to’s, guides, etc.) . &gt; effective documentation saves time by providing clarifications and helping avoid roadblocks. . &gt; recognize good documentation by how much time it saves . &gt; We do not need to bother ourselves with complex criteria for measuring comprehension. In the case of software developers, we need only to validate whether inexperienced developers are able to imitate experienced ones (here we respectfully tip our hats to Alan Turing for establishing this idea). basically, to measure comprehension, look at how close an inexperienced user is to an experienced user. &gt; To put it another way, effective imitation can be most quickly achieved with a good supply of pertinent examples &gt; An example from the field of music education reinforces this concept and its efficacy. The Japanese violinist Shinichi Suzuki seized upon the idea of teaching children how to play music by focusing on repetition and imitation. . &gt; Sorry coders: tests are not effective documentation . &gt; If you hang around with enough developers, eventually some genius will try to convince you that source code is documentation. In my experience, it is usually the most brilliant minds who make this claim, and that tendency should be a warning to the rest of us. To state the obvious: source code is not documentation. . &gt; The primary benefit of using an automated process is for its thoroughness: it will prevent you from forgetting some function or class. After that, its usefulness wanes. The doc-blocks in the code are not the best place to write thorough examples, explanations, and variations on them. &gt; Although the doc-blocks in the source code are useful for making technical notes for other contributors, their target audience cannot be often said to be newcomers. &gt; how to structure your project’s documentation for maximum usefulness. &gt; &gt; * Clearly and succinctly state the project’s purpose and audience (e.g. in your README). &gt; * Sketch out your functions and their signatures. &gt; * Sketch out how to use your functions to accomplish the tasks for which you are writing your software. &gt; * Include variations. Stretch yourself to demonstrate different use-cases for your code. If a user asks how to do a particular thing, consider adding an example to your docs. &gt; * Anticipate problems. The best documentation includes tips for what to do when things do not work as expected. . &gt;Tom Preston-Werner was not joking around: your project really should have a README file and it makes good sense to focus on it first. At the absolute minimum, your README file can communicate to potential users whether or not your code is what they are looking for. &gt; * Name: The name of the project &gt; * Description: A brief description of the project answering “What problem is this project solving?”. Include an outline of the technologies used in the project. e.g. the framework, programming language, database, ORM. &gt; * Authors: The names of the developers on the project. &gt; * Links: Include links to any related projects (e.g.: Is this a Rails API that has corresponding iOS and Android clients?), and links to online tools related to the application (e.g. links to the Github bug-tracker or a link to the Dropbox where all the wireframes are stored). &gt; See http://blog.thefrontiergroup.com.au/2013/05/writing-a-good-readme/ or http://www.wikihow.com/Write-a-Read-Me for more thorough discussions. . &gt; Whether it’s information about how to install or how to run it, your documentation should include enough information for a new user to get started using your code. E.g. for a Rails app, list the perfunctory db:create db:migrate db:seed steps. For a PHP library, list the appropriate Composer commands. For a Golang package, reference the proper “go get” commands. . &gt; Every function or method used by your code should be documented with a proper signature so it’s absolutely clear what it accepts as input and what it returns as output. . &gt; [Descriptions] should be as short as possible while explaining exactly what the function or class does. . &gt; Examples are the most important building blocks of your documentation. Explanations should reinforce, not replace, examples. . &gt; For any given function or use-case, it can be useful to reduce the usage down to the simplest possible example. . &gt; More users will follow examples when they are relevant. . &gt; The painful truth here is that sometimes code authors are the worst possible candidates to write the best documentation because more than anyone else, their view of the code is biased. . &gt; No matter how good your documentation is, you must provide a way for users to provide feedback. . &gt; Effective formatting should allow users to control the level of detail visible in the same way that they might zoom into or out of a map or photo That's all the points that I pulled from this that seemed relevant on skimming this. I now detest this author for burying their point in so much shit. :/
I appreciate your response, I didn't think to read the terms! Sounds like a very interesting product that I may consider proposing for an upcoming project. (and great to see it's free to use in open source and non-commercial!) I guess I was a little harsh calling it an ad, it wasn't intended to be an attack, this got my upvote anyway. Thanks for making it clear in the post the upstream links, as well as on each individual package page too :)
I'm for switching everything to TLS, but your point is not correct. Modifying headers requires an active man-in-the-middle attack, which is completely different from an attack where a website embeds your content (if you didn't set `FrameDeny`) and performs clickjacking; or an XSS attack on a content without `nosniff` mentioned in the post. 
If your content is important enough to protect from malicious ad networks, then it is important enough to protect it from the 15 year old at the cafe.
Just out of curiosity, what happens when $data['posts'] is different every time.
I would really like to see your go code. Just in case you are doing something wrong. I would have thought golang being much faster than php 7. Also how you are testing as well. ab, seige, etc?
Go provides a lot of what they want - but it also goes against other things. For instance, the author was against descriptions - and golang.org and godoc.org are just descriptions, with the go wiki and go blog as second optoins. TBH tho, I think the troll portion is quite possible. It's just annoying cause the author is actually flirting with some valid points.
By the way, I've tried mt_rand(0, 100000), it's the same. Without opcache, however, it's definitely slower (2x). But why on Earth would I switch opcache off...
Loader.io, you can try it for free with up to 10k cc/s. [This is the Go code](http://pastebin.com/q6Ky4gt3) Golang is faster, when I don't output anything (don't use text/template).
I tested using *ab* and without that change the benchmarks didn't finish. After applying that change the test finished *most* of the times. I couldn't find the cause.
Just to add to my love of artificial benchmarking tools, I see 6.2k/req/s with GOMAXPROCS=4 and `html/template` with the example down-thread on an i7-4771, SSD, OS X. Available RAM inconsequential for this. Using `wrk -c 100 -d 5m -t 4 http://localhost:8888/` - external services can have a lot of variance. I can't test the PHP code as it only appears to be a snippet based on the `Route::` and `View::` classes.
Can I assume that nginx is caching responses that haven't changed? That's common behaviour (and Go can benefit from it as well). I also think that's the first time in your thread(s) that you've mentioned the tuned nginx configuration. 
You can't really exaggerate when it comes to Java.
Great!
That's great! I just started using errgo a while back and it seems to overcomplicate a few things, but Merry looks very straight forward. Thanks for publishing this! :)
Refinement with interface type and idiomatic struct + receiver funcs: http://play.golang.org/p/dGDBG_f4FP There's nothing wrong with using function handlers to do some lightweight polymorphism. The problem you'll run into is that as individual variables, keeping them in sync as you switch from implementation to implementation could become problematic (unless you want them to all be set independently wherever/however). It's better to use an interface and have multiple concrete implementations via structs instead, since that ensures that the various member functions all stay coupled for each type. Edit: Also, func vars are *nil-able*, meaning that you should those vars against nil before calling, lest you wind up with a panic somewhere: http://play.golang.org/p/5zrZykPXvn
i dont get it? i like the encapsulation though... cool paradigm
With closures!
&gt; a growing base of experimental feature-sets, making the language one of the most extensible ones available. What's this referring to?
I read this first as "a compiler implemented in [scratch](https://scratch.mit.edu/) for go" and was ready to be impressed.
[**@josevalim**](https://twitter.com/josevalim): &gt;[2015-07-16 10:15:32 UTC](https://twitter.com/josevalim/status/621624196997775360) &gt;It is so interesting to compare Go's and Clojure's communities understanding of "simple" / "simplicity". [**@josevalim**](https://twitter.com/josevalim): &gt;[2015-07-16 10:21:47 UTC](https://twitter.com/josevalim/status/621625771673710592) &gt;[@josevalim](https://twitter.com/josevalim) Most interestingly, Clojure sees simplicity in decoupling and composition, while Go is about "rigid application of simplicity". [**@TheMue**](https://twitter.com/TheMue): &gt;[2015-07-16 10:25:10 UTC](https://twitter.com/TheMue/status/621626623142572032) &gt;[@josevalim](https://twitter.com/josevalim) [#golang](https://twitter.com/search?q=%23golang) tends to decoupling by usage of interfaces and composition too \(at least when people have to maintain larger projects\). [**@josevalim**](https://twitter.com/josevalim): &gt;[2015-07-16 11:00:09 UTC](https://twitter.com/josevalim/status/621635423723462660) &gt;[@TheMue](https://twitter.com/TheMue) In Go, you have no answer for that. You can't decouple and you can't compose. Most of my software is working with collections. ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/3di4tj%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Are we supposed to bash this person for not knowing better? I don't think this is healthy.
XSS is not an input problem, it's an output problem. A problem that Go's standard `html/template` package solves elegantly. `BrowserXssFilter` in this sense is a misconstruction based on an [IE8-MSDN blog post from 2008](http://blogs.msdn.com/b/ie/archive/2008/07/02/ie8-security-part-iv-the-xss-filter.aspx). Don't do this, rather, escape your output.
Good call. That can lead to some *very* confusing code. It's possible for a struct to export func *fields* that would make it resemble an interface, yet not support it: foo := NewMyStruct() n, err := foo.Read(someBuffer) // read some bytes using a func field named 'Read'! x := foo.(io.Reader) // error - foo is not convertable to io.Reader http://golang.org/pkg/io/#Reader
Do you think it's "not knowing better" case? I doubt it. Jose perfectly knows what he's saying. Paraphrasing Jose — "Go has no generics but my Elixir has" and provided link in subsequent tweets. I applaud him, this was refreshing new way to complain about generics.
Funny enough, i've stumble across this a couple times, because i started playing Ark (the game), and i've been modding it so ill search for Ark github (for the dev kit binaries) and i always end up pulling this up :-P
Does this sub not have a "no blogspam" rule? At least proofread your article before posting it.
I got a lot mostly from the docs: https://godoc.org/golang.org/x/oauth2#Config The rest was kind of just playing around with the response and digging through the godocs for the auth package and the google authentication guide: https://developers.google.com/identity/protocols/OpenIDConnect#exchangecode It also helped to look at other packages which do something similar like this one: https://github.com/markbates/goth/blob/master/providers/gplus/gplus.go
No, to the best of my knowledge, the only rule is "it has to be go-related". If you dislike content, feel free to downvote, which is the usual reddit way to moderate :)
[Closures](http://play.golang.org/p/9jNMnzvJ0_)?
You can't decouple _functionally_ and you can't compose _functionally_. Nobody pretends otherwise. However, these aren't the only methods of decoupling and composition, and in a lot of ways are relatively new as a practical technique even if the heritage nominally extends back to the 1960s. By contrast, despite the fact that a lot of languages have something like interfaces, most of them just have something a little tiny bit off that makes them not as _practically useful_ as they are in Go. I would not run around claiming these languages "can't decouple".
I was able to resolve by using a asn1 encoding on the r, s big.Int values. IE so I'm able to consistently unmarshal the data.
My use case is that I have tokens in the URL. They determine what headline, image, copy, etc need to be used to replace the existing default choice. The text is retrieved from the database cache based on the token_id. So at run time the template needs to be changed on the fly by this text. Thats what I mean by dynamic. Having a template hard coded won't do. If you are saying that via conditionals I can determine whether to replace text or not. Then I think this will be acceptable.
Yes, see their Readme, it's totally possible.
Because sometimes the upper 8+ bits of r or s are zero.
awesome. thanks!
&gt; just like compilers today create code that is much faster than anything you can write manually I guess then that developers of x264 (which is the best or one of the best video encoders in the world) are idiots because they wrote half of it in assembly for speed. And x265 goes the same route.
Actually only that one since: (1) it's really just a channel wrapper around a waitgroup.wait() (2) more concerned with PoC right now :)
This is the closest I have come to finding it... https://twitter.com/golang/status/113468340005113857
[**@golang**](https://twitter.com/golang/) &gt; [2011-09-13 04:25 UTC](https://twitter.com/golang/status/113468340005113857) &gt; The Go Gopher vinyl figurine is now on sale at the Google Store. http://www.googlestore.com/Fun/Go+Gopher+Figurine.axd \#golang ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Neat trick. I know the author mentions that `doesEverything` is a bad interface, but it bears repeating: if you are the owner of this code you really should be creating smaller focused interfaces, and testing against those. If you still want a giant interface somewhere you can still have it, you would just create `doesEverything`that is composed of the smaller interfaces.
stupidly, I broke it yesterday, but thanks to a contributor, it's fixed now, with travis keeping watch.
Can you provide a playground link? (http://play.golang.org/) with the whole code if possible? Besides the unusual function declaration, it seems OK. 
One issue with this is, that your tests might fail, if your code starts calling different methods on the interface. Thus, your tests need to take into account the implementation of a tested function, instead of just the behavior. But I think this is relatively minor :) Neat trick :)
We've benchmarked against C, and it's somewhat on par. However, the feature set is primitive so this will probably change. Also the compiler is early in the stages, so as soon as more features are implemented it may get slower (or even faster), and we'll probably start optimising when everything is working.
That is the most verbose use of closures I've ever seen, but yes.
Only if you are a) trying to be extraordinarily anal, b) ignore the context of the post it's in, c) ignore the context the post is in and d) ignore your own choice of words.
Why didn't you tweet that guy and ask him?
Almost four years too late.
Go is not a lisp. Adapt your style or don't use Go?
Congrats on the great lineup and good luck!
Quick! Someone ask him about genetics!
Code to test effectiveness of different eviction strategies across workloads : https://github.com/dgryski/trifles/tree/master/cachetest
That was on purpose. I nearly accidentally did this in [something](http://www.github.com/DeedleFake/imgsize) the other day before I realized how pointless it was. I was tired.
Thanks!
The documentation needs love. It references a "Set" (instead of "Put") method and the parameter to New is not documented :)
There is a flaw in your last example : the signal on the `result` channel should be sent by the goroutine which handles the cash transfer. In your example, `1` can be sent on the `result` channel before the cash transfer has been executed (if for any reason the runtime schedules the `result` goroutine before the execution of `sendCash`) Here is a suggestion : https://play.golang.org/p/cBmU9WjDvY
This is like the tenth dupe of that link. Also, it's not without using additional memory.
Great advices! But what do you do with interface approach when there's tens of methods for the models? Is there any cleaner way than to create Datastore for every model?
This author loves hearing himself speak. I think if I had to choose between his docs and reading his code without his wordy docs, I'd probably go with the code alone.
Really great thorough review of the different patterns. I'm definitely going to link people to this. Some edit suggestions: - Add a short overview at the intro of all the types before diving into detailed examples/discussions. - Add a conclusion in the end with some recommendations would be great. I'd especially emphasize the beauty of the Datastore interface approach, the easy-mocking is not to be undersold but also you get easily pluggable storage drivers right out of the box. Want to toss in a caching layer between some of the calls? Piece of cake.
The key is to avoid building a storage driver interface that approaches the complexity of a generic ORM. It's common to have a combination of some per-model helpers (e.g. All, GetById, Update, Delete) but for complex queries, like ones that require joins, you want to create a higher-level interface for your entire datastore rather than sticking with a composition strategy per-model (e.g. BestBookByAuthor, ReviewsByBook, RecommendBooks). The goal is to abstract the fact that you might have a relational database underneath. You should be able to provide a completely different storage driver behind the scenes (e.g. Redis, flat-file fixtures, memory mock for tests) without running into problems with the design of your driver interface. This also lets you refactor your schema and queries behind the scenes without worrying about affecting the rest of your app.
Thank you! Well yeah, I understand the whole mocking goal, but (for example) there's (Add, Update, ByID, ByLogin, Delete, ByRole) for Users alone, and while AUD functions could be interfaced out - it would require making something like Add(obj interface{}), and this kills both performance and compile-time checks. Can't figure out a way around. :( For now I'm having UserLister, UserSaver interfaces and UserStore interface, which composes the two; same for other models.
[git shortlog b1..b2](https://bpaste.net/show/8fddd341fda7)
It's vinyl by the way, so it's unsqueezable. I got it from a presentation hosted by Andrew Gerrand in Rijswijk, The Netherlands :)
Have a look at this: https://github.com/kelseyhightower/ipxed/blob/master/api/server.go
&gt;It's vinyl by the way, so it's unsqueezable. I got it from a presentation hosted by Andrew Gerrand in Rijswijk, The Netherlands :) I still want one. I think the plush one leaves something to be desired. 
Thank you very much :)
Thank you very much :)
Anyone try out the vendoring stuff yet? 
https://medium.com/@freeformz/go-1-5-s-vendor-experiment-fd3e830f52c3 (I'm mentioned in the article)
Using package names "a", "b", "c" are really confusing, I think real-world-like paths would influence more on readers imagination. Instead I'd like to see "github.com/foo/a", "bitbucket.org/foo/b", "gopkg.in/foo/c" etc. 
Good to see the whole compiler is written entirely in Go.
Can you please explain why you think this is the future of all Go programs? Is it just for the closures? That seems unnecessary with unexported variables. This looks messy.
I haven't been checking Reddit much lately. I mostly posted it so I could read a discussion of the trade offs: 4k goroutine v. N-byte buffer. 
This is a great implementation. Maybe Go authors will mainline this?
&gt; When is the best time to do a GC? &gt; When nobody is looking. &gt; Using camera to track eye movement &gt; When subject looks away do a GC. 
I haven't used it, but I have used Cassandra. In general NoSQL databases are less flexible than their SQL cousins for arbitrary data. They force you to carefully structure your data so that queries can be performed efficiently. (Basically think of SQL without any Join capabilities) If you have no idea how you want to structure your data you may be better off leaving it as raw files and storing it on GCS or S3. Eventually when you figure out what you want to do with it, you can write a program that churns through all the data (tip: run this on a machine near the data... like an amazon or google virtual machine) If you're wanting to explore the data like you would with a SQL database, then perhaps Amazon's Redshift might be a better option: https://aws.amazon.com/redshift/. (I've never used it but this is what they say its for)
Well they have a note on the 1.6 slide about UI libraries. We do, but maybe we can do better than that!
Please excuse this off-topic comment. To the author: Please note that your blog is user-hostile. Instead of linking to your document, you linked to a JavaScript application that can load your document. I already have an application for loading documents: Firefox; I do not need or want Blogger's. I believe I have seen Blogger blogs that do not rely on special JavaScript programs to load the blog posts, and I would recommend that you look into that. Alternatively, you could skip Blogger entirely and use a more accessible platform for your blog. Perhaps a public FTP server with plain Markdown files or a static website generated with a tool like [Hugo](http://gohugo.io/) or [Jekyll](http://jekyllrb.com/). I'd personally prefer just the Markdown file—that's what I really want, a document. I did manage to read your post, however, through the [Atom feed](http://mrekucci.blogspot.com/feeds/posts/default) that I found in the page's source.
Why is the CSS on the website a near exact copy of GitHub's? Do you have someone who can proofread it and remove the numerous typos?
Existing [godo](https://github.com/go-godo/godo/tree/v2.0.1)
The Go community tends to prefer not using too many dependencies, and pulling in a full library for a 4-line function is considered a bad trade. YMMV, but I've definitely come around to it. By contrast, if you're going to use a lot out of that library, pull it in. I'd also say, looking at some of those functions, that if you're going to use some of the more interesting and complicated functions like NextPrimeUint64 that you might want to pull it in too.
Googling for 'golang http proxy' results in [this library](https://github.com/elazarl/goproxy), which looks like it fits the bill and there's an example where the proxy adds a header too. Good luck!
It's 2015. Turn on JavaScript.
GoSearch may give you a clear clue: http://go-search.org/search?q=redis
Well... then why does the standard library exist at all? I agree with you, I'm not saying it's a huge deal. It's just slightly odd.
Because it takes too much useful vertical space for too little content.
The problem is people.
Yes, it could be embedded into other products. 
Nice! Good write-up and documentation. I am not sure I am sold yet. It seems like in your "typed" examples the "roundtripper" loses its type, and is an interface{} - am I misreading it? What I like about Daves approach is that if I require a parameter to be an http.Roundtripper that is checked by the compiler. Using you library I have to check it at runtime, which is an unnecessary risk of error. 
You have just spend more time discussing the necessity of writing if…, than it would take you to write at least five of these statements. Even needing to write them "all over the place" ultimately costs less time than discussing if you really need overloading…
&gt; The modern programmer thinks a newline is a thousand times harder to type than any other character. If instead you take a newline as only one keystroke, which it is, the fact that your program might not fit on one line is a bearable burden. -- Rob Pike
Amazing.
Ooops, sorry, mixed package name and link. You'll find it as part of my Go library (multiple packages) at https://github.com/tideland/golib.
That's right, but you can add a few lines of boilerplate to get arguments with your own custom type: https://github.com/soheilhy/args/blob/master/example_custom_test.go
Yes, I consolidated my packages. The original one will stay available for some time to give all users the time to migrate too.
Floating point precision is a feature of floating point implementation, and yes, it's weird. But why would a language implement an equality operation for such datatypes if it cannot, in fact, guarantee equality? Given Go's other design decisions it seems strange to take a pass on this issue. Carry on downvoting if you disagree, that's totally what downvoting is for.
Damn. I had no luck on eBay either... Anyone got one for sale? :P
amazing!
Let me try to dig up the 3D models that were used in the original design. Perhaps we could print our own?
Sure, software evolves. The migrated one is the v3. The larger API change has been between v2 and v3. Here we still miss a good concept, but the 1.5 vendoring or gd are on the right way.
The **perfect** place for this function is in the math library. If you were to program your own version of this function, you would want to be able to put it in the math library. Otherwise, now you've got this weird utility library hanging around that you use side-by-side with the builtin math library. Or you've got a weird utility library that just wraps the math library. Hell, it doesn't really make any sense that they have a `max` function for floats and not for integers. In fact, I wouldn't be surprised if the authors of the math library didn't actually foresee the problem with casting and expected people to do type conversion. I don't know why you keep using the word "afraid". Good programmers don't bake in all of the low-level logic to their projects. Good programmers don't try to reinvent the wheel constantly. Good programmers aren't *afraid* of doing either of these things. In fact, sometimes its rather pleasant. However, on large projects, it's almost always better to lean on already existent functions to reduce code complexity. Baking your own `math.max` for ints is actually reasonable, given that `math.max` for ints doesn't exist. But it's not reasonable for `math.max`for ints to not exist.
Yes, I saw the example. What the example doesn't make clear is that you can have the parameter be a specific type. You should probably change the example to: `func RoundTripper(r http.RoundTripper) ServerOpt { return ServerOpt(roundTripper(r)) }` and `rt := roundTripper.Get(opts).(http.RoundTripper)` Now it *will* be a http.RoundTripper since it is checked by the call to `RoundTripper()`, and it will be casted to that in the receiver. `rt` will not be type `interface{}`, but a `http.RoundTripper`.
Sure, thanks. that's a very good point. I updated the examples and the docs.
That's indeed one of the problems with vendoring. But it's the same like when there are fixed dependencies to a given version. *sigh* Sadly I don't have a very good solution for it.
How is this heuristics data saved?
&gt; But why would a language implement an equality operation for such datatypes if it cannot, in fact, guarantee equality? Equality is guaranteed on floats, and it is extremely well defined. The problem is that you are thinking of floating point numbers as real decimal numbers; rather than binary numbers used to _approximate real decimal numbers_. I won't go into more detail here because there are so many details to cover, but in short, floats are not magical like you think they are. Having floats represent real decimal numbers rather than an approximation would be very expensive and needless for many use cases. I encourage you to research this more online, see [wikipedia](https://en.wikipedia.org/wiki/Floating_point) for example, to get a better understanding. They're tough to understand. Sorry that people are down-voting you. I find that annoying personally because it stops other people from being able to learn things like this (now that it's hidden at the bottom). 
 Thanks for responding try this project works well create me the backend to the proxy and you have a log on exa, but the problem is that I can not modify headers http direct sending to the proxy could give me a idea as capture headers pass them to string modify my taste to return them send them to the proxy etc I hope I can help is grateful it is the project thanks por your help https://github.com/dgryski/dhd
If you build it, they will come. ;) I did see the referenced repo, but didn't support users at the time. I also found a lightweight client which used the REST api under the Facebook Go repos. Just would be nice to have a first class option with documentation.
Just a joke, bro.
Funny stuff. 
I agree, Nate. It was actually the very first version that I wrote. But, after a while I dropped it because I always set the default value. I am still not sure if it's better to have a IsSet() method or change Get() back to (val interface{}, ok bool). What do you think?
Discussing this with a few friends, I decided to revert the API to (v, ok).
just write your own max function for your type as a private function at the bottom of your file. it works fine.
I'm not sure I agree with Go's philosophy of being "unreasonably practical and simple". To some extent, I see where it's coming from. However, I don't know that I agree with sacrificing power for an abstract notion of simplicity. If you're coming from an extreme variant of this viewpoint (which you seem to be), then I understand your point of view in most cases. However, in this case, I disagree that it's as trivial as you're making it out to be. My ideal `math.Max` function (for ints) would looks something like this: func MaxI(nums ...int) { max := nums[0] for _, num := nums { if max &gt; num { max = num } } return max } Now, using this is really easy. Writing it is not the easiest thing in the world--it's prone to bugs--but it's not too bad, either. Inlining it adds complexity that's unacceptable; this especially applies when you're trying to get the maximum value of a set of variables rather than a slice. Then it becomes this unwieldy mass of incredibly repetitive and nearly irrelevant code.
Go's idea of simplicity can be limiting, and it depends on the kind of code you're writing how much that gets in the way...for example, I think that for certain kinds of mathematical code, operating overloading can help clarity of code *a lot*, and Go doesn't have that. Similarly it definitely does not lend itself to a functional, general list-processing style, as elegant or appealing as that style can be. (I do agree that in most cases it's better to use a function than "do it all inline," but you just have to right the functions yourself, for your specific case a lot of the time.) By the way, your ideal MaxI for ints is going maybe a little against the grain of the language. Thoughts: By using '...', your suggesting you'll be typing out all the arguments in the code. Are you really going to have more than two items you're comparing? Even then, would it be sufficient to just go max(a, max(b,c))? The downsides of using a slice argument: - It's slower (because it needs to create a slice) - You crash at runtime if you happen to call the function with 0 arguments or an empty list If you realllly wanted the list-max, I'd maybe consider doing this func maxlst(m int, xs ...int) int { for _, x := range xs { if x &gt; m { m = x } } return m } to at least avoid the crash possibility. But I'd be surprised to see code where either max(a,b int) or maxlst(xs []int) wasn't more appropriate. 
This: the representation is a data issue and makes sense at a technical if not intuitive level, but the operations permitted on the datatype are a language design issue and should put intuition first. Either find a way to guarantee intuitive equality, or if the datatype is hostile to such comparisons, forbid them or gate them behind a compiler pragma or the like. If you straw-poll the Go community, how many are aware that floats don't compare equality the way you think they do? The ones who know are probably from that slice of experienced coder who can quickly adapt when faced with a language design that behaves differently from C.
&gt; If I'm missing a good reason why, please inform me. A good reason is, that a) you don't want to define your own floating point standard in your language spec and b) IEEE-754 defines `if x &gt; y { return x } else { return y }` to be something, the author of the math package considered less helpfull than the behavior of math.Max¹. &gt; The problem in this instance is that Go provides a standard library implementation of min and max for floats, which encourages bad conversions. I don't see how. It is clearly an implementation for float64s, no? As far as I can tell, if you are trying to use it for integer datatypes, the compiler will blatantely tell you, you are doing something wrong. In fact, that's the whole reason why strong typing exists in the first place: So that you *don't* inadvertantly convert between types, but have to think about whether or not a conversion is correct. &gt; I'm simply arguing that the author is pointing out a quirk that is only revealed in the common case because of Go's incomplete standard library. I'm still unconvinced of this. I think "people come from weakly typed languages and thus usually don't think about whether conversions are correct" is a much better diagnosis. Sure, you could *also* make it easier for them to write small-ish correct programs by putting a gazillion more three-line-functions in your stdlib. But ultimately, they still have to learn at *some point* when conversions are correct and when they are not, because they will do them all the time. [1] I am generally avoiding doing stuff where this might matter, so you'd have to ask the author of the math package as to *why* they thought this. But I think it's both reasonable to use an existing, widely used specification of floats for your language *and* not agree that what it defines for certain functions is *always* the right thing.
The flag package has an isset method, so maybe that's the best lead to follow.
http://anvaka.github.io/pm/#/
If we have a few options sure, but when you have a handful of them it'll get very messy, especially when you want to have default values and flags. I've use that mechanism for a few years, and believe me it's not a pleasant experience neither for me nor for the end-user. Consider this as an example: https://godoc.org/github.com/kandoo/beehive#HiveConfig https://github.com/kandoo/beehive/blob/master/hive.go#L143 Try to explicitly set the listening port, but reuse the default config. :-) This is what I'm trying to improve and because of that I have created args. 
Yeah, 'against the grain' is obviously just a vague and subjective thing to say, and in the cold light of morning, maybe even a stupid thing to say. :) I just meant you're trying to write a fancy, general case max, whereas Go tends to reward doing the stupid, simple, specific-case thing. Aaaand yeah maxList is probably a better name than maxlst. I have an unhealthy hatred for vowels, sometimes. Something about my first exposure to terse C code after being educated in the reallyLongNameObjectOrientedOrthodoxy was just so cool and sexy seeming, and it's still a little hard to shake. Anyway, a few points: Performance of max: Probably not something that's likely to matter. The fixed-args function should get inlined, though, and be equal to doing it inline. Not so with the slice version (or even if it gets inlined, you're still making a slice). I think not having overloading is a great example of the sort of trade-offs go makes. On the one hand, not having overloading sucks. On the other hand, the whole thorny question of overloading rules is just *eliminated*; that's something you just don't have to think about, at all. It also makes it crystal clear, for both humans and machines, what code is going to be called. For example, there's a nifty tool called godef that jumps to the symbol under the cursor. Go's simplicity makes this tool easier to write because it doesn't have to consider the arguments of the function to figure out where to go; in general, a simpler language will be easier to write tools for. I feel like every C++ IDE I've used still can't get this simple 'jump to symbol' functionality right 100% of the time. Probably the closest was WholeTomato back on Visual C++ 7. Xcode, ha. Another counter-example: Doing rename refactoring correctly in C++ is incredibly hard in the presence of templates. E.g. struct A { int foo; } struct B { string foo; } template &lt;class K&gt; doThatThing(K k) { cout &lt;&lt; k.foo &lt;&lt; endl; } Good luck ever getting a tool that lets you automatically rename A.foo to A.bar without breaking your program. 😈 I would probably write your multiple-case max like this: maxDim := max(frame.clientWidth, max(frame.innerWidth, frame.InnerHeight)) Pretty? Nah, but easy, simple, and fast. (And I would define my own private 3-line max at the bottom of the file.)
Working on it. 
Awesome! That makes it a lot more clear. Thanks!
Thanks for the feedback
On the contrary, this kind of thing has to be repeated again again and again ad nausea .
While I like your idea of having named optional parameters (and the order not being important), I find the resulting code hard to read, but that may just be a personal thing. In Python, kwargs is a dict. Why not emulate that in Go by making a `type Args map[string]interface{}` with getters like `Args.String("param")` that return (possibly nil) pointers: http://play.golang.org/p/ZOUfQxnqgs 
We are hoping to record all talks.
Doesn't make it any less sad. I shudder every time I get a password reminder that's actually just my password.
Awesome, thanks!
Is this staying that Go 1.5's collector is actually slower? Or am I crazy?
That's exactly what I've done: https://github.com/kandoo/beehive/blob/master/app_test.go#L121-L124 And I personally prefer the new approach over this older one. Personal taste maybe. :-)
Portsmouth/Southampton have a decent tech scheme, there is a fairly large php user group that has meetups once a month in Portsmouth. I work at a decent sized tech firm with a few people keen to join, and I know that there are other companies around here using Go.
I have never used RabbitMQ, but you should totally take a look at martini for REST APIs https://github.com/go-martini/martini About having producer-consumer loops inside the app, I suppose is for testing purposes, try with in-built testing package for Go. http://golang.org/pkg/testing/
Why? Why can't you create the comment immediately? I've used this library: https://github.com/streadway/amqp , but only on the "producer" side. It's easy to use. If you don't want to create the comment immediately, you can use a buffered chan.
OK, that's a good reason. Read https://github.com/rabbitmq/rabbitmq-tutorials/tree/master/go &amp; https://godoc.org/github.com/streadway/amqp
Its not idiomatic to how Go was designed. The creator of Martini even wrote a response to the criticism of it saying he built it before fully understanding Go. I reccomend starting with standard library only and going to 3rd party when you see a need. You will most likely use the Gorilla MUX rourter, but I recommend building your own first before jumping to that. Look at Go as modular rather than one framework to rule them all. Also ORM is a tricky one in Go. I use Gorm, which can be really nice but I sometimes wish I just abandoned an ORM and went with the standard library or maybe Gorp. Go is really fun though so enjoy the learning experience! 
Hey buddy, this is pretty nice. How was working with the docker deamon, is that library your using to interact any good? 
Martini due to the amount of reflection use and dependency injection leveraged is quite a bit slower than other frameworks. Though when I say quite a bit slower we're still measuring in the nanoseconds range. We actually run a production REST API in Martini. At the time most of our developers only knew PHP (our company recently switched to Go) and Martini was the most familiar feeling to the team to allow us to deliver a product the fastest. Is it fast for us? Go/Martini has never been a concern for what it actually does. Will we rewrite it and ditch Martini? Probably. 
&gt; Yep this, and if you need to handle a more than average load on the reverse proxy, consider tweaking the http.Transport member variable MaxIdleConnsPerHost. I think the default is 2 but you can do something like: &gt; &gt; &gt; &gt; http.DefaultTransport.(*http.Transport).MaxIdleConnsPerHost = 50 If it is a proxy, but how I can do so that you receive or read the server response sorry I am new to go you would appreciate your help 
please helmpe necesito su ayuda 
As people have been saying, a distributed file system would be really good for this. You can deduplicate for free by saving files as a sha1 or some other has and using parts of that in your directory structure. You could also use that a key in your database if you so choose... I'm not quite sure how you plan on linking images with users or names etc... But: image.jpg gets uploaded hash it: the hash is aabbccddeeff Store the image in aa/bb/cc/ddeeff.jpg add line in the db on key aabbccddeeff add desc / title / owner / link / etc to that row. ? have fun? Just an idea. 
Haha, yeah it is a mouthful, I admit. Anyway, it's been a fun thread. :)
Oh this is nice, I didn't know about the 202 status code.
&gt; We marginalize people based on preferences of experiences with different technologies. Why is it okay to make fun of Windows or Ruby or Java? Even if we think we’re just being derogatory towards the technology itself, the users very often have made it part of their identity. These jabs divide us more than they bring us together. My first ever exposure to Go was [a video by Rob Pike](https://youtu.be/cN_DpYBzKso?t=4m27s) where he discussed getting gophers to burn C++ books. Personally, I realised it was just a joke and he didn't actually endorse the idea of burning any books, let alone C++ ones. My question is - is this sort of joke no longer kosher? Or is it allowed if we can come up with a reasonable explanation like &gt; it’s not C++ itself at fault, but a complicated development process that got out of hand at Google. I only hope that these efforts to be more inclusive (which are laudable) don't devolve into witch-hunts over jokes. I think in this specific case, the problem is less about the jokes and more about the people who are outraged over them.
FYI, your page layout on an iPad in landscape keeps recalculating the widths of the sidebar and content columns, making it impossible to read that way. In portrait the content column is so narrow as to make even your punch card-friendly code wrap, so the code becomes hard to read. Reader view doesn't even help, as the code comments are low contrast enough that reader view makes them white on white. 
Great article, really enjoyed reading it, thanks. One question: at the end, you access the node's pstore to verify that the entry has been committed. Can you do this without knowing about the underlying storage? eg. if I am a user of the system and I want some sort of acknowledgement that the message I `Propose()` has been committed (at least to the leader's journal), is that possible through the raft API? Or if not, how does one implement retry logic?
Was that kind of joke necessary in order to say how Go helped simplify their system designs? I know inflammatory comments get views and stir up controversy, but does that create the right kind of conversation?
I think you could argue for either perspective - that it was just a joke or that it was an inflammatory comment designed to stir up controversy. I personally think it was the former. I have no problem if you disagree and hold the latter view. However, if someone who thinks in a similar fashion also starts a witch hunt and *demands* an apology for that comment, it wouldn't be constructive at all. In this case, its Rob Pike. No one in the Go community is likely to demand anything from him (not even generics). If a lesser figure had said it or something similar (about Java, Ruby etc.) and made someone feel "unwelcome" as a result, the response might be different.
OK, thanks.
Maybe I missed it in there, but I still don't understand, what is the proposed scope of the CoC? What is the definition of the "Go community"? Each community seems independent, from Reddit to Slack to golang-nuts to IRC. Does it extend to Twitter and other social media?
That's right. I actually used a similar approach, an instance of the config to store the default values: https://godoc.org/github.com/kandoo/beehive#DefaultCfg But the problem is if I get a 0 value from one of the fields in the configuration struct, is it set by the user to 0? or is it not? Still really a matter of taste though. :-)
Neat. But why Martini?
I agree with your statement 50%. Do not use Martini. But you don't need Gorilla or Negroni either. The best thing I ever did for my web application was writing my own muxer. Sure, I initially started using Gorilla, but I soon realised it didn't *fit* my needs perfectly. Looking at the Gorrilla Mux source code made me realise that I could easily cut out the middle man &amp; doing so also cut out *a lot* of overhead. It's can't be overstated just how much overhead these libraries add. They're great to get you started, and I would use them for simple "Hackathon" style hobby projects. But for real apps you're building - do it yourself.
I just want to say that I posted this in text, but it was blocked by reddit filter, and after talking to the admins to this subreddit, they said I should write a blog post instead and link to it. And that is what I'm doing. I'm really hoping for a sincere discussion so I can make the marketplace for my users. Thanks!
Why did you choose MySQL as the backend instead of, say, redis?
You have context, so something like "hb" seems reasonable and straightforward. But to someone without context it means nothing. Code is read more often than it is written so choosing appropriate variable names is crucial to ensure that those reading do not need to spend extra mental cycles mapping short variable names. I haven't read your code yet, but I'm guessing that something like "heartbeat" would've been a better name choice. It's straightforward and conveys what is being stored in it. Plus all modern code editors do name completion, so there's no need to use short variables under the guise of saving key strokes :)
I actually very much agree with you. I started with standard library and went to Gorilla for the muxer just because I wanted to save some time... I actually like Negroni... But yeah you can essentially build it pretty simply or something like it...
When using Negroni (or Alice) I quickly realised that "middleware" really only applies in a framework context. Seeing as you're building software from the ground up, with awesome first party libraries, in my opinion it doesn't fit in the same way. Why would you need middleware if you're building the routing engine?
I don't see how mifdlewares only applies in a framework context. I mean essentially I'm building a custom framework for my application. I like the middleware pattern for auth and handling some session data. 
So if you were implementing something like `encoding/json` with a better API, how would you easily configure json.Marshal to work with your own type? Would you require even common things (say `json:"title",omitempty`) need to implement their own `encoding.TextMarshaler`? Would you pass some kind of config into marshal? Or is there a better, easy way?
I always get cross when I'm compiling. Usually because there's an unused import of fmt I've forgotten to remove.
I just use goimports.
Honestly: I don't have a good solution either. In particular as we are stable now. I would probably start by putting tags in the language as package-namespaced typed identifiers. If that is unacceptable, because the spec would get too complex (which I would understand) the API would need to be different. Given the language as is, the best (as in most "correct") implementation would probably be some kind of visitor-pattern. You pass a closure to json.Marshal, that decides in what way a given field should be marshaled. But, I didn't really want to hate that much on tags. They are an uglyness, but one I can live with being in the language. But I wouldn't promote them and in my opinion we don't need more packages that make overload them (for example I saw some kind of ORM-like package that uses the 'db' tag-key). Find solutions that work together with the compiler.
Author here. I used this library ( https://godoc.org/github.com/fsouza/go-dockerclient ) to interact with it. It uses the remote API to interact with the docker daemon. You'll have to open that port if you are going to connect to it remotely. Since this port will be open, I added an HTTP authentication layer using nginx which will then proxy pass the request to the daemon.
I'm a go beginner. I searched for a small web framework and martini was the first thing I found. It's very easy and suitable for my needs since I have only 2 endpoints.
As far as I can tell, it includes all of those places that you mentioned. I think it's a little sad that there's very little discussion on this thread. I think people just got tired of it, especially when they saw that Andrew Gerrand wasn't really looking for feedback about the CoC from Reddit, only confirmation for a decision that had already been taken. Personally I wish they had extended the Go philosophy of "less is more" to this area as well, and it seemed like most of the people on reddit seemed to agree. But Andrew decided that in this case, "more is more". What's more, since he solicited feedback here he can now claim that it was endorsed by the community when it wasn't.
Hello. Use it as example for your projects (or learning), or as complete tool. I share this with pleasure. Hope for someone it will be useful. Have a nice day :) 
So, in theory this should be equal var got []float64 got = make([]float64, 0, 0) want := []float64{} if !reflect.DeepEqual(got, want) { fmt.Printf("got:(%T,%v) want:(%T,%v)\n", got, got, want, want) }
On the other hand it just got harder to cross compile for something like MIPS.
&gt; His usecase was that the PDF generation is triggered from a Rails app - so this wouldn't work. Assuming there is no load issue, this will work perfectly with golang. Rails app calls a golang API server which can immediately return the response back to the app while creating the PDF in the background.
rconn, err := net.Dial("tcp", dst) if err != nil { log.Println("errorconnectiongto",dst,":", err) // lconn.Close() return } I put part of the code I need is to be able to edit the payload of rconn which is a variablde net.conn and to its ves io.write added this so help entener my problem thank you 
try https://github.com/smallfish/rabbitmq-http ?
It makes starting with go SO much better.
Yes. The playground says those are equal.
Thanks, yep - should be saving the leftover bytes. It's definitely not very crypto in nature, however, I currently need it to allow the user to [generate the same SSH key on demand](https://github.com/jpillora/chisel/blob/master/share/ssh.go#L20-L27). What would you suggest as an alternative? 
Just a heads up: Your post is incomprehensible. Try restating your question more clearly and with actual example code that compiles.
Nice introduction, a very easy read. Hadn't thought of using tags for validation but it's a good use case.
They are not equal in a literal sense, in that the memory used by each is different. That said, I think they behave exactly the same (trying to think of somewhere they don't; can't), so I'm not sure exactly what purpose is served by not considering them 'equal' for DeepEqual purposes, other than philosophical purity. (In contrast, a nil map doesn't act at all like an empty map, tho I wonder why [perf?].)
Is there any benefit to experimental packages like this living under `golang.com/x/exp/...` rather than it being just like any other third-party package like `github.com/google/gxui` is? Especially since they're trying to dispel the notion that it's blessed and stable.
well if you read the post, it said &gt; It is under golang.org/x because I want to use the same code review process as everything else under golang.org/x, a process I use every working day.
Looks interesting. One quick comment, though. The line `msg := arg.(string)` in the readme's Simple Example is redundant. The only thing it does is cause a panic if `arg` isn't a `string`, which I suppose could be useful, but probably isn't what you're going for here. `fmt.Printf()` takes a list of `interface{}`s after the format argument, so msg just immediately gets reencapsulated.
If you are serving a lot of requests starting goroutines without control how many of them are preset is not smart decision. Goroutines are cheap, but too many of them can slow down system. With this you can limit number of goroutines, and you are able to do job(s) concurrently.
[Djinn](https://github.com/thrisp/djinn) does much of this, from a different perspective perhaps. I'd be interested in how you would compare temple to Djinn.
Followup: so I'm still learning how go works, but I liked the answer about long polling, and I liked the answer about using a goroutine. I tried this and it totally works... func main() { initializeDB() // get a connection to dat yung db go initializeRabbitMQ() // listen for messages goji.Get("/", Root) goji.Get("/pdfs", GetPdf) goji.Post("/pdfs", CreatePdf) // more routes... goji.Serve() } func initializeRabbitMQ() { // dial rabbitmq, setup channel, setup exchange, setup queue, start long running consumer } Is this approach idiomatic to Go? Any really obvious issues? I guess I'd probably want to consume each message on my RabbitMQ channel/exchange/queue in a goroutine so it doesn't block. I dunno.
One thing I ran into when attempting to play with QT+Go, is that Go really does not like it when you mix Go and C/C++ code in some ways. Specifically: channels and goroutines on code invoked from QT. Panics and frozen processes were guaranteed on my workbench when doing this. So that leads me to my question: does this library work okay with starting Goroutines and using Channels in Go code invoked from Lua?
I have not had time to work with goroutines and gopher-lua. However, according to the documentation the LState object is not goroutine safe. Instead one LState object per goroutine is recommended. See https://github.com/yuin/gopher-lua#goroutines for more information. 
Go HTTP server as you said already works in a way that it creates one goroutine per request. Imagine situation where you have to do concurent jobs for almost every request. Not always you can know how many goroutines will be needed to finish job. It can be 1...n. In this case goroutines pooling makes perfect sense, because it will prevent one request to eat too much system resources.
Use this with great care. This actually introduced a dangerous bug for us once. Instead of importing html/template, it chose text/template, which doesn't do HTML escaping. Boom, potential security vulnerability.
I'm curious what the reasoning is for that. Licensing/control? Difference of opinion on implementation details? Something else?
I'm just going to ask again for benchmarks or something :) I think we can discuss theoretically for great lengths, whether or not this is helpfull, but ultimately it comes down to real-world usecases. So do you have some example of stuff that actually, measurably got faster using a goroutine-pool? If so, can you share?
IIUC you still need OS X for the iOS SDK. 
&gt; If it's s bunch of white dudes then that defeats the purpose. How do you come to this conclusion without prejudging either minorities or "white dudes"? 
Why invent your own when you can use one from NIST SP 800-90A? Specifically, check out Hash-DRBG or HMAC-DRBG.
Yes, from what I understand now I believe == should return false, and reflect.DeepEqual should return true. After all, DeepEqual cares about semantics, not memory equality.
I'd agree that it would be preferable for that condition to exist (the person to have their preferences met), but I cannot agree that gender discrimination and exclusion is okay for the sake of making someone feel better.
The entire purpose of the conduct team is to make people feel better. If it doesn't then it's useless.
Well, seeing the team choose to implement gender discrimination makes me feel worse, so it's actually counter-productive at the moment. Under the current setup, if the 4 best candidates for the 4 positions are women, only 2 of them will be allowed to hold the positions due to gender discrimination. I'd rather not see the community have this kind of gender discrimination. It suggests women lack some abilities that men have.
You seem to have no problem voicing your concerns so I think it'll be okay. (No snark implied.) It's difficult to balance everyone's concerns and preferences, so I don't expect my decisions to be popular with everyone.
&gt; You seem to have no problem voicing your concerns so I think it'll be okay. (No snark implied.) You can't know what I think and feel, or how this will affect me. The reason why I'm discussing it is because I'm trying to tell you it adversely affects me. This reply of your's appears to be a flippant disregard of my complaint of gender discrimination thereby making my experience with the community more hostile.
The settings in the full \*tls.Config object are there for a reason. You're generally doing yourself a disservice to try to simplify them. The TLS interface in Go itself is already pretty much as simple as it can and should be.
While true that a statically build go binary needs very little, one thing we see quite often are developers on OSX and WIN workstations that need to build go apps that deploy on Linux clusters. While they could use the cross-compile features of Go to solve the problem, it is common to have the Go program built inside of the Docker instance. That's probably why you see Go images with the go toolchain included.
I made some changes to support external plugins using RPC instead of compiling the bot to add another plugin. In theory this should allow anyone to write plugins, using any language they choose, although I've only been able to test it with a Go plugin. 
You make some good points, but your perception of the "majority" is skewed. The most vocal people are not the majority. I have spoken to many, many people about the Code of Conduct and the vast majority are in favor of the terms as I have described them. As for witch hunts, I guess you'll just have to trust my ability to handle those kinds of issues fairly. There's not a lot I can offer beyond that. (And frankly I don't see how this is really related to the code of conduct. The first incident you pointed to occurred in relation to a project that had no CoC.) WRT people feeling excluded: if someone tells us they feel excluded, we should think about why. Maybe we should do something differently. Maybe not. But it's important to be receptive to feedback, and to have the willingness to be more inclusive where it is reasonable to do so. &gt; Take the example of the person who identified as a "Ruby developer" and who felt "unwelcome" at Gophercon this year. This is crazy, There may be a lot of ex-Ruby programmers in the Go community, but maybe someone _was_ actually rude to that person for being a Rubyist. You don't know, and neither do I. (Yet you call their claims "crazy?" Doesn't seem fair to me.) The only way we can know is to provide an avenue for people to give us this valuable feedback. I know for certain there are rude people in this community—to the extent that it drives other people away—and I would like them to knock it off. Edit: I guess I should add: While there are a few high profile incidents of witch hunts resulting in people being (perhaps unfairly) hounded out of various communities, there are ~two orders of magnitude more incidents where people are made to feel unwelcome or uncomfortable, are harassed, and are even assaulted. These latter incidents are the issues that motivate the code of conduct. Hopefully we won't have to deal with the former kind of incident, but if we do I hope we can do it well. (And as I said, these incidents can occur regardless of there being a CoC in place.)
Why? Because I'd never heard of DRBGs before, hence the post asking for suggestions
I just saw this, and wanted to say that this makes complete sense and is very helpful, yes! Thanks! 
I was speaking on how the majority of reddit felt based on the upvotes for the top rated answers in that thread. No doubt there are alternative viewpoints, but /r/golang seems concerned about potential abuses of a long, descriptive CoC. Dismissing that as "merely most vocal" doesn't seem to be correct. The incident I linked to doesn't have a CoC, and that's why the protestors were unsuccessful in having a contributor removed for views he posted elsewhere, not on gitter, or a code review, or an issue tracker, or anywhere else on github. If they had had a CoC, blackballing him would have been straightforward. &gt; maybe someone was actually rude Some would feel that adults can handle rudeness as a part of everyday life. As a C++ developer I could have chosen to feel unwelcome when Rob Pike made a joke about burning C++ books and *demanded* an apology. Or I could haven chosen to act like an adult and take a joke. I'm glad I chose the latter. We as a community are placing a great deal of trust in you. I really hope you succeed with this, and that our community is as welcoming as possible for people of all backgrounds. With effective arbitration, I think all concerns can be addressed, including those about false accusations. Good luck to you and good luck to us all :)
Hugo.
&gt; allow the user to generate the same SSH key on demand. Don't do that. You might as well just use passwords. You can't have "deterministic" "crypto/rand" reader... those two quoted phrases can't co-exist. Don't do anything that involves trying to generate "deterministic" SSH keys, it just means you have "things that look like secure keys but aren't". &gt; What would you suggest as an alternative? Probably "figure out how to use ssh-agent". Some people consider that less secure than some alternatives, but we don't need to worry about them, they've already passed out due to explosive nasal phleborrhexis after seeing "deterministic SSH key" previously.
crazy ... really?
:(, then it is not cool. Many other solutions don't need, such as Adobe AIR.
But HN says I'm not supposed to like uber! Just kidding. This is awesome. I've been looking for something to make some graphs for me... I'm not quite smart enough with excel or anything to make my own. I really like Dave's memory profiler. Also, I like their code quality.
https://github.com/kisielk/goflamegraph
Can you explain what millisecond timing exactly means? For example I tried it on some of my code and I am very positive functions should be executing faster than 200ms. Maybe this is the total time this function was executing in the entire recording timeframe? So from 30s of recording time I have 200ms of exeuction for this particular function, no?
That's fine. Now you know :-) I suggest implementing HMAC-DRBG, as it's considered safer http://crypto.stackexchange.com/a/1395
Up until yesterday, it was an exact copy of my site's layout and style (yes lots of people use Hugo with that theme, but I put a lot of work into customizing the theme). It still is, just with a different color sidebar, which is fine, I don't mind. I just didn't want it to looks *exactly* like mine, because then it could be mistaken for my website or at least cause confusion. Plus I spent a lot of time picking out that particular color purple ;)
This is how I'm managing errors on the APIs I've been developing: http://play.golang.org/p/YHS-hxlaP1
No, he's just an idiot that doesn't read the install instructions.
Thanks for sharing, but no. I don't think any of them have merit. It's basically "I need to RTFM to use it? This software sucks!".
Dumbest article EVAR
It's no more safe compiling yourself than running github binaries if you don't read and comprehend the full source. Gah.
Am I the only one that thinks that go already is successful?
You are correct. It's time spent during the entire profile. 
So called article is just silly and whiny, does not even deserve a real criticism. On the other hand if the title was "Why go needs some minor improvements for the convenience" it would have been a good start.
While the author obviously needs to RTFM, I do agree the go tool could be a little more friendly to new users just wanting to install software and get on with their day. % go get golang.org/x/tools/cmd/goimports package golang.org/x/tools/cmd/goimports: cannot download, $GOPATH not set. For more details see: go help gopath Considering somebody who doesn't have their GOPATH set is probably completely new to Go, I think "go help gopath" is worded a little confusingly. It says "Each directory listed in GOPATH must have a prescribed structure:", which is odd because $GOPATH doesn't need to have a structure. It doesn't even need to exist. "go get" creates it if it doesn't exist, and it creates all the aforementioned structure.
I agree, but that's a complaint to bring up with the maintainer of the brew package, though. 
That looks pretty impressive. Been a long time since I actually built a website, but going through the example app, this seems to do a lot of heavy lifting and 'mandatory' boring stuff for you.
[Image](http://imgs.xkcd.com/comics/duty_calls.png) **Title:** Duty Calls **Title-text:** What do you want me to do? LEAVE? Then they'll keep being wrong! [Comic Explanation](http://www.explainxkcd.com/wiki/index.php/386#Explanation) **Stats:** This comic has been referenced 2307 times, representing 3.1376% of referenced xkcds. --- ^[xkcd.com](http://www.xkcd.com) ^| ^[xkcd sub](http://www.reddit.com/r/xkcd/) ^| ^[Problems/Bugs?](http://www.reddit.com/r/xkcd_transcriber/) ^| ^[Statistics](http://xkcdref.info/statistics/) ^| ^[Stop Replying](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=ignore%20me&amp;message=ignore%20me) ^| ^[Delete](http://reddit.com/message/compose/?to=xkcd_transcriber&amp;subject=delete&amp;message=delete%20t1_ctdhl2l)
This looks really promising, thank you for sharing.
&gt; I’d rather not run binaries from Github on my machine &gt; sudo brew install go
I disagree with the opinions of the author, but I don't find it the least bit stupid. I have experienced more than one non-idiot (though a novice) struggling with stuff like this. They didn't write a blogpost, but they *did* have the same problems. As such, the author of this post certainly expresses valid opinions (even if the title is truly horrible. But a horrible title and even a horrible blogpost is not a reason to belittle a person). I do think, the expressed criticsm has at least some merit, even though I don't really agree with all of the solutions given. Disagree with that person all you like. But don't call them an "idiot" or "retarded". Be excellent :)
Interesting. :P We have an internal version of Bamboo that does multiple exports. What this means we refactored the codebase to support many requirements that cannot be satisfied by HAProxy, e.g. consul export, websocket, iptables, nginx, apache etc. That version of Bamboo is planned to be released before MesosConf. We also plan to release a cross datacenter Mesos deployment tool with support of custom plugins that will work with Chronos, Marathon and many more framework &amp; custom deployment workflow. There's a plan to support of rolling % traffics between multiple environments.
Informative, but I'm pretty sure CERN's http server wasn't NCSA: https://en.wikipedia.org/wiki/CERN_httpd
makes sense, didn't consider having to deploy on a cluster. how are you guys finding kubernetes ?
More I learn Go, more I think it will be successful and I am pretty sure that soon great things will happen between Go and Dart. The Go community is great, the tools are great, and all works on fully free distro Archlinux / Parabola. Your title is big jstuartmill, but I don't see your arguments.
This is interesting. If you're looking for something a bit lighter weight for a simple site, http://gohugo.io/ is a good option.
Maybe rather than take the example you would mentally extend the suggestion to "do whatever other Homebrew packages do, because Go is likely not the only package it can install that wants to set an environment variable".
I saw one of those, I think in that color, and was told there were only about five made. I don't know if that's true or not, but I think he got it at a Go convention a while back. It seems like rare stuff.
Scrolling down on that page in chrome on iOS 9 is broken. The fonts are being resized up and down for every swipe.
Its really cool, and it could be extremely useful, but the type assertions put me off quite a bit. It is also unfortunate that the anonymous functions need types in the signatures, since that also increases the size, and hurts readability. It is probably as good as we are likely to see in go though. Very nice work. Another approach is the code generating way: https://clipperhouse.github.io/gen/
Can you share the problem you solved with this?
Obviously you can't have something that is **deterministic** and **truly random**... The use case, however - which you've neglected to attempt to understand, is to move the entropy back from the key into a passphrase for the *server*. This is *not* for the client so ssh-agent does not help users here. This allows users to setup a server without state contained in files on disk and also it allows it keep the same public key between restarts (key generation on startup is also an option). To me, moving the randomness back a step isn't such a crazy idea as to send the viewer into an explosive nasal phleborrhexis. And if it is, I appended the "Suggestions?" as to give you a clue that I'd like to be educated as to why. /u/dchestnykh on the other hand, offered [deterministic random bit generators](http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf) as an alternative, which is actually helpful.
Works now! Brilliant.
While this guy does need to RTFM, his complaints on usability regarding GOPATH creation are somewhat valid. I personally think it would be nice to have some safe defaults that do not require configuration. I do not quite see a downside to that approach.
It's fine, but AFAIK it doesn't implement the standard I pointed out, its: "Package drbg implements a minimalistic DRBG based off SipHash-2-4 in OFB mode." I also have a very simple SipHash-based DRBG (in counter mode) (https://github.com/dchest/captcha/blob/master/siprng.go), because it's fast, but I wouldn't use it as a general-purpose PRNG (e.g. I wouldn't generate cryptographic keys from it).
&gt;Note that the point of this article was not to promote a single tool, rather to provide an unbiased comparison of Flask, Sinatra, and Martini Cool, but why those specifically? &gt;With that said, I would select Flask (Python) or Sinatra (Ruby) By picking lines of code and a superficial look at respective communities? &gt;realpython.com Uh huh. 
Your docker file for go tells that you should spend a bit more time learning a language before you try to compare it with others.
That was disappointingly lightweight.
No, there are now at least two people that think Go is already successful ;)
Not sure if this is the best place to ask 'what else [if not Go]' Maybe you should add some more background like why you consider learning another (alternative ?) language.
Why do you think you'll get a good answer here? What interests you? If I were you I'd probably go for Scala tbh, to learn some functional programming. Whilst there are some interesting things to learn in Go it wont push you that much. I see Go as a nice alternative to a lot of things you can do in Java. Scala/Haskell will push you as a developer more. But anyway, you need to put more thought into this.
I think you should learn Go, C++, Python, ML, Common Lisp and Haskell. It's useful to know all of them.
If someone's asking why, show her/him /r/lolPHP
I believe it's this talk: https://www.youtube.com/watch?v=woCg2zaIVzQ The specific context was it was a small simple tool rather than a mission critical application. If it was the later case I'm inclined to agree
Which Python ecosystem?
Anecdote from the past: Startup company was moving fast. Requirements changed all the time. Business critical system amassed a lot of technical debt. Developers proposed rewrite but the answer was always no. Project manager secretly organised this rewrite without approval from the executive guys and just showed up when rewrite was 80-90% through. You now what happened next. He was fired. I had trouble understanding why at first. But with experience comes wisdom.
Kinda true, I can't seem to find a reason to learn C++. I've got some experience in C, and now in Go.
i don't think the Go maintainers care about the labels for features. I think they demand a concrete reason to add things and the bar for inclusion is really high. A common reason that people give for desiring a feature is "expressiveness" which has two problems. First, it is totally subjective; what the requester feels is expressive and "the way I think about things" may not be how I think of things. The second is that expressiveness isn't a goal of the Go language. The maintainers take the ethos and goals of the language very seriously. If this is a serious problem for you and you want to see the opposite of this take a look at Scala. I say all this based purely on my observations; I'm not a Go maintainer, so I might have it all wrong. On a related note, I'd love to see at least basic generics in the type system. :-)
Hah, you're right. Thanks, I didn't notice. 
It's a way to manage and isolate dependencies. http://docs.python-guide.org/en/latest/dev/virtualenvs/ This basically has all you need to know.
Excellent, thank you! Is it good practice to use virtualenv in any major project with dependencies?
Node.js isn't actually single threaded
Sure, it has a few extra threads - but they aren't for users.
Look at this similar thread on /r/rust and BE AFRAID: https://www.reddit.com/r/rust/comments/3crtcc/languages_to_learn_after_rust/ I'm quite interested in Pony -- Rust-like guarantees but a fast actor runtime. But Go has a huge advantage in being friendly to tools, especially for automated refactoring and formatting. It is also maturing really nicely now (regarding GC and platform support and so on).
Nooooooooooooooooooo. Oh hell no. No no no. Where are the synchronisation primitives in JavaScript? Oh that's right - there are none. Why? Because code only executes in a single thread. So you can't trash a variable using multiple threads at the same time. A function *always* completes (except when a `yield` keyword is called). That's why you always write Node.JS/JavaScript functions to complete quickly. No other function will interrupt your function.
No.
honestly it looks like rnn output.
It's implicit in the way that it's used as a conversation-ender. There are certain things that, if you mention them, will cause high-profile folks to regard you as "one of *those* people' and not worth talking to anymore. Anything even remotely functional is one of them.
Thanks, that's a good overview. One thing I'm still not clear on is how you expose your own code to pip so others can include it in their projects and all your dependencies automatically. I've only seen tutorials on pulling code in using pip and never how to push code in the other direction. This was one aspect of npm that I found to be very beneficial for the NodeJS ecosystem.
I think there's a certain level of expressiveness / extensibility that's *necessary* for a general-purpose language. A niche language forces you to think about things its way; a general-purpose language is able to see the problem your way, with a little convincing. Absolutely it's true that people have different approaches, and what one person sees as useful and beautiful, another person sees as junk. It's also true that if you try to throw everything in at once, you get what *everyone* sees as a pile of junk. One way to deal with that is to include what the language maintainers think is beautiful, and to say "if you want anything else, go write your own language". Another way is to include features in the core language with an eye to elegance — adding the smallest feature that *enables* the greatest amount of flexibility. What that means to me is not making Go a functional, reactive, aspect-oriented, object-oriented, etc. language, but providing whatever is needed for a motivated person to go off and write libraries/frameworks/extensions for any of those things which will be usable and which people can adopt if they like and ignore if they don't. I would venture to say that in the past, languages that have been really successful have included these kind of "escape hatches" more or less by accident — they had features that were used in unintended ways to do things that the language creators never envisioned, and those breakout features were popular enough to redefine the language and contribute substantially to its popularity. For example, C++ template metaprogramming is based on a completely insane combination of edge-cases in the language spec that few people even begin to understand, but Boost and C++11/C++14 totally rest on it. Now we're in a different, more-informed era of language design, and we like to think that we can avoid "accidents" like that with good design. But the truth is that we can't anticipate every need. The way to go isn't to make the escape hatches unnecessary, it's to make the escape hatches well-designed, well-labeled, and brightly lit.
Node.js performance is not a deal breaker for most tasks because many tasks are I/O bound not CPU bound (especially on the web). I can't really respond to those microbenchmarks except to say that v8 is probably one of the most optimized runtimes, so I would expect it to perform pretty well. I expect Go programs to get faster when they actually focus on improving code generation. It would be interesting to see how gccgo performs in that benchmark. However, one of the best talks on JS performance benchmarks I've seen is: https://www.youtube.com/watch?v=65-RbBwZQdU It's food for thought here. 
As someone who primarily develops in, and loves, Python I couldn't disagree more. Dealing with python packages, even with virtualenvs is painful because modules imports are cached by name and disallow multiple versions of the same library from being used without serious hacks. For example, If your project has two dependencies that each depend of different versions of the same library you're basically prevented from using those dependencies together. The first one to import the dependency wins and pollutes namespace for the rest of your program. npm, while wasteful on disk space (which we have plenty of these days), can successfully use multiple versions of the same library which makes using dependencies cleaner. It also installs dependencies locally to a project by default so you don't need the concept of a virtualenv. As I said, I love python, but lets not pretend virtualenvs are a great solution or that packaging in python is really that great.
We get a lot of the anti-go masturbatory drivel, sometimes it's nice for some positive posts =)
Lets not confuse package systems (though my exprience is that Python has worked more reliably and with less fuss than npm) with the ecosystem. My experience has been that npm is more often littered with half or limited packages, or packages that interact in unusual ways. To me, ecosystem is more about functionality available in libraries (including the stdlib) than it is about the particular package system you use. All that being said as well, working professionally in Python for about 7 years now I have _very_ rarely run into the cases you describe above. Like, probably a handful. pip requirements + virtualenv works well enough for me to not think about them.
Nope, I'm referring to the ecosystem of available and well-maintained libraries. In my mind ecosystem is larger than just the packaging system used.
You can install editable versions of packages, and you can install pip packages locally (ignoring pypi) as long as you use distutils. No need for it to be published on pypi.
Right, I agree that there's a lot out there and I don't _dislike_ npm or the node ecosystem. My point is just that I prefer the python ecosystem of available libraries because I generally find them more mature, stable, and fully featured.
Redigo is faster but less type safe than others. Depends on what you want. I went for redigo in the end, IIRC i switched from go-redis to redigo somewhere along the way. Again, IIRC batch operations are much easier in redigo which was the reason I switched.
Node js was nice because of the fantastic standard library. Easy file io, cyrpto, http, everything with simple implementations. But golang has an even more powerful standard library.
If you want to be able to do more organized, low level things but really can't have a garbage collector blocking evey so often, c++ is still pretty good (though I still find most code written in c++ so redundant and unreadable.
I think the packaging system and use of Virtualenvs in Python is definitely problematic for people new to Python, but like anything, it becomes second nature after awhile and is no longer the annoyance it was when I started using it in development.
Processes, not threads
Yeah, not disagreeing with the overall pattern, but I haven't experienced it being as personal as you described.
&gt; What are the messages sent by the server application? Are they guaranteed to be valid utf8? They are all generated by the Go JSON library. &gt; The code above closes the connection after receiving 20 messages. Can that have anything to do with the issue? No. It does that even when that code is commented out. That count is there only to prevent DOS attacks. It's reset every server game tick. (1/60th of a second.) We finally figured it out. There was a scheduling starvation that resulted in unexpected lag for the system that handles delta-time scaling between the client and server. The delta-time system was effectively acting as a application level heartbeat, and the unexpected lag could cause large enough gaps to set a timeout off, happening more often exactly while trying to log-in new clients. To figure this out, we implemented a python "dummy client" for load testing. We didn't absolutely need it, but it allowed us to compare between the two clients. 
I use it for project development, and then bake a container for deployment so I can be 100% sure that the system in dev/test/staging is the same as in prod and it moves through a little faster.
Node is performant for io bound processes. Out of the box you get some serious gains over any wsgi python framework. Most node libraries have async in mind which alleviates the problem of a sharded ecosystem, like asyncio in python. Not to mention Web socket support is pretty great in node as well. In python, json serialization of objects can be a real hassle, no worries in javascript. Simply put there are a lot of reasons to choose javascript over any other Web framework.
why not just use Scala? I'm genuinely curious as to what value java brings to the table in your case
Here are the issues as I see them. The two big issues, as I see them, are the language and the ecosystem. First off, javascript is a "ball of mud" type language. While a smaller project might be simple to do in javascript (and really that is pretty much the only place where javascript is OK on the back end IMO), anything that is large and complex will quickly start running into some pretty hairy problems. It is far too easy in javascript to do something in one place the completely screws over code in another (the mark of a maintenance nightmare). Further, as a dynamic language, there simply aren't good tools to help identify when you are stepping into those sorts of quagmires. I like a good typed language with nice tools to catch issues before they go live. Javascript is not that sort of a language. Secondly, the ecosystem. Javascript does have some nifty tools and projects, but my big problem with it is the fact that community is practically schizophrenic when it comes to their opensource libraries. What is popular in javascript seems to change with a stiff breeze. Further, many of these libraries never hit "stable". They are forever pushing out unstable versions. The JS community seems unwilling to commit to an API and that is a pretty big problem when you are trying to develop anything. Having some sub-sub-sub library change everything which causes breaks is a reality with javascript. Since javascript is a "fail slow" type language, discovering these sorts of breaks is damn near impossible until you run a large swath of the code. For my time, money, and sanity, I prefer type languages is good tooling. This is why I like languages like Go, Java, C#, Scala, etc on the server. The inconvenience of json serialization is a small price to pay for a large evolving project. Rarely have I seen issues caused by serialization. On the flip side, just changing a single method parameter list has caused me to have to update 100's of lines of code. I would never want to do that task in a language where that sort of thing is not an immediate compile time error.
&gt; These two ideas can be frustrating from those coming from a systems with a centralized trusted host. And refreshing when you see the 3rd or 4th build failure because npm or rubygems or maven has shat itself. 
npm still needs to do some network operations to grab updates and still sucks if you have a critical vulnerability or similar. one central place with a lot of risk. Vendor your code and run it off your servers.
I am also a java developer, and I have specific reason for wanting to try other languages. Mostly because I am interested in learning something new. I guess the question I would have for you is this. For what reason do you want to turn your attention away from Java? I am a huge fan of Go, but everyone has their own reasons for liking it. I am curious what your angle is on Java and why you are seeking something else?
Interesting, are you saying that it is generally faster to calculate in Go with int32 rather than int (aka int64) on x64? Or is that something specific to that benchmark? 
Well said. I think the only time NodeJS can be useful in back-end is for very small apps. I haven't had experience with NodeJS personally, but I'm pretty sure if the app grows a lot, it will be a major problem to maintain the code. Even Python has that problem.
Where do you store the users? Is it in a database or do you have to query all systems?
Ok. I recently played with an ldap server with similar needs. I used `gopkg.in/ldap.v1` This way you can query your active directory for users in real time. An issue you might run into is that there are also system accounts that look a bit like users. It could be how our AD was set up. You can use this tool if you like or put them into something like a levenshtein trie. github.com/jamra/levenshteintrie (disclaimer: I made this hastily and did not do thorough testing. But it should still work perfectly) Are you going for a web interface or a command line utility? Edit: I suggest trying things out by using their API before you play with ldap. It kinda sucks.
This why I leave this community, the circle jerking is just to damn high, that is not even funny.
I've seen many polarizing arguments and comments lately. It's a bit bemusing and sad to me. Try again later, please? I swear we have good discussions from time to time ...
Good catch 
It's a nitpick, but I agree. Searching is the action you'd use above what this does.
I'm forced to use NodeJS on the backend for front end package management. Gulp / Browserify / Bower. My app has a need for dynamically generated front end assets and they're the only tools that do it properly. I fucking hate it. Every unnecessarily nested async call makes me really annoyed. The language and its idioms are not intuitive. I am not a fan of the callback pattern, nor am I a fan of forcing async. Sometimes I want blocking, and I want to return something meaningful to the calling function. I don't know why you'd choose NodeJS voluntarily. Unless your only other programming experience is PHP.
I'm sorry to hear that
I don't think his methodology is terribly good, but it was interesting to see how many bugs and tests the average go repo has (well, files with "test" in the name, which may give an edge to go, since you must have test in the filename). I'd like to see someone do this in a more rigorous way.
It seems more idiomatic to me to have the concurrent function, printer, call Add(1) and defer Done(). All of which can be done in the anonymous func that is called with go keyword. Then the waitgroup is at a reduced scope and the code is easier to reason about. I would give an example but I'm away from my mac, using my phone. Hope this made sense
The first thing I noticed is that flags are defined as string each time you refer to them, making it easy to misspell. For ex, your own example has annend-b and your code checks for annend.b (with a dot). Having looked through all the options I could find, the one that stood out to me most is koding/multiconfig. 
Add(1) or Add(n), it is paramount that those do not happen _in_ the concurrent function, otherwise you have a race condition on the Wait() outside the concurrent function. Typically, I use Add(1) in the for loop right before go func(){...}() and avoid globally defined variables, like the waitgroup in the example, using a closure instead or pass it in at instantiation.
The problem is not with the channels! You are using a pointer in the channel and then keep changing the value of the memory location where the pointer points to. So the result will be random because it all depends on when the receiver looks at it. Here's the fixed up version that works as expected: http://play.golang.org/p/6r6d69KRk-
It's not breaking mine; however it does look like an old bruise.
&gt;Poor guy couldn't believe it when I finally broke the news to him that Node.JS was actually single-threaded. I find this quite alarming. The first thing I do when I find out about some new language/framework is to google it and find out what it's all about... Apparently this doesn't fall under the umbrella of common sense, though...
Yay arguments! Now I can get verbose test feedback and benchmarks! 
Yeah, I had started with go-redis but switched to redigo for the same reason.
It could also be a call to another function that would need the same lock - it was just shorter to show with recursion.
Has anyone else seen this before? It seems very un-Go-like to me. You'd have to locally define the 2 wrapper functions, and how does that make it any cleaner than the more explicit: mu.Lock() defer mu.Unlock() 
Becoming a 'Github Rockstar' would be more precise ;-) 
That makes sense for simple Lock/Unlock, where you can have private functions without locks, that you wrap for public functions: http://play.golang.org/p/n00ligphKU But there can definitely be cases where you don't want to hold a lock for the entire function call, or you want to release it/change it for a function call: http://play.golang.org/p/JjbuyxJJ3X So in the general case I agree with you, but there is no "one-right-way" for mutexes, since they can be so key for good multi-core performance.
It's a cute trick. However, since the functions are public, I couldn't help but giggle a little bit at the idea of people importing the package and having to "ruin" the cuteness by prepending a package name: defer sync.Un(sync.Lock(x)) 
Great job Fatih! :)
I thought PHP was the preferred method to allow shell access remotely via http.
It was a PHP exploit joke. edit: Having that sort of thing exposed over something other than ssh also bugs me.
I had sort of a mini epiphany the other day. We all know channels are a _type_. I've always thought of them as a _communication_ type since that is how they are documented. What I realized is that it is more accurate to think of them as a steam instead. I am going to go back and look at the examples with this new frame of reference.
Well of the hundred or so web frameworks for Go, yours has the coolest logo.
So just do it: Validate them. 
Couple ways. First is to manually get each form input's value with [r.PostFormValue](http://golang.org/pkg/net/http/#Request.PostFormValue). Another would be something like the Gorilla library's Schema package that reflects over the url.Values{} and marshals them into a struct that represents the form. Those are the 2 primary ways. As for the actual validation (e.g., is the provided input a valid email? Does the comment contain profanity? Etc.) that'll depend what you're looking to do. Emails can be parsed to see if they contain an at sign and a period and only contain valid characters (could use a regex but I'd advise against it). Profanity could be checked against a map or you could bounce each word to a redis db... Hope that helps a little.
I'm not saying the lib has no value, I'm just saying it tickles my security paranoia gland. I'd sooner have the remote commands specified in the service itself and have them triggered remotely rather than setting up a full remote shell - so a very explicit whitelist, I guess. The whole thing sounds like a way to bypass security team policy. This post might just be paranoid rambling, especially since you provide an example that checks the cmd.Path to whitelist a command, but anything with the words "remote" and "shell" in the same sentence will generate such consideration.
http://play.golang.org/p/huCiPGRy0G
Using Anonymous function is certainly a good point, but it would confuse newbie visiting/reading post. And calling Add(1) inside concurrent function would be of no use, as we want our main function to wait for all goroutine sprouted from it to close
Instead of `return func() { x.Unlock() }`, you can use [method values](http://golang.org/ref/spec#Method_values) and write `return x.Unlock`. For [example](http://play.golang.org/p/ViQggpKsJH).
I dont think that's really the "spirit" of DRY. DRY means dont have repeated logic as in you shouldn't repeat "Cats have 9 lives". No (non-trivial) program in the world has one place that says "if there is an error, do this". Because "this" varies. In respect to OP. Validation failures are not "errors" per se. You wouldn't see if err !=nil You would see if myStruct.paramX != "foobar" Which is what.. reality is! I dont see how this is especially different from any other language. You have to define *somewhere* what is valid, and what isn't
Agree - start by validating them, and then observe what you do a lot and refactor it. Go is so easy to refactor, that it is perfectly fine to write stuff first and refactor when you know what you need. For instance, in a rather big web-app we started with huge functions for each API call, basically validating every parameter. After some time we generalized a lot of stuff, so: * Models can have a Validator interface, that can return one or more errors. Run before saving to DB. * We use other interfaces to check common properties (does the object have custom properties, tags, etc) * All ID types - links to other objects, which have a common interface are automatically validated. * All absolute times are converted to UTC. * Updates/patches are sent through a common validator, which can also filter out no-ops (input=existing data), and send notifications. * Data models are separated into internal/user creatable/user updatable structs, so we safely can de-serialize json, and not worry about users overwriting internal parts of documents. Embedding is awesome for this! Example: https://gist.github.com/klauspost/da89bbcba090dcd5c0f4 This may seem like a lot, but each feature was only implemented after we realized that we were doing too much of the same thing, or that we were risking missing important checks. But the important part is NOT to plan everything out beforehand, but do it incrementally. That way you can evaluate on the fly if your refactoring brings better readability/security.
fix'd formatting https://play.golang.org/p/y20a0iIPBK
Perfect :)
Ever used that thing? Ugh ...
Make sure to [gofmt your code](https://blog.golang.org/go-fmt-your-code). Go comes with lots of great tools to make development easier and more consistent (e.g. Gocode, Godef, Golint, Oracle, Goimports, Gotags, Errcheck). Most code editors have plugins that enable the use of these tools. Make sure you're using one. :)
Thank you, I'm using atom's go-plus plugin. Just enabled the format feature :)
&gt; There are several places in the standard library where they’ve copied and pasted a small routine instead of importing the package that contained it. Every such case I'm aware of is simply to avoid extraneous package interdependencies. I.e. they don't want everything that imports `fmt` to implicitly end up indirectly importing/depending on half the standard packages.
The `forever` channel in `startProcessingServer()` isn't necessary. If you want to block forever, you can use an empty `select` statement. For example: +/u/CompileBot go --include-errors package main func main() { select {} } It might be better to try to structure the code so that you don't have to block forever, though. Can you move the `for` loop up out of its separate goroutine, or would that break something somewhere else? Are you worried that the `msgs` channel will get closed and end the program?
1. Why no unit tests? They are great for many great reasons, and go makes it easy- testing is built right into the language. See: https://golang.org/doc/code.html#Testing 2. A general stylistic preference I've found useful is this: Return useful `fmt.Errorf`'d errors which include information about what seems to have an issue and any other helpful information. Without this the error logs can be very challenging to correlate back to what went wrong where in the source code. This becomes even more important as a project gets larger and starts to have many modules and more complex and/or subtle interactions.
Best? You mean after .Net, JVM, QT.
Use constants for environments: const ( envDev = iota envProd ) For the style: - Capitalize "DB" (like in `ctx.Context.AuthDb` for example) as you'd do for "JSON" or "ID". - Use simple file names (i think to `jsonEventTrackingValidator.go`), no camel-case and no underscores (except for _test and _platform-specific files, obviously). - Use `New` instead of `NewContext`: a function that returns a new struct closely related to the package should just be named `New`, like in these packages: http://golang.org/search?q=func+New%5C%28 - Add [packages docs](http://blog.golang.org/godoc-documenting-go-code). - For docs and comments, add a space after `//` (and a point at the end of a phrase, especially for docs).
bcrypt is a pleasure to use
Surely it has to do with cache-performance.
Totally agree on the typing point. I come from 10 years of C++ programming, looking to learn server-side development, and dynamic typing is terrifying. Like, does it not just mean errors aren't caught at compile-time? If it's broken i'd like to know. A strong type-system is essential to larger projects. Anyway go is looking really sweet, scala is good to but I just really like go-routines.
Thank you for your answer! Bcrypt doesn't offer the use of a salt, right? I tried to find out as much as possible about securely storing passwords and almost every organization and person recommended PBKDF2. I also used it in earlier (sadly) nodejs projects.
You might be interested scala + akka. It is the actor model for concurrency and is somewhat interesting. I like go, but it is hard to beat Java's ecosystem when it comes to server side development.
I wrote some for the middlewares, looking forward to complete the whole thing! Are there any good resources for mocking? 
The PostgreSQL "text" and "varchar" column types require their data to be valid in their configured character set; encrypted data is by design indistinguishable from a random sequence of bytes, and so is unlikely to be valid in any given character set. Use a column with the [bytea or blob](http://www.postgresql.org/docs/9.4/static/datatype-binary.html) types instead.
You might try picking a project you really care about and ask for a code review on just the one.
Be more specific. We're happy to give advice or critique, but I don't want to spend my time browsing everything in your github and hoping that what I comment on is also relevant to you. Instead, look at your own code, ask yourself questions about it: am I proud of this? Could I do this better? Did I write it in a way that others can understand? When you're not sure about the answer to something, then post the question along with the code here. If that seems like too much work, then I completely understand, but you're asking us to do more so it seems only fair.
Ah, that makes sense. I'll try it immediately and report back. Thank you :) edit: It worked! Thanks again
the go website has all you need. http://golang.org a while ago I was in the same position as you, trust me, you won't regret it :) Go through the tour and read the documents. Just google anything else. https://gobyexample.com is also very helpful. 
Currently there is resource only for a book for a determined beginner (https://www.golang-book.com/). The "absolute beginner" can mean a lot of things. But here are few additional questions to help clarify: * Have you ever written a program? * Have you used command line before? * Are you good at STEM fields? It's not that important to programming -- but it usually gives a good indication of thinking frustration threshold. If you answered "no" to all of these questions -- read ["A model of problem solving here"](https://github.com/egonelbre/spark/blob/master/basics-of-programming.rst#a-model-of-problem-solving) and play http://lightbot.com/hoc2014.html. See how your mood and frustration levels change while playing the game and try to figure out what to do when you get frustrated. This is one of the major reasons people fail to learn programming -- not knowing how to deal with frustration. If you answered "yes" to all/some of them, then you are probably fine learning from golang-book.com
There is http://www.gopherjs.org/ that allows to transpile Go to JS, but it doesn't save you from needing to know JS. You still need to know how to interact with the DOM. For learning JS there is http://eloquentjavascript.net/. For Python there is [LPTHW](http://learnpythonthehardway.org/), which is the best book for beginners I know of. Once you know one language it won't be difficult to move to another language (in the same paradigm).
I ran into this blog post titled [How a complete beginner learned Go as her first backend language in 5 weeks](https://sourcegraph.com/blog/live/gophercon2015/123565059490) a while ago. It's both inspirational and has a great set of resources for getting started (though most already mentioned here).
Right. I deploy quite a bit of Go infrastructure in Docker containers so the ineptness of this was the first thing that stood out to me.
I have personally found that Go's simplicity and readability has dramatically improved my pace of learning and overall understanding of software-engineering concepts, as well as how to apply them in a variety of situations. Go gives you the tools you need to create good software, and nothing more; it's easier to focus on what's important when you don't have distractions like whether to use camelCase or under_scores and tabs or spaces. In addition, the Go community's preference toward using the standard library over frameworks discourages 'magic' and prevents you from creating software without understanding how the underlying code actually works. The only significant problem I encountered using Go as a first language is that a lot of content and documentation frame things in terms of "How x works in Go" rather than "How x works, coincidentally in Go." As a result, I sometimes find myself having to supplement tutorials and guides with complementary explanations for C or python -- conceptual overviews utilizing pseudocode works best, when available.
Go tour is best to start with https://tour.golang.org Then you can check https://github.com/astaxie/build-web-application-with-golang It covers all you need to know while making a web app in Go.
I think i will use my Python lessons with Go on the side with a direction towards building with Go, but understanding the basics with Python. So i can look at lots of tutorials of the basics in Python then do them in Go. I think that's my guide for this.
No, JVM doesn't do cross platform. It doesn't support iOS and Windows Mobile. It also doesn't support Android. The VM on Android devices is not JVM. The Java slogan "Write once, run anywhere" is the biggest lie in programming world. .Net also doesn't do corss platform officially. There are some other 3rd party c# based non-free tools do. QT mobile is still not mature yet. Adobe AIR supports every popular platform: Windows, Mac, Android and iOS.
+1 for the answer given by someone else here. you can use any stable an reliable SMTP server to receive emails and get the "receive" as you write wit a IMAP/POP library of your choice. I use https://github.com/mxk/go-imap for a project to get email from GMail and that works great so far.
Where exactly did OP bash Ruby?
are you from Angers?
No.
Would Python as a first language and Go as the secondary be a good step? Go should complement learning Python? I already have some tutorials done with Python. Edit, spelling.
So actually I would say it's a terrible choice if your goal is to get a good foundation in programming. I've seen a lot of research into teaching kids to code and have a few friends who are teachers. Aside: This is specific to learning programming not the concepts of logic which is better taught with something like Scratch Basically all the latest research is that high level languages are terrible way to learn (esp for younger learners) and people are much better off starting with basic, assembly or some other more low-level language. Working with say 68000 ASM on an emulator or with real hardware say it teaches the core programming skills, and that there is no real difference between data &amp; code and how registers and stacks work. The abstractions of object oriented programming, garbage collectors and other productivity helpers block learning core concepts. Once you have a good grounding in those systems then the more abstract stuff comes much easier. Best of luck.
Year ago while looking through SMTP server implementation the best I found was https://github.com/mhale/smtpd. Of course depending on what you need it to do, you may need to add protection against DoS, spam, FROM/REPLY-TO spoofing... and more... also fault tolerance by deploying to multiple servers.
Other have recommended Python as a place to start. While that is a good choice, the syntax is so different from curly brace languages that I would not recommend it if your plan is to move to Go. I would actually recommend Javascript as a language to start out with, especially if you want to make web apps fast - you only need to learn one language for server and client side and it has certain semantic similarities to Go that will make it easier to transition to Go in a while if you want to.
The problem with learning low-level stuff (even C) is that it takes a lot of work (and a long time) to realize any results (the reward). That can put off a lot of new programmers because they build abstract toy programs that aren't useful or relevant to their interests. I don't think there is any one way to teach programming languages because different approaches suit different people. 
Your first language should be C or Python. Python only cause it's easier to get help than Lisp. C cause you learn how computers work. However, my inclination is to say Go is close enough to C and comes with benefits.
Do you have any references to that research?
At work, I dropped a quick IM to my teacher friend. She will have the best links for this :)
Thank you! I would love to read about it.
Sadly can't find another way around it. I am hoping to look into a way to precompile or something
Linux is not a popular platform. Adobe AIR ever supported Linux, but dropped it now. "Oracle Java runs anywhere where the JVM is" &lt;=&gt; "Java is dead in mobile age." 
thank you very much. time to fix it up.
Sure, same argument could be extended to learning Assembly...not that important when just starting out. Valid point. 
https://www.reddit.com/r/golang/comments/3elvhs/map_reduce_and_filter_in_go/ctg9o9m
Check out https://clipperhouse.github.io/gen/ for a code generation approach. Your current approach is clearly tidier and IMO perfectly suitable when out-and-out speed isn't required or eg. the mapped function in your MapParallel is IO-bound. 
Go would make an excellent first language. It is very simple so learning will be fast. The only downside I can think of is that because it's so simple moving to language #2 down the road may be a little harder since many language features will be alien. I say go for it and good luck!
I learned programming with QBasic on a monochrome 286 Epson and I liked it! Kids these days don't know how good they have it.
 if err := req.ParseForm(); err != nil { log.Printf("Error parsing form: %s", err) return } l := req.Form.Get("limit") limit, err := strconv.Atoi(l) Why call `req.ParseForm()`? Why not just limit, err := strconv.Atoi(req.URL.Query.Get("limit")) ?
I also think it would be great. I think over the last couple of days i have looked at lots of languages. Am i right in thinking that Dart, Swift and Go all look very similar? I get they're all different but they do look very close to me. The more i read, Go seems perfect for learning good strong CS standards instead of learning one framework. 
Definitely the way to go for maximum cuteness in this example. (It's possible this code dates from before method values were introduced, in Go 1.1.)
&gt; Yes, C doesn't have to be your first language I meant that although I really like C, I would recommend against learning C as your first language. &gt; you'd accomplish none of the things in your second paragraph with Basic as a first language I would never recommend anyone to learn Basic as the first language ;) It was just what provided the initial sparkle for me (well actually, DOS batch files became too limited, so I started looking into Basic). It showed me what was possible. &gt; And all the reasons you give for Go are what I said, it's C with benefits. I'd turn it the other way around: C without the C-specific complications you will encounter sooner than later. Unless you already know a lot about how memory is actually managed, you'll be off fighting the language and system to start with. Some people will be intrigued by why something doesn't work, but those are the exception. Most people are encouraged by being amazed by something relatively useful they were able to pull off. They become frustrated by any roadblocks that for them are inexplicable, and eventually give up. And C throws up many roadblocks like that. That said, imho you should always be ready to learn new languages imho, and C (and maybe ASM) is one every serious programmer should learn at a certain point, just because you are confronted with things most languages/runtimes hide for you, which gives you an idea how computers work.
That would actually be a better language than C to start with, it doesn't pretend to make things simple and then inexplicably doesn't do what people would expect. You avoid the "why doesn't it work when I return an array?" or "I return a (stack allocated) string from function X but it is corrupted somehow" questions. I did try to learn someone C as a first language, I quickly switched to something else due to stuff like this. And my (m86k) ASM is pretty rusty these days - only really needed it to write optimized crc32 and crc16 implementations. These days everything embedded is a 200Mhz ARM with loads of memory, no need anymore for such tinkering. It's still nice to know what really happens, and interesting to see what compilers these days output, but for writing stuff in ASM, I'll skip :)
website written in Go So it's double-semi related :D
Yeah I was thinking of using the murmur hash constant... I will give it a try
The trailing-comma-in-composite-literal thing is a consequence of the [semicolon-insertion](http://golang.org/ref/spec#Semicolons) rule, which is intentionally left simple for ease of understanding. You probably would have to considerably complicate it to make this possible. In particular, it's not trivial :)
Note, that the comma-insertion happens on a purely lexical level and needs to be able to work without any lookahead or -behind of more than one symbol. I.e. you can look at the last token in a line and nothing else.
If this seems familiar it's because it was almost a year ago.
Found my first crasher 3m20s in. Had to abort though, as I didn't bring my power cord and fuzzing uses all the cores. #PlugItIn
when reading code like this foo, bar := baz() var fizz MyType foo.x, fizz = quux() it clearly tells me foo and bar are being declared at that line foo.x and fizz was declared somewhere else foo, bar := baz() foo.x, fizz := quux() this code doesn't when it comes to foo.x and fizz... I don't know that foo.x was declared elsewhere and that's more time I have to spend reading code just for one less line... thing I love about Go is the clarity... there are no "maybe" or "could be this or that" or union ( from C ) helps alot... especially when reading other code and not related but I say this alot regardless.... ALWAYS check for errors...
I learned on C64 BASIC - I suppose Apple][ LOGO would technically count as my exposure to the craft before that, but it's not much of a "language". These days, you have the revolutionary concept of having separate pieces of software for editing *and* running the program; some environments have more than one option of each. Sheer luxury!
I agree. I would argue that Go has subsumed most of the area that C covers when it comes to fundamentals of programming on bare metal. Things like pointers, memory locations, stack frames, integer widths, etc are all doable in Go. From there, all the basic data structures and algorithms are easily implemented with same-ish looking code at that. Go does lack some details that C has, but I don't think that's a reason to not consider it for first-timers. First, is the utter hackery that C gives you with pointers: that everything is easily turned into an address with a little bit of math and casting. Stack allocated variables are kind of unimportant in Go - it's more about scope than stack vs heap thanks to the GC. Finally, the Go docs are kind of silent on the distinction as to what is a value type vs a 'reference type' - C makes that easy as everything's a value until you point to it. Overall, it's not wildly different, but some strict instruction on when and when not to use '&amp;' would be necessary. Then there's the heap. I would argue that discrete heap management (malloc/free) is a form of resource management that sits between the programmer and the unadulterated process .data/.text memory space. It's not distinct to C or C++, but it's also not the default resource manager for all systems when it comes to RAM. To me, a GC (like the one in Go) is no different here; it's just another resource manager with a harder-to-screw-up API. In the end one really needs to drop to ASM or embedded C to get a feel for managing your own RAM byte-by-byte as one might do in a toy program on a whiteboard. The moment you call (malloc) you have already diverged from classic CS, so targeting a GC based language right off isn't any worse.
Honestly, this is more of a narrative on the not-so-great state of error handling in golang than anything.
^(I was going to write out a huge wall of text, but, due to technical issues, I'm writing this several hours after I first saw it, and a bunch of people have said pretty much what I wanted to say. So I'll just comment on two things.) &gt; Go elides some traditional constructs, for example for handles for, foreach, and while loops, so why make and new still exist side-by-side, even when Rob Pike proposed merging them, leaves me scratching my head. &amp;Foo{} is equivalent to new(Foo), so if there's no need for while then there's no need for new. There are two nitpicks here. One is that `new()` and `make()` are seperate, and one is that `&amp;Struct{}` and `new(Struct)` are the same. I'm not entirely sure why `new()` and `make()` are seperate. I would think that `make(*Struct)` would be a perfectly clear, maybe even clearer, syntax, but at this point there's not much that can be done anyways; removing a builtin function would shred the Go 1 backwards-compatibility guaruntee. In terms of `&amp;Struct{}` and `new(Struct)` being the same, you're right, but you're also wrong. The multiple syntaxs exist for a reason, but they just happen to overlap in this one case. If you want a pointer to a new struct that has its fields set to specific values, you have to use `&amp;Struct{}`. If, on the other hand, you want a pointer to a non-struct value, like a string, for example, you have to use `new(string)`. I think that's a little cleaner than something like `&amp;string`.
Hugged to death?
What surprised me most about this article, is that the author called out a lack of tooling for go. They seem to define "tooling" as a "killer IDE" (because them not getting delve to run is clearly not a go-issue) which I find just weird. When I think of a "killer IDE" I think of Java, a language so needlessly verbose, that it is impossible to write without something like eclipse around. On the other hand, go really *shines* when it comes to tooling: godoc (plus godoc.org) ist just documentation done right (I know of *no* other language that has central documentation, which indexes and correctly cross-references *all* public repositories that have ever been looked up and making it trivial to add your own package to it). gofmt is such a goodness, that I am refusing to write any language that doesn't have a canonical and widely used auto-formatter. Profiling, Testing and Benchmarking is a breeze. The oracle ('nuff said). It just seems mad to me, that you would complain about go tooling, just because it doesn't need an IDE enough that there is a "killer IDE". Plus, I haven't tried any of them yet (happy without) but there *are* IDEs with good go support…
Ok then
Don't hesitate to do so again. ^^Just ^^my ^^2 ^^cents.
Open source? Ive been trying to do the same for iOS but ive been running into issues with the Go GC
Marshalling data between the two lands is expensive, and art cannot reason and compile code paths that use it.
Commenting to save this for later
&gt; Is there a way to iterate through a struct's fields? Use `reflect` with `NumField` and `Field`. You could use tags to annotate validation ala json. I prefer a more straightforward style. Create a few helper functions for the various types of fields you want: obj.PhoneNumber, err = GetPhoneNumber(req, "field-name") if err == nil { obj.Email, err = GetEmail(req, "field-name") } if err == nil { obj.Country, err = GetCountry(req, "field-name") } // and so on If that's too repetitive a map would be more appropriate than a struct. Go's database libraries rarely require structs to work with so you could actually make the whole process very dynamic. But I like the slightly more verbose nature of the struct. The type safety catches a lot of mistakes. It's a little extra typing, but we're only talking an extra 20-30 minutes. And once written adding additional fields is trivial.
i'd really like to see how your source is organized.
How do you reconcile that with defer? Are you using defer func(){ if err := f.Close(); err != nil { log.Println(err) } }() Everytime you want to defer a close? I would *like* to check errors on defer (just in case), but as you said, most of the time there is nothing usefull to do anyway and a construct like this massively turns me off… :-/
Java side https://github.com/sajal/digdroid Go lib https://github.com/turbobytes/pulse/blob/master/digdroid/digdroid.go Im actually re-using code written for TurboBytes Pulse ( https://pulse.turbobytes.com/ ) https://github.com/sajal/digdroid/blob/master/app/src/main/java/com/turbobytes/dig/MainActivity.java#L137 &lt;-- this is where java is calling a Go method. And yes I know im doing networking on main java thread which is a taboo. Just that im lazy to learn about AsyncActivity at the moment
Will totally help those people that want a little crawler or a small app for their personal use. Hey, let's start with blinking LEDs, I'm sure that will help me with this web crawler I need for my work.
I really enjoyed this read =) I also tried Fucking Scala, and it was not amusing.
&gt; Next time someone with style and clout sits down to write a language, how do we make sure that they're aware of the last forty years of language theory? I've seen this kind of rant many many times and it starts to sound like "next time someone sits down to research chemistry, how do we make sure that they're aware of the last forty years of phlogiston theory?". Maybe the problem is that the whole area of research has been misguided and focused on the wrong problem? When you're developing a *tool* for *programmers* it helps actually being a programmer in reality and not building a theoretical model of what programming should be and solving problems for that theoretical model. "Modern" languages have a stink of "assume a ~~spherical cow of uniform density in vacuum~~ static team of equally skilled developers with perfect communication and a finalized and unchanging project design with all corner cases considered". 
It would be nice if you could write a post (here or on your blog) detailing the process of writing this app. I'd love to read more about it.
I was one of those full-blown graphical IDE guys that teased his Vim buddies. I decided to give it a try recently, and in large part, because of vim-go, I'm a convert. Really great work!
very nice. I was just profiling an app where gzip and json consume way more cpu than I expected. This should help a bit.
[See mine and other comments here](https://www.reddit.com/r/golang/comments/3bioq2/oauth2_golang_tutorial/) *Edit: The osin package is for building your own oauth2 server. You are probably looking for the osincli package. https://github.com/RangelReale/osincli
In that case I think I may need both. I really just want to make sure that a user can log in to my service using credentials in my system, which is pretty standard. Usually it would be done via sessions or whatever through browsers, but in order to make it more widely usable, I would like to do that using OAuth. Sorry about not having clarified that enough
Ok. Keep in mind I'm not really sure if my understanding is correct, but assuming that I host the Authorizing server myself instead of using an external service I must be done some kind of authentication using OAuth?
The godoc talks about simple importing but that didn't seem to work for me.. I ended up just touching the build.gradle file in order to compile and build the aar file for consumption.. is that what you did? 
Email is an administrative nightmare at the best of times. Personally I rely on external services for mail management, which has saved me a lot of headaches. Currently I'm using [Mandrill](http://mandrill.com/). /u/i_regret_most_of_it has the best suggestion if you're set on managing it all yourself. Postfix/Dovecot with [go-imap](https://github.com/mxk/go-imap) is a great option. 
Im not entirely sure. I will go thru it again and update. I think all i did was create new module using the instruction in godocs.
Thanks for this!
http://imgur.com/a/dEewm Following exactly what godoc says... I did not need to do anything to gradle.
Those [GC pause numbers](https://www.youtube.com/watch?v=aiv1JOfMjm0#t=18m15s) are fantastic.
[So, don't do that.](https://pbs.twimg.com/tweet_video/CJJMx4UUcAAnOdR.mp4)
Thanks
You're compiling your templates over and over - compile them just once and reuse everywhere else.
I can recommend Dimitry's talk (number 7 in the playlist), a very interesting look into the race detector and go-fuzz. Seems like a very clever guy!
Thank you so much for the feedback! I guess I separate out examples and tests because in larger projects, tests end up being many hundreds of lines long, but in a project this small, you're right that it looks a bit contrived. As far as separate packages or the same package, do you have any articles that convinced you one way or the other? I've done it both ways and it seems like only being exposed to the external API is more congruous with what clients use so there's some meta element of "dog-fooding". **Edit:** Based on the discussion here, I changed the *tests* to be inside the same package, but I kept the *examples* in the `prime_test` package, because when a client uses a package, they must `import` it, so an example that is being published in documentation ought to reflect that sort of usage. I really appreciate the guidance. Thank you!
In support of your point, whether you create a separate example file or embed it in a test file is not a stylistic choice. One produces an example that can be a full executable, one produces an example that is a single function. You need to choose the correct one, as the wrong one either has extraneous details, or is missing critical details, both bad characteristics for examples. Usually you want the function, of course, but when you need the separate file you _need_ it.
I see your point. But the standard library also occasionally uses a separate test package. For example, check out the strings_test package: https://golang.org/src/strings/strings_test.go I am not sure why they chose to do this with the strings package. Perhaps it was a special case? The other reason is as [jerf says in a sibling comment](https://www.reddit.com/r/golang/comments/3ewsay/the_anatomy_of_a_go_project/ctjmch0), I liked the idea that the example file was standalone. But perhaps that's unrelated: I could image a test file that is using the main package and an example file that is using a different package. I don't want to be dogmatic, and especially since my tutorial is aimed at beginners, if there's a broad consensus, I'll update it. Thanks for your input, I appreciate it.
While I agree, note that you can test internal functions from a separate test package too. For example, you can create a file foo_test.go with // foo_test.go package foo var ExportedInternalFunc = internalFunc and then do // bar_test.go package foo_test import "testing" import "foo" TestInternalFunc(t *testing.T) { foo.ExportedInternalFunc() } 
I want to add that ejayben's solution is probably current accepted best practice. Generally I'm not a big fan of packages with names like "structs"; I'd really rather see "common" or something else that indicates its function rather than its implementation. But, no sarcasm &amp; fully seriously, your mileage may vary. Part of the reason for that is that over time you're likely to find more code wandering in to that package, and the sort of code that wanders in and belongs there may begin to suggest a better name. It is certainly common in this sort of situation to still end up with vast swathes of functionality in the "core" package and for the client and the server to just end up thin drivers around those things.
Thanks!
&gt; Comparing a near-max value float to 13.0 as a float evaluates true No, where did you get that idea? The only value a float32 or float64 can hold and compare equal to 13.0 is 13.0.
I can't speak for best practices, but if you imagine that your packages have to be arranged in a hierarchy such that no cyclic imports exist, then it makes sense that there should exist a package which depends on no other packages in your project. In some projects I've named this package `util` and its where I put things like common struct definitions, common error checking, net/http wrappers... basically everything which could be categorized under miscellaneous. Other good names might be `common` or `types` if it only contains structs and interface definitions. Your goal is always to produce readable code. So when you import and use the stuff in this package, which is more clear? `structs.Data`, `util.Data`, or `types.Data`? 
Both tools are great and you should run them both against your code. Fuzzing is easy to get started with, it's all in the readme. 
So, are vinyl gophers a GopherCon thing now, or is there still some way to purchase them independently?
Thank you very much. The ease of generating the go aar is amazing, compared to the complexity I've come to expect from anything android related. I work in a company that has a couple of Android products, but I mostly write server side stuff in Go and Python, although I've written my fair share of Android code. The idea of being able to just offload parts of the logic to Go is very appealing, but so far when we've discussed this internally, we're mostly deterred by the overhead it will add to the APK download size. I'm seeing your .aar lib weighs 2.3MB, this is compressed and I'm sure most of it gets added as-is to the APK. This is a big price to pay if your APK is already big. It won't matter much to games weighing at 50-100MB, and it's a reasonable price to pay if you have a small app weighing 3-4MB. But we've reduced our APK size from 18 to 8MB with tons of work in the past months, and just adding 2.3MB is pretty much a showstopper. 
yeah.. the .aar size gets added as it is more or less... My final apk is 3.7MB But in my example the package i built includes other packages which includes more packages(which are not needed in the app). I am guessing a simpler package would generate a smaller .aar
A Hello World Go1.5 app (not an aar, just a simple binary) weighs 2.3MB, and 800k compressed (aar is basically a zip file). I'm guessing a simpler android aar won't weigh much less than 2.3MB.
Doubt it, but the lightning round talks will be up at some point. 
Thanks for the link! Now I have videos to see this summer ^^
I can only find the plushies there, not figures.
Why is a Mac OS still needed to build iOS version? This makes the golang ios project be not very useful. Aodbe AIR doesn't need Mac OS to build iOS versions.
That's fair then - apologies for inferring and implying what you are clearly not saying. :)
&gt; How meaningfull is "semantic versioning" really, if almost every change to an API needs to increment the major version? The importance is not necessarily about making a promise as to the stability of your API, but rather, having some *semantic* marker to distinguish between different API versions. This distinction - what a version number means to the software vs the human maintaining it - is important since it's easy to conflate the two. In practice, the semantic content of a version number merely suggests the magnitude of the change, not how disruptive it is to your program. Ultimately any change to a library, no matter how small, can break software that uses it. Even changing an API's implementation to fix a bug, can break a program that (unknowingly) relies on that bug. This means that we should treat every version, even the commits between releases, to be distinct versions of any given project. Assuming otherwise invites disaster. &gt; Is it okay to restrict compatibility to packages on godoc.org and automatically check those when breaking the API? There's no reason, other than the raw CPU power expended, to not have automated checking at the contract level - that is, use continuous integration to make sure that things still compile okay. Even better, use automated testing. But we're going to need a proper package management solution that declares dependency graphs, before you can just sweep a bunch of Git repos and make blanket assumptions about compatibility at the semver level.
It just depends on what "backwards compatible" means. I think it extends passed just API changes as you stated. Here's an example that I ran in to personally: https://github.com/golang/go/issues/10918 The API did not change, but a change to when something is returned significantly impacted my application (at least it would have if the response was not made available within the error that was returned). I don't have any gripe with the compatibility, though. Didn't I see a project that took a sampling of github Go projects and plugged different versions in to them to check for breakages? Maybe something like this could be thrown in to the review process of a release for consideration?
The numbers are where they should be in the magical land where GCs don't stop the world for eons.
If you Google, there is a sort of semantic versioning standard. It's not IETF or anything, but it exists, and I'm pretty sure it is what the article is taking about. By that standard, yes, almost every change in theory indeed ought to be a major version. Personally, I'd unapologetically make it so additions are "free". In theory, that can break everything... in reality, the odds are low. Contrast this with a real breaking change, with 100% probability. It's fair to treat them differently.
It might be meaningful to distinguish the cases of might break and definitively 100% guaranteed will break downstream build.
The GopherCon team had them manufactured for the event.
This package is probably not a great idea, but two suggestions: 1. Use a type switch instead of reflect (https://play.golang.org/p/X8LMv6fWrM) 2. Don't convert integers to floats This will require a ton more code but at least it will be closer to correct.
Thanks for your nice feedbacks! I have some questions. 1. Use a type switch instead of reflect --&gt; Is reflect more expensive than type switch? 2. Don't convert integers to floats --&gt; Could you tell me more details? Is it slow?
After a long day of watching most of the GopherCon 2015 videos I found this one to be the most entertaining.
Please also fuzz your code to ensure it handles malformed inputs gracefully as the original Go code does. 
There is certainly more reasons, but it does not work with integer superior to 2^52. Try with: x := int64(2&lt;&lt;52+1) y := int64(2&lt;&lt;52) fmt.Println(Max(x,y))
Yeah, I agree.
Is there a difference between the `vendor` and `internal` folders? Initially, I thought Brad said we were going to [put dependencies in `internal`](https://groups.google.com/forum/#!topic/golang-dev/nMWoEAG55v8%5B1-25%5D). But, now I'm reading about [putting stuff in `vendor`](https://medium.com/@freeformz/go-1-5-s-vendor-experiment-fd3e830f52c3). Also, what ever happened to the configuration file format? Also, also, are we just supposed to manually copy packages we want to vendor into the `internal` (or `vendor`) folder? Or will `go get` receive a vendoring flag? 
After some experimenting, I've realized that `internal` and `vendor` serve different purposes. `internal` is about limiting your packages' scope and `vendor` is about vendoring third party code.
Thanks for your detailed feedback! :) I've found out that easymath needs a lot of changes. I'll rewrite the package entirely.
It's terrible from a professional kind of view but it's also terribly funny.
And you wouldn't happen to know about anyone planning to sell the ordinary non-cowboy vinyl gophers in the near future, would you?
It seems like a useful challenge. I have a few questions. &gt; the goal of this challenge is to write a tool that will find unnecessarily exported identifiers How do we know that the identifiers are unnecessarily exported? What's the criteria for that? Is it user input? In what form? &gt; in a package and help unexport them I assume this means renaming symbols to lowercase form? Or is something else here in question? 
$0.02: One man's un-needed export is another man's public API. I think it's safe to say that if a developer were to use such a tool on an existing codebase, it would un-export (or provide lint warnings to that effect) anything that wasn't explicitly used outside of it's module of origin. It's not possible to solve the problem for a module in isolation, unless you dig *deep* into github and find every last place a library is used. To be really useful, I would wager it would have to ignore everything under `./vendor` and/or possibly a configurable subset of modules or files. &gt; I assume this means renaming symbols to lowercase form? That's probably it. This developer is not aware of any other mechanism for exporting symbols in Go.
This was the original recommendation. Due to community requests, a new proposal was accepted and we now have the 1.5 vendor experiment. There is still a configuration file format: https://github.com/kardianos/vendor-spec . It isn't integrated with "go get" yet. If this works in 1.5 it will probably be added for 1.6. You are correct in your own rely, they serve different purposes.
&gt; **Bad package names** &gt; &gt; Packages named **util, common, or misc** provide clients with no sense of what the package contains. This makes it harder for clients to use the package and makes it harder for maintainers to keep the package focused. https://blog.golang.org/package-names
It's less self indulgent than the usual fare, thankfully.
Pretty clever, and really shows the power of interfaces in Go. To expand on what the author says in his post, this is not limited to a certain protocol. Rather, this looks to be available to anything that implements the [Listener](http://golang.org/pkg/net/#Listener) interface.
The "runtime" changes don't really look like a changelog from a beta 3.
Right theres Cortex in python as well. I just wanted to try my hand at it in golang. Theres still a LOT of work to be done.
Fun. Reminded me of Alice: https://github.com/justinas/alice
Neat! But what's a GPX file?
There does seem to be a lot of moving parts which can be overwhelming and confusing. The problem I found was that many solutions only solved specific pieces and rarely the entire thing end-to-end. Some focus on providing OAuth server capabilities (like osin does) but others focus on OAuth client sign-in (e.g. goth or x/oauth2) My take on it is that you typically need parts of both. You need to be an oauth server to your own clients (browser / users) and also an oauth client to the providers that your users want to use to sign-in with (facebook, google, twitter et al). That really is the confusing part but it gets easier once you figure out the 'app glue' where those parts meet. You use the 3rd party issued tokens to identify your users (using the provider + subject) and then issue your own token under your control which you can add your own information to ( based on your user within your system - the most common need being roles. If you use JWT tokens then it's fairly trivial to decode them in the API server and check for roles to authorize each request as required using middleware - no user or database lookups required (thus allowing the API vs Auth/user systems to be separated). The client (browser) can store the tokens (in localstorage or a cookie) and there are a few libs for frameworks like angular to automatically add the authentication headers and handle the refresh mechanism (which osin is great for). The beauty of JWT is that it can also contain extra info useful for display on the client - the same roles used for cosmetic security (hiding or showing options), username and avatar for sign-in status display and so on. I've just implemented such a system where I use osin for issuing tokens plus handling the token refresh mechanism (where user roles are re-checked) but not the full range of oauth grant types - I don't expect people to use my system's auth to sign in elsewhere. It's worked out really well and definitely something I'll re-use for future projects.
osin is also useful in the scenario where you have existing users that need to be able to sign in directly with a username &amp; password. In this case you just handle the 'password' grant type for those and after that you have the same JWT token mechanism as before. This way your app can support either sign-in mechanism. You can associate multiple credentials with a user to allow them to add additional 3rd party sign-ins to their account which makes for a great gradual-migration.
No, sorry.
Your communication isn't just abstract data. It represents something, like bitcoins. Maybe call it package bitcoin. (Or, if I'm wrong, call it _data_.)
Neat, reminds me a lot of [go-flags](https://github.com/jessevdk/go-flags). Great use of struct tags.
Actually, they're all terrible as they don't say anything on what the data is about. If, say, your types represent stuff on reddit, you might call the package reddit and then have types like reddit.User, reddit.Comment, and so on.
&gt; How do we know that the identifiers are unnecessarily exported? What's the criteria for that? Is it user input? In what form? From the website : &gt; Solutions should: [...] Allow the user to decide which identifiers should be unexported. There may be good reasons to keep an identified exported even if it is not used by any packages. One simple way to do this is to have unexport generate a series of gorename commands. The user could then decide which renamings to apply. It is up to you to design the interface as you please.
Quibble with the wording of your readme: "If you set the default tag for something, this value will be used in the case of absence of it in the environment. If you don't do that, the zero-value of the type will be used: (empty), false and 0 for strings, bools and int's, respectively." This makes it sound like if you don't set the "default" struct tag, then the package will write the zero value to the field... which would overwrite any existing value in the struct. Thankfully, the code doesn't seem to do that, but I think the wording could be clarified. You could just say "if the default tag does not exist, the value in the field will not be changed" or something like that.
That's beside the point. I assume `data` is a stand-in example name for a more specific struct name he didn't want to reveal. 
I really don't like the use of struct tags as an opaque backdoor for declarative programming. Consider that the compiler will tell you nothing of whether the keys in your tags are being properly discerned by the library nor if their values are even valid for their intended use. Though convenient at times, this is the world I left behind.
I tried to fix that. English is not my native language... please let me know if it still confusing...
Couldn't see from a quick glance but why is sudo needed to execute? Something to do with the way the net package works?
Jesus Christ, how many middleware packages could we possibly need? Why is everyone so jazzed about middleware? You know there are things you can make in Go besides middleware libraries, right?
Another library that's very much worth checking out is [viper](https://github.com/spf13/viper).
This isn't expected to offer clean shutdown out of itself, is it?
https://godoc.org/golang.org/x/exp has packages inotify and winfsnotify in it. Does that help you out?
Yes, I have a working example for that. Also it can do h2c, h2 on the same port for HTTP2. I'm waiting on https://github.com/bradfitz/http2/issues/69
Cool, thanks for the info.
Just came to my mind -- why make `CMux` an interface?
I'd love to look around and see if there's anything I can help with!
Well, that's pretty much like any other library, you'll have to wait for the other goroutines to exit if you want a clean shutdown. It's outside cmux scope, really. Also, you can "go mux.Server()" and instead block on say http.Serve to run some code right after http.Serve exits.
I thinked to convert to geojson but for a side project I need a lightweight JSON, so it's "in-house". If you need a standard format I can suggest you to try ogr2ogr p.s. I know.., I work with GIS and mapping tools too :D
I read the README and was wondering if struct embedding would be easier to solve the problem you described. And also, to ignore the password while encoding JSON, you can use `json:"-"` tag. I made a sample program with a simpler solution (possibly) at http://play.golang.org/p/w19dIcGNUc. Good job making the library, but I think in the example you gave, struct embedding is better. I think your library would be useful if AccountResource didn't contain some field of Account. **Edit:** I think, even if AccountResource didn't contain some field in json, you can just add json:"-" for that particular field in Account.
Added an example for this: http://godoc.org/github.com/soheilhy/cmux#example-package--BothHTTPAndHTTPS
yep the json:"-" will work for some case. This library will bring you more, context in methods, additional methods without polluting your models or writing more codes. In a big application it's important :)
"Usually" is the worst. "Usually" is what leads to assumptions and grave bugs. Either make `string` appear as an immutable slice of *runes* regardless of its internal representation (maybe even going as far as Perl 6's Normal Form Grapheme to make true characterwise work easy), and relegate all non-Unicode work to `[]byte`, or else make it abundantly clear that UTF-8 isn't *actually* special. But anyway, it's a moot point, it's obviously years too late to be having this argument :)
I know OP tried to say this in the title, but here it is from the readme, &gt; There is a "stock" Github integration in the Slack defaults that does the same thing. So why would anyone use catbot? &gt; What bothered us about the default integration is that it required read/write authorization to ALL the user's repositories. 
People were easily swayed by the Transformers movies. Now everything's just prime. 
Yeah, that would be nice... An approach for now is write tests for this.. but I honestly don't do that...
Not complaining, just asking for clarifications. :)
Given how interfaces work in Go I'd expect the decision to use an interface or the concrete type to be left to the user. At least that's what I've heard many people recommend.
I think the main difference between the compiled languages is whether the language's integer type defaults to 32 or 64-bit. 64-bit division was still about 3-4x slower last I heard. Edit: Running the Go benchmark, I get 2.672s for the default int, and 1.088s when I change it to int32.
&gt;The go command now provides experimental support for "vendoring" external dependencies. I remember reading a while back that they were planning this for 1.5. Nice to see it made it into the release.
Most of the changes, like the GC improvements and moving the runtime to Go, are great. I wonder, when did the general consensus on GOMAXPROCS change: when I once suggested a golang-nuts user to use `runtime.GOMAXPROCS(runtime.NumCPU())`, I got people telling me it was a terrible idea. Despite all the cool stuff, I'm kind of worried about Go becoming some kind of 21st century PHP in some ways: &gt; Option sets options for the template. Options are described by strings, either a simple string or "key=value". There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics. (http://tip.golang.org/pkg/text/template/#Template.Option) Is this really the best API possible in Go? As this is not going to get expanded by third parties, maybe we don't need a whole mini-language similar to struct tags? Surely we could've gone a safer route by using bitflags or numeric constants or [functional options](http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis) even?
Wouldn't it be easier (and possibly faster) to do this? https://play.golang.org/p/ZSCnYRMK9P
How do I update to this (windows) from 1.5 beta without breaking everything?
Sorry, I don't get your question. How exactly would a user decide on the structure of the imported type like CMux?
Yes, but: &gt; Builds in Go 1.5 will be slower by a factor of about two. The automatic translation of the compiler and linker from C to Go resulted in unidiomatic Go code that performs poorly compared to well-written Go. So while no (or just a few) new bugs were introduced, the Go code could be much improved by hand to speed things up. That will take time, and with the compiler written in Go, it will be easier to add optimizations.
Presumably, in a few years, you won't even recognize the original code or its former performance.
add name attribute inside input tag &lt;input id="foo" value="bar" name="name" /&gt; and use [FormValue] (http://golang.org/pkg/net/http/#Request.FormValue) function to get value name := r.FormValue("name")
r.FormValue should work for most forms, however if things get more tricky, use `x/net/html` http://godoc.org/golang.org/x/net/html Here's an example form, which has a value that I want: ``` &lt;form method="post" target="_self"&gt; &lt;input name="authenticity_token" type="hidden" value="1LsJBwjnPEBNnJyq5tWjUtNRBscHijWMkFe74YjlgKw=" /&gt; &lt;p&gt; ``` I used net/html here: ``` // setToken parses an http.Response for x-csrf-token func (c *Client) setToken(resp *http.Response) error { // parse html for x-csrf-token var f func(*html.Node) doc, err := html.Parse(resp.Body) if err != nil { return err } f = func(n *html.Node) { if n.Type == html.ElementNode &amp;&amp; n.Data == "meta" { for _, a := range n.Attr { if a.Key == "name" &amp;&amp; a.Val == "csrf-token" { token := n.Attr[0].Val // set Token c.Token = token } } } for c := n.FirstChild; c != nil; c = c.NextSibling { f(c) } } f(doc) return nil } ```
You may use this: https://github.com/yhat/scrape
They said Windows 
Pairing Go cross-compilation with entr, docker-compose, and the Docker scratch image I created a very minimal 5MB and automatically reloading go/docker project. https://bitbucket.org/justbrettjones/dockergo/src/
So, will the Go DNS resolver no longer use libnss? If so, a side effect will be that libnss plugins will no longer affect Go programs, which would be a shame since some of them are very useful (check `ls /usr/lib/libnss_*`). But since this can be toggled with an environment variable I suppose it's OK.
Well, I might not have been as clear as I could. I've heard many people in the community recommend that one should default to returning concrete types and accepting (preferably minimal) interfaces they implement.
Again, you are missing the main point of this library (you should read the introduction to the bottom), not having to write more code by providing also a context for some attributes :)
I'm going to add h2 support soon, and I'm expanding the features as I go along, but the main idea is to easily be able to add new protocols that can be detected by reading a few bytes from the client, and being able to grant you SSH access through even the most annoying firewalls while still serving HTTP/HTTPS.
I actually *just* saw that today, hence me thinking that it might be time (or rather, slightly too late) to post about my own project. It's kind of fun to see two people individually developing similar concepts! Some of the concepts are the same. We use the same way to handle HTTP when using a Go implementation, by having a Listener implemented with a channel. I just focused more in people adding their own ProtocolHandlers, which could use my ChannelListener from serve2/utils if they needed to, and having a simple premade one where you can add a magic, and have it call another (probably local) service, where the cmux project is focusing only on internal Go servers. I don't have h2 support yet, but will soon. I really like the cmux project, though, and might get a bit inspired to expose similar functionality (I've had it implemented for a month, just only use it internally for the HTTP handler). In my world, a ProtocolHandler is a thing that has a Check method, that tells you if a byte slice is a match, and if not, whether the ProtocolHandler wants more data. Upon match, the Handle method is called with a net.Conn, which is actually a utils.ProxyConn, that sneakily injects the original data that was read to detect the protocol. I've been running it for quite some time, so it seems to work nicely. I have a firewall rule redirecting *everything*, officially making my server the most visible and most bruteforced server in the world... Hahah! **EDIT**: I just read a bit more of that source, and concluded that the main difference is in the way we match things. For me, each handler has a Check method that is called with a bigger and bigger byte-slice, whereas cmux uses a nested io.MultiReader/io.TeeReader trick to provide all matchers with an io.Reader that can be given regular protocol handling routines, like http2 frame readers or http1 request parsers. This is very cool, and I'll consider some ideas from it (Maybe supporting both?). I'm not sure how well it handles when a message is short with a handler capable of finalizing the connection with the provided data, but a "prior" Matcher, as cmux calls it, tries to read more data than is available, either to EOF or to timeout. It might have to wait for the timeout. Runtime is also a bit more complicated to estimate for cmux. serve2, on the other hand, always provides data to the one asking for the least data first.
Why should I mind? It's open source.
Sounds like many of the same ideas I had. Do you have "dialing local services" implemented (yet)? That's how I provide SSH support. I'm still really surprised that we have been developing essentially the exact same thing...
How do you detect protocols that are initiated by the server (like SMTP and I think SSH) ? You can't sniff out what the client sends to detect the protocol because the client will be waiting for the server...
What is the benefit of multiplexing over a single port? Is it just exposing fewer ports?
Interesting, I always 'telnet' a SSH server to test if it is online and I always get a banner from the server first without sending anything so I assumed it was server-initiated. Thanks!
Aw, I thought 1.5 was released today...
Feel free, and keep me in the loop! I just took at stab at adding "Hints" support, which informs a ProtocolHandler (both Check and Handle) of previous transports. This means that any TLS-wrapped handler, for example, will be able to get the ServerName, requested protocol, etc., allowing SNI handling, h2 (HTTP2 over TLS), both when detecting the protocol and when handling it later. It's in the "hints" branch of serve2 (the lib itself, https://github.com/joushou/serve2), if you want to have a look. Hit me up if you get anywhere, need help, or want to add to or play with my project. 
If you do it the other way (nc -l 8080 &amp; ssh -p8080 localhost), you'll also see the client sending a "banner". I'll read up on the spec soon to see how much is by spec and how much is just implementation.
will do, thanks!
No explanation?
I was referring to the fact that this was posted without context after two extremely similar projects were posted. 
So Go 1.5 brings a Float type in package "math/big" to complement the Int and Rat types already there. Is there a Complex type coming in Go 1.6 I wonder?
I've read about 10ms GC pause max so mabye. I still avoid every game made with a GC language.
Hacked together a simple web based terminal using jquery terminal, ace editor, a go-lang web server and a command server inspired by redis. 
I really don't get way the sudden interest in these things. Sure its a cool thing about how the protocols can be used but I don't see the real world value in it.
Serving services from port 80 or 443 which are usually open on normally locked-down networks where as you would need to request other ports be open for specific use
That feels kinda gross as a network programmer. I like my services on specific ports.
yamux is entirely different from the other protocol detecting projects that were posted recently. I've used it for applications where I needed the client to create the connection to the server, but then be able to initiate requests in either direction. It could be done with websockets, but with yamux it was trivial to just have both sides have a regular HTTP API. The yamux API basically implements the interfaces required to look like a regular network connection at both ends of the connection. 
You wanted a real world use... Libraries/Schools/Offices often times are pretty locked down. This allows easier access to certain services funnelled through a common port like 80.
a) If setting `GOMAXPROCS` &gt;1 "breaks" old code, then that code was *already broken*. b) If you want to, you could just set and export `GOMAXPROCS=1` in your environment.
I think he meant to the math/big package.
**inb4:** *Thats what she said.*
That I agree with David but the ability to serve all services on the same port is just a consequence of https://github.com/soheilhy/cmux I'm using cmux for serving grpc and http on the same port, which is a very common issue with grpc https://github.com/grpc/grpc-go/issues/75 grpc is advertised as over http2 but it wants its own listener. As such, you'll need to create one port for grpc/http and one port for rest/http which is pretty annoying for admins and users. There are similar other networking services that are using the same underlying protocol but are designed based on having their own listeners. :-)
Thanks, didn’t know that C’s `strftime`did localization :)
I've left you some comments/thoughts on your GitHub repo, hope this helps a little :)
Replied, was my first time using releases. I deleted the first release, but it still shows. BTW, it would be awesome if you could send a PR with the refactored changes? ;)
Done :) Some things for you to consider: - Tests! - A little 'how to use' introduction in the README.md, perhaps with a copy of the command line help displayed. - Add license information. Keep it up, and keep learning! :)
* Usage included! * Added license :)
Excellent!
Thanks! Look at the GoDoc ref if you want documentation on how to do learning with the online methods. All models work as-expected (according to the extensive tests of idealistic test data.) The only one I'm iffy if it works 100% as-advertised is the softmax regression. It classifies handwritten digits from MNIST with just about 70% accuracy which isn't that great. I think the derivative may be slightly off, though I've checked it multiple times and nothing _appears_ to be mistaken. I'll look into it more, though. I do have a naive bayes text classifier working well that I set up this week for a production product (https://github.com/cdipaolo/sentiment which is the engine behind https://github.com/cdipaolo/sentiment-server) so I'd like to move that algorithm upstream into the package. --- Let me know what you guys think! There are examples on datasets in this repo: https://github.com/cdipaolo/goml-examples
This is a great idea. One thought: the errors channel is a nice idea; so nice, in fact, that I would avoid directly fmt.Print()'ing the errors from within the library. [Here is an example where the error is printed and sent over the error channel](https://github.com/cdipaolo/goml/blob/33f79401a0e02a44cf35843433daf5b4cae3edc5/perceptron/perceptron.go#L308).
done with https://github.com/cdipaolo/goml/commit/827ee14a75fc8ba7af994c1dea859a94de47416a
Beautiful!
I don't play MC but more because it's not my genre. 
I'll always have a soft-spot in my heart for Python, but after doing a few servers in Go, I'd be loathe to switch back, for server stuff at least. (Previously in python I've done a couple servers, numerous GUIs using PyQt, and lots of small scripts &amp; whatnot.) For me, Go's type system is a huge win. I also *really* like the reliance on explicit error handling, as opposed to exception raising. For more interactive programs, probably these differences would be less important. A note on performance -- the 'just write the slow bit in C' line is way too facile. In one GUI I was doing, I had to generate dynamically scalable plots for schedules. The original python worked great for small projects (in the hundreds of tasks), but was hopelessly slow for projects with many thousands of tasks. So, great, I'll rewrite that bit in C++. I was eventually successful, but it was *very* tricky -- the problem is when you have data living in python land that you wish to operate on in C++ land, there's a huge impedance mismatch (unless you want to write C++ that is manipulating the right python types -- yuck). So quite frequently the overhead of transferring the data from python -&gt; C++ can quickly become too high. Lots of thought &amp; additional work was needed beyond what would've been required if I had just written in a fast language to begin. Maybe even worse, the resulting solution had a lot of extra incidental complexity to deal because of having to cross the python/c barrier. So I don't find the "python + C for the parts that need to be fast" argument to all that compelling. If you need parts to go fast, you should strongly consider just writing in a fast enough language to begin with, IMO. (If you were talking about back in the day when Go didn't exist, and your choice was between something extremely cumbersome like C++ or moderately cumbersome and extremely low level like C, then maybe the Python+C approach made more sense. But with Go you can get within a constant factor of C performance and Python smoothness of development. &amp; of course there are lots of other interesting, high-performance, high-productivity languages other there now, too.)
So they can never include anything new into Go1 because of that. Doesn't seem very intelligent for a programming language.
Just write the slow bit i SIGSEGV (core dumped)
Python is nice, and I use it occasionally. My increased use of Go has not and probably will not affect that. Though, and I can accept that it may seem to be poor-mindedness on my part for thinking this way, I would have more respect for the stated arguments if such "features" were official implementations included with the language. I don't intend to discourage the idea of packages/libs which improve upon core features. The concern is regarding the idea that "official" (i.e. well deliberated and provided by default) tooling provides a healthier sort of environment and cultural development than that which is born from simply whatever is found to be the most commonly used. Certainly, not all tooling can or should be provided through the officially moderated channels, but because there are many examples provided by them from conception there is a much greater likelihood that outlying and complicated toolsets will be established in a similarly well deliberated growing medium. I am hoping that this principle will show itself true through the budding and fruiting of the vendoring solution. In other words, the development philosophy of the core team is something to admire in and of itself, and it's healthfulness is, thus far, evident (with the potential for much more to be seen!). I believe other languages should be less concerned about whether their tooling list matches that of another language, and more concerned about whether they are properly striving to drive their team(s). The "whoa" command should probably be used with more confidence and concision in many communities. I also see it as evident that many languages have spiraled out of control in this way and, while still being very useful, don't have much hope of a lovely recovery in the long-term.
On the contrary. It helps them improve and optimize a working language instead of dealing with new implementations, up until Go 2 work is on the table.
It's a tradeoff, and virtually freezing the interface comes with a lot of benefits.
What about the packaging stories of these two languages? I really like the idea of single-file deliverables in Go, versus a virtualenv or docker.
First: I like python. Python and Rust are definitely the languages I recommend to people not satisfied with go. That being said: &gt; As for go get, Python has pip. The great innovation about go get (and import paths in general) is that it completely moves into a decentralized model without any additional [requirement](https://packaging.python.org/en/latest/distributing.html) to make your code installable. When I want to distribute a go package I * Write the code * Document it with godoc-comments * Upload it to github * Profit I get a publically hosted documentation on godoc.org literally *for free*. Someone finding my github-repo can just prefix a "godoc.org" and find the correct and up-to-date documentation. And I didn't need to write any package-declarations, manifests or dependency files. Speaking of godoc.org: Again, this is one of the greatest innovations go has to offer. I don't know of *any* language that gets this as right as go. Not only do you get free doc-hosting, you also get it well-linked with all used packages. Every type you use becomes a link to it's documentation. After working with large, interdependent C++ frameworks, I can't overstate the importance of this. &gt; For style formatting that follows PEP 8, there is pep8 for commit-check time or autopep8 if you want more go fmt style automatic rewriting. Maybe I've been out of it for a while, but the last time I told pythonistas about auto-formatting, they heard of it for the first time. The great thing about go fmt is not *that* it is an Auto-formatter. C and C++ also have an autoformatter with clang-format. The great thing is its pervasive use in the community and that it's idempotent (it's a sad thing that this needs to be said, but clang-format at least creates different outputs based on what version you use, which mean that you and your team-mate can get different auto-formattings which is annoying as hell in version control). The mere existence is not enough, it needs to actually get *used*. &gt; I also don’t think it’s hard to convince people that you can definitely get a lot done in a few lines of Python code (the Go/Python 3 comparison shows that Python can accomplish solutions in less code than Go every time). So I would argue no one should disagree that you can be highly productive in Python, even compared to Go. I do agree, though I hate it, when people equate productivity with "how many code do you need for any given task". From that point of view, APL is the most productive language in the world, ever. Productivity isn't measured in terseness, it's measured in how long it takes me to solve a problem. It's an entirely time-based measurement, not a code-based measurement. And I personally find, that a language that emphasizes terseness (*cough* perl *cough*) hurts productivity, because suddenly that becomes a factor in your thought-process and gets in the way of simply writing code. Luckily though, python still strikes a reasonable balance here and does indeed pretty good on the productivity front :) &gt; Python is an evolving language. Unlike Go, Python is willing to change the language, even in ways that won’t be backwards-compatible forever. This means Python can become even more productive over time at a faster rate than Go typically can. Sadly, I find python's grab-bagging of features a big turnoff. This touches on the point above: go doesn't only turn down features, because they would be incompatible. It also treats adding features as a *tradeoff*, acknowledging that yes, features are usefull and will make some programs more expressive and terse, but no, that isn't necessarily sufficient to add them, because you want a small, lightweight language. I think Gustavo Niemeyer [put this into words perfectly](http://blog.labix.org/2012/06/26/less-is-more-and-is-not-always-straightforward). So, overall, a good article. It definitely makes the choice "less murky" and I enjoyed reading it. But in some points, I find the reasoning a tad misguided :)
I wouldn't actually consider go forward compatible at all. That would require, that with a go1 compiler you could compile a go1.4 program, which is not the case *at all* (indeed, most third-party packages I seriously used require something between 1.2 and 1.4). I don't know where the author is getting this idea. go is strictly aiming for backwards compatibility.
&gt; so that old code still compiles correctly Forward compability is new code compiling with every Go version since 1.0. What you describe is backward compability.
If I can make a counter-suggestion, even this is hard-coding something that is a bit of an imposition on the consumer, because channels are synchronous. Even better would be to take a function(err error) which you will call on an error; consumers can easily turn that into channel pushes, you could even provide the wrapper if you like: func ErrChanWrap(c chan error) func(error) { return func(e err) { c &lt;- e } } but making it a closure also gives any other options the user wants. In a similar situation, I have a library that takes a closure for error logging, but if you don't pass one, defaults to using log.Errorf() out of the standard logging package, and that seems to work out pretty well.
I've worked with gorm for a while now and switched over to sqlx. I regret nothing!
The thing is generics wouldn't necessarily be backwards incompatible with 1.x - I've never seen the Go team make any statements indicating as such. The reasons generics aren't included are technical and performance based.
This article just reminded me why I love the KISS philosophy of Go.
You need a `setup.py` file to list version, meta info and stuff, as well as dependancies. It's admittedly a little convoluted, but I could do, for instance: `pip install -e git+https://github.com/django-haystack/django-haystack.git@fcb1568c320628c2dea1f90038597a3468f7c529#egg=django-haystack` to install django-haystack at that specific revision without touching PyPi at all. https://pip.pypa.io/en/latest/reference/pip_install.html#vcs-support It's not straightforward, for sure. EDIT: Pre-emptive edit to say I'm not making any points about Python packaging being _better_, or even really talk about a direct comparison at all, but I've seen a lot of conversations directly comparing Go to Python, and there being a lot of misinformation about the capabilities of Pip/distutils. It isn't the prettiest thing in the world, but it's quite capable. That's the only point I'm really trying to clear up here. 
Regarding the Godoc part is there a way to disable the godoc public facing page? I imagine for proprietary code you wouldn't want public facing doc-page
There are a whole bunch of frameworks out there with examples. Of those frameworks, there are varying levels of handholding you can expect. If you're trying to assess whether or not Go is capable, you have to build it yourself. If you are trying to find out how to write code with Go, try these links: * [How to access a Database](http://www.alexedwards.net/blog/organising-database-access) * [One person's opinions about templates](http://shadynasty.biz/blog/2012/09/05/auth-and-sessions/) If you want to write complex business logic, that's up to you. I'm not able to share the code I write for my workplace.
Make the package a private repo on github and godoc won't be able to index the code.
Have you seen this? http://getqor.com/ Most of what you describe is there.
There's a few features about godoc that many people don't know about. There was a question on stackoverflow a few days ago asking how to find all the types that implement an interface. Of course you can find 3rd party commands that will do this for you, but godoc can also do this. If you run the godoc command locally with godoc -http=":8080" -analysis="type,pointer" you will get documentation that shows you detailed type information and some good callee/caller analysis in the source code view. I use godoc this way when developing as the online version of godoc doesn't have this enabled(for good reasons). You can find more info on the code analysis at https://golang.org/lib/godoc/analysis/help.html 
Is there a reason you couldn't just have a gorouting doing the logging while waiting for a response from the channel? That's (I think) why @carbocation suggested this. The user will be be returned errors on a channel anyways, and there's no reason why they couldn't have a loop in another goroutine just logging the errors and handling them in a business-specific mode. 
&gt; Is there a reason you couldn't just have a gorouting doing the logging while waiting for a response from the channel? The problem that I'm pointing out is that you've _forced_ this on the user. Plus given that you're looking at what is presumably high-performance code, you're also forcing a sync point on the error because channels are synchronous, though in practice if you're throwing up errors at a rate where that starts to matter it's probably time to \^C the process anyhow. (No sarcasm; this probably isn't a relevant point in this particular case, but I mention it for general discussion.) As flexible as channels are, it's actually a bit of a code smell to have them in your API. Sometimes it really is the best choice and unavoidable. If you go through the core Go library module by module, you should notice that A: yes, channels do sometimes show up but B: probably not as often as you might have expected. It forces a decision on how to arrange the goroutines on the user.
`gorilla/schema` was a lifesaver for me, but it doesn't work for file uploads, and my app uses dynamic tables pretty extensively, which initally utilized some hacks to get them to comply with `schema`. Honestly, my biggest mistake here was trying to jQuery everything, rather than use a more declarative approach to the javascript. I'm currently in the processing of rewriting a particularly hairy piece of it in Backbone, because I don't have enough time in the project to learn React or anything like that, but I dream of a form-generation package that can take a struct and spit out a fully-functioning CRUD UI based on its fields. Standard forms that don't require any dynamic client-side behavior are pretty easy, but unfortunately I underestimated how much more work a dynamic page would be.
I've built a number of large web and server-to-server apis with go. I've found the middleware approach demonstrated [here](https://github.com/rcrowley/go-tigertonic) to be an example of good api design with go.
Yes, Angular frontend to API server with OAuth server and client (see brief writeup here: https://www.reddit.com/r/golang/comments/3ewed0/eli5_rangelrealeosin_package_oauth2/). It also includes an image processing system using Go, VIPS, GroupCache and AppEngine Managed VMs. The system auto-scales and auto-discovers peers for GroupCache which caches thumbnails + image tiles and also ensures they are only generated once across all nodes. VIPS is used via CGO for fast image handling. I'm using labstack/echo for the actual web-app which is a very nice + fast micro-framework. I tried lots of them, ended up settling on that one (although goji + gin were also good). My previous experience is C# / .NET + some Java, Python and now Go. I prefer Go and find it the most productive to use. There is a lack of 'large reference apps' but part of that is to do with the language and platform - it does encourage simplicity. Still, I think a lot of examples are a bit too simple. It doesn't hurt to separate services with interfaces and modularize handler endpoints instead of having everything in one package. I find it good to question whether it's worth adding a dependency on a package or whether the std library is enough. Adding too many 3rd party packages does tend to make things feel more complicated.
I built this one in revel/go https://gotadevida.co/ BTW is text are in spanish for the moment
&gt; The great innovation about go get (and import paths in general) is that it completely moves into a decentralized model without any additional requirement[1] to make your code installable. When I want to distribute a go package I * Write the code * Document it with godoc-comments * Upload it to github * Profit This is _not_ an innovation. Its a step backward. Hardcoding a url means you are hardcoding _where_ something should be, not _what_ it is. If github goes down, we'd have to manually track down where each of our dependencies have decided to rehost, then update that url everywhere in our source code. If `pip` or `npm` go down, their entire manifest is open source so it is guaranteed that someone in the community would pull it and host a mirror. Or you can. And then all you have to do is tell the package manager to hit that mirror, which is a simple command line flag. `go get` is, in every sense of the phrase, the absolute worst part about the go development toolchain. Its only redeeming quality is that it is built-in. It forces you to hard-code URLs, which is a **hard no**. It completely lacks versioning. It introduces global dependency hell (which should cause some deja vu for pythonistas). And, what's more, its _so bad_ that the community is now split between two or three band-aids which fix these things, which is pretty much a nightmare scenario for any package manager. 
&gt;if you're throwing up errors at a rate where that starts to matter it's probably time to ^C the process anyhow that's part of my point though. I get where you're coming from. I think adding in the callback could reduce performance though because you're either forced to run it in a goroutine and not worry about the user keeping the function lean (this is what the onUpdate callback within most - or maybe all I cant remember - of the OnlineLearn functions does, in case the user wants to persist to like Redis or Postgres or something) or run it directly which, if the function takes a non-trivial amount of time, would slow down performance significantly. The main use case for using the library is, design wise, learning from temporal data being pulled from some API. Based on that use case I think channels would be/are the best design choice and certainly the most idiomatic way to implement online learning. If you're going to be passing your data along a channel I think it'd make sense to pass back errors through channels as well. Note that the user _can_ choose to learn in batch settings, and that is the only way to learn for some algorithms, but if you're only going to be doing that you might as well just run sjwhitworth's library `golearn` which focuses on that. I know that channels do only show up 5 times within the standard API. I think that is a necessary and judicious use, though, and takes advantage of that feature of Go
performance. how do 120k requests / second @5000 concurrent sound?
Exactly. I do like python a lot for certain tasks, but reading this article just highlighted how much incidental complexity python has around the language. * Want something like a statically compiled binary? Just learn about virtual envs and cx_freeze and docker/containers and figure out which one is right for you. Then figure out exactly how to bake it into your deployment process. * Want your code to run faster? Research a bunch of different VMs and find out which one happens to work best for your workflow. * Want something like go get? Learn how pip works and package your code. Want to be able to get someone else's code as easily? You better hope they went through that trouble or you'll have to package it yourself. * Want good concurrency? It's great in python 3. Good thing no one's legacy code depends on a ton of python 2 libraries that no one wants to port. Har har. * Want static typing and related tooling? We're working on type annotations now. We'll get back to you. **Or** I could get all of those things for practically free with go right now.
Sure have! I have been working on a fairly large web app here: http://github.com/jordan-wright/gophish. It has a full api, middleware, etc. Let me know if you have any questions about design decisions, etc.
Enjoyment.
a) What /u/alexwhoizzle said :) Public code is per definition not private. If you don't want something indexed and used, don't put it on the internet. b) If for any reason you don't want your public code indexed, write a mail to the team, as mentioned in the [about-page](http://godoc.org/-/about).
You probably shouldn't open a database connection on each request, as `database/sql` will pool connections for you automatically. You have severals ways to achieve what you need. The ones to come to my mind right now is either having a global DB object, or passing the DB handle using a closure: func handlerWithDb(db *sql.DB) http.Handler { return http.HandlerFunc(func(...) { // use `db` }) }
I have done a 5k LOC web project this year. No fancy Javascript, just plain page generation with `html/template`. I have used https://github.com/gin-gonic/gin as my main engine for routing and middleware, `gorilla/sessions` and `bcrypt`for authentication and Rails-style "flash" notifications. Also `go-sqlite3` with `database/sql` for data handling, this is a low-traffic website, and Sqlite does the job nicely. Apart of that, just standard library. File structure is flat, with separate files for `const`-based config and SQL queries, also separate files for controllers and models corresponding to domain objects and their (mostly-CRUD) operations. While working on the project, i have borrowed some solutions and structuring conventions from Rails, because i know it well and it was easiest to just transfer the knowledge. My main annoyances were largely with Go being lower-level language so it's not possible to write code as concisely as it can be done in Ruby/Rails. 
You don't have to write in PHP
Yes. Gorilla (mux, sessions) + middle + [amber](https://github.com/eknkc/amber) (pure `html/template` is a painful when you need build a really big and complex front-end) + sql driver ([mysql](https://github.com/go-sql-driver/mysql) (with [mymysql](https://github.com/ziutek/mymysql) have some troubles)), and some previous experience in Go for right project architecture.
Could you expalin the "error struct" more detailed. 
Thanks for the explanation :) It was more meant as a "why are pointers a problem, but python lists aren't", than a "why is this so?". :) I am genuinely interested in the question why people struggle with pointers from a CS/programming education perspective.
People struggle with lots of seeminly easy things. Maybe because people can think in terms of lists of items and 'for each x in y do z' naturally, but not so much when it's behind a level of a rather synthetic indirection? Long history of epic fuckups in C proves that the concept of pointers is not as easy as it may sound.
I run a real-time charting service for Bitcoin markets, and the backend is 100% in Golang. It gets quite a bit of traffic. https://cryptowat.ch It consists of HTTP + Websocket servers and has a lot of special logic for getting data from different exchanges. I also have contracts with some clients who asked for customized views of the whole thing, so the template logic is pretty complex. The biggest gotcha was that it took me some time to get accustomed to how to write good templates in Go. I was unable to find any good examples of *complex* Go template setups (just simple stuff). But I didn't have too much trouble coming up with my own patterns because, like the language itself, the template syntax is so simple! Database-wise, it uses persistent Redis for most data storage and MongoDB for some small user-related collections. I find most popular services like those have really well written Go drivers so it has never been an issue trying to integrate services. Sadly none of it is open source, but I want to open it up in parts once it stabilizes as a business. But with regards to Go, yeah, I am very glad I decided to use Go.
The exact answer I gave my boss a few weeks ago.
I am not claiming Pointers are "easy". They evidently are not, otherwise people wouldn't be having so much of a problem with them. :) I am asking *why* pointers as a reference type are hard to understand, when you are already used to python lists as reference types. It seems counterintuitive to me, as pointers only make the reference *explicit* (as opposed to python lists, which are "sometimes treated as a reference, sometimes aren't and the difference is implicit"). And I think unless we (as people who understand pointers) try to understand *why* they are difficult, we can't give good explanations that make them easier. As such, the question was directed at /u/plasticmacaroni who apparently was in specifically this situation so might have something valuable to contribute and help me understand, what makes pointers harder. I don't think a different person making guesses about the reasons helps me, no offense :) I can guess myself, I was interested in their opinion. :) And lastly, though somewhat unrelatedly: I don't think C Code had any *pointer* fuckups, did it? It had some pointer *arithmetik* fuckups, but even then, most of the time even *purely* arithmetik fuckups (buffer overflows have little to do with pointers, they are only based on the fact that someone miscalculated or failed to check some bounds). They lead to crashes and security bugs, because C doesn't have *typechecked* pointers and wasn't memory safe. But alltogether, I don't think that the failings of C a) where due to pointers as a concept and b) explain why pointers are difficult.
I've used a global in the past for this, but I've seen some contention among some gophers about using globals (whether they're good or bad). Either way, OP -- definitely let database/sql manage the connection for you. 
Indeed very good article, since I am new to golang, this gave so much knowledge.It answered my next question also. "How to make database and model as separate package". Thank you very much for the right direction :)
I will follow the code. Thank you very much :)
Well, building. It's a platform for hosting special videos and photos that can be texture mapped on a sphere so that you basically have a 360 x 360 perspective, as if you're actually there. With a VR headset the feeling only becomes more immersive. I have a pretty simple top-level directory structure that grows more complex the more you tunnel down. View logic in the views directory, models (including the database calls I need for them) in the models directory, a directory for app settings, and another directory for "utility" stuff. With the views directory, the directory structure is broken down such that with profiles, I have a dedicated profiles directory, with a file dedicated to POST requests, a file dedicated to GET requests, additional files if there are other requests, and also a file dedicated to grabbing and validating form inputs. It's worked pretty well thus far. This is a tad embarrassing, but I must admit I really hate Gorilla's sessions implementation combined with the library used for MySQL as a session data store because the damn thing didn't exactly work the way I expected it to (by contrast, the JWT library I'm using works exactly how I expect it to). So, I wrote my own session library instead. I'm not afraid to say my own session library is probably crude, but takes into account basic security (the session id's have 64 bytes of randomness, or a 88 char length base64 string, is that excessive or not enough?) and has satisfied my own self-imposed goal of being pretty simple to understand. The catch is that it's use case is pretty limited because I built it to solve an immediate problem. I'm working on expanding it to be more general purpose while still keeping the simplicity goal in mind. Question: Has anyone found any templating engine that's more similar to Jinja / Django's default templating engine? I come from Django, so while I haven't had any issues with Go's built in templating engine, I definitely miss the Jinja way. EDIT: Blast, the OWASP cheat sheet says I should be using at least 64 *bits* of entropy for session ids. So I'm probably overdoing it here by a long shot, but damn if my session ids are unguessable now.
I've used this a bit, and it generally works well.
Interesting. I can see why you'd want to (re)move things like `encoding/base32` that basically have no use, but the large standard library is still one of the most compelling reasons to use Go for projects. I love that there's SMTP support in there, for example.
Yes, and we don't have forward compatibility. We have backward compatibility. not sure why anyone is calling it forward compatibility.
Why the `.Function.Params…` style, instead of just… using functions and parameters? That looks incredibly un-statically-compiled-typechecked-language-ish to me…
wow nice site! how are the stats for your server?
why would base32 have no use?
Well, base64 exists. There might be an edge case where you'd want base32 instead, but it's not common enough that it'd need to be included.
@bradfitz (member of the go team) on the standard library &gt; Q: "If you could redesign one of the standard library packages which one would you choose?" &gt; A: "Oh, I would delete half of them." [link](https://youtu.be/rHBbqjWCGq8?t=1h10m55s)
I'm having good times and luck working with beego as a web application platform.
I don't understand why there's golang.org/x/image but not golang.org/x/cloud (or similar). It should contain all the cloud-infrastructure stuff you need, kind of like go-kit is trying to do. Defining interfaces for Auth, Consensus, Logging middle-ware, RPC,… and then implementations of common and widely used protocols. That would be really great. I don't think all of this necessarily belongs into the stdlib. I don't think the http-server needs to be in the stdlib. But definitely on golang.org/x/… where you know, that capable people with attention to coding practices and stability will maintain it and it's "officially blessed".
Go's net/http package is kind of important. It definitely belongs in the standard library.
I find that arguable. Why? Specifically, your answer can't be "it's important that we can do HTTP requests in go". It can't even be "it's important that everyone uses the same API/package to do HTTP requests". Or "it's important that we have a stable package for HTTP". What *specifically* makes HTTP more important than, e.g. * git, hg, bzr, svn wire protocols and client implementations * Image decoding (because that's an example from brads talk) * SMTP, IMAP * Machine Learning * Parsing Lisp * A GUI toolkit * Terminal handling (think termbox) * MongoDB drivers I'm not arguing that these should be in the stdlib. I'm not arguing that HTTP is not important or that I'm not glad that there comes an HTTP server and client bundled with go. I'm not even *really* arguing, that it *shouldn't* be there. I'm just arguing that I always found it kind of coincidental, what is and isn't in the stdlib and as far as I know a lot of stuff in the stdlib is there, because camlistore needed it. There is no clear line what should and should not go into the stdlib, certainly not a definition and OPs link *clearly* demonstrates that. It is arbitrary. I think golang.org/x/net/http would have worked equally well and has the same advantages as net/http. An arbitrary line that can be drawn is "the stdlib is for stuff, that's needed for the standard tools to be implemented". That would work and it would work as an argument for net/http (go get needs that). But it wouldn't a) explain why we need a server too or b) explain why the stdlib doesn't give us free cloning of repositories. I'm not trying to argue about whether stuff should or shouldn't be in the stdlib, but about whether *arguing what should and should not be in the stdlib itself* makes even any sense. Imho it doesn't.
The only condition I've heard people call this "middleware" is in the HTTP handler scenario. Everywhere else, this is basically a textbook implementation of the Gang of Four "Decorator" pattern. https://en.wikipedia.org/wiki/Decorator_pattern And this is something I've found myself doing a few times in Go lately, and not in an HTTP context.
&gt;&gt; Question: Has anyone found any templating engine that's more similar to Jinja / Django's default templating engine? Have a look at https://github.com/flosch/pongo2
Correct me if I'm wrong, but doesn't it being in the stdlib mean it can only be updated with new Go releases? I think it'd be interesting to break out some of the important things into separate repos and then making those repos filled with good implementations of many industry standards. For example database could be broken out and then a consistent ecosystem can continue to be promoted by having implementations for many of the major database drivers and not just sql. The std lib should really just be the barebones necessary for making good Go code - ie core functions, testing, logging, io, regexp, etc. In that view, it doesn't necessarily make sense to me to even have net/http as /u/TheMerovius argued other than convenience and because it's become essential to Go's identity. I think if that were to happen some more work would have to be put into exposing those other repos and raising consciousness of looking there.
Good point.
This looks promising!
Social engineering?
The flipside to that is whether base32 really adds maintenance weight/bug surface area to *not* include it. Since it's a fairly basic implementation, and useful in its own right (base64 isn't always suitable where base32 is), then there's an argument to include it.
How would you tackle validation? The syntax between even the popular SQL engines (mySQL/Postgres/MSSQL) varies so wildly as to make that a huge task with a lot of corner cases (quotes, params, etc). Integration tests on the application side are also *still* going to be more robust. Otherwise: it looks solid. The `pkg.DirName.FileName` approach is alright, although even with 30-40 odd queries you end up with a lot of files to deal with (even a well-tuned vim doesn't make this an exciting prospect). I'm hoping (due to my own lack of time) that someone makes a 1:1 copy of `yesql` for Go, using the standard SQL comments to provide naming. Putting the queries into a `map[string]string` keeps it simple too (and can tie in with go generate if you want to generate the map AOT).
Not just (in fact, that's a side effect). See (read: the discussion we had/are having) here: https://github.com/gorilla/csrf/commit/21dad7a81a52b69de043cd46eb1e603cf5d1c6d1#commitcomment-12532054 If you *don't* return a `func(http.Handler) http.Handler` then you can't do the below, which is a simple (but common) use case: e.g. func main() { CSRF := csrf.Protect([]byte("32-byte-long-auth-key")) r := mux.NewRouter() // The two below lines are now invalid. r.HandleFunc("/signup", CSRF(ShowSignupForm)) r.HandleFunc("/signup/post", CSRF(SubmitSignupForm)) // Other routes that you might not want to apply CSRF middleware to - i.e. static file handlers // ... http.ListenAndServe(":8000", r) It would also apply if you wanted to individually wrap nested routers/muxes with the same CSRF instance, amongst also using middleware chaining libs. The "flipside" is that you end up with: http.ListenAndServe(":8000", csrf.Protect([]byte("32-byte-long-auth-key"))(r)) ... instead of: http.ListenAndServe(":8000", csrf.Protect(r, []byte("32-byte-long-auth-key")) I see this as a worthwhile trade-off—you can share a single csrf instance across handlers/routers at whim—and it's not uncommon in its own right. 
Wow I was looking for this today...need to get these stats into influxdb now...
Yeah, thats a great talk . Another one that echoes the sentiment I was attempting to convey is "dotGo 2014 - Blake Mizerany - Three fallacies of dependencies" https://www.youtube.com/watch?v=yi5A3cK1LNA Basically, think twice before creating a large package, just to find out later that the standard library already covers. :-) Refactor your knowledge of Go as well as your code :-)
Right, l'll push a change today. Thank you for your feedback :)
Go core team philosophy: Do as we say, except when we don't.
Wouldn't .page attempt to reference a field (non exported, but anyways) in the provided structure? "." In this context is your page struct, you shouldn't attempt to reference it.
No that's not what I mean. page is the struct you pass in, which means "." *is* page. Doing .page is equiv to page.page. You probably want something like {{with .Title}} &lt;title&gt; {{.}} &lt;/title&gt; {{end-}} Sorry for formatting, on phone.
Thanks for reminding me about that possibility but, no, it didn't change anything.
Ya. Currently we use React Native for about 70% of our iOS apps and the rest written in Objective C. We are very happy with React. It's much more pleasant than writing everything with standard iOS tools, but we still wanted to evaluate Go a bit because it's a language we particularly enjoy. 
That works. There must be a mistake in how I'm passing the structure and I just don't see it or I forgot something.
This is a great technique for builds that use the appropriate ldflags, but what can you do for people who just `go get` your application? The best I have come up with is a hard coded version that we increment by hand at each official release, so at least people who build from source have a ballpark range available. This in combination with data and sha for any build with the right ldflags seems to work ok. Kinda wish you could customize the build command for `go get` just a tiny bit more somehow.
Just gave it a try and it seems that slices aren't supported - and silently ignored. Any plans to fix this? I just looked into doing it myself, but I just started with Golang and so far I was able to avoid the reflection APIs.
Anyone know how this package compares to [nosurf](https://github.com/justinas/nosurf)?
Anyone know how well this works, or have an example input/output?
I'd imagine these are largely network IO bound tasks so I cannot imagine performance changed significantly.
Any hook would have to be installed by hand for the specific user. There is no way to get one to run when someone simply does `go get`
&gt; Interesting that there was no mention of performance. It appears he chose some non-core services, so any performance improvements would be meaningless. (i.e. if it's not a bottleneck, making it faster won't matter.) &gt; I can litter code with sleep statements that would nicely reduce cpu usage. Good for you, but not everybody is that twisted. :) I think we should assume they were doing a straight-forward port, and weren't trying to make Java look bad. &gt; it seems like it might be worth experimenting with Rust. It seems they did. The article specifically dismissed Rust for 2 reasons: Immaturity (a big 1.0 doesn't magically make it mature) and lack of good libraries for HTTP. &gt; There's always a chance it may be a better fit. Yes, but: 1) You can say that about any language because that statement is impossible to falsify. 2) Go and Rust are similar enough that either one is "good enough" for the job. If there is some _specific_ technical reason you thought Rust would be better in this case, let's hear it.
You can follow the progress of a pure Go port here: https://github.com/romain-jacotin/quic
I know, but just to save you remembering to manually increase the build number. 
TL;DR: They used a language that doesn't load an entire hotspot compiler into memory, and lot less memory was used. Everyone was very impressed.
Well, he could have run his java process with -Xmx3M -Xms3M and obtained the same level of memory utilization....
Unless you compare apples.
Have you considered just proxying the requests to the old API and start building only the new API in Go?
Not only is your answer wrong, it was supplied by someone else hours ago and is the longest thread here. On top of that, I supplied the solution to the problem myself in the answers.
Uh. Of course I was wrong and made a mistake. That's why I asked the question. I even said both things in my post and elsewhere. You're hours late to the party, didn't even read anything, the solution was already given, you get called on it and now you're saying I'm the problem?
[**@golang**](https://twitter.com/golang): &gt;[2015-08-06 05:30:17 UTC](https://twitter.com/golang/status/629162555248807936) &gt;Go 1.5 Release Candidate 1 is released &gt;DL: [*golang.org*](https://golang.org/dl/#go1.5rc1) &gt;Notes: [*tip.golang.org*](https://tip.golang.org/doc/go1.5) &gt;Issues: [*golang.org*](https://golang.org/issue/new) &gt;[#golang](https://twitter.com/search?q=%23golang) ---- [^[Mistake?]](/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3fyyxr%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
It's implied that the memory usage shot up when they moved to docker - am right? If that were the case then surely it's the item to focus on? Also, the mention of tomcat makes me think there were gains to be made there - plenty of microservice APIs have embedded HTTP servers and therefore don't need a web container. 
Interesting! Small nitpick and completely off topic but... for line in `docker ps | awk '{print $1}' | grep -v CONTAINER`; do \ please think of the children and don't pipe awk to grep... for line in $(docker ps | awk '!/CONTAINER/ {print $1}'); do \
I haven’t tried it yet, but we have an iOS and Android application, same app on both platforms with a couple of C libraries that are used across both platforms. I can see Go being an excellent replacement for those C libraries.
I've worked with Sublime for a while now and didn't know about this feature. Thank you!
Excellent! Is there a change log from beta3?
If you are not using the GC much I guess it follows that improvements in the GC have little effect. Were you expecting major code optimization improvements? Have you tried gccgo? Is it better?
This might be overkill, but would [InfluxDB](https://influxdb.com/) do what you need?
Fantastic article. Do you have an adaption/example of the static fileserver that makes use of precompressed lookup? 
Well, hopefully their package is better than mine: [https://github.com/josephspurrier/csrfbanana](https://github.com/josephspurrier/csrfbanana)
The `$` characters are the syntax of the snippets. They represent the tab stops and are ordered by the number to the left of the `:`, and the value on the right is the default that will be highlighted by the cursor. See the docs for reference: http://sublimetext.info/docs/en/extensibility/snippets.html 
Interesting that your build is faster! My understanding is that a lot of people are experiencing 2x slowdowns as a consequence of the move from C to Go, though the build times are expected to jump back down in the future.
It's an obviously faster build, too. Most of my imports are small, native Go libraries. There are three imports that are not native: GLFW, GL 3.3 and Assimp. These three imports end up calling C libraries. 
The last time this was discussed among members of the Go team at Google, the general recommendation was: Once you've reached v1 for your API, make an explicit compatibility promise. If you need to change the API in a way that breaks that promise, it should happen on a different import path. Although Fowler recommends against versioning REST API paths: /myendpoint/v1/functionA /myendpoint/v2/functionA I do think that in the Go case, it is preferred over your options #1 (seems excessive) and #2 (too complex to maintain). 
Don't simulate a sync.Mutex, just use a sync.Mutex. I think it takes hits on all fronts (except reliability). Compare with [this](http://play.golang.org/p/31McBb67Ko). This is also better because you can make it a RWMutex, to reduce lock-contention when you write it seldom and read it often. You also don't include any code to stop the started goroutine which might lead to resource leaks. [This pattern](http://play.golang.org/p/KIjrnZENH0) is a *bit* more appealing to me than locking, if you want to enable the same usecases. Overall, I think it depends much on the usecases you have. I wouldn't try to simulate usages of sync Primitives, but instead focus on the pattern of giving a goroutine exclusive use over a resource and offer an API to it via channels. [edit] Forgot that I wanted to also demostrate how to [abort the goroutine](http://play.golang.org/p/cyUHWi6Ub-)
Cute trick but the compiler will eventually learn it can omit those.
Cool, it seems the time is way more ready for this now than when I first launched the subreddit. Let's see where this will get us :).
parallelizes, not parallizes (sounds like paralyzes...).
This is a clear example of code that may be cool to write for the lolz but should never be published. Somebody may think it's a great idea.
This seems like the simplest way yet to package up Go programs for Docker, very nicely done. But, like almost all of the other recent blog posts on this topic, it sets `CGO_ENABLED=0`. I hate to keep beating this drum, but the runtime uses cgo in a few places itself and disabling it in your container might end up surprising you *at runtime* if you are not also setting `CGO_ENABLED=0` in development and testing. I prefer to use a small but glibc-enabled image like `busybox:ubuntu-14.04` as my base image so that I can avoid `CGO_ENABLED=0`, as my apps depend on some of the cgo functionality (like `os/user.Current()`). I wrote about it here: https://joeshaw.org/smaller-docker-containers-for-go-apps/
That sounds like it would explain it. Awesome feature! 
Thanks. Not a complete one I can share. I have an old one from a Revel project I worked on a while back. https://gist.github.com/klauspost/baad923e77caf20b777e It doesn't do any gzip by itself, since that is handled by a separate filter in Revel. But it basically checks if the ".gz" version exists, isn't a directory (really just being paranoid) and will stream that instead. It also sets extremely optimistic caching, since we change the path for static content on every version, so be careful with that if you use that part. I will see if I can cook up a non-Revel version.
I know that this is yet another way of simplifying your deploy process (and if fact I think I could use something like that for my own projects), but I can't help but thinking "YO DAWG" every time I read something like this. To make it even more nested, the Go program should be launched from a shell script generated by a Ruby DSL, and the Go program's configuration file should actually be a script in Lua.
I use systemd. On app deploy I: 1) copy the Go program and a systemd config file 2) Tell systemd to restart the program. 3) Drink Beer.
:)) 
So, I decided to do some performance testing. Using channels instead of mutex locks took about 10 times as long. I'll post the code in an hour. 
You aren't using channels *instead* of mutexes. Channels are implemented *with* mutexes. Channels are a thread-safe abstraction around communicating.
I highly recommend the tools "go vet", "golint" and "goimports". Lots of the feedback you've already gotten would be mentioned/corrected by those tools. I also recommend using a text editor like Sublime (with GoSublime) or Vim (with vim-go) instead of an IDE. Its definitely more common to not use an IDE and you'll want to see your project the way others will if they fork it. You've split your main.go into sections with comments when what I think you really want to do is split those blocks into files. Your "main_test.go" file doesn't contain any functions that start with "Test..." so you are not leveraging the included test runner ( http://golang.org/pkg/testing/ ) It is more idiomatic to return an error and let the caller decide what to do than to print it. For example: func loadConnectionString() (Config, error) { content, err := ioutil.ReadFile("config.json") if err != nil { fmt.Print("Error:", err) } var conf Config err = json.Unmarshal(content, &amp;conf) if err != nil { fmt.Print("Error:", err) } return conf, err } Would be written as: func loadConnectionString() (*Config, error) { content, err := ioutil.ReadFile("config.json") if err != nil { return nil, err } conf := new(Config) err = json.Unmarshal(content, conf) if err != nil { return nil, err } return conf, err } 
Ahhh, that makes sense. Thanks! 
Sppeling is hart.
This is nice. Do many browsers support lzo? You can generally compress it and decompress it much, much faster than gzip with not a huge gain in size. Ideally, you might have a compressor that would vary the compression based on input speed in the pipe. So if it's CPU bound and it finds that lowering compression level increases speed, it keeps it low. If it's out of the pipe bound it finds that compressing at a higher rate means it's pushing more data through and in turn reading faster. The compression thread could also be niced fairly high to be sure it's not slowing down much else and more using spare cycles. Of course if you just have one big batch of content, it's best to compress it all at once beforehand.
What advantages does this have over the official golang image?
[**@jamwt**](https://twitter.com/jamwt): &gt;[2015-08-07 18:55:32 UTC](https://twitter.com/jamwt/status/629727590782099456) &gt;All the [#golang](https://twitter.com/search?q=%23golang) excitement on hacker news makes me realize I don’t think people realize how deep [@Dropbox](https://twitter.com/Dropbox) is in golang. ---- [^[Mistake?]](/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3g7tyv%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Yeah I may have phrased it badly but I guess my point was that channels still carry the cost of locking.
Web front-end is still millions of lines of python.
There have been some interesting Go related posts on Hacker News the past few weeks (e.g. from Cloudflare's blog), so perhaps that's what prompted the tweet.
Method expressions are cool. I just had no idea they can also be called via interface. Thanks. There is another example for Method expressions in use: http://play.golang.org/p/yKr7Y4SY1h
Thanks for clarification.
I don't get it. People *still* keep using the name golang. 
I don't like shorteners; they add a layer of complexity which takes time, requires extra resources, adds attack surface and has privacy implications. They obfuscate the final destination, preventing a user from making an informed decision to load it. And who knows how long they'll be around for. I prefer using a full URL.
How ironic for a programming language developed at Google to be named in a way that makes googling it harder.
[**@jamwt**](https://twitter.com/jamwt/) &gt; [2015-08-07 20:22 UTC](https://twitter.com/jamwt/status/629749541856632832) &gt; @asbradbury The infrastructure service layer -- data, metadata, monitoring, notifications, queueing, search etc--is go. App/web is python. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
At least they didn't say GoLang. 
At least they didn't name it "porn"
What's your point? I mean, I *get* it. I know about search, meta tags, domain names, Rob Pike's joke on Quora about the name, etc. What I don't get is the laziness. It is intellectual dishonesty to call this language by any other handle than Go. The official documentation makes this abundantly clear. Moreover, it sounds idiotic when used to label it: "I re-wrote the server in golang, check it out!" There is no ambiguity. "Docker is written in Go" in 2015 is completely clear in its meaning. Sheer laziness. **All of it.**
The hashtag is similar to the domain name: a matter of practicality. Someone used it and it stuck. It's unfortunate. What I'm specifically nagging about is the use of the term "Golang" when the word "Go" makes equal sense. This is not the case in domain names, twitter hashtags or search terms, but is the case in blog posts or tweets. edit: to clarify, that excludes user names, domain names, email addresses, twitter handles, twitter hashtags, archive release files, aptitude packages, subreddit titles and so forth
https://github.com/jteeuwen/go-bindata works great: during development it serves the files from a directory (so you can edit them and they'll reload), in production it keeps the assets in memory (optionally compressed).
Wasn't their desktop client Python too? Or did they change that?
Google is the worst at this. They named their JS compiler 'Closure.'
&gt; You're right, but Google does index by HTML meta tags No it doesn't. Maybe the description, but only the first 255 characters. Keywords are ignored completely. Also content &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; meta anything
Are you sure about this? 
Bit tightly wound then buddy? It's being called that because its clear what you mean, that isn't lazyness.
I was confused by this comment at first. Jaime is a him. 
&gt;I quickly found that practically anything I want to achieve no matter how primitive requires trawling github to find a package that does what I need. I've had the opposite experience; I've found that everything I want to do is covered by the standard library or is too specific to be covered by any third-party package. What are the things you're trying to do, and what packages have you tried? &gt;Maybe I have had it too easy with c# and javascript, but wasn't go supposed to be simple and fast to develop with? In my experience, Go isn't necessarily faster to get a first working example, but it does make refactoring and adding features easier. &gt;I tried to say neutral compared to my co-workers, what am I missing? It might not be the language for you. There are definitely a lot of places where Go is awkward or obtuse, and it's totally understandable that you don't like it.
to echo /u/ergotayours - i find the majority of things I need are in the stdlib. The times I use packages off github are for more complex things I don't expect there anyway, like oauth, postgres driver, font rendering, etc. the docs and tooling make it much easier to work with than C#/JS in my experience. but it's definitely more verbose and not necessarily faster. Personally, it took me a good 4-6 months before Go really "clicked" - I could write code just fine, but nothing was really idiomatic or clean until then. I had to get out of my previous code mindset to get to that point though (e.g. I had to structure my code like a Go program, not a python-program-in-Go-syntax). can you provide any specific examples of something primitive you had to scour github to solve?
I didn't see you respond to the suggestions in that thread. Did .FormValue() work for you? If not, why not?
&gt; type *http.Response has no field or method FormValue I don't think my question was read properly. I end up using Goquery which works but is again another package.
parsing html you'd definitely want to find a package for, but if you're up for regex this is fairly simple w/just the stdlib: package main import ( "fmt" "io/ioutil" "net/http" "regexp" ) func main() { tofind := regexp.MustCompile("&lt;input[^/]*/&gt;") resp, _ := http.Get("https://duckduckgo.com") content, _ := ioutil.ReadAll(resp.Body) fmt.Println(tofind.FindAllString(string(content), -1)) } I'd want to check all the errors and close resp.Body, etc. but it's only a few lines of real code.
&gt; the docs and tooling make it much easier to work with than C#/JS in my experience Honestly I find MSDN far superior to any of go's docs. &gt; Personally, it took me a good 4-6 months before Go really "clicked" - I could write code just fine, but nothing was really idiomatic or clean until then From the replies so far I will push on and hope things click. &gt; can you provide any specific examples of something primitive you had to scour github to solve? I replied to /u/rgotayours with an example.
I started out by googling regex for golang but the first result was a a guy telling someone with the same question as me that using regex for html is a terrible idea
&gt; it does make refactoring and adding features easier. This is also where I am getting stuck. When I want to refactor something I can't even see what the types are that I need to pass to my func. I'm used to being able to hover over a variable and instantly see the type. 
I have spent plenty time on godoc.org, the problem is that for a lot of packages they give you a simple example and beyond that you are on your own.
To be objective I have years of experience with c#, java, javascript etc and maybe I just have a bad memory but I remember being able to get on with what I wanted to do, with c#/java at least I agree on the js side. I have no intention of "copy and paste development" but I do have actual solutions I want to build not various hello world incantations. .NET has such a fantastic environment for getting up and going quickly. You can build real applications extremely rapidly yes the code might be horrific but you can learn as you progress. With go I feel like I hit a brick wall very quickly. 
You're complaining more about the IDE here than the language. Going from C# and VS to a not-so-strictly-typed language in an editor without a great intellisense replacement is going to be difficult no matter what. You would have the same experience with a multitude of languages.
I don't mind seeing golang so much, but fwiw this isn't actually true. Google does a pretty good job of surfacing go links for go + something: https://www.google.com/#q=go+dropbox https://www.google.com/#q=go+testable https://www.google.com/#q=go+assembly https://www.google.com/#q=go+rust etc... (though to be fair, I suppose I could be in my own search silo here)
Haha. I suppose to be fair MSDN has come a long way over the years.
I would like to commend /r/golang for the level-headed replies so far. They have made me re-examine things and I am finding this incredibly helpful. Edit: Well it was fun while it lasted, I see the trolls have come out to downvote everything. It is unfortunate that the neckbeards are so emotionally fragile. Thank you to the helpful and patient redditors.
The magical thing about Go is that it has no magic.
vim-go and GoSublime are pretty good and integrate with go oracle pretty well. there might be some configuration to do though. Last time I used Atom the Go support was abysmal... not sure what it's like now, but look for something using go oracle. Still nothing on intellisense though.
Atom has not been great. I will see how Sublime fairs. 
I'm having a problem with that first statement, too. If one is looking for other people's code to make your Go code work, then I question his methodology for learning Go. Or maybe I misunderstand that. All too often I see people learning programming or something new and their first assignment seems to be to find someone else's code to do the work for them rather than learning how to write the code themselves. EDIT: Scrolling down a little further, I see he finds "getting up and running quickly" to be important to him but that adds more to what I'm questioning above.
the stdlib is well documented. as i said above, stick with it to learn the language. there's no point in spending time in chinatown or little italy if you're trying to learn english.
Then maybe you should stick with MSDN.
Here is an example without any third-party libraries (it uses `golang.org/x/`, which isn't in the stdlib but is maintained by the Go maintainers). package main import ( "fmt" "golang.org/x/net/html" "log" "net/http" ) func getElementById(id string, n *html.Node) (element *html.Node, ok bool) { for _, a := range n.Attr { if a.Key == "id" &amp;&amp; a.Val == id { return n, true } } for c := n.FirstChild; c != nil; c = c.NextSibling { if element, ok = getElementById(id, c); ok { return } } return } func main() { resp, err := http.Get("https://github.com/login") if err != nil { log.Fatal(err) } defer resp.Body.Close() root, err := html.Parse(resp.Body) if err != nil { log.Fatal(err) } element, ok := getElementById("login_field", root) if !ok { log.Fatal("element not found") } for _, a := range element.Attr { if a.Key == "value" { fmt.Println(a.Val) return } } log.Fatal("element missing value") } EDIT: Moved value checking to a separate loop from id checking
I posted an example using only golang.org libraries.
I see you have reading comprehension difficulties.
Not at all but I am willing to spend the time on whatever tool(s) will improve my productivity. I posted this thread because I dont want to give up on go and wanted to hear from experienced go users how I can get myself on the right track.
Oh... I'm not sure wether it's the brightest idea to pick up Vim and a new language at the same time... Vim is the kind of thing that [takes a while to learn](https://i.imgur.com/0l9dKNi.png) and years to master. Maybe try out sublime first. But more importantly, I'd recommend you take your time to switch your way of working with code. C#/Visual Studio encourages you to let your editor do all the heavy lifting and hide all the extreme complexity behind it. Go encourages you to keep everything in your head, be able to dive in and out of the code with full knowledge of what you're dealing with because the language and runtime is very very simple yet elegant. These are very different approaches, and .net/Java developers always seem to have more problems than usual when breaking out of their shell, so if you keep going at it you'll be able to do it. As a Python programmer, while I was able to work with Go with little study, it really took me a while to "grok" what Go is all about and what simplicity really means.
[**@jamwt**](https://twitter.com/jamwt/) &gt; [2015-08-07 18:55 UTC](https://twitter.com/jamwt/status/629727590782099456) &gt; All the \#golang excitement on hacker news makes me realize I don’t think people realize how deep @Dropbox is in golang. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Pass a reference to the WaitGroup into "printLine" instead of a copy. Right now you're making a copy, and the original is never modified when "wg.Done()" is executed. [See this version of your code](http://play.golang.org/p/lz53ZOmhUs) with this small modification to the function signature and call.
So, in your first example you declare the sync.WaitGroup in main(), but you pass a COPY of the sync.WaitGroup to the printLine() function. Calling wg.Done() in printLine() isn't calling Done() on your original WaitGroup, but instead on a COPY of your WaitGroup. To fix this your printLine() function needs to take a pointer to a sync.WaitGroup and you should pass in &amp;wg to your function. The reason your second example works is because the sync.WaitGroup is declared at the package level, so it can be called from both main() and your printLine() function without any problems. Read up on https://golang.org/doc/faq#pass_by_value for more info.
&gt;Yup, there isn't a good debugger, yet. Two projects to keep your eye on are [Godebug](https://github.com/mailgun/godebug) and [Delve](https://github.com/derekparker/delve). Both take very different approaches to debugging go programs.
Is this an actual thing, because I'm not sure AWS Lambda works the way you think it does, or I'm misunderstanding the project. Or are there some docs out there that talk about how the Lambda infrastructure works? Do they use containers? From my experience, when you upload a node.js or JAR archive to Lambda and run your Lambda function, the first initial run takes a little longer than normal, presumably because they need to copy the resources from S3 and get everything initialised, but invocations after that are very quick assuming you are running the function on a regular basis. 
To be fair, the binary_parameters stuff is only documented in this issue: https://github.com/lib/pq/pull/357
Since you've spent only a couple weeks with it, what you're missing is patterns. Let me give you an example. Let's say you're learning Java, naturally you would find yourself making datatypes, classes, and using inheritance. With Go, you'd find yourself using interfaces in a more functional sense, you will find yourself doing very less inheritance, and more composability. Then, after a few thousand lines of code, you'd find that while you read Java (or Python, Ruby) code like a doubly linked list, you can read Go code as a tree. Separation of concerns is a big Go feature. Concurrency is another, but I believe that's why people come to language in the first place.
Trying to parse practically anything with a regex is almost always a bad idea. Trying to look for content in a dynamically changing blob that doesn't abide by "nice" rules, is always a bad idea. All your assumptions that you use to search will fail at some point, unless the content is well defined. A HTML parser is definitely more "stable". ... But the fact that it's a bad idea shouldn't stop you if you think it is simpler, justified, and can reason about it being "stable" (You're in control of content, or have clear documentation of it). Getting the job done is sometimes more important than doing it in the most correct way.
[There exists an IntelliJ plugin.](https://github.com/go-lang-plugin-org/go-lang-idea-plugin)
Stuff would change, but not in a bad way, and it wouldn't be all that cumbersome. Think about your example of cat. `os.Args` would be a `[][]byte`, and `os.Open` would take a `[]byte`, so taking a filename on the commandline wouldn't be harmed at all. `os.Environ` would also return a `[][]byte`. If you wanted to read a filename from stdin obviously you'd do it as bytes (raw io is already bytes and `bufio` can give you either). So mostly it would be pass straight through and you wouldn't even notice. If you wanted to have a filename as a literal in your program you'd write `os.Open([]byte("hello.txt"))`, or maybe there would be some sugar for it like in Python 3: `os.Open(b"hello.txt")`. As for potential errors, keep in mind that a `string` *already* holds a completely indeterminate encoding, so Go already has to deal with the possibility that it contains bytes that don't constitute a valid filename to the OS. That's nothing new at all.
Thank you all for the feedback, I really appreciate it. I've incorporated the changes mentioned (not committed yet) and think I am starting to think in more of a 'go' way. Although, I have tried declaring variables in C# using ':=' ! I think the hardest bit so far has been trying to stay idiomatic as, coming from a C# background, there are number of differences. 
seriously, webstorm or intellij with the plugin, really helped me out a lot with getting into go
HTML parsing and getting GET requests from a page are things where Go sucks too.
It's not laziness... It's just what it's become. I usually call it Go when speaking about it but almost always refer to it as Golang when typing it. Don't really understand your gripe with it. Hacklang uses the same thing because its such a common term.
Do you also refer to any C code you wrote as "that C(Programming Language) code" or "that CLang code" or "that C_lang code" to not be lazy and avoid confusion since "C" is hard to search for and could mean something else (Carbon?)? No, it's C code. Just as you programming in Go, you write Go code, and you refer to it as Go code. There is no such language as golang. There is no such thing as golang code. Of course, for a web url, a sub-redit, a twitter hashtag (like here), #golang makes sense (as does r/C_Programming vs /r/c or https://en.wikipedia.org/wiki/C_%28programming_language%29 vs https://en.wikipedia.org/wiki/C). However it's still about Go and not golang which shouldn't be *incorrectly* used in titles/text etc. Saying "golang" instead of "Go" isn't not being lazy, it's being ignorant.
+1 for GoSublime since I read you're not versed in vim... Leave that for another day.
Ouch. Postgres does NOT use the question mark for parameter placeholders, so none of the examples here would actually work. Kind of a big thing to get wrong :-(
Don't call yet another k-v store a "filesystem", it is very misleading
That makes a lot of sense now. Thanks for the link to the pass by value, I missed that!
More like key-blob
I'm pretty sure it's a requirement for Google projects now... Like "Inbox" by GMail...
Would that supposed to get you out of it? In case you haven't noticed, you "question" has been downvoted to the abyss --far from magic and unicorns you hoped for.
Welcome to Go. I don't know Python as well as I should, but I'll try to answer your questions. Hopefully someone will correct what I inevitably get wrong. &gt; Is there a good introspection feature (like dir() in python)? I do not want something like tab complete in my editor, I just want a way to see all the features an object from time to time. fmt.Println an object seems to give the values but not the names that go with them, maybe I am missing something. You could use [`fmt.Printf("%#v")`](http://play.golang.org/p/FP0XwPQ4Bl), but I think that `godoc` can do what you want. Go 1.5 will introduce `go doc`, which is more tailored for command-line use. For example, if you want to see all the exported fields and methods `json.Encoder`, you could just run `go doc encoding/json.encoder`, and it would list them. &gt; How are you supposed to find what file functions are within? I was looking at a few larger projects and it felt daunting to search through all the files in the folder for any given package to find the right file that housed the function that was being called. Is it just based on naming conventions or is there something that points to the specific file (kind of like in python)? This is a bit of an issue which has been complained about before, but the simple syntax in Go makes it pretty easy to find specific things most of the time using something like `grep`. For example, let's say you want to find which file in `encoding/json` defines the `Encoder` type. You could use `grep 'type Encoder' *.go`. &gt; What are the "best" handful of blogs/posts/vids for learning, using, and best practices for go? I will start checking out the "Resources for new Go Programmers" on the sidebar. One that I rather enjoy recommending, if only for the sole reason that Go is pretty much the only language you can do this with, is [the spec](http://www.golang.org/ref/spec). You can literally read through the entire thing in about an hour. &gt; Is there a package manager that lets you pull down projects for snap-able pieces (like pip)? I'm not exactly sure how `pip` works, but you could try [`gb`](http://getgb.io/)Go 1.5 will be adding experimental support for vendoring, so hopefully Go 1.6 will have a more full-fledged system available. &gt; Is there a multi environment tool that lets you have different versions of go libraries (like virtualenv)? Provided I am understanding your question correctly, this isn't really necessary, since Go binaries are statically linked. The aforementioned vendoring support should make it possible to determine versions more easily at compile-time as well. &gt; Is the convention of returning an error value in (almost) every function and then checking if there was an error in the calling function standard practice? I believe I understand that there is no try/except in go and only to use panic when you really want things to bubble up. Pretty much. A function shouldn't have an `error` return if it's not going to cause an error, though. `panic()` and `recover()` usage is pretty rare, so far as I have seen. I hope that helps, and I hope someone can fill in what I missed.
&gt; I just tried the fmt.Printf("%#v", obj), I think it does the same thing and does not show the names of the fields only what is in the fields if that makes sense. Maybe I am doing something wrong. Did you take a look at the link? It does show field names. One thing to keep in mind, though, is that fields in a struct and methods on a type are completely, vastly different things in Go. Fields are what you would expect them to be from Python, but methods are more like functions with some syntactical sugar. They can be defined on any type in the same package that that type is declared, and types do not need to be structs.
Thanks! I may check out the vim-go plugin. Seems like that is the way people are pointing. Can't believe I missed "go get". It's right there when you type go.
a more updated doc here: http://docs.sublimetext.info/en/latest/extensibility/snippets.html
Could I ask what the possible use cases for this are? Also, you shouldn't need an init function. All 3 of those statements could set inside the variable declaration above. (Although you'd need to change log.SetFlags to logger = log.New(os.Stderr, "", flags.) Additionally, I'm curious why you use atomic.LoadUint32 here: https://github.com/zxjcarrot/gochan/blob/master/gochan.go#L75 And the if/else on the following lines could just be an if statement because the break will prevent the next line from running. :-) Also, why do you have maps of all the channels? 
I haven't used this implementation, but I've created something similar for dispatching long-running jobs to a compute cloud where you need to monitor stdout/stderr and also cancel if a context is closed.
One thing: Please read up on [how to document go code](http://blog.golang.org/godoc-documenting-go-code). In particular, godoc comments aren't javadoc comments. Don't do the @parameter-thing.
GOROOT really should not be set unless you have a good reason. Also, there's no advantage to just getting the archives from the website or cloning go itself directly, no? Or did I got something wrong?
Go's goroutines are the crown jewel of the language. It is well executed and fits in quite well with the language. I didn't realize that they had gone as far as implementing a separate network scheduler for go routines. That is pretty impressive stuff. Also, I should add that this article is surprisingly accurate. Something that is increasingly rare when talking about performance.
I mentioned Notepad++ because it's just a text editor. It doesn't have intellisense it just highlights code and then provides some more code related features. Sublime is a much better choice but is very similar. Sublime offers plugins that make the editor more powerful. Atom is an open source clone (not 100% the same) of sublime. But the key point is they are all just text editors. Not IDEs.
This is similar to https://github.com/travis-ci/gimme - which is what Travis CI use to install Go during builds. 
noted, thanks.
My worst favorite question from non-gophers is "does go use asynchronous io?". Because the answer is "No!". But also "sort of". They sort of side-stepped the problem by letting goroutines "block" conceptually to the programmer, but also removed the performance hit by letting the runtime take care of it for you. Sometimes that can all be hard to explain to a node or .net dev who think about things a bit differently in terms of threads and asynchrony. This helps a lot. 
It's cool and all, but you better add a section to your README about why anyone should use this over `map[string]interface{}`. Because this will most probably be the first question people have in their mind.
It would be helpful if you included a method to marshal your objects/arrays. Otherwise it really doesn't have that much to do with JSON.
Thanks for the info, I'm going to give it a shot. 
Nice, I love seeing go projects around these types of applications. Not sure if you saw my project https://github.com/mephux/envdb but it's similar. I'm going to be working on a web service for people to submit/import saved queries - would be nice to collab if that sounds interesting.
Accurate to the point of even clarifying in the foot notes that CMOS hardware also drains power when charging capacitance. This is a very well written and thought out post!
First of all, it is terrible from a security perspective. `/usr/local` is a system directory that should only be writable with an operator account. If you change the owner, you would leave yourself open to having anything you run change your system. You might also (and most likely will) have other software installed in `/usr/local` that will not work with the owner change. The directory is a base directory for keeping locally installed program (`/usr/local/bin`), their configuration (`/usr/local/etc`) and their related data files (`/usr/local/lib`). When working there you should attain an operator account (`sudo` or `su`) and do your work. This is also a good habit to learn. If you need to install software without an operator account, you would normally put it inside a sub-directory in your `$HOME` (e.g. in `~/bin`) and add the directory to your `$PATH`.
There's mention of open source in the article, but it looks like MQTTParty itself is not open source?
I consider such a program as unethical. This is ultimately a prisoners dilemma: Everyone has the option of writing a bot (defection) or to only submit one E-Mail-Address (cooperation). If everyone cooperates, everyone has an equal and fair chance of getting an invite. If everyone writes a bot, it's the same, *but* OnePlus' servers will be overloaded, sluggish and the system will break. If *some* people write bots, they effectively cheat everyone out of their rightfull chance to an invite. So, by using this bot, you initiated defection. Yes, "everyone defects" is a nash equilibrium. But that doesn't make it *ethical*. We should strive for pareto-optimal solutions (which is, everyone cooperates).
Seems to me the best solution is to use Option 1, uninitialized structs, and document where the default values may not be optimal, so users know they'll probably want to set those fields, plus provide Option 2, initialized structs, in cases where the default values for one or more of a struct's fields are never or almost never what a user would want, and document the existence of the constructor and explain why it might be easier to use it. The method signature doesn't change — both options 1 &amp; 2 take the same args struct.
Functional options: http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis
so you don't have to throw away the error, define var err Error on the line prior, and then you can do db, err = gorm....
Something I use is to print the object with the %#v format, which dumps the details. In your program I did: fmt.Printf("\n\n%#v\n\n", db) and got: gorm.DB{Value:interface {}(nil), Error:error(nil), RowsAffected:0, callback:(*gorm.callback)(nil), db:gorm.sqlCommon(nil), parent:(*gorm.DB)(nil), search:(*gorm.search)(nil), logMode:0, logger:gorm.logger(nil), dialect:gorm.Dialect(nil), singularTable:false, source:"", values:map[string]interface {}(nil), joinTableHandlers:map[string]gorm.JoinTableHandler(nil)} I find it useful sometimes to see the details of the current value.
Oh, that's perfect!
That's what I ended up doing, everything's cool now. I feel like I should be old enough to not be hassled by a scoping issue, but that's life I guess...
Floats have errors when you perform operations on them. They can add up, and with money, being consistently off by a few fractions of a cent causes problems in audits. Usually a custom type is recommended, or a "lossless" numeric type. Go's only such types are the int types. You can use floats for money as long as you're careful about your rounding and it might depend on your use case. Rounding rules vary between financial institutions, etc.
You could switch your project to C++. The expressive type system there allows people to develop named parameters, even though they are not part of the core language. http://www.boost.org/doc/libs/1_58_0/libs/parameter/doc/html/index.html This is just another example (cf generics) of how Go can be limiting. 
Thank you, but I have other plotting options for my C++ projects.
&gt; including gc Ah yeah. I should have thought about that a bit harder.
This may be a dumb question, but when would you want to prefer a non pointer receiver? Is there a benefit outside of when you need a shallow copy?
A non pointer receiver is much easier on the compiler as it doesn't require escape analysis to prove that the object doesn't escape; thus, it might increase the likeness that objects of that struct are allocated onto the stacks.
Which is why people shouldn't be so quick to say "pointers are always faster" when it comes to Go (not that anyone here has said that, just in general). Its an example of trying to outsmart the compiler and a pre-mature optimization, both of which are big no-no's. 
Doesn't really seem all that useful. On OSX, 1.4.2 is available on [brew](https://github.com/Homebrew/homebrew/blob/master/Library/Formula/go.rb) and it would definitely be better to stick with brew for consistent updates. Many Linux distros have the most recent version in their central repositories. Debian doesn't, but you can add `ppa:gophers/go` and install from there, which is far superior than a bootstrapped user script like this because it ties in with apt. And it doesn't support Windows. So that's great. Nice if you demand compiling from source I suppose.
Poor Guido :( Is worth noting that they are working on a [high performance Python interpreter](https://github.com/dropbox/pyston), so obviously they still use lots of Python and plan to. 
&gt; I am the only person using my machine That doesn't stop malicious processes from hijacking binaries that you might run with `sudo` or from corrupting things. If it works for you though, then it works for you.
Would love to see some formatting benchmarks ...
I've build such a pkg for money calculations based on int64 type. Float64 is totally unreliable, a PITA. Including Marshaller and DB interfaces; Swedish rounding and i18n currency/number formatters based on http://unicode.org/reports/tr35/ But the pkg needs some external reviews before I start communicating about it. Edit: Also the overall API will change ...
Look into channels. You can use them to pass data between goroutines. For example, you can have those goroutines stream strings to the main goroutines, and so stuff with them there.
No, it is not possible *in general*. You would need to build your checkpoint-facilities yourself and customarily for the state your goroutine could hold. http://play.golang.org/p/BZ53SJiiM5 gives a rough example. But I don't know if this is really as usefull as you imagine it to be. [edit] http://play.golang.org/p/8rzgXRS_ek also restores
@TheMerovius That looks similar to panic(), recover() mechanism. And that would require users manually decide what to save. @garoththorp In this scenario users have to periodically emit corresponded state/ information so that later on it can be restored accordingly. Thanks for all your help. It's very useful, I appreciate it! 
There is a "reply" button under each post. Also, highlighting people is done using /u/username. It'll turn into a link and they will be notified. As for the answer, there is no real use for saving an entire goroutine. You can just store the data it handles and return, then spin up another goroutine with that data when you need it again. Goroutines are not expensive, so you'll incur no real overhead from doing that. I guess the important question is, **what is it that you want to accomplish?**
&gt; That doesn't stop malicious processes from hijacking binaries that you might run with sudo... Which is why I don't use `sudo`. I only do when setting up a new computer to own `/usr/local` and change my shell to fish, etc. &gt; If it works for you though, then it works for you. So far so good, but you said it was terrible advice to own `/usr/local`, but I still can't see why. If you mean that piping a script into your shell with `sudo` is terrible advice, then, yes I can agree with that. In this case I wrote the script, so I know it's not malicious, but I would be wary if I was someone else, still I posted the script here hoping it would be useful to someone someday :)
That just sounds like time sharing. It sounds like you want an operating system instead of a programming language. Allowing users to supply their own source code is not only dangerous, it'd also be pretty damn hard considering Go is compiled and statically linked.
&gt; you said it was terrible advice to own /usr/local, but I still can't see why. I didn't say that, but I can see where /u/chrj is coming from.
Note that this port is not ready yet (according to Nigel Tao, the author: https://groups.google.com/d/msg/golang-nuts/XtsP-DW0oqc/iYXzXZy00R0J )
To really drive the point home about the differences, I suggest making a one-character change to the example: [Remove the &amp; from the Mutatable in `main`](http://play.golang.org/p/4guPgi4mFe). Or perhaps show both. Whether the variable is a pointer and whether the method is a pointer method are independent from each other; pointer methods can be used on non-pointers and non-pointer methods can be used on pointers.
 type Computation interface { Begin() Suspend() interface{} // this is really a class method: Resume(interface{}) Computation } This is about the best you can do. The user can supply an object that conforms to this interface. It is the user's responsibility to arrange for checking for the Suspend call every so often. It is the user's responsibility to ensure that the returned value from Suspend is indeed sufficient to resume the calculation. You need to specify how the value coming from Suspend will be serialized or stored (i.e., "must be round-trippable via encoding/json" or something). A distinguished value should probably be emitted from Suspend if the Computation is complete. (Adding a `Name() string` to the interface can be helpful as you can then use that to register the values.) `Resume` is actually a class method; as long as you have an object of the correct type, even the zero-value, calling Resume yields a new Computation that you can then call Begin on, and suspend later as needed. If you need some more solid notification of completion you may want to make `Begin(func())`, where you pass in a function to be called upon completion that does whatever you need it to do. This is all you can do. There's no mechanism for suspending and moving goroutines themselves. There's no mechanism for sending interrupts to a goroutine... it has to be actively listening. The type system is not capable of enforcing any of the constraints on the user's code that I mentioned; that would take Haskell's type system at a rough minimum. Oh, and you'll have to actually compile and/or recompile an executable for each new program. This could be anything from "really annoying" to "total stopper" depending on your situation. You may want to consider writing or using an interpreter for your long-running task, but if it's a long-running task that is also performance sensitive this won't help the performance any. If you can give more details about the nature of the long-running tasks we may be able to advise on a better language, or a better approach. Please also specify whether you trust your users, and think _hard_ about that statement before you're too quick on the draw.
&gt; That looks similar to panic(), recover() mechanism. I don't know, what you mean by that. &gt; And that would require users manually decide what to save. Yes, that's exactly what I meant, when I said, there is no general way and that you need to build that customarily for the state your goroutine could hold. Doing something like this (in general) would fundamentally undermine memory safety. Ain't going to happen ever and is a very bad idea from so many points of views.
Thanks for your question. I got something out of it too.
I got a tagline for you: #Bro ***Helping bros become brogrammers*** Edit: Apparently people don't like this humor. :(
I am unsure whether this is a good idea or not, but *if* you really want to do that, here's (roughly) what you *should* do: * Have them write their program as a main-package * Check for inclusion of unsafe, compile the main-package with go-nacl * Run that program in a separate process [edit] with seccomp enabled, I think go-nacl implies that, but am unsure [/edit] * To suspend, SIGSTOP, dump it's core, safe it to disk/transfer it * To resume, restore it's core, SIGCONT it. * All the while, make sure that you *never* restore a process image to a different binary it was created from (so, transfer the compiled binary with the core) This is more or less, what the playground is doing, or the Google App Engine (probably). It is an *absolutely crazy* idea to have users function run in a separate goroutine in the same memory space as a) the supervisor and b) other users code. *batshit, absolutely unforgivable crazy* (I really want this message to come across, so I don't want to understate it).
Mostly rounding errors, standard accounting practices recommends four digit precision, some currencies have 3 digit precision and third party services vary on this regard. For example IIRC PayPal only supports 2 digit precision.
Bro, I heard that you like test so I made a helper app for that has no tests
Do people consider mixed ptr and non-ptr methods bad style? http://golang.org/doc/faq#methods_on_values_or_pointers "Next is consistency. If some of the methods of the type must have pointer receivers, the rest should too, so the method set is consistent regardless of how the type is used. See the section on method sets for details." I understand that a mixed approach leaves the non-ptr receiver with the "wrong" method set, but isn't there a benefit - even just as documentation - in using value receiver for non-mutating methods?
This is called "Irony"
I originally got the idea from there, I literally cloned it in go but it wouldn't work anymore. I had to make it spoof a browser, it sends the exact GET request of chrome bit by bit, then the dots were now every 2 characters and finally my version is self learning which is cool. https://medium.com/@JakeCooper/so-nice-i-did-it-twice-hacking-the-oneplus-reservation-system-again-2e8226c45f9a - thats the one that I got the idea from.
I write testing... :)
I write testing... :)
Mind sharing the source (even if it isn't ready yet) so I can take a look at it? I'm very interested in this.
Be glad Github is still working on that code of conduct... "bro" is a term that promotes rape culture and the patriarchy! But seriously, don't be surprised if some day someone opens an issue demanding that you change the name because it triggers them.
Is this the current best interface? aren't there two others?
What is wrong with owning /usr/local? 
I was using levigo for a project, but will take a look into this
&gt; First of all, it's still sort of a lie, within a non-pointer receiver the copy is in fact still fully mutable, with all that implies. Yes, but isn't this a non-feature? Is there any value at all to a method which modifies a soon-to-be-discarded temp copy? Personally I'd love this to be a compilation error.
&gt; It may not be discarded. But only if the address is returned or stashed somewhere? That's kind of an odd setup for a method I think (can always be replaced with something else? e.g. a method on the object containing the mutated obj?) Otherwise it's: foo (o Obj) variant() *Obj { o.property = frob() retuen &amp;o } which is unreasonable since if it's OK to pass an Obj *in* by value then it's OK to pass the mutated obj out by value too? &gt; On a much more mundane level, making that change now would be a backwards-compatibility-breaking change. (Which is a descriptive argument, not a normative argument, but worth pointing out.) I can wait for go 2.0 if need be :-) My main problem is that it's occasionally easy to operate on a temp copy of an object. Worst offender is "for o := range objs { o.frob() }" but there are others.
Actually, you could very well spawn a goroutine for every little object you wanted to render. Go is optimized for use with tens of thousands of goroutines in mind. The possibilities that exist for making the jump from traditionally single-threaded-heavy games to ones that really can use up all of the raw power of the CPU, which explicit APIs like Vulkan will enable. Vulkan aims at being CPU bottlenecked, which is exactly where we want to be. As well, GC improvements in the Go runtime are only getting more and more fruitful. But one could always turn it off entirely. At the same time, Go now supports being linked to by C applications. This could have wide impacts in Go's application to gaming. Even if it's primary use is for core game logic and I/O(Which Go excels at)..