I am not really sure what are you asking or what did you find offensive in that comment. I can do my best to explain if you can let me know.
Nice post, but I have a few comments: if err := godotenv.Load(); err != nil { log.Print("No .env file found") } It seems `err` is not used, can we be sure that a non `nil` value means the .env file doesn't exist? Yes [apparently](https://github.com/joho/godotenv/blob/master/godotenv.go#L203) this is the case currently. But this is generally not a great idea, I would suggest using `err.Error()` here instead &amp;#x200B; &gt;There are several libraries out there that claim to offer a configuration ‚Äúsolution‚Äù for your Go application. But is it really a solution when it‚Äôs just as easy to make one yourself? For education purposes, please re-implement any functionality from any library you want to explore, understand and/or improve. However in a professional setting, you would pick a library that already [exists](https://github.com/Netflix/go-env) over reimplementing it any day of the week. There are rare cases (exceptions) when existing libraries don't do the job, but this is maybe 1% of the cases. tl;dr please don't advocate reinventing the wheel
Sorry for the confusion, I wasn't referring to you. I was referring to a project maintainer who would have an issue with your helpful PR. The fact you left this comment praising the repo shows there are other projects in need of better management.
Do or do not, There is no try. Oh wait, there is no do either!
This is an excellent answer. My tl;dr: The signature is `func Slice(slice interface{}, less func(i, j int) bool)`. Second argument `less` is a function which is used as callback. This function returns whether item with index `i` should be sorted before item with index `j`.
Oh. I see what you mean... Well, I guess they won‚Äôt be around for long or we‚Äôll never know because people won‚Äôt use them. What you asked also reminded me the left pad disaster happened few years ago. People were using ‚Äúleftpad‚Äù library to pad their strings, including it to their dependencies while they can add few lines of code as a helper function, yet they don‚Äôt realise the way until the author removes his package from the npm repo and break half of the node/js repos. Guess the solution is not feeding the toxic ones or forking them to create better managed versions and let the community know that the better solution exist.
Thanks for your reply. I've done a few sorting algorithms in my time, and they've all been quite explicit on indexes of what is compared to what. And I agree it make it easy - just perhaps it should be hidden further so that details of the magic trick are hidden from us. Like for instance: ips = sort.Slice.ByField([ips.Date](https://ips.Date)).Ascending Would make it very readable. And the magic hidden from view :)
I want both. I will always use \`xerrors.Errorf\` in normal code, and prefer \`try\` in unit tests. &amp;#x200B; Have you ever got tired of writing new unit-test because you have to write so much boilerplate code with lots of \`if err != nil\` statements, which you know don't get executed or will likely caught by other tests anyway? If yes, then \`try\` will help you in that case.
I think we've all encountered a project where even the simplest PR sits for months before getting attention (if ever).
I agree with you. But what's the type of ips.Date? Given two instances of Date, how does the library know the ascending order of that type? What about custom types created by us? ü§î There should be at least an interface, like Comparable, so the algorithm could know how to sort any given type. But then the "Less" function would still be implemented because of the Comparator interface anyway, only this time inside the class-to-be-sorted... There's no generic way of comparing *every* possible type, we need to hint the algorithm somehow. But I agree that it could be a little easier with Go.
Knock on wood!
Well, of course, some of us have a lot of sympathy with that view. I'm attrected to go precisely because it's opinionated and no-one has yet managed to make it a clone of all those other modern languages.
Well in this instance, [ips.Date](https://ips.Date) is a time type - but that is not important insofar as what I'd like to have is a sorting method that recognize type, and sort up or down according to what make sense for that type. This may be difficult - hell, I am sure it is - but it would be nice.
Why boilerplate and copy-paste? If you must have stack traces everywhere, you can Try: - https://godoc.org/github.com/pkg/errors#StackTrace - https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package Except CounterArgument: One can argue that stack-traces *ought* to be an easily-accessible part of the errors package, but OTOH there are many valid arguments *against* allowing developers to surface them easily ‚Äì in other words, one is making a trade-off either way. In making these kinds of subjective/trade-off decisions regarding APIs, it's important to *consistently* fall back on your principles. Go's principle is minimalism, and it has consistently fallen back on this. Personally, I'm happy with the idiom (exemplified by the standard library) of defining and returning your own exported error types, and invoking fancy code to get stack traces where a caller believes them to be absolutely necessary.
Looks like you're [getting around to it first](https://github.com/pion/webrtc/blob/master/examples/sfu-minimal/README.md).
errors.Wrapf(err, "something") For example is pretty boilerplate-y to me
And together with Athens - [https://docs.gomods.io/](https://docs.gomods.io/) it's pretty nice as you can just have it saved locally in your own cache in case something goes wrong with github or whatnot.
Come on, just give it a _try_
I would recommend running something like Athens, [https://docs.gomods.io/](https://docs.gomods.io/) . That way you have it cached locally. And, it goes so much quicker if you ever need to "get" it again.
An easier solution for dev is to `cat` your `.env` file; which you can do without an extra code block to load them in: eg `env $(cat .env) go run main.go` (syntax may not be exactly correct, but you get the idea)
Golang needs fixing in two main issues: 1. Error values, where the "adding context" part comes. 2. Error handling, since currently, errors are handled using `if err != nil {...}` boilerplate code. try is introduced to fix the second issue, whereas xerrors is package created to solve issue 1. In fact, you can see the design drafts for these two issues separately [here](https://go.googlesource.com/proposal/+/master/design/go2draft.md), based on which both try and xerrors are created. So try and xerrors are solving different problems here. Once both are implemented, the context adding can also be done with "try": type ConnectionError struct { err error hostport string } func (c ConnectionError) Unwrap() error { return c.err } func (c ConnectionError) Error() string { return "Error while connecting to: " + hostport } func Connect(host, port string) (c net.Conn, err error) { defer func(){ if err != nil { err = ConnectionError{err, host+":"+port} } }() c = try(net.Dial("tcp", host+":"+port)) } Now, when a function Connect is called by some other function, it should wrap the ConnectionError in the same way ConnectionError wraps the underlying error and exposing it using Unwrap function. So finally, you can check if something is wrong due to ConnectionError like: err := CallSomethingThatCallsConnect() if xerrors.Is(err, ConnectionError{}) { if xerrors.Is(err, InternetNotAvailable{}) { //Maybe? //handle the error } } This way try and xerrors can work together. Note that try is only a syntactic sugar. This is what I have understood from the documents. Please correct me if I am wrong.
So not [this](https://godoc.org/github.com/pkg/errors#WithStack)? I'm not familiar with xerrors but: err := errors.New(theErr) if trace { err = errors.WithStack(err) } return err Of course not literally this, but a pattern similar to a error wrapper in your code isn't unreasonable, IMO.
The Go tool chain can work with most VCS (version control systems). A module is just a special tagged repository with a `go.mod` file. The url links to the repository. This must be a vcs repository even if it does not contain any Go files. The wiki page covers more information: https://github.com/golang/go/wiki/Modules
Neat! I implemented a small simplification to the Go version that makes it about 2x faster on a quick test of two 8k images: https://github.com/nicolashahn/diffimg-go/pull/2 I noticed that the Go version was doing very different work from the other versions, in that it was nesting iterations through x, y, and color channels (and converting each x,y coord into a Color along the way). The comparison that would be closer to apples-to-apples is if each program did the same work as the Rust version, which just loops through an array of pixels. It's just a quick hack to see, but I'd be interested to know if that simplification changes any of the results from your test against images of various sizes, with known correct values.
Right click on any .go file then properties -&gt; in the "open with" section, click on Change and then set it to your IDE/Text editor .exe file or the go.exe if you want
The lack of context really is an issue especially with these things being popular as long running web services.
No other requirements? Your question is a bit too vague for a decent answer.
Only 270 commits, too. Projects that you can describe as "basically done" are nice.
Don't we have the ability to do that right now? I usually just write `return nil, errors.New(fmt.Sprintf("error doing foo: %s", err.Message()))`. For example, it could be that a connection timed out while I was saving a user in a database. My returned error includes the low level network error and adds that it occurred while my high level code was trying to save the user.
I believe they are looking for you to create a very basic server in Go, but one that demonstrates that you understand best practices. Your server should behave well in a kubernetes-like environment, which means it should do things like listening for os signals to know when to gracefully shut down, log useful things using middleware, expose health and readiness endpoints among other things. I would avoid 3rd party libs...I would rather you demonstrate solid knowledge of the std lib. This is a good guide I found useful when I was starting out. It‚Äôs a little old but should still be fairly applicable: https://blog.gopheracademy.com/advent-2017/kubernetes-ready-service/
Thanks your advice. Unit tests will be added gradually. But for the security audit, I'm not familiar with it and don't know how to do it.
They didn't implement it in 1.13, it is being implemented in the 1.14 branch.
are you sure you're actually passing a \`\[\]Resource\` to your function and not, for example, a \`\*\[\]Resource\` or even a \`\[\]\*Resource\`? &amp;#x200B; what you're doing seems reasonable. try printing the type of the value in the \`default\` section of the type switch like this: &amp;#x200B; \`\`\` package main &amp;#x200B; import "log" &amp;#x200B; type X struct { Name string Age int } &amp;#x200B; func Parse(x interface{}) { switch v := x.(type) { case X: log.Printf("we received a value of type %T", v) case \[\]X: log.Printf("we received a slice of type %T", v) default: log.Printf("we received an unexpected type %T", v) } &amp;#x200B; } &amp;#x200B; func main() { Parse(X{Name: "x", Age: 10}) Parse(\[\]X{{Name: "x", Age: 10}}) Parse(1) } \`\`\`
I think people misunderstood your comment here - this is definitely a common problem in open source, and I've found Go project maintainers seem to be quite pragmatic and good at avoiding this sort of stuff. I don't think the language is attractive to bikeshedders.
I notice some new branding and Logo for Go and it is looking nice.
Follow up question, maybe you will have an answer: what about just handling the authentication to the database of database users? I intend to have a few different users/roles for different access privileges. Export environment variables for each one? While it seems sketchy I considered just having encrypted files which the server could just get a password over commandline to decrypt and use as a config file for DB credentials on starting the server.
Yea, I messed that up
You're talking about how to store login details that are between the app and the DB? You have multiple options all with their ups and downs. 1. Unencrypted file. This is the usual route most go. Store the details in a config file, pull them. Easy peezy. Obviously a problem if someone can read those files (such as through a file inclusion exploit) 2. Environment variables. Almost the same as above except now you're reading from a server variable. Upsides is it's not vulnerable to just a file inclusion. Downsides would be deployment as now each server needs to have them set. 3. Hashicorp Vault. This is a new one, but probably the best. Vault is a program which is meant to store these kinds of things. They're stored in an encrypted format and is accessible via an API gateway which can have its own auth requirements. Every request is logged, the user can be setup to be auto-deleting and more. The downside is this is a lot more complicated to setup but is the most secure.
&gt;You're talking about how to store login details that are between the app and the DB? Yes, rather than just hardcoding credentials to connect to DB. What about having an encrypted config file that is decrypted and pulled from when running the server? I made a separate post for the question, by the way.
You could do that, but it's a worse version of using Vault. How is the encrypted file decrypted? If you store the key in the code then you're at the same issue of just storing it plain text. If you decrypt it when the server boots then it's plaintext or environment variables. Vault is the way to go if you want secure storage of auth credentials.
Go has no contravariance or covariance. (If you don't know what those are, those are the Google terms you're looking for. There's a lot of good explanations on the net that I can't do better than here. Plus to be honest I can never keep track of which is which so I'd have to check anyhow; you might as well cut straight to the sources.) A type assertion can only match the exact type the underlying variable has, so if you have a variable x that is of type \[\]Account, and an Account is a Resource, you can not convert that to a \[\]Resource with anything less than creating a new \[\]Resource and copying every entry from one slice to the other. That said, the name JsonEncoder implies this is headed for encoding/json anyhow; there's shouldn't be any need to do any such translation? It may help if you can show why you want to do this in the first place; encoding/json will probably just do what you want with either type of value.
If the goal is to just to ‚Äúpass it along‚Äù you always have the option of not storing the returned value into a variable. I don‚Äôt see how a try block makes things that much better for this use case. Basically you can say ‚Äúexecute these few statements and if any of them fail, fall back on these statements‚Äù. It may not be as direct in go but you can still do it no problem.
i must be a lucky person then because i've been using NPM since 2013 and never had a single problem, with absurdly small repository sizes üòé
&gt; If that Goes down, nothing will work anymore That's like "if Google goes down i will lose all the work of my life", you know that's not gonna happen. NPM hasn't gone down in its 7-8 years of existence, and only once a package got removed and it's not possible anymore, so what's the excuse not to have something decent in Go?
&gt;How is the encrypted file decrypted? Like I said, when you start the server it would just prompt for a password. So you just put it in over command line, then it would pull the config
&gt; If I rename a rust crate, you'll have to change your imports too, don't you? You can't rename a package in NPM and i'm pretty sure you can't in Cargo either. What you can do in NPM is make a new package with whatever you want in it, and any prior version will always be available to download.
One of the best packages out there. I don‚Äôt even know how to do a router and handler the traditional way now.
Use fmt.Errorf, save yourself a step.
Too vague. A microservice could be the checkout of a e-commerce which need a frontend or the tax calculation which doesn't need any.
I'm with you on xerrors, but they don't solve the issue of error spaghetti. Only check and handle (almost but not quite try) can do that. Go needs check and handle, *and* xerrors to determine context where needed.
I would. This GopherCon 2015 talk provides some great arguments for why: [Audrey Lim - How a complete beginner learned Go as her first backend language in 5 weeks](https://www.youtube.com/watch?v=fZh8uCInEfw)
very very stable and beautiful package
My worry is that people will just opt for try on everything. Much like we see in java or other try/catch languages where nobody does any introspection on the error and just uses a catch all. That‚Äôs what the try proposal is, just a catch all. And we know that‚Äôs poor programming practice. I‚Äôm ok with a bit of spaghetti to enforce code clarity.
Check-handle isn't the same as try. You have to make it explicit on each function call that it should participate in the handle, and you can still handle errors individually underneath the handle by just not using check.
Why are Is, As, Unwrap listed but changes to Errorf not?
&gt; "If Error": { "prefix": "e", "body": [ "if err != nil {", " $0", "}" ] }, It took me two seconds to realize this is the proprietary syntax to create a ‚ÄúCode Snippet‚Äù in Visual Studio Code [1]. Since no every Go programmer uses Visual Studio Code, you could have said something like this: &gt; _‚ÄúMaybe **a code snippet** will help the try() people out [‚Ä¶]‚Äù_ [1] https://code.visualstudio.com/docs/editor/userdefinedsnippets
&gt; _I notice some new branding and Logo for Go and it is looking nice._ I think you are at least one year late to the party. The Go brand was announced on **April 26, 2018** [1]. [1] https://blog.golang.org/go-brand
I'm not overly keen on this try proposal but just saying, it'd make my life much better if they added java lambda syntax to go. First class functions are great in Go but the lack of shorthand syntax makes functional programming hideous in Go. stream.Filter(func(some X) bool { return some.Y &gt; 3 })
Hello, we do not use any framework for that, it is a quite small project.
I'm usually a lurker, but I want to add my endorsement of this message. We only use Go for a couple of small services at work so I'm not in it all the time, but I've never had a serious problem with `if err != nil`.
I do view gorilla as a stable part of the ecosystem at this point. They provide the building blocks that all my web based go works on. It may not be as all-in-one as other solutions, but if you utilize everything together it is very powerful. And the source is easy enough to interpret to create custom even more powerful solutions.
Gorilla mux was the first go package I added to my first go project and it's going to be in every one from now on
Oh really? Do you see that on main [golang.org](https://golang.org) site?
exactly my experience unfortunately you only understand this when you have had experience with clever code before...
My favorite work example is a class that handles phone numbers. Seriously, it's 4 strings of data. The class should be 8 lines long. Our phone number class is thousands of lines long, including several inner-class builders, most of which are incomplete ... because phone type wasn't in the original spec, even though the system we're integrating with had it 10 years ago. Did we need a separate 'builder' for international, local, etc ... phone numbers? Did we need a builder for any of them? What about the classes to verify the phone number? Now that they're so complex, we'll need a test class to test all of them. Trying to follow every new trend in Java turned a 4-variable class into thousands and thousands of lines of incomprehensible, useless, bug riddled code that got dropped in my lap. These same programmers are excited about go because they don't feel tied to all these best practices they mindlessly followed to create hulking monstrosities. Phones can be 4 strings again! In a big way, I want to say 'You never needed to make everything so terrible to start with!', but whatever. I'm just glad things are shifting in the right direction. KISS may have been the first, best, practice that we all somehow forgot while trying to outsmart one another. I just hope when someone delivers me an API it doesn't require a client, or if there is a client, it's simple, straight forward, and actually works. No more 1,000 lines of code to figure out how to set the phone number through a special client because the API is so poorly written it NEEDS a client in the first place. Ugh.
Since you are inside GOPATH, and GO111MODULE=auto, you are not using module, so the hep package you import need to clone it in specific path " GOPATH/src/go-hep.org/x/hep". &amp;#x200B; If you try using module now, it still suggest to using \`go get [go-hep.org/x/hep\`](https://go-hep.org/x/hep`), otherwise, you need to find the modules cache location to git clone ( I have not try this way though ).
All you really need is the [S and K combinators](https://en.wikipedia.org/wiki/Combinatory_logic), everything else is non-orthogonal and adding something to the language that could be expressed more fundamentally.
one of my first and only more 'major' contributions to open source was for a Go library and the owner of the project helped me greatly in improving my PR but also learning a little more about Go, sample size of one and all but, Go devs definitely seem very helpful and pragmatic
The question mirrors the brief that I was given. It purely states two endpoints and what JSON data those two endpoints should retrieve. It is obviously a bit more verbose than that but I think the brief is purposefully vague. This is why I was asking more so from a best practices stand point more so from what the brief has asked of me, seeing as the brief said very little whatsoever.
Agreed, but it mirrors the brief. The only useful information taken from the brief is "create a microservice with two endpoints, that retrieves information from this dataset, here's the information it should retrieve" etc. Nothing else is explicitly stated. Hence why I was asking from a best practices stand point
Thank you! This is what I was looking for really. So a basic server *is* a microservice? I think I'm getting my head tangled around the microservice word, when I can create a simple server pretty easily.
They don‚Äôt want a a frontend, they want a server. It should have a route that returns JSON. You can use curl to test it works. I‚Äôd focus on the server and README rather than deploying it or dockerizing it although including a Dockerfile would be a nice touch. Use the standard library, not a framework. Start with a simple hello world server, then look into JSON.Marshall(), finally add some logging and finish up with good documentation that shows how to run the server and request the JSON.
I am interested.
Perfect! It sounded like this is what they wanted, but as I had no knowledge of microservices I wasn't quite sure if something else was expected. Thank you
Yes, exactly, we can do it right now, but try() does not support this. And it's really a best practice that should be followed most of the time, so try() becomes kind of useless unless you want to make your error wrapping worse (using the more general wrapping with defer).
is it possible for try to automatically add a stack frame to the error? then you get simple context for free (or for the price of using try). then you basically end up with a stack trace (at least if the whole code flow uses try or adds a frame manually)
maybe try allows wrapping and if you don't wrap it auto-adds some context for you (filename/line#)
Indeed I had a manual review in mind. There are surely tools available that cover a range of checks for known vulnerabilities, but I have no list of such tools at hand, and I also would expect that these tools are limited to detecting specific vulnerabilities that can be expressed by formal rules.
Checkout [https://realworld.io](https://realworld.io), they have examples of Medium-clones in multiple stacks both for front-end and back-end. The Go back-end example happens to be using Gorm.
Indeed. I've made an issue about it: https://github.com/golang/go/issues/32914.
Please, don't use floating point for money, that will give you a lot of problems. Look for alternatives, there are quite a lot Now to your question: A common pattern for this is having a table with a fixed set of fields that will be necessary and having extra tables to hold item data that can vary like " field-id: 35; value: blue" while in another table you hold info for that kind of fields: "field-id:35; name:color; type: string; description: house color"
You can use docker/docker-compose
Definitely interested. Caddy is a brilliant project, it's been my "*go to*" for a while now. I think it was probably the first exposure I had to the Go ecosystem too, and just how easy deployments were. (Erhh... copy the binary?)
Perfect, thank you!
Microservice generally means a server that does one thing or group of things. So instead of a single server that does everything (monolith) you might have a users microservice, a widgets microservice, etc... that can be developed, tested and deployed independent of each other and communicate through some type of protocol such as HTTP with JSON or gRPC, etc...
Perfect. Thanks for the simple explanation. I read Martin Fowler's article on Microservices but it was expansive and still didn't nail down the fundamentals for me
I've used Apache, then Nginx for a long time, and then recently had to decide between Tr√¶fik and Caddy because I wanted something "easier". Caddy won. Since then I migrated a few servers from Nginx to Caddy and also a few friends of mine migrated. It's an awesome piece of software.
I think that's a tad strong; `:=` is the weakest language feature. Some suitable support for generic types comes second. Now that everything seems to be converging on modules (after the dep debacle*) I'd personally put the error handling in third place :-) * This may also be over-egging it, but it caused quite a bit of pain.
It sounds like the take home project was poorly spec‚Äôd out. I‚Äôd try to include some of the best practices from 12factor.net rules. The most important of which are keeping the server stateless and having logs be treated as events. Additionally make the server listen address be an environment variable and use them for any other configuration needed with sensible defaults.
When you say retrieve I assume you mean return? If they listed two endpoints and what data to return that‚Äôs what you should build, no frontend required.
I'd personally like `try` to be spelt with zero characters. n+1 values expected at the call site? Work as before. n values? Insert this behaviour. Suddenly the n=1 common case looks readable.
Yes... I don't know why I said retrieve...
Cheers. To be honest I get the feeling it was purposefully vague to see where the applicant runs with it.
I would add, somewhat frivolously, that that leaves the word `try` available* to act as some sort of syntactic bracket around a group of statements that have this behaviour. \* I can't work out an unused syntax to let it be spelt `for`
The standard library does include sort.Float64s(s) and other variations for basic types akin the SQL. For custom structs the above comment is correct, there‚Äôs no way to know what field and expected result you want in a clean API that‚Äôs performant.
That's sad.
&gt; without opening an issue Means opening a related github issue, a ticket, not that anyone would have an issue with it.
Good stuff.
Let's donate our workforce to a commercial entity for nothing in return! Yay!
Pretty sure it is close to one man project that he releases the public for free.
It was never about writing it. It was about having to read it all over the place.
I've been using Caddy personally for a few years now, and it's worked really well for me. Thank you for the good work!
I think one way or another it depends on how well the programmer uses the tool. If someone is tired of manually adding metadata, he will probably start adding whatever message instead of good messages. In that scenario, I'd rather have a complete trace. I really like traces. They always tell the truth. Messages sometimes hide the real issue. You get used to reading stacks in a few days, nothing cryptic about them.
https://caddyserver.com/products/licenses
If you want it to belong to the community you should scrap the CLA.
Hi u/mwholt, Caddy looks really interesting, what would you say are its main differentiators to Apache and Nginx?
what's .basis?
This is copy-paste driven development in Go explained in one reddit comment lol
A `select {}` inside the handler blocks forever. `time.Sleep(time.Second * 10)` should block for 10 seconds.
Because it is not included. Some changes got pushed back.
Did you even read the blog post? &gt; Part of the reason I moved Caddy out of my personal account---and why I am opening the Caddy 2 source before it is finished---is because I want to undo the mistakes I made as Caddy 1 grew. That means no license shenanigans, no business use case limitations, no unnatural response headers. Caddy 2 is and will remain truly open source (it is licensed with Apache 2.0).
*There is a new supercompression algorithm and this algorithm reduces the size of the image by a huge margin and converts it into a new format called* ***.basis*** *format. This image algorithm is on* [*Github*](https://github.com/BinomialLLC/basis_universal)*, and there is a command-line compression tool to convert images to .basis format, but to use this tool you need to setup the entire project and also the .basis file can‚Äôt be displayed on browser.* &amp;#x200B; So for that I've created this server, you can just make a call to API and convert png to .basis format quickly.
Did you read the rest, too? Commercialization isn't going away. There will still be an Enterprise version.
Can't understand why not to have dedicated wrapping function instead of this ugly `fmt.Errorf("&lt;text&gt;: %w")`. Can't understand why not to have `errors.Formatf` right in the module.
&gt; how I can block it without using something like time.sleep(10000) Why not do that (I mean, with the correct constant of course :) )? Seems like a totally fine way to test what you want to test. A more complicated (and thus arguably worse) way to do it would be to type-assert to [http.Hijacker](https://golang.org/pkg/net/http/#Hijacker) and call it. That would prevent the http server from actually writing a response. However, it only works with certain `ResponseWriter`s and might prevent your test from being effective (for example, the test might make an HTTP2 connection and then fail). But really, `time.Sleep` seems fine.
I'm definitely in favor of try. I think it does help the readability quite a bit and I really do dislike to sprinkle `if err != nil` everywhere. People seem to dislike that you can nest them. I thinks it's a feature. There's often a value you want to just put in a struct but you can't because there's also an error value returned from the initializer. Wrapping the error in defer is absolutely good enough. Are you really going to claim you won't be able to tell if it was `json.Unmarshal` or `ioutil.ReadAll` that returned an error without marking them differently in the calling function? Just keep your functions relatively small and there won't be any problem.
I agree we need more data before deciding the fate of the \`try\` proposal. But writing that try will "cause severe inconsistencies in code bases" is FUD in my opinion. Rust has introduced try! and ? without any major issues.
I get it, but it's not really more magic than most other built-in functions (append, delete, make or panic for example).
Other people do not like how it is now.
It absolutely is. It does not take "err" in, but somehow assigns to it. Of course those things you mentioned do weird stuff under the hood, but from the outside they make sense. Try does not.
Hmm I find it increases it, maybe not readability in terms of prose but Go was never good at that, it improves clarity though.
[removed]
I don't think you can drop the CLA if you plan to use contributions from the public in a \*potentially\* closed-source, paid-for enterprise edition?
Agreed about `try` transparently assigning the error to the return value.
Thanks!
Does that mean that gradle is not open source?
No you can't. And that's sort of the point. Saying `It should be the Go community's web server` and having a CLA is disingenuous at best.
https://en.wikipedia.org/wiki/Mutual_exclusivity
Using `defer` for wrapping looks very much like using try-catch/except for error handling: there is a business logic in one place, there‚Äôs error handling related logic in another.
You got downvoted to heck, but I agree with you. I really disliked check and handle, and am glad they ended up with something reasonable and minimally invasive like try. I'm a bit nonplussed by the dependency on a named return variable, but only because - while go supports them - they're not really canonical. I see them used almost nowhere in the wild. But I can live with it, for what try brings. It's a very go solution.
I still think error handling in go is the weakest part of the language and missing features is an entirely different discussion. Having your code littered with `if err != nil` is pretty bad, I don't see how the optional variable inference short hand is the weakest part in your eyes.
The function signature for `split.String` is ``` func Split(s, sep string) []string ``` So it returns a slice of strings and only returns one type of value. It doesn't return any errors. I haven't tried but I would assume if the original value is equal to the only item in return value, that means the original string doesn't contain the delimiter. I might be wrong, just try and see.
&gt; secure [...] environment variables [...] command line Be aware that many operating systems allow any user to query the environment and command line of any other running process. You should *never* pass sensitive information via either method.
Very funny!
you can create your own version with custom error
`time.Sleep` is fine (as others have mentioned); remember that each request is already in it‚Äôs own goroutine, so you can still do concurrent requests
Can it suport a wsgi server without nginx? (For Flask or Django)
Compiled the whole thread into a single post, for easy reading: https://threader.app/thread/1146128393542492160
But also true. Every programming language feature is unnecessary. Every programming language is unnecessary. We use them for a reason, to make programmers more effective and programs more expressive. So I don't buy the argument from orthogonality.
Not related, but if you scroll down there is an entertaining chain of tweets about "the weirdest bug you‚Äôve ever found that left you wondering how computers even worked in the first place": https://twitter.com/jessfraz/status/1135360185290174464
 10 Exceptions and generics are fundamentally bad ideas because they introduce unmanageable complexities 20 Write new easy to use language without them 30 Endless complaints that fundamentally flawed features aren‚Äôt there 40 They are added 50 Once easy to understand language now unmanageable like so many others 60 GOTO 10
Folks, this does not apply to everyone but it definitely applies to a non-trivial bunch of people: You do not win people to your side by being _assholes_. There are people being real assholes about this `try` thing, doing things like downvoting perfectly reasonable posts in favor of `try`, or outright insulting people who want something other than the current mechanism to be available. Please stop. This is a technical discussion, and I can _feel_ my position hardening because there's a set of people being assholes about `try`. I want this to stay a technical discussion. If you feel like you're on the _attack_ and you're going to _score some points_ and you're going to _really show_ those people who dare to like `try`, please stop, step away from the keyboard, cool down a bit, and wait until you can be more rational. (I'd call out those supporting `try` too if I saw it; so far, from what I've seen, we've not yet metastasized into two sides that just hate each other. Please help me and the community keep it that way.)
The core distinction between exceptions and Go's error handling is that with exceptions, the error is passed arbitrarily far up the _call stack_ into code blocks that can't know what to do with the error because they can't understand it. The atomic element of error handling in a language like Go is the scope, because scopes are what the language is made of. Scopes have things mixed around and a bit out of order all the time, with their loops and if statements and so on. You can end up with error handling in the same scope, but distant, even in Go today, such as in the style [shown at the end of this blog post](https://blog.golang.org/errors-are-values), where many operations are speculatively done and the error is only checked at the end. (It could easily be another 20 lines.) You already have to understand the scope you are in to know what the scope is doing. You can't expect to, say, take the first half of the lines of a scope and expect to know what it is doing; you have to understand all the flow control and conditions and so on. It is not unreasonable to expect that you have to understand all the `defer`s in a scope to understand how that scope works, and, indeed, _that's already the case_; putting error handling in a `defer` is, from that point of view, not a new "type" of thing at all, but just re-using existing mechanisms in Go. The IDE point is valid enough on its face; personally I kinda preferred the explicit `handle` for that reason, but, then, that's making even more and larger changes than the current try proposal.
[No, it can't.](https://github.com/caddyserver/caddy/issues/176)
It‚Äôs nothing like exceptions
Would you write this comment about Docker too? To me it's the same premise. Nothing wrong with contributing to a commercial product that has a nice free open-source version.
&gt; Would you write this comment about Docker too? Sure. All this fake caring about "the community" while you just use them as cheap labour is the same, no matter who's doing it. If you're a commercial entity, you're not part of "the community", you're using it.
As long as the enterprise version is the same code as the free software version, so what? Companies make millions selling commercial versions of Linux, but it's not like we get nothing in return. In fact, most of the improvements to Linux come from commercial entities paying developers to do the work. ("But apart from btrfs, XFS, Wayland, RAID support, Clang, ARM support, EFI support, dtrace, USB support, WINE, CUPS, GPU drivers, VNC, docker and KVM, what has commercialization ever given us in return?")
A CLA can be good even for free software projects. Look at the situation with Linux, where it's stuck on GPLv2 forever because of the near impossibility of tracking down every single contributor to get approval to change the license. (Sure, Linus doesn't want to switch to GPLv3, but even if he wanted to switch to BSD, your favorite license, or some hypothetical GPLv4 that everyone agreed was better, those things would be near impossible too.)
&gt; for nothing in return You get a webserver in return.
He isn't listening - they've had the Go Survey results from the 5883 people (globally) that bothered to respond, and they're basing their decisions on that. * package management * generics * error handling All of these apparently significant issues, are championed by an inflexible, vocal minority of the Go community, which is exerting an asymmetric level of influence on the roadmap. Look again at the survey results: 89% of users are happy with Go and 90% would recommend to another developer - yet because 5% aren't happy with error handling, we're having people propose crazy, non-idiomatic workarounds that just aren't in the spirit of the language.
But named returns? Just "filling" the err in? Where, how? I like the idea of try, but I absolutely hate the implementation (proposal). Nesting is part of it. A keyword would work much better in my opinion, but I still would have issue with the implicit assignment. I agree that using it for log&amp;wrap for example doesn't have to be a problem and it cleans up the code.
&gt; I see them used almost nowhere in the wild. Because their benefit is limited - you can rarely use naked return - and they help with adding shadowing bugs. And I would lean on consistency (not use them anywhere) over having them just where they make sense.
Twitter is the worst medium for these.
I believe this question does not belongs to this subreddit in anyway since it's specific to Windows OS, not Golang.
&gt; come from commercial entities paying developers to do the work let that sink for a moment.
&gt; My favorite work example is a class that handles phone numbers. Seriously, it's 4 strings of data. Except when it isn't. e.g. `+44 1223 12345` (valid UK number).
&gt;If the goal is to just to ‚Äúpass it along‚Äù you always have the option of not storing the returned value into a variable. Then you couldn't pass it along... you'd just swallow the error and continue. &gt;I don‚Äôt see how a try block makes things that much better for this use case. The proposal isn't a try block like in languages with exceptions. Read the proposal. It's like a function that checks whether it receives an error as its final parameter, and if it does, it returns from the parent function with that error.
See, what I use go for is web services. Errors are logged for developer use. Those errors do not ever get displayed to the end user of the system. Try and errors with stacktraces is exactly what I need.
A library writer can always add whatever context they want. Try doesn't take away the ability to do things the old way. What it does do is make things more sane for writing apps that consume those libraries.
Your language (English) and the way you use it makes it the perfect tool to dispute about white things being black. I clearly meant in exception handling they have an __exception-prone code in one place__ and __react on exception in some other on__. With try proposal and defer as a way to annotate errors you have __error-prone code in one place__ and __react on error in some other one__.
Good! Think about how much good Nginx has done! I spend most my time configuring IIS, but I still prefer Nginx, and recently I've been growing towards Caddy instead (only for personal projects so far, but I would choose it over the other two if given an opportunity for a work project). Caddy will continue to be fantastic if the author can also make a living.
I understand that. My point is that in the case of exceptions, "the other place" is in arbitrarily-distant functions higher in the call stack, and in the case of \`try\`, it still is in the same scope. That is a critical difference, because a "scope" is already the smallest possible unit of code that can be properly understood on its own. So it is not the same as exception handling, and not a change from what is already necessary to understand a given piece of code.
&gt; If you try using module now, it still suggest to using `go get go-hep.org/x/hep` But would that mean I could still make changes to the source files and rebuild the project? (How would I rebuild it? `go build` from the root directory of the project?)
Well shit Russ, when you put it that way. Ok.
I'm not sure what you're trying to say. I see 3 strings, out of four.
&gt; Think about how much good Nginx has done! ? I never said Caddy is bad. Or that commercialization is bad. But Caddy belongs to a company, not the community. Same with Nginx. Claiming anything else, like OP did, is just dishonest. If you want a piece of software to be a community project, rather than a commercial project with unpaid labour contributions, hand over its stewardship to a community-controlled foundation, like LibreOffice or Linux or Apache did.
A _lot_ of people hate `if err != nil` and are extremely vocal about it. A thing I've only really come to notice since the `try` proposal came out is that most of the most vocal opponents are actually people who don't like Go anyway. I think this is one of the major arguments people use to dismiss the language without further argument, because it's widely understood to be a weakness. I don't mean it _is_ a weakness, just that it is understood to be one among the _Rabble Rabble_ People. "Fixing" this via `try` or whatever else is not going to make those people suddenly embrace Go. It's just going to cause them to find another linguistic peculiarity to _rabble_ about. That said it is fantastic that the Go team is making a concerted, serious effort to address those things that their users feel are deficiencies. It speaks volumes about how to project is being cared for. Personally I don't mind `if err` and have come to appreciate its explicitness and visibility. But whatever, everyone has opinions. In the long-term it's better that the Go team be actively engaged with their developer community than that we make sure no one's feelings get hurt when problems are identified.
I get your point, and it might be one of the more community driven approaches, but it requires more people to run a foundation than a small project like Caddy has working on it. Also, a foundation still isn't a pure democracy of the user community--nor should it be. That isn't how software gets organized, cohesive APIs. I think the end difference is far smaller than you think--especially if the project is licensed similarly to how Caddy is licensed.
Like [this](https://play.golang.org/p/PuPgnP9CQIL). What would be the point though, you may as well check if your return value has length 1 and do something custom from there.
Want to make Go a better language? 1. Finalize package management (already happening in go 1.13) 2. Make error wrapping better (already happening in go 1.13) 3. Remove the named return values and bare return (which was always against the 'only one way of doing things') 4. Make JSON encoding/decoding faster 5. Add more refactoring tools to the standard toolset (extracting methods, generating interfaces, that type of thing) I would keep generics in the realm of generators, so as to not make everyone pay the compilation performance penalty for a feature that they do not need. I would also personally like to see gofmt respect a 100 char column limit, automatically adding line breaks, but I know I'd probably get a lot of pushback on that. I could probably think of more stuff but that's just off the top of my head.
Aye, this is getting worse than the whole vgo vs dep war
On one of my proposals somewhere, I think I proposed providing an alternative mechanism for rewriting the error on the way out so you don't have to use named returns to make this work, so an error-handling defer could do something like: defer func() { retErr := returningError() if retErr != nil { setReturningError(someContextAround(retErr)) } }() (Ignore the names, pick whatever you like.) You could even define the returningError() to look up the current stack for a returning error so that function can be abstracted out as a module-level reusable handler. One of the things I was really looking forward to, and still hope I get somehow, was something like: func moduleError(s string) func() { retErr := returningError() if retErr != nil { setReturningError(someContext(s, retErr)) } } func OpenConnection(...) (...) { defer moduleError("opening connection to database")() socket := try openSocket(...) ssl := try sslifySocket(socket, ...) dbHandler := try initialCommunication(ssl, ...) return dbHandler, nil } Given the tone of the conversation, though, this seems like even more magic that people won't like, because of the way this would look up the stack tree to find an error return in progress. Though perhaps people would prefer it to named return handlers. The current proposal could still do something similar, as I understand it: func moduleError(s string, err *error) func() { return func() { if *err != nil { *err = addSomeContext(*err, s) } } } func OpenConnection(...) (res *DBConn, err error) { defer moduleError("while opening db connection", &amp;err)() ... } // or alternatively func OpenConnection2(...) (res *DBConn, err error) { var err error defer moduleError("while opening db connection", &amp;err)() ... return conn, err } although in the latter case you have to be careful to never rebind err, which `:=` makes it easy to accidentally do in a new scope IIRC.
I don't understand your mean of rebuild? you rebuild a main package ? or rebuild \`[go-hep.org/x/hep\`](https://go-hep.org/x/hep`). rebuild a main package, to output the binary, using go module, can just using go build ( you can change local cache package ( in \`$GOPATH/pkg/mod\` ), you later update may make your change lost. &amp;#x200B; rebuild a package is automatic, I think if you changed the package of local cache, your changed pkg will be in effect. ( I haven't try this way though ).
For some reason having to declare an error variable annoys me. So I'm happy that: ``` var err error arg := nv.Value nv.Value, err = c.cci.ColumnConverter(index).ConvertValue(arg) if err != nil { return err } ``` can become: ``` arg := nv.Value nv.Value = try(c.cci.ColumnConverter(index).ConvertValue(arg)) ``` I can also see myself doing something like: ``` func foo() (int, error) { v, err := func() (int, error) { a := try(doSomething()) // ... b := try(doSomethingElse(a)) return b, nil }() if err != nil { return 0, fmt.Errorf("could not foo: %s", err) } return v, nil } ``` Which is basically an ugly version of try/catch..
I think `go build` should execute inside directory of main package, unless you specified package path.
I'd love to see a slightly more complicated example. &amp;#x200B; Like... one that uses a go routine to change an image every 5 seconds, or navigational tabs. &amp;#x200B; It was a little bit ... non intuitive even to get wasmserve running it as the instructions for the url weren't working (needed full localhost:8080/github.com/gopherjs/vecty/example/markdown) gopherjs is just spewing errors so I gave up on that. Seems like a great idea, but please put together a slightly more complicated example than a text box.
You're right. I'm going to delete the post.
But... I just found the Go language _5 minutes ago_ and have the right to question the ideas of those working on the project night-and-day for 10 years. Especially the right to call into question their management of the project considering they've written hundreds of pages of custom responses/replies and to community input which is _basically_ about equal to the work I put into my tweet rant.
c was ahead of its time with a monthly type system.
Let me clarify - So.. after doing `go get` [`go-hep.org/x/hep`](https://go-hep.org/x/hep`) I can use the library via import ( "go-hep.org/x/hep" ) Suppose I make some changes to the source code of hep/. Would the changes be reflected in the go files having that import? Or do I need to rebuild hep again? And here how do I rebuild?
They were thinking the same thing most of us who‚Äôve used Go for a while have realized. You don‚Äôt really need these things as much as you think you do. That said, we are probably going to get generics in some form or another, and probably something similar to this project (which is usable now if you really must have it): https://github.com/cheekybits/genny Maybe it‚Äôs ‚Äúweird‚Äù because it‚Äôs different from what you‚Äôre used to.
You know this is Reddit right? Reddit **is** an asshole amplifier as are Twitter, Facebook, ETC.
&gt;nv.Value = try(c.cci.ColumnConverter(index).ConvertValue(arg)) I think thats gross and hard to read.
It will reflect the change after you have rebuild. I think you can just try you idea, go command will tell you.
there are tons of discussion about this. have you googled for it? i think fundamentally, there is nothing weak about go's type system. it may not be as rich as many languages but it isn't limiting and you can achieve the same results. ultimately, if you are unhappy with Go's type system, why not just learn rust, haskell, ml, or something else? go is just a tool -- if it doesn't meet your needs, get another tool.
Good debugging idea. It dump out \`account.Account\` and \`\[\]account.Account\` in the 2 scenarios above. I guess it seem like go can check if a singular struct satisfies an interface, but not a slice of structs match a slice of interface :(
I've seen these words pop up a few times, didn't know what that meant either. Guess I'll have to read up on it more. Thanks
Wow! There's a lot of misunderstandings in this thread. - You're not building a commercial product for free; you get a great web server, which the Go community needs. Look, just have fun with it. If you're bitter about it, we don't really want that attitude anyway. Feel free to ignore the project if you don't like it. - Caddy is not licensed differently for business, our build/download services are; and that is probably going away when caddy enterprise is released. - A CLA does not have anything to do with ownership. Caddy's CLA does not adding copyright. It just means that you certify that you have the right to contribute changes under an open source license. - All growing open source projects are backed by commercial entities which are making money from them, like, you know, the Go language itself. It's not evil, it's necessary, and it's how you sustain a community. I've been working hard to get the docs up to speed lately in the wiki. Let me know if you have any questions!
&gt;go is just a tool -- if it doesn't meet your needs, get another tool. &amp;#x200B; Exactly ! Why all these complaints about things missing or being wrong. Just find another language, there are so so many. Its already hard to choose, so its good there are at least some differences ;-)
I'm not really sure what you mean by that comment. The person asked about something being first class but it's effectively already in stdlib, except you have to write a small function and use it the same way. I just wrote a small shitty example.
ya -- i didn't read your original post carefully. so yes -- go will attempt to check if a slice of things implements an interface but it will not implicitly check if the MEMBERS of a slice implement a particular interface.
\&gt; He isn't listening - they've had the Go Survey results from the 5883 people (globally) that bothered to respond, and they're basing their decisions on that. &amp;#x200B; Exactly. I for example did not respond because I think they did a good job so far. Did not expect this change in policy though.
You're week.
I'm fairly new to Go, but I found this talk by Rob Pike (one of Go's creators) really informative: "Simplicity is Complicated" [https://youtu.be/rFejpH_tAHM](https://youtu.be/rFejpH_tAHM) It's only about 20 minutes.
&gt; A thing I've only really come to notice since the &gt; try &gt; proposal came out is that most of the most vocal opponents are actually people who don't like Go anyway. Exactly. I see some folks asking `Go` should do things the way `rust` does. Doesn't make any sense.
At work I use python. I love that go has type-safety.
Not at all. What I like about Go is that it doesn't have the features you mentioned because I think it makes other peoples code (objectively) easier to grok. I'm glad Go exists in its current form. There are plenty of other languages that offer the features you want, you can have them right now if these features really would help you ship your project in a way Go can't already. Rust isn't hard to learn either if you think it fits your problem domain better. Go feels like it's carved out a good systems/tooling niche by not having these features and it would be a shame for Go2 to end up like C++, Perl6 etc trying to be everything to everyone.
Thanks! Yeah, I watched that! As a new Go developer, has there been anything that you've really liked or that made you decide to learn it? My only motivation was that it was developed at Google to pick this language so I'm curious why others picked / stuck with it.
Contributions welcomed!
That's not how a CLA works or what it does. CLAs are normal in open source projects. The Caddy CLA is borrowed from the Linux project. It says in full: &gt;Developer Certificate of Origin Version 1.1 &gt; &gt;Copyright (C) 2004, 2006 The Linux Foundation and its contributors. 660 York Street, Suite 102, San Francisco, CA 94110 USA &gt; &gt;Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. &gt; &gt;Developer's Certificate of Origin 1.1 &gt; &gt;By making a contribution to this project, I certify that: &gt; &gt;(a) The contribution was created in whole or in part by me and I have the right to submit it under the open source license indicated in the file; or &gt; &gt;(b) The contribution is based upon previous work that, to the best of my knowledge, is covered under an appropriate open source license and I have the right under that license to submit that work with modifications, whether created in whole or in part by me, under the same open source license (unless I am permitted to submit under a different license), as indicated in the file; or &gt; &gt;(c) The contribution was provided directly to me by some other person who certified (a), (b) or (c) and I have not modified it. &gt; &gt;(d) I understand and agree that this project and the contribution are public and that a record of the contribution (including all personal information I submit with it, including my sign-off) is maintained indefinitely and may be redistributed consistent with this project or the open source license(s) involved. What about this destroys community ownership? There's no copyright assignment, only a statement that either it's your own original work or you have the permission and rights to submit the change under the project's open source license. It's a protection for both you and the project. What do you hate about this?
This does also stop anyone from legally distributing a closed-source linux version.
I like that it is strongly typed (unlike Python), compiles to machine code, and is garbage collected. So you can have the safety of strong typing and it is fast, but you don't have to manage your memory manually. Concurrency and channels are awesome as well. It's really fun to program with, you should definitely five it a spin!
Sure, pay me my usual hourly rate.
It's not something *I* need myself, but I'm sure someone who needs it would be happy and able to pay *more* than your usual hourly rate.
Awesome job, Matt! I love how easy and straightforward caddy is to setup compared to nginx, apache and iis!
&gt; Feel free to ignore the project if you don't like it. Feel free to ignore the criticism if you don't like it. &gt; and that is probably going away when caddy enterprise is released. Making Caddy Enterprise a bit less of a nebulous undefined thing would probably help to clarify your position. &gt; All growing open source projects are backed by commercial entities which are making money from them How does the Apache Foundation monetize their projects? How about the Linux Foundation? The Django Software Foundation? PostgreSQL?
 6. Already in work in gopls.
&gt;Making Caddy Enterprise a bit less of a nebulous undefined thing would probably help to clarify your position. What do you want to know? &gt;How does the Apache Foundation monetize their projects? How about the Linux Foundation? The Django Software Foundation? PostgreSQL? Ah, I'm using the term "commercial" in the business-interest sense, not the "non-profit organization" sense. Even these non-profit organizations have very business-minded objectives, because they have very real funding requirements and objectives, and whether their money comes from sales or donations, all these entities need a compelling case for people to give them money. Nothing is truly free in this world.
I was under the impression that the key complaint about named return values is they clutter up the resulting godocs. Is there anything else about it you don't like?
&gt; learn something that was better designed Better designed? Go maybe limited in features but it's one of the better designed languages out there. &amp;#x200B; &gt;Something that I wonder as well is what the hell Robert, Ken, and Rob were thinking when they decided to keep out some of the things that I've just mentioned. Experience. They knew that many of the usual features are not actually that needed. Every big language suffers from the same problem - people choose a subset of its features, creating their own smaller language. And everybody has a different opinion on what this "smaller language" should be. That's how you get modern C++. Go is like this "small language" from the start. Only this time the choice of features was made for you. &amp;#x200B; As for learning other languages, what's stopping you? Why not learn and use multiple languages?
Have a look at the Github contributors page: [https://github.com/caddyserver/caddy/graphs/contributors](https://github.com/caddyserver/caddy/graphs/contributors) Notice a trend? Matt has committed 100 times more code than the second contributor, and that contributor hasn't helped since the very early stage in 2015. He's asking for contributors because he doesn't have enough people in his corner to start a freaking Foundation.
Only if you hit the right URL
You can read https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4 for some of the previous discussions on the topic. tl;dr; There are many options when designing generics and there have been many design drafts, however, a design that fits well with Go hasn't yet emerged. Regards to the problem space that generics solve... Some problems require to write your code differently than you are used to and then again some problems are harder or more verbose to express in Go. I guess the question is, which exact design problems/annoyances are you facing?
... is another person's offset
Its nice to create binaries which are easy to distribute and fast to use (no install) on different environments.
I'm just saying that 4 isn't 3. You didn't say "up to 4". I've seen people write phone numbers with more than 4 groups of digits too, and you need to deal with things like extension numbers. In general I don't think it's a good idea to start specifying how many groups of digits you're allowed in a phone number. Just make it a text field with maybe a few validators/converters for ITU-T standard and local formats you want to support, and be done. So I agree with you about people overcomplicating things, but I'd go further and say that storing phone numbers as multiple fields is overcomplicating things too.
üëÜ I think it‚Äôs a disaster that we‚Äôre moving toward generics ‚Äî as I suspect you‚Äôll agree. The only benefits I see are less noise about their lack, an increased flow of newbies to write indecipherable and unmaintainable code. Can someone tell me what generics can do that interfaces cannot be used to implement today? As for, paraphrased, ‚Äúwhat were they thinking?‚Äù ‚Äî they were thinking that language progression has produced a (very) few gems ‚Äî some like CSP which have been completely overlooked, most like hairballs elevated to ‚Äúmust have‚Äù status ‚Äî and that it was time for a reset to C 2.0. It‚Äôs worth noting that that these thinkers that you question the thinking capacity of created a gigantic portion of the computational world that you live in and had around 40 years each to ponder said world ‚Äî and what would be most beneficial for the next several decades. Lesson 1 for all newbie developers: lots of complex code is easy, little simple code is genius, and clever code is nearly always a disaster.
Speaking as a user, and only of Caddy 1, Caddy is *well-crafted software:* the defaults are sane and the configuration is simple. It's capable and maintainable. It can automatically issue, manage, and renew TLS certificates via Let's Encrypt. It's good.
Yep. The 4th is 'type', so 'home', 'work', etc ... but yeah, having 3 doesn't really work because of extensions and all sorts of other non-US standards. Then they decided it would be easier if they knew right off if it was a UK number, or Chinese, or US ... so the integration partners, who know what data they have and how to convert it, now need to figure out data they DON'T have, to use the right builder, etc, etc ... You're not wrong, 4 is not 3, and 2 would probably have been optimal. My point was really about how they've got builders, DTO classes, ORM tags, test classes, etc ... a literal mountain of code, that often doesn't work, to store a few strings in a database. There's a point in the client where it pulls the user's phone numbers, no more than 4 (one for each type), but because it's 'bad practice' now to do a for loop, it converts the list into stream, then filters the stream by type, and converts that stream back into a list, and checks to see if the list is empty ... instead of looping through 4 (max) items. It's good someone added the method to break that search up into a multi-threaded search! Hahahaha
&gt; I'd love to see a slightly more complicated example. There is a full TodoMVC implementation. See `example/todomvc` &gt; It was a little bit ... non intuitive even to get wasmserve running it as the instructions for the url weren't working (needed full localhost:8080/github.com/gopherjs/vecty/example/markdown) You must have ignored the step to cd into the example directory.
No. I went into the markup directory in bash, but wasmserve appeared to be serving what I assume is gopath. Wasmserve.exe is in g:/go/bin I'll have a look at the TodoMVC thanks.
A lot of people don't seem to realize that with mobile phones now the default, it's much more useful to just use standard format everywhere and let the phone handle it.
Honestly, the real bitch is that all 3 of the systems have built-in functions to change a 'standard' phone number into their proprietary format. Of course they do, these are modern human resource management systems! So, really, any one of the 3 systems could just build a phone number from the other two by using their built-in phone-number creation routine, and whatever string was stored by the other two. There's really no need for the conversion to a standard 'type' at all. I get why they'd want to, of course, but then if you're going to do that, at least make it simple and straight forward instead of inventing a 4th 'standard' that nothing can read/convert natively, so that now we're customizing 4 systems so they can talk to one another. Our problems go beyond software design, but our software design is the kind of horrific monstrosity people write blogs about. Lucky for me, I don't work in that area, so I'm pretty much in control of my own code, and only have to deal with that stuff for integrations.
I personally love err != nil. The code is unbelievably easy to read and understand, and it's not even verbose.
You need the CLA to re-license it under the project's license, too. Contrivutors still retain their copyright.
Glad to see the [Subscribe()/Change stream](https://godoc.org/github.com/dgraph-io/badger#DB.Subscribe). Also like the new Options API [mentioned by Tim Shannon](https://tech.townsourced.com/post/boltdb-vs-badger/). I didn't know /u/campoy was working for Dgraph.
I‚Äôm happy with go, don‚Äôt change it
Sorry but i have one more question here. They havent supplied a URL for the JSON, just an example of how they want it structured. What would be the best way to include the json I need? I was thinking of creating a json file and hosting it online to have the server request the data from there, Can you think of a better way? Want to stay away from a DB if possible, possibly out of scope for this task.
 require.NoError(t, ThingThatCanFail())
&gt; Go maybe limited in features but it's one of the better designed languages out there. These check-handle and now try proposals shows this can easily be a lucky coincidence.
You know those are just proposals? First was scraped. Second probably will follow. Not the first time this happened.
That is all great but if you want to wrap the error this is not going to help you at all - and you should wrap errors. It may even force you to use named returns which I find a harmful pattern.
&gt; Something that I wonder as well is what the hell Robert, Ken, and Rob were thinking when they &gt; decided to keep out some of the things that I've just mentioned. Decades of experience working at huge software projects. Seriously your post shows a lot of ignorance. Software development works very different when you are at googles scale.
wasmserve definitely serves local directories: https://github.com/hajimehoshi/wasmserve#example-2 And I just confirmed on Mac as well and the instructions here definitely work: https://github.com/gopherjs/vecty/tree/master/example#running-examples If you're certain you ran wasmserve from the markdown directory, I don't know what the issue would be.
I find Go interfaces very well designed. The fact you are coding to what things can DO (instead of what attributes things have) took a minute to get used to, but now I love them. They make mocking and testing very straightforward. Composition of Go interfaces is quite nice.
False. `%w` is [still there](https://tip.golang.org/pkg/fmt/#Errorf). What got rolled back were the formatting and the stack frames.
Eh. I honestly prefer the current one, but at least the new design isn't something outrageous.
What if `ThingThatCanFail` returns a value that must be used later in the test case -- which is the most common? ``` svr, err := NewServer(...) if err != nil { t.Errorf("could not create server instance: %v", err) return } defer func() { if err := svr.Close(); err != nil { t.Errorf("could not close server: %v", err) } }() if err := svr.Start(); err != nil { t.Errorf("could not start server: %v", err) return } defer func() { if err := svr.Stop(); err != nil { t.Errorf("could not stop server: %v", err) } }() ... use server in the test ... ``` Compare the above with the following: ``` svr := try(NewServer(...)) defer func() { try(svr.Close()) }() try(svr.Start()) defer func() { try(svr.Close()) }() ... use server in the test ... ```
It's not a big issue in my view. I have stuff in prod that is bulletproof. I can revisit the code a year later and read it, because the surface area of the language is not big. Any language has tradeoffs. Go trades off language features found elsewhere for simplicity, othoganality, readability, comprehensibility and robustness. If you really can't do without those language features, use another language that suits your case better. M
SE at Google's scale -&gt; reinventing the wheel with every custom data type? Go does a handful of things well. However, dismissing valid design concerns with "they know what they're doing, they've been doing it long enough" makes you the ignorant one.
I just don't like the added parenthesis. It's way harder for me to parse to which component it apply to. Either nv.Value = try c.cci.ColumnConverter(index).ConvertValue(arg) or even nv.Value = c.cci.ColumnConverter(index).ConvertValue(arg)? would be good for me as I can see in a second what's happening. &amp;#x200B; This: nv.Value = try(c.cci.ColumnConverter(index).ConvertValue(arg)) nv.Value = try(c.cci.ColumnConverter(index)).ConvertValue(arg) I have to stop and count.
No, I agree. As far as new designs go this is very reasonable. I was scared of those overloaded javascript clusterfucks or some atrocious color scheme etc like e.g. Rust chose.
It's not that bad with require.NoError either, just more letters: svr, err := NewServer(...) require.NoError(t, err) defer func() { require.NoError(t, svr.Close()) }() require.NoError(t, svr.Start()) defer func() { require.NoError(t, svr.Close()) }() ... use server in the test ...
I'm on the other end. I find those if blocks degrade readability significantly. When I read code I haven't written, I almost always want to see what it does in the happy path. I usually don't care how an error is handled. Having those blocks everywhere not only makes things more difficult for me to read, but it might hide proper if blocks since they might be a single tree in that forest
I've never understood why anyone would want generics in Go. I've never had a problem with the type system. I've read back through the origins of Go and why choices were made, and I will be frank, there are things I didn't understand (conceptually) but when they explained them, it made sense. I am not a code god, but their arguments made sense. I've never felt like I'm jumping through hoops, and everything I've ever written in Go has been clean and concise. That is what matters the most to me in my code. That I can return to it in a week, month, or years, and easily understand what I was trying to do and not have to pick through a bunch of "clever" stuff. I for one wish generics weren't coming; but I'll simply ignore them and hope other programmers that I have to follow will choose wisely when they consider them and either not muck things up completely, or leave enough money in the coffers for me to come fix their choices. Finally, absolutely learn more languages, and not just because this one doesn't meet your requirements, but because that is how you will become a better developer in ALL languages. The concepts from PHP, to Python, to JavaScript and even Java seem similar, but they each give you a tool in your belt. Why not add R, Rust, C, C++, Objective C, Kotlin, Scala, Delphi, or Watermelon if you have time. The worst they can do is teach you what you don't like in a language. The more you know.
Well, they had a choice and decided against including a lot of features. You would have to ask them if they regret any design decision.
I'm confused by most of these, as they basically already exist? - traits.Hash -&gt; arguably [hash.Hash](https://golang.org/pkg/hash/#Hash) - traits.Jsonify -&gt; [encoding/json.Marshaler](https://golang.org/pkg/encoding/json/#Marshaler) - traits.Stringify -&gt; [fmt.Stringer](https://golang.org/pkg/fmt/#Stringer) - traits.Validator -&gt; no direct match but already directly supported by [asaskevich/govalidator](https://godoc.org/github.com/asaskevich/govalidator)
[removed]
Of course he is listening. The survey is a proper outlet for developer feedback. Being happy does not exclude perceived deficiencies. I can be happy overall, and still see the absence of user defined generics as a weakness. You are just assuming that people are either happy or they see weaknesses, but not both.
&gt; My point is that in the case of exceptions, "the other place" is in arbitrarily-distant functions higher in the call stack, and in the case of try, it still is in the same scope. I still think we lose a lot by moving error handling somewhere other than directly adjacent to the error-causing expression.
Should we assume that you never use defer when you write code then?
[removed]
* traits.Hash -&gt; see implementation * traits.Jsonify -&gt; wraps [encoding/json.Marshaler](https://golang.org/pkg/encoding/json/#Marshaler) * traits.Stringify -&gt; see implementation * traits.Validator -&gt; wraps [asaskevich/govalidator](https://godoc.org/github.com/asaskevich/govalidator) The idea is to reduce boilerplate by embedding traits.
[removed]
&gt; I love Golang, but sometimes I feel that I should use my time to learn something that was better designed. No offense, but I don't understand how you reconcile these two statements. If you love it, that seems to imply that you like the design.
&gt; probably something similar to this project What makes you think that? It seems to be completely different from any proposal the Go team has talked about so far.
Thanks for sharing your work. A few questions: * Where are the unittests? * Why would anyone need 6 different sorting algorithms? * Why would anyone need [your](https://github.com/suryanshv23/go-datstr/tree/master/Sort) sort algorithms when there is a sort algorithm in the [standard library](https://golang.org/pkg/sort/)?
What you just said is probably the best thing about it. Error path is a real path you have to care about..
&gt; The top three pain points for Go users, in surveys and direct feedback, have been consistent for a number of years. They are: package management, generics, and error handling. We are working on all three. - If 5% of all people say that "error handling" is the biggest pain point in Go, then that means there are 95% of people who are ... not pointing to "error handling" as the biggest pain point. I didn't just make that 5% number up: that's from the [latest Go survey](https://blog.golang.org/survey2018-results). - Just because it's a pain point doesn't mean something needs to be done. This is the politician's fallacy: "this is terrible, something ought to be done! This is something, therefore we must do this." Sometimes, things just are the way they are, and doing something doesn't necessarily make it better. Error handling is tricky to get right in any language, and many people point out flaws in other systems too.
[removed]
It surprises me too; this is from a few years of looking after go code. The bugs that have cost me most time are the one-character ones where a variable in a loop should be updated (think: paging REST responses, that kind of thing) and instead is shadowed. It plays really poorly with the scope rules for loops that mean that shadowing a loop variable is a common enough idiom that the tooli g accepts it as probably the right thing to do. This has literally cost days of my time.
&gt; svr, err := NewServer(...) &gt; require.NoError(t, err) This is where the `try` benefit is.
You can read this https://www.google.com/amp/ewanvalentine.io/microservices-in-golang-part-1/amp/
[removed]
So I guess if you distill Go down to its most fundamental properties, one of them has to be that errors are not exceptional, that the "sad path" is at least as important as the "happy path", and that error-handling control flow isn't any different than any other kind of control flow. It's fine if you don't think of programming that way. Maybe this makes some of your programs harder to write. I think that's fine. Maybe those programs still get a net benefit from other strengths of Go. And if not, maybe you shouldn't write them in Go! That's also fine. It's OK for languages to carve out a little space for themselves and say "this is what's important to me", it's OK for languages to specialize. I was drawn to Go in large part because of this principle. I would hate to add features that subvert it. It would make Go less Go-like. And I don't think all languages need to converge to the global average.
What boilerplate does traits.Jsonify reduce?
I don't follow the argument from those who say that a builtin like try is not in the "spirit of Go" or that it doesn't "align with Go's simplicity." These are imprecise statements where the argument is always a moving target. Who gets to define the "spirit of Go" and how do we validate new features against it? Imagine if the language had reached 1.0 without defer. Defer is used everywhere in Go, from cleaning up resources to recovering from panics, and many would describe it as a core part of the language. If defer were proposed today, how many of those people would argue that it is too complicated and doesn't "align with Go's philosophy?" Languages evolve over time, and it is important to not reject an idea based on a first impression. Run tryhard against your codebase and observe the results. I personally find that repeated "if err != nil" can obscure the logic inside a function, and coming up with abstractions to deal with it (for example, a sticky error reader/writer, an error-based server handler, logically dividing functions that perform database transactions, etc‚Ä¶) can be too overwhelming or unnecessary when they‚Äôre not being reused. Some of the counterarguments to the proposal lie in dogmatic adherence to certain guidelines like ‚Äúdon‚Äôt use named parameters‚Äù and ‚Äúnever use a naked return‚Äù. Strictly following any guideline only deprives one from coming up with a solution that is suitable for the problem at hand. Also, just because one uses a named return value to enable the try builtin, it doesn‚Äôt mean a naked return has to be used. Don‚Äôt conflate two independent language features. Any proposal that is meant to condense the repeated ‚Äúif err != nil { return err }‚Äù has to provide a mechanism that affects control flow somehow. How invasive or implicit that mechanism is depends on the particular proposal. In fact, one finds similar behavior to try in testing.Fatal and testing.FailNow, and people don‚Äôt find issue with those functions.
&gt;I‚Äôm happy with go, don‚Äôt change it It won't be changed, but it will be called Go1
License? And can you tell it what headers to send or is it always json?
&gt; CTO: We have a lot of users and need to expand. What languages should we invest in? &gt; Manager A: Well, Elixir and Rust aren't mainstream enough to sufficient local talent. I think we should consider Go. &gt; Manager B: Go error handling is a mess and lacks basics like generics &gt; Manager A: Well, that leaves Java or Node. &gt; Manager B: I think Go is a great choice.
So you save a little bit of boilerplate by introducing another third party dependency. Doesn‚Äôt seem like a good trade off.
This is fine .. switch to Rust, Python, C++, Kotlin .. there are tons of options.
What? No. The error path is not the real path you have to care about, it's equally as important as the happy path and any other execution path that your code could take. Littering the code base with `err != nil` by no means helps with that either because you end up with a lot of different error paths that you have to have trust in others in your team to treat correctly and not screw up. This problem is exacerbated by the lack of proper stacktraces. It's also a problem that you just can write code and not handle errors and if you don't have a text editor/IDE with error handling highlighting (Goland's `this call throws an error thats not handled` highlighting, for example) it can sometimes be quite easy to miss something. This is then made worse that side effects and mutation are very acceptable in Go, this means you generally have two, or three ways of writing a function that can error: * you return a left biased tuple, checking if `err != nil`. * you pass in something mutative, also checking `err != nil`, but now you might have already mutated the thing, in your err block you have to do something to undo that (maybe you did some IO, maybe an important value in memory is now different). People forget this a lot. * you do something effectful and panic on err, or just don't return an error because you are new to Golang or lazy or a whole host of other awful approaches here. Basically my point here is that `Hell is other people's code` and Go really turns up the heat on that. If you are in a well disciplined team, or working on your own it's not terrible but the majority of programming shops will have people of a variety of skill levels - Go, though being built to be simple to learn makes people write a lot more code around errors, and a lot more code means a lot more bugs. Exceptions might be heavier, but they free up the code base from error prone and sometimes opinionated *manual* error handling. I love Go for lots of reasons but not the error handling. It was lazy thinking on the language designers part.
all im saying is its literally the point of it and intentional https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=16m13s
I was pretty excited about this when I saw it posted, so I decided to see if I could get a particular bit of server-side Go logic moved into the client side in the browser. I kinda brute-forced my way through cobbling together a Vecty app, trying to figure out what I needed to put into this or that component to create the html elements. It would be greate to see a large kitchen sink example. Also I was hitting a browser deadlock when my main goroutine was blocking too long on the main form submit request and figured out that I needed to move it into another goroutine. Once I got all the initial Vecty app stuff set up, I worked on getting my existing Go code to actually build to wasm. Some of the initial issues were getting rid of the cgo dependencies, and then working around lack of support for `user.Current()` under GOOS=js. Also I had to hack my lib/pq vendored dependency to add a dummy implementation for how it gets the current user. Eventually I got my Go Vecty app to build. But then I hit the final roadblock, which was a failure when the Vecty form submit called into my client library and it went to make an HTTP request. It failed in wasm_exec.js using 'fetch' because it was a GET request that uses a body. Apparently this is not allowed?
Architect: Java it is!
This is an aside from your comment, but a software architect as a job is as dead as a database administrator, milk man, or a stock broker. This job is simply irrelevant. A senior software engineer consensus will out perform anything a single "architect" will ever come up with.
&gt;License? MIT &amp;#x200B; &gt;And can you tell it what headers to send or is it always json? I need to add the feature of capturing the content-type and return it (to return more that json) &amp;#x200B; Set arbitrary headers, if someone needs that I could that, for now, I don't need that feature. &amp;#x200B; thanks for your feedback :)
Go error handling is the best error handling.
Lots of people complain that things can get a little funky when using named return values alongside defer statements. I personally don‚Äôt like them since to me they‚Äôre less clear then the ‚Äúnormal‚Äù approach which makes functions that use them more difficult to debug. I also just don‚Äôt think there a very many cases where the provide a practical benefit.
I made the mistake of using them extensively in a codebase I created a long time ago. Sometimes you just want to see what is returned at a particular point of a method, but then you have to go back and decipher what is happening to that named argument, vs just seeing a value that's explicitly returned. It's a relatively minor readability complaint, exacerbated by the fact that the feature itself breaks their own time of only having one clear way of doing something.
Sure, but that can be said about any code you write and will be replaced. It is good to have a foundation across a large code base. Especially in an industry outside of SaaS, like agency and consultancy work. It depends on the project like anything else
Have you ever worked in a language that does checked exceptions, or worse, a company that forces you to use them?? It's sucks. Seriously one of the worst things ever invented. You might think it's being clever and making you handle everything, but what it does is make you write Kilometers of code to handle basic shit that most of the time you cannot recover from. - if you travel the smart path, catch all and wrap in an unchecked exception. err != nil makes you ignore or handle the error where it happens. You can always append error messages and track wtf is going on. Honestly it's a breath of fresh air after writing Java for years at the Big software shops (Microsoft believe it or not).
Sounds like most of your problems are with Go's WebAssembly support not with Vecty itself. 1. Yes, in browsers if your application blocks the browser will 'deadlock'. As you figured out, you must move any substantial work to a separate goroutine. 2. Yes, you cannot use CGO or `user.Current()` in a browser (what would the latter even do?) 3. Yes, you cannot send a GET request with a body in a browser. I am surprised that net/http allows that, to be honest? Why aren't you using a POST request? I don't intend to sound harsh here, but nothing here is magic: browsers and native environments are not so similar that you can just run some arbitrary CGO code with a bunch of syscalls and odd(?) HTTP requests directly. If you're writing pure Go code and not relying on a bunch of that, though, things will work fine and the general experience will be pleasant.
My sides, I needed a laugh. Thank you :)
I'm not a Go programmer, but I've been following this particular debate since the announcement for Go 2 was made. I get that a lot of people value the simplicity of the language, and that's perfectly fine. But there's one thing I don't understand: why is it that errors should not get special treatment, i.e., a new statement that optimizes‚Äîfor programmers‚Äîthe common case of returning the error to the caller for handling, but that resource cleaning can have special treatment in the form of `defer`? Go has `goto` statements, so the sort of `goto fail_xxx` handling that is common in C could be used, and that'd be, on a semantic level, simpler. Why `defer` but not `try`? Are there Gophers who think that `defer` was a mistake? When I first learned of the language, I thought that defer was a really cool idea (not perfect though), and I think most Go programmers would agree. Wouldn't `try` in some form eventually become something that people appreciate as they do defer?
rebuild of import package is automatic when you build the main package.
Can you accept `interface{}`
errors is a leaf package (it imports nothing) and can‚Äôt add a dependency on fmt for Errorf. This would cause an import cycle.
You can accept interface{}, but then you lose type safety on the function call and have to resort to reflection with runtime error handling. This is one of the canonical examples of why people want Generics in Go, but you‚Äôll find even though you really want to make this function generic, your app likely only needs this one function.
Are you sure that you need general version of this func in your app? Or it‚Äôs just generalization for generalization?
There are so many of us out there who love the err != nil pattern. It feels almost like the people who complain about the code being ‚Äúlittered‚Äù with these calls and about how they ‚Äúdon‚Äôt care‚Äù about the unhappy path are a minority and likely don‚Äôt even code in Go.
&gt; Yes, you cannot use CGO or user.Current() in a browser (what would the latter even do?) I totally get why it wouldn't work. Just saying that trying to use existing main libraries or dependencies that use it require some updating to work around it. &gt; Yes, you cannot send a GET request with a body in a browser. I am surprised that net/http allows that, to be honest? Why aren't you using a POST request? Because I didn't write the service endpoint and it happens to be a GET endpoint that accepts a json request body :-) Your advice about wasm vs native environments is totally fair. I didn't really mean to imply that anything was wrong with Vecty, and my only comment about that was a kitchen-sink demo would be super helpful for a newcomer. I knew most of my issues were related to translating to a wasm environment, and I was really just reporting on my first experience in trying this out and what I learned. There can be compatibility issues at both the main project level and at the dependency level, if the project is not written 100% targeting wasm. Thanks for this feature for Vecty, btw. I plan to use it again at some point!
I need one for runes another for ints and lastly another for floats, I thought about generics but apparently go doesn't support them
If everyone just wrote basic code like 99% of every go tutorial out there, we'd be fine, and systems would be built amazingly well. It's when people come and try to be clever or too abstract or weird that you get into this "hell is other people's code" problem. It's why any decent shop will have peer reviews, and at least 1 senior who understands that simplicity is a huge part of why Go kicks ass and enforces that ethos across the team. The amount of times I've had some junior do some java code for me, and submit thousands of lines of abstracted useless copy pasta is too many to count. Go fortunately avoids a lot of this because it is easy! Learn to use the err != nil, and bask in the fact you are being productive and making code easy to understand and reuse.
No
I thought the server should return the JSON. It‚Äôs hard to help without the full project brief. You could create the JSON file and store it with the Go files and just have the server serve the static file but that seems too easy, I was thinking they wanted you to generate the JSON with the server.
`try()` without corresponding deferred error handler seems like an easy way to forget to wrap errors, especially for people new to the language ("have an error you don't know what to do with? just `try()`...", seems way too tempting and boom - all context is lost) I think I'll stick to `errors.Wrap()` for now until some solution emerges that addresses that. It could be a linter/vet that forces people to wrap errors in functions that use `try()`. What I find most concerning though is that the proposal appears to recommend that the context included in the errors describes the callee and and not the point of decision that resulted in error being propagated. Most code I worked with I've seen follows this style: ``` func x() error { if err := y(); err != nil { return errors.Wrap(err, "failed to y") } if err := z(1,2,3); err != nil { return errors.Wrap(err, "failed to z(1,2,3)") } if err := z(3,2,1); err != nil { return errors.Wrap(err, "failed to z(3,2,1)") } return nil } ``` as opposed to this (which loses a lot of useful context, IMHO): ``` func x() error { if err := y(); err != nil { return errors.Wrap(err, "x failed") } if err := z(1,2,3); err != nil { return errors.Wrap(err, "x failed") } if err := z(3,2,1); err != nil { return errors.Wrap(err, "x failed") } return nil } ``` Addressing this in an idiomatic way in 1.13 will lead to proliferation of small functions (with named return variables) where a larger function might be much more readable.
``` func Contains(n int, f func(int) bool) int { } func main(){ s=[]int{1,2,3} e=2 Contains(len(s),func(i int)bool{ return s[i]==e }) } ``` This way function Contains doesn't need to know the types of any elements, so it works for all kinds of slices and map. (includes user defined type of slices and map). if you just doing search, I'd sugggest you could just use pkg/sort.Search func Search(n int, f func(int) bool) int https://golang.org/pkg/sort/#Search
Split like this would be retarded move. Fracturing community etc.
It's a little too opaque for my liking. Having to explicitly handle every single error isn't a bad thing but it would be nice to have some syntactic sugar than having to write `if err != nil` every single time. Also the lack of ternary operators is a pain since I can't do a return statement in a single line which is compounded by the error handling problems. Checking err != nil wouldn't be as much a problem if it was legal to write something like `return err != nil ? nil, errors.Wrap(err, "blah") : &amp;Value{val}, nil`
No I feel even more entertained when watching people playing.
&gt; Also the lack of ternary operators One of the reasons Go is so popular is that its easy to write ideomatic Go code where the same problems are solved with the same code. Ternary operators (or handling errors within multiple ways) would be against that because of too many coding styles. For me, the explicit, verbose error handling as it is is one of the biggest advantages of Go.
Maybe pass a struct with 3 arrays and 3 values. If one of them != nil check them and return the bool. One large func with copy/paste insteas of 3 :D
Not sure your whole problem but if this helps. https://play.golang.org/p/2qc_YazQFMN
I've also given them a try and still have yet to find a use case where named returns are genuinely more clear then just declaring a new type. For example I've seen others say that named return values should be used when returning more then one value of the same type such as: func getDeviceLocation() (lat float64, lng float64, err error) {...} So far I still have yet to see an example where something like the following couldn't be applied though: type Coordinates struct { Lat float64 Lng float64 } func getDeviceLocation() (*Coordinates, error){...}
No you cannot. And you must not. Why? Because the function would be broken, buggy. Your code of `func Contains(s []int, e int) bool` is nice, ideomatic and correct, all good, thumbs p, well done! If you use the same code for int32 and int64, e.g. in functions like Contains32 and Contains64: Still fine. Maybe someone told you "don't repeat yourself" (DRY) and you thought I should write that function just once? Well, maybe for the different integer types that is doable and okay. But your code is **wrong** for float64s (and float32s)! Is is wrong on two levels: 1. The first is fundamentally: There are float64 which you _cannot_ compare with == for equality. The set of possible values of a variable of type float64 includes stuff like +Inf and -Inf (they are fine) but also NaN and strange but true NaN != NaN so your code could never detect a NaN value in the given slice because `a == e` is always false whenever `e` is NaN. To detect a NaN you must use math.IsNaN. 2. Is more a semantic problem: Comparing floats for identity is complicated because floats are not exact, the are not integers, not rationals and definitively not real numbers; maybe they could be described as "approximation to a rational". And comparing approximations is difficult. The famous example is `a, b, c := 0.1, 0.2, 0.3; fmt.Println(a+b == c)` where most people would think that a+b actually equals c, but it doesn't because == on floats is "bitwise identity" and not "their numerical value if interpreted as a real number is basically the same". Both problems might never be a problem for your program: If you never store NaNs in your floats (problem 1) and if the value you look for really must match on the bit level (problem 2) or your values have exact representations as a float then your code would work correct. But I think this is a very bad practice. Even if you could write one generic function handling different ints and floats with the same code you would hide the fact that that function is subtly broken for floats under a bold-promis name "Contains". DRY! Is the single worst advice as it produces so much harm. Probably it is better clean up _after_ you have written the same code several time and it really is the same code. For floats you typicall have to write different code to be correct.
Cool! üëç Thanks for sharing
[removed]
I am writing my first 2 webservices in Go, found xerrors pretty early and it's really good, but generally libraries don't support wrapping so one can't use it to the fullest. It's not bad though(and I come from tracestack-everything Java), I have my logs correlated and it looks like it all works fine. I'm not sure try solves any problem, I would like to see xerrors + some mechanics to allow calls chaining or just generics so it would be possible to simply write some sugar for people who feel like they need it.
The more i use Go the less i need any featured web server :) !
very less cognitive overhead of configuring/reading a config for maintainance
Opaque is the wrong word. Poorly understood abstraction resulting in shit implementations of a fundamentally viable and valid approach. Thus, the opaque nature directly derives from ether bad engineering or laziness. Which is usually the case. Rarely is opaque code the fault of the language. That being said, golang doesn't give you the tools to leverage the abstraction they expect you to take with errors (as you said), so that contributes. This doesn't mean the abstraction is bad or inherently opaque. This is distinct from opaque callback hell in JavaScript. That is totally js's fault. :P For my other love of a language, python, it's super 'readable' but also often used as a lazy 'goto' system of program by interrupt. some of the most unreadable code I have ever seen abused this. One piece of code I audited monkey patched an exception handler into the main function through import side effects, which caught an expected exception when you ran it in windows or Linux (Dev used mac) to retry loading the config from a different directory. None of this was documented and I only found it through running a debugger before the first import statement.
I can't tell you that it makes sense, but I can at least tell you what's happening in that stack trace, so you can decide where to investigate more. Your program was garbage collecting when you dumped the stack trace. The garbage collection was triggered by an allocation in the math/big package, during the process of checking a potential RSA private key for primality. This is a normal part of making a new certificate, so no surprises there. While it is true that finding an RSA private key is computationally more difficult than finding an EC private key, I've never experienced a significant CPU or memory problem, not enough to hang a system and need to debug it like this. But if it's easy for you to try, you could change to using an EC key. See [https://sourcegraph.com/github.com/golang/go/-/blob/src/crypto/x509/x509\_test.go#L533](https://sourcegraph.com/github.com/golang/go/-/blob/src/crypto/x509/x509_test.go#L533) for an example of how the Go tests make an EC key for the P256 curve. Was this a one-off hang, or can your reproduce it? Good luck, tell us what you find!
Architecture is a discipline, and at a certain scale having a person who is driving that discipline among multiple teams is not dead nor even dying. The classical, ivory tower type of architecture is indeed finally starting to die out, but that's also not what architecture is today.
I'm seeing this attitude less and less as time goes on. The language performance and speed of delivery for go applications is incredibly enticing versus a language whose smallest distribution is in the hundreds of megabytes requiring gigabytes of RAM for exactly the same set of operations today.
I find the error handling in Rust a little bit better
Taken from https://github.com/golang/go/issues/32437#issuecomment-508357911: // After. a, err := foo() try(errors.Wrapf(err, "some message %v", b)) That's a way to wrap while avoiding the if.
Just great. Let's fix error handling by adding builtin function that enforces bad style and goes against best practices of actually dealing with errors, because *if != err* is the main problem, not the fact that most of go errors are strings without context.
When you'll work with a great DBA you'll miss them at your next job.
&gt; having to write if err != nil every other line (this also messes with code coverage in unit tests). This means you're only testing the happy-path! Error handling can absolutely (and should) be covered by tests.
Post the repo link, not the readme...
Manager C: You forgot about Scala
[removed]
Let's be honest, go is great if you are coming from Python
In many cases the Enterprise version doesn't have to be, and often is not, the same as the community version. Why bother contributing to such an unfair relationship?
Comparing Rust generics to Go interfaces, I clearly understand why we don't need that spaghetti code they do have there. To specify T to be some trait, which is in turn is another trait is a pain. Whilst in Go type guessing keeps you from all that mess. You can argue that Rust generics give you the compile time error instead, well, Go teaches you to unit test your code -- a routine too many people trying to ditch. You can write your own iterator, God bless you, why do you need that thing. And it's still going to be pretty much easier with reflect.MakeFunc specifically. Week type system? Hmm... Ahum... Why do you think it's weak? It doesn't allow you to set even int32 value to int64, what's so weak about that? And if you talking about type guessing, see the do the unit testing thing above. Go standard library is really and truly a tremendously powerful instrument to achieve any possible goal: ‚Ä¢ Enumeration replaced with iota -- is a deal breaker for me. I love it. It's powerful and amazing. ‚Ä¢ Go routines together with channels and sync package -- are the most beautiful way of handling the concurrency. ‚Ä¢ And of course a syscall (which is now under x section), which has ...Syscall... functions implemented in assembly, rather than relying to a system libc. Rust supports assembly calls in nightly builds only, otherwise requiring a system libc. Have you seen the boilerplate in Rust to build something for different architectures or operating systems? Holly Molly, it's a nightmare, comparing to Go where it can be done with a single line of code or even with a filename only. Oh, yeah, and one more thing, speaking about the Rust, to have a raw string defined as a field you need those life times defined, which may seem as a good idea, right until you face a point where you need to differentiate between more than two life time. Whilst in Go it's just another field. Well, obviously I'm in love with Go =)
Ha, yes sir, all in, balls deep. Honestly, I bailed for a roll your own approach about a year back.
Please don't make me embarrass you and matt.
&gt; this also messes with code coverage This is completely backwards. Unless you're using a tool that reports code coverage by expressions within lines instead of line based then having a error checks/handling on a separate line (and separate lines for the branches of a ternary operator) make your code coverage reports more accurate indicating which errors and branches your test cases don't cover.
Yep, architecture nowadays just seems to be about various patterns people use to organize code, data, information or people to manage the complexity that comes with scaling things up. One thing I'm liking about the current state of discussion in the industry is that it's more about comparing the pros and cons of these patterns for different uses cases rather than people trying to sell silver bullets. Not trying to say that there aren't those hype merchants still around trying to sell empty promises. But it seems that there are more people who've woken up.
Named returns can't be removed because then it would be impossible to recover from a panic by turning it into an error, no?
We'll all miss you...
Ahah I'm not one.
In a similar vein, the "Contracts" aspect of proposed generics is not orthogonal to Interfaces. It's more like "Interfaces, this time additionally with something to say about symbolic operators!".
Why reflection? For values, can‚Äôt he use `==`?
Nice. Any comments on [https://github.com/ryanbradynd05/go-tmdb](https://github.com/ryanbradynd05/go-tmdb) , and why you decided to create your own?
At my current job we can‚Äôt even create an index on our DB with engaging a DBA. I will not miss that
Exactly. What I really liked about Go is that it made you approach problems thinking in a different way. If there were just the concepts from other languages, but with a different syntax, there'd be no good enough reason to pick up Go.
&gt;Can someone tell me what generics can do that interfaces cannot be used to implement today? No, for pretty much the same reason that you can't tell me anything you can write with with go routines that you can't write with something pthreads in c. Just because something is equivalent in what you can do doesn't mean it is equivalent in terms of expressive power or ease of use. To give an example of something which is much (much) nicer as a result of using generics: go channels are generic (i.e. chan int is a different type to chan string). They're much nicer, both to use and than they would be without the use of generics.
Yeah, I do agree with that. In fact, [even the `mov` instruction is turing complete](https://github.com/xoreaxeaxeax/movfuscator). But I'm not arguing about what we should write. I think the value actually comes from when we read the code. Just like you said, we have programming languages to make programmers more productive and we have features in a language to make programming languages more expressive. But I would argue that even though more features make languages more expressive, they make reading the language harder. For example, I think c++ is a very feature-rich language. It allows the programmer to approach the problem from a lot of different mental models of approaching a problem. but I really think c++ is way less readable even compared to C, simply because there are so many ways of doing the same things, as opposed to C where there are fewer. I should've made it clearer in my post but like I just mentioned, I think that's where the benefits of having very few ways of writing a solution to a problem comes from. And since we read code more often than we write it, I think it makes sense we put readability first.
Are you really sure you want == for floats?
What search terms have you tried? I found [this](https://github.com/suedadam/GoWall) 4 year old project with no tests and minimal docs, but it meets your requirements: implements a firewall (with iptables) and in go.
As for project folder layout, have a look at this [sample](https://github.com/golang-standards/project-layout) project.
I think that the last pull request on [https://github.com/ryanbradynd05/go-tmdb](https://github.com/ryanbradynd05/go-tmdb) was mine. It's a nice wrapper. I decide to create my own pkg to practice :)
I‚Äôm looking for something that is more like iptables in go
I AM going to ask you why you don‚Äôt have access to electronic payment forms, and why you can‚Äôt give a friend some money who does have access on your behalf if you‚Äôre truly unable for some strange reason. Why don‚Äôt you have access to electronic payment methods? Why can‚Äôt you give money to a friend to do it for you? How are you even on a computer? Why are you asking for free stuff instead of supporting an obviously valuable learning resource?
&gt;However, the amount of free materials is not the same for Go as for Python... This is probably correct, but mainly because python is waaay older than Go. What is the reason you want to get access this specific course? What do you want to learn? If you can be a bit more specific, people will have an easier time sending you in a direction.
I have been using this one to structure my project but I was having a difficult time finding some completed projects which used this architecture and served a similar purpose as the project I have in mind. Do you know of any easy to dive into projects that I can look at that use this type of architecture?
I'm no language expert but it seems to me i'd prefer to have an anonymous code block or defer that can be setup to handle errors by default. So much more readable.
If I understand it correctly, I don't believe you could do much in pure go. You'd have to do a lot of cgo to build a go interface to the kernel's netfilter. Which I can only imagine is very cumbersome to program against directly, hence why everyone just builds tools to wrap iptables because it already does the heavy lifting.
https://en.wikipedia.org/wiki/Elvis_Grbac
Ehm, what exactly are you trying to do? And you don't need tags to differentiate between function and a field, reflect.Type pretty much gives you all information you need. Another thing which is not exactly clear, if you're copying one struct into another, do you know the structure in advance, if so, why not using type guessing instead. If not, than how can you be sure that a struct has same field names and method names? About the methods, speaking, for example, if you creating a runtime defined type with reflect, make sure that you properly read input arguments, return values and store a pointer to the original method and it's object , because otherwise there's no way to copy a function, if you don't know what actually it does.
Thank you for asking.
Did I just see a for true {} in go? Oh god :s
&gt; What is the reason you want to get access this specific course? What do you want to learn? 1. Because I think it would be very difficult for me at present to learn Rust. :) 2. Because I learned the basics of Flask and Django. Thank you for asking.
I've worked on a couple of projects with Go and netfilter queue. It is pretty straightforward, actually. There are a handful of NFQ packages on GitHub, but you need so little functionality just to get the packets flowing through userspace that I wrote my own with cgo. Coupled with [https://github.com/google/gopacket](https://github.com/google/gopacket), and you can be writing custom firewall logic in no time. &amp;#x200B; /u/lukekhamilton \- can you say more about what specifically you're trying to accomplish?
If the free version does everything I need, why not?
Hey! I pmed Todd McLeod via Twitter and got a discount link from him! It only costed $5,75.
I have an object loaded by GORM from a database which I have to transform to an object which is managed by Protocol Buffers. Since in the future I will probably have a lot of these "couples", I thought it was a good idea creating a "common way" for transformations. Tags are used in three ways. * Fields which should not be transformed can be marked as "-" * Fields which have a different name on the destination can be marked as "field:name" * Fields which must be preprocessed can have a linked function "fn:name" which is called on the first structure with a string (the field name) and the value of the column. The return type has to match the second structure field type What do you mean with "type guessing"? Thanks for your comment!
I hope you did understand that I will not be able to transfer *any* amount of money. Nevertheless, thank you for your initiative and for McLeod's generosity.
Just curious, what were the criteria that caused you to select Caddy over Traefik? I've been using Traefik for a few years and really like how easy it is to use and configure.
I wasn't sure how else to solve it, how would I keep updating the DB for an indefinite amount of time? &amp;#x200B; Ok will do, will sit down today to make the whole program nicer and more efficient.
Am I the only one who cringes at the word "coding" or "coder"?
I hope you did understand that I will not be able to transfer *any* amount of money. Nevertheless, thank you for your initiative and for McLeod's generosity.
Well you may use `for {}` and for the program, well, I assume you don't have some of the linters and formatters that go uses, like gofmt, but esentially, in every programming language style guide, there's a max-line-width that should be followed. In fact, your current editor have a vertical line just for you not to go beyond it :D
No.
Also on 4:16, the if... else if... else if are all using the same variable (i) and it's an integer, therefore, a `switch (i)` will be much more readable, and in some cases (I have no clue if go actually optimizes this) can be optimized by the compiler into a jump table.
You don‚Äôt care how errors are handled? I would never want to work with you.
First you have to learn programming. You can use go as your starting language but I'd suggest starting with something like python as there are plenty of absolut beginner tutorials/guides. &gt; ''In how many weeks can I master Go? Haha'' Mastering the language wont be the biggest obstacle but learning programming. I don't know how technical you're versed but you'll have to learn a lot of concepts and those can be hard to grasp at first. e.g. to know how to code a webserver it's not enough to know the language of your choice but you'd have to know what a webserver is and what it does and how it does it. Regarding learning programming with go as your first language: the go community is split if this is a good idea leaning towards that other languages are better suited for programming novices. Go does things a bit differently and you wont be able to appreciate it simplicity, scope, stdlib etc without knowing other languages/other language concepts.
\&gt; What are things most beginners do wrong while learning Go? First learning to program - no matter the language - beginners tend to do one of two (or both) errors; \- Overthink a problem trying to tackle it head on rather than break it up into smaller parts. \- Get too ambitious too fast. Keep it simple. \&gt; What are some good resources to learn Go as a complete beginner? I'd go visit a University/College Academic book-store and actually buy a book on Programming for beginners. Preferable using Go as the example language, but it isn't really too important. Trick is to learn to think as a programmer, not learn the details of a given language implementation. Either way - you'll need to develop some serious google-foo. Searching for answers to a problem you're stuck with is one of the most important (junior to intermediate) programming skills. \&gt; What other things do I have to learn, if I want to master Go? Hmmmm, well. The editor and the CLI (Command Line Interface). For the former I'd suggest using VSCode - it works perfectly with Go. For the latter, whilst I can't praise Bash high enough as the programmers best friend, if you're on Windows just learn to use CMD (or Powershell) to good effect. The Apple people got their ZSH Terminal. First important tool in the CLI you want to get friendly with, is Git. You don't want to add extra weight to the burden by also changing OS - so stick with what you know the best and are comfortable with. \&gt; ''In how many weeks can I master Go? Haha'' Weeks? After a few weeks you may be able to solve little 'puzzlers' that come in at under 100 lines of code. Give it a few months, and you can move on to more practical projects that'll run up to a few hundred lines of code. To be really proficient - without prior programming experience - maybe two years of constantly challenging yourself.
Well, once more again, there's no way to marshal an arbitrary function no matter how you handle it into a permanent storage and to unmarshal it back. If a function is a field on an object you need to work around and find the ways to store it, unless you don't own it, in the latter case you'll have to omit it on marshaling and unmarshaling, or in other words on converting from a database object into whatever else. If your objects don't have functions to store and you want to create a runtime defined type with a method to return the field value, or if there's a known structure with a field storing a function, you still don't really need the tags, reflect.Type and reflect.Kind will do that. If you want to create a generic function with at least approximately known in advance types or least kinds, you can try dealing with reflect.MakeFunc to ease method creation. But I'd rather suggest using interfaces and the type guessing, which is a technique to guess the type of an interface to extract the underlying type value. For example: ``` import "io" type Foo struct { i int32 } func (f *Foo) Read(to []byte) (int, error) { // do something here } func (f *Foo) Init(i int32) *Foo { f.i = i return f } func main() { f := new(Foo).Init(13) i := bar(f) // i == 13 } func bar(r io.Reader) int { // type Reader is an interface return int(r.(*Foo).i) } ``` The `r.(*Foo)` is a type guessing, which assumes that io.Reader is implemented by *Foo. It's a short form. The full one is `f, ok := r.(*Foo)` where ok will be true as long as the r is implemented by the *Foo. There's also a switch statement based type guessing for which you'd better to read the language reference or take a tour. So, to summarize: there's no way to store and retrieve functions; if you defining a runtime type with a public getter you'd be fine without tags; if you know the structure of each object in advance, try using MakeFunc; finally, try to incorporate interfaces and type guessing instead.
Well, I'd say you give a realistic impression of building a project. I'm sure a lot of newcomers would appreciate this.
My structures are not defined at runtime. Both structs are data-only, and are fully defined in different packages. The thing is that I have to convert struct-to-struct, sometimes using functions for processing. Functions are defined only on the first struct, the second struct is actually defined by Protocol Buffers compiler so I cannot edit it to include GORM tags. Let's say I have two structs: ``` // GORM struct type Data struct { ID int Name string Date string // as YYYY-MM-DD HH:mm } // Protocol Buffers struct type Message struct { ID int Name string Date int64 // unix time from epoch } ``` All I'm trying to do is convert Data into Message using tags for "non-standard" conversions. For instance, converting Data.Date to Message.Date requires a string-to-int64 convertion which is made by a function. I don't think I can use interfaces and type assertions for this matter, am I right?
&gt; **To be really proficient - without prior programming experience - maybe two years of constantly challenging yourself.** This cant be overstated! If OP already knows what project you want to be working on expect to start in 2 years if you're a really good. The step from "knowing how to programm" to "actually working on projects" is huge! There is just so much to learn about the whole ecosystem and like /u/Zy14rk said you have to be constantly challenging yourself. Just think about all of the stuff you already know but dont really. Like you know files exist but probably not what a file actually is. To learn about files you learn about file systems and to learn about those you learn about how an OS actually works etc. There are quite a lot of topics you need to learn about to be able to understand how programming works. The more the better. The inner drive to learn more is crucial to become a good developer because this is what we all do constantly.
I don't have that reaction, can you explain why?
Thanks, that's what I was aiming for with this video. Showing how to approach/conceptualise a project and then working on it.
Well, if it always going to be just Data and Message, you can simply convert them without reflect. If there's going to be more types on both sides where you need to convert int64 to string and back, I'd suggest using tags just to mark those fields not to convert other int64 field possibly present to another possibly present string field. If the types are going to be different, but you would actually need always only int64 to string or vice-versa conversion, there where you will better be suited by interfaces and type guessing.
Thanks for pointing that out, I didn't know switching can be more efficient compared to if's. &amp;#x200B; The code is not yet published anywhere, my plan was to make it nicer before making the repo publicly available.
That's the whole point: in the future I will probably have many more of these convertions, which I don't know right now, and many more of these "couples" of structs which must always be converted in only one way (ORM to ProtocolBuffers). What I aim for is building something which I can reuse endlessly without the need to build a new function for every struct. Thank you very much for your patience :)
KISS keep your structure as simple as possible. Adapt your structure when necessary but don't worry too much from the start but rather focus on building strong interfaces. This way you're able to refactor more easily later on and adapt the structure to what is needed. Because you didn't start coding yet you can't even imagine all the problems you'll face and wasting time precautionary structuring a project won't save you any time later on. tl;dr: Just start with the simplest structure possible and evolve when necessary
Sorry. I skimmed through your post and didn't read that part.
&gt;er it' Thankyou!
Cool just take your time. However, if you plan on publishing the work for open source, it's always good advice and practice to start pushing stuff from day 1. Nobody will judge your skills based on an unfinished repo or some messy code that is in fact under very active development. In fact, by not publishing it, you lose some potential early contributors that may lead you towards better project structure (and this is something really bad to change afterwards) and perhaps better code. Regarding to the switch stuff, this is something I doubt go is focusing on (the optimization) but it's something that it's even more readable. Also, if you ever code in C, C++, Rust, etc. Switch statements / (or match statements in rust) are often optimized into jump tables when the number of cases is significant enough. In cases where a few items exists, it's most likely to generate the same machine code as the ifs (simple branching). However, don't bother that much about speed, this is premature optimization. Just code as if you were developing a library that most people will use and inspect. Readability often beats speed in most non-critical projects :)
It‚Äôs like calling your chauffeur a driver. Rather be called a Software Engineer than a coder.
Same feeling, also, I agree that `defer` hides where the error happens, if they don't "fix" the stack trace stuff with something built-in, (without frames dance stuff), I guess `x/errors` already achieve this (I hope). What I'm currently doing is, with the `pkg/errors` package, I return all my errors with `errors.WithStack(err)` and then my logger prints the stack trace: `fmt.Fprintf(c.Logger().Output(), "%+v\n", err)`. I would love something ala swift in the near future, like marking funcs using the `throws` keyword, that would remove the need to return `error` interface at the end of each func, and the `try` keyword, preventing error var shadowing (which I personally hate), something like this: // this func throws an error func a() (int) throws { throw &amp;someError{} } // if you don't use `try` the compiler warns you cause you are not handling it anInt, err := try a() if err != nil { fmt.Fprintf(c.Logger().Output(), "%+v\n", err) } Just some brain-fart here, but I think the `try()` func and `defer` mechanism makes readability worst
That's pretty interesting. So instead of manipulating nf for the firewall, you're saying to only do enough to get the packets into user space and then implement the firewall there? What implication does that have for performance and security? I know full user space network stacks perform very well, but wouldn't this route add more context switches to the life of a packet? As far as security, how early in the packet's journey can you get it into user space? Would it leave you vulnerable to any kind of crafted packet attacks that you may be able to catch early with iptables?
Thanks guys! Very useful info! Guess this is not a ride that can be completed in 40 weeks, what I thought to be enough if I spend 4 hours a day on learning Go
what's another option?
I read through another thread, and saw that Todd McLeod Go course is really appreciated. Got myself the course, and I guess that I will be completing that course for a while \^\^
This comment made me smile, thanks. :)
Some people might say that you can only call yourself a software engineer if you have such a university degree or have that as your job title. Coding is more informal IMO and applies more generally.
Well, if you own both packages, consider adding interfaces, for example: ``` type DataTimer interface { IntTime() int64 } type StrTimer interface { SetTime(string) } ``` And then create a function: ``` func Covert(dst StrTimer, src DataTimer) { iTime:= src.IntTime() ... // do conversion to a string dst.SetTime(...) // use converted string } ``` OR ``` type IntTimer interface { IntTime() int64 MyName() string BoolValue() bool } type Foo struct { Time string Name string Value string } func (f *Foo) Convert(i IntTimer) { // do the proper conversion } func (f *Foo) RConver(i interface{}) { // use reflect instead } ``` Then you'd only need to ensure each source type implements DataTimer and each destination type implements StrTimer. Of, course if you insist on using reflect package, you can use the initially suggested by you approach, yet, it seems like an overkill. Since you'll be implementing the conversion method anyway, why not to make it public and let it be the part of interface.
This may be helpful: https://dave.cheney.net/resources-for-new-go-programmers
Ok so, if I understand you correctly, you suggest augmenting current structs with interfaces in order to simplify convertions instead of building a all-around object "copier". I could add methods to the object generated by Protocol Buffers, as long as the files I create belong to the same package, is it correct?
Yes, it adds a sense of sophistication and that‚Äôs my point. I disagree with those people as you can call yourself a Software Engineer if your end product is Software. A coder would suit a biologist writing a Python script to analyze samples for instance.
Yeap. Exactly. More over, if, for example, you don't own the other package, you still can define an interface as long as all objects in question implement the defined methods of that interface. So, if you have external package where each object has, for example, GetFoo method returning a string, you can define: ``` type GetFooer interface { GetFoo() string } ``` And use it as an argument type.
Yes I got that one, and I personally think that it is a great feature :) Thank you very much for the insight, I really appreciated it :)
You're welcome, no problem.
And if you want to play around a bit, see reflect.StructOf and reflect.New.
You may want to implement a socket filter with https://github.com/dropbox/goebpf.
seems like a meaningless distinction just for the sake of your ego. My official job title has been a lot of things but if I'm writing code, then I am coding. I write code for a large part of my work.. I am a coder. I also do some other businessy stuff but I think anyone that cringes at a an effective way to describe an activity because it doesn't sound fancy enough for their ego needs to get a reality check.
Sorry if im being a noob now, but what happend to xerrors? I kinda liked the idea of wrapping the errors with context and just returning it up the stack.. or is this entierly unrelated?
You can try it out here: https://ccbrown.github.io/go-web-gc/server/ Be patient, it's noticeably slower than local or server-side compilation. I don't know if there's any point to this; I just hadn't seen it done yet and was bored.
So, once upon a time switching was slower than a block of if else of blocks, this however has not been the case for a long time and will be compiled out in pretty much every language. But, on another note, if you find yourself writing an else, ever, take a step back and think about refactoring your logic into separate methods :)
Isnt it more boilerplate than json.Marshal?
Your playground is really effective at crashing Chrome. I've run into this several times already: https://i.imgur.com/Z3U88PP.png That's a totally fresh Chromium profile with no add-ons. This program triggers the Chromium 73.0.3683.75 bug after clicking "Run" a few times: package main func flip() int { a := make(chan int, 1) b := make(chan int, 1) a &lt;- 0 b &lt;- 0 select { case &lt;-a: return 0 case &lt;-b: return 1 } } func roll(n int) uint64 { var v uint64 for i := 0; i &lt; n; i++ { v |= uint64(flip()) &lt;&lt; uint(i) } return v } func main() { println(roll(10)) }
It is probably better that way, if you teached yourself python, you are not a novice anymore, and Todd has a talent for putting people to sleep. Check awesome go on github, and there are plenty materials use golang as search keyword. I bout some course of his but never got to the end. Lost me at the part explaining the symbols behind the power button. I will save this post and I will check later if I have that course, I will donate you my account.
Well, both do a really good job, but Traefik is "only" a proxy while Caddy is also a web server. The differences that made Caddy more suited to my problem are: - Easy configuration through a file or multiple files (Traefik is usually configured using labels in a docker environment with full access to the docker socket, which I do not want. Configuring Traefik through a configuration file also just felt wrong [and multiple people said it's not the way Traefik should be used]) - Caddy also serves static files (which eliminates, in my case, already three additional Nginx instances I'd need if I'd be using Traefik) - Optional fpm support (just a nice bonus, right now I don't even use it) Also, Traefik had a few routing problems that nobody could solve (on a fresh Ubuntu server installation, I've asked for help but the configuration seemed right. No idea why it didn't work as reliable as it should).
That is the way the projects I worked on were implemented, yes. It leveraged iptables' CONNMARK functionality so that it could flag an entire connection as either blocked or allowed, and once the userspace process had made a determination, the forward/drop decision was made in the kernel. The system was not deployed in a performance constrained environment, so I can't speak to how well it would perform compared to something like a BPF filter that keeps all logic in the kernel. The system provided egress connectivity for 100+ servers and containers on a micro ec2 instance, for context. Security-wise, the only right answer is to analyze your threat model and make a determination based on the trade-offs. On the one hand, you're introducing new variables and home-grown code (that will never be as battle-hardened as e.g. vanilla iptables or a commercial security product) into your security model. On the other hand, you're able to have very fine-grained control over the system and implement it *precisely* how you'd like it.
I'd like to know how many dev teams adopted MongoDB and other "schemaless" databases just to bypass DBAs.
no joy, I only have this one: https://www.udemy.com/course/learn-how-to-code/ I can recommend: https://github.com/astaxie/build-web-application-with-golang https://github.com/avelino/awesome-go
A nice idea for a first Go (not golang ;) project, and your code [achieves an "A" on goreportcard.com](https://goreportcard.com/report/github.com/ttauveron/git-follow-up)!
Essentially what my team did we went with couchbase just to avoid the database team. We can essentially put arbitrary data in but to create indexes we have to engage the dba team. We can query programatically through sdks to circumvent that which fits our needs. Ideally we should have gone with postgres but engineering decisions are now being decided by bureaucracy
You can also use ‚Äòtime.NewTimer(interval)‚Äô to create a ticker that keeps updating at a given interval * https://golang.org/pkg/time/#NewTimer You ca use it like so, ‚Äò‚Äô‚Äô t := time. NewTimer(time.Second) for range t.C { // your code goes here } ‚Äò‚Äô‚Äô
Me neither, but I am not a native speaker, that's perhaps why... I would be curious to know what negative connotations these words carry.
You can get quite far in 40 weeks though! You will be able to code many things, but it will take several more years to become truly efficient and experienced.
Thanks for your feedback! I didn't know goreportcard, that's a pretty nice tool :)
Awesome stuff dude! The editing in this video is really amazing! One minor point is that the source code you show off is very small, it might be worthwhile increasing the font-size or adding zoom-in effects so that you can better show off the code! Keep it up though, it is awesome to see more Go YouTubers! :D
FWIW, I hope you keep going with this, keep coming back here with updates and showing folks where you're at. This is a great idea, and will be really helpful to up-and-coming developers who might be nervous about getting started -- then when you're done if you release the source you contribute something awesome to the community (and not incidentally raise your profile if you're trying to get hired :) )
Nice!
Just wait on the done channel of the context of the request: &lt;- request.Context().Done() This will block until the client closes the connection. This way the go routine can be stopped on disconnect.
I'd that grumpy to tell the article author those four magic letters to pick up: R. T. F. M.
A browser preflight is an OPTIONS request. Hopefully that hint is sufficient.
Yeah I'm also not a native speaker, that's probably why.
Please read through the Stackoverflow post carefully!
Thank you, I really appreciate it :) Yeah I realised afterwards that the font size is too small when watching at lower resolutions. I already zoomed in where it was possible but in the nex video I will just increase the font size.
I'm glad you liked it \^\^
I'm on 75.0.3770.100 of Google Chrome and I didn't encounter the bug. I'm guessing whatever issue you're hitting has been fixed in more recent versions
Thank you so much for the kind words :) I'm really motivated to work on this series and make it great for new developers.
As per the docs: &gt;Go has no line length limit. Don't worry about overflowing a punched card. If a line feels too long, wrap it and indent with an extra tab. It is up to the developer to enforce a rule with a linter such as lll. Even then, you must fix it manually.
Ofc thid is not part of the standard. This is code style. In every lannuage. Most ides comed with that vertical line to help you.
Apparently that hint was not enough for you. Please read up on CORS and browser preflight requests. You are handling for GET requests, not OPTIONS requests.
I'm sorry to see that the gazette editorial is leaking an anti-try bias. It makes it much less pleasant for us in the pro-try camp. The first quoted tweet article doesn't even contain an argument; it's just whining with a click-bait title, and has no value. The second tweet links to a tithing "proposal" which doesn't meet any of the defined standards of a proposal. It's more whining. If you're going to push the anti-try agenda, at least link to articles that contribute something useful to the discussion.
Thanks for doing this! I cant wait to see more
 [https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/](https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/)
Thank you for your nice suggestions. I watched all the sample videos of the course I mention and I didn't get sleepy. On the contrary, I found them very challenging.
[https://github.com/evilsocket/opensnitch](https://github.com/evilsocket/opensnitch)
Isn't a software architect the same as a full stack developer?
So it's good for storing a lot of png files on a file server but you have to convert it to png again to be able to show it in browser?
Nice video! Have you considered https://github.com/shirou/gopsutil/ for system metrics?
Just read the try-proposal now and I hate it. Defer an anonymous function to add context to errors? Really? Just include pkg/errors in the standard library (as is), done.
Oh, someone actually made it. That's both amazing and appalling at the same time!
 &gt;Well, obviously, I'm in love with Go =) You could have just led with this and saved us all from reading this terrible answer.
It's an editorial, expressing your opinion in it isn't "bias" or pushing an "agenda", it's the nature of an editorial.
I actually looked into this when I made Operation Go (http://www.gocode.io). I needed a playground that users could edit code right from the browser. In the end I couldn't get the performance right, so I went with my other plan of making a POST request to the office Go Playground. They ask that you Email first for permission and put set your HTTP referrer to your site and then you're good to go.
That's awesome! I was literally working on the same thing but ended up giving up. I was running into a weird error where the compiler would exit with status code 4, but I couldn't figure out why not could I get any kind of stack trace.
That's go's style guide as well tho
But it makes no sense to make a proposal to reject another proposal. Accepting this proposal is the same as rejecting the `try` proposal. That's the point op was making.
Its just a research project at the moment to see, one is this possible in go and two then to learn more about how.
Thanks all for your input this is heaps for me to now dive deeper with. Peace
Firefox on macOS goes well.
No, to use that in browser we created a tag simply which can be used. Check this repo: https://github.com/manishsingh10895 Already working on how we can show it in browser without converting in png.
&gt; You can write your own iterator, God bless you, why do you need that thing. Sometimes I want to iterate over a list of things, or it's convenient to be able to separate the 'how do I produce a new value?' code from the 'what I do with those values' code. Granted the CSP in Go to some degree replaces the need, but Rust doesn't want to be tied to any particular async model so it's not going to first-class its channels the same way or encourage their use so prominently. &gt; Go routines together with channels and sync package -- is the most beautiful way of handling the concurrency. Perhaps it is the most beautiful, but whether it is or not it's most definitely not the only model for concurrency, nor is it universally applicable. Rust and Go are just fundamentally looking to be different things in this respect, and the fact Go provides straightforward and first-class support for CSP is great for what Go wants to be, but is entirely unacceptable in some of the domains Rust seeks to inhabit. &gt; And of course a syscall (which is now under x section), which has ...Syscall... functions implemented in assembly, rather than relying to a system libc. Rust supports assembly calls in nightly builds only, otherwise requiring a system libc. Yeah it's unfortunate that right now the inline assembly is still considered nightly only for some users, but why exactly is it you care about not using a libc? Linking libc can lead to a smaller library (don't need to inline stuff that's shareable) *and faster* (both because of hyper-optimization in projects like glibc, and things like Linux's [vdso](http://man7.org/linux/man-pages/man7/vdso.7.html)) binary. Is it less portable? Sure, a bit, but glibc is a pretty safe bet for any Linux... but maybe you really want it all self contained, fair enough, let's take an example like [this rust program](https://pastebin.com/yQCbfTNX). It weighs in for me (after stripping debug symbols) at 200K for the standard build which links glibc. If we statically link musl libc it balloons up to 240K, which still isn't too shabby. It's not hard to do a static link, and it gets you to the same level of portability as Go for doing so, but unless you really anticipate copy/pasting the binary around between disparate machines you're better off linking libc. (Which is no doubt why linux distros that let you install big go projects from the package manager build those projects to link against libc). &gt; Have you seen the boilerplate in Rust to build something for different architectures or operating systems? Holly Molly, it's a nightmare, comparing to Go where it can be done with a single line of code or even with a filename only. if cfg!(target_os = "linux") {} #[cfg(target_arch = "x86_64")] fn foo() {} #[cfg(target_arch = "aarch64")] fn foo() {} &gt; Oh, yeah, and one more thing, speaking about the Rust, to have a raw string defined as a field you need those life times defined, which may seem as a good idea, right until you face a point where you need to differentiate between more than two life times. &gt; Whilst in Go it's just another field. Go doesn't really have an analogue to the Rust `&amp;str` type at all by the nature of Go being garbage collected and it only having a `string` type which is backed by a slice. Rust doesn't have a garbage collector, and to some people *that's an important feature*. If you really don't care about the impact of a garbage collector or care about the potential performance gain of sharing memory without incurring any reference-counting or garbage collecting costs then Go will do just fine for you! But some people have other wants and needs, and for them there's Rust. (Or C/C++ and being careful to ensure you never end up with invalid pointers.)
This is very cool, nice work! I haven't tried large programs but it seemed pretty snappy in stable Chrome on macOS. I knew that one of the challenges would be that `cmd/go` is a command without an external public API, so it was interesting to see how you resolved that. For reference, the GopherJS compiler has also had a Playground that ran entirely in the browser. Although it's facing a bit of an existential crisis now, because adding support for modules to GopherJS will likely require using the `golang.org/x/tools/go/packages` package, and that package shells out to `cmd/go`... But neither GopherJS nor Wasm support spawning new processes. Perhaps a similar approach can be used to make it work. One last thing; in case you decide to work on this playground further and add snippet sharing to it, feel free to reuse the same snippet server as GopherJS uses at https://github.com/gopherjs/snippet-store. (It's a really small and simple program though, so it's not going to save you a ton of time. But still, I figured it's worth mentioning.)
If you want to iterate over a list of things there're container subpackages for you, and list package specifically. And you're free to do it any way you like. If it's not, what you're looking for, define an interface and reuse it's application among your projects together with an implementation, which will be the same as with Rust since iterators specifically are not the part of the language, but rather a module of a standard library. Well, yeah, I can imagine sometimes instead of dealing with concurrency with a single word you need to initiate the process with couple of lines to access the same convenience sync package gives. Speaking of which, sync has a Pool which gives a more accurate control over the garbage collection, heck with it, attach a runtime.SetFinalizer on some kind of Init method and you got yourself a good garbage collection assistant, for the times you need to control memory allocation and deallocations, for example, on a particle generation. And Golang developers run a pretty good magic in reducing the `stop the world` event down to an absolute minimum, mostly doing the clean up in another thread. And, yeah, you're right: `#[cfg(not(any(target_os = "windows", target_os = "mac")))]` -- it's the same way of convenience as `// +build !windows !darwin` -- absolutely, no questions here.
Why was it terrible? Because you couldn't cope with the fact that Go is brilliant, nah... You probably had another reasons.
Maybe you can "Go" make pennies from your underwhelming blog posts elsewhere.
Neat, however, I'm not compelled by "I don't like javascript so I made up a string based html templating language wrapped in go". I don't quite think you're playing to its strengths,
That's pretty neat!
Your answer sucks because it is shallow and rather boring. It has nothing to do with Go itself, despite the similarities.
The thing is - programming isn't a static skill. It is - for most anyways - a passion. Something one do because one enjoy it. Because one have a mindset that solving problems and learning new things are worth it. Fun even. &amp;#x200B; I know - in this day and age, many go into programming for the same reasons that people go into finance or law - Moneys. It is a high profile occupation that with success do come with very good rewards. But to reap those awards require passion. &amp;#x200B; Just because you got a law degree and are allowed to practice by passing the bar, do not actually pay off unless you're smart, work hard and have a few successes under your belt. And have the good sense to pick good future projects. Pick the winners that ensure personal and professional growth and experience, and not waste time on the losers. &amp;#x200B; There is an old adage in this business: Do you have 10 years of experience, or 1 year times 10 doing the same shit?
[removed]
Hope you are right
Your account's created just to post this and you are super secretive. There MIGHT be someone to buy this course for you, you may get what you want for asking but I don't think what you do is right. &amp;#x200B; If you can't (or won't) explain and say \`don't ask\`, I am sorry. I don't think I am feeling your pain because others suggested super valid ways like asking your friends to do that for you but it seems even that is not an option, which is a bit suspicious. &amp;#x200B; I also checked the course you've mentioned. It doesn't contain anything you can't compile from the docs, blog posts and tutorials. &amp;#x200B; Good luck on your search.
While I agree with what you said, I don't think it would be right to compare Go to Python with number of resources since -IMO- Go is much simpler than other languages and requires less abstraction for many things.
Nah, I'm cool with coder. Because I'm from Australia (where such terms are regulated) I have a bigger problem with "software engineer". It usually seems pretensious. But these are cultural differences in terms, and usually not worth the brain cycles to debate.
ooko oo k...... ...................................... Œ£œÄœÄœÄ9
I am quickly reading your code without using a proper IDE, so can't say this is a proper code review :) but; * I would use environment variables instead of reading the token from a `.txt` file. * In `checkandpost` function the code says `if err == nil`, I would go with `if err != nil` and remove the `else` * Also the function names neither snake_case, nor camelCase. I'd stick with a standard and follow it instead of this naming convention. * I would avoid nested if-else blocks, extract the task to a function when possible. * I would add tests.
Looks like frontend code to me.
While this is a cool experiment, there are obvious issues with this implementation that make it unsuitable for real-world use cases, like search engine indexing and simply going beyond a typical hello world application. If you want to avoid writing JS, you can compile go to JS with arguable more success.
[https://github.com/coreos/go-iptables](https://github.com/coreos/go-iptables)
So, you saying that Go has nothing of what I've listed in my comment, aren't you? That's amazing...
It just reminds me of: "We never will, but it's very important that we able to. But we won't. So let us do it. Because we won't do it. Which is why we're spending so much money to make sure we can. But we won't. But let us." I mean if they're going to ask for community contributions, the least they could do is make a commitment through licensing that the community will always have rights to share equally in the product.
Thank for your opinions. Good luck on your opinions giving.
This is a useful unbiased hypothetical example. Thanks for adding something useful to the conversation that's not just "it sucks".
Hey, I just started learning programming maybe 2 years ago. I'm still in college, senior now, but I have an internship doing Python software development and I'm really loving it. If you're passionate, just don't stop working on it. I started learning golang a couple months ago, and I'm really enjoying it as an intro into static programming. If you ever need some encouragement, let me know!
There's 4 lines of HTML - that's all the frontend code there is, no JS
No I did not!
I like this package. It basically allows you to get the benefits of some common interfaces for one line of code. And methods are more useful than naked functions in Go.
&gt; The first is fundamentally: There are float64 which you cannot compare with == for equality. The set of possible values of a variable of type float64 includes stuff like +Inf and -Inf (they are fine) but also NaN and strange but true NaN != NaN so your code could never detect a NaN value in the given slice because a == e is always false whenever e is NaN. To detect a NaN you must use math.IsNaN. I.e. you *can* compare floats using `==` but the result might not be what you expect because NaN != NaN and you didn't read the specification. &gt; Is more a semantic problem: Comparing floats for identity is complicated because floats are not exact, No, floats are exact. The base 10 literal representation of floats is not. When you write `0.1` to specify a base 2 rational, you're the one not being exact. &gt; the are not integers, Obviously, but they're an integer representation of rational numbers. &gt; not rationals and definitively not real numbers; maybe they could be described as "approximation to a rational". They're exactly rational numbers except when NaN or +/- Infinity. &gt; `==` on floats is "bitwise identity" and not "their numerical value if interpreted as a real number is basically the same" Wrong. `-0.0` and `0.0` have different IEEE 754 representation but are equal. &gt; But I think this is a very bad practice. Even if you could write one generic function handling different ints and floats with the same code you would hide the fact that that function is subtly broken for floats under a bold-promis name "Contains". It's not subtly broken and it's not a bold promise. Just like everywhere else, you need to understand how floats work to deal with floats in a manner that won't surprise you. &gt; For floats you typicall have to write different code to be correct. For a very peculiar definition of correctness.
frontend code != javascript. If you're writing code to render something all that code is frontend code. Just because we might stop writing frontend in javascript doesn't mean we'll stop writing frontend code. That's like putting on a job description: backend developer, and then they end up writing a server side rendered website and having to do css etc.
The title is technically not true I guess, but by frontend code he's referring to all the JS frameworks like React, Vue, etc &gt; How could I write a reactive single page app without using the JavaScript or it‚Äôs ecosystem? I'd personally love to use something like this, because JS is just a terrible language and I hate how to design a reactive website you have to use it
&gt; They're exactly rational numbers The set of floats is finite, the set of rational numbers is infinite. Arithmetic operations are slightly different as well.
Appreciated!
I have to say, as always with Eli, quality content. No blah, blah, no holding your hand, but enough to stimulate the mind to go out and research the blanks yourself. I really appreciate he takes the time to create those posts.
&gt; Don‚Äôt decorate what‚Äôs already decorated (e.g. os.Open). It is valid advice for simple CLI utility. But it is not good for cache with file system backend: `failed to get cache item: file.name: file does not exist` vs `file.name: file does not exist".
The example I provided also adds some context: parse respondents.txt: open respondents.txt: no such file or directory It just adds it at the beginning with `fmt.HandleErrorf` instead of at every error. In the example you provided, you'd probably have a function like `getCacheItem`, so you'd add the context there, again, with `fmt.HandleErrorf`.
&gt; you'd probably have a function like getCacheItem I guess you need to train yourself in code decomposition a bit more. I would have an interface type Cache interface { Set(name string, value io.Reader) error Get(name string) (io.ReadCloser, error) } And this error message will be at implementation level func (c *fileCache) Get(name string) (io.ReadCloser, error) { file, err := os.Open(name) if err != nil { return nil, fmt.Errorf("failed to get cache item: %s", err) } return file, nil } Cache users will put their own annotations related to business logic.
This is super cool! And was something I was thinking about looking into soon so I am happy someone beat me to it :) Since you mentioned not knowing if there was a point to this, I have two specific use cases for being able to compile Go -&gt; WASM in-browser which I hope to prototype soon: 1. A website for [Vecty](https://github.com/gopherjs/vecty) where you can compile and run examples directly in your browser. 2. A browser extension, also for Vecty, which allows for viewing the source code of a component and making temporary edits in your browser -- a bit like how you can edit HTML/CSS temporarily in the Chrome inspector. I'm not 100% certain about details on this yet, though. Either way, I think this is very promising -- thank you for sharing!
So in that case, feel free to use `if err != nil`, just as I said in the article, there should be no shame in it.
I wonder if `golang.org/x/tools/go/packages` could expose a `purego` build-tagged implementation which does something similar?
(disclaimer: I am the author) You may be interested in following progress on [Vecty](https://github.com/gopherjs/vecty). While not ready for prime-time yet, it may be close to what you are wanting.
Something is wrong with the code design if there're lots of naked err returns. Too much levels of unnecessary abstractions.
Floats are rational numbers, it's just that you can't represent *any* rational number as a float.
Do you have a suggestion on how to improve the example that I provided so that there aren't as many naked err returns? (They aren't really naked though, `fmt.HandleErrorf` adds context to them.)
Thanks. If you have ideas for more extra useful functionality, share or open a pull request.
Makes sense. One takeaway here for me is that I need to make sure in Vecty's future docs we make it clear that your code must compile with `CGO_ENABLED=0` and explain what that means for newcomers. It's not that the project needs to be "written 100% targeting wasm" -- it's just that the project needs to _not_ be using CGO and `unsafe`.
For "kitchen-sink demo", [the todomvc example](https://github.com/gopherjs/vecty/tree/master/example/todomvc) is closer to this / may be interesting to you. (It's still not a great example, though, for reasons [mentioned here](https://github.com/gopherjs/vecty#current-status)).
Hi, I'm pretty new with Go and have a question. How is it different than the official playground on golang.org? What does it do that the existing one doesn't?
Thank you for the kind words, I will get to work on the next episode asap :)
Thanks! I've just checked it out and it looks really great, might be worth the switch, I will look into it :)
No one has written a purego implementation. But yeah, that‚Äôs be ideal for GopherJS needs.
Awesome. Also someone just poster a guide on how to implement new keywords in the go compiler. Maybe we'll just add a try/catch block that compiles down to something like this. That might improve over doing manual stack traces by giving every error we return context. Haha.
In general you'll want to make use of the official Go playground, this is mostly 'just cool' rather than useful from a practical standpoint (in its current state). The official playground sends your code to a server which compiles, runs, and forwards the output back to your browser. This one compiles your code in your browser and runs it in your browser directly. In the future, you could import `syscall/js` and call browser APIs too.
I heard Ken has semi-retired. Don't know about Robert, but Russ uses Acme too.
good answer you can find here about history -&gt; [https://unix.stackexchange.com/questions/332465/what-text-editor-was-used-by-thompson-and-ritchie-in-the-writing-of-unix](https://unix.stackexchange.com/questions/332465/what-text-editor-was-used-by-thompson-and-ritchie-in-the-writing-of-unix) and it's good question for now... probably Acme too.
I mean, adding popular unmarshalers like xml or gob could be an easy one. Or adding the sort interfaces. A naive sorting of struct fields could be useful. This kind of library is easily extendable.
[removed]
Great post. Thanks!
I worry about how `try` and deferred error handling will affect beginners in Go. Code that a beginner may have been able to easily understand before like: func Foo() (int, error) { v1, err := Generate() if err != nil { return 0, fmt.Errorf("generating: %v", err) } v2, err := Encode(v1) if err != nil { return 0, fmt.Errorf("encoding: %v", err) } return v1 + v2, nil } Will instead become something less explicit like: func Foo() (r int, err error) { defer fmt.HandleErrorf(&amp;err, "generating") v1 := try(Generate()) defer fmt.HandleErrorf(&amp;err, "encoding") v2 := try(Encode(v1)) return v1 + v2, nil } As a beginner you now need to: 1. Understand what `try` does (many beginners will chalk it up as magical until they understand). 2. The order in which `defer` executes (note the above two examples are not identically functional either). 3. Name your return values. 4. How to translate the 2nd code example above into the first one when changing e.g. `Encode` to return values that `try` cannot handle, such as returning both a value and error.
and the HTTP model went out the window \*cries for the web\*
So they are not exactly rational numbers, rather a subset (with different operations).
In the same sense int64s aren't "exactly" integers, sure.
I don't like the automatic return by `try`. It kind of breaks the flow of code and creates hidden complexity. I like the current explicit error handling as it forces you to design your application accordingly and I don't see a problem with `if err != nil` being used everywhere because it does what it says and there's nothing magical about it. As a former PHP developer coming to go, I was astounded by the explicit error handling and the clarity it creates. Errors were no longer exceptional and something that shouldn't happen, instead they became part of the logic you're implementing.
You know, that's a perfectly fine stance! However, you also need to take into account that many write programs where error handling just becomes unnecessarily verbose. You may not be one of them (in fact, I'm not one of them either), but those programs exist and would highly benefit from something like 'try'.
I watched a preview: poor design and dry code making learning process hard enough.
[removed]
Thats easy, A way to write an algorithm library that doesnt need a separate function for accepting every int/uint type or to accept an interface{} and slow itself down by using reflection. I like go, but some of the communities bullheadedness is bewildering. Generics aren't an exotic feature that needs to prove itself to anybody.
It adds complexity and magic, which isn‚Äôt good for anyone but those that wants to write the most clever and complex code they want to show off. All the complexity and magic has the be learnt and retained to use a language and frameworks. If your focus is to build software that solves problems all that added mental capacity needed to do something is not a good thing. I dealt with elixir just before go. I spent almost no time thinking of the problem, it was just about the language and all the clever non-obvious magic that goes with it. I had never been less productive, because my life didn‚Äôt revolve around wanting to learn everything about the language. Go I got going with in no time, I quickly got productive and started to solve real problems. And it‚Äôs not like I hadn‚Äôt learnt languages before (20 year career). The current way to handle errors isn‚Äôt clever or terse or magical. It is in the other hand easy to understand, easy to write, and easy to read.
Thanks for the article. This also lines up with my intuition: that you can basically get the same errors, just by moving the added context into the function a lot of the time. I like the lazy inclusion. I do expect that this will become somewhat common if try goes in. Tiny note though: you can use %q instead of "%s" and it'll automatically quote and escape things, so it tends to be really good for strings in errors (you never know when a weird nonprinting character will sneak in).
I'm saying that your analysis and comparison is naive.
Right, and whining about Go weak type system and lack of generics is so much profoundly better.
Thanks, I fixed the code to use `%q` instead of `\"%s\"`.
Like from other comments I can see this would be benefitial when writing cli scripts. For my use case having some manual docker tasks run with `go run` directly but for example in database applications I would only use it for opening/closing resources and use explicit error handling for domain errors.
It‚Äôs not stated in the documentation, and I see you just posted a request on github asking the same question. You can do a code check and see, but I usually assume it isn‚Äôt unless otherwise stated. For that, a sync.Pool is a good option to prevent multiple allocations needlessly, at the tiny cost of an extra mutex in the pool. It‚Äôs cheaper than making the encoders/decoders directly safe themselves.
That website...before anything loads it wants to install an app? No.
Yeah, usually i close the page after such a notification.
Link to the YouTube video directly and not the annoyance riddled landingpage for the video. If the video is good people will check you out.
LOL, no.
Both defers would execute for the second error case, so your example is overcomplicated and incorrect. Deferring a formatter would let you annotate ‚ÄúFoo‚Äù onto the error, basically. It wouldn‚Äôt let you annotate a specific verb per error, unless you did something excessively complicated like having a string declared at the beginning of the function to be the verb, then setting that before each try... but that‚Äôs not the intended use of try. If you just annotate ‚ÄúFoo‚Äù, and each function like Generate and Encode also annotates their own names, then you don‚Äôt need to annotate each error branch anyways.
Well, frankly, it is. Those are at least well-founded complaints. "Go's type system is powerful because it it doesn't let you assign int32 to int64" like saying "Potatoes are the best food because they keep you from starving to death."
Interesting. Thanks for the info. One of my Traefik deployments does have to use nginx for serving some static files, which is annoying. Maybe when Caddy 2 is a little more fleshed out I'll give it a try again.
So I do agree that constantly doing ``` val, err := os.Open(path) if err != nil { return } ``` Can take up a lot of the vertical space, which can be annoying at times. But I really don't think `try` is the solution to this. It may sound silly, but the solution I'm proposing is to not have `try` at all, but just wrap the lines and take up just one line for such simple error handling. So the example above would look like: ``` val, err := os.Open(path) if err != nil { return } ``` So yes, the `try` example would only take up one single line, but I think it hides too much away and feels too "magical" to be added as a core feature of the language.
[removed]
(I am aware both defers would execute and the output would be "generating: encoding: error") &gt; if you have a longer function, a single defer at the top and a bunch of ‚Äútry()‚Äù statements will significantly shorten the code, arguably making it easier to read and write. This approach works only if the code you are calling is properly annotated already OR if you are okay not knowing where an error came from within the function. For example, did the following error come from `Generate` or `Encode`? &gt; foo: unexpected index 5 outside range 6 : 10 func Foo() (r int, err error) { defer fmt.HandleErrorf(&amp;err, "foo") v1 := try(externalpkg.Generate()) v2 := try(externalpkg.Encode(v1)) return v1 + v2, nil } If `externalpkg.Generate` and `externalpkg.Encode` aren't already annotated with something like `fmt.HandleErrorf`, then now you are either: 1. Getting ambiguous errors like the above. 2. Need to propose an upstream change to `externalpkg` to annotate errors (which may break API compatibility in the package) 3. Wrap the error in your own code.
[removed]
Or, option 3: you also include the top stack frame in your annotation. Then you always know exactly which line in your function returned the error, no matter what.
No one has written a `purego` implementation of go/packages. But yeah, that‚Äôd be ideal for GopherJS needs.
I'm sorry, I don't want to troll but this is kind a question my son keeps asking me.
Well, if one type based on byte and another on uint16, as long as there's no shifting occurs the language inability to set one to another feels overprotective and is named a shortcoming. On the other hand when you use bits math, a compiler prevents you from typos and tired-logic mistakes where one may simply keep shifting and|or oring or xoring in mind, yet, forgets to type the symbol. Another case is system calls, where the difference between int32 and int16 is crucial, since it may otherwise result in something critically wrong. Generics add complexity to the code, and even though they provide compile time type tracking, the whole source code becomes less readable, more complex and more error prone. Whilst interfaces and interface inheritance provides the same way of compile time type checking with the same level of complexity. Go type system is an advanced tool, with a proper approach it allows to ensure convenient naming, compile time value and type checking. With less boilerplate required. The need for iterators is in many ways overestimated, except if there's a tree or otherwise intentionally linked list of elements, you don't need an object to track the iteration over the collection, since in many cases it's either slice/array or a map. And to keep track of current value of those you need either any type based on any integer or any integer type or a map key type local variable. Which in turn given the length of the collection and order remains same for each go routine gives an easy and a light way to iterate over the collection independently. When there's a need to synchronize the changes to a collection between go routines there's either a channel type or sync package assisting in that. That is why iterators exist in standard library of Go, yet, they are tied to a few specific packages. And that's why also you are encouraged to write your own handlers if you need those. Language does not prevent you from emposing new interfaces to handle your and even some external code, together with reflect package it allows to implement an iterator if you need one runtime for any iterable object. In other words it's rather the lack of understanding how Go works which prevents developers from creating anything with it.
Notice that in this example, we had to use named result parameters for the best effect. Named result parameters on functions is usually to be avoided because 1) godoc stutter and 2) it creates an automatic return (which is less clear) in the name of saving lines of code. Try seems to follow the same form of saving some lines of error checks by using automatic return. ``` func (pipe *Pipe) Save() error { if _, err := pipe.writer.Write(pipe.FlushBuffer()); err != nil { return err } return nil } ``` Using named returns ``` func (pipe *Pipe) Save() (err error) { _, err = pipe.writer.Write(pipe.FlushBuffer()) return } ``` Using try(?) ``` func (pipe *Pipe) Save() error { try(pipe.writer.Write(pipe.FlushBuffer()) } ``` So if we are going to support `try`, seems we might to need to reverse this negative view of https://github.com/golang/go/wiki/CodeReviewComments#named-result-parameters (baring the stutter issue)
Of course experienced people will understand and figure it out and `try` doesn't really change anything in that regard, I completely agree. But we're now talking about _good_ Go code having 5 different options of handling this situation, including a custom deferred `HandleErrorf` implementation recording the stack frame. And _this_ is exactly my original point: As a beginner you now need to understand much more when reading existing (good!) Go code and that will affect beginners negatively.
Correct, named results are even mentioned in the original try proposal: &gt; The main drawback of this approach is that the error result parameter needs to be named, possibly leading to less pretty APIs. Ultimately this is a matter of style, and we believe we will adapt to expecting the new style, much as we adapted to not having semicolons. https://github.com/golang/go/issues/32437
Not a fan of it. I always have more explicit error handling in my library code and when I'm writing a command line app, I always define a function like this: func panicOnError(err error) { if err != nil { panic(err) } } So that elsewhere in my code, I can do things like: f, err := os.Open(filename) panicOnError(err) data, err := ioutil.ReadAll(f) panicOnError(err)
Rob Pike should rewrite Acme in Go that shit would be fire
&gt;Can someone tell me what generics can do that interfaces cannot be used to implement today? Sure, a continuously sorted or fixed order "map." That's one I ran across yet again today. It's worth pointing out that using interface{} to solve these "generics" issue is not bypassing generics. It's just using inappropriate/poorly implemented generics to solve the problem. One of my favorite ways to point out Go's limitations from the lack of generics is to quote Rob Pike himself. *"I wanted to see how hard it was to implement this sort of thing in Go, with as nice an API as I could manage."* ([https://github.com/robpike/filter](https://github.com/robpike/filter)) One of the primary authors of the language implemented map/filter/reduce with Go's "generics." The outcome was so bad that he recommends that it should not be used!
Even better if we can just do `if err { return }`
unpopular opinion: let's just add a little bit of magic - extend try to take an optional 'context' string arg. try will then wrap the error like $context: &lt;orig error&gt; If no context is given to try a default context of &lt;filename: lineno&gt; will be used. unpopular because behind the scenes stuff is going on but I think it's practical. It acknowledges that stack traces included with an exception (as many languages do) is practical and useful and adds a bit of the usefulness to go. &amp;#x200B; example: result := try(doFoo(), "doing Foo") output would look something like: "error: doing Foo: unable to Foo" OR result := try(doFoo()) output would look something like: "error: bar.go:100: unable to Foo"
No, they are stackless developers.
&gt; // go.mod &gt; module github.com/name/base Then you should be using `import "github.com/name/base/a"`.
In some additional senses as well (e.g. loss of significance).
I'm officially coining the term "**Gohole**" to tag all people who use the response *"if you don't like feature X (or the lack of feature X) then you should use a different language."* The single sentence is one of the most unwelcoming and short sighted things I read in the Go community. It's also outright hostile to those you spit it at.
That's the same sense.
I like named result parameters and wish their was a solution to the godoc issue along with developers making a mistake with variable shadowing.
Same goes for me. Problem is outside of this you can't return it.
[removed]
youtube link https://www.youtube.com/watch?v=IE1CTA4IqsA
Punch cards.
No, there is no loss of significance for ints.
Edwood (https://github.com/rjkroege/edwood) is already in development.
There is if you try to specify one that can't be represented by the int type you're using. That's why big int libraries exist. Same as floats.
To be honest, I can't seem to figure out when that happens. We build a big application which is a webshop with a shit load of business rules and exceptions and everything and error handling is not a problem. If something really shouldn't happen, just panic while logging it really well. Most of the time is that a fine option.
I think that Thompson uses sam.
"1/2 and 1/3 are not rational numbers, only a subset."
I think it‚Äôs to each their own. I started with Go and have been coding in Go for a couple years now, and find it an unwieldy language to use. I‚Äôve recently just ported a lot of services I‚Äôve written for my company from go to elixir and have no plans on looking back - I feel far more productive with elixir (and functional programming languages in general).
[removed]
there is no ‚Äúif it can‚Äù: The argument you‚Äôre making can be summarized as ‚Äú*every* feature can be misused, therefore we should *never* add a new feature.‚Äù
We use proprietary goproxy which seamlessly generates modules when requested a proto-repository URL-s. This is the best method when you need libraries working with generated code. You better generate right into your project source tree if you only need to interact with services.
I would suggest using \`elem\`, it works for any kind of foldable/iterable container AND for any element type that can be compared for equality. elem :: (Eq a, Foldable t) =&gt; a -&gt; t a -&gt; Bool elem 5 \[1, 2, 4, 5\] elem "foo" (Set.fromList \["foo", "bar", "baz"\]) elem False (Vector.fromList \[True, True\])
Use the struct, because it's the simplest and most intuitive way to model your domain. If your program is too slow, profile it to see if map access is a bottleneck. If so, consider alternatives like string concatenation or hashing.
named error parameters. &amp;#x200B; defining functions so we can decorate errors. &amp;#x200B; seems a bit ceremonial.
[removed]
Right https://twitter.com/rob_pike/status/472960298706407424
I don't have strong feeling about it, but the way it is proposed is that it is up to you whether you use it or not.
You can absolutely use a struct as a map key! https://blog.golang.org/go-maps-in-action, and check out the *Key types* section. There's really no downside to using a struct as the key. Hashing and concatenating the two parts would not be easier or faster, since the Go runtime will hash the key anyway.
A `*json.Encoder` only works with a single target `io.Writer`. The response body in a handler needs to be written into an `http.ResponseWriter`. AFAIR the `http.ResponseWriter` passe into the handler by the server is not buffered itself. I think you would to first write into a memory buffer (`*bytes.Bufer`) for most REST endpoints. That would be followed by an `io.Copy` or a single `Write` call. I think there are ways you could reuse encoders + memory buffer pairs. However it would complicate the code. I would not do it unless I was sure the performance was unacceptable without it. For YAML it will depend on what library you use. AFAIR there is no YAML support in the standard library.
I expect that the struct is indeed faster. Not only will hashing a struct be faster than computing an md5 and hashing that, the storage space per key will be smaller as well. However these are assumptions. If you want to be sure, why not implement both and benchmark them. Go supplies the tools for that. If you do create a benchmark, please post results here, I'd like to see them.
‚Ä¢ Rob Pike uses Acme ‚Äî https://twitter.com/rob_pike/status/1055632360606035968 ‚Ä¢ Russ Cox uses Acme ‚Äî https://twitter.com/_rsc/status/1127173579299282945 ‚Ä¢ Ken Thompson uses Sam ‚Äî https://twitter.com/rob_pike/status/472960298706407424 ‚Ä¢ Bjarne Stroustrup uses Sam ‚Äî https://twitter.com/rob_pike/status/472960298706407424
Right, so would be handy to provide this pooling for encoders / decoders within stdlib
I read this and the example program and thought: This example is exemplary of why \`try()\` is problematic. &amp;#x200B; PS: I'm not saying that faiface did anything wrong / bad / etc, don't take my commentary that way as it wasn't intended that way.
I'm having similar issues but not fully following these steps. The second bullet point/the also line where am I putting this config? go.toolsEnvVars? Or am I setting this on my computer's environment variables directly? Also are you using the go language server? So far I've either gotten my imports to have a could not import/no parsed files for package LSP error. Or my files are error free, but peeking (F12) just hangs forever. Thanks
Sort of. I wouldn‚Äôt necessarily want the stdlib to deal with that for me. I may not want all my encoders/decoders sharing the same pool if they‚Äôre doing something different.
Thanks for that nice example. I also really appreciate the side note about Ref - that's a nice solution. This makes it easy to appreciate why try is a step in the right direction - it definitely reduces the error handling boilerplate. However, I also see tools like vet and lint becoming even more necessary to help track consequences of try returning early. To me though, that's an acceptable cost - all the tools are free and making tools work for you is in my opinion, the Go way.
Use `source_relative` with protoc. Eg: `protoc -I. ‚Äîgo_out=plugins=grpc,paths=source_relative:. *.proto`
Looks neat, but it currently doesn't build :(
Yes - this was the solution I ended up finding.
Builds for me on my Mac. What is it complaining about?
``` ~/go/src/github.com/brendanporter/duck $ go build # github.com/brendanporter/duck ./main.go:315:34: not enough arguments in call to quack.SendPing have (string, number, chan quack.PingResult) want (string, int, int, chan quack.PingResult) ~/go/src/github.com/brendanporter/duck $ cd ../quack/ ~/go/src/github.com/brendanporter/quack $ go test # github.com/brendanporter/quack [github.com/brendanporter/quack.test] ./quack_test.go:24:5: undefined: resultProcessor ./quack_test.go:41:20: undefined: sendPing ./quack_test.go:80:26: undefined: ttlTrace ./quack_test.go:82:6: undefined: elog ./quack_test.go:85:5: undefined: ttlTraceResultChan ./quack_test.go:119:28: undefined: ttlTrace ./quack_test.go:121:8: undefined: elog ./quack_test.go:133:6: undefined: unhealthyPingResultChan FAIL github.com/brendanporter/quack [build failed] ~/go/src/github.com/brendanporter/quack $ ```
Dang. Forgot to push latest quack changes. Thanks for the note, should build now with updated package for quack.
 ~/go/src/github.com/brendanporter/duck $ go test # github.com/brendanporter/duck ./main.go:109:5: Printf format %s reads arg #7, but call has 6 args
Fixed up, thank you.
Works great now. Thanks!
Will do. Thanks guys
Hint: if a minimal version of "not doing it wrong" for something that should be ubiquitous costs a hundred lines of code, you've failed catastrophically.
&gt;It's not that the project needs to be "written 100% targeting wasm" -- it's just that the project needs to _not_ be using CGO and `unsafe`. That, and other things that end up not working correctly in wasm like the net/http GET with body, which works fine in a native app. The gotcha is that while the main project may not be doing these things that don't work, a dependency could, for instance, call `user.Current()` which can work without cgo but obviously has no impl for js and returns an error where it would have fallen back in the env in anither GOOS. Might be interesting to track a list of gotcha examples for wasm, but maybe that belongs in lower level Go js/wasm docs. Thanks for the response!
Added the benchmark, can you check if this is correct benchmark? (it's my first time)
Mind expanding on what you mean by problematic?
I don't think the struct is going to be faster to hash than a single string consisting of the concatenated halves of the key. The latter is one indirection and a single linear scan over the string. The former is two of those. On the other hand constructing a concatenated key probably requires every lookup to perform an alloc+gc, which I would guess will hurt more than the hashing will. I'll wait and see what @gotBanana finds with the unit tests.
When I said "fork," I meant it more in the originally definition rather than [GitHub's more recent re-definition](https://drewdevault.com/2019/05/24/What-is-a-fork.html). You'd host the repository internally on your organization's own network (local GitLab instance, etc.), maintaining a mostly independent fork, occasionally pulling changes from upstream if necessary.
Updated.. can you guys let me know if my benchmark has a misleading bug. Thanks
I don't understand what proposal is supposed to be locked - I couldn't find any. But FTR, "an issue was locked, so we ¬ªrouted around it¬´" is an obviously counterproductive and toxic way to interact with the Go team. If they lock issues, they do so for a reason. Trying to circumvent the lock or having it blow up in their faces shows that you don't value their work, time and the sustainability of their job. And in bird culture, that is considered a dick move.
I said interfaces, not empty interfaces... Empty interfaces are the devil.
Write the library to accept interfaces, not low level types.
I haven't tried this yet. But I love the naming scheme.
Definitely. On the stdlib side, I think most of this is just from Go's WebAssembly support being very early stages currently. For both, you should've seen documentation indicating that would not work in the respective packages (I am sure this will come sooner or later).
Thanks!
Thanks! I thought Ref was kinda neat, so I included it, glad you liked it :). And I definitely agree about the tools, they are gonna help a lot.
u/Ballresin, this is awesome. It built and ran perfectly on Linux. It was exactly the tool I was looking for this week, so perfect timing. I do have one question/suggestion. I often need other non-tech people to run something like this. It would be great if there was an export in the web browser that allowed the to save a file and then send it to me. I would then import the file somehow and view the exact some data in the browser. I can do this is using PingPlotter, but it would be very nice if this tool could do it too. Using screenshots worked, but I had to create several screenshots to get all the panels, which would be a pain for a user to do. I see there are there generated json files. I wouldn't mind the user emailing me these three files, then I could view it using the browser. Do you already have a way to do this or have you thought about this?
Hey thanks! Yeah, I have considered something like that. Technically right now if you plant the 3 JSON files in the directory and target the same host, it will load the files and the web UI will display the ping history. However, it will then proceed to continue testing. I don't currently process the hosts or paths to produce any output, but I intend to change that. I'm of two minds on this sort of feature. I generally seek out the most zero-configuration and least-user-fuss solution. This would lead me to a client-server model wherein the individual ducks could be configured to report to a server, and the server would have an expanded interface to view the various results. However, that being said, I've been considering a load-from-json function to switch between results from different targets. The trouble is the actual tester and the web UI are pretty tightly coupled right now. I could build a daemonized version of this that can optionally run tests, which would serve as a base for the future use case of client-server fancy-ness. I'll think on it and play around. I appreciate the feedback!
now, with the headers, to the response, you can set the content-type or sleep time.
There is your way and there is the Go way. The Go way usually calls defer f.Close, your's here doesn't. Just because a feature can be abused is not an argument for anything, since anything can be misused.
And now you've forced your consumers to write boilerplate for a simple int. You would need Add, Subtract, Multiply, Divide interfaces or similar nonsense, and all that work just for decreased performance considering the program must start chasing pointers through all the interfaces on a simple operation
There are some other efforts as well: https://github.com/eaburns/T/
True, but it doesn't change the fact that it still sucks.
Took a shot at benchmarking (This would be a good fit for a benchmark with sub-benchmarks...) package mapbenchmark import ( "crypto/md5" "testing" ) type ComplexKey struct { one string two string } type ComplexValue struct { one string two string } func BenchmarkComplexKey(b *testing.B) { for i := 0; i &lt; b.N; i++ { m := make(map[ComplexKey]int) key := ComplexKey{"123", "456"} m[key] = 1 value, ok := m[key] if ok != true || value != 1 { b.FailNow() } delete(m, key) } } func BenchmarkComplexKeyOneInit(b *testing.B) { m := make(map[ComplexKey]int) for i := 0; i &lt; b.N; i++ { key := ComplexKey{"123", "456"} m[key] = 1 value, ok := m[key] if ok != true || value != 1 { b.FailNow() } delete(m, key) } } func BenchmarkComplexKeyComplexValue(b *testing.B) { for i := 0; i &lt; b.N; i++ { m := make(map[ComplexKey]ComplexValue) key := ComplexKey{"123", "456"} value := ComplexValue{"789", "abc"} m[key] = value retvalue, ok := m[key] if ok != true || retvalue != value { b.FailNow() } delete(m, key) } } func BenchmarkComplexKeyComplexValueOneInit(b *testing.B) { m := make(map[ComplexKey]ComplexValue) for i := 0; i &lt; b.N; i++ { key := ComplexKey{"123", "456"} value := ComplexValue{"789", "abc"} m[key] = value retvalue, ok := m[key] if ok != true || retvalue != value { b.FailNow() } delete(m, key) } } func BenchmarkConcat(b *testing.B) { for i := 0; i &lt; b.N; i++ { m := make(map[string]string) key := "123" + "," + "456" m[key] = "1" value, ok := m[key] if ok != true || value != "1" { b.FailNow() } delete(m, key) } } func BenchmarkConcatOneInit(b *testing.B) { m := make(map[string]string) for i := 0; i &lt; b.N; i++ { key := "123" + "," + "456" m[key] = "1" value, ok := m[key] if ok != true || value != "1" { b.FailNow() } delete(m, key) } } func BenchmarkMD5(b *testing.B) { for i := 0; i &lt; b.N; i++ { m := make(map[[32]byte][32]byte) var key [32]byte x := md5.Sum([]byte("123")) y := md5.Sum([]byte("456")) copy(key[:], append(x[:], y[:]...)) m[key] = key value, ok := m[key] if ok != true || value != key { b.FailNow() } delete(m, key) } } func BenchmarkMD5OneInit(b *testing.B) { m := make(map[[32]byte][32]byte) for i := 0; i &lt; b.N; i++ { var key [32]byte x := md5.Sum([]byte("123")) y := md5.Sum([]byte("456")) copy(key[:], append(x[:], y[:]...)) m[key] = key value, ok := m[key] if ok != true || value != key { b.FailNow() } delete(m, key) } } --- go test -bench=. goos: linux goarch: amd64 BenchmarkComplexKey 2000000 682 ns/op BenchmarkComplexKeyOneInit 2000000 661 ns/op BenchmarkComplexKeyComplexValue 2000000 736 ns/op BenchmarkComplexKeyComplexValueOneInit 2000000 706 ns/op BenchmarkConcat 5000000 239 ns/op BenchmarkConcatOneInit 10000000 215 ns/op BenchmarkMD5 1000000 1086 ns/op BenchmarkMD5OneInit 1000000 1065 ns/op PASS ok _/home/kevin/map-benchmarks 14.422s A single string as the key is faster than a struct, but not by much. IMHO using a struct is more elegant, and you'll get that performance back if you ever need to access the `two` field in the key.
This has been around for years. Something new?
Thank you for confirming!! Will use struct
Maybe someone is new to go? I have used the package and really liked it.
I like it too.
I'm suddenly wondering if my style of Neovim use might have more than a few similarities to how you work within Acme.
I've used this package and it saved me a lot of time. However I moved on to writing my own simple bash script to download a tarball from a github releases page and install the binary manually, because this tool was giving me too much boilerplate.
So, you are saying that the below piece of code is not a real world problem? ```go test := []info{{data: "data 1"}, {data: "data 2"}, {data: "data 3"}} list := make([]*string, 0) for _, k := range test { list = append(list, &amp;k.data) } for _, s := range list { fmt.Println(*s) // what's wrong ? why always "data 3" ? } ```
In current times most of apps are deployed via docker by me so this software has not much sense above tagging a release on github but it is anyway 2 clicks :)
Ditto
Nice effort. Curious around the context you're looking to use this? Are there limitations you've found with defer/recover? https://blog.golang.org/defer-panic-and-recover
Thanks for that. You're right that there is some hacky code in there. In the last few days I was mainly interesting in proving the mechanics could work. However, I have created an issue to fix that: [https://github.com/elliotchance/pepper/issues/5](https://github.com/elliotchance/pepper/issues/5) You triggered something interesting I hadn't considered yet, which is that visual state can be shared and live between different clients. Such as a shared counter where multiple clients could increment it. I have a few ideas on how this may work, but synchronisation and only rendering subscribed clients is critical. I'm going to add an example for this soon.
Yes. Hopefully that was clear in my description of what it might be useful for. Pepper is certainly not a general purpose framework or to be used to make real web applications. It's still very much an experiment, but I'm looking forward to building in some graphing so I can show some real time stats for servers that are already running in production.
Vecty looks very cool! I have only looked at it briefly but the compiled size looks enormous. Is that just the framework bloating it, or would web applications easily go into the several megabytes?
It's good for cross platform CLI tools that don't make sense for a docker dependency. That's where I currently use it.
Yes it is totally thread-safe. By the way @DeusOtiosus, encoding/json is using internally a sync.Pool, you can get more details here [https://medium.com/@blanchon.vincent/go-is-the-encoding-json-package-really-slow-62b64d54b148](https://medium.com/@blanchon.vincent/go-is-the-encoding-json-package-really-slow-62b64d54b148)
encoding/json is using internally a sync.Pool, you can get more details here [https://medium.com/@blanchon.vincent/go-is-the-encoding-json-package-really-slow-62b64d54b148](https://medium.com/@blanchon.vincent/go-is-the-encoding-json-package-really-slow-62b64d54b148)
That doesn‚Äôt describe the encoder, only the convenience methods. It would be strange if they didn‚Äôt provide some way to be thread safe from those. Creating an encoder, basically creating a struct/object, is different, and from a brief glance, it doesn‚Äôt appear to be thread safe. Hence why it isn‚Äôt noted in the documentation.
Since the encoder manages its own buffer, using the same encoder can lead to conflicts - you should use one per goroutine
My bad I was not really clear. The pool actually shows you need one per operation - the instance is not shared but a new one is returned when it is free - The encoder manages its own buffer so you cannot share the struct.
Indeed. I don‚Äôt even think one could make a pool that would work with the encoder/decoder as they pretty much just attach to a reader/writer.
Did you figure out the problem?
I found this and other parts related to language evolution insightful as it relates to Go 2 proposals and to "try" particularly. Rust has a similar error model to Go ([error codes](http://joeduffyblog.com/2016/02/07/the-error-model/#error-codes)), so their history with "try" might bring interesting points to the discussion. I've linked directly to the relevant part, but the whole talk is very worth a watch to anybody actually interested in real-world, community-aware language design.
I found this talk interesting as it relates to "Go 2" proposals, and to "try" in particular. Rust has a [similar error model](http://joeduffyblog.com/2016/02/07/the-error-model/#error-codes) to Go, so their story with "try" might shed some insights into the discussion. I've linked to the part that talks about "try", but the whole talk is very worth a watch for anybody actually interested in community-aware language engineering. Of course, Rust is an entirely different beast from Go so it attracts a different kind of community, so things may not be directly applicable.
&gt; To be honest, I can't seem to figure out when that happens. It sounds like you only write web applications, where just panicking is an option, even if not a great one. That doesn't work with other kinds of applications.
You can do it all kind of situations. Again, only do it when it really shouldn't happen. The standard library has a lot of error that are given back, but a lot of them are 100% preventable. Panics don't have to kill the application and can be handled in the same way as floating random errors all the way up. It's not right for everything, but it sure is applicable for more than just web apps.
But goreleaser is for publishing releases, not for downloading them
5 months later, any new updates?
I've turned off language server feature to make the auto import working.
I'm confused. On his reasoning on the talk is 52:40 "we had earlier, unintentionally, followed (sp) rule of try bang that was very loud and nobody objected to it, and that gave us enough experience on why we need this question mark... And now, as far as know, this is very popular and, uh, indeed many people who were against it have come up to me and said, "I was wrong, thank you for merging this", so I think it was a good call" I feel this is very dumbed down to what likely transpired, and I can believe that they still likely get backlash for introducing it. Go initial try proposal is heavily controversial before even trying... So I don't think this is the same thing. On the topic of go try, let's go to Rob Pike's proverb: https://go-proverbs.github.io/ "clear is better than clever" I feel is weakened with try in its current proposed state. https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=14m35s But that's just my opinion on it.
Any Rust solution should be taken with a grain of sort. The language is just poorly designed.
You don't have to use defer: func Foo() (int, error) { v1, err := Generate() try(handle(err, "generating")) v2, err := Encode(v1) try(handle(err, "encode")) return v1 + v2, nil }
You don't have to use defer or named return: func Foo() (int, error) { v1, err := Generate() try(handle(err, "generating")) v2, err := Encode(v1) try(handle(err, "encode")) return v1 + v2, nil }
 locale := os.Getenv("LANG") locale = strings.SplitN(locale, ".", 2)[0] That will panic if LANG is not set, empty, or an invalid value. Also, locale is more complex than just getting the value of LANG; there's also LC_TIME, LC_COLLATE, etc. It all depends on what you need the value for. From memory, I don't think you really need to set LANG at all, and just LC_ALL will also work for many purposes.
If you are using the values within the struct as the differentiator, then hashing a struct is the best. However if you are using the objects themselves as differentiators, using their address as the map key MIGHT give better performance.
See https://golang.org/pkg/testing/#hdr-Benchmarks for the idiomatic way of doing benchmarks in Go. They'd go in a *`_test.go` file.
Use a struct. One thing I haven't seen mentioned is that it avoids the silly mistake where `GraphEdge{"fromX", "to"}` should be distinct from `GraphEdge{"from", "Xto"}`. (I.e. neither simple concatenation nor naive concatenation hashing will have the correct semantics for arbitrary input). A wrong answer really, really fast is still wrong.
Thank you! I actually swapped to learning Python, because my college is gonna teach us Python the first year. Want to have an easy year, so I can focus on Golang later on. Any tips for learning Python? I heard just diving into practice on Codecademy is great
Can you elaborate on why you think that Rust is poorly designed? I'm seriously curious.
By the way, since your fix didn't work the first time and apparently there is different code compiled for different GOOS settings (I haven't actually looked at github link) I'd remind you that you should be able to trivially cross-compile with just: env GOOS=linux GOARCH=amd64 go build env GOOS=windows GOARCH=386 go build ...etc... This can be very useful as a sanity test even if you have no easy of running the resulting binaries. (In the past I've even used the output of `go tool dist list` to try building with every possible setting; something like: `go tool dist list | awk -F / '{print "env GOOS="$1 " GOARCH=" $2 " go build"}' | sh -x` but that's usually silly).
&gt; https://github.com/RadhiFadlillah/sysloc/blob/master/locale.go#L19-L24 Compare this with output from `go tool dist list`. You should realise that the world uses more than darwin, linux, windows. (In particular anytime you have a ‚Ä¶unix‚Ä¶ case almost certainly most/all of the BSDs will work the same way, e.g. dragonfly, freebsd, netbsd, openbsd, solaris).
You're right. I confused it with https://github.com/goreleaser/godownloader which is by the same author.
&gt;So, you are saying that the below piece of code is not a real world problem? I don't understand what you mean here. By real world problems, I was trying to imply the larger issues you had when working on a project. &gt; what's wrong ? why always "data 3" ? When looping \`test\`, the item is always assigned to the same \`k\` variable which has the same pointer and \`list\` is holding the pointer rather than the data itself. So when you loop \`list\` one last time, you're getting the same memory address which points to the last state of \`k\` which is \`{data: "data 3"}\` \`\`\` for \_, k := range test { fmt.Println(k, &amp;k, &amp;k.data) list = append(list, &amp;k.data) } \`\`\` \`\`\` {data 1} &amp;{data 1} 0xc0000101e0 {data 2} &amp;{data 2} 0xc0000101e0 {data 3} &amp;{data 3} 0xc0000101e0 \`\`\`
Not OP, but I don't think Rust is poorly designed, just that I don't agree with some of the fundamental language philosophy. Programming in Rust reminds me of that old joke describing how to identify programmers of different languages, and you can tell the Ada girl because she's sitting in a corner with the Ada manual trying to figure out if it's legal to add two integers. Rust is like that.
They probably haven‚Äôt used it.
&gt;I can believe that they still likely get backlash for introducing it. Not really. The question mark operator is pretty uncontroversial in the rust community these days. Every few months someone chimes in that they just encountered this weird question mark, and how do I google what this means? And someone tells them it's called the question mark operator, and someone else points them to [the book](https://doc.rust-lang.org/book/), and then we don't hear about it again for a few months.
&gt;https://blog.golang.org/defer-panic-and-recover One limitation, and annoying aspect I foresee is explicit error type checking,
It isnt available for windows
In my opinion it's more like "{1/2, 1/3} are not rational numbers, only a subset".
That's not what loss of significance means though.
That's not what loss of significance means though (in my experience). (Fixed-size) ints have limited range, (fixed-size) floats have limited range and loss of significance in addition. Catastrophic cancellation comes to mind: the "proper" result does fit in the range (i.e. a closer number to the exact answer is expressible as a float).
WSL or Docker
I don't understand why would you downvote me, wsl or docker aren't windows.
Amazing tutorial ü•áüî•üöÄüëèüëå
It's worth noting that TinyGo doesn't provide GC (except for ARM targets), so all memory allocations are never freed. That means that if you running your webasm app for a long period of time - it's going to eat a lot of memory.
I did not downvote. Yeah, they aren't Windows but provides an option to use it.
Why should I downvote, by the way?
Thanks :)
aren't available for Windows != aren't Windows
Lol that‚Äôs true. It is I think pretty confusing the first time you see it then it becomes pretty clear.
Hi. Thanks for sharing your code, here's some suggestions / comments from my side. `ReadStdin()` [reads](https://github.com/foxyblue/tinj/blob/master/pkg/root.go#L19) one rune at the time, this seems inefficient. Why not use [(\*bufio.Reader).ReadBytes()](https://golang.org/pkg/bufio/#Reader.ReadBytes) or [(\*bufio.Reader).ReadLine()](https://golang.org/pkg/bufio/#Reader.ReadLine) instead of calling ReadRune() repeatedly? (And what would happen [here](https://github.com/foxyblue/tinj/blob/master/pkg/root.go#L20) if err is another error than io.EOF?) Why call json.Unmarshall twice in [(\*lineFormatter).Print()](https://github.com/foxyblue/tinj/blob/master/pkg/formatter.go#L24)? There are no unittests. How do you know the code does what it's supposed to do?
Beginners are only beginners for a little while. Then they have to suffer through the horrible error handling like the rest of us.
If you don't want GC, and don't want to give the programmer the responsibility of memory management, Rust is where you'll likely end up. For many tasks, it's quite a decent language, but if you try to be clever with DAGs, you'll end up with a lot of &lt;...&gt;.
https://github.com/golang/go/issues/32437 was locked. It seems the Github interface exposes no history of such actions. Anyway, while an issue was locked, people kept arguing that the locked issue's thumbs up/down voting means something. That combination was just silly. You can have either one but not both; either voting is allowed and results indicate something, or it's not and they don't.
This is what you see. I'd be much more worried about what you don't see. Maybe everyone who experiences this weird postfix operator googles until they find the information and then accepts that everything is fine and continue using rust (and then think it's good) ... I would bet a lot that doesn't happen 100% of the time though. It's a lot like the generics problem in Go, you hear loud angry shouts from the people who expect it to be there but you hear very little from the people who just accept it (or got used to being without it) or even from those who shrug and use something else because it's not there.
I looked at rust a little bit and didn‚Äôt like the syntax myself, but I would hardly call it poorly designed. I prefer go because I feel it is designed better, but that doesn‚Äôt mean rust is poorly designed, or even bad in any way.
Hundreds of lines of code to use *os.PathError?
This isn't relevant because rust's result type returns a union, not both the potential value and potential error. Why this difference is important is because in Rust you must unpack the result to get the returned value. I don't code in Rust, so there may be a way around this, but this generally means highly nested code or other verbose methods are required. Additionally, Rust has macros, which are very different from anything Go offers. Try is something anyone could write, so it's more of a standard library feature than a language feature (until they added the special syntax). This means things hiding return statements is not unique to try.
I would be against the question mark operator for a try simply because it means something different in two of the biggest mainstream languages today: it means an ‚Äúoptional‚Äù in Swift and Kotlin. I actually really miss the optionals in those languages as it makes it super clean to traverse a struct tree. You may end up with a null value because the root object was null instead of a segfault, and it can be done in one line instead of several. Making it too easy to just pass the error upward is what causes bullshit error messages that a user of the software, even a sysadmin, can‚Äôt decipher in a meaningful way. I know software developers love our stack traces, but those are absolutely meaningless to a sysadmin or end user who‚Äôs trying to debug an issue. Take parsing CSV for example. I can‚Äôt count how many times excel or some third party library has produced a sub-standard CSV file. Mismatched quotes or UTF-8 inside a ASCII file. ‚ÄúError parsing file‚Äù. Thanks. Where. Why. What can‚Äôt you parse about it. Ruby‚Äôs CSV parser makes me want to jump out a window because of this. Give me intelligent context. The best we‚Äôre gonna get from try is a stack trace. I‚Äôve seen some goofy proposals to use defer blocks to attempt to add context, but damn if that just makes it much more spaghetti and confusing.
Thanks for the feedback! I take it that you're "notimpressed" ;) \&gt;There are no unittests. How do you know the code does what it's supposed to do? Standard: "It works on my machine." But you are right, unittests are a must to support more complexity and remembering what everything does and that it continues to do what it does. Currently it's just pseudo-code and you'll have to take my word that it works. I'll add them soon enough. \&gt;what would happen [here](https://github.com/foxyblue/tinj/blob/master/pkg/root.go#L20) if err is another error than io.EOF? No idea, I'll have to tests for this. \&gt; [(\*bufio.Reader).ReadLine()](https://golang.org/pkg/bufio/#Reader.ReadLine) This is a good tips. \&gt;Why call json.Unmarshall twice Also a valid point!
Is the server responding to the preflight OPTIONS request? You can see it in the network tab of chrome developer tools.
If you try to squeeze intermediate results that can't be represented by your type through a value of your type, you'll always have lossy results. You can see the same mess with integer arithmetic, but it's less common (although still quite common) because integer overflow is easier to spot, and conceptually easier to remember. Still you have people writing code like (a+b)/2 to compute the mean of two ints, so it's not like it isn't an issue "in practice."
gameswithgo.org video series will get you up to speed quick
Build something. Practical experience is far more valuable than a large amount of half forgotten facts. Also relax, your employer will not expect you to know any Go when you start in a junior position (assuming you didn't massively lie on your CV). As such they will give you time to learn and train you up. Very little will be expected of you for the first few weeks and likely months. It can help to get started now but don't burn yourself out before you even start. Have some fun, build something that interests you, dip your toes into the language but don't try and become an expert in 3 unsupervised weeks.
One thing I love about Go is it's readability. I cannot say the same thing about Rust. The right decision for Rust and its design/audience may not (and probably isn't) the right decision for Go.
Go has excellent online documentation - read it in combination with the tutorials and examples @ https://gobyexample.com/ Go is in many ways a very simple language so three weeks should be enough time to develop a good understanding of the fundamentals.
Typical golang gatekeeping
What a great article. I'm going to have to dive into tiny go more.
There‚Äôs a small handful of other features that it doesn‚Äôt support either: https://tinygo.org/lang-support/ Most notably, ‚Äúyou should treat goroutines as an experimental feature‚Äù. Unfortunately, properly supporting goroutines without additions to the WebAssembly spec would most likely require significant bloat (which is a large contributor to Go‚Äôs large WASM binary sizes). See https://github.com/WebAssembly/design/issues/796#issuecomment-401310366
I tried to summarize some details that usually developers do not know - any feedback is welcome
It is easy: 1. History of development shows. It was a language with heavy runtime with green threads (similar to goroutines) and garbage collector, i.e. something at the current level of Go. Moved to the low level niche since that. This means they barely had an idea what they were doing. Really bad sign. 2. History of syntax. Rust code looked even crappier from the beginning. Bad sign as well. 3. ‚ÄúResult‚Äù and ‚ÄúOption‚Äù types are completely alien for imperative flow as they cause excessive nesting. Creators introduced ugly workaround with `try!` macro which is exactly like recent `try` proposal with all its disadvantages (lack of error decoration at first). 4. Rust is focused on functional approach too much (those fancy maps, filters, reduces). Engineers who love this approach think they are smart using it. And me, as a mathematician, think these people are pathetic. I am easy with these idioms and I am afraid functional approach lovers just don‚Äôt have enough training to see the method shortcomings: ‚Äúreduce‚Äù is just naturally flawed (see at tons of different folds in Haskell) and they better use pretty array comprehensions for initializations. 5. They refused to introduce [] operator for maps because of float keys. Float keys for maps? 6. Lots of other issues All in all, the Rust looks exactly like Russian Lada cars from 1990s.
&gt; by default on Unix in `$XDG_CACHE_HOME/.cache` or `$HOME/.cache`. That's not quite right. It puts things in `$GOCACHE`, which on non-macOS Unix defaults to `$XDG_CACHE_HOME/go-build`, where `$XDG_CACHE_HOME` defaults to `$HOME/.cache`. It doesn't put things in a `.cache` directory *inside* of `$XDG_CACHE_HOME`, `$XDG_CACHE_HOME` *is* the `.cache` directory.
&gt; If you don't want GC, and don't want to give the programmer the responsibility of memory management, Rust is where you'll likely end up. That's a very narrow set of restrictions that's often assumed to be a common requirement in software projects. Outside of niche uses, it's not common.
It does offer other advantages, such as no deadlock. But indeed, most jobs could simply be done in Javascript.
Hi, thank you for your feedback - Yes thats right, it uses first `$GOCACHE`. I should have been more clear about that. I'm not sure to follow you about `$XDG_CACHE_HOME`, the code in Go is: &amp;#x200B; `dir = Getenv("XDG_CACHE_HOME")` `if dir == "" {` `dir = Getenv("HOME")` `if dir == "" {` `return "", errors.New("neither $XDG_CACHE_HOME nor $HOME are defined")` `}` `dir += "/.cache"` `}` It concats the `.cache` to the default folder. Did I miss something?
Pretty good! Didn't know about the metric reporting functionality.
That code, properly formatted for Reddit is: dir = Getenv("XDG_CACHE_HOME") if dir == "" { dir = Getenv("HOME") if dir == "" { return "", errors.New("neither $XDG_CACHE_HOME nor $HOME are defined") } dir += "/.cache" } If `$XDG_CACHE_HOME` is non-empty, then it doesn't append `/.cache`. See also: the comment a few lines up: // On Unix systems, it returns $XDG_CACHE_HOME as specified by // https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html if // non-empty, else $HOME/.cache.
You need to fire your sysadmin if he can't read a stack trace.
FYI a stack trace doesn‚Äôt provide you everything either. It‚Äôll say it had trouble opening a file or similar, but won‚Äôt say what file. A stack trace is not useful for production, but only for developers. I fucking hate it when a developer can‚Äôt produce proper, sensible error messages to help devops solve the problem quickly.
I think https://github.com/libra/libra is a relevant update on the discussion.
I would start with the Go Tour on the main Go website and then look into gRpc, create two services that communicate with each other. In 3 weeks you can learn a lot, im on week 2 and im creating go services with gRpc and Rest support, granted im a medior so maybe just getting to know the language is enough to keep you busy. One thing that tripped me up a lot was package management, use vscode it will ask you to install a bunch of plugins that make your life easier and follow tutorials, in 3 weeks you can get a good grasp on the generals of working with Go.
Maybe taking advice from Stroustrup makes sense for Rust since it's a kitchen sink language like C++, but this definitely doesn't work for Go. I switched to a C++ job 2 years ago from Go. I still maintain some open source Go projects. The amount of complexity is too damn high in C++. At work, we regularly have bugs because not everyone is a C++ expert. Adding more ways to handle errors seems like a terrible idea. At least in our code base, we have so many ways to handle errors that either people skip it altogether or end up chosing the wrong one. `if err != nil` is a breath of fresh air. Increasing complexity and typing a little less just doesn't seem like a good trade for being dummy-proof and flexible. There are things that I hate about Go, error handling is not one of them.
You need to fire your developer if that's their idea of handling the error.
I just tried to use a library that uses a library that uses his library. It's a complete mess. [He's been deleting tags and re-adding them on different commits](https://github.com/dgraph-io/badger/issues/886). [He keeps on breaking everybody's shit](https://github.com/dgraph-io/badger/issues/904) for the sake of keeping his tags "sensible".
I already solved the problem. Thanks for your help anyways!
You're pushing this idea of a hypothetical problem with no evidence. If there's no evidence of it being a problem, why worry about it? If people didn't like it, we'd probably see a lot of rust code using the explicit \`try!()\` macro, or manually matching on \`Results\` to return errors. Rust code doesn't generally look like that. Or we'd here people complaining online, if not about the feature itself, then about problems arising from the feature. It just doesn't seem to be a major source of issues for people. For sure, there are debates about the best way to structure error handling in larger projects (see discussions over error\_chain, failure, custom error types, and \`Box&lt;dyn Error&gt;\` as ways of handling errors), but those issues are present regardless of what syntax you use to pass errors around.
&gt; You're pushing this idea of a hypothetical problem with no evidence. In the talk he said people who had been using rust for a long time initially didn't like it ... but they came to like it. There's also a lot of history of people disliking similar looking things (like the ?: operator in C). On a personal note I think it also looks ugly with the required ';' (I have conflicted thoughts about it other than that somewhat minor part -- but I don't intend to use rust).
Sure 1. History of development. They started from something with heavy runtime and green threads and GC and ended with C-sh low level. Then upped it to the C++ (panics handling). These kinds of changes means people were learning too much in the process. I am not against learning, but good languages need steady foundations, not an amorphous list of wishes. I know people write something in Rust, but this is not telling argument ‚Äî there are lots of software written in C++ or PHP. 2. History of syntax. Look at its early variants. Damn bird language it was. Sane design would have been similar to its current form (in fact sane design would have been different ‚Äî C++-sh templates were unlucky choice) 3. Result and Option are core types and processing for both doesn‚Äôt fit well into imperative flow because they causes excessive nesting. The aforementioned `try!` macro (and `?` operator) is just a workaround on this issue and has all the shortcomings proposed `try` have: context lost, unclear flow, etc. In my opinion this is by far the worst issue with Rust. These types processing is much more annoying than Go‚Äôs error handling. There are several methods to make it as easy as Go‚Äôs error handling without a sacrifice of type safety. What is it if not a poor design? 4. A showcase. These guys were asked for [] operator in maps instead of get and set methods. They refused because of float keys in these maps. Wait, float type keys in maps? 5. etc I am pretty sure these guys would make much better language if they were asked for improved Rust without backward compatibility, but this approach looks like a student‚Äôs work a bit too much.
Sure 1. History of development. They started from something with heavy runtime and green threads and GC and ended with C-sh low level. Then upped it to the C++ (panics handling). These kinds of changes means people were learning too much in the process. I am not against learning, but good languages need steady foundations, not an amorphous list of wishes. I know people write something in Rust, but this is not telling argument ‚Äî there are lots of software written in C++ or PHP. 2. History of syntax. Look at its early variants. Damn bird language it was. Sane design would have been similar to its current form (in fact sane design would have been different ‚Äî C++-sh templates were unlucky choice) 3. Result and Option are core types and processing for both doesn‚Äôt fit well into imperative flow because they causes excessive nesting. The aforementioned `try!` macro (and `?` operator) is just a workaround on this issue and has all the shortcomings proposed `try` have: context lost, unclear flow, etc. In my opinion this is by far the worst issue with Rust. These types processing is much more annoying than Go‚Äôs error handling. There are several methods to make it as easy as Go‚Äôs error handling without a sacrifice of type safety. What is it if not a poor design? 4. A showcase. These guys were asked for [] operator in maps instead of get and set methods. They refused because of float keys in these maps. Wait, float type keys in maps? 5. etc I am pretty sure these guys would make much better language if they were asked for improved Rust without backward compatibility, but this approach looks like a student‚Äôs work a bit too much.
&gt;Why this difference is important is because in Rust you must unpack the result to get the returned value. I don't code in Rust, so there may be a way around this, but this generally means highly nested code or other verbose methods are required. You can do this in an unsafe block, but it doesn't really make sense to do. The Result type is an enum, and Rust enums are tagged unions. If the enum contains an error but you try to read the success value instead, you are essentially transmuting the bits from the error type into the success type, resulting in garbage data.
 &gt;I don't code in Rust, so there may be a way around this, but this generally means highly nested code or other verbose methods are required. No, embracing `Result` as a return type also means that there are a multitude of first class ways of dealing with it. `let value = result?; // same as var value, err := result; if err != nil { return nil, err }` If that isn't already enough to convince you of the usefulness of `Result`, then here are other ways you might deal with it, all in *much* less verbose ways than Go's second class handling of err. `let value = result.unwrap(); // panics on error` `let value = result.ok(); // returns Option&lt;T&gt;` `let value = result.unwrap_or(default); // returns the value or a default value on error` &gt;Additionally, Rust has macros, which are very different from anything Go offers. Try is something anyone could write, so it's more of a standard library feature than a language feature Macros just expand into something anyone could write. There's no magic (except that sometimes they hide some complicated mechanism). There is nothing you can achieve with macros that you couldn't with regular code (except clarity, perhaps).
You conveyed my exact feelings about this situation.
[removed]
Lots of good advice here. I would suggest, after reading the docs, and playing a bit, make an attempt at converting some of your Java projects to Go. Guaranteed that‚Äôs where some of the ‚Äúreal‚Äù learning will start
&gt; Why this difference is important is because in Rust you must unpack the result to get the returned value. I don't code in Rust, so there may be a way around this, but this generally means highly nested code or other verbose methods are required. Something like this fn do_three_fallible_thnigs() -&gt; Result&lt;(), ErrType&gt; { match fallible_thing_one() { Ok(result_of_call_one) =&gt; match fallible_thing_two(result_of_call_one) { Ok(result_of_call_two) =&gt; match fallible_thing_three(result_of_call_two) { Ok(val) =&gt; Ok(val), Err(err) =&gt; Err(err), }, Err(err) =&gt; Err(err), }, Err(err) =&gt; Err(err), } } Can be written a bit more monad-y like: fn do_three_fallible_things() -&gt; Result&lt;(), ErrType&gt; { fallible_thing_one() .and_then(fallible_thing_two) .and_then(fallible_thing_three) } Which means the same thing - `and_then` only operates on a contained `Ok(value)` and is effectively a no-op for an `Err(error)`, so the three functions only get called if the previous one did not emit a failure. The end result will either be the error (which 'fell through' the `and_then` calls) or else the final `Ok(value)` emitted by the `fallible_thing_three` call.
 go get github.com/mongodb/mongo-go-driver should do the trick
I ran that and attempted to build the application again. It still returned: mongobuster.go:12:2: code in directory /root/go_projects/src/github.com/mongodb/mongo-go-driver/bson expects import "go.mongodb.org/mongo-driver/bson" mongobuster.go:13:2: code in directory /root/go_projects/src/github.com/mongodb/mongo-go-driver/mongo expects import "go.mongodb.org/mongo-driver/mongo"
It seems you are running as these go commands as `root` user for some reason, becase of the paths starting with `/root`. Do not do this! You may damage your system! The only programs run as root should be system tasks which *require* root privilleges.
This is a non-persistent kali usb I use to mess around with, I would definitely swap from root in other circumstances :)
This package is NOT using Go Modules, so it expects everything (all dependencies) to be in the GOPATH, including the package itself. The quickest way to get this to build would to add a `go.mod` file, set the name of the Module and the let Go figure out the dependencies it needs. Must use Go &gt;= 1.11
First off I would say to just relax and go with that feeling that it'd a junior level role and you will have time to learn alongside your team. We hire junior roles and don't expect them to hit the ground running on day one. 3 weeks is actually a decent amount of time in the context of learning Go. If you have fundamentals in another language, you can get through all the Go basics (Effective Go) and the Go Tour and then try something practical like a command line tool or serving some json endpoints in a simple http server. I've seen devs at my work with zero Go experience start submitting merge requests to a Go project in 6 hours, or writing a prototype web service in a day or 2. From that point it's just about asking a lot of questions and improving on idioms. Again, don't worry about cramming.
Sorry, new to go. You create the go.mod file in the GOPATH location, correct?
It is telling you that this project uses a vanity import path and that you have cloned it to the github name and not the vanity name. That being said, the `go get ` command thag you ran already did the right thing and cloned it to the correct name, built it, and installed it to your $GOPATH/bin or $GOBIN
In the root of mongoBuster run this: `echo ‚Äúmodule github.com/yashpl/mongoBuster‚Äù &gt; go.mod`
Thanks dude, that worked perfectly
Well, having experience with both I can say that Rust is easier to read once you get familiar with built in functions. The easier to read part of Go seems to work only for new people. Once you get used to it, reading through many for loops and imperative semantics of the language tends to take a lot longer than reading declarative code with short expressions which convey just as much information.
One thing I simply can't understand about Go community, is the insistence that higher verbosity == readability. Personally I find the opposite to be true. That may help the newcomer to understand the language quicker, but once that's out of the window after first week or so, higher noise-to-signal ratio just makes things more time consuming to read and increases change of missing something important once brain get adjusted to skip the "irrelevant" ever repeating parts.
\&gt; it feels like I'm just cramming as much information as I possibly can and not really digesting anything. I think you just answered your own question. You need to switch from "learning" to "doing". Write some programs in Go. Start with things you are familiar with, re-implement them in Go. But make sure you aren't writing "Java in Go" (it's hard, but possible.). Use Channels, Structs, Methods, etc. You can take a look at the excellent [https://exercism.io/](https://exercism.io/) which helps you learn. &amp;#x200B; \&gt; Or maybe I should just relax and not worry about it because they know I'm a new, junior engineer that will be learning on the job. Yes, you could do nothing, then just show up. But the further ahead you are in Go, the faster you will pick everything else up. There is a **lot** more to programming than the language. (Testing, CI/CD, Deployment, Reviews, Git, PRs, Bug tracking, sprints, documentation, monitoring, troubleshooting, observability, tribal knowledge, etc.)
Basically everything. Just start on a cool project
Why not design a the language in a way that all functions by default return an error possibility? There could be default error handling, by providing a callback function. No need for try/catch or err != nil. I think this is the way rust does it? Anyways, coming from Java and Node, the golang's way of handling errors is sane enough for me.
Quite honestly go is a simple language. If you are enthusiastic about learning it, you have plenty of time to learn it over at https://tour.golang.org
Leaned go in less then a week, started a project right after. Then 2 weeks after had a running backend with all the features I required and now it's been quoted to a lead and we have 2 additional leads coming in. Phase 1 is done and now management is about to give me the go for phase 2.
I'm using Gin router as the feedback was that gorilla is 2 big and slower, is this still true?
Seems interesting, next week I'll give it a spin and send you my feedback. Since I'm using graphql I need something like this and I build my own query builder helper but I feel I could have done a better job, just didn't have the available time. I'm also using postgres, so if I'm missing a feature maybe I'll contribute some...
Second this!
I agree with your feeling about error handling. I am curious what the things you hate about Go are?
Feedback is always welcome. Thanks. I wish someone had started something like that before me so I did not have to. Not sure why others did not. Also as this will grow I will add other dialects in. Just need immediate need right now.
&gt; We recently scanned all the open source projects we could find and discovered that this snippet occurs only once per page or two, less often than some would have you believe. ‚Ä¶ And other hilarious jokes you can tell yourself They clearly haven't seen my projects, haha. Still, I love `if err != nil`. Fuck try / catches.
no javafication of golang.
This article is from 2015...
Hi, thanks, I do not know how I missed that -_- I will fix it, thank you for your help!
It‚Äôs still relevant today, especially with the `try` proposal.
It's not try/catch.
In my opinion, this is a real world problem too, since there are new developers that are doing this mistake and get frustrated with Go language. Here is another one of `frustrating code`: ```go type People struct{} func (p *People) Method1() { fmt.Println("Method1 called") p.Method2() } func (p *People) Method2() { fmt.Println("Method2 called") } type Teacher struct { People } func (t *Teacher) Method2() { fmt.Println("Overriden Method2 called") } func main() { t := Teacher{} t.Method1() } ``` Most ex-Java developers get upset when you show them this :)
I know this post is in the pro-try/anti-try discussion, so I'll throw this fact here. [59% of all error handling code (in the so-called Go corpus) can be directly (and automatically) rewritten to use 'try'.](https://github.com/golang/go/issues/32825#issuecomment-508959127) This number will probably go way higher if we rewrite some code to use deferred error decoration.
And it cannot practically be applied to 90% of anyone's code, including the stdlib. But people will try to point to it like it's some sort of panacea.
Any half decent library will add the path to the file (if it indeed is a file, and not some abstract input stream) to the error message accompanying the stack trace
OMFG... Again... Well, I, personally, don't need it, I'm fine with nil checking, pointer/value checking and a defer statement. After all, I believe, we all have our own handlers written, most of which look like: ``` // OhShit panics when shit happens. func OhShit(err error) { if err != nil { panic(err) } } ``` Which entangled with defer gives us the very same result, which is still readable compared to `try(not(to(try(or(try(it(harder(moron()))))))))`.
They should. Sadly, that‚Äôs not always the case, especially if you‚Äôre using some more obtuse library for decoding something lesser known.
Readability. Try separates the two distinct paths of the code into two distinct blocks, whereas the current approach is to intertwine error handling within regular business logic
This is extremely cool, we use Vegata all the time, having an API could really change how we look at CI for our releases.
Regarding all the projects that contain this type of error handling and their claim "occurs only once per page or two": The important distinction here is that more error handling happens closer to IO actions, and less of it happens further away from it. It's perfectly possibly that at time of writing (2015) there were equal parts of code that don't deal with IO as there were parts of code that do. Your view personally can be incorrect in a global perspective if you mainly deal with writing REST API's for example. That's IO heavy stuff.
Soon to be outdated by `try()`.
They also developed a nice alternative to GRPC written in Go: [Twirp](https://github.com/twitchtv/twirp)
Actually Rust has `[]` for maps ([example][1]). Of course, a HashMap requires that the key implements the `Eq` trait, so you cannot use floats, since they do not implement `Eq`. [1]: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=260e255c55d395518436c570a6448386
I'm not pro or against try, but the readability argument you make is a bit a straw man. You would probably split the nested function calls into lines using intermediate variables to make it more readable.
Almost all of the language? Go‚Äôs spec is concise.
It's not clear how OP intended this to weigh in the try discussions, though it seems clear it was meant to be read one way or the other. In my mind this is still relevant even in the world of try. Usually when I have try-candidate code (that doesn't wrap the error) it's because the error is already being generated by nearby code that has enough context. It's easiest to arrange for that to happen when you treat errors like values, and helpers like the ones in the blog post can include context and then the caller can just try on its result. I'm still skeptical about try, but I will give it a shot when the prototype is ready.
Why should infallible methods be able to return an error? And Rust definitely does not use callbacks for error handling.
Making something dummy proof atracts dummies though.
Yeah, right this is because in complex loops like: ``` func (r *Reader) Bytes() (data []byte) { for _, unit := range r.foos { if unit.CanDo() { data = append(data, unit.Do()...) } else { for _, bar := range unit.bars { if parser := bar.Parser(); parser != nil { if err := parser(unit); err != nil { panic(err) } } } if unit.CanDo() { data = append(data, unit.Do()...) } } } } ``` using intermediate variables is so much better for the readability and the cyclomatic complexity than: ``` func (r *Reader) Bytes() (data []byte) { var batch []byte for index, unit := range r.foos { if unit.CanDo() { batch = unit.Do() } else { batch = r.reparseFoo(unit) } data = append(data, batch...) } } func (r *Reader) reparseFoo(foo *Foo) (data []byte) { shit(foo.reparseBars()) if unit.CanDo() { data = unit.Do() } return } func (f *Foo) reparseBars() (err error) { for _, bar := range f.bars { if err = bar.tryParser(); err != nil { break } } return } func (b *Bar) tryParse(r *Reader) (err error) { if b.parser != nil { err = p.parser(r) } return } func shit(err error) { if err != nil { panic(err) } } ```
Have you ever heard of cyclomatic complexity and it's relatively tight relationships with readability?
So far I've seen 3 different numbers. I've seen 95%, 70% and now 59%... \¬Ø\(¬∞_o)/¬Ø
70% is for the Go standard library. 59% is for the Go corpus, which should be representative of Go code in the wild. Not sure where 95% came from.
If you actually check.. 40% of corpus can use Try, out of the box. That said, Im still against it. But your numbers are just wrong.
https://github.com/golang/go/issues/32825#issuecomment-508959127 &gt; So, in real-life code, 40% of if-statements are written for error-checking, and try can eliminate 59% of them out of the box. 40% is the number of if statements used for error checking out of all if statements in Go code.
Here's the main doco: [https://urban-wombat.github.io](https://urban-wombat.github.io/)
I was obviously talking about the "errors are values" "article", since the second sentence cant be reasonably applied to the recent try proposal
Yeah I see you just edited your comment to something else
This is just anecdata, but: I knew no Go when I started my current job, as a junior dev. I delivered my first project (microservice listening to a message queue, getting data from other internal services and publishing formatted data to a third-party API) in about six weeks. (This included learning a lot about the company's internal infra architecture, etc, that isn't really Go-related) As others have said: take a concept you know from your previous projects and try to implement it in Go.
Dude, he just added this clarification: `("errors are values" )`. I read his comment before the edit and understood it exactly as he clarified it now. You just misread him.
Eh, yeah I saw the edit. Still doesnt change that several were confuse by it. So its great that you understood it, but not everyone did.
I think what he meant is that the Rob Pike's idea cannot be applied to 90% of Go code, which could be interpreted in two ways: 1. 90% of Go code isn't suitable for the Rob Pike's idea. 2. Rob Pike's idea isn't as universal as `try`, which can be applied to 90% of Go code. In both cases, the 90% is just a guess, of course.
How so? Pretty much every piece of Go code is using errors as values. The point of the article is not in the given example, which is not very practical indeed, but in establishing proper mindset when writing Go.
That doesn't tell anything useful actually. 59% could very well indicate that we have a problem (and we do) with people not decorating errors and just "rethrowing" them. "try" will only make this worse by encouraging this way of handling errors. And that's my personal gripe with it - without some way of decorating it will be do more harm than good.
I think almost zero of mine would, I wrap everything with more context so you actually know what‚Äôs going on before hunting down line numbers. Callers should decorate errors with args IMO, not the callee, they defer stuff looks worse than just returning a errors.Wrap(), but it should be decorating each call, is it writing to a file, closing a file, whatever.
`try` actually makes the most common case of decorating errors (one context per function) much simpler, because you don't have to repeat it with each error: func doSomething() (err error) { defer fmt.HandleErrorf(&amp;err, "doing something") x := try(oneThing()) try(anotherThing(x)) // ... }
After using Elm for a while functional stuff in Go looks ridiculous. This pattern doesn‚Äôt scale too well if you have more than one ‚Äúconstructor‚Äù in the pkg, and they all start with With* or something for discoverability. Chaining is kind of nicer that way, at least you can quickly find what the options are and there‚Äôs no need to prefix for a particular type.
Why use a builder pattern over the functional options idiom tho?
I wish this pattern would disappear haha. a) Go is not a good functional language b) you can't really discover what the options are in auto-complete easily, unless they're all prefixed with \`With\*\` or similar c) it over-complicates something that isn't complicated at all (use a struct) d) chaining has better discoverability and you can have multiple types in one package, with functional options you have to prefix for each otherwise you have no idea which options are which.
I wouldn't call this much simpler - the flow is broken. I wouldn't call it the most common case either. It kinda works in simplistic cases like always with these examples but in the real world you have different decorations for different call sites. This will make defer useless or very cumbersome to use which, in turn, will encourage to just return an error as it is. &amp;#x200B; And if your decoration is the same for every call site in the function then there're no point in even decorating it. The point of decoration is to add useful information. Just return it as it is. Although cases like this are very rare, they would actually benefit from "try".
&gt; Matt Klein, a member of the Go steering committee recently apologized for the angst caused to some people by "the try() kerfuffle... Change is hard, but sometimes it's for the best." I've never heard about Matt Klein, nor I'm aware of the existence of any 'Go steering comittee'. What the hell is going on here?
XAMPP is already bound to that port, if I understand your problem correctly. If you want your Go program to bind on that port, you should kill the XAMPP process or configure it to use a different port. Otherwise, you can choose a different port for your Go program, like 8080.
Dave Chaney gives some great comparisons in his blog post: https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis
&gt; And if your decoration is the same for every call site in the function then there're no point in even decorating it. I feel like this is the key misunderstanding that perpetuates much of the opposition to `try`. Suppose we have an error message like this: update news feed: update Reddit: fetch reddit.com/r/golang: couldn't reach https://reddit.com/r/golang What if the `couldn't reach` part was generated by a network function, the `fetch` part was generated by a `fetchWebsite` function, `update Reddit` was generated by `updateGroup` function and `update news feed` was generated by an `updateNewsFeed` function. Or something similar. If we just move the decorating inside the functions where it belongs, we can most of the time use `defer` decorating.
Oh, so the problem is that my Golang program is using port 80, but so is XAMPP. I get it. So I just change the 80 in my code to something else, then type ``localhost:8080`` or whatever it's set to in the code.
But we all knew that. Exceptions are also just values that get passed up the stack. It didn't present any new information, and was akin to saying that "true" is a boolean. In my mind that post's goal was always to present some novel way of dealing with errors, but it was neither novel nor applicable most of the time.
Obviously some kind of troll.
That's not how errors work today in Go and shouldn't work in general. The function itself should return only information why it failed itself. The information that fetch function failed because fetch is failed is useless and redundant. That's what the caller should return - it calls the fetch function and decorates any possible error as such. Even better, the caller actually has the context in which the call was made. Maybe a function calls fetch twice - which of the two has actually failed? In Go this problem is solved by wrapping and decorating. You get logical call stack which tells you exactly the flow of execution. try doesn't align with this at all and works only in simplistic cases where decoration is not needed. I have a similar problem in Swift now. There we already have this try function but have no way of decorating errors in the standard library and even no established practice to do so with third-party libraries. It's expected that you just let errors bubble up the stack and reach some catch block. That's useless because you don't even have call stacks like in exceptions. Maybe there is some other solution but right now I'm forced to put do/catch (similar to try/catch) blocks around every other function just to give it some context and allow me to trace the flow back when something fails.
&gt; The information that fetch function failed because fetch is failed is useless and redundant. It's only useless and redundant if you also decorate it in the caller. And that's the point! If you don't add this decoration in the caller, then great, you suddently can use `try`, without losing any context. The situation with two fetches: that's a good candidate for `if err != nil`. But it's not the majority case.
No, exceptions are always treated like something very special that you shouldn't touch unless you have to. You don't see them being stored as fields, transferred over the wire. The point of the article was to convey that errors are just values - you store them in structs, pass the around as arguments, do anything with them and build complex logic around them. That's very different from what exception has taught us. Remember the usual rule that you shouldn't use exceptions for control flow? It's not novel indeed but was lost because of the abundance of languages with exceptions. In C we had errors as values and treated them as such. Go tries to bring this back and I'm glad it does. In today's world it feels very refreshing and for me works much better.
&gt; But it's not the majority case. But in many cases you call different functions for different purposes inside one single function. Try doesn't work here because only the caller has the context. &amp;#x200B; &gt; It's also how stdlib functions work There's no useful context for me in this example to just re-throw the error with try. Why I was even calling this function? Which of the calls failed if there're multiple ones? That's the context and only the caller has it. Try doesn't let me add this context, so I will not use it. But I don't expect everyone else to be so responsible as to give proper judgement where try can and can't be used. That's why and probably many others are opposed to try. Syntactic sugar shouldn't encourage bad code.
I roughly see as many exceptions being stored in classes as errors in structs. I've seen them being used pretty much like everything else, and honestly I have no idea where you claim that you shouldn't touch them comes from.
Also, [os.Open](https://os.Open) example is an outlier. If you look at the implementation, you will see that "os" package uses generic error type that contains various things, among which is the operation that failed. If we look at other packages, there's a very different picture. Pretty much every other package returns only the reason error occurred. For example, crypto/aes package will fail with exactly the same errors for Encrypt and Decrypt functions. It is expected that you, the caller, will give it proper context.
Very good read, thank you for sharing!
Can you post the code you've written so far? You're working on Windows, right?
Looks like you program in very unique environment. For me it's all common knowledge supported by years of practice in languages like C++, C#, Java and reading tons of information from other people. Exceptions are not treated like regular values and never were. The fact that it's a common antipattern to use them as control flow should tell you something.
Yes, I'm working on Windows. I know the code must work because I copied it wfw from the tutorial. I'm just confused as to why it's not connecting and running.
We will need to see your code to help.
``` package main import ( "fmt" "net/http" ) func main() { http.HandleFunc("/", handler) http.HandleFunc("/earth", handler2) http.ListenAndServe(":8080", nil) } func handler(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello World\n") } func handler2(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello, Earth\n") } ```
ListenAndServe() returns an error, check for that and print the error to the console of its not nil. Then you'll see what's going on.
But surely if the tutorial code worked, this should as well?
As I already wrote in the article, try to avoid the actual practicality of the approach. The primary goal is to teach some basic FP concepts, using a well-known design pattern.
Rust has \`\[\]\` for retrieval, but not for insertion. Insertion requires the \`.insert()\` method, which is not the most elegant. This is potentially something that could be "fixed" in a future version of rust though, as it would be backwards compatible with the current syntax (unless I'm missing some nuances that would prevent it). It might introduce some weird inconsistencies with other pattern matching structures, though.
Not if you also have something listening on port: 8080. Every computer is a little different, you need to deal with every error.
[removed]
[removed]
I'm pretty sure I don't have anything else on 8080.
Ok, well, if you don't check for the error you'll never know why it's not working. Might be a permissions issues.
The referenced apology says "Go++ steering committee" so obviously the person who wrote the Slashdot summary didn't get the joke.
How would I change the access permissions?
I haven‚Äôt really had a problem with it unless: a) they don‚Äôt have the With* prefix. b) there are two types of them in a single package.
Run as a different user. Until you handle the error and find out what's wrong is it's all just guess work.
Noicee blog, but i think go has type conversion and not type casting, those are different stuffs. I am not an expert but i think go by default creates new data of the new mentioned type. Type Casting is done through unsafe package i think. Be sure to google it i might be wrong Nice post from a nepalese brother???
When you say "as a different user", do you mean log out completely and log back in as someone else, or run XAMPP as admin or something?
Seriously, check the error. Three lines of code.
I did. It says: ``` 2019/07/07 15:18:58 ListenAndServe: listen tcp :8181: listen: An attempt was made to access a socket in a way forbidden by its access permissions. ```
Yeah it‚Äôs fine in that kind of situation, but it doesn‚Äôt really scale to all types of packages so it seems like an awkward pattern to only use in certain scenarios
I am glad it's helpful. Be sure to share some feedback if you decide to use it üòä
I am one of those people that were pretty against introducing ?. It‚Äôs now one of my favorite features. For me, the difference was actually writing more than a few lines of code that actually used it. I previously was trying to make an argument from principle, about sigils, about two ways to write the same thing, about it being too implicit. I don‚Äôt really write go, so I‚Äôm not saying that I think this proposal for Go is good or bad, but the presentation is very accurate with what happened in Rust.
(Rust does not prevent deadlocks, but it does make them harder to write in many circumstances)
Rust has tagged-union type enums ; the Rust standard library includes `Result` in the global namespace to make referring to an Ok/Error outcome easy. enum Result&lt;T, E&gt; { Ok(T), Err(T), } fn fallible_function(x: i32, y: i32) -&gt; Result&lt;i32, ()&gt; { if y == 0 { Err(()) } else { Ok(x / y) } } The rust compiler also includes some small magic that will warn you if you ever ignore a returned `Result` value, and as per the video Rust also has the `?` operator which will, if possible, convert an error into the same type of error the scope it's in returns and immediately exit that scope. So there's no requirement functions return an error, there's just a type that can easily represent either a good output or an error condition. Infallible functions are still able to return a primitive or nothing at all. fn constant_value() -&gt; i32 { 42 } fn do_nothing() -&gt; () {}
It is possible but does have some nuances, which is why we don‚Äôt have it yet. There‚Äôs been a proposal for it for quite a while, but it‚Äôs not enough of a pain for it to be enough of a priority to finish off, yet. Someone was actually just asking about the status of it today.
[removed]
Go (sort of) has both. You‚Äôre right that type [conversions](https://golang.org/ref/spec#Conversions) make a copy and conversions have the form newtype(oldvariable). Go also has [type assertions](https://golang.org/ref/spec#Type_assertions) which are what many other languages call casting.
Is your windows firewall on? Try turning it off, see if it works.
grpc is an example where it‚Äôs annoying because there‚Äôs the CallOption and DialOption.
I can't turn it off; it doesn't let me
 func (f Foobar) Something(a int, b int, c int (foo int, bar int) { // ... }
If you get this type message of error and, as indicated in your other comment cannot modify your firewall, then it sounds like you don't have permissions to allow the binding to this port and will need help from a system administrator.
And you have to visit http://localhost:8080 on your browser now. Port 80 is the default for http that's why you don't write it, same for 443 for https.
From the error you posted, you don't have permissions, and if you also don't have permissions to modify the firewall, then you need to get your system administrator / someone with a local admin account to add an exception for you.
Good point. However, it seems that the try statement wouldn't increase the number of branches, as otherwise you'd still need conditionals with early returns. Try would merely be syntactically less verbose or am I wrong?
Is this a work machine? Do you have an administrator account?
Type Casting and type conversion can be different in the root but looking them from the top level they are similar. The blog post contains basics about it, so these two terms are written interchangeably which might not be correct but is for simplicity. The one I have mentioned in the blog is typically a type-conversion. Type Assertion can be done for an interface. Yes, Nepal!
 fn something(a: i32, b: i32, c: i32) -&gt; (int, int) { // ... }
Your example shows my opposition to the try proposal. Suppose we have the error message you posted. How is this any better than attaching a stacktrace to the error? I'd even argue, that a stacktrace provides more information than magic defer error decorators. So far I've seen two different situations: 1. All errors are decorated with custom messages. In this case, `try` is senseless. 2. None of the errors are decorated, or all errors receive the same message. In this case, `try` saves a few lines of code and can make error handling much nicer. A good example for 2) is reading data into a struct. try can help reduce the `if err != nil` checks. Such code mostly does not care about which value was unassignable. Instead, a generic message like: "could not create struct" can be sufficient. As others have pointed out: Do you really think that adding `try` just for the 2nd case is justifiable? I fear people being lazy and a decrease of high quality code which does proper error handling.
Well, there's a good reason we don't have `[]` for insertion (although it has nothing to do with floats). In fact, you cannot use it for insertion with any container. let mut vec = vec![0,1,2]; vec[3] = 10; thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 3' In order to add a mutable `[]` for your type, you implement the [`IndexMut`][1] trait, which lets you return a mutable reference, which the user can use in various contexts. One use is to change the variable: ``` vec[0] = 10; ``` But the expression `vec[0]` returns a reference, which means you must be able to read from it too. What should the result be if you type `map[key]` for a non-existing key, and try to read from the reference? Indexing can only be used to change an existing value, never add a new one. In principle they could have implemented `IndexMut` for `HashMap` too, but they decided against it, because it was too confusing that it would only be able to change existing slots, and would panic if you added a new one. [1]: https://doc.rust-lang.org/std/ops/trait.IndexMut.html
That‚Äôs probably your issue. If you have a VM installed, you could try running/compiling on a VM.
A tip for the future: when asking for help online, make sure you understand your problem first. You should always at least check the error message in your program. Otherwise, Redditors and other online people aren't going to want to spend the time guessing at what the issue could be with you.
What I don't like about the idea is that it duplicates the existing pretty much straight forward solutions. All it does, it assigns the error value for you which you still need to check this way or another. By removing err variable from the equation it doesn't really simply anything, yet, it complicates the readability with the excessive brackets and not that much understandable execution flow. It doesn't replace the need to verify the error, the authors argue that the defer statement slows the code down, yet, they supplied a case in which the frames stack generated in a loop with a defer statement, where the alternative, not that straightforward solution is possible: when you need to defer an execution of multiple functions, store them in a slice and defer slice members calling, or avoid the overall defer usage at all, resorting to other branching strategies. I'm not against the whole bring something new idea, I'm against the ideas complicating things or not widely applicable. I agree with those saying that an error handling package in addition to what's already there would be bad, don't screw the language for those lazy not willing to clean own home.
&gt;trying to figure out if it's legal to add two integers. Rust is like that. Nono, that's C++. Rust fixes all that. If you do something that isn't legal, you don't have to check the manual, the compiler will tell you.
Something I think could be useful is in-place compression. A little while back I was looking into compressing data with snappy before placing it in a k/v store. Some other projects had tried the same thing and discovered that the extra allocation (`EncodedLen(len(data))`) tanked performance. Pools or scratch buffers can help mitigate the overhead, but they‚Äôre not always possible depending on the API. Is it possible for snappy S2 to use a small scratch buffer and allow in-place dst &lt;- src compression?
&gt; try actually makes the most common case of decorating errors (one context per function) much simpler 1. This pattern isn't common. I hadn't seen it, or used it, or thought to use it, even once, before the check/handle proposal. 2. It's simpler in one facial sense i.e. fewer LOC, but [much] more complicated in another, IMO more important sense, which is that error handling/decoration is now physically removed from the statements which generate the error.
&gt; That's not how errors work today in Go and shouldn't work in general. The function itself should return only information why it failed itself. Agree. The caller should to decide how to interpret or decorate errors it receives from the functions it calls.
It's also OK, and IMO even better, if Go doesn't change itself to make writing those programs easier. Because the risk is that the affordances appropriate for those programs leak into programs where they're not appropriate, and the overall ecosystem is made worse.
Flipping from white box testing to black box testing removes the tests from code coverage reports. Am I missing a flag or something non obvious? I had 100% code coverage, then I appended `_test` to the package name, etc, and coverage is now 0%.
In-place compression is somewhat doable, but likely at a non-trivial performance cost. The destination would at least need to be one byte bigger than the source to indicate whether it is compressed or not. For Snappy, the overhead will be between 2 and 8 bytes depending on the input length. You are probably better off by keeping used buffers around. Inplace Decompression is more feasible. I think the current (Snappy) assembler implementations makes assumptions that prevents that. But interesting nevertheless. I will see if I can come up with something.
I'll keep that in mind. I'm new to Go, so I'm still learning about that stuff. I fixed it now though. A friend of mine helped me out.
Good point. But are there 100% infallible methods? Maybe even a simple print to the console can generate errors in some extreme unlikely cases
It's a small tools to manage pull requests: * Checkout a PR (interactively or by its number) * Remove a PR (interactively or by its number) * Remove all ‚Äúcheckouted‚Äù PRs for a project. * Push on a PR. * Display all ‚Äúcheckouted‚Äù PR (for a project or for all projects) * Manage all your repositories. * Save your configuration: config/prm (or \~/.prm on Windows) * Only works with GitHub.
Coverage works fine for me with `_test` packages. I just run `go test -cover ./...` or something more specific like `go test -cover ./path/to/package`.
Another trick with the `_test` packages is that you can export things for testing within the same package. So, you can have a file like `export_test.go`: package example type SecretType = secretType func DoSomethingFun(s SecretType) { // ... } Then in `example_test.go`: package example_test import "example" func TestSomething(t *testing.T) { example.DoSomethingFun(example.SecretType{}) } Typically, you wouldn't want to do this, but I find it useful sometimes if there's some internal state I want to set (and offer a nice API during testing, rather than resorting to a non `_test` style and screwing around with unexported members).
How about the [`len`][1] method on the rust list type? Or `is_empty`? I mean, your example of printing to the console is bad, because that's IO and can easily fail: Just close the stream. If you want infallible methods, find methods that compute something. [1]: https://doc.rust-lang.org/std/vec/struct.Vec.html#method.len
don't you forget that it is `(f Foobar)` ? I think it is more: ``` fn something(&amp;self, a: i32, b: i32, c: i32) -&gt; (i32, i32) { // ... } ```
This reminds me of the Hub CLI https://hub.github.com/
PRM allows to commit on a PR branch, Hub checkout only a short link to the PR that don't allow to commit.
Do you know if there are other options, e.g. MSVC or MinGW? Unfortunately I'm locked into an update policy so I can't enable WSL, and Docker isn't "trusted" SW.
I am afraid not. I think the better way is to raise an issue in TinyGo's GitHub repository.
nice idea. I like it. &amp;#x200B; it would be great if you write more test coverage.
Any support for github enterprise? didn't see any mention of it
&gt; The rust compiler also includes some small magic that will warn you if you ever ignore a returned `Result` value, Note it's not really magic, it's just a [`#[must_use]`](https://doc.rust-lang.org/reference/attributes/diagnostics.html#the-must_use-attribute) attribute in the [type definition](https://github.com/rust-lang/rust/blob/9210359b18185f46af9c0f30cc3d2678394930ef/src/libcore/result.rs#L244). You can apply it to anything you like: #[must_use] fn annie_are_you_ok() -&gt; bool { false } fn main() { annie_are_you_ok(); } &amp;nbsp; warning: unused return value of `annie_are_you_ok` that must be used
The is mainly for OSS maintainer, but I already added the support for private repository https://ldez.github.io/prm/#private-repositories then I can create an option to manage Github Enterprise repositories.
I think an env variable to set the api base url something like PRM_GITHUB_BASEURL should do the trick and could be helpful in testing.
I think what is unfortunate is that the comments here seem to be specifically regarding the syntax and the syntax in Rust when the rest of the talk is really about problem solving in a large distributed project and dealing with conflicts which is probably more apt to the current situation then syntax.
I don't see why the deferred error handler helps in any way; If you handle all your errors the same way, it makes more sense to just pass them up to the calling context and handle them there?
I agree. Rust is not much more readable than Go.
Thanks you, i will improve it
!remindMe
**Defaulted to one day.** I will be messaging you on [**2019-07-08 23:12:04 UTC**](http://www.wolframalpha.com/input/?i=2019-07-08%2023:12:04%20UTC%20To%20Local%20Time) to remind you of [**this link**](https://np.reddit.com/r/golang/comments/ca5r6f/learning_golang_from_zero_to_hero/et7xyb2/) [**CLICK THIS LINK**](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=%5Bhttps%3A%2F%2Fwww.reddit.com%2Fr%2Fgolang%2Fcomments%2Fca5r6f%2Flearning_golang_from_zero_to_hero%2Fet7xyb2%2F%5D%0A%0ARemindMe%21%202019-07-08%2023%3A12%3A04) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete%20Comment&amp;message=Delete%21%20ca5r6f) ***** |[^(Info)](https://np.reddit.com/r/RemindMeBot/comments/c5l9ie/remindmebot_info_v20/)|[^(Custom)](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=%5BLink%20or%20message%20inside%20square%20brackets%5D%0A%0ARemindMe%21%20Time%20period%20here)|[^(Your Reminders)](https://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List%20Of%20Reminders&amp;message=MyReminders%21)|[^(Feedback)](https://np.reddit.com/message/compose/?to=Watchful1&amp;subject=Feedback)| |-|-|-|-|
It's a contrived example which also shows, that if you had to rewrite the examples WITHOUT try, you'd end up with more structured and readable code
Any developer blog that unironically uses emojis is not worth reading
If you want per-callsite error wrapping, this will work: x, err := oneThing() try(errors.Wrap(err, "one thing failed")) err = anotherThing(x) try(errors.Wrapf(err, "another thing failed: %v", x))
Especially since the author has spammed the same link so many times
spammed the links? These are different posts.
Done :-) [https://ldez.github.io/prm/#github-enterprise](https://ldez.github.io/prm/#github-enterprise)
Cool! I am also from nepal :)
Dang! You fast!
Make sure to mention microservices and containers .
&gt; The destination would at least need to be one byte bigger than the source to indicate whether it is compressed or not. In some cases, that can be delegated to the higher level. Consider a type-length-value and instead of one type `foo`, register two types `foo` and `foo-compressed`.
[removed]
That seems harsh, /u/SJWcucksoyboy
os.Open can't know *why* I'm opening that particular file. My function opens multiple files.
Good example! I've worked in Java, C#, C as I'm sure many of you have. My personal preference is error handling inline just like we have now. Personally I see no value in a try() function without catch. Try() does not allow you to handle the error, so it is a step backward. What happens if you want to handle a request regardless of success or failure If there are so many developers wanting exception handling, then I have an idea for you. Create a preprocessor (think typescript to javascript) that has exception handling the way you want and then generate the raw Go code.
Imagine nobody has ever heard of "gotables".
https://github.com/google/nftables
netlink is just syscalls. https://github.com/google/nftables https://github.com/mdlayher/netlink https://github.com/vishvananda/netlink etc
[removed]
Use a struct for maps. If you end up needing a persistent data store that needs keys to be byte sequences, there's https://github.com/tv42/compound to combine multiple values into one key safely.
True, we are just getting started. We also had a meetup couple of months back and surprisingly, there was quite a bit of number attending.
Yeah ‚úîÔ∏è what ‚ùìis wrong üôÖ
Oh, my bad. The titles were confusingly similar enough and I didn't look into it deeply enough
!remindMe
Toxic.
Gotta say I find this incredibly condescending and the current error handling idiom is what has kept me from seriously investing in golang.
Kind of a dick thing to say. If you can learn those Java or C++ what makes you think you can understand error handling?
Lmao why do they have such a ridiculous interview process if that's what they think of their new hires?
It's one of the things I like about the language. There's no nonsense, and practical benefits as a result. For example, a colleague can't write their own exception hierarchy nobody else knows how to use or bothers with in their corner of the codebase, and the code is easy to review as errors have to be explicitly not handled.
As ‚Äúharsh‚Äù as the statement is, there may be a grain of truth to it. There‚Äôs a reason those guys are writing languages, and we‚Äôre using them. Valuing their experience is part of the agreement when it comes to Go. If we want feature x in form a, there‚Äôs probably a dozen or so languages which have that. If you want a language that is 100% what you want all the time, you‚Äôre probably going to have to create it yourself. I‚Äôm feeling pretty good in this moment with having nothing changed about error handling. I like creating my own logging and error handling wrappers, tbh.
I wouldn‚Äôt be against ‚Äútry‚Äù if they were also forced to add context to the error. Similar to xerrors wrap functionality. But this ‚Äúkick it up to the next guy brainlessly‚Äù, that‚Äôs too far. Lots of poor developers out there who will ignore the error and let someone else deal with it.
after years of working in Scala codebases, I found that it's not _just_ the fresh out of school coders that should be using golang
Do you mean GoLand IDE by Jetbrains? Or can IntelliJ edit Go code with completions as well?
It reminds of me of writing low-level UNIX driver code in C. I'm all for dealing with errors locally but cluttering up the significant code with error handling boiler plate..I just don't see how that's helpful for a maintenance programmer. I'm looking forward to the argument over try() getting resolved soon so I can either finally start using Go or put it away forever.
The point was that they are fresh out of school. I'd say that most programmers become really good after at least 10 years of working with software and preferably have learned at least a handful of languages well enough to understand how and why they differ.
This sounds seriously uncharacteristic. Can you supply any sources for this? Otherwise I'm going to assume that he didn't actually say this and you're just spreading FUD
No sources were given. Save your rage for when (and _if_) Rob confirms he actually said this. Otherwise you're just being manipulated.
check this out, [https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/From-Parallel-to-Concurrent](https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/From-Parallel-to-Concurrent) Just did some minor googling to find source, don't have the time now to confirm he says the thing this post claims he does. But check for yourself
Maybe Rob Pike doesn't interview and that's his honest opinion of the people Google hires? I don't have any Idea if Rob does interviews.
I haven't found it to be too burdensome in practice. Code on the left side is the happy path, code on the right side is the unhappy path. I come from a background in backend js/ts if that informs your opinion at all.
I agree, in programming I found that you need to make your code like a tool to produce more features and code. Having a tool that is dead simple and hard to misuse is great design in my opinion.
It's from this talk at 20:40 https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/From-Parallel-to-Concurrent
Why the downvote? I went out and found the resource for you.
&gt; How can they be so far up their own ass as to have a grueling and honestly often time wasting interview process and then spew shit like this? I would guess that Rob Pike is not the person who designs their interview processes.
&gt; No sources were given. I recall hearing him say something very close to this.. It's one of the earlier presentations on go from 2010-2013 or something like that.
Rob doesn‚Äôt need to confirm he said it because it‚Äôs from a talk that was [recorded](https://channel9.msdn.com/Events/Lang-NEXT/Lang-NEXT-2014/From-Parallel-to-Concurrent). He says it at about 20:35. That being said it seemed like an off-hand remark and I don‚Äôt think he meant it in a condescending way.
because reddit
It is terribly condescending. I don‚Äôt know if he said it in a dumb way, or if he really looks down on people that way. That said I‚Äôve got 20 years of experience. One of the most error prone and difficult to test/debug/reason about programming constructs I‚Äôve ran into are exceptions. Not to mention the frameworks that uses exceptions as flow control. :( Doesn‚Äôt matter if it‚Äôs C++, Java, ObjC, Ruby, Swift, JavaScript, or Elixir. It‚Äôs always a mess. Error returns, while not fancy nor terse, are still the most clean solution I‚Äôve seen. If go could come up with a better solution they would have solved a hard problem. They already improved on C with multiple returns and no errno craziness. That said the proposed solution with try isn‚Äôt good at all. It‚Äôs far too clever and complex.
No talk of pay at all. Kind of sad. No talk of equity either. Does YC no longer give out shares?
[https://blog.golang.org/go2draft](https://blog.golang.org/go2draft)
You seem to think he says that the people are stupid, thats not what he is saying. He is saying that they are inexperienced at practically working with programming languages to make production software.
The ability read the code of one function from the top to bottom is very valuable. That is to read it without having to look in a million places to see what the heck is going on. Good old ‚Äúlow coupling, high cohesion‚Äù is a good way to look at it.
well, xerrors isn't ready for the stdlib (which I agree with) so wrapping won't be a part of try.. I think I personally would like to see parametric polymorphism ready before most other changes because error handling could very well make use of it if it existed.
that seems like a good way to miss valuable info
pay is competitive with market and DOE and yes we have equity
It could have been said in a far better way. To me it‚Äôs not about experience (boy have I seen terrible software design from 30+ years of experience). It‚Äôs about the mental effort someone has to put in to learn the language, the API, and then maintain that. Go is, compared to most big languages today, fairly easy to learn. I feel it‚Äôs made to write software rather than spend time on figuring out clever ways to use the language. I hope they only replace/upgrade the current error handling if they find a *better* way, with an as simple or simpler mental model. Also every single time I‚Äôve seen generics it‚Äôs been a massive mental effort to fully understand, and reading/writing/debugging is a PITA. Especially since everyone working on the code determines the complexity the code can have. Everytime someone writes more clever code the ones under the threshold there is a problem. This is why I rather work with an average team that works well together than a really smart team where everything is a struggle because nobody can agree on the particular cleverness that should be used.
These concepts are not at odds. Consider that even expert C++ programmers introduce CVE's. Go's design was intended to steer programmers, both experienced and inexperienced, toward more robust implementations.
What is competitive? Is it 130k in Silicon Valley only? Because that‚Äôs what it sounds like
Thanks for putting it in the original post
Thanks everyone for the source. The context here helps clear up the intent, and it definitely doesn't seem as bad as it sounds at first.
&gt; You seem to think he says that the people are stupid I don't think that at all.
``` func (f Foobar) Something(a, b, c int) (foo, bar int) { ```
Is that supposed to be more or less clear?
In case it might interest you, my old take on improving some Snappy shortcomings: https://godoc.org/modernc.org/zappy
Syntactically correct and canonical.
I automatically assume anything posted on Medium will be similar quality to emoji spammed shit, luckily there are a few exceptions but for the most part, Jesus Christ
The idea that a try/catch block requires "looking in a million places" is absurd on its face.
Cool! Thanks! The "repeat" offsets help with the same issue (long matches are inefficient).
I'm still fairly green when it comes to Go, but why is everyone so up in arms about this? I get that Go is already pretty verbose without greedy error handling like try/catch, but I don't really have any issues writing a few extra lines to manage specific errors. Can someone explain a scenario where the current setup is failing? Or is it just a verbosity gripe? Honest question btw. I've going been coding in Go for a month or so now and haven't really felt annoyed at this specific thing yet.
What's the right way to do it? Because right now, with error returns, every piece of error handling code is essentially: check if error and return the error to the caller. More often than not, it's the same result as just ignoring the error and letting someone else deal with it. If there's a better way to handle errors that does more than just add some context to the error then I'd love to hear it.
Yes, good point :)
The interviews are mainly on logic, algorithms and data structures which are the fundamental of computer science, not programming language. I guess it is supposed that if your are smart you can learn the language. But with c++, which is a complex programming language, one must be *very* smart to master the language. Hence the goal to design a simple language. The success of python has something to do with its simplicity.
I completely agree. Right now, that‚Äôs all there is in the standard library. In that sense, try is a perfect fix, as it makes that ugly and pointless boilerplate much easier to look at. But that‚Äôs my problem with errors. Right now, go 1.X has junk in terms of options to deal with errors. Xerrors gives me hope, but if we suddenly get try and everyone starts depending on it (you can‚Äôt really remove it once it‚Äôs there without breaking code), we will lose the opportunity to use a better error handler, like xerrors.
If small WebAssembly binaries is the goal then going from C is the way to go, basically a 1:1 mapping with the Clang toolchain.
If you take this quote seriously, it means that the Go team should ignore the community of Go programmers when making its decisions, because said community is mostly composed of young and unsophisticated programmers who don't know what's good for them. I don't know if that's true, but observing the wanton douchebaggery that passess for discussion here, I would find that conclusion extremely tempting.
&gt; The ability read the code of one function from the top to bottom is very valuable You must hate `for` loops.
PMd you :)
How do you know if someone uses Haskell? They'll tell you üòí
...hate is. it literally poisons your body
That's actually what I like about it. It seems a bit loaded to paint "kick it up to the next guy" as a brainless method. It's pretty nice to be able to do this when organizing code and there are a plenty of reasons you would delegate the error handling to the parent caller. Want to wrap it? That's easy enough. I personally have seen nothing evil with `try` and the only arguments are about context while missing the point you can defer a function call to add context to an error on triggering exits by try failures. Sure we can keep spinning things back and forth but ultimately I think this is gonna come down to subjectivity. Personally I'm still for it.
&gt; it‚Äôs made to write software rather than spend time on figuring out clever ways to use the language. I think you've really put your finger on it there. There *is* quite a lot of magic in the tooling, which can be hard to get your head around, but the language itself is super simple to pick up and just use.
I don't know if i agree with the generics point. Yes sometimes generics are annoying to read but sometimes it solves a design problem. But the go mentality is from what i can see is have minimal language api so there is 1 clear way to do everything. If you give clever people generics they might go astray like you elude to. I agree with you on your final point. I use typescript at my work. I like to keep my head down work hard and discuss design with my team. Thats the most important bit. Not what feature a language has in it.
they should ignore the community because the community always want's the latest language gimmick and if go adopted them all, it would just be another c++ but with a garbage collector that nobody wants.
&gt; It is terribly condescending. I don‚Äôt know if he said it in a dumb way, or if he really looks down on people that way. Depends on context and what he means by "brilliant language", I suppose. It's definitely not a nice thing to say about new graduates, but possibly also a dig at overly-complex languages.
Take a look at SwiftUI and the endless amount of generic magic it has. I was mucking about with it just a few minutes ago and as a veteran iOS developer that has been out of the game about a year or so, maybe a bit more, it‚Äôs almost impenetrable if you want to actually understand it. What am I suppose to send in as a selection to a TabbedView? What is a binding with a hashed protocol there for? What‚Äôs wrong with an int so I can know what tab page I‚Äôm looking at? It‚Äôs just mumbo jumbo until you‚Äôve spent enough time to learn far more then I feel anyone should need to. Think of generics as Emacs, and go as a small modern to the point editor. As cool as emacs is, I don‚Äôt actually want to plow that much time and energy into it just to use it:)
xerrors looks really neat and I can see it coming in handy an solving a lot of the problems that currently plague Go error handling. What's the consensus on adding it to the standard library over the \`check\`, \`handle\` design?
&gt; Lots of poor developers out there who will ignore the error and let someone else deal with it. They do that anyway by brainlessly returning the error to the caller‚Ä¶
It might be old man yelling (i.e. me), but at this point I want to write that does stuff rather than build giant designs all the time:) Basically the polar opposite of Java:) There‚Äôs some magic around the tooling, but it certainly isn‚Äôt worse than let‚Äôs say maven, ant, make, that thing Android uses, and the 10 billion JS build systems that exists :) In fact it wasn‚Äôt too bad at all. Which is funny because my biggest gripe with Go is the tooling. I keep seeing people write build scripts in bash (unreadable!) or make to deal with multiple binaries and docker and deploy and what not. Having a very go solution for these things would be welcome. A simple straight forward way to manage those things that are part of the base install of go.
I don't see how a try function would make the language hard to understand. Shouldn't you also be worried that people might find ‚Äúreturn" or "append " confusing as well?
It‚Äôs relevant to the conversation. How do you know if someone uses Go? They act like a dumbass in other aspects of life too.
&gt; It might be old man yelling (i.e. me) Make it two old men yelling :) &gt; Having a very go solution for these things would be welcome. There [mage](https://magefile.org). I've seen a few projects that use Go scripts for building (i.e. `go run build_script.go`).
Yeah, because it takes a brilliant programmer to write try { some code } except (e) { error handling }
Hmm. I should try that one out (just quickly skimmed the readme). It fails one criteria of mine, be part of go, but it‚Äôs still definitely interesting.
We are building multiple media services using go, and the try feature is appreciated because we do have a lot of if err !=nil checks. Our coding style relies on early exits and no nested if statements. We often have methods with 5-10 early exits which are just if err checks. As a result we never have more than 1 or 2 indents (2 happens when you have an if in a loop). I could see a dirty code base with a lot of indentions not taking advantage of the try statement, but those code bases are bug prone and less readable already. We also avoid stateful objects (including builder models) due to their being bug prone. This likely also contributes to the number of if err statements.
This \`try\` proposal mostly treats errors as exceptions, but errors in Go are not **exceptions**, they are **values**. Most people programming in Go don't usually pass errors up the stack as they are, they add some context, pass another error, or just handle this error in-place.
Try it for a while, I thought it would be bad as well but it‚Äôs not.
IDEA is the big daddy intellij product. All the other IDEs are essentially standalone intellij plugins. IDEA ultimate can gain the functionality of all their other IDEs through official plugins
I know that feel, dude.
It doesn't though. It doesn't unwind the stack at all, and is merely a shorthand for if-return
I use Goland It's not a test editor, _per se_, but it is great nonetheless
You're right. But I wanted to say, that *simple* `if-return` is not the way errors were generally meant to be handled. And this `if-return` with error handling N levels up the stack is just like poor man's exceptions - just without a callstack information. People coming from another programming languages want to see something like exceptions they are familiar with. That's why libraries like [https://github.com/pkg/errors](https://github.com/pkg/errors) became so popular.
Adding "try()" for example obviously won't remove "if err != nil" so obviously "if err != nil" will stay, no matter what. After all there are more complex cases that it is absolutely required for and there has been zero talk of removing it. Obviously also due to there being a lot of code out there that uses "if err != nil". So what is the problem? Adding an easy to understand shorthand for an exceedingly common case will ruin any codebase that uses it? People are afraid that it will be overused? Leaving it our won't force anyone to deal with their errors any better. Instead it will just make typos in the longer "if err != nil { ... return ... }" possible. Or are people afraid of some slippery slope here that will then land us with gazillion quirky short-hands and lead us on the road to Perl? A part of me thinks that this sounds pretty similar to people opposing the inclusion of "goto" because they've grown in a culture that says that "goto" is inherently bad. I know people who actually say that this is how they feel. But for me it's not a matter of feelings but of facts and the fact is that the careful use of "goto" in specific situations makes the code cleaner. But in the end all this talk of betrayal and such just makes this sound like an argument out of emotion and attachment to tradition. It's not often that I get to hear arguments that are conservative in nature from programmers. The process of Go evolving through specs, peer review and such makes it similar to science and we \*know\* that science isn't a shouting match, a popularity contest nor about what people \*feel\* like should be the case. Talking about this on Reddit however does not really contribute to the discussion unless we actually come up with good arguments for and against the ideas in the specifications and manage to improve the actual documents that guide the process. Saying that people aren't capable of understanding things sounds condescending but that's just how it is. Plenty of stuff I get wrong too and don't understand but if you want quality software projects need to run as some sort of meritocracies that prioritize the opinions of those who've put in the effort to acquire the know-how required. Which makes it kind of like science.
Yep, just like Backus said back in 1978 in his "Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs" Turing Award talk. Quote: "Programming languages appear to be in trouble. Each successive language incorporates, with a little cleaning up, all the features of its predecessors plus a few more. (snip) Each new language claims new and fashionable features, such as strong typing or structured control statements, but the plain fact is that few languages make programming sufficiently cheaper or more reliable to justify the cost of producing and learning to use them."
I think the Go team is doing the right thing by proceeding the standard route of writing up specifications and proposals, and asking the community to do the same too, followed up by proper technical discussion and review so that it won't all devolve into popularity contests or shouting matches. I didn't watch the entire clip but someone from the Go team (probably Pike) once said that originally no feature went into the language unless everyone on the team could be convinced that it's a good idea and plays well with the rest of the language. If that's how we got here and at least I'm somewhat happy with the result then we should stick to that kind of level of difficulty for getting things into the language so that it won't becoming a big ball of mud like most of the other ones. But yes, I agree that there's too many people voicing opinions by saying things like "Error and exception handling are solved problems. It's stupid not to make Go just like Java in that regard." Not all opinions weigh as much.
Rob Pike is referring to juniors on "mount stupid": [http://www.smbc-comics.com/comics/20111228.gif](http://www.smbc-comics.com/comics/20111228.gif) He's not wrong. We've all been there, even Rob was a junior at one point.
I'm having issues with Fyne when trying to use multiple windows as the thread complains about blocking if it needs to jump between the main window and a child window if it ticks at the same time as a blocking process, OpenGL error, I don't really have control of the canvas rendering thread to pause it (or at least I haven't really checked as I don't want to hack a library to get it to work). Executing the same thing using ImGUI doesn't have an issue. Quite sad, as liking how quickly I managed to build everything with fyne, hoping if they implement #207 it would solve my issue as well.
He has a point. Go attracts more than just "programmers" (generic man with beard making 'program'). For example, WebAssembly is going to attract a lot of people from a web-dev background, that is a JavaScript background, and as a web-dev myself I can safely say that after working with JS and frameworks for a number of years, Go is a different world. Designing the language for "googlers" and people who have worked with C# or maybe some Python seems like a sensible way to increase adoption and also maintain usability in the language. Put the door on the front of the house and provide a floor-plan and when there is a fire then hopefully no-one will die.
err != nil ....It's more understandable)
I was actually able to squeeze out a few more free percent of compression, so long matches will at most be represented as two tags. I made a quick comparison for the block encoding. Both are pure Go implementations - no cgo or asm. With a few changes (the URL you use for testdata is no longer available): ``` --- PASS: TestCmp (0.05s) all_test.go:313: testdata\html: s2 21304, zappy 22943, 1.077, orig 102400 all_test.go:313: testdata\urls.10K: s2 287623, zappy 355163, 1.235, orig 702087 all_test.go:313: testdata\fireworks.jpeg: s2 123045, zappy 123031, 1.000, orig 123093 all_test.go:313: testdata\fireworks.jpeg: s2 123045, zappy 123031, 1.000, orig 123093 all_test.go:313: testdata\paper-100k.pdf: s2 83073, zappy 83075, 1.000, orig 102400 all_test.go:313: testdata\html_x_4: s2 21313, zappy 22956, 1.077, orig 409600 all_test.go:313: testdata\alice29.txt: s2 87342, zappy 104016, 1.191, orig 152089 all_test.go:313: testdata\asyoulik.txt: s2 80251, zappy 91345, 1.138, orig 125179 all_test.go:313: testdata\lcet10.txt: s2 223983, zappy 275488, 1.230, orig 426754 all_test.go:313: testdata\plrabn12.txt: s2 321845, zappy 376885, 1.171, orig 481861 all_test.go:313: testdata\geo.protodata: s2 18743, zappy 20759, 1.108, orig 118588 all_test.go:313: testdata\kppkn.gtb: s2 68977, zappy 87200, 1.264, orig 184320 all_test.go:317: TOTAL: s2 1460544, zappy 1685892, 1.154, orig 3051464 ``` And speed: ``` e:\gopath\src\github.com\klauspost\compress\s2&gt;benchcmp zappy.txt s2.txt benchmark old ns/op new ns/op delta Benchmark_UFlat0-8 277798 148500 -46.54% Benchmark_UFlat1-8 2721992 1177497 -56.74% Benchmark_UFlat2-8 8944 8124 -9.17% Benchmark_UFlat3-8 9069 7970 -12.12% Benchmark_UFlat4-8 51799 30940 -40.27% Benchmark_UFlat5-8 416667 443666 +6.48% Benchmark_UFlat6-8 999502 407400 -59.24% Benchmark_UFlat7-8 814998 322399 -60.44% Benchmark_UFlat8-8 2614017 1210001 -53.71% Benchmark_UFlat9-8 3790024 1512999 -60.08% Benchmark_UFlat10-8 220200 158800 -27.88% Benchmark_UFlat11-8 958497 465667 -51.42% Benchmark_ZFlat0-8 359800 180699 -49.78% Benchmark_ZFlat1-8 3521998 2206003 -37.37% Benchmark_ZFlat2-8 452000 20269 -95.52% Benchmark_ZFlat3-8 462331 19950 -95.68% Benchmark_ZFlat4-8 391201 131199 -66.46% Benchmark_ZFlat5-8 702502 282000 -59.86% Benchmark_ZFlat6-8 1313994 707499 -46.16% Benchmark_ZFlat7-8 1132496 573000 -49.40% Benchmark_ZFlat8-8 3338010 2031999 -39.13% Benchmark_ZFlat9-8 4426651 2482000 -43.93% Benchmark_ZFlat10-8 336801 169899 -49.56% Benchmark_ZFlat11-8 1111499 629002 -43.41% benchmark old MB/s new MB/s speedup Benchmark_UFlat0-8 368.61 689.56 1.87x Benchmark_UFlat1-8 257.93 596.25 2.31x Benchmark_UFlat2-8 13761.10 15149.92 1.10x Benchmark_UFlat3-8 13571.47 15444.48 1.14x Benchmark_UFlat4-8 1976.84 3309.63 1.67x Benchmark_UFlat5-8 983.04 923.22 0.94x Benchmark_UFlat6-8 152.16 373.32 2.45x Benchmark_UFlat7-8 153.59 388.27 2.53x Benchmark_UFlat8-8 163.26 352.69 2.16x Benchmark_UFlat9-8 127.14 318.48 2.50x Benchmark_UFlat10-8 538.55 746.78 1.39x Benchmark_UFlat11-8 192.30 395.82 2.06x Benchmark_ZFlat0-8 284.60 566.69 1.99x Benchmark_ZFlat1-8 199.34 318.26 1.60x Benchmark_ZFlat2-8 272.33 6072.69 22.30x Benchmark_ZFlat3-8 266.24 6170.08 23.17x Benchmark_ZFlat4-8 261.76 780.49 2.98x Benchmark_ZFlat5-8 583.06 1452.48 2.49x Benchmark_ZFlat6-8 115.75 214.97 1.86x Benchmark_ZFlat7-8 110.53 218.46 1.98x Benchmark_ZFlat8-8 127.85 210.02 1.64x Benchmark_ZFlat9-8 108.85 194.14 1.78x Benchmark_ZFlat10-8 352.10 697.99 1.98x Benchmark_ZFlat11-8 165.83 293.04 1.77x ``` Only file 5 `html_x_4` is slightly slower on decompression.
Congrats, very nice speedups! What about the compressed sizes? Particularly (very) sparse files are interesting for me.
TinyGo was posted on this sub recently. Before choosing to use TinyGo for any serious project, keep in mind it‚Äôs [limitations](https://tinygo.org/lang-support/). Namely for WebAssembly, garbage collection does not work and many language features like maps and goroutines have caveats. It mentions there may be problems with more than two goroutines.
I‚Äôm in the same boat as you I don‚Äôt understand the problem with err!=nil
Seems like a good way to miss medium spam
Sparse files see the biggest improvement. The "adresser.json" is a sparsely populated (or highly repetitive) data set and is close to 50% of the size of the Snappy file and compression speed is less than half.
From my experience, the distance between error origin and handling grows with the size of the code base. While some errors can be handled easily at the source, often times the user input is necessary to deal with them. So these errors need to go though all abstraction levels to reach the user. Other times you can reliably handle the error at a certain level only, not at the source, so it still needs to propagate upward. Therefore, while it would be nice to deal with all errors as they happen, it's often infeasible.
#1. I used to do #2, but now I don't think I need to know all the basics to get started. Diving right into the project also gives you some motivation.
In the real world and for single-project-usage, it is likely that the first option will be considered. However, if your company is going to use Docker/Go in the future or you're a developer interested in these technologies, you won't get around the second option. :) &amp;#x200B; Books in general are great for in-depth knowledge, but also talks and blog posts from contributors may be interesting.
If a cli.Flag has a "Value" field set, then then it will be that value when *not* set in the cli.
Did that. Was horrible complicated and hard to get for others. Template Engine all the way now
Regarding to PHP it is better to mention that at the beginning PHP was meant to be a template engine. Since that the language changed a lot and in its current form it is beneficial to use template engine as it can add a lot of functionality on top of PHP (eg. escape variables, template inheritance). * Does anyone stuff HTML into functions rather than use templates in Go? From my side I use the template engine (or SPA). * Would it not always also be easier to just ship one binary containing all the HTML build into it? You can include templates in you binary (eg [gobuffalo/packr](https://github.com/gobuffalo/packr)). * Would it not improve performance? Not necessarily. If you read templates during initialisation of the application you will have everything in memory by the time they are requested. You could also add some lazy loading that only load the templates when they are first needed. Depending on how you handle the return of the function you could add some penalty (eg returning \`string\` instead of \`\[\]byte\` will cause a copy of the string.) * And last, but not least, would it not improve safety in that everything gets compiled before usage? I use tests to improve safety and rely on CD to be sure everything is deployed. Also I have to mention that as Single Page Applications (SPA) become more and more popular for a reason. It is not a betray of your favourite language to use a frontend framework (Angular, React, Vue pick your choice). This adds a bit more flexibility as the API can be anything (I saw a lot of interesting combination of languages). Also you can add JS files to your binary similarly as template files.
It actually prints what I would expect this time :) But please allow me to disagree on the terminology one more time; I would call these as \`language's internals\` rather than real-world problems. May be I should have gone with \`real-word examples\`. It really doesn't matter what do you (or I) call it, your examples are much appreciated. Thanks again.
Sooooo... I think this is extreme, but it guarantees that you will *know* it afterwards... I wanted to get in JavaScript, because it‚Äôs popular AF but I can‚Äôt develop with it right now... So, instead of using it in a project, or contributing to an open source project, I used what I know (Go) and built a JavaScript VM. This means that you have to learn the specification, which gives you insight into how the language works, why different pattern work, and also in-depth knowledge of e. g. the Memory Layout, the way concurrency works etc. Etc.
He said ‚Äúthey‚Äôre not capable of understanding a brilliant language,‚Äù which is not technically calling them stupid but you can understand how people might come away with that impression.
Oh really!!! Did not know about the meet up
I get the impression that Rob usually tries to be precise in his statements and people have a tendency to read in stuff he doesn't say just because he avoids being verbose. I've seen it happen multiple times before.