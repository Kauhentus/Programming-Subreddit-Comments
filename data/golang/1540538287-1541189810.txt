That for loop range over the strings channel is going to loop forever unless something closes the channel. And you are using a global channel across handlers. The inner goroutine doesn't make sense if you need to block on scanning anyways. That is, unless you also need to do other work concurrently within the same handler while it is scanning. 
You're hitting the maximum allowed connections for MySQL (Error 1040), which is set by the server, and defaults to something like 150. You can increase this on the server, but as others have mentioned (sort of) `database/sql` implements a simple sort of connection pooling, so you don't need to (and should not) explicitly open a new connection for every query/client connection. In addition to this fix, you may also wish to configure your DB handle so that it does not exceed the maximum number of connections you have configured on your server (see the documentation for `sql.DB`).
Oh, interesting. I stand corrected. I thought it used qemu as required.
**Always** is very extreme. There are packages that you want to expose and that can be used outside of your library, and there are those internals. In this case the internals are not the things that you will `go get`. Also, if you are moving towards `go mod` it will troublesome just to continue developing this library as you will have to create hierarchy which is weird.
I use both Go and C# daily - and prefer Go. There is too much 'magic' going on in C# that often makes it hard to skim through to paint a mental picture of what is going on. Though that said, C# is a wonderful language, in particular if integrating with MS Azure features.
How much non-English do you need in your life? Go is a candidate for lingua franca of computing. "90% good, 100% of time".
Not tons of languages doing it for decades now! Because almost every language was created with a single core in mind. Only recently multi core computers became standard, golang is one of the first languages taking this into account and even making it core concept. Yes you have so workarounds to get some sort of concurrency in older langs, but they are workarounds and oftentimes even just emulate what it would be like if they could real concurrency. 
I think that if you include an implementation of the thing your article suggests a language should have, and it looks like this ... func Assert(predicate bool, message string) { if !predicate { panic(Error(message)) } } ... maybe the language has all the functionality it actually needs in this area already?
I played around with Go on my Raspberry Pi, which was fun. Building the Go compiler with GCC took about an hour on it.
I did that for awhile but it wasn't worth it. Ended up using Alpine instead.
I loved PHP until I realized how useful it is to have things like type safety and concurrency.
Im stuck with magento 1 and i came to this company as main engineer and they want to make custom e commerce solution, guess what will power backend of that, modafokin go üòÅ
Personally? As somebody who moved from Scotland to Finland I need quite a lot of non-English in my life ;) &amp;#x200B; Go is good. I start most projects using it, but even so there are lots of codebases that will never be converted, and it \_isn't\_ perfect for everything. Go-advocy is good. /r/golang is obviously always going to prefer go, but a good coder knows multiple languages and picks the most appropriate one for the task in hand. Blindly choosing go 100% of the time, whether due to lack of experience, or blind advocacy is going to be a mistake.
Same here! I love it. &amp;#x200B; Its so weird that some of the things that go has are things that I wondered why they are the way they are when I was learning C++ (obviously because that's how the designers made it - not that they did a bad job but its interesting to think of what was going through their minds at the time or the specific problems at hand) &amp;#x200B; Like for instance there are no uninitialised variables in go, I made this mistake in C++ when I was starting out and it was causing weird loops that did different things at different times completely randomly. &amp;#x200B; Also, there are no while loops and else if statements which I think is a genius omission. Just the other day I was spending time thinking if I should use a while loop or a for loop and now that I am learning this I realised what a waste of time it is to think about which choice to make.
Yeah honestly I'm gonna start writing my other code like I do go (not everything obviously) . Like no else ifs or while which make the code so much more readable. 
Do you think we will get the same amount of packages in go as in python? &amp;#x200B; That seems like an attractive feature in python which would be nice to have in go
I just tested, it works great, thanks a lot!
I'm the same with python, I didn't realise it was so popular since it's just never grabbed me.
what you are saying sounds very reasonable, can you name some examples? Like for web development perhaps? Or building to ARM?
The Go compiler is capable of cross compiling on all platforms. You can develop on your high powered Linux desktop and simply change the compiler target to ARM and then copy the binary to your pi. Much faster this way.
Performance-wise you mean?
I covered it briefly in a talk I gave to the Hannover Gophers a few months back: slide/page 30 of this: [https://github.com/HannoverGophers/talks/blob/master/meetup-2018-07-05/01\_debugging-go/debugging.pdf](https://github.com/HannoverGophers/talks/blob/master/meetup-2018-07-05/01_debugging-go/debugging.pdf)
&gt; Only recently multi core computers became standard, golang is one of the first languages taking this into account and even making it core concept. You've never heard of Erlang then have you? It's from 1986 and has all the Go concurrency concepts built in _and more_. &gt; Yes you have some workarounds to get some sort of concurrency in older langs, but they are workarounds and oftentimes even just emulate what it would be like if they could do real concurrency. That's just plain wrong. Go provides some nice and easy to use abstractions (like goroutines, which are basically lightweight userspace threads) but they still come at a cost and are of not much use you need real threads and precise control. Consider for example the nginx server, which powers what, like half of the web? It very much is concurrent software and you'd never be able to match its performance with Go's concurrency. Go is fine, fairly good for its intended purpose, but this sort of blind propaganda is what really pisses me off about the community... 
pip shit env
Go is amazing, but i think that if i only had 1 language to chose, it would be Python or JS. 
What is it that means you'd probably use Perl for a web-app? Is it just that it's something your experienced in? You find it fun? Or does it have something that actually makes it the best tool for the job in your case?
Nice one. That's all I'd really thought up myself.
I would not expect any language to be perfect, there are always drawbacks. Functional languages have to deal with immutability and space complexity, dynamic languages have to deal with unpredictability and the associated management overhead etc. My point is that Go is more of a modern C++ with great concurrency support. In that respect it does not allow for higher level abstractions that would allow you to do simplify complex algorithms. I am happy people are using it but it's good to see things in perspective.
&gt; Go is fine, fairly good for its intended purpose, but this sort of blind propaganda It's weird, Nowadays you can just google programming paradigms, watch some videos on youtube by experts and experiment a bit with some languages and you can discover so many interesting approaches. And yet people seem to be unaware of the options even if they have years of work experience.
I just wanna race to this grpc thing with go. I just think your own personal cluster that communicates with simple code is just fun. I like go cause I don't have go look stuff up Everytime there is 10 different ways of doing things.
Cool concept but where are the benchmarks?
This. Go has so few features that it makes understanding other peoples code a lot easier than, say, C++.
ooohh - nice - thanks for the link and awesome deck, I'll give that a nose!
I'm glad that you're in a position where you can make that kind of decision! My company is migrating away from Rails and starting to use single page apps driven by Go on the backend and I couldn't be happier about that because there's a clear separation of concerns. I've been using Go for the majority of my time there and I love it as well.
No static typing? Please don't do that to me.
Could reproduce the problem with this simpler command `go get -u -v go.opencensus.io/exporter/jaeger`.
I have a lot of experience with Perl, and the best way I can describe it is "PHP, but better". The syntax is a bit arcane, but you can get a **lot** done in a few lines of code. Also, Perl has a super mature templating library called Template Toolkit. As well as the fact that it's been around forever and there are a lot of (mostly) stable libraries out there for it. I would still reach for Perl for a lot of text parsing or even system maintenance tasks,
You still use the same GPUs on Linux, Windows and Macos. Vulkan even supports a bunch of mobile arm GPUs which metal and DX don't 
I will add them later.
Yes, and it's *super* refreshing how there is support for encapsulation but you're not forced into object orientation that you may not want. And if you want to use existing C libraries, *Go even has you covered then*\* too with cgo. ^\* ^in ^most ^cases
Same here. It never felt "natural" for me. Go, on the other hand, feels right at home for me.
[removed]
I feel like Go is a good "modern C" as it does well in the systems programming realm, and Rust is the "modern C++" and seems to have found its place developing standalone applications.
Let's also consider the fact that, because Go is a small, fairly opinionated language, as well as adhering to a style guide and even including a linter, that it forces even mediocre programmers to write better code. A coworker recently asked me to review some of her Go code and acted like she was ashamed of it and I would hate it, but it was perfectly well done, despite the fact that she came from a Rails background. 
Or dig through endless pages and different versions of Python docs, and still not have the thing work the way you want. Also, if you get it to compile and the linter throws no warnings, it's very likely that you're going to get what you expect, as opposed to "dynamically" typed languages where unforeseen bugs can creep in.
Go is not a systems language
So what you're saying is, we're going to have two incompatible versions of Go floating around soon? That seems like a terrible idea :-(
That really depends on what you're trying to do. What I'm reading here indicates that you're simply continuing to read lines from a file and load them into an array. All the stuff you're doing with setting the Scanner's buffer is likely unnecessary unless you have a good reason. The reason you're running out of memory is that you're starting with a zero length slice and appending every single line - possibly reallocating the whole array between calls (especially as it grows). This is a very memory-heavy operation. Is is strictly necessary to load every line into memory? Can you do your processing inside `for scanner.Scan()`?
You are trying to read the entire 4GB file into memory at once in your example, and your operating system is killing your process because you don't have sufficient memory to do that. It is not that you need to use another function, rather, you need to change your algorithm to do the work in a streaming fashion. Rather than collecting all the lines in a slice before processing them, try reading the lines in, and as you find a line or a word, depending on which mode you are in, pass it via a channel to a goroutine that processes it and records your statistics, then *discards it*. That last bit is important - the only bit you want to retain is your statistical data. So, in your example, I would change the function to either receive a channel, and output the lines to that channel, instead of returning a slice, or to create a channel and a goroutine to fill the channel, and then return the channel. func readLines(path string, out&lt;-chan string) error { file, err := os.Open(path) if err != nil { return err } defer file.Close() scanner := bufio.NewScanner(file) const maxCapacity = 512 * 1024 buf := make([]byte, maxCapacity) scanner.Buffer(buf, maxCapacity) for scanner.Scan() { out &lt;- scanner.Text() } return scanner.Err() } 
I'm using `db.db.Where(user.User{Email: u.Email}).FirstOrCreate(&amp;user), db.Unscoped().Delete(&amp;user) and db.Where(user.User{Email: vars["email"]}).First(&amp;usr)`
It really wasn't a great presentation - it was just a tour of debugging tech I'd been looking at.
you can use else ifs in go just fine ([play.google.org](https://play.golang.org/p/rmaFG3m2wWM))
I haven't read much yet but I just wanted to point out that the i7 7700 ont has 4 cores, not 8 as stated in the article. I think you are referring to threads.
I'm really anxious about go 2 especially the error checking. I didn't get why they did the error checking in go 1 the way they did at first but the more I wrote go the more it clicked. It forces you to write fully checked code and it's clear what happens in case of an error. 
If I run a *$lscpu* it it shows **8 CPU(s)**. Yet, you're right there are only 4 CPU cores but because of hyperthreading it returns 8.
The post does contain a link to an implementation, but it is buried. The post is more around whether or not they should be used. 
Yeah I see that but I think that's a bit different than how, for example, Java handles else if. I think switch statements look cleaner in any case and I prefer to use them.
I've added a minor comment in the post, just for the sake of precision ;)
No they are both running in a different scenario (if I recall correctly, the Java post is only running with 100k elements). The main goal was not really to compare both Java &amp; Go but don't worry, Go is way faster! :D
Can confirm, I write Go for embedded ARM applications, and we cross compile with something like `GOARCH=arm go install`. Works like a champ :)
I strongly believe they are lost, but I dont have any proof. 
File permissions like execution are OS and FileSystem specific ways of controlling access and privileges of files. Once you "upload" you have read the file from your FS as a stream of data, so all permissions are lost. That said, file transfer protocols often will obey and copy permissions from one location to another, but all protocols are not created equal. In short, permissions are a location specific control. 
... though in C, you at least you have the option to use the pre-processor to implement some kind of generic containers. (Yes, yes, I know it's coming in the next one...)
is that your job? what kind of applications does that have? I'd love to work on embedded systems with go
What issues did you encounter?
If a file is tarred before uploading, will the permissions be persisted once untarred on the server? Provided that both are running the same os?
Yep! We do security software and hardware for remote sites. The main requirements are: - low power (we sometimes have systems running on battery) - small (we put these things into small, weather-proof boxes) - powerful (process and store way more data than a microprocessor could, but not enough that we need complex server hardware) - interact with other embedded devices (GPIO, serial) Basically, we're between "internet of things" and below "the cloud" (though we certainly have cloud options for aggregating data from multiple sites).
Typescript is the same thing as JS to me. 
I'd be curious to see a comparison to a version implemented with a worker pool.
As a beginner, I have 2 gripes with the language but it‚Äôs likely due to a lack of understanding on my part. 1. Compiler throws an error for dead code. Is there a way to disable this or at least change it to a warning? It‚Äôs annoying to have to keep commenting/uncommenting imports and variable declarations when you are just trying to prototype something. 2. Package architecture. I wish go had some sort of namespacing ability beyond the package declaration. It seems awkward to have to worry about naming collisions between multiple files and I don‚Äôt like not being able to quickly determine where a function, constant, etc is declared.
&gt; I don't know enough about networking/multithreading to understand what you mean by TCP sockets are intrinsically serial. Any good reference for learning more about this? What I mean by that is simply that a TCP socket is ordered. If you send A, B, and C, the remote side will receive A, then B, then C, or the socket will be terminated. So a lot of time it's not worth trying to get too crazy with the concurrency, because you have to receive things in order anyhow, most likely at a speed much, much slower than what the computer can handle. There's no reason to add ordering indeterminacy with goroutines when you've already got an ordering. (By contrast, if you use UDP to send A, B, and C, you can receive pretty much any combination of A, B, and C, in any order and in any quantity, including 0 of each. For UDP, you could receive nothing, or AAAAAA, or CBA, or CBBCBAAC, or maybe, just maybe, you'll receive ABC, but there's no guarantee.)
Yes
I'm sure it was for the sake of explanation, but I'd assume best practice would be to not store the secret key within the source code. Ideally, especially for a SPA, the client wouldn't even have knowledge of the key. In that case, I'd assume the flow could look something like this: Client (Basic Auth) -&gt; Server Server checks authentication / authorization Server Generates JWT -&gt; Client Client stores JWT and sends with all subsequent requests The server would validate the JWT is valid and hasn't been tampered with on each request from the client. Since the client doesn't know the key, the JWT can still be decoded (for UI changes based on perms or whatever) but can't be altered.
I was going to add this as well. We don't know OP's use case and using channels/goroutines here adds a lot of complexity for trivial gains, especially since processing text line by line is almost always I/O bound. I tried to keep my solution as generic as possible because that's likely exactly what he/she needs - pass each line to a processing function.
I believe it is a matter of implementation rather then pervasive property of the concept.
You can, but idiomatic practises suggest to use them sparingly.
Those are interesting gripes. I can relate to the first one, but I actually love Go for the second one. There's a tool called `goimports` that helps solve the first gripe. It replaces `gofmt` by doing all the same auto-formatting, but it also adds needed imports and removes unneeded ones automatically. For the second gripe, I'm not sure. I haven't really run into this as a problem. Perhaps the best way to solve this is with a `godoc`-like tool or an editor/IDE feature. I really enjoy being able to split a package into multiple files while keeping things in the same namespace (the package).
When you process line by line, only keep one line in RAM at a time. When done, `scanner.Scan()` and `scanner.Text()` will get you the next line. Repeat. If the file is structured, and not just a giant pile of lines that are all the same format, that complicates things a bit, but I'm sure you can figure it out.
That is one way to fix it. I could also delete the go.opencensus.io directory before updating and it will pull it down the first time fine. The bigger issue though is that it seems like every vendored dependency will break `go get -u`. In the source for my projects, I am not directly pulling in the go.opencensus.io lib, but one of the packages I use is using it. I'm currently trying to automate the build setup for my projects, and keeping the packages updated is proving to be difficult. Ultimately I see this as a bug in `go get`.
Shameless plug, but I wrote a blog post that hopefully helps to point new Go developers in the right direction for common tasks (testing, documentation, adding dependencies, etc). Might be helpful for you: [https://weberc2.bitbucket.io/posts/go-getting-started.html](https://weberc2.bitbucket.io/posts/go-getting-started.html)
I have a production microservice running at 2.5Mb using a scratch base image and stripping symbols (no upx).
upx makes a compressed binary that is self-decompressing. Assuming your assets aren't already compressed, you will probably still see considerable space savings, but it's not worth the effort (just for fun).
Yes.
[removed]
[removed]
Thank you for the response! I will need to take a look at `goimports`. My second issue is more of a preference thing I suppose. I am coming from a java/clojure and python background so it just struck me as different.
If you telnet to port 80 and type "HELLO!" that's not http to begin with -&gt; it won't be handled by any http.Handler, it'll get an error from the net/http level. If you're trying to debug a broken http client library, wireshark or mitmproxy are probably what you want.
If it's an HTTP client, one option is to use an `*http.Server` directly, and when you call `server.Server`, instead of passing it a net.Listener straight out of the `net` package, implement a wrapper around that listener that hands out wrapped `net.Conns` that use io.TeeReader to both read the original socket connection, and writes the raw connection to some log somewhere. If it's HTTPS, that will be less useful, because you'll get the encrypted TLS connection. For both protocols, the other thing you can do is fork net/http. Copy the `*.go` files out of the source Go net/http directories into your own new package. Do not copy the subdirectories in the source net/http. You can then use this new package in product as a drop-in replacement with just a tweak to the relevant import statements [1], and you can do whatever you like to it so it can log incoming data in a way you like. This is ultimately more flexible, and depending on how comfortable your are with reading Go code, may even be easier at first than the previous. However, it does incur a long-term maintenance cost. If you do go this route, I recommend doing the best you can to minimize the changes, because the smaller the changes, the easier they will be to port forward as you upgrade Go. (It is possible this could be &lt;10 lines of change, give or take error handling.) [1]: If you call this new package `http`, it'll be a total drop-in replacement. You can also give it a new name, in which case you have to modify the package declarations. You can still make it a drop-in replacement by renaming the new package in the import statement (e.g. `import http "my/path/hacked_http`), although that will tend to make it so you accidentally import the wrong package with goimports whenever you mistakenly type something starting with `http.` in a new file. Or you can just go all-out and replace the new name entirely.
Wasn't worth it? There's less to do than any other method...
Agreed, a good way to explain. chroot + benefits :-)
[removed]
Frankly, there is not right job for PHP, Perl and Node, if you define job by task and not by environment / infrastructure / find tools that over have made for you.
var tristate \*bool
The biggest pro is the data you're requesting from the DB can be decreased tremendously by using JWTs. Although I prefer [paseto](https://github.com/paragonie/paseto) to JWTs.
drop down a level, to the net package ([https://golang.org/pkg/net/](https://golang.org/pkg/net/)) log everything, then pass it to http as normal
Not sure about the using TLS pkg, but you could write your own TLS implementation to just read the certificates. I did something very similar on a hack day in node, not sure how useful it would be for your go project, but here it is anyway. https://github.com/fewstera/node-tls-implementation/blob/master/index.js
lost during upload. What you get is a stream of bytes, with some attached metadata about mimetype and filename. file permissions are an OS property, and your http upload is OS-agnostic, so it doesn't make much sense to preserve them anyway. the combination of browser version and mimetype can help with this, and I believe you can work out if it's a POSIX executable using the ELF package ([https://golang.org/pkg/debug/elf/](https://golang.org/pkg/debug/elf/)), though I've never tried this myself.
almost all the cool stuff that works on files in the standard lib uses streams (e.g. hashing algorithms for fingerprinting files). There's a ton of useful code in there for how to work with arbitrarily large files using streams. You are totally OK to copy it :)
I see, thanks for the answer! 
Right, but as Winsaucerer noted if you ever need the ability to prematurely deactivate a JWT because it was compromised then you'll have to do it via a database lookup. So now you're not eliminating DB calls anymore.
Solid answer!
I'm not sure I follow? It's a preprocessor. You even called it that yourself. The output of the preprocessing step can integrate however you want it to.
Could be very interesting to follow such a process from someone that knows Python well - actually could be an absolute awesome continous blog topic doing Python functionaltiy in Go, would probably get a high amount of hits :) I love python but am not good at it, and i really like Go as it feels abit like C, and i also really like the route to binary and production-ready code which is shorter than in Python. But also feel that the language is alot more simpler/limited than Python and some of the things that is natural in Python with datastructures and types i can image must be absolute hell to try to reproduce in Go. So would be so awesome if there was a Python vs Go community/blog/book whatever going.
Oops. reddit formatting showed it as single line of code. Still no fatal error for me: https://gist.github.com/godwhoa/d99ecd073be1479f95acc32e1a9340cc
&gt; The idea that you can compile to a single binary and do so much is amazing. You do realize you can make static binaries on more than one platform, yeah? 
Would be nice to add to gometalinter :)
Not all database calls are the same. Database call to check validity is much shorter and smaller than a database call each time to get user information gathered from the user for the website such as name, address, etc.
Almost there. Now i get all the data but i don't know if it came from a failed request. Anyway, this is enough for me. Thanks.
Gotcha, I'll definitely give this a go. Total Go newbie, but making cross platform stuff seems trivial so I thought I'd give it a try, hopefully this works!
I'll have to look into this for bandwidth-limited situations.
Absolutely, what i mean by active is actually on your app. So you can run code in the background to rotate the tokens when expired. For example, lets say a user logged into your web app, did the exchange for a token. Then closes the browser. This token will still expire and since the user isn't "active" on your page (i.e. has your web app open) you cannot do a token refresh in the background. So their token expires, they come back to your page and now have to re-login. This is just one of the tradeoffs in having a shorter token TTL. 
Fails to detect the defer statement in the following code: package aaa func g() {} func f(b bool) { for { if b { defer g() } } } 
Make sure you are testing with more than the http server in go. Just because go can handle your request doesn't mean an other server can. I learned this the hard way when an update to Apache that increased case sensitivity broke my client because I did something stupid. It took forever to debug and now I need to run a go server that is case insensitive in that part of the protocol just to support all these old clients. 
What I'm asking is if there is a way to not have preprocessor output in the git repository, but still have the code generated when someone runs `go get`.
This is why we have refresh tokens and access tokens, to have the best of both worlds. &amp;#x200B; You create an access token that is valid for 15-30 mintes which does not need to hit the datbase, when your access token expires, you create a new one using your refresh token which will hit the database so you can do invalidation there. &amp;#x200B; This reduces the load on your database massively while still giving you the ability to revoke access if the token is compromised.
The goal is not to eliminate DB calls but to reduce the load. &amp;#x200B; If you use an access token and a refresh token, then you can reduce the database load from every single request to every 15-30 minutes or so while still being able to quickly invalidate compromised tokens
The creators of `go get` have stated on numerous occasions that generated code should be included in the git repository. So, probably not. Your expectations are contrary to how the tool was designed to be used, as explicitly stated by its authors. If you have good reason to not use the tool in the way it was designed to be used, perhaps it isn't the right tool for the job?
I won‚Äôt disagree with you there because I don‚Äôt know enough about python and I‚Äôve only used c# or go most recently. Programming isn‚Äôt my job or career so my opinion on the matter is pretty much invalid. I will say that I passionately hate Perl :)
It's not a particularly great tool even if you are writing C. But that doesn't mean it isn't an option. It is most definitely an option that you can choose, if you so desire.
actually found one resource not very extensive but several examples from python to go : http://govspy.peterbe.com/
Dictionary's in C# are really long while and you need to add the values to the dict later, while in Python you just do it all in 1 one, But enough of me talking about dicts. Yeah I also hate Perl its just a really bad lang same thing with PHP its designed poorly and dying and the only reason PHP lives is because alot of people know it and alot of things run on it
There is no other way to disable individual lines, so maybe that's an (undocumented) feature.
agree to the first one, that is probably my biggest issue as its abit the way i code too - would have been really really nice with a directive that could put your code in dev mode ( and warn but not stop ) or production where its fine that it throws the error. I understand why they do it and all but it is abit annoying especially during learning.
At best, this article is poorly titled.
There's no need for two tokens. Your access token can function as a refresh token if you create a refresh handler that will validate and return a new token. 
If someone is able to infiltrate your system to access your encrypted token then they're going to be able to access your system and access your validation credentials. 
There are often public and private keys the public key can be provided to the end user to validate the token. The private key would be accessible to the application for the creation and validation of the token. 
Cool wrote up. It's definitely a technology getting more use these days so examples and best practice write-ups are for sure needed. That said given the bad start JWTs had... I'm still wary. I remember there was a part of the older spec that allowed the client to tell which algorithm to use for signature validation. I think at one point people also used this as a way to get by rs256 signing since the public key could be used to sign a bogus payload and then they'd just flip the algorithm to hs256. I saw they revised it but they mention it SHOULD be rejected. This level of allowance to me seems insane and I'd love to know what systems are handling tokens using two different algorithms in the same process. Just seems like it would breed code that's messy and insecure. I get what JWT is supposed to do and I appreciate it but I will still probably be super careful because of its rocky history in specification and implementations.
I agree with this. 
Not necessarily. There are cloud based firewalls where exfiltration is a concern. 
But then you only have 30 minutes until this access token expires, who wants to log into their application every time they didn't use it for more than 30 minutes? &amp;#x200B; Your refresh token can be valid for literally a year, since you revoke that token anyway.
Thanks for sharing! Someone already submitted a patch that should handle this case. I will land it later today.
&gt; How much non-English do you need in your life? Woah there, keep your American imperialism in check please. 
It's kind of a big project. But that only happens after deleting something.
Depends on how you define systems. It's definitely not a language for OS/hardware programming, but "systems programming" often refers to problems of lower-level networking and foundational stuff like database implementation. c.f. https://en.wikipedia.org/wiki/System_programming Java, while slower and more abstracted than C/C++/Rust*, is frequently considered a systems language and is used for many databases and networking libraries. Go has a lot of potential in the same space. * I'm not entirely sure Rust is fit for hardware programming either, since you're going to need a LOT of unsafe blocks to do anything useful, and might as well use C at that point. An OS that was a mix of Rust and C might be interesting. 
I believe 2.0 is aiming to be compatible with current Go programs. I'm not *sure* that it's 100%, but the goal is to be as close as possible.
`go mod` needs something like [npm link](https://docs.npmjs.com/cli/link).
Sounds a lot less transparent than the replace directive. Isn't npm link easy to overlook and thus cause awful confusion?
This is cool. I can see it being handy, but at the cost of type safety. I would use it, but very sparingly and only for prototyping. 
Not true at all when you want things like SSL certs.
You can do that, and sometimes for gnarly unstructured JSON it's the only option, but you'll have to type-switch all those values every single time. From the example struct in your post with Name and Age and such, you'd have to be doing stuff like: // happy birthday if age, ok := f["Age"].(int); ok { // have to make it an int before you can +1 it f["Age"] = age + 1 } if name, ok := f["Name"].(string); ok { // there's better ways but this shows the // example. type casting all the time fmt.Println("Happy birthday, " + name) } if parents, ok := f["Parents"].([]interface{}); ok { for _, v := range parents { if name, ok := v.(string); ok { fmt.Println("Parent is " + name) } } } That or `switch(f["Key"].(type))` blocks depending on what you're doing. It's better to stay within Go's type system as much as you can manage.
I assure you we use SSL certs :-) HTTP/2 from client to container for the win...
The argument for this being necessary doesn't hold water for me. Every loop has the potential to trigger a memory leak! Defer should be used immediately after the resource that needs to be freed or released, and sometimes that'll be in a loop. What if you're connecting to a list of backends? What if you're in a retry loop? It's perfectly legitimate in those cases, and I'm not really sure I see people making the mistake that it would catch (and I do a lot of code review).
I've add benchmark result in the repository. All these two repos are abandoned change lists in the Gerrit which I modified to run outside the standard library. English is not my mother tongue so go laugh if you want to.
Thank you for your contribution. I see some assembly code and benchmarks. Looks promising! Here are direct links to the two libs: * https://github.com/libgoost/encoding-base64/tree/master * https://github.com/libgoost/hash-adler32
Empty interfaces are best thought of as a necessary evil. They are useful for deserializing JSON data that has an unknown structure. They can also be used in data structures: https://golang.org/pkg/container/ring/
What I do in staticcheck instead is flag defers in infinite loops (`for` with no condition and no manual `break`). This catches the occasional bug without having false positives for all the things you mention. There's still the chance for a false positive if you use defer in a loop to recover from a panic, but I think that's rare enough (and bizarre enough), and avoiding the (relatively) more common "defer that never executes" bug would justify rewriting the panic handling, IMO.
The path is not perfect too. package aaa func f() { for { func(){ defer g() // this line shouldn't be reported } } } 
You still can have a compromised token for 15-30 minutes though. 15-30 minutes of time is *a lot of time*. If you want to be able to prematurely kill a token you'll need to make a DB call with every API request to check if that token has been deactivated. This DB call will be very similar in complexity as a session lookup for a cookie based session. So yes, technically you're correct, but in practice the requirements often don't allow for that type of access. For more information take a look at Randall Degges' talk [JSON Web Tokens Suck](https://www.youtube.com/watch?v=JdGOb7AxUo0). I think his talk is a bit more negative than it needs to be, but I think he's right.
Have you tried checking the returned error? If it's non-nil then the result will be 0.
When things don't work, don't ignore the error.
You're not checking the error value, so how do you know the call was successful? Go will always return the zero value from a function call, but you need to check your errors instead of throwing them away. In any case, as you've described it, the code works fine. I presume though that you're reading your lon/lat from somewhere else, rather than having them hard-coded, so my guess would be that you're getting an em-dash (`‚Äì`) instead of a dash (`-`), or you have a trailing/leading space, or some other malformed input.
Why is defer in a loop bad? I though it runs the specified function when the given scope exits (Excuse my ignorance)
Thanks I was just in the slack and no one answered which is why I posted here. I posted in review channel.
Maybe that‚Äôs true, maybe it‚Äôs not. Either way, there are a lot of things to consider, not just whether the language supports what you‚Äôre attempting to do. I would argue my PHP, Perl, and Node services can produce and consume JSON APIs way easier than my Go apps can, due to the inherent nature of not being strictly typed. What about hiring and longevity for enterprise software? Does a particular area/location have a concentration of a lot of developers well versed in a particular platform? Does a particular platform have a large selection of libraries available in the space needed? (For instance, scientific computing in R and Python.) Anyhow, your comment doesn‚Äôt really add anything to this discussion regarding use cases for Docker in combination with Go projects. I was pointing out that that Docker can be useful for Go projects to keep a homogenous environment. I would be very surprised if there weren‚Äôt tons of companies running multiple stacks of software for various reasons, the most common of which is just ‚Äúlegacy‚Äù - it was written one way and the cost of switching it is prohibitively expensive compared to the value of switching, which may include the time cost of rewriting and the personnel costs of hiring new people.
[https://play.golang.org/p/E5ng9lXf1l4](https://play.golang.org/p/E5ng9lXf1l4) This works without error as you've described. Check that your loc2 is actually "-44.44444" and that it doesn't contain any hidden or invalid characters.
I wrote code to open a file and defer its close at the start of a for loop. The daemon eventually reached the open file limit for my system. 
It has not problems in logic.
LPT: use golangci-lint, it's like 100 times faster (ok, maybe less than that, but very noticeable still)
That works. But note that you have to keep count of the tasks, to get the packet back. Another way is to range over the done channel itself. And then just close the channel once you are done. That way, you are not bothered over how many tasks are out there. This also has the additional advantage of ensuring that you cannot read once done is closed. Thereby making your code much easier to understand and reduce chances of bugs.
Here's @TheRedLion 's playground modified to throw an error. It looks the same Funny that an armenian hyphen looks very much like a hyphen-minus See [http://jkorpela.fi/dashes.html](http://jkorpela.fi/dashes.html) for a list of minus sign look alikes
Deferred functions don't run until the enclosing *function* exits. If you use defer in a loop, you're stacking up a ton of actions that won't be performed until the loop finishes.
Showerthought: can you stack smash with deferred functions?
So that's‚Ä¶ a bug inside Go itself?
Here, I made some changes with some comments: https://play.golang.org/p/giiPMy91txF
Knowing when to close the channel adds additional complexity for this example which I don't think is needed
No. It works as intended. It is hardly to be a bug. Not all deferred calls in loops are bad. It is just that care should be taken when using deferred calls in loops.
So, I think the Reddit community is fairly good about that. The trick is, don‚Äôt ask questions that are easily answered by the docs. Unlike most programming languages I‚Äôve used, the Go docs are extremely good and cover (with examples!) many different tasks. So if your question is answered there, you‚Äôre going to get linked there; nobody wishes to donate time retreading the same explanation. Now, if you‚Äôre passingly familiar with the docs and know your question isn‚Äôt answered there, ask away! I haven‚Äôt seen any real negative reactions to questions here myself. 
You can try the Go slack or even here, but to be honest I think it‚Äôs part of the culture of the Go community to link to docs. It‚Äôs not done to be mean or rude, it‚Äôs because one of the things Go programmers focus on is writing good docs. It‚Äôs built into the tooling. 
You need a lot less unsafe than you might think.
Step 1. Read the documentation Step 2. Don't ask stupid questions There you go. Solved your problem for you.
Are you serious ?
Yes. Start with chapter 1.
Runes are a UTF-8 'character' (the term they use is code point). Because UTF-8 is variable length it can be up to 4 bytes, but if you use regular ascii it is represented by only 1 byte. If you look at the code points for those character you will see they are 3 bytes big, but the code point for 'A' is only one. Both will still be an int32 as a rune, but their strings will be variable. There is nothing special about runeValue, it's just the variable assigned in the for loop. You are looking at a range for loop which had the format for I, V := range Collection {} Where I is the index, V is the value, and Collection is either a slice, map, or string
Its not really the point but then again abit the point about how the attitude many times seems when it comes to Go - i find it odd. And btw read several books already including the Go programming language, thankyou. 
Thanks for sharing! Also, I've found in [https://exercism.io](https://exercism.io) a cool way to practice :) 
I have to agree with /u/koresho If you just have a look around recent posts on this subreddit, you'll see that most comments are really trying to be helpful, without being mean. https://www.reddit.com/r/golang/comments/9rrcfc/helpseeking_feedback/ https://www.reddit.com/r/golang/comments/9rts8b/i_need_help_understanding_runes/ https://www.reddit.com/r/golang/comments/9rkrb5/need_some_help_with_go_mod_and_local_development/ https://www.reddit.com/r/golang/comments/9rkn59/how_to_upload_a_file_and_check_its_permissions/ https://www.reddit.com/r/golang/comments/9rk1rw/processing_of_huge_text_files/ https://www.reddit.com/r/golang/comments/9rlouu/how_i_can_handle_malformed_http_requests_in_go/ If your problem is literally answered in the docs or with a 2 minute search on Google, that is exactly what people are going to tell you. I don't think that there are stupid questions, but I think it's fair to expect a certain kind of time investment from the person asking the question, before people invest time answering it. A good way of getting people to help you is by not simply asking a one-sentence question, but also explaining your thought process, showing code you already have or what you tried to solve the problem so far. TL;DR Asking a question should involve a reasonable investment of time, then people will be happy to help you
or in the case of a channel, where v is a variable too many
You dont come across like someone that gone through multiple languages, you learn by doing with doc as reference, but docs have a way of going "hello world" to everything, and when you need to solve real problems in a new language it often takes abit more than docs. Docs can the after that help you clarify things
I'm familiar with quite a few languages. Compared to most of them, the docs of Go are exceptional. So, read them, absorb them, and stop asking stupid questions.
Apparently you have a habit of asking questions that are answered by the docs. Then you went on to make this topic complaining about it.
So I may be way off base here. But in this thread at least, you‚Äôve mostly ignored several more positive comments and focused on the one negative one, devoting multiple replies and obvious thought to it. Meanwhile, even in the positive replies like this one, you brought up the one negative reply- it‚Äôs clearly on your mind. I suggest that you may be focusing more on negative comments than positive/helpful ones. I don‚Äôt know of course, and I want to stress that it‚Äôs perfectly natural to do so... but if you learn to just ignore the negativity you will feel much better! :) 
Are you...not understanding what I'm saying? I know all of this, I just said with a JWT it's a much shorter DB call. For some other cases you can make the JWT expire earlier so you don't need that DB call anyway.
No the problem is - and maybe because the people who reply them arent capeable enough is they think all can be answered by a link to the docs - if you take my "hello world" analogy and understand whats meant by that, then you would also understand that there can be alot bigger things to solve that doesnt refer to a single place in the doc - where it comes down to experience, and opening up for the experience seems hard for quite some people. Its not unusual to meet people like you in the world of programming or on SO, but met a few like that that think the goal is to send naughty students out on a wisdom journey but probably it comes down to those guys cant understand the actual issue as they are hello world'ing them through their daily life.
Well it was the first comment i got which exactly nailed it to the wall which is why it gets my attention - plus it annoys me that attitude. But true some positive comments and reading here seems to be a good place so will absolutely try it out, just my SO havent been so positive my own and digging up others posts.
NP. 
`for` understands UTF-8 strings, and reads between one and four bytes from the string into each `rune` it returns, depending on the length of the encoded Unicode codepoint.
Hi, don't worry about the pencil guy. He's probably just having a bad day. Rules for Reddit: 1. Ignore that guy. 2. Don't be that guy. Anyway, hopefully we can be more helpful to you. Do you have anything specific you need help with right now? In regards to the Go SO community, I used to be quite active in it, but have neglected it for a year or so. If you have any links to questions you've asked but aren't happy with the answers, please post the links. I'm happy to have a look and see if I can help. Welcome to the Go community. Hopefully we can improve your initial impression! 
Yes it‚Äôs very clear to me now thank you. 
Hey [muaythaidripper](https://www.reddit.com/user/muaythaidripper), Welcome to the community. I have to say I have come to enjoy the reddit community here immensely and found it nothing but cooperative and insightful. I am clearly no programmer and yet I have been welcomed here with open arms when asking questions. ([Q1](https://www.reddit.com/r/golang/comments/8cwkng/can_i_get_a_little_assistance_with_struct/), [Q2](https://www.reddit.com/r/golang/comments/93fqko/help_appending_to_a_map_should_be_simple_so_why/), [Q3](https://www.reddit.com/r/golang/comments/9k00zt/im_looking_for_comments_suggestions_and_positive/), [Q4](https://www.reddit.com/r/golang/comments/9p07s4/is_it_possible_to_read_an_out_of_scope_channel/)) I think it has to do a lot with the fact that I naturally tried to solve my problem myself and by consuming as much of the documentation I could before asking. I also try to gild a response or two when I have the funds to show my appreciation, although it's not necessary. The documentation is somewhat difficult when you are just starting out, mainly because it's all generated by a [go package](https://godoc.org/golang.org/x/tools/cmd/godoc). I found a key to understanding it was getting a handle on [receivers](https://tour.golang.org/methods/4). They are all over the place in the documentation but until you understand what they are it can be a little confusing. At least to me. It took a little while, but I'm coming along and even made some progress writing a tool I use on a daily basis. I love this language, especially compared to what I was playing around with before finding it, PHP (shudder). My point is, don't get discouraged by a snarky comment or two. What Mr.[StatelessPencil](https://www.reddit.com/user/StatelessPencil) is trying to do is give you the knowledge to help yourself and there is insight there. What he fails to understand when he speaks the way he does is that this may not come easy to everyone and we all need a little help from time to time. When you ask a question it is always better to do as much as you can to understand the problem yourself. In doing so, you prepare yourself for the answer and/or you may even discover the solution. Many times the response to your answer may be as simple as "Hey have you tried reading about \_\_\_\_\_\_" to get you in the right direction. I wish you the best of luck and look forward to seeing you active here!
I can mostly comment on docs because I don't ask a lot of questions in community groups. &amp;#x200B; I think I recall the docs being my favorite resource only after a little learning and using Go for a real project first. Initially I used [tour.golang.org](https://tour.golang.org) and then fought daily syntax problems by looking at [https://www.dotnetperls.com/go#go](https://www.dotnetperls.com/go#go) and [https://gobyexample.com/](https://gobyexample.com/). After I had a strong grasp of syntax, my preference shifted to the docs. They're usually fantastic when you understand the syntax since Go hides very little in abstractions. That's why there aren't a lot of examples, but before you understand all the syntax you will probably long for the example-rich Python docs. Python docs are that way because a single method call might seamlessly call thousands of lines of C behind the scenes. Both languages are pretty fantastic, but the Go docs feel much worse until you get some experience and they then feel much better since the language encourages docstrings so heavily. Also, the standard library has some pretty good examples for some topics as well. It's a stark contrast to a lot of MSDN for C# where you often get almost no documentation (or at least that was true until .Net Core and recent efforts on expanding docs).
It's dubious to think that in the modern age of surveillance, an email account can serve the same role as a strong password. It looks like you check spf, but you should also validate dkim if the domain provides it.
Thanks alot, and i have to say its also not geared towards this community here as my impression have been positive and seems its a nice crowd of people. I do find the documentation really good and ive also gone through several books now so piece by piece i feel im understanding the language and i can also sense i have abit of love for this language compared to so many others so its something i will give a solid effort to as my alternative to Python ( i am totally in love with what Python can do, the syntax and structure though just never seemed to be natural to me, Go is much more natural to me ). I do understand the way of asking is alot related to what answer you will get and i probably asked too broad questions or too early questions maybe, but i think that is normal when people reach out that we have to accept different stages of where people are on (again its not here just seen alot of examples on SO). But will absolutely give it a go here and post questions have also seen nice posts here where people help with code review etc. 
thanks will note down the golangbridge too ! and i agree that SO has this mechanism and always had, just felt it had a slight overload of it for Go. But it seems im in good hands here so at least found one forum where ping pong can occur ! 
and if it's in a box? and if it's with a fox?
Just checking, did you create this tool because such a check didn‚Äôt exist, or was it for learning purposes? I‚Äôm pretty sure the [staticcheck](https://github.com/dominikh/tools) tool already detects these, see SA5003 and SA9001 at https://staticcheck.io/docs/staticcheck#checks.
To block a token all you need is to block the `jti` value. You can almost certainly afford to keep a list of blocked JTIs in memory and not have to access the database. I mean, realistically, how often do you have to kill sessions?
This has some nice comments thanks and It was a bit unclear for me the whole shadowing of the task struct. I guess what you are saying is if the task struct gets modified by the goroutine then it is required else not? But then what about the errors slice, since you are appending to it would that count as a modification? Lastly the whole thing about being able to initialize the packet struct without errors slice was something I did not know I could do.
That‚Äôs basically all most services use really though, since a password can be reset with just the email. 
Shhhhhhh! Warm fuzzy feeling-better-about-yourself circlejerk in progress ;)
P(free friendly help) is inversely proportional to the amount of entitlement and passive criticism exhibited by the person asking for it.
This seems like a bad idea. The security depends entirely on other people‚Äôs SPF configurations. Even with the best SPF configuration, it still allows anyone who can send email via those servers to log in as anyone from the server‚Äôs domains.
that doesn't make sense, why aren't they run when the narrowest enclosing scope exits? I don't think doing that is "complex", and it solves this weird issue. Is it so people don't try to emulate RAII lol
&gt; An Expresssion Is Evaluated After The Expressions It Depends On &gt; This rule is easy to comprehend. That's no rule, that's the only possibility.
I just use alpine base image and inject Go binary into the docker container rather than using Go base image. Cuts down on size by like 500MB or something (don't remember exactly). This is all automated, in gitlab and Jenkins, using secondary Go docker container to do the build, but I push the smaller image to docker repo.
This is spam. Stop.
The natural rule. :)
Golang IRC is fairly nice with some helpful people. Lookup #go-nuts at freenode :)
Not sure about friendly/helpful, but I usually ask on the Go discord channel or here on Reddit. I usually get a handful of people who are trying to show that they're Very Smart without actually understanding my question, but it's nowhere near as bad as the Python community in my experience (I'm a professional Python dev, so I spend a lot of time in both communities). Anyway, I like helping people, so feel free to message me here or on Twitter (@weberc2).
Wow, guys thanks so much! I almost never ignore the (err) but this time I was like meh... it shouldn't matter... turns out it was the "space" before the " -44.44444", I have rewrote the way the gps format is sent, and viola it works as it should. Complete rookie mistake and I thank you for your kindness in your responses!
I dont have an attitude and i dont beg
Cool thanks alot ! my impression of the python community has been different but that was also on beginner level which my Go is ( even though i think i understand Go more now than i actually understood Python ) - but this subreddit is nice !
That account has posted nothing but links to this "newsletter", which means it is not following the Reddit rules regarding self-promotion, and therefore it IS spam, but furthermore, it would be better to submit the actual content individually. Reddit is already a link aggregator. Links to another link aggregator are not beneficial.
It's been a while since I worked with that SDK but I'm fairly sure the main issue is that you need to make all the structs and their properties public so that it can encode it. I'm fairly sure it either uses the `encoding/json` lib https://golang.org/pkg/encoding/json/ or a similar approach. Take a look in that link about Marshal and Unmarshal behavior to get a better explanation of what I mean.
I started getting into go while working on a Prometheus project at work (monitoring software built in go) I found that my Ubiquiti edge router lite runs compiled mips64 go code quite well :)
SHA256 is 32 bytes. https://golang.org/pkg/crypto/sha256/
Ohhh thanks. I was reading that wrong ... 
Joel wrote a nice piece for [understanding unicode](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/).
Thank you for your help. I will try with encoding json lib. üëç
Have you tried multi-stage build? I read a post that it reduces the image to about 6 MB and is easier to use than injecting binaries. I am still new to Go, but when I use docker with other languages i find multi-stage quite useful, leaving the build tools out of the final build.
ok, if you say so!
It was a little bit of both but I hadn't noticed that static check had it! That's great to know though.
It's simple. First passing a pointer also makes a copy - of the pointer itself. Second - passing a pointer will allocate the object on the heap(most of the times, refer to quote bellow) and later the garbage collector will have to clear that up - which puts a strain the GC process. Quote from Go's FAQ about heap allocation: *According to Go's FAQ: if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors* On the other hand copying a struct will free the memory immediately after the scope exits. It's all a trade-off, but as a general rule: You pass by reference only if you need to change the instance or If you are sure that the object is large enough that copying it would be slow.
Recently, [meow hash](https://github.com/mmcloughlin/meow) was being discussed. :) [Original article](https://mollyrocket.com/meowhash).
Makes sense. I forgot about garbage collection. I was thinking about the issue from a C++ viewpoint where garbage collection isn‚Äôt a thing and creating a pointer to something allocated on the stack is trivial to do. 
While this may not be the best idea ever. It's important to experiment. :) Thanks for sharing.
\&gt; no need for you to get offended or sensitive I wasn't offended, and I wasn't "being sensitive". I was just pointing out ways you could have responded differently. \&gt; its a fair question to ask Er, so are you saying you reject my argument that it would have been better if you asked your question in a different way?
Majority here have come with constructive and useful replies - on the topic - that i can use so no not really, its a common issue in this world and there are some places that are more open than others - and this place seems to be majority friendly. 
A better title for this article would be: **Go already has assertions** which is exactly what the article says. The content is reasonable and acknowledges that making your own 5 lines Assert() is fine. The noisy response on Reddit is prime example that a good title can make or break articles in social media.
Super cool !
I used a framework when I first started too, but if you have time I suggest you play with the standard library. I have examples of both a [standard](https://github.com/TheSp1der/testing/blob/master/httpserver.go) and [tls](https://github.com/TheSp1der/testing/blob/master/tlsserver.go) webserver on a little play ground area if you are interested in an example of either using the standard library. 
It didn't work directly, but it put me on the right track... The server end is using self-signed certificates, which obviously don't verify (right now, at least, if I can get the root CA public cert then I probably could). So I have to set `InsecureSkipVerify` on my tls.Config object, which then means that `verifiedChains` is always empty. However I have managed to change that to use `rawCerts`, then inside the function I use `x509.ParseCertificate` to parse `rawCerts[0]` and then use the `String()` method on the resulting [`pkix.Name`](https://pkix.Name) object to print out the issuer name. Thanks for the pointer, I also need to get the thumbprint from the certificate but now I at least have the certificate object being returned this should be reasonably easy. Thanks for pointing me in the right direction!
Doesn't Alpine have issues with root SSL certs missing? I've always had issues having my applications make any sort of https call with Alpine. 
How is this related to Go?
Yeah, it probably varies. I tend to ask more advanced questions on both subreddits since these are my primary languages, so we're probably prone to different experiences. There are a surprising number of intermediate Python developers who get testy when you point out their pat answers don't address your particular problem (e.g., "just rewrite it in C!" when that would require you to rewrite an unacceptably huge chunk of your business logic in C or spend all of your time marshalling between Python objects and their C representations).
Why would you do your senior project on a topic you know nothing about? Shouldn't you choose something that demonstrates your mastery of computer science in some arena?
...and on weekends and holidays and all throughout May and YOU'LL ALWAYS BE WRONG NO MATTER WHAT YOU SAY!!!! ‚ÄîBrian Regan
I don't like the idea of temporally modifying `go.mod` for development. You can easily lose legitimate changes to `go.mod` when removing your `replace` directive.
I love that dude
OK huge thank to you. Struct was in private when you write without caps .. --' ``` type MediaList struct { MediaID string MType string MediaViews uint32 PayableViews uint32 Viewers []string RightHolders []string StartDate uint32 EndDate uint32 } type Media struct { BcDate string LastTickUpdate uint32 TotalViews uint32 M MediaList } ```
32 Bytes ... that‚Äôs ok
Why not serve the http server on a seperate goroutine? Have that goroutine push any errors onto an err channel. Then have a middleware that after responding to n requests puts nil onto the channel. Lastly have the main goroutine block on trying to get an error out of the channel.
Yes, but you still cannot invalidate access token immediately. Refresh token can be revoked from data store and thus invalidated immediately, so that potential attacker will not be able to obtain a new access token. One mechanism that makes JWT token authentication more secure is use of rotary keys too.
I think you're close. Try using Shutdown() There's an example here that you could adapt to your needs perhaps: https://github.com/gin-gonic/gin/blob/master/examples/graceful-shutdown/graceful-shutdown/server.go
Are both env vars actually set?
Yes 
I like this approach too, but even that only ensures that the person has the physical key. Have to determine if you're okay with that being the only validation.
json tokens.
m1 is a reference (maps are always references). So you're ending up with `result = { m1, m1, m1, m1, m1, ... }` All those `m1`'s reference the same underlying map.
Declare `m1` inside the loop instead of outside.
Hadn‚Äôt watched the video so not knocking it, but every time I see any mention of JWT there‚Äôs always someone bashing it. Mostly saying to use [Paseto](https://paseto.io) or plain cookie sessions. I wish I could decide... 
If your Go code has any C dependencies (one of my projects parses XML and requires libxml2), then the C code needs to be present on the system. Using docker means we only need to worry about a Linux setup, regardless of what host OS I'm building on. Also, if you have an application architecture that has multiple services running, Docker Compose can be used for multi-container setups. We have an application that consists of a Node.js API, MongoDB database and Oracle service. Docker Compose allows us to run a single command to build and run all the components of the application locally on each dev's machine. It's a godsend for fullstack dev. We're swapping out the Node.js REST API for Go.
I think that's half of the story. I'd bet that most Go developers already knew another language beforehand. Most people start with C, Java, Python, Javascript or some other language that's more marketable. If you started with another systems language, you probably already have some exposure to pointers, threads, and other concepts that tend to cause frustration for a beginner. From my experiences, Go reminds me of C and Javascript. The language is small and the lack of exotic features make it very easy to follow a new code base, like in C. Yet, it has garbage collection and built-in support for data structures like maps and dynamically sized arrays, like Javascript. The way it handles imports (being able to use a github link) is also very modern and reminds me of the Node.js Package Manager tool.
At a glance, I don't see what's wrong, though admittedly I'm not as well versed in using Vault as I'd like to be. I'd recommend looking at the config. There is a `DefaultConfig` function that you can use which will automatically read the `VAULT_ADDR` and `VAULT_TOKEN` (not `TOKEN` as in your example). It may be filling in some fields that need to be set.
Alacritty should work on Windows as well, fwiw.
Right, but most people are much better at securing physical objects than digital secrets.
Hi just wondering why not using Redis for the shared memory? Or is it a too complex solution for this use case? Thanks for the advice! Actually the number crunching would come from either a Python or Julia API. We're learning Go right now for a week to try it out and see how it goes before truly deciding. To be truthful, if we go Node JS, it would take us probably just a week or two to get things up and running. Not counting extra quality of life features. So at least there's that as back-up.
We use Docker extensively at work for a variety of tasks. Sometimes it's easy because it's how you described, but other times it's less so (for example, when other dependencies need to be built into the image). 
It works okay. 
Redis might be a good solution for a shared mem cache, though I'm not sure what the performance penalty looks like when making numerous small mutations to the dataset. Serializing and deserializing each blob of data might have a steep cost when compounded. If you guys are most comfortable with Node, just start out with Node. It sounds like you'd mostly just be doing CRUD with the Node app.
Are you using KV v2? That has a different API, and the json has another layer: https://www.vaultproject.io/api/secret/kv/kv-v2.html#read-secret-version Try this: https://play.golang.org/p/ZH911dtVokY
Wow this solved it. Thank you for clarifying that!
Is there a way to increase it pat 1000?
The 10k requests are super fast requests basically just grabbed cached metadata from a movie metadata server. Each one returns in under half a second at most so I thought (naively?) if I fired 1000 concurrently I would get 1000 concurrent responses around 0.5 seconds later
Try sending stdout to a file instead of terminal. Something like this: `go run . &gt; output.txt` It should help with the terminal slowness at least.
Your are in the best position to figure it out. Use a profiler or get timestamps after each step and figure out which part is taking the longest. Without doing that, you could try removing the request and replacing it with some hard coded data, this should tell you how slow the web requests are.
In my experience, most computers will struggle with 1000 connections anyways... You probably won't see any benefit from increasing it.
I would suggest that you have a look at the implementation of [OpenEBS](https://www.openebs.io/). OpenEBS is a container native storage and implements a distributed file system. OpenEBS itself has two major components. * The control plane or [Maya](https://github.com/openebs/maya) * The actual storage engine or [Jiva](https://github.com/openebs/jiva). You should have a look at the Jiva project more closely. It uses [iSCSI](https://en.wikipedia.org/wiki/ISCSI) for block storage emulation. The OpenEBS has a very welcoming and active community on slack. 
Does paseto solve the invalidation problem? Can these tokes be revoked without hitting the db on every request? 
umm, no. Bandwidth doesn't work like that. The analogy of 9 women giving birth in 1 month comes to mind. You'd be better distributing the workload over multiple servers. If I was gong to do this, then I'd use a serverless architecture like AWS Lambda, so you're not limited by the server network plumbing. Spin up all your requests on that and pipe the results to an S3 bucket (or better, a database so you can analyse the result set using SQL, but that's probably just me). As others have said, there might be a bandwidth problem with stdout too. You could put the fmt.Println call into another goroutine but I suspect that would just defer the problem - eventually you'd have so many goroutines stacked up waiting to print to stdout that you'd run out of memory. You need an output method that can cope with the parallelisation. Something like Redis maybe? Do some benchmarking to see where the problem is. Split the http call and the output into two functions, and run the benchmarker on each to see which is slower...
I don't really understand what advantage this has over emailing a magic link to the user?
I have three packages in my app, each with their own test suite, and an additional test suite for integration tests. I'm considering moving to a Docker build (so this article is really useful, thanks), but I am a bit puzzled about how I get all the moving parts together. At the moment I have a Makefile that has tasks to run the tests either independently or together (and do things like reset the test database). How would I transfer that to a Docker setup?
The Paseto people (Paragon Initiative) are billiant, but they are not Google/Microsoft who created JWT. If you don't like JOSE (which jwt is a subset), then there's COSE, a binary oriented format that works differently from JOSE, and still made by the Google's and all of the world. 
What other systems? My point is that an email for authentication is just as secure as a website that lets you reset a password with just an email. 
A nil *bool is different from a bool which does not know if it is true or false.
The usual approach is to dump the db as part of development and replay that dump onto a blank db before test runs. That way you can spawn as many test DBs as you like.
Break command terminates loop.
I don‚Äôt know this library, but it looks like a.Entry() returns the next element until there are no more elements and then returns io.EOF. When EOF is reached, the loop terminates in the break statement as you mentioned. If an error is encountered before EOF, then the return statement terminates the loops and sets the err variable to the pertinent error. 
You can begin a transaction before each test, and rollback at the end, so that the db remains the same after every test. 
mysqldump?
To add to what the others have said, one thing that I think is making this code harder to understand are the bare return statements. If it were rewritten such that the break on the `EOF` were `return contents, nil`, and the non-`EOF` return was `return contents, err`, it would aid the readability of this function.
Some [background here](https://blog.steve.fi/monkeying_around_with_intepreters.html), as the link was easy to overlook.
Maybe the api is not responsive :) you are doing gets measure time how long it takes to do the get.
This is basically a mysql question. You can use the tools provided for mysql to export the tables or to make a dump of an entire database. You can also use something user friendly like phpmyadmin.
Run `hey` or `ab` to generate load on the upstream service and compare the results with those of your program.
BOFH is that you?
How?
i use docker to compile golang code. works awesome
I‚Äôm not sure I haven‚Äôt used or tried it yet. 
:D nice. 
They‚Äôre not the same though. It‚Äôs much safer to assume that a password reset email _arrived_ at the correct email address. Then, we assume that there is strong authentication to be able to access that account. It‚Äôs not safe to assume the email was _sent_ from the correct account. Spoofing outbound email is incredibly easy. This library takes the extra step to ensure that SPF passed, but even that‚Äôs not perfect. That‚Äôs why this is a very dangerous idea in practice.
s/break/return nil/ would be more readable in my books.
No; it just makes it difficult to use weak crypto/skip token verification. 
As someone who has to write software that works across multiple terminal emulators, please no.
[removed]
Nothing can solve this problem, you have to pick one. Either you hit the db (storage) on every request, or you don't. For most domains it is fine to do this check every 5, 15, or even 30 minutes instead of doing it on every single request.
A) Technically these are different and B) semantically it makes a difference if I do not have a bool to store a (possible known answer) or if I have a value which means "don't know". Well, maybe we should go for bools which can store any real value from 0 to 1 to be save. 
Why include tests, I mean, I trust upstream didn't merged with failing tests, Also, besides source codes for go,c or other language, what else to including on vendor Also, it's not Google decision, the language was created by Google engineers, not Google
Yes, you'll just want to build a Docker image with the DB files included. Start with a base image, then add your data to the data directory. It should be way faster than replaying a logical mysqldump. Once that's done, you can use something like https://github.com/ory/dockertest/ to bring that image up and down in your tests.
&gt;Tip: for keeping to standard http.HandlerFunc: if you need other resources like a DB connection, make your HandlerFunc a method on a struct where you keep those things. `func (a *MyApp) LoginHandler(w http.ResponseWriter, r *http.Request)` While I don't necessarily agree with the rest of the above comment, that part I quoted there sounds very clever and something I haven't seen yet! It never crossed my mind to pass a method instead of a pure function as a handler before... I'll definitely be trying this idea out and including it in my projects going forward, thank you!!
If you set it up as a DNS that would work https://www.consul.io/docs/agent/dns.html
This is great, I already started using base64. Now, something similar for image/jpeg based on libjpeg-turbo would be great :) Can projects like this https://github.com/minio/c2goasm help, just as a starting point maybe? 
I liked this toy, so I wrote [https://play.golang.org/p/QFXBVIUHAwh](https://play.golang.org/p/QFXBVIUHAwh) to convert the files back again. Now, if only they'd survive the conversion to jpg, we might have a new way to compress source.
Maybe you're in the wrong area? I have 1 year experience with it and get several calls a week. Every company I talk to says they want to move more over to Go, but can't find enough Go devs. I'm in Silicon Valley. Apple, Cisco, General Electric, Google, Docker, Uber, plus tons of start ups are all eager to hire anyone that knows Go...
Out of curiosity, why do you `sudo`?
But how do I call it via http.Get ?
Then just use enums: ``` const ( false = iota true iDontKnow noOneKnows unspecified specificallyUnknown ) ``` Or just use three, as has been done since decades with SQL. 
You might be interested in https://github.com/gotestyourself/gotestsum. It is a similar idea. It also supports writing a JUnit XML file for integration with CI systems, and custom test output. None of the formats use a table yet, but that might be a good addition. Instead of piping the output, it runs `go test` as a subprocess so that build failures (which go to stderr) can also be captured are reported. github isn't working for me right now, but I'll check out the code in more detail when it starts working again.
Was testing something out with the `net` pkg, when key up forgot to remove `sudo.` Good point, this is a bit misleading. Will update the repo example image, `sudo` is not required unless `go test` requires it, e.g., binding to a socket, port, etc. &amp;#x200B; $ go test -count=1 net -json | tparse +--------+---------+---------+-------+------+------+------+ | STATUS | ELAPSED | PACKAGE | COVER | PASS | FAIL | SKIP | +--------+---------+---------+-------+------+------+------+ | PASS | 26.88s | net | 0.0% | 247 | 0 | 15 | +--------+---------+---------+-------+------+------+------+ $ sudo go test -count=1 net -json | tparse +--------+---------+---------+-------+------+------+------+ | STATUS | ELAPSED | PACKAGE | COVER | PASS | FAIL | SKIP | +--------+---------+---------+-------+------+------+------+ | PASS | 26.79s | net | 0.0% | 251 | 0 | 11 | +--------+---------+---------+-------+------+------+------+ &amp;#x200B;
Honestly I like the fact that it just reads from stdin. It's simpler. Its simple enough to pipe both stdout and stderr.
Oh awesome, thanks for sharing. `gotestsum` looks interesting, was the inspiration to use it within a pipeline? I found myself tweaking the `go test` flag set on the fly quite a bit, `-count=1` or `-run=`, so wanted a simple tool to use alongside `go test` to quickly gather info, hence the pipe mechanism. Nothing really exciting about the underlying code.
Cool, thanks. The filler value 255 can occur in the file itself, so there might be some mismatch. A minimal variation would be to use a buffered writer to write out the bytes ([https://play.golang.org/p/V9rOeaHzuud](https://play.golang.org/p/V9rOeaHzuud)), so at least at that point, we do not need too much memory (still required when decoding the image, though).
fascinating project! &amp;#x200B; it's interesting how some files seem to have similar visual structure while others look like complete noise. i wonder if it has to do with the compiler... binpic and go look quite similar... and they come from the same compiler.
Use `var requestData io.Reader` and use `=` instead of `:=` when you assign in the case blocks. You can also use `bytes.NewReader` for the json bytes. 
No, this does not cover all the intermediate states of how much I do not know: Really need real bools. The real reals œâ^œâ. Won't do with less!
Similar structure in executables would be a result of a [shared format](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format) (ELF).
You're right, yes. I just wanted to see how reversible it was, as a first pass &amp;#x200B;
Unfortunately that does not work. Piping both is lossy. It combines both streams into a single stream. You no longer have enough information to understand if the output is test output or a build failure
You'll need recursive DNS servers on your network, then you'll need to configure your resolvers to use them, and the recursors will need to forward requests for the `consul` TLD to your Consul servers on port 8600. This is not a Go question though - you should probably ask this in a Consul-related forum.
That's a good point
I didn't use long-lived sessions. Clients were responsible for getting fresh ones. I never bothered with explicit revocation beyond a timeout. Lifetime per client was determined on how noticeable an auth round trip before a request would be. In our setup it didn't matter much, so the longest lifetime was half an hour. I think we could've gone even shorter, though.
I find it strange that we need extra tooling in order to make go mod not skip certain files from vendor.
Your title actually does not make sense. It's the definition of a static language that you can not change the type of a variable once defined. As others already mentioned use a common interface. 
[removed]
Me too.
Go's "typing" is very primitive.
Is this like GraphQL? I'm confused. 
I'm guessing the more it looks like noise, the better the compression ratio (see the video files). Any visible structure is an opportunity for compression.
Definitely remove `sudo` and make sure it runs without su privileges: I, personally, would not trust such testing environment/system/etc., which requires extra privileges. Nevertheless, the output looks interesting.
Updated image and repo. Agreed, no need for `sudo` here
The go tour does a good job of teaching golang without doing a whole lot of "now a variable lets us store a value, but what if you wanted to branch your program depending on its value?" type stuff
If you can attend an in person class by Ardan Labs I would recommend it. They do have content on GitHub https://github.com/ardanlabs/gotraining
This. Go is a really simple language, just dive in o the tour.
From the "playground" demo it looks to be a query language for HTML docs. Similar to what jQuery (or xpath) offer. Actually kind of neat to have a query language for this. Unclear how it handles the modern apps of the day that render everything. 
https://gobyexample.com/ is all you need.
For interesting things you can do with Go and other small projects, don‚Äôt forget the [Just For Func](https://www.youtube.com/channel/UC_BzFbxG2za3bp5NRRRXJSw) series by Francesc Campoy. 
Currently doing https://gophercises.com/ and getting a lot out of it. 
If you don't use either DomainRegexp or DomainGlob then your limit (the parallelism will never match anything). I don't see anything else that jumps out at me from the one time I use Colly... ``` myCollector.Limit(&amp;colly.LimitRule{ Parallelism: 2, DomainGlob: "*", }) ```
[removed]
I can't get it to work. It just says "waiting for Firefox to connect" forever. Tried googling around, but I didn't find anything helpful. 
I was asking more from the standpoint of how to handle this in go from the testing container into another container that is running the DB
Turns out the secret to getting people to write good documentation was to _remove_ all of the darn notation from the documentation comments. I still laugh to distract myself from the pain whenever I have to document something in Java. ^(Having tons of good examples of how to write good documentation all over the place in the standard library doesn't hurt, either. Nor does having the documentation easily link to _the exact line of code that a declaration was from_.)
If you know the concepts and just need the syntax: [https://learnxinyminutes.com/docs/go/](https://learnxinyminutes.com/docs/go/) &amp;#x200B; What languages do you know already? I might be able to tell you the key differences there and what you need to learn.
I know C#, R, PHP and JavaScript. Thanks!
I guess one thing I'm not familiar with coming from those languages is pointers. I'm not sure what the difference between `var i int` and `i = new(int)` is, and I'm not sure what to do with `make()`
Can it revert the graph back to the original structure? This would be great for any kind of wysiwyg stuff. 
This is a good material to learn Go
go lang built-in tool tour and this course.
Dude can you name some of such startups. I will try to apply there. I would be very very thankful. 
Ultimate Go programming by William Kennedy
When I write Go I don't typically use `make()` or `new()`. I will when I have to create maps or channels, but only because it's required for initialization. But what you stated are all valid ways of initializing things. Pointers are rather simple once you get the hang of it and you'll be annoyed when other languages don't make it so clear in the future. I won't go into how these work since it's easy to look up, but in general you probably want to use values when it's a simple structure (like an int) and a pointer when you're dealing with objects / more complicated structures. You might not have much experience with channels either - channels and goroutines are the most unique and powerful parts of Go. Master them.
Thanks for the tips - goroutines look very exciting, I just want to master single thread programming before I even try to understand them
You say you know C#, so: &gt; one thing I'm not familiar with coming from those languages is pointers Pointers aren't really Go-specific, so I think [Wikipedia will tell you most of what you need to know](https://en.wikipedia.org/wiki/Pointer_(computer_programming\)). That article even has a small section on [Go pointers](https://en.wikipedia.org/wiki/Pointer_(computer_programming\)#Go) in particular. &gt; I'm not sure what the difference between `var i int` and `i = new(int)` is `var i int` allocates an integer value and gives it the name `i`. `i = new(int)` assigns a pointer to a newly-allocated integer to `i`, which is presumably a pre-existing variable of type `*int` (pointer to integer) or `interface{}`. The latter is the empty interface type, analogous to C#'s `object` type in that it can hold a value of any type. As an aside, if `i` did *not* already exist, it could instead be created on the spot with a minor modification to `i := new(int)`, which would give it the type `*int`. This is equivalent to `var i = new(int)` or `var i *int = new(int)`. &gt;I'm not sure what to do with `make()` when I can initialize a slice with `[]int` AFAIK C# does not have a concept of slices (but see below re: `List&lt;T&gt;`), so first things first: Go distinguishes between arrays and slices. Arrays have fixed sizes and are *value types* unlike most other languages. That means array types like `[5]int` can only ever have hold arrays of their predetermined size and they cannot directly be used when a dynamic size is needed, which is where slices come in. Slices are *views* of a backing array. Think of it as similar to C# `List&lt;T&gt;`, except different slices can have the same backing array, and can have different offsets or lengths. (There's also the capacity, which is the "headroom" available for a slice, and usually the offset + capacity is the length of the backing array unless it's been explicitly restricted, but that might be going a bit too in-depth). `var x []int` (which is what you presumably mean by that last part) will create only a slice variable but not assign a backing array (it will be `nil`, which is a special case of the empty slice: not all empty slices are nil, but all nil slices are empty). This is basically a cross between `List&lt;int&gt; x` and `var x = new List&lt;int&gt;()` in C#, in that `x == nil` will return true but it can otherwise be used as if it were a fully-functional (albeit empty) `List&lt;int&gt;`. `make([]int, length)` allocates a backing array, of fixed size `length`, and return a full slice of it (from beginning to end). `make([]int, length, capacity)` will also allocate a backing array, but of length `capacity`, and return a slice of length `length` starting at offset 0, leaving some amount of extra headroom for things like `append`. `make([]int, 0, 4)` is about equivalent to `new List&lt;int&gt;(4)` in C#, I think. `append(s, 5)` will add an extra element (`5`) to the end of a slice if there's enough "headroom" for it, writing it into the backing array of `s` just after the last element of `s` and returns a slice of length 1 longer with the same backing array. If there's *not* enough "headroom", it will instead allocate a larger backing array, copy the contents of `s` into its beginning and put `5` right after it, and return a slice with *that* backing array. Either way, `s` itself is unaffected so if you want to reuse it to address the expanded (or replaced) slice, you need to assign the result of `append` back to it. You can think of `s = append(s, 5)` a bit like C#'s `s.Add(5)`, except that since `s` itself is a value type other copies of it are unaffected. For more on arrays slices, see [this and following chapters of the tour](https://tour.golang.org/moretypes/6). For how slices work internally, see [this blog post](https://blog.golang.org/go-slices-usage-and-internals), though that kind of assumes you have somewhat of a handle on pointers already, I think. (Also, `make()` can be used for other stuff like channels and maps which require some more initialization than the "just set all the bytes to zero" Go usually uses) I hope this helps you further along. I'll mention the [Learning Go section of the docs](https://golang.org/doc/#learning) here, where you can find both the tour and "Effective Go", both of which should be helpful.
Thanks for explaining this. I appreciate the thorough and thoughtful explanation of each point. A couple things I'm curious about, apologies if I misunderstood your explanation or missed something. If I create a pointer to a new int with `x := new(int)` then x is of type *int, so all I have is a pointer. Let's say I want to initialize a new variable y with the value stored at x, would I simply do y := *x? I guess I don't get the advantage of initializing a pointer instead of initializing a variable, then pointing to that variable. I'm also wondering, since slices are backed by arrays which have to be fixed in length, are slices truly able to be dynamic in length, or are they always limited by the size of their backing array? I ask because if not, I imagine appending to a long slice would be very inefficient since the backing array would have to be copied into an array of length n+1. I may be making too many assumptions here - as you can tell from the languages I know, lower level programming is foreign to me. I at first thought slices were the equivalent of List&lt;&gt; in C#, but that doesn't appear to be the case.
Thanks for the thoughtful and thorough explanations. I'm curious what the advantage is to declaring an empty pointer, rather than declaring the variable first and then pointing to it. 
github
Thanks works ! :)
declaring an empty pointer allows you to assign to it later... e.g: var result *int if thing &gt; 5 { result = &amp;thing } else { result = &amp;otherThing } *result = *result + 10 return result contrived example, obviously. But just like any other variable, sometimes you need to declare it before giving it a value.
Neither. Webassembly for go is too new and I‚Äôm afraid there isn‚Äôt a whole lot on stackoverflow that could help you out. GopherJS without knowing JavaScript first might be scary as well. I recommend writing typescript on the front end and golang for the backend. If you want to learn something ‚Äúnew‚Äù use grpc / grpc-web to connect them instead of a json-http. There are a lot of front end frameworks you can try. Vue and react are a couple big name ones. 
it says 'application/json' for response header
I'll check that, thanks for the quick answer. I indeed have no JS knowing atm (Might as well learn basics quickly, won't be useless for my future anyway). But I'm not sure, think the boss wanted either one or the other, since he likes to take internship students with him, he might prefer something any newcomer can get in hand easily with online documentation... Well, I'll ask later.
that's weird then. have you tried using gzip before reading it? although I'm pretty sure `net/http` does that automatically.
Maybe it's gzipped, but transfer encoding is incorrectly set? 
It's kinda ultra-boring "HOW-TOs" video, I wouldn't advice that. This is bad practice (IMO), 'cause it cannot give you a solid knowledge of language. I would recommend [Ultimate Go Programming](https://www.oreilly.com/library/view/ultimate-go-programming/9780134757476/) by William Kennedy from Ardan labs. It's not cheap (\~$280), but it's worth it. William Kennedy is also author of [Go in Action](https://www.manning.com/books/go-in-action). I strictly not recommend to watch/read materials of such cheap publishers like packt. &amp;#x200B; &amp;#x200B; &amp;#x200B; &amp;#x200B;
gophercises is just coding exercises, not a learning tool. I think you're misunderstanding its purpose as much as the guy you replied to is making a slightly poor recommendation.
Oh I Think I know what the issue is. Ive set that i accept encoding gzip so it will not decode automatically. I will give it a try later :)
Why do you recommend Typescript over Javascript?
[removed]
Not OP, but I'd say that if you intended to code in Go, a language that's both statically and strongly typed, going directly to Javascript could be.. overwheling Typescript being stricter concerning typing and whatnot, I feel that the transition from Go to Typescript could be easier.
That's definitely what's attracting me to Go. My toolbox has most of what it needs with Python. But when I need something to be performant and it can't be done with existing libraries or Python wrappers, I'd love to stop having to write C. I'm new to Go but so far it seems I can just author a library and use CFFI or whatnot to call in to it.
Can you post some example output?
I love your approach, a very nice drop-in generator! Hard to add something else here. Usually generators are used to provide mocks (moq, gomock, etc.) or a whole edge implementation (api endpoint gateways), and it's refreshing to see a generator *add functionality* (and not dictating things)
Thanks, you can extend it using your own templates, so actually you can generate whatever you want with this tool. I just implemented templates for most wanted features.
Yes
Sure, I tested generated code for all templates in the repo. You can find examples of the generated code here: [https://github.com/hexdigest/gowrap/tree/master/templates\_tests](https://github.com/hexdigest/gowrap/tree/master/templates_tests) There's interface.go file that contains an interface declaration. All other files either examples of the generated decorators or tests for the generated decorators.
[removed]
Thanks, I'll check it out. Have you used it in any open source projects?
Not yet. I just recently finished it. Feel free to use it for whatever you want :)
I actually just did the same thing at my company. It was pretty simple to do. I have a few people looking at it now and playing with it, but so far, so good. I can explain what my problem was and how I solved it, maybe some of it will be relevant for you. Problem: we have a bunch of routable micro services that need to be protected. Most of these services are REST APIs, but some are web frontends. This means we now have two different access patterns: service to service and user to service. This is important as we don‚Äôt want users to have to sign in to each web service individually, so we have an opportunity to introduce single sign on here. Our primary identity and access management system is LDAP for now. So I wrote a simple Go service that performs logins against LDAP for both user and service accounts that returns a JWT. There‚Äôs also a second API for validating a token, so that we don‚Äôt have to share any signing keys. This handles the service to service pattern: app gets token, calls app2 with token, app2 validates token using auth service and done. I also implemented an API for querying LDAP so that apps can get the username from the token, then get a list of groups they are members of to handle AuthZ. For users, things are a little more complicated. While apps could implement their own login screens that do the same thing as before, the idea was to make the implementation easy for apps. Apps check for a cookie or the auth header and just send both to the auth service. The service then determines if there is a valid token in there somewhere. If not, the app is instructed to redirect users to the auth service which has a built in login page. Once logged in, a cookie is set in the browser for the domain and users are redirected back to the original app. Now, any user that visits a web app that uses the auth service for authentication will automatically be recognized as long as the cookie remains and the JWT is still valid. I didn‚Äôt want to build a full OpenID Connect (OAuth2.0) solution as that is way overkill for our needs and I‚Äôm still not fully sure how it all works. The service I built ended up with two endpoints for handling authentication: /login and /validate. I also may look into public/private JWT signing so that apps could validate the tokens themselves is latency is a real concern, but the /validate endpoint can already handle a thousand requests per second as a single instance, so there shouldn‚Äôt be much concern having apps call it for every incoming request that needs authentication. 
@deejross exactly what i'm trying to build minus the ldap :) I'm trying to migrate a existing legacy authentication layer to JWT user to service and service to service solution. service to service I mean we can use oAuth for that, the main thing is the user doesn't need to login to the various services, the services should validate the token and if the user has access then allow them otherwise tell them no access. I have found tons of good examples of how to authenicate the user just ZERO about how to authorize them or authorize a service to auth/authz service. Any suggestions on where to look? &amp;#x200B; The idea would be that this auth/authz microservice would handle all things Authentication and Authorization. This is where my oAuth 2.x and JWT stuff would all live. Users would also get their RBAC/ACL per service when the service would validate their token. &amp;#x200B;
Just an update for anyone looking to do the same. This result worked. The sad part is, I had this solution previously, however since it was declared inside the loop, the result could not be passed outside, so like a newb, I scrapped the idea. Turns out, keeping this declaration inside the loop, then creating a global variable and assigning the result to that allows it to be passed as needed. &amp;#x200B; Thanks to all of you. I am new to this community, and fairly new to Golang, and I have nothing but great things to say. You all help in a way that lets a newbie feel accepted, and not shunned.
Can you share your full Dockerfile for this build?
Embedding Go in non-Go isn't a really great experience, you're much better off letting the Go runtime be in charge of the process.
I also use neovim but all the plugins are vim compatible * 'tomtom/tcomment\_vim' - For easy multilanguage efficient commenting * 'ctrlpvim/ctrlp.vim' - Mainly for fuzzy buffer/file navigation, also a vim-go dependency * 'altercation/vim-colors-solarized' - One readable thme * 'itchyny/lightline.vim' - a light decent status line * 'fatih/vim-go' - THE ONE YOU NEED FOR GO * 'SirVer/ultisnips', { 'for': 'go' } "required by vim-go * 'tpope/vim-surround' - So useful to deal with tags/quotes * 'jiangmiao/auto-pairs' I'm also thinking about * 'autozimu/LanguageClient-neovim'
Yeah the resulting AuthZ I leave up to the individual microservices to figure out once they have a valid identity to work with. In my case, I‚Äôm using LDAP security group membership as my AuthZ, so I make it easier for services to get group membership info from the auth service. It‚Äôs a crude example, but if I have a group called App1-Access and App1-Admin, once I have the user/service account name, I hit the LDAP API I built and ask it if the user is a member of the particular group. If they need admin access, they need to be in the admin group. I‚Äôm not sure what your version of that would be, but you might also want to look at something like Dex: https://github.com/dexidp/dex 
`%v` isn't "print a struct" in Go. It's "oh, just print this thing, I don't care how, just do it". If you want _specific_ information, it's not the right choice. If you want to dump a struct with the default library, "%#v" is better, but the subcomponents of the struct can still have interface implementations affect them. Something like [go-spew](https://github.com/davecgh/go-spew) is even better, but I've also lost some data I was looking for because I implemented a .String() method. The upshot seems to be that if you want some particular data printed out, you need to do it yourself, or be _very_ careful about your .String and .GoString methods.
I love the output formatting. Great job!
Then the title is misleading. 
&gt; In that respect it does not allow for higher level abstractions that would allow you to do simplify complex algorithms. Adding complexity to a language until complex algorithms look easy is not a solution. You then just traded algorithm complexity for language complexity. I believe there is a sweet spot between simple and complex where a language is expressive enough for most requirements, yet clean and straightforward enough to make it easy to read (and reason about) other people's code. And I believe that Go is pretty close to that sweet spot. YMMV. 
It seems a shame to take three BSD, Apache and MIT licensed libraries and put them together in a GPL 3.0 library, which makes this project not useful in a lot of projects that prefer to keep more permissive licenses. I always recommend that libraries keep MIT, BSD, or Apache 2.0 licenses and things like servers, databases, photo software can be GPL if you choose because you aren't going to hurt other open source projects that way.
That's the one. Thanks for covering my lazy ass
It depends on where you come from. The canonical answer is: use plain JS. But JS is a tricky language in it's own right, and it's async nature takes time to master. Going with gopherjs/wa is a bad idea imho. They are good for hiding an engine/framework that benefits from the nature of go (or require fast/optimised code paths) TS is also a no for me, unless you know JS. You'll constantly be jumping between different layer of environments, which is a recipe for chaos.
I think about what license to choose for libraries, for binaries/servers I usually don't care. But I can always relicense now to e.g. BSD, if there is a need?
Or you just keep a list of revoked tokens in memory. You only need to store a blacklist of jti values, after all.
fair enough... at first I wasn't thinking of it as a server but as a library because I was thinking it would need to be modified to fit into an application with auth and other things, but as I thought about it, I realized my assumption wasn't correct. Anyway, I'm excited to try it out. I actually have a Raspberry Pi and webcam on my desk that I've meant to use for showing the parking on the street below my condo, so this project looks like a perfect way to change this from a 2 week project into a 20 minute project! :-D
I'm using (some of) https://github.com/fatih/vim-go
[removed]
Every run of go:generate gets a chance to wreck things. If the command line generated changes, what gets done when gets confusing, and you might even need to run go generate multiple times for it to settle. If something goes wrong, you can't just `rm *.gen.go; go generate`, because you just deleted your go:generate lines.
For the record, software flow control is hardly "archaic bullshit"; it's there for a reason. If you don't like it, you can always turn it off with: `stty -ixoff -ixon`
...and I thought it was "All software eventually becomes BigTable" :P
Nope, if you have more than 1 instance then you are still hitting a centralized "storage". At that point you can just look up your session data.
Thank you, I actually added this line after I got an error that the /hello path does not exist. Will try again and let you know - I may have just done something really wrong 
No, you've pretty much covered it -- but, sometimes it's just easier to hit CTRL-S and scrollback a little than it is to let 4T flow by on your screen. Also, most output buffers aren't very big and, if you suspend output w/ CTRL-S you can often force the process to block waiting to write -- and *that* can really come in handy when you're in a pickle! :D
This submission has been randomly featured in /r/serendipity, a bot-driven subreddit discovery engine. More here: /r/Serendipity/comments/9shs0a/cam2ip_15_turn_any_webcam_into_an_ip_camera_now/
...and, now that I think about it -- shouldn't software flow control get handled by the `tty` driver and not the terminal?
That example makes sense. Thanks!
`rr := r` I'm not sure why/if this line is necessary? &amp;#x200B; `for c := time.Tick(1 * time.Second); ; &lt;-c` I'm not sure why you'd need a `time.Ticker` in this portion of your code. I'm assuming the `time.Sleep(time.Second*2)` in main represents the `expiresIn` you mentioned? As it currently stands, you're forcing anyone using your closure to wait at least one second between generating tokens; it probably makes more sense to just generate a new token whenever someone asks for it. Finally, you have two memory leaks in your current implementation: there is no way to stop the goroutine or `time.Ticker`.
Got it... Thanks for the feedback, I think I need to read more about go routines :D
Btw. both VS Code and Atom both have decent Vim plugins. Others may also, but haven't tested it personally. 
I wasn't sure -- so, I just checked. Sadly, it looks like vim's undo files have a different format. I'll have to dig a little to see how much of a difference that is. 
OK -- after a little more digging, it doesn't look like undo files have the same metadata in them that swap files have. Since this package only deals with a swap file's "block 0" I'm afraid it doesn't have anything to read from an undo file.
Probably because authz is something that's hard to do in a centralized way. Authn is simple; you've got a token and you want to know who the heck it belongs to. But every service you might be running has its own business logic and authz rules for how the person that's making a request is allowed to interact with the logic. I think AWS IAM's authz model is a _really_ good one that is probably too complex for its own good, but you could distill it down and create something that is generally shareable among a service architecture. You've got "services"; those services have "actions" that map to API routes; actions act on resources. The hardest part is figuring out a model that works for the way Resources are set up in your app; for example, if your app sends messages, you might have a SendMessage action, but what's the resource there? Its not the message, its almost the "people" that you send to. Etc. Authz is ridiculously hard and domain specific. That's why you don't see a lot of generic solutions, unlike authn. 
I thought the idea behind steroids was to make things faster, not 2-3x slower ;)
Kind of curious why you're returning a function. Is that a Go standard thing that I'm unaware of?
1. For more true randomness its better to replace 'math/rand' by 'crypto/rand' 2. Its easier to get some of shaXYZsum of 1 generated number instead of 10 random generations 3. Throw away all that mentioned random shit and use [uuid](https://github.com/satori/go.uuid) for simplicity.
Each time you call tokenGenerator() it will spawn a new goroutine and generate a new ticker. It will then wait for one tick to get a random value and return that. After that none of it is reused. Judging by the code I think this is what you maybe meant to do?: https://play.golang.org/p/1poRKU80zm9
This was already posted 6 days ago [1]. [1] https://www.reddit.com/r/golang/comments/9qsiqp/build_a_singlepage_app_with_go_and_vue/
Yes, you‚Äôre correct in both arguments, I was spawning a new goroutine and that‚Äôs exactly what I wanted to do but with different constructs
*&gt; Every run of go:generate gets a chance to wreck things. If the command line generated changes, what gets done when gets confusing* When command line changes you wreck things anyways whenever you put the go:generate instruction. Let's say you put go:generate instruction near the interface declaration manually and the version of ANY tool you use for the code generation has backward incompatible changes. You can't simply rm \*.gen.go;go generate in this case either. *&gt; and you might even need to run go generate multiple times for it to settle.* I would like to see an example when you need to run go generate multiple times. I use code generation a lot and it never happened to me. *&gt; If something goes wrong, you can't just* *rm \*.gen.go; go generate**, because you just deleted your go:generate lines.* This is true but we all use VCSs nowadays. *&gt; Putting go:generate lines in generated code makes about as much sense as having a code generator use the same file as both input and output.* No, it's not. go:generate instruction is an input for the "go generate" command, the generated file is an output of the "gowrap" command. I think for the most of use cases it's just simplest and working solution. Still you can use "-g" option and put go:generate instruction whenever you want if you don't like that behavior. I appreciate your comment though. I actually spent quite a while thinking about default behaviour and maybe I'm not right, let's see what other people think. &amp;#x200B;
So we had the router-pocalypse, then the logger-pocalypse and now it's time for the DIC-pocalypse? Please kindly take your DICs and go back to other languages. Cargo culting is hurting Go.
I haven‚Äôt reviewed the implementation...but can you be certain this is an apples to apples comparison? NATS has like 4 years (more?) of optimization on top of golang. GC pause being the main bottleneck can be significantly improved.
You can never really be sure for large-scale benchmarks like this. I'm not familiar with NATS but from briefly looking at the code it doesn't look like there's any mental optimisation going on there - looks like idiomatic Go.
I guess it was just a matter of time till something like this would appear given how fast go compilation is and how easy to get started with go is.
Check [vecty](https://github.com/gopherjs/vecty) and [myitcv/react](https://github.com/myitcv/react) for GopherJS higher level building blocks. I'm using Vecty for two frontend projects, and really impressed how cool is the experience. Never had so much fun and confidence writing frontends. Going to blog about it soon.
I think I heared something about vecty on m'y first day, might be worth
I thought we killed spaghetti-code long time ago.
Use io.ReadFull or ReadAtLeast - fh.Read may not read as much ss you eant!
Well, not CGo actually :) By default it uses libjpeg-turbo, OpenCV is optional, but it can be compiled without CGo with `-tags jpeg` , on Linux/RPi and Windows. For macOS you can use `-tags cv2` or `-tags cv3`, even if implemented without OpenCV on macOS CGo will be needed.
I'm looking for a light weight webserver, is this 1st choice? Any alternatives?
Web server != router. Router only spawns handlers for defined HTTP paths. If you are looking for a lightweight router, there's a few to choose from. Depends on what you need. 
I want to serve static files, and Json.
I recommend a dedicated web server (Nginx, Apache) for static files. Dynamic JSON can be served by any Go router. Try Chi muxer or OP solution (but I haven't tried the latter). 
This, the op, "router" serves static files. According to the readme. I want it to be embedded, so I can provide one binary to a user. Like a fat jar with embedded tomcat.
There is one optimization which _looks_ like idiomatic Go, but is very easy to turn it to unoptimized code. That is the map[string] lookup. If you do `map[string(byteSlice)]`, the compiler doesn't allocate the string. But the moment you change it to `buf := string; map[string(buf)]`, it allocates. Optimizations like these matter if you are looking for high throughput.
I'm trying to stay as close to vanilla as possible without causing a lot of pain. I'm using the following plugins: - [`ctrlpvim/ctrlp.vim`](https://github.com/kien/ctrlp.vim) is a fuzzy file finder I'm using it in conjunction with [`ripgrep`](https://github.com/BurntSushi/ripgrep) because it's speed allows you to disable `ctrlpvim/ctrp.vim`'s caching mechanism. " Use Ripgrep if executable('rg') " Use Rg over Grep set grepprg=rg\ --color=never " Use rg in CtrlP for listing files. Lightning fast and respects .gitignore let g:ctrlp_user_command = 'rg %s --files --color=never --glob ""' " rg is fast enough that CtrlP doesn't need to cache let g:ctrlp_use_caching = 0 if !exists(":Rg") command -nargs=+ -complete=file -bar Rg silent! grep! &lt;args&gt;|cwindow|redraw! nnoremap \ :Rg&lt;SPACE&gt; endif endif I lifted this from [thoughtbot's `.vimrc`](https://github.com/thoughtbot/dotfiles/blob/master/vimrc). However, they're using The Silver Searcher instead, which is not as fast as `ripgrep`. - [`tpope/vim-surround`](https://github.com/tpope/vim-surround) simplifies handling parentheses, brackets, quotes, XML tags, ... - [`vim-scripts/tComment`](https://www.vim.org/scripts/script.php?script_id=1173) simplies commenting out and uncommenting - [`jremmen/vim-ripgrep`](https://github.com/jremmen/vim-ripgrep) use `ripgrep` to display results in a quickfix list - [`fatih/vim-go`](https://github.com/fatih/vim-go) of course No syntax highlighting because I do not like code that is readable only if you're using it anyway and switching back and forth between syntax highlighting and no syntax highlighting due to different environments was an unnerving experience while it lasted. Furthermore, last time I checked syntax highlighting was glaringly inferior compared to what Visual Studio Code and others have to offer. scriptencoding utf-8 let mapleader = " " set backspace=2 " Backspace deletes like most programs in insert mode set nobackup set nowritebackup set noswapfile " http://robots.thoughtbot.com/post/18739402579/global-gitignore#comment-458413287 set history=50 set ruler " show the cursor position all the time set showcmd " display incomplete commands set incsearch " do incremental searching set laststatus=2 " Always display the status line set autowrite " Automatically :write before running commands set hlsearch " Highlight all search results filetype plugin indent on augroup vimrcEx autocmd! " When editing a file, always jump to the last known cursor position. " Don't do it for commit messages, when the position is invalid, or when " inside an event handler (happens when dropping a file on gvim). autocmd BufReadPost * \ if &amp;ft != 'gitcommit' &amp;&amp; line("'\"") &gt; 0 &amp;&amp; line("'\"") &lt;= line("$") | \ exe "normal g`\"" | \ endif augroup END autocmd Filetype go set nolist " Use one space, not two, after punctuation. set nojoinspaces " Numbers set numberwidth=5 set number set relativenumber That's it. 
Thanks!
So you shouldn‚Äôt do the second one because it uses more memory?
Yeah I just really like GoLand because you can press cmd b and it takes you to the function declaration which makes it easy to learn the packages as I use them. Still tryna figure out how to do that in Vim
also make sure to keep a read write lock around updating and readjng like in the playground improved version to avoid race condition
After comparing go and java, it concludes that go can replace c++... there are not enought unicode code points to express the unrelateness
Yes, I thought it was obvious enough. Unless you deliberately want to use more memory somehow ..
You can do that in VSCode. Although IdeaVim is better than VSCode vim, I've found. I think it works great. Spacemacs is a great way to go for configuration out of the box. (emacs + vim mode)
[removed]
[removed]
By an account that has only ever posted about Okta. And now this sound that goes around posting about Okta as well on various subreddits I think both are working at Okta.
Ory's [Keto](https://github.com/ory/keto) gives you authz. Ory also has [Hydra](https://github.com/ory/hydra) for authn. While you're left to build the actual ID provider (for authn) yourself, those two and, if you like, [Oathkeeper](https://github.com/ory/oathkeeper) to in the darkness bind them, can get you quite a bit along the way with off-the-shelf. They have ready-to-run [examples](https://github.com/ory/examples) using all of the above. 
That repo is unmaintained and has a security bug. Use this fork: https://gof.rs/projects/uuid/
A markdown wiki is a project that gets me interested in using it too. Running a specific program motives programming. This is how eating motives cooking.
[removed]
You could leverage BoltDB for some task/todo management application. If anyone wants to push the limits then you could also do some (g)RPC stuff with a GUI. 
Right it was and no I wouldn‚Äôt. Sorry I‚Äôm starting out and just wanted to make sure since I always seem to misinterpret. 
/u/qu33ksilver wasn't entirely correct regarding allocations: converting a string to a byte slice (and vice versa) _does_ allocate memory. Strings are immutable, so when converting a byte slice to a string they more or less have to be copied to preserve the immutability guarantee. The same applies in the other direction; converting a string to a byte slice requires making a copy so the backing array of the slice (i.e. the contents of the original string) can be changed. See eg. https://github.com/golang/go/issues/25484 for discussion. You can verify this yourself with: func BenchmarkStringConv(b *testing.B) { b.Run("string to slice", func(b *testing.B) { str := "abcdefghi" bs := make([][]byte, b.N) b.ReportAllocs() b.ResetTimer() for i := 0; i &lt; b.N; i++ { bs[i] = []byte(str) } }) b.Run("slice to string", func(b *testing.B) { bs := []byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'} strs := make([]string, b.N) b.ReportAllocs() b.ResetTimer() for i := 0; i &lt; b.N; i++ { strs[i] = string(bs) } }) b.Run("unsafe bytes to string", func(b *testing.B) { bs := []byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i'} strs := make([]string, b.N) b.ReportAllocs() b.ResetTimer() for i := 0; i &lt; b.N; i++ { strs[i] = byteSlice2String(bs) } }) } The pre-allocated `[][]byte` and `[]slice` are there to prevent the compiler from optimizing away the conversion happening in the loop. They have no effect on the reported number of allocations. The output will be something like `BenchmarkStringConv/string_to_slice-8 30000000 47.0 ns/op 16 B/op 1 allocs/op` `BenchmarkStringConv/slice_to_string-8 50000000 30.5 ns/op 16 B/op 1 allocs/op` `BenchmarkStringConv/unsafe_bytes_to_string-8 500000000 8.03 ns/op 0 B/op 0 allocs/op` meaning that "normal" conversions between strings and byte slices allocate, and the unsafe and hacky way doesn't.
I once wrote (not in Go though) a small utility to highlight stderr in a different color than stdout. So if you run `color cmd arg1 arg2` in your terminal you'll see the output of `cmd arg1 arg2`, but with stderr in red. Might be *too* small though, I don't think it'd take hours to write this even for programmers unfamiliar with the language.
A small music player. 
I think this is the way to go. It has non-trivial utility, but is not that hard to put together. Plus, if someone finishes early, there's plenty more features they can think of that they can add in that time frame. Just by way of showing by example how easy this can be, I wrote [markdir](https://github.com/thejerf/markdir/) for just this sort of purpose; not showing off how awesome my coding skills are, but showing off how easy and rapidly you can put this sort of thing together. You can crib off of that for your own research pretty easily. It's a sample project, yet one that I still occasionally actually use myself.
To be honest, it isn't really that interesting to ensure that it's an apples-to-apples to comparison once you get up to this scale. What matters, and what this does reasonably successfully demonstrate, is that Go is at least in the same range, and is a viable choice. I pretty much guarantee that if you tried to get a pure Python server up to the same speed, you'd quite likely fail, and if you didn't, you'd put a _lot_ more effort into it. Just the fact that Go and Java could get into an optimization race is enough to prove that Go can run in the optimization race, which is the important fact. Which of them could, after several months of optimization, be the fastest, is not _that_ important, except on that small handful of software where someone may take it to that level.
https://github.com/caalberts/localroast/issues/9 created an issue for this. Please contribute your ideas.
Cool idea, music is always good. But at this point I have no idea how to make this. But I will make some research for it.
In our local Go user group (Orlango), we wrote a simple version of GNU Parallel. We broke into groups of 2-3 devs and pair programmed (one novice to the language paired with someone more experienced). It took data from studio, so you could pipe output from another program or set the number of parallel processes, just something pretty simple. Had to use a number of techniques I was unfamiliar with, specifically goroutines and Go's closures. In your workshop you may not have the benefit of having the experienced devs, but I think the idea could be useful. You could potentially give them the tools to start from, maybe show them `go doc` and tell them the libraries that will help them `bufio.Scanner`, so they get experience using some of Go's built in tools.
There's an id3v2 library to read Metadata, and plenty of small ones for audio, and bindings to ffmpeg. I'd look into https://github.com/eugene-eeo/orchid and try make a simpler version of it :) 
Robotgo is always fun 
TCP port scanner to show off go routines and channels 
And then React came along.
As far as I know, memory in C is allocated using `malloc/calloc`. In my code, I am not calling any of these two explicitly, just casting pointers to Go objects and vice versa. What that tells me is either of 2 things: 1. The C code I am using allocs things and then does not take care of freeing them. 2. Casting things back and forth is leaving some orphaned references somewhere. I am not too sure about 2. I will go back and check more judiciously for number 1. Thank you for your help, BTW.
http://www.todobackend.com/contribute.html I saw recently and looked like a good spec.
Thanks for the list, that's really handy. I knew there's cases where the compiler can avoid the copy, I just didn't think to search for a good source. But yeah, in general the conversions do cause allocations due to string immutability; the exceptions in your link are cases where the compiler can guarantee there's no mutation
&gt; converting a string to a byte slice (and vice versa) does allocate memory. Yes, I never said that it doesn't. The optimization I mentioned is _only_ applicable for map[string] lookups. Here is the commit which does that - https://github.com/golang/go/commit/f5f5a8b6209f84961687d993b93ea0d397f5d5bf. And NATS uses this optimization. That was the entire context. Hope that clarifies. 
Thanks for your feedback. I find your comment intriguing. Given the context it's almost as if you're advocating that `fh.Read` should rarely if ever be used - regardless of circumstance. In this case however, I don't believe a change is warranted. `ReadFull` is decidedly uncalled for; since we only ever read block 0 of many. `ReadAtLeast` is a possibility but I'm not sure if fits here either. Given the unlikeliness of a short read while consuming \~1kb in a 4kb block-size world, it seems like *just so much window dressing* \-- especially since the only situations I can come up with that would introduce a short read in this context are indications of a higher order issue to be addressed elsewhere (and would, more often than not, emit an error as well). Then there's the little matter of the last sentence of the docs for `ReadAtLeast`: &gt;If r returns an error having read at least min bytes, the error is dropped. In this case, I believe I'm more concerned about the error than the short read. \-- While I've long been familiar with `ReadFull`, I somehow missed `ReadAtLeast`. I'll take note and employ its use in the future as needed. I'm certain it will prove quite useful. Thank you.
Huge apologies. You're totally correct that I do work for Okta, but we really do care about being upstanding members of the communities we share in. I completely missed that this had already been shared, or I'd never have shared again.
Caddy is nice, too. Automatic certs and simple configuration make it my go-to these days, and it's replaced nginx on all of my servers. I almost reflexively put it in front of everything now.
Theoretically, gopherjs and webassembly are just different compiler targets, like i386 and arm. There are packages to bridge what supporting packages may be used by those targets. But you've got your work cut out for you. The ecosystem is incredibly immature.
GoCity is an implementation of the Code City metaphor for visualizing source code. GoCity represents a Go program as a city, as follows: * Folders are districts * Files are buildings * Structs are represented as buildings on the top of their files. The web tool is available here: [https://gocity.rodrigobrito.net/](https://gocity.rodrigobrito.net/)
Oh I see that makes sense thanks. 
As a Java developer, I can say that it is not well implemented. It uses the original socket api with a single socket, two dedicated threads, and synchronized methods. That is effective Java 1.0 code. Using NIO, such as through Netty, would be a more modern comparison. As usual, even attempts at fair benchmarks usually fail pretty badly.
nice
[removed]
[removed]
You could write a utility which mimics how go code is organized, with go get, run, build, install for other languages. go build/go install for interpreted languages should create an executable script that runs the main file of the project. the utility could also make use of go's path structure, with src, bin(and maybe pkg). Good luck!
You're right. The title was supposed to reflect the first line of the FAQ, but it looks to have misled many readers.
Ah, right you are. Wasn't paying enough attention, sorry
Another important thing to add; if you use function parameters for DI instead of assigning to struct fields, or basically any other method, then you can rely on the compiler a lot to tell you if you've forgotten to set a dependency somewhere. That is, if you update the constructor function when a new dependency is added, but don't update the uses of that constructor, the compiler will complain and not let you compile your code - much better than using something like dig or facebook inject.
The post didn't introduce any new packages, just explained the approaches you can take, and the various opinions that are in the community, with some suggestions. Amidst all of the reflection-based crap DIC's, I think this is a pretty good article to help people realise that those things _are_ bad if they couldn't themselves.
People are always comparing speed, but why does no one ever compare memory usage?
Take a look at the Create Rule section of the [Ownership Policy](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html) page in the Core Foundation guide. I'm relatively certain that it implies the CGWindowListCopyWindowInfo function creates memory that you are responsible for disposing of using a CFRelease. I think the Rect returned by CGRectMakeWithDictionaryRepresentation is something you are responsible for as well.
Profile your code.
The actual file you got from profiling would be the only way to make progress. See https://blog.golang.org/profiling-go-programs &amp; https://jvns.ca/blog/2017/09/24/profiling-go-with-pprof/
You need just a single Unicode code point to express your disdain: `U+1F4A9`.
I applaud your persistence. If I had half of your will, my life would certainly be even better üëè Have you tried benchmarking the server with a tool like `ab` or `hey` like /u/decapolar suggested? This is a a quick way to know if the server can respond to those 10k requests within your requirements.
Thanks for sharing this, it‚Äôs a very useful package. 
Tests are often the best documentation you'll get.
Street address parsing (simplified but you can make is complex as you want by including street intersections, for instance). I wrote it in JS, PHP, C# and Go and use in ETL projects. Does 95% of work. Requires a simple database-like storage for street type and unit type abbreviations. Could be in-memory storage. Arbitrary date/time formats parser with things like -Wed or +4d. I am writing one in TypeScript at the moment for org-mode VSCode plugin but will do it in Go later as it looks useful. Image resizing is an excellent idea. Make it use nearest neighbor but add more algorithms if you want to add complexity. Add conversion to grayscale as an option. &amp;#x200B; The first two are lending themselves nicely to covering with tests. 
I have this little workshop: - https://github.com/sbinet/margo Feel free to reuse/steal it :)
* First of all, most modern Java networking code using NIO. Its better on Linux. \[windows is better at multi-threading\]. The author says this is too much work for SSL. Ok. * I don't understand why the Java code is synchronizing on concurrent collections and \_especially\_ in the hot loop. There look to be several 'synchronized' statements being used when they needn't be used. * Why isn't there a ThreadPool (ExecutorService) for dispatching connections ? Why are new threads being created all the time ? Thread creation is expensive. Kindly use an ExecutorService Note: I use both Go and Java at work. I like Java 8 better for app software due to streams and lambdas. I like go for writing small, low-memory agent/side-car code.
IMHO, this is the most important first step. If the server your application is calling can't handle the load, it doesn't matter how fast or efficient your application is. The process will not be able to go any faster than the slowest part. &amp;#x200B; Once you find out the performance threshold of the server you're hitting, you can make adjustments to *your* application to stay just under it.
Haven't read your previous posts, but If the requests are taking 10 minutes, then this doesn't look to be a client problem. It looks to be a server problem. Benchmark your server separately with a cli tool. See [https://github.com/wg/wrk](https://github.com/wg/wrk) or choose one of the tools in [https://github.com/denji/awesome-http-benchmark](https://github.com/denji/awesome-http-benchmark)
Your readme isn't great - it refers to ./cmd/frontend/main.go which doesn't exist! Not a great start...
Nice now run `hey` again targeting the server you want to fetch info from. If that server is Google I'll warn you that they have strong anti-flood protection. You'll hit walls of captchas and temporary IP bans. There's no reasonable solution to bypass their protections while still expecting to perform 10k requests within seconds. I know from experience :)
Cool I'll take a look!
Is there a way to run "hey" while specifying a list of different auth headers for each separate request it should perform so that it only performs 1 of each? So basically if I want "-n 5000" (5000 requests) it will do 5000 requests with the 5000 different headers I provide it?
Oh man, thanks a lot for pointing that out.
aargh i was so close to work with you francesc!
It does not panic here (for reading a file shorter than 1016 bytes) only because you don't truncate the block to the real size and use it with zeroes.
EventSource (nee Server Sent Events) is a common method of doing this.
Thanks for the comment, not sure why but it was on some .gitignore. The file is there now.
Ta, thank you!
Really? When!?
Thank you for the suggestion! Have you personally used SSE? &amp;#x200B; I've been looking at SSE for a while, what worries me is that it's not supported by MS browsers and while I could use a polyfill it would essentially be the same polling solution that I currently have. [https://caniuse.com/#search=server%20sent%20event](https://caniuse.com/#search=server%20sent%20event) Furthermore, a smaller issue is that the current browser implementations have low limits for max Event Source connections, which is a problem when using multiple tabs. &amp;#x200B; I really didn't want to implement a websocket API but I think using something like [socket.io](https://socket.io) on the client is my best bet. I'll spend a little more time on this, and I'll update the thread in case I find a better solution.
Maybe but I see WAY too many articles about DICs lately.
i interviewed for the Senior ML Engineer a couple months ago, went all the way to the in person interview in Madrid,where I met with Vadim and the rest of the team, pretty cool people!. Didnt make the final cut though. You guys are very focused in DL and NLP and those are not my forte by far. Anyways, the main reason I learnt SourceD existed is because of your awesome videos!
Aha! I wasn't clearly following your train of thought but I see where you're going now. (n.b. verbosity can be a virtue :) ). I've updated the logic to puke on a short read and always truncate block0 to the proper size. I'm still not convinced of the appropriateness of io.ReadAtLeast in this situation; that call seems much more aligned with reliably reading x chunks of size n (more often than not from a socket).
I don't think I've ever been so excited to see code I don't need. :-D It's such a fun idea! And great execution. :)
I'll give you an easy example. You have a cart, with cart items. A cart item is basically a product with a certain quantity, but you don't want the frontend to understand this nesting, so your backend has a cart item model it stores in the db with a product id and a quantity, that then gets inflated to a domain cart item by combining the db cart item with the product information coming from a product service, this domain cart item knows about domain rules like for instance, how to price them, stock checks etc. It's quite a fat object. Then, you create a "frontend cart item" that really only contains price, name, quantity and image url and that's what you serialise to json for your SPA to render.
Try writting some little utils for your Raspberry Pi
There's not a single unit test in this project. If you can't be bothered to test your code, why should we?
This is really cool, gave it a star. From a UX standpoint it would be nice if the info box that pops up as you hover different things actually updated its position to follow the cursor at all times. Otherwise it kinda gets in the way of the cursor while you're looking at different things.
Hah that's awesome! Maybe next time you'll get the job!
Yeah, MS browsers still suck, no surprises there. You can work around the connection limit using a shared webworker if you expect many tabs to be opened, but this adds complexity, and imposes some additional restrictions. All that said, I would indeed just use websockets, however you'd excluded them from consideration in your original post (FWIW, you can secure websockets during the upgrade request very similarly to any other HTTP request).
\&gt; If a tool is so hard to use that it needs another tool to manage it's use, then something's not right. I would generally agree with you, but similar to something like logstash fits into ELK, docker is powerful by itself but was designed to be a part of a bigger stack. Docker was designed to be used with an orchestrator like kubernetes; the docker company offers [their own solution also](https://docs.docker.com/engine/swarm/swarm-tutorial/). it's unfortunate docker isn't an all in one solution, but isolating components to simple functions makes for much more powerful integrations &amp; frankly better use of the software.
Have you considered designing the Pool to add a task via `AddTask(func() error) ` instead of storing a single function for the pool that has to accept `interface{}`? That way you could run multiple functions in your pool using closures and have type safety. Also, are you sure that your worker and listener loops aren't just spinning and eating cpu when the pool is idle? You seem to use default cases alot in places where there aren't new messages or tasks. 
In my opinion, lambdas is one of the worst inventions in programming world. Generally, what lambdas is introduced into a language, it reflects that the flexibility of the language is weak and need a way to remedy. Functions in Go are so flexible that lambdas is not necessary at all for Go. ========================= By the way, what are the advantages of Java streams? Although there are tons of stream classes in Java, I don't think there is any advantage over Go's simple stream design.
So profiling my code over 30s with pprof I get 25.76s of runtime.usleep, what do I do with that?
I have had problems testing throughput in the past from a single machine. I was running into all kinds of problems with buffer overruns on the kernel side and tcp sockets not being reused. They used to have a recycle parameter for the kernel's tcp stack but I believe that's gone now. Something like https://stackoverflow.com/questions/410616/increasing-the-maximum-number-of-tcp-ip-connections-in-linux
because use of i++ and i-- as expressions accomplishes little besides reducing line count - which is a shitty metric, whether as a measure of productivity or efficiency - and the cost is that it's use is a common cause of subtle, hard-to-spot bugs.
What jumps out at me from a phone without the ability to look stuff up at the moment is that you could test this with different transports. The default simultaneous requests per host is pretty low, so you'll be waiting a lot. Of course, the server will need to actually be able to handle that. If the server is Google, like you used to test the hey tool, then the server can certainly take it, but it is Google throttling you with slow responses or something else along those lines. If you rotate headers, I wouldn't bet upon that helping. They would still see unusual traffic that they are most qualified to identify. The only thing likely to work would be to contact a sales rep at Google and ask what this will cost you for an API key without an exhaust in the range of the standard pricing model. If you use multiple accounts with different API keys, the attempt is still obvious and unlawful access of an electronic system is a crime. Facebook has actually filed felony charges against someone who web scraped without permission. I don't remember if they succeeded, but I'm sure it was expensive. It's a weird part of law, and I don't think Google would pursue anything, but don't try to intentionally skirt access policies. It isn't about being polite but rather it's that the crime isn't worth any benefit you could get. No reason to risk it.
A project management application for small teams to show activities when develop internal software projects, just like a white board.
It's typically only done by accident, not intentionally. Piling on a bunch of defers is not something good code does.
[removed]
I have done two automated e2e and regression frameworks so far in Go. My recommendation is to utilize the 'go test' framework that already exists. I started using build tags to organize e2e, performance, regression, and functional tests. So running e2e tests would look like 'go test -tags=e2e'. It doesn't solve everything for you, but it's a good base layer for organization and running test cases.
Wow, Ian gave a talk ! Nice.
We can agree to disagree on lambdas. That is OK. However streams have deeply significant advantages and I miss them in Golang. They are data \*pipelines\* that can be filtered, mapped, collected/reduced, buffered, split, merged in wide-variety of succinct ways. They have a mini language of their own that is common across programming platforms. Once you learn the mini language, they are far easier to read than nested for-loops as each stream operation has a well defined job. Using multiple for-loops, maps and slices to do this job is deeply, deeply painful. We will see stream libraries in Golang once generics comes in Go 2. 
Ignoring undefined behavior (others have covered that), even its defined behavior in C is subtle. In C, because they're expressions, you need prefix and suffix variants, because `x[++i]` and `x[i++]` behave differently. We don't need those in Go. And, based on the same example, we don't _want them_, either. `x[i++]` is one of those cleverly short things that are much clearer when written out explicitly as `x[i]; i++`. 
Are they open source? Where can I find some examples?
Yes as far as I know, selenium and appium need to be used. It seems to me that Go doesn't have much to offer in the QA automation domain. Most people seem to be going for Java or other languages. But I wanted to be sure and that's why I opened this thread, hoping to gather info and resources to read. After some search I found https://agouti.org but it looks much less friendlier than the equivalent Java framework and I am not sure if it supports Android apps.
What are your security concerns regarding websockets? 
Let's say you have a web server that serves a file called "weather.txt". (Clients can ask what the current weather is). You want to write a process update this text file. You can't just "file=os.Open(weather.txt); file.Write(bytes)" because clients are very likely to get a partially-written file. So you have to do an atomic rename (mv) of a file onto weather.txt. But there are some tricky corner cases that could leave bad state if your computer is unplugged/rebooted at just the wrong time. This package handles all those corner cases for you.
OK, I don't know Java has a Stream concept for any element type now. I misunderstood that a stream is a data/byte steam. Neglect the generic issue, the functions you described can be implemented in a custom library with one hundred lines of code by yourself. 
This is a great read: https://blog.golang.org/go-slices-usage-and-internals TLDR: struct slice { ptr *T, len, cap int } Copying the above struct around is fine because the pointer hidden inside always points to the underlying data so it can be modified. This is also how two different slices can use the same underlying data. 
From the little go I have programmed and read I think the idiomatic way of implementing this type of functionality in go is with package global objects. Ie, instead of having a single object storing data that can be used in different places, every package handles it's relevant data. In the place where you would populate the injector with data, you do it for the packages that need it. di.set('db', sql.Connect()) models.DefaultDb = sql.Connect()
there are no examples of how to extract the URL parameters in the Read me ``` mux := gorouter.New() //url parameters match mux.GET("/user/:id", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte("match user/:id !")) })```
What is regular? regex?
&gt;regex yes, I mean regex
like this `id:=gorouter.GetParam(r,"id")`
Thank you very much for the help. Turns out I was missing to `CFRelease` some things and to `Close()` my opencv `Mat`s. Thank you very much for your help!
[I prefer net/http](https://blog.merovius.de/2017/06/18/how-not-to-use-an-http-router.html). It has API-advantages (in that it is better integrated into the ecosystem as a whole) and the performance of your HTTP router literally does not matter (no, not even at Google scale).
I would add a method to struct, that accepts initialized Writer from encoding/csv and writes there own contents. BTW, your variable names are... ugh. 
Variable names, are exacly like fields names from original xml file.
Mo≈ºesz przet≈Çumaczyƒá na angielski. Mieszanka jƒôzyk√≥w w nazwach zmiennych jest mocno nieczytelna. Szczeg√≥lnie kiedy trzeba powr√≥ciƒá do kodu wiele miesiƒôcy p√≥≈∫niej :) 
How large is "large scale" here? 10 routes, 100, 1'000, 10'000, 100'000, 1'000'000?. Does it make any difference to your project? If not: Why bother?
I wasn't really honest with myself when I wrote that I'm worried about security issues. The tech of WSS is sound, I'm really worried about developing and maintaining 2 separate APIs, as well as WS becoming an obstacle to moving to http2 and the issues associated with load balancing web sockets. &amp;#x200B; These are the only real reasons why I'm considering simpler solutions such as Server Sent Events. &amp;#x200B; For those interested - I've listed some resources about securing websockets that I found useful. [https://www.owasp.org/index.php/Testing\_WebSockets\_(OTG-CLIENT-010)](https://www.owasp.org/index.php/Testing_WebSockets_(OTG-CLIENT-010)) [https://security.stackexchange.com/questions/178692/security-implications-of-allowing-websites-to-open-tcp-sockets](https://security.stackexchange.com/questions/178692/security-implications-of-allowing-websites-to-open-tcp-sockets) [https://blog.securityevaluators.com/websockets-not-bound-by-cors-does-this-mean-2e7819374acc](https://blog.securityevaluators.com/websockets-not-bound-by-cors-does-this-mean-2e7819374acc)
Another day, another HTTP router. 
soo is this better than httprouter or no?
Slices are references, like some other types in Go, say map, channel, function, pointer. It means, they point to some actual object behind the scenes, and thus are ‚Äúfree‚Äù to pass around. The underlying object for Slices is Array. Be careful growing a Slice with append(): the underlying Array may not be large enough to hold new elements, and a new Slice pointing to a new Array can be returned.
This way Go prevents one to remember what‚Äôs the difference between postfix and prefix ++ operators, like in C/C++, and people won‚Äôt shoot themself into the foot.
[http://dayssincelastgohttprouter.com/](http://dayssincelastgohttprouter.com/)
Reset the counter.
**Thank you so much!** I moved of the processing to `scanner.Scan()` and use of Goroutines. 
Im trying about the same thing, so ill give you what i know till now: Btw im working with a raspberry pi 3 model B Be sure to install pi blaster on it Get a small easy pin number sheet on google or something Before you order stuff for it, check on the gobot website if theyre compatible The bot loop cant go faster than about a second (that ive noticed atleast, might also be a problem with just me) Be sure that you know a bit of the basics of electricity, like for a led youll need a transistor and such And i havent gotten the servos to work yet, but i dont know why, if you get any working please tell me aswell
I just looked at the godoc and the tutorials on their site, there arent much guides of it out there
Totally thought this was for the Gopher protocol we used in the early 90s. https://en.m.wikipedia.org/wiki/Gopher_(protocol) 
* Little or no documentation. * No appropriate tests related to the change. * Bad naming (interfaces with the word `Interface` in them etc.) * init functions * package global variables 
&gt; Little or no documentation. Or badly written documentation.
more basic red flags: - not using gofmt - not avoiding increasing indentation levels - not using any linters at all - trying to use OOP design patterns - everything is exported - everything is using its separate goroutines/channels - every singe file is in its own package - having -go in the directory name (my pet peeve, not actually a red flag) 
Just wondering, are you new in Go? Seems like something that someone that visits this subreddit wouldn't say.
I dunno why but my code just cracked up!
X _, _, _, _, _, := func() Please no.
You can try this book - [Distributed computing with Go](https://www.amazon.com/Distributed-Computing-Nikhil-Anurag-Vemuri/dp/1787125386). After a brief intro into testing with Go and other such stuff, it explains how goroutines &amp; channels work under the hood then shows how to use them. And rest of the book is about using these concepts with networking applications etc. 
I think before criticizing or following the IoC highway too much that people should understand why it became so popular. I don't want to write a thesis so I'll make it short: IoC (Dependency Injection) was / is to Java \-as- NPM is to Node.js, Gems are to Ruby, and Dep/Glide are to golang. This is really the crux of it. We didn't have package managers for Java, and the tool chain for managing builds in large Java applications was becoming a nightmare. Enter DI and the Spring framework. This let people concentrate on their domain logic and keep dependencies to useful 3rd party libraries out of their code. At the time, it was an academic ideal that found widespread usage in meeting a common need. In the year 2018 this is all largely automated with package managers. If we ignore package managers and think about narrower use cases for dependency injection (which all orbit around better means to achieve object composition), I think that languages with built-in features likes Rust's trait mechanism and dynamic languages like Ruby (modules) manage the polymorphism demons in a cleaner way that's far easier to maintain. \--jaded opinion of an old developer 
Why are init functions bad according to you?
[removed]
If it's not obvious what the code is trying to do. Go is such a readable language, 99% of the time, if it's not readable, someone messed up. 
&gt;"*Have you considered designing the Pool to add a task via AddTask(func() error) instead of storing a single function for the pool that has to accept interface{}? That way you could run multiple functions in your pool using closures and have type safety."* A&gt; I'm currently working on some similar ideas: give the client the chance to enqueue a job plus a function to process the job. Your idea looks interesting, I'm going to add it to the planning phase. &gt;"*Also, are you sure that your worker and listener loops aren't just spinning and eating cpu when the pool is idle? You seem to use default cases alot in places where there aren't new messages or tasks."* &amp;#x200B; A&gt; That's an area of opportunity: minimize (to the lowest expression) the cpu use when workers are idle. &amp;#x200B; Thank you for you feedback! &amp;#x200B;
By definition, the only thing that \`func init\` can do is mutate global state. Go programs (really all programs) should have as little global state as possible, especially mutable global state, and ideally none. Therefore, any init function is a huge red flag.
I run [diff-cover](https://github.com/Bachmann1234/diff-cover) on all PRs I review (just so I know whether I have to review the tests or ask for more first)
underrated
I come from PHP and Java, which always makes me want to use design patterns. However, i'm afraid i'm horribly tangling and/or opening my code base without those patterns. 
I use init functions for constructors that compute, what's any other option?
Let's cite [the FAQ](https://golang.org/doc/faq#inc_dec): &gt; **Why are ++ and -- statements and not expressions? And why postfix, not prefix?** &gt; &gt; Without pointer arithmetic, the convenience value of pre- and postfix increment operators drops. By removing them from the expression hierarchy altogether, expression syntax is simplified and the messy issues around order of evaluation of `++` and `--` (consider `f(i++)` and `p[i] = q[++i]`) are eliminated as well. The simplification is significant. As for postfix vs. prefix, either would work fine but the postfix version is more traditional; insistence on prefix arose with the STL, a library for a language whose name contains, ironically, a postfix increment. 
This is the "god object" antipattern, in a nutshell. 
You should look at migrating that job to something external and have a queue based system pick jobs to do from something like amazon SQS, RabbitMQ or Kafka etc etc. That way your main api would be sending jobs to the queue service, then your microservice picks jobs from the queue and does them and reports back the results. 
I see these types of questions from a lot of new Go users. It‚Äôs usually because they are having trouble wrapping their heads around pointers, and when and how to use them. Just when they think they‚Äôve wrapped their heads around it, they discover something new about them. I would say that references, like slices, maps, and channels qualify as ‚Äúsomething new‚Äù that adds confusion around pointers, and whether something is passing data or a pointer to data. It‚Äôs because the decision to pass data or pointers is left up to the developer for all types, with the exception of references, where you technically still can pass a pointer to a pointer, but it‚Äôs discouraged and rarely needed. That said, I‚Äôm pretty sure the designers of Go were aware of the possible confusion, but chose references as the best option to handle those data structures. Once you understand what they are doing and why they do it, slices and maps are highly appreciated constructs. They do a lot for you, and do it very efficiently. Others have explained how they work, so I won‚Äôt bother, just adding my two cents. This is something I make a point to teach new Go programmers. 
Looks like a dog sled.
Have you considered FaaS? https://en.m.wikipedia.org/wiki/Function_as_a_service
You could use a Terraform config to define the instances and provisioning steps. When it is time to scale up, just increase a scale variable. ```hcl variable "instance_count" { default = "2" } variable "linode_token" { description = "Linode APIv4 Token (from cloud.linode.com)" } provider "linode" { token = "${vars.linode_token}" } resource "linode_instance" "instances" { count = "${var.instance_count}" // ... see https://www.terraform.io/docs/providers/linode/r/instance.html provisioner "remote-exec" { inline = [ "do stuff", ] } } ``` ``` terraform init terraform apply -var instance_count=4 ``` 
Not following [Effective Go](https://golang.org/doc/effective_go.html), mainly the part that says getters should not have a `Get` prefix. For me, seeing functions like `GetSomething()` is a red flag just because it certificates that who wrote the code haven't read the official guidelines.
Interesting...that used to be the fun part of independent contracting, interact directly with the folks who knew the business logic the best; with F# interactive you can just about write/tweak the GUI with them sitting next to you to get it as close as they want. Great language...have you interacted with .Net Core 2.1 much?
[removed]
Interface return type when a struct (pointer) is enough. The only exception is if it's a factory that really can return different implementations. Ideally, that would be in addition to underlying `New*` functions.
In many cases you can just assign from a function call. It doesn't work well when you have to handle an error value, though. Not all libraries provide `Must*` functions.
And If you want to code something to create more instances, you can use https://github.com/linode/linodego to create the instances automatically as your application needs more nodes. You can simplify the provisioning steps by creating a StackScript. Then supply that StackScriptID and StackScriptData when calling CreateInstance (see https://godoc.org/github.com/linode/linodego#InstanceCreateOptions ). The Linode Terraform provider source and examples in the LinodeGO repo should help: https://github.com/terraform-providers/terraform-provider-linode 
But... why?
I disagree. I think keeping the variable names close to the source names in the original xml document will make it much easier to manage. For example I can‚Äôt read Polish, but I can read XML and Go and so I would still be able to figure out what this code is doing given the raw XML document. If he translates it I would be completely lost.
Hmm... I've been doing flag stuff in init(). Is that wrong? 
Run it 
I made a codeception clone (enhanced and faster) written in Go. So it is doable.
It can make your packages brittle and hard to reuse. Parsing those args should be in thier own function and called else where in you main init. &lt;- my own opinion
oh god. not using gofmt is a definite red flag.
&gt;having -go in the directory name Don't even get me started!!! Why do people do this? It would be one thing if they had multiple implementations in different languages -- and one of them was Go. But, I rarely if ever see that situation. In fact, more often than not, the author has a number of projects in several different languages, but only their Go code has the "-go" suffix on the repo name. So, if you do this... please stop. If someone told you this was proper behavior, they lied. If you think you have a good reason for doing it, you don't; it is wrong. Just stop. *For the love of God won't someone think of the children?!?*
I never said they're bad but I think they should be used sparingly as it is best not to had side effects by merely importing a package. Obviously there are times when init() is useful -- I'm not saying don't ever use it. My philosophy about globals and init() is that there are almost always better ways to approach a problem and they should only be used once every other option has been exhausted.
The closest equivalent is probably the Golang standard library
I used flask a lot and for go I really like echo server https://github.com/labstack/echo 
This doesn‚Äôt make sense to me but an example may be helpful. If the interface defines a function which returns an interface, I don‚Äôt see this as an issue. In fact, it makes mocking in unit tests really easy. And I think the second part of the comment re: factory returning different implementations makes sense. But, avoid OOP. The factory pattern, imho, leads to singletons and I don‚Äôt like unnecessary global state. I know it‚Äôs a common pattern and there are obviously many cases where it‚Äôs an elegant solution, but calling it a factory at all is what bugs me since there are no objects. Personal quirk I guess. 
* An interface defined by a producer instead of consumer. This will almost always bite you later. There's a good reason for the adage "[Accept Interfaces; Return Struct](https://mycodesmells.com/post/accept-interfaces-return-struct-in-go)". * Code with a veritable dearth of pointers (i.e. passing around struct copies all over the place). Learn to love the pointer; pointers are our friends. * Excessive / unnecessary goroutines. Just because concurrency in Go is easy, doesn't mean it's always the right thing to do.
I think the real problem is that there's a function that returns an interface. More often than not, that's a serious code-smell.
Security: Origin policy is the one extra issue to worry about with Websockets compared to HTTP. Gorilla websockets implement same origin policy by default, so there may not be anything extra of the application to do. Load balancing: As far as the load balancer needing to manage a long-lived connection to some backend, Server Sent Events and Websockets are identical. The difference will be in the protocols supported by the load balancer. HTTP2: Websockets run alongside HTTP2 just fine. They are not an obstacle to moving to HTTP2. Two separate APIs: New code is required for publishing events whether you use Server Sent Events or Websockets. Other than that, what are the two separate APIs that you are concerned with? Simplicity: Server Sent Events has the extra complexity of providing a second event delivery mechanism for Microsoft browsers. WebSockets are simple because you can use the same code for all clients.
How about Buffalo.
One more that came to mind: * Premature/unjustified optimization. Performance related changes should be backed up by benchmarks unless they are painfully obvious. I've seen people using `if len(someString) &gt; 0` instead of `if someString != ""` thinking it is faster, for example. * Novel use/abuse of language features -- To go on about `init()` functions, I know someone who came up with a scheme where they define an `init()` function before every other function declaration in a file. Same person uses interfaces to export functions across packages -- so every package must do something like: ``` import ( "some/pack/age" ) var ( myage = age.Interface() ) func main() { myage.Foo() } ``` So they use interfaces to pass functionality across package boundaries. The rationale is they can now "mock" then entire package by providing an alternative implementation of that interface. They obviously don't understand how packages work in Go but this falls under a novel use of a language feature. They're hard to identify because you don't know them until you see them. But if you see something that gives you the same feeling as this, then it is a huge red flag. 
also + not Golang naming convention + ISome instead of Somer. + GetValue()/SetValue() instead of Value()/SetValue() + snake_case, instead of camelCase + very long lines of code 
Session data is probably significantly larger than a JTI value, and JTI blacklists could still be stored in memory even if centralized, to avoid hitting the database on every request.
Not why is it wrong, why would you do this?
It's common for newcomers to Go to get "channel-happy" and overuse goroutines/channels. Specifically, it's tempting to shoehorn in a channel when a mutex/waitgroup/callback would work better. Goroutines+channels are great tools, obviously, but it takes some experience to know when they're truly the right tool for the job.
Depends on what you're doing, but if it is a init function that initializes an object, it is better to have a New function that returns the object initialized and all
You know, to make a joke.
\- OOP design thinking - trying to make everything an object and not understanding that functions can just \*be\* functions on their own \- over-using channels because "cool! channels and goroutines are why we're here, right?" \- factories. This isn't Java. Stop with the factories. \- parsing config files in preference to writing code. Your config file is an untyped, unlinted, uncompiled mess. Just write the code and don't be so afraid of compiling, it takes literally &lt;1s. Do a big switch statement and set a constant. \- `map[string]interface{}` you know there's gonna be all sorts of run-time mayhem sorting that one out. Why isn't it in a struct? \- `import "reflect"` wave buh-bye to compile-time checking of anything. Now you have to test for everything explicitly. &amp;#x200B;
genius at work
yeah, the old "accept interfaces, return structs" gold. I don't do enough of this in my code
Very large interfaces, especially where they sit in the same package as the primary implementation. Often an indicator that having the interface probably isn't providing any value. &amp;#x200B; Will echo what some others have said about difficult to follow code as well. Idiomatic go is, in my view, incredibly easy to follow, so if something isn't clear with a couple of passes reading it, there's likely going to be problems down the road.
&gt;very long lines of code That's interesting. One of the main reasons I picked up Go was simply because Google's internal style guide for Go has no line length limit. For context -- Google has 4 primary, sanctioned languages for production code: C++, Python, Java and Go. The style guides for both C++ and Python limit code to 80 characters per line while Java's limit is (last I heard) 120. I haven't written Java in a long long time and I'm sort of OK w/ 80 chars in Python but the way my brain works, C++ in 80 characters is virtually unintelligible. But, there's no such hard-and-fast rule for Go -- other than, "just be reasonable". Winner winner chicken dinner!! :D
NPM, Gems, Dep/Glide/vgo is all about dependency management, not dependency injection. They do not wire your code at all, they just make sure everyone gets the same libraries and dependencies. Wiring them can be done manually or with dependency injection libraries.
The way php works isn't necessarily bad. It is what it is. People that don't like it have the option to use any other language. I wouldn't call it a broken architecture, mostly because it does work and has repeatedly shown success. I also might not have gotten into programming without such a simplified design pattern. I think it's important to note this is your opinion and this matter is subjective, not objective. 
"It depends" is the only sensible answer. I'm working on a toy interpreter at the moment, and I use `init()` to seed the random number generator. That seems like a valid use to me, but perhaps other people have different views!
Of course sometimes you __want__ to provide side-effects via a mere import. I hacked up a quick library to submit application-metrics to a Grafana instance, and to use it you merely import the library. That means no code-changes in the typical case, and for that you get graphing of goroutines, GC stats, etc , etc. * https://github.com/skx/golang-metrics Might not be the most common use of such a thing, but I have to say that I think it is pretty neat regardless!
&gt; The factory pattern imho, leads to singletons [---] but calling it a factory at all is what bugs me since there are no objects Sure, but the [factory pattern](https://en.wikipedia.org/wiki/Factory_method_pattern) in Go is just a function, usually named `New*` or `From*`. Other languages/environments use classes for the same pattern, and that would have been overkill in Go, even if syntactically possible. (Yepp, people have tried to sneak that past my reviews. They didn't succeed.) A pattern I'm very happy we don't see much in Go is the builder pattern. IMHO, that's a workaround for the lack of keyword and optional arguments in Java. Sadly, there are existing specimen; e.g. the Google AppEngine [`datastore.Query`](https://cloud.google.com/appengine/docs/standard/go/datastore/reference#Query).
What about [net.Dial()](https://godoc.org/net#Dial) ?
These questions about routers are never followed up by their creators. Did you try the standard lib? net/http? templates? what did you find missing? 
The worst I've ever seen. [https://play.golang.org/p/tdTOAKMpdMF](https://play.golang.org/p/tdTOAKMpdMF) Other flags, in the same codebase: 1. Flat file structure. Everything is exported, while everything is in root 2. No error checking, ever. 3. Using http.Get without your own client 4. One global instance of the database, written to everywhere in the application 5. The unit tests use the global database instance, which is initialized to the QA environment 6. Having "Object" in the struct type name, or "List" in the array/slice name. 7. Really really long, verbose variable names, when the scope is 3 lines. 8. Using multiple test frameworks in the same package 9. Having an interface, with "Interface" in the name of it with methods like GetName, GetX, GetY, GetZ, etc. -- sharing data, not actions.
About the premature optimisations: couple of days ago I was mentioned as a reviewer in one PR of our team, my colleague has changed some code and use mutex.Lock() // some actions here mutex.Unlock() instead of initial mutex.Lock() defer mutex.Unlock() // some actions here The reasoning was "it more efficient from the performance perspective". &amp;#x200B; But the code was in the mock-package used in the unittests only.
The only think I have ever missed in the standard router is path arguments captures otherwise it's pretty good.
Maybe because you are calling `c.cipReq(url, attempts-1)` rather than `c.apiReq(url, attempts-1)`? Or maybe that's just a typo while copy and pasting your code to Reddit.
I think that's borderline ok simply because the net package is the ultimate consumer of the returned Connection. But, I think the real reason it's that way is because the net package was written before we truly understood the full ramifications of using interfaces that way and, due to the compatibility covenant, we can't change it now. tl/dr; I wouldn't recommend writing new code that way.
Sorry - it was a typo. Wish that was a solution though haha
If you're working on a big project you'll want to use a prebuilt framework that relies on selenium or appium. This way you can scale out easily with testing services like saucelabs.com and test all OS, browser, and mobile combos. However if this is small or a side project you can follow in what others have done and build your own UI testing suite. 
I had to look up the emoji. &gt; A triangular red flag on a post. Being color blind makes you seem stupid in many circumstances.
contexts are new. And context.Contexts are used in other packages. I guess we disagree to some extent. It‚Äôs a really elegant way of keeping things extensible without rewriting a lot of business logic. For instance I wrote a context implementation that kept a stack trace in the context for every new timeout. When the context timed out, you could inspect the stacks and see which mutation had the lowest timeout and how we got there. And I could chain this implementation with context.Contexts at runtime if it wasn‚Äôt needed. Pretty elegant. 
I like chi. 
I'm not colorblind, the flag is just yellow on my phone. It is very outdated though 
It‚Äôs not routing alone that we‚Äôre considering. The standard library doesn‚Äôt support variables in routes which is quite odd. I use Chi instead. But the other things we need are: Mongo-dB connection as well as MySQL and Elasticsearch Controller logic CORS Authentication/Session management Caching Middleware
Is it too bulky? Are there a lot of third party dependencies?
Cool! I‚Äôll look into it
My prometheus counters are always global and I register my prometheus counters in my init functions. I don't know why not using init to do this is better.
I'm not sure if you're saying that my suggestion is the anti-pattern, which I feel it's not, or the DI concept is the anti-pattern. Please clarify. 
Yet, you keep the hidden secrets of your knowledge all to your self. Lovely community spirit.
That's only one part of the dependency injection paradigm. The book-keeping regarding the dependencies neccessary for an instantiation is the other part - the important one - which you haven't touched upon. Please share if you know of an idiomatic way of doing that.
If those return values are legitimately optional you're free to write it like that. Often they're important values that people just ignore to get it done, thus introducing potential bugs and crashes.
It seems to be working for me. I reconstructed your code here [1]. Please provide a copy of the entire code that you using. [1] https://cixtor.com/pastio/d3a5nk
I would even handle that in code review. Build it into CI and check it automatically, rejecting on the spot if it fails.
Fair enough. I think the main problem nowadays is a lot of people pressing ctrl-s out of muscle memory for saving a file, and accidentally suspending the terminal. I guess having a GUI element that suggests a ctrl-q to resume would solve the problem and allow suspension to exist as a feature. I'll probably add it back in to aminal with that extra visual help.
Return a struct.
try beego.
ya -- i agree. what do you think about companies or groups who don't insist on using `go fmt`? i've worked somewhere like that and realized that specifically not adopting `go fmt` is clear bellwether for the health of the team and codebase.
There are patterns in go though, just not everything has to be one. Personally I think design patterns are now so over used that they make things harder to maintain through over abstraction. They should be applied to solve a problem, what I keep seeing is people using a pattern because it's the done thing to do or just to use it.
I would argue for whichever is more readable, since otherwise you are micro-optimizing. Channels can communicate and synchronize, mutexes and waitgroups can only synchronize (where synchronize is communicating a boolean state). Both are effective within those scopes, so from my perspective either are fine so long as the code isn't a mess. I would look for potential data races in code that used mutexes over channels and had shared pointers, etc.
Huh, I never considered that -- since I'm one of those grumpy old men who only uses a GUI so I can run more terminals üòÄ n.b. My window manager is i3 
&gt; What are some standard practices of writing a http server in go? https://golang.org/pkg/net/http/#ListenAndServe &gt; How should I proceed with tests and define project layout? https://golang.org/doc/code.html#Workspaces &gt; Is there any package management tool for go like NPM for Node.js? https://github.com/golang/go/wiki/Modules#quick-start-example
&gt; not Golang naming convention Hey, just so you know, the programming language's name is just "Go," not "Golang." For more information on this, see the FAQ entry here: https://tip.golang.org/doc/faq#go_or_golang Cheers!
&gt; - factories. This isn't Java. Stop with the factories. Are you talking about `New() *MyStruct`? What if I have to have some kind of initialization there? For example making sure that internal maps are initialized?
I‚Äôd go with kubernetes. You can also use it to host you APIs. Easiest way to get started by far is Google Kubernetes Engine. There are layers on top to give you lambda functions but a pool of workers (aka kubernetes job) plus a queue, e.g. rabbitmq which you can also deploy inside kubernetes cluster would make it easy to scale up and down as necessary. (Or use Google Pub/Sub for more robust queue)
I've just released a dependency injection framework for Go: [https://github.com/BlueOwlOpenSource/nject](https://github.com/BlueOwlOpenSource/nject) along with a companion specialized framework for http handlers. Among other things, nject allows for indirect variable passing which often removes the need to use context. &amp;#x200B;
When discussing concurrent code, it's sometimes helpful to remember that a valid concurrent algorithm doesn't require parallelism -- it only enables it. Consider how this code operates if you specify a maximum of 1 concurrent request. You'll only have one worker, but because each worker operates until "reqChan" is depleted, even a single worker is adequate to (eventually) service all requests. Channels represent a kind of queue by which work can be distributed between concurrent processes. They're optimized for ease of concurrent access, with a guarantee that each pull from a channel will be issued to one and only one goroutine. Because of that guarantee, the above code is permitted to let 2 or 3 or 5 or 500 goroutines all pull values from the channel at once, confident that you won't be duplicating work or skipping requests. When the channel has run out of requests, the range loop on each worker ends and the goroutine returns. Once all goroutines have finished, the program reports its performance and terminates.
&gt; What part of it is limiting it to 500 HTTP actions at a time? flag.IntVar(&amp;max, "concurrent", 200, "Maximum concurrent requests") &gt; how does it do the next 500 or even the whole 1 million eventually? for req := range reqChan {‚Ä¶} When `dispatcher()` is called, it goes from 0-to-N where `N` is the value passed via the command line argument `reqs`. It sends all the requests to an unbuffered channel `reqChan` where they wait to be executed by `worker()` which iterates over all the items in `reqChan` which is also another unbuffered channel. When `consumer()` runs, it iterates the same number of times as `reqs`, in your example, 1,000,000 times and consumes the HTTP responses from `respChan` as they get executed by `worker()`. &gt; And is it operating in chunks of 500, waiting until that chunk of 500 is finished then starting a new 500, OR is it just always chugging along adding 1 more once it hits 499, etc. Both, kind of‚Ä¶ The program executes `N` HTTP requests in concurrent mode, where `N` is the value passed via a command line argument called "concurrent". When the pool is full the process locks and waits for at least one of the responses to be consumed before adding more. For example, if 500 are being processed, then 5 are released, 5 more will be executed. If only 2 are released, then 2 more will be executed. If 300 are released, then 300 more will be executed.
### What part of it is limiting it to 500 HTTP actions at a time? flag.IntVar(&amp;max, "concurrent", 200, "Maximum concurrent requests") ### how does it do the next 500 or even the whole 1 million eventually? for req := range reqChan {‚Ä¶} When `dispatcher()` is called, it goes from 0-to-N where `N` is the value passed via the command line argument `reqs`. It sends all the requests to an unbuffered channel `reqChan` where they wait to be executed by `worker()` which iterates over all the items in `reqChan` which is also another unbuffered channel. When `consumer()` runs, it iterates the same number of times as `reqs`, in your example, 1,000,000 times and consumes the HTTP responses from `respChan` as they get executed by `worker()`. ### And is it operating in chunks of 500, waiting until that chunk of 500 is finished then starting a new 500, OR is it just always chugging along adding 1 more once it hits 499, etc. Both, kind of‚Ä¶ The program executes `N` HTTP requests in concurrent mode, where `N` is the value passed via a command line argument called "concurrent". When the pool is full the process locks and waits for at least one of the responses to be consumed before adding more. For example, if 500 are being processed, then 5 are released, 5 more will be executed. If only 2 are released, then 2 more will be executed. If 300 are released, then 300 more will be executed.
Thank you very much this really cleared it up for me along with the other response this subreddit is great
Oops yes 200. I understand now that the workerPool is creating all the goroutines that independently chew down the created stack
I understand now! I initially thought that the workerPool was like a going task by task, but it's creating the goroutines that do the tasks!
I didn't even know you could do that.
I had an employer who forced me to do this with no reason. I complied because I didn't see any harm. I also did this for the same reason you mentioned; I was porting code from c++ and they happened to be in the same directory. 
Relatively new to Go (less than a year) and my threads are all mixed in so this could have been any subreddit when I saw it. Maybe nobody likes to smile in here. :shrug
Hmm, didn't think about the "build system as a service" component. There's also the cost aspect as GAE is definitely cheaper than GCF if you're just counting raw ram/cpu. I'm crossing my fingers that when they launch "Google istio engine" or whatever it is they're gonna call it, we won't get charged for the master nodes just like in GKE. 
The only time it has been a good practice (for my team) is when we are rewriting a program or service from ruby/python to Go. Having a repo called ‚Äúldap_extractor‚Äù right next to ‚Äúgo-ldap_extractor‚Äù is helpful since we don‚Äôt want to mix those codebases. Additionally it groups all the ‚Äúgo-*‚Äù repos together into one project (12 Go repos out of ~100 repos in the project) so when $external_audit_team does their regulatory auditing, they can pull those repos out for automated testing. If it was greenfield, we wouldn‚Äôt be doing that at all. 
Mush, mf'er (It's a good name)
Yeah, even 3 args returned starts feeling a little full sometimes
Nice! I had no idea this was available.
Go is not usually what I'd call readable. I have had the hardest time trying to understand the "simplest" things in Go. Three years in and I still couldn't tell you what an interface does. At all. I know more about the secret lemming ruler of Neptune than I do about interfaces in Go.
* Unnecessary abstractions. * Using channels to exchange data instead of for signaling * Allocating memory when not necessary (e.g. `s := make([]string, 0)` and then intentionally never appending to it * Not using `gofmt -s -w` * Not organizing imports correctly * Packages with only one file * Putting tests in their own package * The presence of a `util` package or some analog of `util` * Bloated interfaces * Absurdly long variable names * A const for every string * The existence of a `Config` struct 
&gt;What are not the goals of **go-mysql-server**: Kudos for including this very important part of a README.
People do this with Python and Rust too; `py` or `rs` in name. Really annoying imo.
I write it in main, or in tests. It isn't that complicated. Wire does it for you, but I find that it's not a burden, and makes the main of a Go binary a very useful source of the true implementations used in a binary, whereas in Java it's spread out and I often struggle to determine which actual dependency is used.
How do you consume the logs? Are they sent to a centralized service, or do devs ssh into the box and grep/tail them manually? If you send your logs to a centralized service, the service usually has a definition of preferred structure that's easier for it to digest/index, and you should go with that.
An interface is a hole that will accept any object as long as it's the right shape.
mmap isn't harmful. It, like all syscalls, is just bad if used incorrectly.
please watch the talk. it talks about exactly what the Go team wants to avoid. python 2-&gt;3 transition is an example of something they don't want to do. 
mmap, sbrk and brk are all used by the underlying heap allocators so why call them directly? I've never used them directly in C let alone go. Are there any legitimate reasons to? Besides incredibly low level programming.
Especially errors
Haha. Red flag. Very funny. Literal answer to OP question. 
The only reason given is "mmap of large pieces of data will cause IO, and the Go runtime can't detect this so will stall the entire thread." ... this is instead of just the goroutine with an io.Reader. This is a pretty weak argument considering the things you have to be aware of to use mmap properly (Eg. ftruncate() in another program can crash yours).
Typically you will specify a variable as a specific type. Let‚Äôs pretend it‚Äôs a peking duck type. You and the type system know what a peking duck can do. But only peking ducks are allowed. Mallard ducks are forbidden. What if you want anything that can quack? You create a quacker interface and use that as the type instead of peking duck. Anything that has the quack method is now allowed. 
Interface usually requires explaining, but it's straightened out normally in the first month or 2 of go. We present go programs, with interfaces, in interviews and ask candidates to walk us through the code whether they know go or not. I've yet to have a candidate fail 
 wg := &amp;sync.WaitGroup{} for _, c := range clients { wg.Add(1) go func(c *client.Clients) { defer wg.Done() // update client entry in database... }(c) }
&gt;Using channels to exchange data instead of for signaling Effective Go states that this is a great use of channels for non-blocking thread-safe sharing of data between routines. Could you ... why you think this is a flag?
Using channels to exchange data instead of for signaling, Putting tests in their own package, The existence of a Config struct why?
Also, if you're not doing centralized logging, do it.
That last one, was what the person who pair programmed with me did while learning go. I hated it at first as it just made understanding anything for me far more complex. But now I'm used to it, and don't mind it. The rationale of mock packages is the exact reason they used, although I've never seen any value in making a ton of fake code mocking something. It's testing your mock code. 
I suddenly realized that what the stream provided in Java as you described can be easily implemented by using channels in Go. They are already supported with Go built-in generic. You can read the "Data Flow Manipulations" section in the [Channel Use Cases](https://go101.org/article/channel-use-cases.html) article for details.
Only if the values cohere. No point chucking disparate bits of data into a struct, you‚Äôd just be masking the problem.
Passing it in as a dependency to a package that needs it, as an interface. 
I hope not. Those aren't factories, they're constructors. If you whip up a separate object that you initialize to create another object, THEN it's a factory. That's a big gun you usually don't need, but it's appropriate if you have very complicated init. I'd say a constructor is usually a code smell in Go because it's not idiomatic, and because it probably means what you're trying to initialize needs to be refactored into smaller bits. Still, they are probably not wrong 100% of the time. As always, the only advice that can accurately applied to all circumstances is "do what is contextually appropriate".
Horizontal scrolling is the boundary.I'd prefer 80 character to support users with low display resolution. Especially for open source projects. Yep, no such rule, since Google's developers are using wide-high-resolution displays. They just never seen the problem XD Cheers.
I'm curious about this myself. I've pre-initialized a buffered chan of db handles before, and wrapped that in an object, but that was for light work. Annoyingly, you had to remember to defer(dbm.Recycle(dbh)) to give back the handle to the db manager. Upside was being relatively simple, threadsafe. The manager could also spawn more handles up to a limit if the chan queue was empty.
It‚Äôs a potential red flag because your essentially introducing multiple opaque entry points into the program. How do I know if the package I imported is using `init` and fucking up my code silently? Without looking through the source, I can‚Äôt know that. Sometimes packages are ‚Äúmeta‚Äù packages that actually require you to import another package that supplies a concrete implementation through an `init` function at runtime. This can bite you if you haven‚Äôt imported the correct driver packages, or you imported two mutually exclusive driver packages. It can be useful, but definitely something to watch out for, especially if the `init` is large. 
Assigning a value from a function call to a global variable is essentially just ‚Äúshorthand‚Äù for putting that code inside the init function. It‚Äôs functionally identical and comes with the same caveats, imo. 
Use parameterized queries. https://rosettacode.org/wiki/Parametrized_SQL_statement#Go
Lambda can be annoying sometimes. Have you checked the CloudWatch logs?
Will it be safe even for WHERE statements? Example: SELECT email FROM people WHERE country=? (Like MX, UK or US)
This is what we do. I'm the main architect for a SaaS company that runs Golang microservices via Lambda and API Gateway. We send logs to cloud watch with keys as defined in the domain diagram we use as a group to ensure consistency. We output to a third party processor for their format but keep our specific one stored in cloud watch logs. These get offloaded periodically to s3 for sourcing from our 3rd party service for log analysis. 
Channels‚Äô primary use is for signaling. Using a channel to shuttle data back and forth between goroutines indicates a design issue to me. Of course you are going to pass _some_ data, but it should supplement the signaling aspect, and not overshadow it.
I like the polling method better. Then you get to control the update rate.
Yes. The point of parameterized queries is they always do quoting correctly. As to a failure using them, with the query you've given, perhaps a user could not submit a country in a url and if you didn't check if the value received was found, receiving a `country, err := UrlToCountryFunction()` and not checking the `err`, you'd just get a default string value for country, so `""`, and then return a list of people where the country isn't set. If you weren't using them and were just using string concatenation, like `"select email from people where country=" + UrlToCountryFunction()` the user can submit `/?cc=""; delete * from people ; --` and your database is trashed. If they submit that while you're using the parameterized code, you'll just end up with `select email from people where country = """""; delete * from people; --" `, which will yield only those users currently living in an attempted SQL injection. 
&gt;Allocating memory when not necessary (e.g. s := make(\[\]string, 0) and then intentionally never appending to it I find myself doing this at times because I'm marshaling structs with \[\]string in them, and I'd prefer the output JSON to have `[]` rather than `null`. Just one exception to the above rule that I've encountered (and sometimes the 'omitempty' field tag is a better alternative).
I'd rather have no docs than confusing/misleading docs.
I feel like using channels for this is a bit more idiomatic 
I am. Reflection has its uses, but it's a sledgehammer which often gets used to swat flies. It should be avoided whenever possible because its complexity cost is very high.
having a constructor function is fine. Creating an entire infrastructure around it gets a bit weird. I've seen singleton factory structs that hold state and create child structs using that state. I guess this is really an indicator that the author is using OOP thinking, or has been trained in Enterprise System Architecture that really doesn't apply for Go.
This. Especially in the style people are forced to do Java/C# and result in // Get the Foo // Param: // - bar the Bar func GetFoo(bar Bar) WTF?!?
How does one do this for a multi-value insert? Like if I need to add objects from a slice in one query.
I do not agree. For example, concurrent pipelines sending data from stage to stage with channels is entirely normal. In fact, I more commonly see design problems with channels being used for signaling when things like `WaitGroup`s would work just fine.
good bot
Are you sure about that? Because I am 99.99999% sure that mdempsky is not a bot. --- ^(I am a neural network being trained to detect spammers | Summon me with !isbot &lt;username&gt; |) ^(/r/spambotdetector |) [^(Optout)](https://www.reddit.com/message/compose?to=whynotcollegeboard&amp;subject=!optout&amp;message=!optout) ^(|) [^(Original Github)](https://github.com/SM-Wistful/BotDetection-Algorithm)
Great question. It seems simple on its face, but there's a lot of nuance lurking. &amp;#x200B; The polling option allows you to check as frequently or infrequently as you like. It makes it trivial, for example, to re-render a progress bar once per second. The downside is that the abstraction is slightly leaky: there's an implicit contract regarding how frequently you ought to poll. If \`Progress()\` is actually expensive to compute for some reason, you don't want to call it too often; but if you don't call it often enough, it hurts UX. In other words, your polls won't "line up" with actual changes in progress. &amp;#x200B; The callback option maps well to \`io.Reader\` and \`io.Writer\` interfaces. That is, it would allow you to easily create a wrapper type that calls the callback after each \`Read\` or \`Write\`, such that reading from a \`net.Conn\` or writing to an \`\*os.File\` (for example) simultaneously updates a progress bar. The downside is that, unlike the polling option, you can't control exactly when you update. It can also complicate things if you want to do other work during the download; that is, you can't \`select\` across "either progress has been made on the download, or progress has been made elsewhere." &amp;#x200B; The channel option allows for \`select\`, and you can get a nice \`for\` loop API thanks to \`range\`, but it introduces a much bigger problem: buffering. If you're sending down the channel faster than the caller is reading from it, what's the right behavior? If you block, the download pauses artificially, perhaps indefinitely if the caller is doing something really stupid. If you drop updates on the floor, the caller might miss an update that they're checking for (like "100%"). Buffering the channel is a band-aid solution; it doesn't address the fundamental problem. So again, there's an implicit contract regarding the frequency of updates. (Note that the callback option has similar semantics to blocking: the download speed can be affected by how long the callback takes.) &amp;#x200B; \--- &amp;#x200B; For a simple progress bar like the one you described, I'd lean towards polling. Polling gives you precise control over when you update, and in practice, the \`Progress()\` call is going to be fast enough that you won't have to worry about polling too frequently. For one of my own projects, I went with the channel option, solely because I knew I wanted to send multiple types of update (i.e. not just "Progress", but additional events as well). But if you're solely dealing with a number of bytes transferred, you don't need anything fancy. Stick with polling.
It is a large project. Basically the automation testing suite for the whole company. We are looking at our choices. Java seems like the obvious choice. I wanted to propose Go but it seems like there isn't much here. Are you aware of any prebuilt framework that is good with mobile testing? Any good resources or books? Thanks!
Does it support mobile testing? Are there any good resources or books I could read on the subject?
when you try to rip on people for not knowing naming convention, but don't know the naming convention for the language itself (I know, it's a common misconception... Just thought it was funny :P)
I have my text editor places a line at the 100 character mark. It's very convenient
No, those are constructors. Constructors are functions that build an object. Factories are objects that build an object. Definitely a bad practice in Go.
Thanks for the helpful comment. The problem with polling, at least in the way it's currently written, is it doesn't alert the caller to when the download is done. So you'd need to start a goroutine to poll, wait on the finish signal in the main thread, and then tell that routine to stop polling when it's done. Or I could add an IsDone() method so you poll in a loop like for !status.IsDone() { fmt.Println(status.Progress()) time.Sleep(x) } //check error But that again can give you a delay between when it is done and when you poll to find out it's done. I think I will go for the channel approach, since it looks like in implementing an interface for the polling approach one would have to use channels anyway. 
If you know you'll only send 100 updates down the channel, just make the channel with a buffer size of 100, that'd solve your buffering issue. There would be no case when the downloader is waiting to send data to the channel.
This is an anti pattern. models (the name) is also an anti pattern. Pass your dependencies explicitly to constructors.
I love chi üòÅ
Yes yes I know, I was making a joke, should've put air quotes around "naming convention"
\&gt; how big are the changes coming in go 2? Don't worry about it. It may be years before it gets serious adoption. And the changes will be small compared to learning how Go 1.0 works. (i.e. what is a Goroutine, how everything is pass by value, etc.)
For Web frontends, chromedp might be helpful: [chromedp/chromedp: A faster, simpler way to drive browsers supporting the Chrome DevTools Protocol.](https://github.com/chromedp/chromedp) 
\&gt; which will yield only those users currently living in an attempted SQL injection. Oh hey, I know a guy who [lives there](https://www.xkcd.com/327/). But seriously, how cool would that be for a country to change it's name to a SQL injection attack? Ok, maybe it won't happen. But I'm pretty sure someone soon will rename their country to have Emoji.
This should teach me reading beyond the title before posting any "advice"! :-)
I recommend build your web framework by yourself . BTW recommend a GO Router ,it is simple and fast ,No external dependencies Ôºåas fast as httprouter and support RegExÔºåit is easy to build your web framework: [https://github.com/xujiajun/gorouter](https://github.com/xujiajun/gorouter) 
Currently we are in a transition, we have a docker swarm setup where we are able to tail individual container logs through a web interface, we are in the process of moving to a central log aggregator in combination with fluentd
It doe not support mobile testing. But, you don't have to invent a new tool, you good also be using an allready existing one.
&gt; Maybe nobody likes to smile in here I'd rather guess the folks here know the Go Gopher/Gopher protocol name clash since a long time already.
That sounds like a good way of doing it, does every developer use the domain diagram, how do you make sure that everyone is following the same principle 
Hacktoberfest compatible and medium difficulty! Did 4-5 PRs of command implementations! Cheers 
can't say I know enough about difference btw using RPC and Go binding. Do you think there be performance differences?
OK, you might be right, but without throwing in the reasoning behind your statement, it's not convincing me.
Only if you promise to give me a code review. :) https://github.com/sapcc/hermes 
Using `ioutil.ReadAll` when everything can be done with `io.Reader`s.
Thank you for clarifying. Okay -- I'm looking at the code and it is what I feared. It is okay to mock things but it is not okay to do it the way you are. There are also several well known anti patterns going on there (\`util.LogDebug()\` for example.) You don't use interfaces to describe the functionality of entire packages. I'm having a hard time articulating my reasoning right now but I promise to come back once I've rested and I'll give it a shot.
Well, rpc adds some overhead So there is probably some difference. But i would say a pure golang Implementation has some benefits. 1. You are Not using cgo for the bindings. Cgo is a bandaid and should only be used if necessary. (it is an awesome bandaid, it works very Well but still) 2. There is no buildtime dependency on libvirt to be installed. You can just build your go project without worrying about weird c libraries 
I don't 100% agree on this: "Most info logs are better served by adding metrics instrumentation." I think info logs can be very helpful, to spot what is going on in the service in case of a bug. You mention "We add all the common labels in our logging wrapper from context", do you use the "context" package for this ? Can you provide a code example showing how you did this
\&gt; We believe that coupling exceptions to a control structure, as in the try-catch-finally idiom, results in convoluted code. It also tends to encourage programmers to label too many ordinary errors, such as failing to open a file, as exceptional. &amp;#x200B; [Source](https://golang.org/doc/faq#exceptions)
Yes, I have gone through that page in the page while learning go. I already heavily use channels in my go apps/tools. However, the advantage of a streams library is that all this is taken care for you and you don't need to deal with it. You can just `stream().parallel().map().buffer()....collect()' and you don't have to deal with channels, setup, data-transfer, etc. Once you have the core streams in the standard library, you can also have other libraries that build on streams like https://github.com/amaembo/streamex/blob/master/CHEATSHEET.md Creating a comprehensive streams library in golang will take around 10K lines of code, writing the tests for it will be another 20K lines of code and until we get generics one will either need to live without type safety or choose to restrict the set of types for the same. I am not dissing on golang. Go has terrific advantages which are very, very strong: value types, a low-latency GC, compiles to a lean binary and and a very-good standard library, (http server+client included) which prevents folks from needing to make utility and third-party libraries for the smallest of things. I am fairly confident that after generics makes it in Go 2, folks will make stream libraries in golang. Streams as a paradigm are too useful when processing data pipelines and collections.
Do you know of another public package that uses this technique? I'd like to write a detailed critique but I don't want to use your code.
I do not, again, I've just picked up programming in the last year, and am still struggling to get to a place of competency. This pattern made it much more difficult for me to learn, but I haven't spent the time to undo it.
I think the motivation was that people used exceptions for situations that weren't actually exceptional, producing code that was more confusing than it had to be. Personally, I don't think Go fixed this problem; you can pretty much emulate try/catch in Go if that's the model that you want. Likewise, you could always return more than one value from functions in Java or C#, you just needed to create a class to encapsulate the values. I did that all the time when it produced more readable code. &amp;#x200B;
Oh -- I totally get it. You're not the only one in this situation. Apparently it has happened enough that perhaps an article explaining why *not* to do it is in order. You can -- and I'd say probably should -- avoid it if you have to add new functionality.
I want to, but it then becomes more complex to follow different patterns. Ideally, it just gets removed and simplified into a straightforward setup, including not using so many different files just to hold the api, but I need to focus on delivering features, and improving. I need to add a new endpoint tomorrow, and not using the pattern just for that, even if it's not useful, seems more complex without much value. There's something to be said for the consistency of it.
I think the distinction between byte and rune is very clever in go. Encoding and multi byte values can be enraging in other languages and they are also the source of weird and hard to find/fix bugs. 
&gt; // findPhishingURLs finds all known phising URLs in an HTML string. &gt; Another one: &gt; // activityDeadline is the duration that an http request to any activity // endpoint must complete within One of the go linters I use complains if the comment doesn't start with the field name. eg: ``` // An Example, or Example is required to start this comment type Example struct { // A Field, or Field is required to start this comment Field string } ```
I am completely guilty of this, I will keep it in mind for tomorrow. Thanks.
There are a few red flags in this code base. The `util` package the does logging is a big one. Who ever passed this code down to you left you with a lot of opportunities to improve upon it.
&gt; It‚Äôs functionally identical Yes, of course. It's just a matter of code structure. When I learned you can actually have multiple `init` functions in a module, the distinction became even less relevant (because you can always co-locate declaration and assignment). GP asked what the option was, though. And, syntactically, assignment is a wdifferent option. &gt; and comes with the same caveats, imo Which ones do you see?
It depends on the project, for huge projects/codebases you shouldn't worry about the actual implementation, and having everything in one place can become unmaintainable and messy
You should not use panic/recover as you would throw/catch; only panic for unexpected, unrecoverable failure. Inline error handlers are on the Go2 drawing board, see [https://github.com/golang/go/wiki/Go2ErrorHandlingFeedback](https://github.com/golang/go/wiki/Go2ErrorHandlingFeedback) and also [Requirements to Consider for Go2 Error Handling](https://gist.github.com/networkimprov/961c9caa2631ad3b95413f7d44a2c98a)
Why can't we have compile-time traces in Go? then we could have 'free' traces attached to the errors.
Microscopes are bad tools for hammering
&gt; GP asked what the option was, though. And, syntactically, assignment is a different option. Fair enough. I just got caught up on the fact that it's semantically the same. The (semantically) different option would be to tie the global value to an object and init via a constructor function. This is generally preferable, especially in library packages since it allows the "importer" to handle the lifecycle rather than the library dictating it. The exception being when you have "constant-like" values, such as a regex, which you technically need to compile at runtime, but it has no "lifetime" and no "owner" in any logical sense. A counter example would be storing a database handle as a global variable - an object which does have a lifecycle and shouldn't be tightly coupled to the global state. &gt; Which ones do you see? The same caveats that come with global state as a general matter including opaque side effects when the package is imported, hard to test and tightly coupled code and detraction from good package structure, proper types and APIs. 
This packages seems to be too complicated IMHO. It doesn't fit with the Go idiom to solve problems with simple solutions.
How would those actually be "free"? You don't know at compile-time which function will call functions in which you generate errors.
There are more than one Go package for this purpose. Some of them are minimalistic, some less so. You're right, this one has quite a lot of features, many of them may seldom be used. The reason why we're happy with errorx is simple: it's good for all the error-related issues we used to have and there is no need to invent different solutions in different parts of a codebase. Then again, the value of this package is not only that it can be used, but also that it is an example of how errors may be treated. 
"considered harmful" headline aside, this is a good article :) It seems mean to downvote it like this - I, at least, learned something new, I have not considered this effect before.
So (kinda) would you if you were to implement "ticks" type TickingProgress struct { tickRate int lastReport time.Time onProgress chan int64 done bool } func NewProgress(tickRate int) IProgress { return &amp;TickingProgress{tickRate} } func (p *TickingProgress) report(progress int64) { if p.done { return } if time.Now() &gt; p.lastReport.Add(p.tickRate * time.Millisecond) { p.onProgress &lt;- progress p.lastReport = time.Now() } } func (p *TickingProgress) done(progress int64) { if p.done { return } p.done = true p.onProgress &lt;- progress close(p.onProgress) } &amp;#x200B;
If you are returning disparate bits of data from a function, you have bigger problems :)
&gt; ... this is instead of just the goroutine with an io.Reader. A goroutine with `io.Reader` doesn't block an OS thread from GOMAXPROCS pool (P) - it either runs on a separate OS thread (M) or blocks and yields on non-blocking syscall (epoll), so other ready goroutines may be executed on all the GOMAXPROCS threads without CPU under-utilization.
Calling it function arguments is actually Dependency Injection. There is nothing wrong with calling it that IMHO. &amp;#x200B; The problem is that **DI frameworks** abused the term and for most people DI = Dependency Injection container.
The issue is that mmap is harder to use correctly in Go programs comparing to syscalls. For example, [mmap(MAP_LOCKED)](http://man7.org/linux/man-pages/man2/mmap.2.html) may be used in Go programs in order to avoid hard page faults. But even this approach requires extra care: &gt; This implementation will try to populate (prefault) the whole range but the mmap() call doesn't fail with ENOMEM if this fails. Therefore major faults might happen later on. So the semantic is not as strong as mlock(2). One should use mmap() plus mlock(2) when major faults are not acceptable after the initialization of the mapping
Basics of electronics... yes! It matters a lot. 
Nice explanation! Small remark: &gt; The alternative would be to use ioutil.ReadAll or the like and read the whole file into memory, but that actually requires the data to fit in RAM (or having sufficient swap), so isn't generally possible. Swap is basically a mmap'ed file containing the memory which isn't backed by other files. So swap may result to the same stalls in Go programs as mmap'ed files cause.
Serialization is the only exception to this IMO. There are other ways around it, but they‚Äôre ugly.
I won't use "considered harmful" wording next time in the headline :)
I'll probably just use a non-blocking send. Presumably some update could be missed there but the real thing you're looking for is a channel close and that won't be missed. 
He sums it up perfectly. https://youtu.be/1B71SL6Y0kA
[https://dave.cheney.net/tag/error-handling](https://dave.cheney.net/tag/error-handling) [https://godoc.org/github.com/pkg/errors](https://godoc.org/github.com/pkg/errors) Don't just check errors, handle them gracefully.
Exactly! If you're looking for other existing error-related packages, here's a nice collection in relation to Go 2 draft designs: https://go.googlesource.com/proposal/+/master/design/go2draft-error-values-overview.md#other-go-designs
Unfortunately, it is impossible to create library that will handle them gracefully for you. And this library doesn't even try to.
Because Rob Pike said so.
Try-and-catch-on-problems was nice in the 80's and 90's: An error was something like "floppy full" or "floppy write protected" or "no floppy in drive". Try some floppy operation and let the toplevel event loop f√ºr the user interface catch it, display a modal dialog and wait for the user to switch floppies. Arbitrary errors happening at various code places but all fixed/handled in one place. Try-Catch is _perfect_ here: N code-sites which may go wrong, all handled by 1 catch site. Contrast this with what can go wrong in a system today and how these errors need to be handled. It is no longer a generic modal alert box and a user plugging in his floppy drive, it is rolling back a database transaction here, writing a log message, retrying if it was just a short network glicht, canceling other services (where cancelation itself may fail), looking up an alternative service and invoking this one, and much more. In such a situation it is no longer N-try-sites handled by 1-catch-site, it is more N times a try-catch-finaly-block. There you go: This is error handling like in Go: Each call may fail, each needs different action or cleanup and for this a if-else is fine. I doub't there is a lot of fancy theory behind it: If you really want to write robust code you have to handle _lots_ of errors and most of them differently. So you write the same error handling logic with try-catch-finaly and if err!=nil anyway. With if err != nil being clearer and less error prone.
So there's actually a bunch of different needs here: \- getting a Progress value at any point during the download to represent how far along the download is \- calculating a new Progress value to update the Progress value (not the same as the above, which involves no calculation) \- indicating that the download has finished successfully \- indicating that the download has finished unsuccessfully I'd be really tempted to bundle them all into one call: `func Progress()(progress int64, done bool, err error)` you can poll that to your heart's content (and the implementation can cache the return values until they're updated). You could add a parameter to force a progress calculation, which could block until something changed. I wouldn't use a channel for this, because it would get way too easy to block either end
&gt; I think the motivation was that people used exceptions for situations that weren't actually exceptional, producing code that was more confusing than it had to be. This is part of it; the throw-catch pattern also produces very non-obvious execution paths in a lot of cases, which can makes code harder to read and debug.
The performance differences should be very small.
I love it. I can imagine a style guide saying "avoid dogsledding". 
I understand that is what the docs say. I have yet to understand how to use them. Or, even better, why.
So, I've been trying to teach myself Go for several years now, and still have no understanding of them. Do you have a recommended write up you could pass along?
Here's a recent example that I had to deal with: var routes map[string]map[string]string json.Unmarshal(configFileData, &amp;routes) You can sort of see what they're going for... they want a map of maps indexed by a string for accessing config variables. It was clear from looking at their code that they were expecting Go to work like an interpreted language where you can just throw everything into hash maps. I flagged this and said "Go has a wonderful data typing system. Please refactor your code to structure your config data and get rid of that nested hash map."
I came in here to say, who the fuck writes functions to return 6 disparate variables? I feel like I've never seen a function return more than three things anywhere in the Go standard library. I don't think there's an excuse for this sort of thing. If you see a library like this, be highly suspect that it's not well written. If you *write* code like this, please try to restructure your solution so you aren't doing this. I genuinely can't think of a good reason to ever do this.
Panics are not analogous to exceptions. Errors are.
You don't always need an entire stack trace, just the error message, the line number and the function name. These errors can be embedded inside each other for a very cheap trace. Something like this, the compiler can place the line number and file inside the trace call and these can be embeded within other errors. ``` 1 func ProcessFile(file string) error { 2 f, err := os.Open(file) 3 if err != nil { 4 return trace("Failed to open "+file) 5 } 4 } 5 6 func ProcessFiles(files []string) error { 7 for _, file := range files { 8 if err := ProcessFile(file); err != nil { 9 return trace("Failed to process files").embed(err) 10 } 11 } 12 } 13 14 func main() { 15 err := ProcessFiles([]string{"file1.txt", "file2.txt"}) 16 if err != nil { 17 fmt.Println(err) //main.go:9 ProcessFiles Failed to process files while running 18 // main.go:4 ProcessFile Failed to open file1.txt 19 } 20 } ``` A stack trace has too much overhead so these 'free' traces would be more than good enough.
Some repos do a good job with this, but including goals, non-goals, AND use cases is fantastic. I really appreciated it.
True, but I do want to point out that structs are cheap. Make lots of them. Make them at the drop of a hat. Think a bit more carefully about what structs you _export_. But anytime the thought crosses your mind "maybe I should have a struct", do it. Just do it. Another advantage of not exporting them is that there's a linter that can find unused structs. But export automatically counts as a use.
Looks pretty cool! The example of using sql to query git history gives me ideas to explore other things with this too.
I personally love the current error handling in Go. The number of times I've had to deal with other people's code in other languages that encourage try / catch, and have just encapsulated an entire function in a single exception block, is enough to persuade me that handling errors at the point they return is a much better paradigm. You may be one of the awesome devs who, when given a function that may produce multiple errors, handles each error condition gracefully in the catch block, but you're the exception (no pun intended). I much prefer a language that pushes devs to treat each error as a separate concern as it arises. YMMV. If you want exceptions for errors, then you're welcome to use a language that does it that way. Have fun, and best of luck. Just please don't make snarky, unfounded comments. They achieve nothing other than promoting language wars (the most pointless of all pointless activities). Thanks. 
So, what's the utility here, then? I'm adding arbitrary code that doesn't really do anything just so I can have INTERFACENAME.method as a caller? What problem is this solving? How do the Duck and Mallard know that they are part of the Quacker interface? I am honestly flummoxed, I swear I'm not trying to be a troll on this. Every single write up I've seen doesn't seem to offer a "here's why/when to use this". They just say, hey, here's an interface. And then off to the next subject. I feel like I need a "Here's how 15 years of Python knowledge maps to the Go paradigm" write up.
The leads of each team works with my group and I, the architects, to keep diagrams up to date. They can propose changes and we approve. It used to be just me here and the diagrams we all fully collaborative. It's still that way but I tend to scaffold them first now to get things started. Our team is disciplined on documenting. It took 3 years to change that habit. It has been worth it completely. Automation also helped free up time to do the documenting and diagramming prior to at time starting coding. Still awhile and iterative, just some constant documenting and planning along the way as guiderails. I have a set of keys that correspond to the diagrams we use and how we all represent things. This was agreed upon as made and refined diagrams. We did have to convert old ones to the new key but that wasn't too painful. 
In conventional OO languages, inheritance is privileged in the syntax, but you can still use composition if you work hard enough at it. In Go, composition is privileged in the syntax, but you can still use inheritance if you work hard enough at it. There are probably times when that is justified. I have not personally encountered them in my Go programming, but I think if I were putting together a GUI widget hierarchy, I'd find some way to use it. (Inheritance is just _amazing_ in that particular circumstance. Bear in mind I tend to avoid it almost everywhere else, so I'm not saying this because it's the only way I know how to think. It is legitimately awesome in this one place.) But you're going to see it coming from people who can't think in composition, and are jamming inheritance very uncomfortably into a code base where it doesn't belong far more often than you'll see it getting deployed in a place where it belongs.
Handlers are at the core of HTTP functionality and, well, they're objects that satisfy the http.Handler interface... &amp;#x200B; type Handler interface { ServeHTTP(ResponseWriter, \*Request) } &amp;#x200B; Meaning an **Object**, that has a ServeHTTP method, with that exact signature can be used as a Handler, e.g. &amp;#x200B; type Home struct {} func (h \*Home) ServeHTTP(w http.ResponseWriter, r \*http.Request) { w.Write(\[\]byte("This is my homepage"))} &amp;#x200B; Home is now a valid handler.
Your client code doesn't make sense to me. `user` is passed along to `getMessages` but is never used. Then the response is printed, are you redirecting this to a file? To make sure that your bottleneck is not in the client I would test this code against a trivial local server. Depending on how you've configured the server, maybe it does rate limiting to prevent DoS, but it's hard to say just seeing the client code.
I actually consider Go an object oriented language, in that the ability to put methods on things and its use of single dispatch makes it a language that wants you to use lots of objects. You could program Go entirely procedurally, but you'd lose interfaces, which is a big problem. As I've commented before, Go is not terribly feature rich; it expects you to learn how to use its relatively small set of features very well, so you can't afford to throw away something as large as "interfaces". However, it's not inheritance-based; it's composition based. The thing you want to learn to do is instead of agglomerating small objects into bigger ones with inheritance, to take apart big objects into smaller ones composed together. Here's an example that comes up a lot in my code. Let's say you have a heterogeneous object store with things indexed by ID. You want to have a "base class" that allows you to get an ID from one of these heterogeneous objects, without the thing dealing with the ID having to deeply understand the object. Your inheritance-based OO instinct will be to declare a "base class": type HasID struct {} func (hid HasID) ID() ID { panic("virtual method") } And then let's go to use that in a User: type User struct { id ID } // how do I "inherit" HasID now...? But what you want is this: type ID struct { id string } type IDable interface { ID() ID } func (id ID) ID() ID { return id } Now you can do this: type User struct { ID } By composing in the ID, User now automatically conforms to IDable. The disadvantage to that is that ID is now exported. You also have the option to make ID unexported and manually forward the methods. I have sometimes wished for an "unexported composition" concept, where I can say "I wish to compose in this type, like ID, and I wish to automatically conform to any interfaces it implements and expose its methods, but not export the object itself."
What kind of programs do you write in Go?
&gt; A goroutine with io.Reader doesn't block an OS thread Yeh, that's what I was trying to say is the difference.
Calling something a more complex name is, most definitely, something wrong.
I work in a massive code base though. For dependencies that you don't need to configure, such as the local filesystem, default constructors won't require one. Your tests may need to use a constructor to pass in an in-memory filesystem, but that won't clutter callers that don't require it. In this way, main only tends to need to wire up a few final, purpose-specific components. This is what I find missing in most injection frameworks: it's hard to tell which dependencies you need to configure for your purpose--the more libraries are transitively used by one, the more you have to sift through to make sure it's set up the way you want it. Sure, in Go, occasionally you'll have to change an intermediate library to have a constructor set up the way you need it, but I find that's very rare and other teams are often quite willing to help.
Don‚Äôt worry, it‚Äôs not about bad English or being impolite. The reason people are ‚Äúannoyed‚Äù by titles using a variation of ‚ÄúX considered harmful‚Äù or ‚ÄúY is a ghetto‚Äù and other tropes is because they were funny the first time people used them, but it gets tiresome the more people use them. Personally, I still consider ‚ÄúX considered harmful‚Äù a funny homage, but then I still laugh out loud whenever my dog scares herself every time she farts. I‚Äôm an easy audience, LOL.
The important aspect is that you‚Äôre passing the things you need as opposed to assembling arbitrary bits of your object graph in arbitrary places throughout your code. ‚ÄúDI‚Äù is the term for the concept, and in this context your argument seems like an argument against words in general.
Not sure if this is what you're after but I've used this package to validate struct input for APIs: [https://godoc.org/gopkg.in/go-playground/validator.v9](https://godoc.org/gopkg.in/go-playground/validator.v9)
I usually just define a .Valid() function on a struct for field validation, then return a slice of validation errors or a simple error. type Model struct { Name *string `json:"name"` } func (m *Model) Valid() error { if m.Name == nil { return errors.New("name field is required") } else { if utf8.RuneCountInString(strings.TrimSpace(*m.Name)) == 0 { return errors.New("name field cannot be empty") } } return nil }
ok this was super helpful. makes sense. thank you!
This answer is nowhere near correct or accurate in any sense. Exception handling didn‚Äôt fall out of favor because there are more errors. There are just as many errors coming out of code in the 1980s as there are today. Exception handling has quite a bit of computer science theory behind it, focusing on control flow and what it means to generate an error. In fact C++ and Java‚Äôs implementations of exception handling, while similar in style, are used very differently based on competing theories. There is nothing in exception handling that prevents you from handling ‚Äúlots of different errors‚Äù. There are many examples in the Java stack of methods that potentially throw multiple exceptions. Exception handling is still in use today by some of the most widely used languages on the planet: C++ and Java. Python has exception handling, as does JavaScript, as you well know. The idea behind exception handling in the case of a language like Java, that uses it almost exclusively for error handling, is that an error in the code, input, I/O, or any part of the system is an ‚Äúexception case‚Äù, i.e. not the happy path, and should immediately break from the happy path and deal with this new exception state. For a language like C++, exceptions tend to truly be exceptional. A C++ app will use simple error checking for expected errors such as bad input, but throw an exception if there‚Äôs no user recourse, such as a network failure or disk error. Go eschews exception handling for three reasons. First, exception handling tends to be slower and more memory intensive. The exception typically carries the stack with it, for example. Second, with this overhead, it becomes much slower to compile applications if you have to manage exceptions, and Go is focused on fast compile times. Finally, and most importantly, exceptions are frequently abused and lead to sloppy coding practices. They go undeclared and undocumented, so you don‚Äôt even realize all the exceptions a method or function can potentially throw. Or one exception is used for a slew of different errors, e.g. you might throw ‚ÄúSaveFailedException‚Äù for both a bad filename and a full disk. Exceptions are often simply ignored and passed back up the stack, only to be dealt with at the very top, or just ignore altogether and let some general exception trap log them. The Go developers argue that instead it‚Äôs best to deal with the errors when they happen, so you‚Äôre thinking about every error, documenting every error case in the code (ErrFileNotFound, ErrDiskFull, etc.). It also means Go compiles much faster than a Java or C++ app (for more reasons than just exception handling, but it‚Äôs in there). If you‚Äôd like to learn more about exception handling, search Google for ‚Äúexception handling theory‚Äù.
[removed]
Updated the title [of the article](https://medium.com/@valyala/mmap-in-go-considered-harmful-d92a25cb161d). Now it is less harmful :)
oh this is just fantastic. thank you! as a learner i like seeing how golang users disagree like this :) i learn faster when i can see where the arguments are.
You are missing the second step in the example code: kernel32, _ = syscall.LoadLibrary("kernel32.dll") getModuleHandle, _ = syscall.GetProcAddress(kernel32, "GetModuleHandleW") So, in your example: var ( PowerMeter, _ = syscall.LoadLibrary("mcl_pm64.dll") Open_Sensor, _ = syscall.GetProcAddress(PowerMeter, "Open_Sensor") ) And then to call it: if ret, _, callErr := syscall.Syscall(uintptr(Open_Sensor)... etc That is, you are passing into Syscall specifically the pointer to the address of the desired function in that library, which you got from syscallGetProcAddress.
Look at the example in your link. You use GetProcAddress to get the handle to the function and the you call it with syscall. 
Start with the [Golang Tour](https://tour.golang.org/welcome/1). I recommend downloading a copy of the tour and working locally.
how is *that* reply related to _my_ question? Please reread _my_ question.
&gt;how is that cr√°p related to my question? Reread my question. Because it's a tool written in Go that can generate a blog. Maybe you should learn to ask better questions? If you just want to build an API then there's no need for a framework. At most you'd use something like Chi to make the routing easier. There's also Gin, Echo, Buffalo, and more. That come with various benefits and drawbacks.
Will this work on Linux, for example ?
So....I am not understanding. In your second code block, the word "Handler" doesn't appear. Is it still part of the code? How does it factor into what you've shown? Why is it needed? What is it actually doing that the second block of code is unable to do?
"Hi I'd like a steak sandwich" "Why would you ever want a steak sandwich, have this cookie instead" Essentially what you just did. The reasoning doesn't matter and assuming they just want an easy way to make a blog is pretty fucking ridiculous. Maybe they just want to learn a Go web framework and happen to be using a blog as the means
Greetings fellow tester! So, do you have a recommended book/wiki to learn this? At this point, I cannot fathom using Go for testing outside of unittesting go code.
Try using algorithms. If that doesn't work use ajax traversal manipulation with alternating series. 
hold on a second. you've been writing Go for 3 years and don't know what interfaces do? That's a red flag...
&gt; For something like a blog or a simple REST API web service. 
I'm still calling your experience anecdotal and it's not very scientific. From what you just said, I'm led to believe you have a skewed bias that may be product of your environment. Security for PHP should be handled by locking down a php application per user. Your description about points of entry for the application is only because people want pretty URLs. The applications I've made in php don't use a single gateway script, but still provides pretty URLs. As for fixing things and code maintenance, anecdotally in my experiences, people that run PHP applications tend to be cheap and Indian developers suck because no Indian developer wants to be a dev. They want to get promoted out to management as fast as possible. So their code tends to be low quality.
Mux
use qor. you can create blog admin under 10 minutes.
Not just the go standard library, but programming in general. More than two things being returned from a function is a huge red flag that there's something weird going on in your design. There are a few cases where 3 may be acceptable, but it should only be done with careful consideration.
yup. And that's an anti-pattern. Keep in mind that most of the standard library was written in go 1.0 days, which is ancient history in the Go world. With the go 1 compatibility contract, we can't just go back and change how these things work. That doesn't mean they're a good idea.
Init functions imply global mutable state, and global mutable state is hard to reason about, because you have no guarantee that some other goroutine won't modify the variable right before you access it.
My recommendation for figuring out go is to rewrite something that already exists in another language, in go. That way, you're not having to figure out *what* functionality you need, you just need to figure out *how* to get it to work in Go. Basically - you have a completely and well-thought out spec, so you just worry about the implementation. Re interfaces.... maybe this will help? https://npf.io/2014/05/intro-to-go-interfaces/
Go has a few examples of `Interface` in the stdlib: [https://golang.org/pkg/net/#Interface](https://golang.org/pkg/net/#Interface) [https://golang.org/pkg/sort/#Interface](https://golang.org/pkg/sort/#Interface) [https://golang.org/pkg/container/heap/#Interface](https://golang.org/pkg/container/heap/#Interface) init functions and package globals are probably not best practices, but they, too, have numerous examples in the stdlib. &amp;#x200B;
to be honest, I'm not sure Go is your best place to learn another language. Go is an awesome tool for building servers with. It does this really well. But it's probably not going to teach you as much as other languages could. Go is a finely-tuned language designed for a particular set of problems. It does this in a way that not everyone agrees with, and that will probably leave you with bad habits if you use it's paradigm elsewhere. To be honest, if what you're coming from is PHP and Laravel, then I'd either go full-on Haskell ([http://learnyouahaskell.com/starting-out](http://learnyouahaskell.com/starting-out)) for great good, or double-down on what you already know and learn Python. Python and Django is basically next-level PHP and Laravel, so you'll get it easier and you'll make more progress, and have leveled up. Go will confuse the shit out of you and give you no good reasons why. But, you know, if you're determined... forget the IDE (I think most gophers either use Vim or VSCode), and just build a server. Work through Essential Go, and keep referring to the excellent documentation, and try to understand the type system instead of fighting it.
I'll be honest, I've never heard of any of the speakers. They seem like really nice people, and I'd probably enjoy meeting them in a bar and having a great conversation with them, but... why would I pay money to go hear them talk about stuff? What are they even talking about anyway? 
Go is different than other languages like java in that you only have to satisfy the interface methods and not explicitly implement it. Go just knows. I get that it may be difficult to grasp without a real example. A better example would be loggers. You could have loggers that output to stdout, or databases or files or syslog. The Log method is a completely different implementation for different loggers. In python you can just pass in anything to a function because it is weakly typed. E.g. def write_log(logger, line): logger.log(line) But you‚Äôll get an exception at runtime if logger doesn‚Äôt have a log method. Go protects you by checking if it has it at compile time. Why can't we have a base class with the log method and inherit from that and override as necessary? You kind of can by embedding structs into other structs, but you get more flexibility and it's more composable this way. A struct could satisfy multiple interfaces without having to worry about multiple inheritance hell. Check https://play.golang.org/p/jYvEyPyUdxx There's not many other ways to support looping over different types like this and remain typesafe.
Totally agree on all points. I was responding under the assumption that the decision to use a global variable had already been made. I.e. just an initialization of a complicated "constant", or maybe generating some lookup table from more human-friendly raw data.
- Relative imports. - interface{}
I thought it was common knowledge by now but I guess it's not. Here you go: https://peter.bourgon.org/blog/2017/06/09/theory-of-modern-go.html Why models is bad it should be self explanatory but if you have doubts: https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1
Are you aware of any existing ones in Go?
Thank you. Do you know any Go tool / framework that is capable of testing mobile apps as well?
Thank you, I'll read them. Never assume people have some specific knowledge unless, maybe, if it's in the official documentation. :)
The basic net http library might work for you
What about the official Go Wiki? [1] [1] https://github.com/golang/go/wiki/Modules#quick-start-example
Do you know every speaker on the GopherCon schedule every year? I am sure plenty of people are familiar with at least William Kennedy. That being said, I agree with the last part about the topics of the talks not being posted. You can see clearly who each person is on the speakers page, but still don't know what they are going to speak about. 
* Bare returns (just writing `return` without args when you have named return values) - just don't ever * Named returns for no reason (only do it for documentation purposes or if you need names for functionality in defer) * Naming basic types without adding functions to them (like `type Books []Book` or `type Values map[string]string`) . My one exception is when that value type is used in multiple places and needs consistent documentation between those spots. * Over use of interfaces... (interfaces of interfaces of interfaces so that you can't even tell what the code is actually doing). * using a plain old string when you really want an enum * almost every use of type assertion to the base type implementing an interface... if you care what the base type is, you're probably doing something wrong. 
I would look at the \`chi\` router, it's amazing -- [https://github.com/go-chi/chi](https://github.com/go-chi/chi)
Suppose you are writing the code to test your RSS parser with some specific RSS you want to verify does something you want it to do. Suppose you have an RSSRetriever that takes a URL and retrieves the RSS at that location: type RSSRetriever struct { // whatever goes here } func (rr RSSRetriever) Retrieve(url string) (*RSS, error) { // implementation here } If you're trying to go beyond a scale that works for just you, one thing this object is probably doing is using a worker pool to ensure that you don't try to ingest every RSS file on the internet at once. If you scale up even farther you'll want to shard your access based on site so you don't hammer one site in 2 seconds, then leave them alone for the next hour, etc. There's lots of reasons you'd want such an object. (That's why I'm saying this isn't just a function. You'll need more management and control than is practical to stick in a function.) However, you have a problem for the test scenario I gave; with that object, your test object needs to be somewhere on the network for your test case, which is both really inconvenient, and violates testing principles by including the state of the network in the middle code that just wants to test parsing. So one solution would be to declare an interface: type CanGetRSS interface { Retrieve(string) (*RSS, error) } and now for your test purposes, you can define a local implementation: type StaticRSS struct { RSS map[string]string } func (srss StaticRSS) Retrieve(url string) (*RSS, error) { rss, haveRSS := srss.RSS[url] if haveRSS { return &amp;RSS{rss}, nil } else { return nil, errors.New("404 not found") } } Now, if you write your retrieval function to take CanGetRSS instead of a RSSRetriever, your test code can call it with a StaticRSS instance and bypass the network entirely. Now, I'm whipping this up off the top of my head, and it's a Reddit post not an actual program, and there's all sorts of fiddly issues I'd take with this design, but the principle generally holds. I do this general thing all the time. (In fact, I'm not just pandering to the fact you said you're in testing; this is one of the major use cases, though far from the only one.)
It's an /r/circlejerk thing, sorry. Usually the verb is assumed from context. 
Interfaces describe behavior. They're best named for what they do. Putting the word `Interface` in their name is redundant. I also think this typically shows either lazy or poor thought into naming and that is a sign of a lack of conceptual clarity or understanding of the problem. The standard library is full of examples (and you have to try hard to find the two legitimate counter-examples above) of good interface names. `io.Writer`, `io.Reader`, `sql.Connector`, `xml.TokenReader`, etc. So think of what behavior the interface describes and pick an appropriate noun for it.
It's usually here to mask obvious political and mental vacuity. 10 years ago it would have been "We're using 100% recyclable forks, we care about environment", it's the same, it's a marketing litemotiv they don't give a shit about anything, these are just words. In 10 years it will be something else. All these people pushing for diversity are well-off white people.
Be careful, report will block until someone reads from `onProgress`. Also, this seems way simpler to me: type Progress struct { mu sync.Mutext value int64 } func (p *Progress) Report(progress int64) { p.mu.Lock() p.value = progress p.mu.Unlock() } func (p *Progress) Value() int64 { p.mu.Lock() defer p.mu.Unlock() return p.value }
No it doesnt. What i need is a high-level API framework connected with ORM/query builder. Ideally, similar to pyton eve, so i could specify sql fields and it would make the api endpoint out of it with the ability to attach hooks (to add auth etc.). Using net/http library i have to write similar sql queries for each api endpoint over and over. What if i have many resourses using the similar filters with GET parameters? It gets complicated with every feature being added. Python rest api frameworks handle it much better, i'd like to find similar frameworks for golang. What rest-layer does is fine but it doesnt have mysql/postgresql support.
Im looking for rest api framework similar to [python eve](http://docs.python-eve.org/en/latest/features.html) or [feathers.js](https://docs.feathersjs.com/guides/basics/starting.html#your-first-app) so i wouldnt have to write boilerplate CRUD code by myself for each API endpoint.
Hi All, posting my first package that might be useful for everyone. I was tired of having to add a comment to each step in the error catching process and came up with this extremely simple stack trace. Let me know what you think! 
What is the Go idiom? Errors are values so handle them like that? Great. Have you tried differentiating errors from the standard library, e.g. if your \`http.Do\` call got a timeout, a rejected connection, a "host not found" error or something else? Spoilers: fmt.Errorf everywhere. The only change you have seems to be \`strings.Contains(err.Error(), "whatever i am looking for")\`. Nicely done!
Was typing on my phone while in a meeting, I'm happy it turned out like this without using gofmt and goimports
Sooo it‚Äôs over engineered and non-obvious to use. Great design.
Are you asking because you'd like to try to articulate to someone that it is wrong?
I'm pretty new to programming and are a little bit curious what you mean with "that will probably leave you with bad habits if you use it's paradigm elsewhere." and "Go will confuse the shit out of you and give you no good reasons why." I have played around with Python before (still not much of actually programming, just the tutorial loop) but for me Go just feels like a better version of Python. I really like that you have to specify everything (variables, arguments, return arguments, structs etc) and that the compiler finds errors and unused values before you run the program. Feels very clean. The syntax is simple and easy to understand. And I really like the idea of "go format". What makes Go so different that you wouldn't recommend it? The biggest downside I have found so far is that it is harder to find resources/tutorials for beginners, but it is not fair to compare it to Python. 
You mention creating a blog twice in the short sentences you posted. If you want another answer then ask a more specific question. I gave you plenty of alternatives.
nice. is gameboy game engine somehow open? or reverse engineering power?
It's probably reverse engineered. Really exciting.
I do the same.
Your mindset is still OO. Don't define a go interface on the definition side. Define it on the use side and only if needed. The implementation should be as simple and concrete as possible and should not contain abstractions if possible. F.i. an io.Reader has no idea it is an io.Reader.
[https://godoc.org/github.com/pkg/errors#hdr-Retrieving\_the\_stack\_trace\_of\_an\_error\_or\_wrapper](https://godoc.org/github.com/pkg/errors#hdr-Retrieving_the_stack_trace_of_an_error_or_wrapper)
Unfortunately not. Which does not necessarily mean that none exists, I am only not involved in Go projects for mobile apps. A quick [search on go-search.org](https://go-search.org/search?q=test%20mobile) does not seem to return interesting project, but you can evaluate better than I if one of these projects suits your needs. Other search options: * https://golanglibs.com * https://golang.libhunt.com * GitHub: `language:go sort:stars test mobile` 
Some quick non-exhaustive feedback after scanning your code. - camelCase package names are a big no-no. Similarly with filenames. - You exported a variable which has an exported type, which makes its documentation [unreadable](https://godoc.org/github.com/ktravelet/errorStack). - Don't put `type` into a type name. - You have `getStack()` return `interface{}`, but it only ever returns `string`. - Consider using `strings.Builder` instead of repeated string concatenation and `fmt.Sprintf` calls. - Why is every line surrounded by whitespace? :P - That `init()` is pointless. You can just assign the variable with a struct literal. - You use global variables for settings. What happens when two packages want different defualts? - Returning `errors.New(...)` is a bit of an antipattern. Your output has a pretty concrete format, and would be better served as its own type which implements the error interface. You should definitely check out these resources: - https://golang.org/doc/effective_go.html - https://github.com/golang/go/wiki/CodeReviewComments And just as a note, I think most people will just use [pkg/errors](https://github.com/pkg/errors), but writing something like this yourself isn't a bad exercise.
Echo or buffalo with --api if you really want to use a framework.
https://github.com/ksimka/go-is-not-good
100000000000% agree
Try Rust ;)
Yes. Also, try haskell ;)
Rust is actually my primary language outside of work, and then Python for everything else.
What about MATLAB? /s
Only for exported identifiers, and only for types, functions, variables, and constants. Notably, NOT for unexported things, or exported struct fields. You can also comment stuff in a group: // This is fine. const ( Exported = 1 ExportedTwo = 2 )
Besides obvious things mentioned already, like not using gofmt or ignoring Effective Go and Go Code Comments: \- logging and returning errors at the same function \- using buffered channels of "huge" size "to prevent blocking" \- testing implementation details, instead of behaviour \- designing package's API while focusing on package's internals, instead of thinking about how this package will be used (this includes packages used only inside a single project)
no -- i don't think Go is "disgustingly" verbose.
If you can put it in a public repo on GitHub, absolutely
I agree, but it's a love-hate thing it's the best language I've run into for writing lightweight network services much at least for me it beats having to reach for java or c anyway 
Here if you need more. https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk
Thank you very much! This is why this subreddit rocks.
&gt;c doesn't have vectors Yes, but it takes about 15 lines of code to implement one, so it's not uncommon.
No.
A go interface is something like this: type interface struct { type type ptr *unsafe.Pointer } It's a pointer combined with type information. When you call an interface method the method of the stored concrete type gets called. Interfaces make otherwise unrelated types compatible and interchangable because they implement the same method set.
Can you justify any of these problems though?
Java did that experiment 20 years ago with checked exceptions. That experiment was a complete failure, lot has been said about that, go around and look for yourself. Besides, contrary to what you suggest, Go does a very poor job on forcing user to handle errors at the point of their occurrence. You can call a function that returns error, never assign that error to any variable (possibly by mistake) and Go will be very happy to compile that for you without any notice. You may never know that exceptional situation happened and it's super hard to debug afterwards. Have you ever asked yourself why Go 2 announced ordinary try/catch error handling if current paradigm is that good? If only Pike didn't ignore last 40 years of language development we wouldn't have to discuss the same mistakes again.
Java did that experiment 20 years ago with checked exceptions. That experiment was a complete failure, lot has been said about that, go around and look for yourself. Besides, contrary to what you suggest, Go does a very poor job on forcing user to handle errors at the point of their occurrence. You can call a function that returns error, never assign that error to any variable (possibly by mistake) and Go will be very happy to compile that for you without any notice. You may never know that exceptional situation happened and it's super hard to debug afterwards. Have you ever asked yourself why Go 2 announced ordinary try/catch error handling if current paradigm is that good? If only Pike didn't ignore last 40 years of language development we wouldn't have to discuss the same mistakes again.
I wasn't the one who suggested Hugo to you. I gave you a bunch of solutions which you just ignored.
If you really think that the new module system could have been written in one afternoon, then I think it's not worth answering your rant. Anyway, most things you complained about are related to the lack of generics and the verbosity of error handling. The Go team has recently published design documents about improving this. 
I've read them and am unimpressed. They didn't even have to design something new, they literally could have just taken the design of NPM or Cargo or Maven or any other and it would have been *so much better* than their proposal.
True, I see what you mean
I'm author of go-sqlite3. If you call Query/Exec with parameters, injection will not be occured. If you call them with concatting SQL string, injection will be occured.
Game consoles of that era were pretty low level. There wasn't really an operating system, and the game would pretty much run straight on the hardware. Some games even included their own hardware on the cartridges to do things that the console itself couldn't support natively. My understanding is that implementing an emulator for those consoles is mostly a matter of implementing the opcodes in the processor properly. 
i can try but don't have the energy. this is a well trod subject. maybe a better way to approach it is to explain how you think some of these perceived problems could be fixed? i mean this sincerely: how would you do error handling? how would you improve appending to slices? how would improve type assertion? etc.? i'm genuinely curious.
You inspired me to write a linter for these types of errors solely because of the name: [https://github.com/alexkohler/dogsled](https://github.com/alexkohler/dogsled)
I do, but I can't at work sadly.
You dont need variable parsing in the routes you can do that yourself quite easily. That said gorilla/mux can handle that without you needing to use the rest of gorilla. As for a mongo connection, there is a mongo driver library available, same with mysql &amp; elasticsearch. CORS is trivial to create your own middleware for. Same with authentication. If you are using sessions, please don't use them within the service; it should be stateless. Caching should take place outside of the service. While you can always use frameworks and external dependencies to "help" with things in go, you would be very surprised what you can accomplish with the STDLIB without incurring the cognitive overhead of learning new libraries or managing those dependencies. 
I totally screwed that up. Wrote constructor, meant factory.
Great follow up to that: https://middlemost.com/failure-is-your-domain/
Well there's Buffalo, Revel etc. if you really want a framework. &gt;Python rest api frameworks handle it much better, i dont have to write CRUD code by myself with them, i'd like to find similar frameworks for golang. The philosophy of Go is different than those other systems. You will either need to roll your own, or perhaps stick to Python.
You should write your own language and use that. Solves all your problems, obviously.
I love how this has come full circle - nice work Reddit. 
[removed]
[removed]
I made Ponzu for this kind of thing. It's like faster WordPress with no "themes", plus a bunch of extra stuff baked in. Any kind of front-end you want, just needs to handle http &amp; json. https://ponzu-cms.org https://docs.ponzu-cms.org
Please write your posts assuming that noone has ever heard of Mainflux.
Prometheus counters should probably not be global. They should probably be created in func main, registered into the right Registerer, mounted into the right HTTP server, and then passed as dependencies to the components that update them. Basically the same way you'd pass a logger.
&gt; Of course sometimes you want to provide side-effects via a mere import. This is a false convenience. It's unpredictable, especially when composed into a (much) larger program, which makes understanding, and ultimately maintaining, programs difficult. Import side effects are almost always a bad idea. 
 s := []string{} Preferred, I think.
Disclaimer: judging from you post history, I'm unsure if I really should reply. Oh well, time will tell if it gets to pcj. I didn't really understood your problem with interfaces and map access. You could theoretically make something like map.On(key).Do(...) but should you? Slices are different. I said it numerous times - slices aren't vectors. For one they allow multiple pointers into the backing memory (which vector doesn't, but range/span do). The second part is that slice struct is actually immutable - on taking slice or appending it, you actually creating a new slice. You could build vector around it if you want, but the main thing is that slices are basic building block for working with dynamically and statically allocated arrays. No more. No less. I didn't understood your point about crippled reflection either. I mean - you can create new types at runtime. It's not big of deal, but I'm not sure it's crippled. Especially if we compare to something like Rust which is very limited in that area. Exported modifiers being Capitalized is a matter of perspective. It's not ideal solution, but it does help a lot when you read others people code. I agree about error handling. I disagree that there is something that is fundamentally better. Algebraic data types? The number of types grows exponentially with call stack increase. Doesn't help with identification of the error exact position either. Exceptions? Checked exceptions seems nice but litter every method with their signatures. Doesn't work with lambdas. Plain exceptions? Never know if method throws it doesn't specifically document this. With exceptions there is also a problem of propagating error from goroutine to a parent goroutine. I disagree about go get and new module system. The concept - as everything with Go, is simple (some may even say dumb). The devil is in details hovever. Try to implement generic downloader from GitHub that doesn't get banned by their throttler as a first example) For me - I like how Go doesn't like "clever" code. I mean - from the programming perspective it may seem counter intuitive, and maybe even be offensive. At the same time, code reviews are so much easier, as well as fixing others people code. And while I agree that some things can be made more elegant (like error handling, or finally getting generics), at the same time there is too many things I like (runtime, goroutines, low GC pauses, fast build times, big ecosystem, locking that is proven to be fair and so on) that make Go "good enough" for me for now. For you? Well... After reading your post again, I'm starting to wonder - if you really want to use Rust, why didn't you use Rust? Change the job if you have to. Or try to convince your teammates to use it. Keep in mind that most of your observed bad things are the matter of perspective, so you will need something more objective. For me every language is just an instrument, but it's affects your happiness this much, maybe you should consider this move? I mean - wouldn't like to work on something I clearly don't enjoy spending my time on. Life is too short to be unhappy. 
[Rest-layer](https://github.com/rs/rest-layer) says that it is inspired by python eve
Python is Object Oriented, Interpreted, and Dynamic. Go is Imperative, Compiled, and Static. PHP is also OO (kinda), interpreted and dynamic, so someone coming from PHP will be way more familiar with Python's world than Go's. Go is unusual in modern languages for a few reasons: it's very simple (deliberately so), it's not object-oriented, and uses interfaces and duck-typing to do things that other languages use objects for, and it has a great concurrency model that is unique and difficult to understand properly. Go also has a strong idiomatic style that takes some getting used to. Beginners to Go tend to write non-idiomatic code, and it takes a while to get used to the "Go way" of doing things. All of this means that learning coding on Go will leave people with an unusual set of skills and attitudes compared to learning coding on (say) Python. Moving from Go to something else will be harder. For the same reasons I wouldn't recommend learning Erlang as a first language. But, y'know, you do you. If you're happy learning Go as a first language, then that's great. Good luck with it :) 
net/http
I was just thinking the same thing. Glad I'm not the only one that lurks this subreddit. 
Wait - is this purely from that comment a few days ago?
Around 3\~4 months from now
yes, half a release cycle away. I was wondering why OP bothered posting this, when the release is still so far away.
Oh, agreed with you there. Factories aren't idiomatic Go.
These notes are about 2% complete. This is just an auto-generated template. 
This Nowadays, computer are so incredibly powerful, they're thousands orders of magnitude more powerful than gameboys... As soon as the opcodes are implemented and behave correctly, boom that's it, it works There's no need to optimize anything
No sorry. But why does it have to be go. Seems to me you are looking for a tool to solve a problem, so that makes every tool valid that does the job.
Sorry, just wanted to give an idea of what's coming. I know that it's incomplete.
Yes, me too. And creating ErrWhatever values or maybe even custom error types. Sadly that's not the case in the standard library, so error handling is really a pain in the ass. I am surprised the sql module is not doing: fmt.Errorrf("something went wrong: %s", err) 
Yes I agree, performance is not a reason to avoid using structs. I was attempting to underscore a principle. If you're using structs simply to pack unrelated bits of data together, you're probably not thinking about your domain properly. Simply packing your 6 return values into a struct doesn't improve the code in any real way, unless of course, those values cohere and can be represented appropriately by said struct.
As others pointed out, there's not so much an engine but just hardware and some basic interfaces. I don't remember that much anymore since it's been a while I watched it, but this talk is really interesting and fun if you are interested in how a gameboy works and what games have to do to run on it: the ultimate game boy talk https://youtu.be/HyzD8pNlpwI
Well it was made 5 hours ago so i guess so yes
thanks. I'm not particularly interested in gameboy. I'm just in general curious about programming and things I don't know much about. This is really exciting connection between old and new technologies.
&gt;Does anyone else feel like Go is disgustingly verbose? No.
&gt; If you‚Äôd like to learn more about exception handling, search Google for ‚Äúexception handling theory‚Äù. Thanks. And if I'd like to learn more about the theory of flat earth I'll google that. Just after exception handling theory. Some theories just do not work out in reality.
I don't recommend you to use any web framework. you can build a web famework by yourself. BTW, I recommend a router , it is a simple and fast HTTP router for Go.AS as fast as httprouterÔºåand support RegExp. It is easy to build RESTful APIs and your web framework. [https://github.com/xujiajun/gorouter](https://github.com/xujiajun/gorouter)
Hahaha i saw full comment regarding this and guy said something like "You coined this term and i will use it anywhere" and i see now library dedicated to this, it is funny but i don't want golang to become nodejs that we need full package for this kinda thing, i hope this is just a joke
Ah, I got it. Thanks for your answer, much appreciated :)
Pretty sure it was a z80 variant 
Hey! Looks like your emulator has the same problem as mine with the loading screen on Pokemon Gold https://github.com/djhworld/gomeboycolor https://github.com/djhworld/gomeboycolor/issues/44 Did you get to the bottom of why it's doing that? 
So the networking between your containers was managed by swarm mode, and now by AWS ECS?
Great comment, especially your analysis of the tradeoffs regarding error handling!
Thank you for your answer
I also come from PHP development, the last 5 years. Now i am working with Go. What helped me a lot is watching all the talks and conferences over the last couple of years. Search in google for "Rob Pike golang" and watch all the videos that come up. You will get a pretty good idea of what the language is about. I use Goland, for an IDE. It seems to be the best.
I know I'm in the Go subreddit but I would personally not use Go's convention for error handling as a benchmark when there are other things out there that make more sense (E.g. Rust). But keeping that aside, I would still argue that the multiple disparate return values for error handling is a globally established pattern in Go and hence acceptable since it's well understood. For any other bespoke case, it definitely adds a bit of mental overhead in parsing what a given function is trying to do.
You should really post your code example even if you say it's a copy. Maybe something is out of sync with the spec of the code and the example documentation. The error implies that the Render() method of your MyComponent doesn't match that of the Component interface. 
To use 1 programming language instead of 2 (some parts of project are in golang anyway).
There is actually plenty of documentation about how the GB and GBC work (from reverse engineering and other means). I recommend looking around it as it taught me a lot (not just about GB hardware). I link to some of them at the bottom of my GoBoy GitHub page if you're interested: [https://github.com/Humpheh/goboy#resources](https://github.com/Humpheh/goboy#resources) 
`Result` doesn't make sense unless you have both generics and you treat errors as normal values (no special control flow for `exceptions`). Once you take away generics and exceptions, allowing multiple return values becomes a natural segue. If you are forced to treat errors as normal values then you're going to want to have some way to return either a value or an error, and without a generic container type to roll them together.... well you either implement multiple returns, or do it the C way and use `out` variables - yuck. The Go solution gets you 80% of the way there without requiring generics. This is especially true when considering that the Go compiler requires you to _use_ returned values in the majority of cases (which is a valuable attribute of the `Result` type in Rust). What I'm trying to say is that the "Go way" is not in competition with the "generic way", it's a direct translation of the `Result` type where you don't have access to a generic type system to implement it. Creating container structs in an attempt reduce the apparent number of return values is just an anti pattern in Go. The fundamental issue is that you shouldn't be creating structs to roll up values, you should be creating structs to represent concepts / abstractions / domains / behaviour. In summary: if you find yourself wanting to avoid a dogsled by creating a meaningless struct to hold the values, then I think you have deeper issues with your code. 
I actually have very little networking directly between containers. My application was built with a message passing architecture, so each microservice just needed access to the message bus. Message passing fits very nicely with a microservice architecture, as any time you need to update or rebalance services, you can just turn them off and messages will queue up until a new version arrives to handle the messages. 
I would say when you have a large amount if repetetive functions, where you would normally use generics. Go provides go generate to generate the source code to deal with the issue. Another case, if you come from say C++ and you do a lot of fiddling with different int/uint types (8,16, etc.); you will have to cast them to correct type every time. Some will say you should just use one type, all the time to avoid this. But I enjoy the restriction of native types such as uint8, instead of creating if sentences to validate the value every time I used a int parameter that will fit all my cases. I really wish situations like `uint16(635) + uint8(5)` would just return a uint16, and the program would then compile. But Go cares very much about types.
It's right there: local/hello/main.go:9:19: cannot use c (variable of type *MyComponent) as github.com/gopherjs/vecty.Component value in argument to vecty.RenderBody: wrong type for method Render func (c *MyComponent) Render() *vecty.HTML Check godoc for [github.com/gopherjs/vecty.Component](https://godoc.org/github.com/gopherjs/vecty#Component). Signature should be: func (c *MyComponent) Render() vecty.ComponentOrHTML 
I agree with you and I stated such elsewhere in the thread, I definitely didn't want to give the impression that return values should just be packed in a struct to avoid using Go's mechanism for returning multiple values. In your case of a Lookup function, why not just use "error" to handle a condition not found? That's essentially the same thing as an "ok" boolean, is it not? And you save the additional cruft of having to maintain an extra variable. Check out my implementation of a lookup method: https://play.golang.org/p/mNqQugbId3J Go's error handling is good because it forces me to think about a failure at every point in the program. I could also add some additional validations, but I've covered the main ones and as a result, I have a very solid lookup program that will behave predictably.
IMO a lot of the perceived issues people have with error handling is due to the proliferation (and plagiarism) of poorly written blogs and other code snippets. Almost every example of Go code people will be exposed to whilst learning to code, will check errors after every return using `if err != nil { return err }` or similar - so of course everyone incorporates this into their own code and never looks deeper into how errors can/should be handled. Another much broader factor in effect here, is one that affects a lot of online communities i.e. the asymmetric influence of inflexible, vocal minorities. Go is used globally, by a very large and increasing number of developers - most of whom use the tools they're supplied and are happy enough with what they have (including error handling). So is the issue really with Go? Or is the issue actually with the small number of users that come to Reddit complaining about various issues that apparently plague the language? The same phenomena is the reason why governments enact unpopular laws due to lobbying. Learn to use the tools you're given.
THIS IS AMAZING
They aren't thousands of orders of magnitudes more powerful. They're a few orders of magnitude, because orders of magnitude are logarithmic. For instance, a 10Mhz processor is one order of magnitude more powerful than a 1Mhz processor, because it's ten times as fast. My i7 is two orders of magnitude faster than that, sitting at around 4.5 GHz, meaning about 4500Mhz, which has two more digits than the 10Mhz one. It's only three orders of magnitude more powerful than the 1Mhz processor, even though its 4500 times faster!
`getty` is also the name of a program that manages TTYs, just FYI.
The example code there is out of date - we changed the return type of `Component.Render()` quite some time ago to allow nesting of components.
(gRPC Gateway)[https://github.com/grpc-ecosystem/grpc-gateway]
It indeed worked, I blindly tried to follow the tutorial when I should have checked the GoDoc with more attention, may that be a lesson. Sorry for the bothering, I can now learn in a more efficient state of mind.
From experience, you may have to fight against Go in some cases: * Insisting in shoehorning Java'ish OOP inheritance in Go * Problems that lend themselves to generics * Interfacing with C is better in other languages * Official package management a work-in-progress As any other language, Go is just a collection of compromises. In my field of work I could say Go follows Pareto's 80/20 principle: well suited for 80% of the problems with 20% of the complexity.
While I agree that "thousands of orders of magnitude" is an exaggeration, cycles per second is hardly a good metric for the overall computing power of a CPU. Your i7 has 8 cores, hyperthreading, pipelining, branch prediction, and a long list of other optimizations that make each CPU cycle substantially more effective than a cycle on a 20 year old Gameboy processor. 
I don't disagree. I just wanted to clear up what "orders of magnitude" meant. I should have used the word "faster" not "more powerful".
Honestly if you want a challenge, study the source code. Some of that stuff is crazy. Like the context package. https://golang.org/pkg/context/#Context
10/10 what a community!
The first block is within Go's http package, it defines the concept of a Handler, the rules for what a handler *is.* &amp;#x200B; The second block is our code. It's our implementation of a handler. We never explicitly say it's a handler, nor do we have to - but we have written something that has a ServeHTTP method with the exact signature that a Handler requires (the w http.ResponseWriter, r \*http.Request bit), so when we give Go this to use as a Handler, it will take a look at it say yes, that can be a Handler. &amp;#x200B; For an ELI5 version of this, imagine you want to define a car. We want a \`type Car interface\` and we want a \`drive()\` method (obviously not everything that drives is a car... but for simplicity sake, bear with me). Now, I have some code that needs a Car, it's a taxi service so it can be any type of car really, but it absolutely MUST be able to drive. &amp;#x200B; \`func drivePassengerToLocation(Car)\` Now, we have stated that we NEED something that meets the requirements of the Car interface, which means in our example anything that has a \`drive()\` method will be valid here, because that's all our interface wants. I don't have to explicitly call my Car struct \`AWebDevCar\`, I just need to have a drive method() on it and it will be treated as a Car.
which parts are crazy?
sorry, posted a wrong url. The new post is here: https://old.reddit.com/r/golang/comments/9tkgcl/whats_coming_in_go_112/
This is really well written, but I am not seeing how the call ServeHTTP call in the second block is part of the Handler interface in the least. That is where my biggest misunderstanding lay, I don't understand how the \*Home is in any way connected to the Handler interface. So, by sharing the same name, Go somehow knows that the ServeHTTP is somehow part of the Handler interface? From my view, it just looks like extraneous code that looks fancy but no one directly uses. Can you answer for how the Home struct ever is part of the Handler interface? Because all the examples I have seen of interfaces in action seem to say a lot about "the object must be of a type, and implement certain methods" but a) what about common re-use in methods and (more importantly) b) how on earth do any of these structs become part of an interface? Oh, they implement a method. Cool. Then why is the interface needed at all? This is what I am missing in the understanding. Do I add a Home object to the interface through some method? Is it all just "magic" that Go does under the hood? I cannot wrap my head around how the interface factors into any of it.
Thanks!
So, I have looked at that link. Interesting, and clearly well-researched, write up. What I cannot understand is, if I don't explicitly have to use the "Walker" interface, why would I? The Walker interface tells you that it has a callable method "Walk", but it doesn't provide any type of actual code. The Walk method created for the Camel struct, does implement actual code. So, why then, is the Walker interface needed? &amp;#x200B; I understand that it's about an implementation spec. But, when would I want to use an interface if it doesn't actually provide any error checking or actual code? Which really doesn't make a ton of sense to me. What's a real use-case? Do you use it for database connectivity? Logging? Or do normal Go devs rarely write interfaces, merely consume those written by others?
Even if you do "hit the brick-wall" the benefits of Go will continue to outweigh whatever frustrates you. The speed of the compiler alone makes for such fast cycles for the developer that all other environments feel like backwards wastelands by comparison.
Any mention of TLS 1.3? (Couldn't see most of the text on mobile.) We do know that TLS 1.3 will be in the next version of Go.
The most tedious thing is I/O error handling to me. I quit node.js because async I/O was a pain in the ass with all the callbacks and promises, yet after JS got async/await which have support for error as value AND exceptions I found it much more pleasant to work with (Typescript) than the 50 if err=nil{...} in every request handler I was writing in Go. Yes, errors as value are great but no, sometimes you just want to do 50 I/O operations and only handle errors at a single spot because there is nothing more that can be done. Furthermore async functions do work like error as value. If I write : const foo = async function(){return Promise.reject(new Error("failed"))} I did not throw an error in my code, I can choose to do `foo().catch(e=&gt;console.log(e))` in the client code, without using a single exception handler, the error was handled as a value. I also think Go should be more lenient with type conversion rules. For instance if a function takes []interface{}, then it should also accept []int or []string. It sounds like a no brainer to me. Or just add tagged unions to the language. I don't even want generics... 
Yes absolutely a big plus too
&gt;Where Go and JSON do the worst is when the JSON uses different types, e.g., {"x": 1} and {"x": "hello"} are both valid in your format. That's not really a Go problem, it's a problem all the static languages have in one form or another, and I consider that sloppy JSON and a bad idea anyway, precisely for that reason. That said, there are still ways to deal with it even so, they just get less convenient. Union types solve this on typed languages.
Not in the slides, but they link to the [GitHub 1.12 milestone][1] which does include a [TLS 1.3 issue][2]. [1]: https://github.com/golang/go/issues?q=is:issue+milestone:Go1.12 [2]: https://github.com/golang/go/issues/9671
Yes, you are right, the extra_config is the additional configuration for non-core functionality. The gateway (KrakenD Community) is based on the KrakenD framework. The framework core takes only the pure gateway responsibilities, while the rest of the middlewares/plugins included in the KrakenD-CE extend the basic functionality. It's actually a pretty good design IMHO.
Ah, I see. That's where the contrived `func drivePassengerToLocation(Car)` example comes in, that's the bit that asks for a Car Interface. Let's look at the real life `mux.Handle()` method. If we look at the signature `mux.Handle(pattern string, handler Handler)` it asks for: `pattern string` which is met by any string, that it will treat as a pattern and more importantly... `handle Handler` which is anything that obeys the rules of the Handler interface, which we looked at earlier, and is: type Handler interface { ServeHTTP(ResponseWriter, *Request) } Remember that an interface is a set of rules, or a contract. Using them lets you ask for an implementation that follows those rules, without explicitly saying how they have to do that. In our Home example, we returned a responseWriter with a "This is my homepage" byte, but we could've done whatever we liked really. The import thing is that the mux.Handle was looking for something that had a ServeHttp method because it NEEDS to call that. Our Home struct has that, so it's all good. In our `drivePassengerToLocation()` example, we want a Car, which we said means it drives (has a drive() method) but we don't care how it drives. Fast? Slow? Scenic? Direct? Our code doesn't care, but it does NEED to call a drive() method, so we ask for something that follows our rules (defined by our Car Interface). &amp;#x200B; &amp;#x200B;
could add: [https://github.com/golang/go/issues/27218](https://github.com/golang/go/issues/27218) which needs documentation but is otherwise submitted for go1.12.
Union types are a consistently useful thing especially in serialization/deserialization and lack of language support is often quite a bummer. They most come with a lot of complexity, implementation or otherwise. 
It doesn't "solve" it. It lets you _deal_ with it, but it's still very _annoying_ to have a field that may be an int, or maybe a string, or maybe an object, or maybe an array of objects, compared to something that is just a string no matter what. It's much better for all languages to treat your JSON as if it's being generated by a very simple, static schema, even if you're in a dynamic language.
My buddy made [this one](https://github.com/AlecAivazis/survey) and it seems to be pretty popular. He just told me inquirer was his inspiration 
Thanks will check it out
Not mobile friendly. :(
good bot
Thank you, MatthiasLuft, for voting on WhyNotCollegeBoard. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://botrank.pastimes.eu/). *** ^(Even if I don't reply to your comment, I'm still listening for votes. Check the webpage to see if your vote registered!)
In Go, interfaces are mainly for use by functions. The function(s) contain the logic to act on a specific interface. Whoever writes the logic function writes the interface. Sometimes that's an already-existing interface, sometimes it's a new one. Look at the `io` package. `ioutil.ReadAll` takes any `io.Reader`. It could be a file, it could be a network connection, it could be the body of an http request... that function doesn't care, it just sucks all the data out until `Read` returns an error, and gives you a slice of bytes read. ``` type Walker interface { Walk(miles int) } func LongWalk(w Walker) { w.Walk(500) w.Walk(500) } ``` The Walker interface tells your function what methods that value will have, so that your code can know what methods it is allowed to call. In this case, the Walker interface only exists because LongWalk wants to be able to Walk someone 500 miles and then walk them 500 more. It doesn't make any sense for there to be base functionality here. The functionality *is* LongWalk. If you want error handling etc, that belongs in LongWalk. Interfaces allow you to share code between implementations of values that you don't even know exist. Like, pretend LongWalk was a 100 line function. Your library can export this function, and anyone who wants to use that logic with their own type can pass in their own implementation of an object with a Walk(miles int) function on it. At work we made an interface that could take either a sql.Tx (transaction) or a sql.DB (database connection). That way you can group function calls that talk to the database inside a transaction or as one-off calls. 
[This](https://github.com/manifoldco/promptui) one looks like what you'd want, but I haven't used it
Thank you, this is tremendous help! &amp;#x200B; This is my full code now: &amp;#x200B; ` package main import ( "fmt" //"os" "syscall" ) var ( powerMeter,_ = syscall.LoadLibrary("mcl_pm64.dll") openSensor,_ = syscall.GetProcAddress(powerMeter, "Open_Sensor") ) func main() { ret,_, err := syscall.Syscall(uintptr(openSensor), uintptr(0), uintptr(0), uintptr(0), uintptr(0)) if err != 0 { fmt.Println(err) } fmt.Println(ret) } This is causing the following error: `Exception 0xc0000005 0x8 0x0 0x0 PC=0x0 syscall.Syscall(0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0) C:/Go/src/runtime/syscall_windows.go:172 +0xf9 main.main() C:/Users/j.haugum/Documents/hello.go:17 +0x45 rax 0x0 rbx 0x55b7c8 rcx 0x0 rdi 0x295000 rsi 0xc00007df30 rbp 0xc00007dee0 rsp 0x77fe38 r8 0x0 r9 0x0 r10 0xc00001c5d0 r11 0x1 r12 0x782921 r13 0x4af980 r14 0x0 r15 0x0 rip 0x0 rflags 0x10297 cs 0x33 fs 0x53 gs 0x2b exit status 2` This seems to be related to a null pointer being returned. Now, I never define the USB device as an object anywhere, or refer to it when calling the method that should be communicating with the USB device. I know that the way they do this in C# is to define the USB device as an object like this: `_power_meter = new usb_pm();`, where `usb_pm()` is defined in the DLL. I imagine something similar has to be done in Go before it can be used (if it can be used they way I want to at all).
I played Gold for years as a kid -- can confirm it's just a silhouette.
This part. Kinda hiding a lot of complexity there. "Use context values only for request-scoped data that transits // processes and API boundaries, not for passing optional parameters to // functions."
Not Chrome friendly either. Locked Chrome up for seconds while it pegged the CPU each time I moved to next slide. Switched to Firefox and it worked fine. 
Oh my God this was the most frustrating experience on mobile ever - not even zoom
I would add though that proper union types can be type checked at compile time, and `switch`ing over them can be checked for exhaustion.
'context.businesslogic()' That's not what context is for.
https://github.com/twitchtv/twirp might be another, http protocols based option
Ops, thank you for your notice, I've updated it.
It's awful even when not on mobile...
You may enjoy reading https://eev.ee/everything/tags/cheezball-rising/ which goes into considerable detail about how Game Boy games work.
I really appreciate your continued help. `dumpbin /exports` yields the following results: ```C:\Users\Jo-Work\Downloads\mcl_pm64_dll&gt;dumpbin /exports mcl_pm64.dll Microsoft (R) COFF/PE Dumper Version 14.15.26730.0 Copyright (C) Microsoft Corporation. All rights reserved. Dump of file mcl_pm64.dll File Type: DLL Summary 2000 .reloc 2000 .rsrc 2000 .sdata 14000 .text
&gt; the code using a union type and a Go interface{} looks virtually identical. only if you don't give a fuck about type safety a function with an int|string type parameter wouldn't let you pass an array.
In _this specific context_, it's not a huge difference. Even if you unmarshal some JSON into a `int|string` type, you still have to handle the case where it was an array instead. Union types give you a lot of safety once the data has been passed through the serialization barrier and allowed into the innards of your code, but _at_ the serialization barrier, if you're going to have to handle a JSON value that may be any JSON type, you can't do that by just declaring a `int|string`. You're going to have to handle the case where it still isn't either of those things. And if you actually _write that out_, in both Go and a language with union types, you'll find they don't come out _all_ that different. Where there is a much bigger difference is when you're in the trusted portion of your code, where you can provide guarantees on values that Go can't even remotely express. But in _this specific context_, it's not that big a difference.
I want to clarify that the suggestions were "*don't do this*, but if you insist, this is as close as you're going to get."