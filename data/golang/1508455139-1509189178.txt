[removed]
My understanding is that it’s integrated into the platform.
Maybe as an addendum, or a link out to a seperate gist or StackOverflow question or something. I agree, it is kinda fringe, but a real pain when you need to make it work.
Psh that’s cosmetic. How about managing versioned dev tools like gox, gometalinter, and shit so that stuff stops breaking on new master commits
Who thought "ensure" was a good name?
I ask myself the same thing. But it works so...
The whole interface is just weird and confusing. Feels very non-go-ish
You are really hung up on one point of mine, and don't seem to have thought about any of the others. I find in practice that I can use Go as only slightly more verbose than a scripting language like Python, rather than being 5-10 times the line count as in Python vs. C. "Can I create a REPL with it?" is certainly _a_ fine criterion for "is it a scripting language?" But it is only _a_ criterion, not _the_ criterion. A _lot_ of the conversation about "scripting languages" back in the 90s and early 2000s was about code size. For one thing, you just confidently gave me "the" definition of scripting language... which excludes Perl. It doesn't have an official REPL, nor am I aware of a very good one. It may be a good definition for you, but I think you'd find a definition of "scripting language" that excludes Perl is not going to be universally agreed upon. (If I could give myself a single epigramic law based on my name, Jerf's Law would be "There exists no programming term whose meaning is agreed upon in all programming language communities.")
&gt; If producing a viable interpreter for a language requires a new dialect and/or alternate spec, it's absolutely not a scripting language. I'm not sure how to put that definition into any meaningful practice. There are interpreters for C, for instance. Compilers are generally harder than interpreters; anything that has a compiler can have an interpreter for it fairly trivially, it's going the other way that is hard. Do you mean REPL? If so, bear in mind that would eliminate Perl as a scripting language; that seems a definition not likely to attain universal acclaim.
[removed]
Add json tags with `omitempty`
I wondered the same thing. It is mentioned in the FAQ. Seems like decent reasoning to me. https://github.com/golang/dep/blob/master/docs/FAQ.md#why-is-it-dep-ensure-instead-of-dep-install
Just stop using `go get` if you use `dep`. It's simple.
I still don't get why it can't be install. Seems like implementation details bleeding into the interface.
I am confused, there is no "bc" code in Go here. The entire thing is (hopefully just) some weird virtual machine to run a real Gnu bc. Why? Why does the github summary/whatever not make that clearer? And most importantly, why post it here? 
still not a very good name. sometimes when you're working really hard to get mediocre results, it's a sign you need take a break / get some distance / wait for inspiration.
I'd check out /r/dailyprogrammer, project Euler, or code fights. All provide great puzzles to solve that can greatly improve your skills while also preparing you for white board interviews in the future
dep developers made many (IMO) bad choices, this is last thing I would complaint about it.
Still useless of it can't hit GH enterprise or anything not GitHub.com
There is already an open pull request since some hours. I have to review and merge it. It was one of the first things on it since I've hacked it together. Note: I hacked it together to a fully functional client in less than a day. So you can imagine that not everythign is perferct. But we are nearly there :D
We will use the integrated unzip package from the core lib.
You are right, @u/PaulCapestany. I work at PingCAP. About your questions: &gt; Do you all have info about whether all of TiDB will always remain open source? The answer is definitely “Yes”! Personally, that’s one of the great things that attract me about PingCAP and TiDB. I have a long and interesting story with PingCAP. We can discuss more later :) &gt; And/or how PingCAP plans to make money? I am sure you must have heard the news that we got $15M in Series B in June. The funding will be used for product development and expansion to the US community and the market. We value community very much and it is our first big step. We’ve built partnerships with some of the biggest cloud vendors in China, including Tencent cloud and Ucloud, and we are also planning to work with Global cloud vendors. Besides the founding from investment, we also have paid customers from 30+ companies in the APAC region, including Mobike, Gaea, YOUZU, etc. PingCAP is growing very fast and we need talents! 
*and* if your json substreams are not enveloped. If they're e.g. length-prefixed, you can make an io.Reader that only contains the json message.
This project looks really cool, but the naming is kind of unfortunate. There's a pretty popular, but deprecated project by CoreOS named [fleet](https://github.com/coreos/fleet).
★ Nothing about it is ultimate ★
this is needed so badly...especially for code generators. Two developers running two different versions can easily step on each others toes. And different projects may expect different versions of the same generator.
&gt; I am confused, there is no "bc" code in Go here. The entire thing is (hopefully just) some weird virtual machine to run a real Gnu bc. The answer seems to be in generator_linux.go. (And in cznic/virtual and cznic/assets.) &gt; Why? Honestly, I have no idea. Maybe just what the headline says: JFF. &gt; why post it here? Why not? It is Go code, and this is a Go subreddit.
After seeing the FAQ, i still think "ensure" is not a good name.
Here it is: https://github.com/mstruebing/tldr/releases/tag/v1.0.4
Here it is: https://github.com/mstruebing/tldr/releases/tag/v1.0.4
I think you could improve the Constants like this https://github.com/gempir/go-twitch-irc/blob/d5f69597dac2104550e3dc9beed1666135cf3ef4/message.go#L14
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/full360] [fleet - osquery server built with go and go-kit : golang](https://np.reddit.com/r/full360/comments/77jzt4/fleet_osquery_server_built_with_go_and_gokit/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Looks fine overall. Here's your [report card](https://goreportcard.com/report/github.com/STAR-ZERO/tumbling) with a few things you can fix. A few nitpicks: * The language's name is Go, not golang. * Your folder `lib` should probably be renamed to `tumbling`. * You are importing a huge dependency `cli` (~7.5k loc) while your project is small (~200 loc).
I'm sorry, but I can't take anyone who thinks that = is a better default for the manifest than ^ seriously. Everyone I've ever talked to with that mentality didn't understand either server or lockfiles.
I haven't been paying a lot of attention to Go lately, this is the first I'm hearing about `dep`. How does it compare to something like pip or cargo?
I'll try. Thanks you for your advice.
For generators I try very hard to make them usable as libraries, then invoke them from a generate.go file in my repo. That way I can vendor them as library dependencies. I have had to submit PRs to a few projects now to break the core functionality into a library, but it is pretty nice once its done like that. Another reason to always always make main as small as possible.
yeah, you can do something like import _ "github.com/me/mygenerator/lib" and go dep would pick it up. It'd still be nice if it could natively manage build tools. Bonus points if it could go install them to vendor/bin or something. Otherwise, we're stuck with makefiles or having to build them as part of a go:generate statement. Not holding my breath, though. 
Try to keep the context. My original question, citing &gt; Is go get and go dep integration planned? To solve the issue I have encountered.
Can you check out [virtualgo](https://github.com/GetStream/vg), which is a wrapper around dep and see if that solves the issue? This might be more of a problem relates to vendoring than to dep. Virtualgo moves the vendor directory to an isolated GOPATH, so if that's the case it should fix it. Also please file a bug report to dep on this. 
You should try out [virtualgo](https://github.com/GetStream/vg), which is a small wrapper around dep. This problem is one of the main reasons I created it. It's also mentioned in de dep docs as the current solution for this. 
It can natively manage the sources for them using the required key in Gopkg.toml. If you want them actually installed and in your PATH, check out [virtualgo](https://github.com/GetStream/vg), which is a small wrapper around dep. This problem is one of the main reasons I created it. 
Are you sure it can't? I think either just importing with the different domain should work. Or otherwise use the "source" key inside Gopkg.toml. 
You should probably take a look at [virtualgo](https://github.com/GetStream/vg), which is a small wrapper around dep. One of its features is that it moves the vendor directory to a project specific GOPATH. 
I made a little utility to do a similar thing that I just call an `ErrorCollection`. You add errors to it, and then check them all at once later at some point. The difference being you don't need the signature to be `func() error` for it to work, you can return multiple values. It's usage looks like this, and the implementation is pretty obvious: foo, err1 := fetchFoo() bar, err2 := fetchBar() errs := errutil.NewErrorCollection() errs.Add(err1) errs.Add(err2) if !errs.Empty() { return entry, errs.Errors() } You can still use it in a shorter way if you are only returning errors though too: errs := errutil.NewErrorCollection() errs.Add(errors.New("foo")) errs.Add(errors.New("bar")) if !errs.Empty() { return entry, errs.Errors() } And it can format the errors at the end nicely so that they come out one after the other on new lines (or maybe if you wanted you could just pass something into the `Errors()` method to control that).
For some time ago, I wanted to make a demo of the CI in gitlab, for go projects. I works partly, but i never finished it, or announced it. You can see it at https://gitlab.com/kjell/go-gitlab-ci-template As long as you have the .gitlab-ci.yml - it will run.
Don't use words in this case, use different http methods: GET, POST, PUT, PATCH and DELETE design on if you want to get data, add data, update or delete.
It's basically something very akin to Rust's Cargo or Ruby's Bundler. I've used it at work for a couple of small projects and so far it's been all right.
https://groups.google.com/forum/#!searchin/golang-nuts/dep$20source|sort:date/golang-nuts/RvR-Tv043w4/HdJtegCUCAAJ
What's the use cases they have in mind for this?
I don't understand the downvotes on above comment. Seems to be a reasonable answer.
&gt; Please stop with these infomercial posts If anything, someone who was previously using Python would be among the *least* likely to make an informercial post.
And how do I go with option 2? AFAIK, `dep` uses the option (1) and I don't know any tools for the second.
If you're creating a package that you can "go get", then yes. But this way you can have multiple services (described in *docker-compose.yaml*), each in its own subdirectory.
I raised an issue about that because I really hate it too.
We use self hosted gitlab at work, we use a lot of the CI tools it provides to build containers and deploy on GCP, I think it's a great solution 
Nitpick: Go's styling prefers CamelCase for constants. As this is the style used almost everywhere(*) in the standard library. *) Exceptions being the `os.O_CREATE` values and friends. These are taken directly from POSIX.
Great post! I would add a note about one thing though. The article's manual implementation of the `String()` method indexes the `names` array, without ensuring the `day` value is in range. It should probably be made clear that Go does not, in any way, ensure that `day` can only contain an existing constant value. It could just as well be assigned 9999. In which case, the call to String() will panic.
Hi there, Nice project. We made a similar attempt albeit only targeting hot-reloading in a docker-container. https://github.com/dkfbasel/hot-reload 
I still have issues related to using dep in a private network with limited external access via proxy. There doesn't seem to be a way to get dep to work when internal constraints have to be accessed without the proxy and external constraints with the proxy. Dep always wants to hit all of the http endpoints. Apparently it is just a known issue since responses to my questions have suggested that specifying "source" doesn't remove the need to always hit the endpoints. I still have to stick with glide at work.
But source cannot be a file path isn'it ? Can we use hgweb or gogs ? I'd like to see examples like that.
Even though I know all of the stuff, it's still very pleasing to read through the article just for the aesthetics!
It works with works. Doesn't work with not GitHub enterprise repos. For example internal GitHub enterprise
Very sure. There is an issue on the GH repo. It's why we still use glide. The issue isn't forks, it's when the repo isn't GitHub.com. 
Thank you! Yes, I’m aware of that, I’m trying to keep things simple but, yes that should have been noted! I’ll update that part. Thx!
Thx! Sorry, I didn’t understand how can I improve them from your link. Can you explain?
👾 I loved to hear this!
Hmm, yes, that would be simpler, as a reference without bloating things up. Thx!
I tried out a few solutions for doing this, I only found one that works reliably: https://github.com/achiku/wbs It's not tied to a particular file type, or a particular function (like it being a web server or something), so it's useful in other projects too if you just want to run some command when some files change. I do think it could be a little simpler for that purpose, and some of the config key names are a little more Go specific than I'd like, but maybe I'll fork it some day to change those things.
Probably for quick, lightweight apps with an HA goal but not enough code to be worth the complexity of other database solutions. I know I am running PowerDNS in my lab which supports sqlite as a storage backend (enabling a management UI). I wanted to just deploy 3 or 4 servers so there is redundancy for the entire setup but using MySQL/Postgres and achieving a multimaster failover enabled setup is a fair amount of manual config. This could allow me to just deploy 3 servers, have this as the backend, then all the failover, HA, etc is pushed into the DB and handled via the LB. Maybe one solution? A lab DNS config is 99% read so no care on the tech, just want it easy to manage.
Last I used the main sqlite package, I did not experience this. 
I've updated the article.
[Product placement?](https://ensure.com)
right, it has problems with complex vcs urls: https://github.com/golang/dep/issues/411
Yeah we had some lengthy convos with Sam. It's just not a high priority for them before other features. We actually are deploying our own [go vanity](https://github.com/dominikh/go-vanity) because then dep will work. 
I am just going on a 100% whim here -- but I think it's because a lot of go devs came from python and still have the horrors of virtualenv fresh in their minds
But, right now there are no multiple services, so it's not necessary to put them into the api folder. You can easily refer to '.' instead of api.
&gt; why post it here? I think it is more interesting than a new web framework in Go everyday thing which invariably lands up here.
and right above you say that ``go get`` isn't awared of ``dep``. This is my explanation to that. To workaround the issue you have encountered I suggested using alias.
You're right. I just chose to do it that way.
That's fair.
Are there maintained libraries for Go clients? I didn't see anything better than alpha state with a year of neglect.
Oh sorry, I think the parent diagram is wrong. The vendor/ for should be at the same level as project1 and project2.
Shovel’s tips are dumb. Thanks for posting your project!
You're right. I fixed it.
Agreed, the Go client library story is not in great shape. rqlite exposes a HTTP API however which makes it very easy to write your own, in any language. I've spent most of my time working on the core database.
Does anyone know if there's a plan to add a `dep get` command? That would solve the problem from the other direction while we wait for `go dep` to exist.
Here this explains it very well https://splice.com/blog/iota-elegant-constants-golang/
Really nice! I'm working on https://takeoff.sh/ and I wanted to include a Go blueprint, but didn't yet because I wasn't sure hot loading would be available. If this supports docker then I'll look at adding one
Not using dep because of a minor dispute about an easily worked around syntax question is silly. If you read through the issue comments, the dep maintainers have a perfectly logical reason for making the defaults what they are. There's no reason to be sore about it when all you need to do is add an equal sign when you need to lock the version down.
Which part?
I don't think so: [it uses `github.com/BurntSushi/xgb`](https://godoc.org/golang.org/x/exp/shiny/vendor/github.com/BurntSushi/xgb) which IMO is a pure Go implementation of the X protocol (generated from the spec).
You are assigning like 1 2 3 manually to the constant but the more go-esque way would be to use iota 
Pip is a tire fire, so it's better than that. :-)
No! That’s the entrance part. Scroll below. I explain iota there. The first was about the motivation behind how enums work wihout iota and why we need it.
Oh I'm sorry I'm on mobile and didn't notice that. Nevermind then :) 
Yeah I agree. I still dislike that convention but if the Std library uses it you should probably adopt it aswell 
No problem! This was a good feedback for me. I put a reminder to the top to let people know that I’m deliberately not explaining iota and stringer at first.
tl;dr Uses runtime.Stack() to get a stack trace into a buffer and then parse out the goroutine number. It's all used behind a DEBUG check, but still.
https://blog.sgmansfield.com/2015/12/goroutine-ids/
Just can't understand why golang is so obsessed on preventing people using it. At least, it's really useful for debugging.
&gt; And in cznic/virtual Yeh, this seems interesting and non-trivial. Would have been cool to post that here and we could talk about it.
Well sadly I actually gave up on this. I will have to check how I bypassed the banner, but I'm not sure it's a good idea because I got stuck right after, and It might have been caused by me bypassing the banner. I switched to C# + WinSCP and got it working right away. :S
Non-sarcastic question, why do you need this?
https://github.com/tylerb/gls As mentioned in the readme. I have the same use case.
It's a github-API client, not a git-replacement. In theory, you can basically manually implement git-clone on top of it, reading one file after the other, walking the repository… But really, you should just use `exec.Command("git", "clone", url)`. Or at least use some other package that actually tries to implement git.
As the author clearly states in his readme. This is the lazy way to do it. If you use goroutineID outside of debugging, you will go straight to H(ask)ELL!
Well. Then. Java programmers are all in hell already.
Ok, good luck.
Thx for your detailed feedback. The unzip dependency is already eliminated and the archive/zip package of the golang core is used now. I now call filepath.Abs on the homedir like this: https://github.com/mstruebing/tldr/commit/9f9ab8ca586a3878c66f34a936219d0770ca6c22 
Regarding the zip download - it's the official way from their site for a client. see here: https://github.com/tldr-pages/tldr/issues/1065#issuecomment-251053184 I want to let this client go into the official tldr namespace. if its in there I think I can make some noise to change this.
It most likely isn't planned, much like awk and sed "integration" isn't planned. They're fundamentally different tools. go get - downloads/builds/installs a go package from a remote repo into your $GOPATH dep - downloads and *vendors* your project's *dependencies* under your project's tree. If you're mixing the two concepts, or think one should replace the other, you're just not understanding the use case for vendoring or for tools that enable that. 
That works for writing JSON without empty fields, but I think the pointer is the right solution for detecting empty fields when reading JSON.
Simple project that highlights using Viper/Cobra and response to SIG_TERM and SIG_HUP signals.
Nice! Some time ago I wrote Tumblr downloader too in Go, to learn about go routine and channel. It can parallel download all image and video without api key. Here is the source code: https://github.com/simukti/tmd
[removed]
My intention is to break execution flow, so I would skip fetchBar or some latter function calls. Think 'if func1() &amp;&amp; func2()' - if func1 would return false, func2 will never be invoked. Same thing but with errors, because we care about specifics and not just a true/false return
Java Programmers: In hell since May 23, 1995
I have a use case where I'd like to gob.Decode a struct that contains things that implement encoding.BinaryMarshaler, and I have some context that I'd like to pass into the BinaryMarshaler. There is no way to do that. So instead I wrap a lock around the entire function, and when a user takes the lock, they also set the context into a global variable shielded by that variable, and the unmarshal code can then find what they need. Fortunately, for various reasons, I don't really need multiple cores running this at once as there is a bottleneck elsewhere that prevents that. But it would still be cleaner if I could pass contexts into functions that implement interfaces that don't currently take contexts. (In this case, I don't strictly speaking mean the Context package's Context, though that would be an option.) I actually don't need the goroutine ID per se; I just need some mechanism to attach a thing to the goroutine itself and then get it back out.
+1 to this. Having had to do something similar recently, if you are dealing with Github-isms (PRs, Issues, Teams, Status checks, etc) use go-github. If you're dealing with classical git actions (pulling, committing, pushing, etc) just use vanilla Git. In the event that you have to do low-level Git object graph manipulations, you can use go-github, but I would avoid that entire problem space if possible...
Strange way to justify one's code. Just because somebody else is doing something, does not mean you have to do it too.
A way to attach something to a goroutine is to turn it into a variable inside the function running on that goroutine. This "something" can be passed to the goroutine via the function's formal parameters or, say, sent to it via a channel. To may be make this more clear, a live goroutine references all the variables the function running on it has access to—that is, allocated itself or closed over at its creation time.
Looks like you need [profiler labels](https://rakyll.org/profiler-labels/). Even w/o them, you can use a `context.Context` to carry this information over.
I'm interested in where you're heading with this as I'm not sure how I'd make use of the map you're providing here. Where would you plan to use this type of library in a Go app?
[removed]
I didn't test, but won't this make e.g. `^Z` reload the application? I'm not sure if assuming that all non-SIGINT and SIGTERM signals is SIGHUP is a good idea :-)
You say that but I've never had any issues. NPM is a tire fire in my experience.
This really seems like a re-invention of the wheel. The problem of having to redeploy / reload an app has been around since the dawn of the server. These days we let [chef](https://www.chef.io/) or [saltstack](https://saltstack.com/) take care of the work for us. If that's too heavyweight for you, you can script something in ansible. If that's still too much, there's always bash... one can watch a file and reload a service on change with just one line of bash.
Go plugins aren't that convenient, it doesn't mean the version as in the commit or even if the source is exactly the same. Version refers to the compiled version of the package code stored in ~/go/pkg so you can only use plugins built on the same host and basically the same time.
This is absolutely awesome. I'm definitely going to use this in my own crypto project.
I'm not sore. I just see this counter-intuitive syntax as a potential ticking bomb this early into the adoption cycle - I fully expect some dependency down the tree fail because of it. If the syntax changes or dep is around long enough for everything that was bound to fail because of it to fail I will start using it.
[removed]
That signal isn't firing the interrupt so you are ok.
[removed]
Bite the bullet and pass a context. Sorry.
At least hell has generics and exceptions
No, it can't. I can't control how gob.Decode works, nor can I control the parameters that [UnmarshalBinary](https://golang.org/pkg/encoding/#BinaryMarshaler) takes, which is the function that needs this context. There is no closure path to pass this in, because gob.Decode directly uses reflect to create objects; gob.Decode doesn't have a `func(i *interface{})` or something that gets run after an object is created to allow you to introspect and modify it or something. There is no path to get from the code invoking gob.Decode that I can see. If I am wrong, I'd love to know. Your task, should you choose to accept it, is to fix up [this playground snippet](https://play.golang.org/p/JLrN02OC9c) to transmit the `x = 5` value into the UnmarshalBinary function. Note that in my real code, I am receiving a heterogeneous list of unknown length of interface values. You might be tempted to try to initialize the Outer's Inner value with the 5 to pass it in. However, along with the fact that doesn't work (I checked), it also wouldn't help me in my real code case. That said, if you did find some way to at least do that, I'd still happily give out internet points. The other problem I have is that _arbitrary_ structs containing the type I need to UnmarshalBinary come in; it's end-user extensible. I have considered a reflect-based solution that recursively walks the incoming data looking for addresses to fix it up after the fact, but this is very likely to be a performance-sensitive bit of the code. I could also require anyone who uses these values to implement a way of presenting them so they could be fixed up after the fact, but that's going to be fairly inconvenient to the end-user too. In my real code, I'm not trying to cross package boundaries, so if that helps you can use it.
So, could the http2 package make use of this instead of the current hack?
Well for starters, it doesn't necessarily install anything.
Attaching the executable wouldn't work because it would be the executable for whatever system you were using when you attached it-- once you moved to a different platform it wouldn't run on said platform. (Granted, if that's not a concern of yours, or if you want to provide multiple binaries, this works) Anything else I can think of either 1. requires that your user already has what you are calling out to installed (which you can provide instructions for how to install) or 2. requires a port of the utility in Go. 
I haven't looked into other OS's, but I highly suspect this is possible in Windows. I think the approach is to statically link it w/ linker flags. Then get the current process's hmodule and do a getprocaddress and work from there. I'm sure other platforms will also let you statically link and resolve function pointers, I just haven't tried.
A madlib: Why golang refuse to provide &lt;feature&gt;, but get to have it for themselves? &lt;feature&gt; can be type-specific containers, goroutine IDs, etc. It comes down to exposure caution. I don't agree with it, but the language maintainers think if it can't be done right or there are large enough caveats, you can't be trusted with the capability.
Of course they are. Why create a new language just to repeat all past mistakes in it?
You can definitely bundle non-executable data, such as images and html templates. We use https://github.com/jteeuwen/go-bindata to include images in a load test client. Including _executable_ binaries is really interesting, I haven't heard it done before. Let us know what you find.
I think the real reason is that `go install` is already taken, and if dep was to be merged into the toolchain this this would be a conflict. So the authors envision the integration to be `go ensure`. The thing they don't understand is that it won't get merged into the toolchain if no-one uses/likes it. Maybe instead of focusing so much on the future, make something that people want to use now.
Perhaps there's a different way to solve the problem you're trying to solve but... if you need really the data in that function, I'd probably prepend it to the byte slice and decode that bit first before decoding the rest using the value you prepended. My need for thread id was to use it for thread local storage (to implement something similar to what we do in Ruby). At the end of the day I settled on a package level global map keyed by an application level value (an database id) and it works well enough.
I've been writing servers in go since the day it went public. I've written several production systems and concurrency toolkits. It's never been a thing I felt I needed. Similarly, someone came into #haskell-beginners recently asking how we log from within functions without turning them all into io actions (where side effects are allowed). We couldn't get very concrete because the person with the question didn't have a problem, but a strategy for solving problems he felt he'd be lost without. If you do things idiomatically, you struggle a lot less.
This looks really cool. I just recently started looking into OpenFaas, so I am trying to see how this compares. Seems Nuclio adds extra concepts like the event sources and brokers. Openfaas functions are just generic executables that accept stdin (if I understand correctly) and its CLI gives you template commands to say write a handler in Python and have it built properly. Nuclio looks like you write functions in one of the supported SDK languages. It refers to being able to write shell scripts or precompiled binaries but I didn't find an example. Anyone have a better comparison? 
Aah okay, that does make sense - yeah. I suppose with that interface you could always wrap a function in a closure to avoid the issues I'd mentioned too.
Couldn't he just refactor his code and make is `http.Handler` functions methods attached to his app object? i.e. func (a *App) AboutPage(w http.ResponseWriter, r *http.Request) The function signatures of the endpoints can be "standard lib vanilla" and you can stick extra things on that `*App` object. Or find a similar way to shuffle your functions around to get a "request global context" of some sort that doesn't involve changing method signatures. Or am I missing part of the problem?
Interesting and kind of scary... I'm going to do some testing to verify this. My thinking was my issue would be resolved with https://go-review.googlesource.com/c/go/+/63693 and I might need to back port it to Go 1.8.3. Is your statement above from experince or is there documentation that says the same? (couldn't find any).
[removed]
Speaking from my own experience of trying to achieve something similar, I don't know the specifics of why however 
Not sure why you were downvoted for this, but you're spot on.
Be careful with attaching executables to your binary because when they're unpacked on a target system you might trip the antivirus.
I can't talk about bundling, but keep in mind that portable binaries aren't unique to Go. You can statically link most C binaries to nearly or the same extent as Go, assuming you have non shared versions of your dependencies on your compile system. They'll be just as portable as Go binaries, which are only portable between same GOOS, same GOARCH. There's nothing particularly magical about what Go does, except that it's the default, not the exception. And cross compiling is usually hella easier.
Kinda already exists for many years though: https://github.com/btcsuite/btcutil/blob/master/base58/base58check.go
same as generics. same as macros. my favorite summary is http://nomad.so/2015/03/why-gos-design-is-a-disservice-to-intelligent-programmers/
If you use the C api instead of wrapping the CLI, you could statically link libavcodec, etc...
I don't get the anger. Apparently you feel like you "caught" the Go team doing something. If you have one of the rare use cases for goroutine ID or TLS, it's obviously possible to implement. However clearly the Go team feels it's generally a bad idea and leads to bad design choices, so they don't feel any need to make it convenient or advertise its use. What's the problem?
dep get would just be git clone. 
Who cares what it's called? Ensure is a perfectly valid word for what the command does. Install, to me, means something different than "copy some code to a local folder". install means "make a binary and put it some where", which dep absolutely does not do. Ensure is "ensure this project's dependencies are in a valid state, in the vendor dir, and the dependency metadata files are correct". 
So, using the unlicense is going to make your code unusable for some people. I've heard multiple people say that their company's legal team doesn't consider it a "real" license, and therefore they can't use libraries that use it. Why not MIT? MIT is about the most open standard license you can use. It's basically just "dude, do what you want, but give me some credit for writing this". I make most of my libraries MIT. And MIT is a well known and accepted license.
It would be good to know how this differs from Viper, what pain points you were solving. Probably a useful section to put in the Readme.
I've been using MIT mostly before too. I would prefer code I write to be public domain though, but yeah maybe you're right in that it might ultimately make it harder for people to use it. 
It's kinda in there though. Viper's support for marshaling into a structure just doesn't work and it requires a ton of unintuitive calls to get f.e. environment variables to work.
Its because go is the best choice both me and my coleages write that fits the job. I really didnt like it after a few projects. I’ve switched to other language but sometimes I still need ‘go’ back to get the shit down. I felt that after I get rid of it I will not need to care about what the go team forces their users to do any more. They are not wrong at designing it. Maybe its just because the tool doesnt fit me.
How were you able to set this up in another language?
Oh, right. I see you're using `signal.Notify(sig, syscall.SIGINT, syscall.SIGHUP, syscall.SIGTERM)` Personally I would still just use `case syscall.SIGHUP:`; it's a lot clearer than `default:` and you would be able to get rid of that comment too :-)
It will be abused, better to not have it to satisfy a few extreme corner cases.
It’s analogy. Depending on how your system runs. With multi threading, you use thread id to build thread local storage. With multi processes, just use global variable when you need it. I just wonder why go didn't ban global variable because it's easy to abuse too.
Global variable (process local) is easy to be abused too, better not to have it,
What's the deference becides it requires more code? Does context.Context brings the context explicit? I don't think so. All it exposes are it's interface methods, not really making things clear.
Don't be sorry
Almost every language has them and idk why. I guess those really rare use cases. But everyone knows not to use globals. That's like programming 101. I think they didn't use goroutine ids cause it would turn into a mess the bigger the project. That's kinda the point of go.
Perhaps this tried and true package can give you some further leads: https://github.com/robfig/cron In particular: https://github.com/robfig/cron/blob/master/constantdelay.go
Wow, that package has immaculate godocs, but nothing in the README
Almost exactly what I needed (submitted one pull request and one issue). Thanks!!!! 
Awesome, I had need for a spf resolver/checker a while ago, and started making one, but never ended up finishing it. Once you get outside of IP addresses and includes, there's some crazy stuff you can do. Have you seen http://www.openspf.org/Test_Suite? I think a go package that passes that would be really valuable. 
Thanks, but that didn't solve the problem of being run on the minute every minute. This did however. Just like regular cron. c := cron.New() c.AddFunc("1 * * * * *", HealthCheck) c.Start()
The time package has a `Truncate` function for this. Something like: nextTime := time.Now().Truncate(time.Minute) for{ nextTime = nextTime.Add(time.Minute) // wait till then or quit }
make it creative commons zero instead of unlicense. it has a generous fallback license.
If he's experienced with Python he should be able to learn Go in a day and write passable production code within 5 days. Assuming you're providing some guidance, and yes I'm taking into account you're not too experienced either. If he doesn't have the drive to learn you're wasting your time; go for something both of you understand or cut the team in half: A single page application for the frontend and a JSON API for the backend, no server-side templating with the index as a possible exception. Good luck.
big.Float or gtfo! neat though.
If he has Exp. With C/C++ he can write passable production code on day 2. Just read the source code to godoc. After reading that you will know most Golan idioms.
Why is Linux not an option? I run windows and just do all my coding in a VM. Linux is just so much nicer than windows for coding...
&gt; Is there a fairly easy way I can develop an interface for our database in Go, and give him access via python whether it returns json, xml, or whatever? You can build a rest API interface to your database, and have your partner build the backend of the data visualization part. So it looks like this: Frontend -&gt; Python -&gt; Go -&gt; DB
but checked exceptions tho...
Have you checked out Eclipse Che? If yes, what are your thoughts about it? It seems similar to what you are doing and I have a friend who mentioned it to me.
Can't agree more. While we're at it, we should also get rid of mutable state and concurrency because they lead to data races. (no, the race-detector doesn't guarantee race-freedom)
Show them this and then code in Go happily together: https://codeburst.io/why-we-switched-from-python-to-go-60c8fd2cb9a9
If you have context that affects how an object should be marshalled, consider putting that context in the object.
You can define a new type and implement the gob.Decoder interface, and do what you want to do in that type's Decode method.
[removed]
Yes, start with Python, iterate fast and when you understand the domain perfectly move to Go.
You could use grpc for connectivity between python and go, and use the protobuf file as your "API contract". Effectively your making microservices. Personally it's worth the setup of grpc because I like the strong typing and compile time knowledge that each end is setup correctly, but if it's a very small app simpler solutions have been suggested by others and may be more well suited. 
Ticking per second, do stuff only on 00 second. Otherwise, skip.
This is it for me. I've never encountered a situation where this would be needed.
I always thought that viper's "configuration with fangs" was kinda funny, because sooner or later you're going to get bitten by one of the problems with it :-)
We solved this generically by modifying our build process to generate RPMs (CentOS) and push them into a local repo. The spec file can dictate where the unpacked files go (e.g. default config files, supplemental binaries, systemd service files,...). We haven't had a need to, but I suspect it would be trivial to include related binaries, assuming they're built on/for the same arch. From the time we tag a git commit, it's ~6 min end-to-end to being available as an update in the target server. (Half of this time is due to our build server polling frequency setting; the other half is waiting for the yum repo cron to index the new package.)
[removed]
I loaded the code, ran the program and my results were not as expected... 
Yeah, except the author of that article now uses Go. ;D
How drunk are you?
It's right at the top. &gt; // Defensive debug-only utility to track that functions run on the &gt; // goroutine that they're supposed to.
Does that means go-coders never need goroutine id for debugging except the go team themself?
&gt; But everyone knows not to use globals. This is what we've been told to. But global variable is actually quite common. It's not that bad. Really. I can find globals in many open source projects. We use it when we really need it. Otherwise a big context needs to be passing around, and it doesn't make much difference except for makeing the code much longer. &gt; I think they didn't use goroutine ids cause it would turn into a mess the bigger the project. That's kinda the point of go. IMO this is not a valid point. Thread/goroutine local is the same thing as global var by analogy. It's just global for thread/goroutine. It turns into a mess only when the developers don't understand the architecture of the project they're working on, and there will be more serious mess no matter whether they use it or not.
[removed]
cron/crontab?
May I suggest to also support hjson (https://hjson.org/) for the config file ? It’s json without the quotes and commas. It’s more natural for humans. The usage is to convert hjson to json. I use it for my project and it’s very convenient. The Go hjson parser doesn’t properly report lines where error occured. So when there is an error, it’s not easy to determine what is wrong. But this could be fixed.
If you really feel that you need for debugging purposes then do as Brad did.
[removed]
https://play.golang.org/p/fFahno03qr ```` package main import ( "fmt" "time" ) func main() { for i := 0; i &lt; 10; i++ { runOn(func() { fmt.Println(time.Now()) }, 1 * time.Second) } } func runOn(f func(), d time.Duration) { now := time.Now() d = now.Add(d).Truncate(d).Sub(now) time.Sleep(d) f() } ````
Nuclio is definitely more advanced than OpenFaaS and fnproject. What I dislike about Nuclio is that it is opinionated in terms of container orchestration: Kubernates only.
[removed]
I have a question very specific to *sql.DB* object. I am developing a web application where I have a package level variable, *DB* of *sql.DB* type. The *sql.Open(...)* call is made from the *init* function of that package and the value is assigned to the package level variable (*DB*). Later I import this package from other packages and execute queries. Is there any issue with this approach? 
I got the sense that Kubernetes is just one implementation of the Controller interface and that others are possible "Controller A controller accepts function and event-source specifications, invokes builders and processors through an orchestration platform (such as Kubernetes), and manages function elasticity, life cycle, and versions." 
Arguably, the point should be that the handler for reading config files from disk should be pluggable rather than building the support directly into the library. I'd like to see HCL support, but I have no problem writing the package to handle the marshalling myself if a proper interface was provided. The options struct in this repo clearly doesn't support that, and it probably should. Then we can all use different half-json DSLs for configuration :D
Using sleep in your code is generally a bad idea..
Looking at the code I doubt there will be any support for anything else but Kubernetes.
Well done. A few things you could try now... * Always check your inputs. For instance, what currently happens if you just enter a single character? * Could you factor out the duplicated code for parsing numbers? * Could you accept expressions like "3 * 4 * 5" * Could you remove the reliance on space-separation? I'd like to be able to enter "2+3" * Could you store the current result, so you could enter "2+3"&lt;return&gt;*4&lt;return&gt;/5 Keep up the good work!
Yes. In more than 4 years of working with Go un a professional environment I've never needed the goroutine id. This is because I also never worked in a programming language which would expose that so I always had a different solution than others who did. It's a matter of just thinking about the problem and not trying to shoehorn a solution you are familiar with. That's the biggest problem all of the Go newbie programmers have. 
If you want to implement it using TCP, you have to setup your own protocol, which is a headache and not recommended. You can either wrap your file content along with metadata in a protobuf struct and then send it over to the server. That way, you just deserialize the struct at the server side. You probably have to handle large files in a elegant fashion. Or, move to HTTP. You can setup different endpoints for different purposes. Or, use grpc. It supports 2 way bidirectional communication out of the box.
This is a good answer. I've done this to run standalone go on embedded devices. Example: https://www.osso.nl/blog/golang-statically-linked/
Assuming you don't want to just use one of the existing and freely-available tools for stuff like this (rsync/scp/(s)ftp/...): You need to define a protocol. A simple one would be to send 1. Length of the file name in bytes (N). 2. N bytes of the file name. 3. Size of the file (M). 4. M bytes of file contents. 5. If there are more files, start over at (1) with the next one. 6. If you want the receiving side to be able to detect connection failures, send a 0 in the same format as in (1). This is never the length of a valid file name, so this can be distinguished from connection failures. When reading, if this is either absent or there's more data after this, produce an error. 6. Close the connection. The lengths (N and M) could simply be written using [encoding/binary](https://golang.org/pkg/encoding/binary/), either using `binary.(Put)Uvarint` to encode/decode using a buffer and transferring the used portion over the network or using `binary.Read/Write` to transfer fixed-size integers. In the latter case, be sure to use the same data types when reading and writing, and use 64 bits for file sizes because files of 4GB+ exist. The file name can be sent by using `io.WriteString()` and the file contents can be sent using `io.Copy()`, but when reading you should be careful to only read as much as you need. I'd recommend `io.ReadFull()` with a buffer of size N for the name and `io.CopyN()` for the file contents. Actually, to be safe you could use `io.CopyN()` for writing as well, in case the file size changes after you check it. For the two-way communication, I'd like to recommend again `rsync`. It's a wonderful tool :). But if you really want to bake your own, you have some options: * After (2) or (3) above, wait for the server to send a 1/0 byte indicating whether it needs that file. If it doesn't, skip to (5). * First send all file names (and optionally file sizes), then wait for the server to indicate which files it wants (using their names, or a bunch of 1/0 bytes, or more compactly a bunch of bytes where the Nth bit of byte M being 1 means "please send file `N+8*M`", or some other method) and send only those (in a predictable order). * Many other possibly variations on this.
Well if the project never grows, no one else touches it, neither happens now until forever, then you have a totally valid point.
[removed]
Wait for a specific point in time, then start ticking.
Yes, there are a lot of issues with this approach. First, with this approach, you're hard-coding a DSN in library code, which is quite suspicious. Second, importing that package has potentially wild side-effects (like creating network connections), with no meaningful way to report errors besides panicking. Third, you are using package-global state, which makes things much more difficult to test and is also potentially dangerous. A good Go package is not akin to an object and cannot approximate a DAO in any reasonable way. Use proper types and methods. Keep packages stateless. Let `main()` do the `sql.Open` and then pass the `sql.DB` to whatever needs it. Consider doing your database interactions through an interface, for easier testing and for cleaner separation of layers.
There is nothing wrong with it, but I try to avoid init altogether. I see too much magic in init methods. In your case, what happens if you can't connect? How do you specify a connection string for a different DB? How would anyone else work with the package? I prefer to use a struct per resource (e.g. UserRepository) that exposes methods that can return []User from a search, a specific User (a specific find/get), or take a User for update, insert etc. It also allows me to use an interface for unit testing, where the logic of the app in the service layer doesn't have to care about the DB. The UserRepository would be given a connection to work with of course. Passing a connection to a struct like ... `NewUserRepository(db *sql.DB)` seems cleaner to me. You can pass the UserRepository into you app from you main. Now you have no package level DB connection, and you can fail cleanly from your main if the DB is unavailable.
Why use Viper when you can use flag?
Thanks for the reply! I'm not really hard-coding the DSN. I am getting it through environment variables. The *sql.DB* is [concurrent safe](https://golang.org/pkg/database/sql/#DB), so I am not sure how the side-effect will occur. So, writing test cases will be a challenge.
Framework protocols are overrated.
Thanks for the reply! My package is not really a re-usable library by others. The package which I named as *db* is part of the application. The *sql.DB* is just a database handle and not really the connection, right?. My understanding is whenever the physical connection is not available, it will create a new connection. As I mentioned in the previous comment, I get the connection string through environment variable. Thanks for pointing out the advantages of the repository interface approach.
Personally for config files, I prefer TOML or YAML, exactly because writing quotes around key names is not very intuitive for humans. 
That's a good one :D
Not sure if this helps your specific problem but it's a good db resource https://www.vividcortex.com/resources/the-ulti mate-guide-to-building-database-driven-apps- with-go
Writing test cases is pretty easy, just have a setup function to load a test dB and test against that. 
Could you please elaborate on the error? At least a screenshot of the traceback?
Yeah if nothing else needs to happen in the meantime, this is the answer 
That's a wonderful documentation. Thanks for sharing!
Unfortunately he's not really interested learning anything. I guess I'll probably just work with python since that would obviously be the easiest solution, and the quickest way to get this done.
If all the tests with database operations are running sequentially, I think "monkey patch" would work for changing the database connections. But with this approach also, we cannot achieve unit testing using mock data. The repository pattern would be more suitable for unit testing. This monkey patching *sql.DB* can be performed at [TestMain](https://golang.org/pkg/testing/#hdr-Main) at package level or for each test cases.
So build an api in Go an and use python on top of it? I think that might be the easiest solution.
[removed]
Tell your partner to suck it up and learn it. Go is easy with a day or two of hacking around.
[removed]
I am not a lawyer, however, I believe dual licenses are a great way to combine an open-source dedication and then say also that you are welcome to use the code under an MIT license.
Interface exposure can ruin things. If they decide to keep things unstable or at least something they may break later, letting us use it and then breaking us later is harmful. So I get why they do it. Funny though. When you try to program straight to the kernel syscall layer, skipping the C library on Mac OS you are asking for the same kind of trouble. Apple’s stable support seems to end at libSystem. While I don’t wish ill on anyone trying to do what Go’s runtime does - I will guess this is a fragile arrangement at best. Seems to have been going ok so far...
After some searching I found this blog post which explains the approach I briefed above. http://www.alexedwards.net/blog/organising-database-access So my conclusion is that the approach is fine. But it has limitation related to testing with mocked database and tests cannot run in parallel. Since go test runner (*go test* command) runs individual package's tests in parallel. At least tests can be run in parallel at the package level. This is the approach I am using in my *pet project*: https://github.com/kaaryasthan/kaaryasthan
opposite direction. python api that go queries for the data/assets needed to do things. Go and python both can access the db, or you can have go be the only thing that does (eg calls python, both saves to DB + sends to client) DB / | frontend --&gt; go | \ python You can also use the DB as the 'source of truth' and have both languages interact with the DB, duplicates effort but can make it easier to isolate pieces. This, imo, can require a more sophisticated architecture to implement well.
Say people who enjoy reinventing crappy wheels.
Here's more on other stuff https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk 
Sorry for my introduction, you may misunderstand this project, it's just for local development but not hot reload on server.
Wow, I wish wbs could be found before I wrote air :) Your are right, these two projects do the same thing, waching file changes and some commands are executed then. Actually I agree on your opinion, such tool should be more generic. In fact air is more generic than wbs, you could customize building command and binary command not only Go related things. Several months ago I wrote a small project https://github.com/cosmtrek/loop, you could explore it, the design is much simple and flexible. I could write some plugins to implement live-reloading utility.
Looks great! But it's overweight for my requirements. I just provide a docker image for those guys that want air running in docker container but not local development.
Thanks a lot. You could fork and try it.
I got panic errors by not spacing the input integers...it was my first try at it...not a big deal.
The current thinking is that, in the medium or long term, the `go` tool will get a new mode or verb that will combine `go get` and `dep`. The precise semantics can't be defined/described right now, because it will probably be coupled with other large changes to the local code environment.
The company I am at has that policy. There is a specific list of open source licenses we are allowed to use and 'unlicense' is not on it. MIT or Apache would be fine.
Can see from the post that the example is docker only (no k8s), nuclio has a controller abstraction layer, support k8s and docker and more can be added (working on one for RPi)
Reinventing crappy wheels is a good way "To learn and play with the Golang standard library"
Nope, don't know about it. Is it good?
[removed]
https://github.com/mcandre/toys/blob/master/go/hello-timers/main.go Adjust timer period as needed.
[removed]
Protobuf is potentially a bad idea in the long run as that requires that the full file be loaded into memory for encoding. Transferring it via ```io.CopyN``` will only load what is appropriate. For that matter you might want to wrap the ```os.File``` in a ```bufio. NewReaderSize``` with a reasonable buffer allocation to speed the transfer and keep memory use reasonable. 
Actually, we're trying to abstract orchestration behind a [Platform interface](https://github.com/nuclio/nuclio/blob/master/pkg/platform/platform.go#L14) and tucked all k8s specific stuff in the k8s implementation. Besides k8s we also support a [local platform](https://github.com/nuclio/nuclio/blob/master/pkg/platform/local/platform.go) which is pretty much no orchestration for things like integration tests and one click, kick the tires installation. This allows you to run the nuclio playground by simply running: docker run -p 8070:8070 -v /var/run/docker.sock:/var/run/docker.sock nuclio/playground There's still work being done with regards to ingress and such, but we'll do our best to keep platforms pluggable. (nuclio contributor)
Some projects can be split into multiple tiers, where one part of the system is responsible for certain things, and another part responsible for other things. If you can break up the server into a backend server in Go, with a frontend server in Python, that’s one way to regularly separate duties. The backend server manipulates JSON REST calls, the frontend server provides a Web UI, requesting information from time to time from the backend.
I'll definitely dive into that and take better care, thanks for pointing it out. If there's any more feedback we'd love to hear it. The goal isn't web scale for web scale's sake. We needed a "serverless" framework for real time big data analytics. This means nuclio is designed to sit right in the middle between very high throughput data streams (which can publish data points via HTTP, streams, MQTT, etc) and a high performance data platform we also develop. Functions can serve as easy-to-deploy glue logic between the data streams and things like Spark and Hadoop, performing things like aggregation, enrichment, routing, etc (sometimes replacing Spark jobs altogether). (nuclio contributor) 
I do too. 
I am using envconfig: https://github.com/kelseyhightower/envconfig As the name suggests, it's configuration based on environment variables.
I was just teasing (though it may of seemed snarky I realize, sorry if so) with the webscale, referencing the extreme focus on performance with the 100x faster than Y claims I couldn't help but take a look. There is always tradeoffs when something new is much faster than something with much more accumulative engineering resources, typically being stability, features, and unfortunately security. Overall I think you're just fine and it seems like you are passionate about the project given the diligent issue tracking and such. I would just be careful around unsafe usage since I see C functions are supported so depending on your design it may be unavoidable, but since events can come from log files and such overflows become an actual attack vector. Good luck though and thanks for the polite response.
Could you expand more on this? I've ran into the same issue where I needed to perform an [action every `X` seconds](https://gist.github.com/nhatbui/61629eb54ca09afe3c88abd4aa524530). Timers with channels was overkill: the process was already done in it's own goroutine. I went with `Sleep`.
To ensure file integrity a simple hash in addition to your file size and name suggestion is a better practice. There are many to choose from but depending on your personal level of paranoia you can go anywhere from MD5 to SHA2 with builtins. MD5 is a legitimate choice as long as you are not expecting it to provide deliberate tampering detection. It's good enough for a simple file transfer to verify the file made it as expected.
Adding support for Docker Swarm would be really great. 
gonfig also does that. You can disable cli flags and config files f.e. 
Nor is stackless-python's implementation :) https://en.wikipedia.org/wiki/Green_threads
I definitely want to get to that, if only to mature the Platform interface :)
Programming pro tip: If every case uses the same code, it should go outside the switch statement. Specifically this code: num1, err := strconv.ParseFloat(c[0], 64) if err != nil { fmt.Println(err) } num2, err := strconv.ParseFloat(c[2], 64) if err != nil { fmt.Println(err) }
I will venture to guess I'm getting downvoted because people can't understand whether I'm joking or not. :D
"best experience"... "XML"... sorry, what?!
Reminds me of dark days of Java.
Okay I see what you're saying. That would definitely work. I can just have him pull the data from the database, I can pull from the database and I can read his data/visualizations as json/html. This even has the added benefit of allowing him to make his own interface so I don't have to.
Here's an example I wrote a couple years ago: https://github.com/djherbis/fenc/blob/master/fenc.go
Okay I see what you're saying. That would definitely work. I can just feed him the data from the database, I can pull from the database and I can read his data/visualizations as json/html. So he could get data from the database, do his manipulations, and serve json/html on an API request.
Exactly! best experience and XML are mutually exclusive in my mind
could you elaborate? I don't see many differences wrt. for instance glide etc.
It's uninterruptable -- I tend to write a function like: func sleep(ctx context.Context, timer &lt;-chan time.Time) bool { select { case &lt;-timer: return true case &lt;-ctx.Done(): return false } } this lets the sleep be interrupted if the context is cancelled, and is handy in loops: for sleep(ctx, timer.C) { // timer triggered, do stuff } 
Maybe someone could help me out. I just don't understand why the method pattern is "fragile" and the closure pattern isn't. My understanding is that they are essentially equivalent, although the method pattern is more ergonomic and more limited (the closure can have unlimited parameters).
Can we agree that HTML is a widely accepted and used language.
If you want to do this as an exercise/challenge, that's fine. But do not, repeat, **DO NOT** use this on or for any data you remotely care about. If you are looking for a way to backup your data, use rsync or one of the other utilities that has had *decades* to find and work through the subtle corner cases and failure modes.
Certainly, but [HTML != XML](http://cscie12.dce.harvard.edu/lecture_notes/2007-08/20080130/slide26.html), so I'm not sure I understand the relevance.
Yes: &gt; I’ve written before about Go and how I was initially pretty unimpressed with the over simplicity and parenting that is forced upon you. However, over time I’ve come to enjoy using Go to the point that every new project I tackle, Go is the first language I consider. (source: http://nomad.so/2017/07/go-v2-0-and-generics-its-a-no-brainer/) The main thing missing are generics / type parametricity according to the author, and I tend to agree.
The underlying principles are the same. Why XML here and with GO? The plugin can take your tags process the strings to give a more accurate trace on runtime panic.Now what if you had this Vim plugin : https://github.com/cheikhshift/vim-gos it comes down to writing Go code.
&gt; process the go code strings in them 
Yep, certainly true. But my post was long enough as is. And to come back to it, `rsync` already implements that :þ.
Is your defense of using XML that it is similar to HTML which is used therefore it is good? I don't want to reiterate arguments other people have already made better than I have, but I think you might want to read some of these: http://wiki.c2.com/?XmlSucks
maybe "fragile" isn't the best choice of words. I guess in my mind it could be "fragile" in the sense all the shared state is wrapped up in the one server object and making a change to that state could have unintended consequences across HTTP handlers. Outside of that, you are correct, the pattern is just more flexible imho. 
&gt; http://wiki.c2.com/?XmlSucks No my argument is if you can open a tag (in html), add attributes to it and close it, then this CLI should be a breeze.
Are you simplifying the use of XML to populating brackets?
Hey guys, C++ and Java have very similar syntax. They must be the exact same.
Now within the tags there is Go code. The XML adds extra code onto the Go code you write. These addons include request tracing and finding the causes of runtime panics. More extensions here gophersauce.com/docs/extensions.html
Its not. This web application server won't consume 128mb ram when it starts.
Why monkey patch when you can simply pass the object you need around, for testing or otherwise? Why use init to set up the DB when you can simply call an explicit function to do so? Why do this all at the package level? What is the point?
A long time ago I rolled an executable and it's config file using gobin successfully. It after a bit like a self extracting archive and I guess that could work for seeding an sqlite file. gobin is awesome for that though
Can you add a feature similar to [flagoverride from Uber-go](https://github.com/uber-go/flagoverride) please? Basically in [Nakama](https://github.com/heroiclabs/nakama), we load the configuration from multiple places in the following priority: 1. Command line arguments / override 2. YML config file 3. Default packaged config for every option Flagoverride basically merges 1+3 together, and we have to do some nasty things to get 2 working in the middle. It would be good to incorporate that functionality here, and this would be pretty amazing :D
you could use http.ServeFile, it will support sending files in whole or in chunks, you could even use it for resuming broken downloads you would just need to add a directory listing with hashes to see what files have changed since last "sync"
[removed]
2017, XML are you serious ...
Hello, I don't undersand why sat is true here: f := bf.And(bf.Var("a"), bf.Not(bf.Var("a"))) sat, _, _ := bf.Solve(f) 
That's exactly what it does, I get I should document that better. Default behavior is 1. load all default values 2. override with what is found in config file (json, yaml or toml) 3. override with that is found in environment variables 4. override with what is found in command line flags And you can disable any of the steps if you don't want them.
Also, it's MIT licensed right now.
gRPC has great support for bidirectional streaming and the go library is great. I’ve talking with people in the go gRPC slack channel who talk about using it to moving around gigabyte sized files. It might be a fun project to work on but honestly I’d just us rsync or ftp
No zookeeper (or equivalent) required because it doesn't implement the things kafka uses zookeeper for..
I clicked, I read until I got to the user authentication system. You can either have LDAP or Mongo for your backend, so I clicked back.
After reading all these comments and links shared here, it looks like there are [basically three approaches](http://www.alexedwards.net/blog/organising-database-access). 1. Use and exported variable for *sql.DB* in package level 2. Dependency injection (Repository pattern?) 3. Use request-scoped context I started with the [first approach for my application](https://github.com/kaaryasthan/kaaryasthan) without knowing the benefits of the other approaches. Now I am realizing that the second approach of dependency injection is better for tesability (unit tests with mock DB &amp; tests running parallel). Thanks for all your inputs!
You're missing the bit about channels with send/receive semantics for coordination, but sure, green threads etc are not new either.
I believe that it's somewhat more tamper resistant if you also specify length.
And also whilst listening.. https://blog.jetbrains.com/go/2017/10/13/help-us-choose-a-name-for-our-go-ide/ 
So whoever makes this up in play in golang, cos its first really elctronic song - done my real muscians like andy and burgess - will be fun - Note headline geriatric players are more expensive, the art is being lost.. - they can lick 4 songs in a day, instread of 1.5 
So, the problem with this is that you're telling an unexported type. Which is a no no. It's confusing to API consumers because there won't be any documentation generated for it, so they won't be able to see what methods it has etc. You're like 95% of the way there, just define a GetPutOption interface that implements both other interfaces, have WithPrefix return that, and everything will Just Work, plus you get the very obvious type hint that this thing can work with both put and get methods. 
https://www.youtube.com/watch?v=TtzpXt-AQeY "Go. Gooo... Gooo... Gooo... Go go go!"
Yep which is why I said "in addition" :)
Don't use protobufs, every thing is pointer for some stupid reason, obviously this means a lot of CPU spent in encoding and decoding. Use gogoprotbuf because Google is lazy to optimize protobufs for Go. It may not matter if you are doing just single digits kQPS. If you want more throughput with better latency, avoid protobufs and use gogoprotbuf. Good luck
its not similar at all. You're comparing my fully functional OS with multiple dev tools and IDEs to a single IDE (eclipse) that happens to run through a browser. I haven't used Eclipse Che. While i have been a fan of Eclipse as an IDE for Pytuon and C/C++, I haven't found it to be good for golang. However, I haven't looked at it for golang in a year, so maybe it's better now.
Woah, i just did that code yesterday, but not yet updated gist, I will.
Zookeeper is afaik used to store config data and to synchronize the nodes. The same functionality is integrated in NATS using RAFT.
Maybe I'm misunderstanding the article but: I've used and understood functional options as a means to set options on a type -- not to dictate behavior of a function of method call. I can't quite put my finger on it but something does't seem right about using functional options this way. 
As well as any go Package.
I did lots of enhancements to the Google Go protobuf package to support all the missing datatypes[1] last year. It would let you handle the struct-in-struct that you need. [github.com/mistsys/protobuf3](https://github.com/mistsys/protobuf3) protobuf has been fine as an encoding for data "at rest" for me, but it's only been a year. [1] Google's protobuf only supports the types which their protoc tool emits, which isn't everything. No arrays, no slices of structs, etc. I wanted to go from existing Go structs, which used all the features of Go, to a marshaler, an unmarshaler, and a .proto to share with others.
You're at the point where you need a protocol to talk over this TCP connection. You can make one up, or use an existing one. Either way the details are for you to invent, which is why the stdlib documentation doesn't help.
Such a function used to exist in early Go. It was removed because people started using it to implement goroutine-local-storage by using a global map keyed with the goroutine ID. That's not good because it beaks in the future if/when callbacks to happen in a different goroutine. In other words it makes which goroutine calls the callback part of the API, which it wasn't supposed to be. (The proper way of passing data to a callback is a closure. That will always work, no matter which goroutine calls the callback.) That said I personally find goroutine IDs to be very very useful in a log or trace file. So I use the source and patch a runtime.GoID() function back into the runtime. The code is trivial func GoID() int64 { return getg().goid } If you also patch in a matching build flag into the compiler then you can produce source code which compiles with and without the patched runtime.
I understand where you are coming from, but I don't think it's a big deal that the options are returning an unexported type, since the options are supposed to be opaque anyways. Returning an interface like `GetPutOption` could make sense, but that also means that if there's an option that is used in many APIs, I now need to have an interface that looks like `GetPutDeleteBlahBlahBlahOption`, which is not ideal.
 func (r *Record) Slug() string { slug := strings.Replace( strings.Replace( strings.Replace( strings.Replace( strings.Replace( strings.Replace( strings.Replace( strings.Replace( strings.Replace( strings.Replace( strings.Replace( strings.Replace( strings.Replace( strings.ToLower(r.Title), " ", "-", -1), "?", "", -1), "&amp;", "", -1), ":", "", -1), "!", "", -1), "@", "", -1), "#", "", -1), "$", "", -1), "%", "", -1), "^", "", -1), "*", "", -1), "(", "", -1), ")", "", -1) return slug } No matter the programming language, but after the first maybe 5 levels you should ask yourself if there are easier ways to accomplish this. ;-) Maybe define a list of chars to remove and then loop over them? Or use a regular expression?
Or use `strings.Replacer`!
Use them or not, but you are wrong when you say "everything is a pointer". For some time now the supported version of protobufs uses the proto3 API, which does not use pointers for scalars. And the reason they were pointers in Go (only) was not stupid, it made sense given the contraints of fitting a C++-oriented model onto Go. But with proto3 one of the most limiting constraints (the "has" property) was lifted and the pointers are no longer needed. 
I use MessagePack, for most cases. The main thing I like is that I can define my data structures in Go, and changing the data structure is backwards compatible. There is at least 3 very good Go packages with different features. At least for me the convenience far outweighs the extra space the format uses for field names.
Identify what area interests you the most. Devops ? Databases ? Web stack ? Then we can perhaps narrow down what could be good to build.
Find the common paths between two wikipedia articles using goroutines to branch out the page links? HTTP API that translates image submissions into ASCII by utilizing a library or another process? I dunno. Guess the first question is what would you ULTIMATELY like to accomplish with go in the future? Work towards that!
I'm working on a series of many mini-projects basically targeting someone like yourself. Will be 100% free and will have exercises covered in screen casts (again, free as well). See https://github.com/gophercises/urlshort/blob/master/README.md for an example exercise. Some will be shorter like that while others will be 3+ parts like build a package then use that package to build something else. While not everything these will end up being reused a ton, many of the projects could be extended to make something much more practical. Eg I use a modified version of the URL shortener code in another web app that is in production.
[removed]
If you store stuff in datastore, you should use datastore's format so you can do proper querying and indexing. You should not use protobufs. Protobufs are useful if you have to create messages of data to send to something or to store somewhere if all you're allowed to store is a string (like if you were implementing a database on top of leveldb, or if you were writing each message to a file). That's why they are used in grpc, to provide a standard for constructing messages. You probably should not use the protobuf generated structs in most of your program's code. Generally you'll have some sort of request handler (acting as a view, in MVC), which treats the protobuf message as part of the request. Then you deconstruct the message and use its components to do work. It's not a good idea to pass the original protobuf generated struct around because it introduces unnecessary coupling and makes the entire message's data available to functions that probably don't need to know everything.
Cryptotrading bot. A lot of aspects of programming are covered when building one and you can even earn some money if done correctly!
Message visibility is a good point I hadn't considered. Also Datastore has no issues storing entire structs that are entirely queryable, it chokes on pointers which Protobuf relies on.
I think this is not strictly better than viper, but it has a couple of advantages. If it is maintained for a year and used in reputable projects I might switch to it.
They give you the most used parameters for different commands that you don't have to read the whole man page how to tar or untar something :) pretty useful everyday
Yeah viper still allows you to load config in a key-value manner without having to explicitly list all possible config variables. I just happen to prefer using a struct for that and support in most libraries for that usage is usually the worst. I already started using it in programs for work, but yeah it will be possible that there are some bugs that will pop up over time. I can only hope enough people start to use it so that those bugs pop up fast ;) 
Thanks for the response! Yeah I'm sure it works fine. I just can't justify switching to it until I know for sure it is being maintained - it's to new right now. I don't want to switch everything to gonfig and then have to switch back to viper later haha - so much work!
It it a big deal since linters are going to bark at it. 
Are you doing a video series because I would love a link if that's the case.
[removed]
That's true. Fortunately whether the type is exported or not is totally incidental to the pattern I'm describing. I will update the example to export the types since that seems to be bothering a lot of people.
proto3 only uses pointers for messages
We our all our modelling for all platforms in with protobuf 3 (Go, Objc, Android, Java, Swift, Python) and use it in place of struct when representing object of our data model. For go we use gogo. Added benefit is serialisation is free.
You can return anonymous interface directly from the function, so it will solve the problem with naming at least) 
- Cron services (non-user facing repetitive tasks) - Web services (user facing api's)
^ this, 100% this.
Not sure if I follow. What did you mean by anonymous interface and which function are you talking about?
You could also make it an unnamed interface and just embed the interfaces it implements. func WithPrefix() interface { GetOption PutOption } Returning an unexported type means that callers can't tell what it implements. Sure they can read the docs, but it's nicer to have it explicit in the types. 
Yep, there will be videos but they aren't published yet. Website is gophercises.com I got sidetracked last week but I should have the first few exercises recorded and live shortly. Probably tomorrow.
Into the right spot in GOPATH. Saves a step. 
Yeah I also wouldn't want people to do that right now. I'd feel responsible for the bugs that obviously will be there. No one writes bug-free code and gonfig only had one pair of eyes on the code for now :) You're invited to take a look, of course ;) it's pretty concise 
These look awesome. I look forward to the screencasts, too. I find watching people code to be really insightful as to how the workflow and thought process should be.
You should check out Todd Mcloud.. he has a YouTube channel and has courses up on udemy etc.. could help you out
Close, but it still has a lot of repeated code. This is what I meant: Move num1, num2, err := parseArgs(c) if err != nil { return 0.0, err } between lines 30 and 31 func processStack(e []string) (float64, error) { result := 0.0 for _, v := range e { c := strings.Split(v, " ") if len(c) - 1 &lt; 2 { return 0.0, errors.New(`error: some arguments are not supplied`) } num1, num2, err := parseArgs(c) if err != nil { return 0.0, err } switch c[1] { case "*": result = num1 * num2 case "/": if num2 == 0.0 { return 0.0, errors.New("error: you tried to divide by zero.") } result = num1 / num2 case "+": result = num1 + num2 case "-": result = num1 - num2 } } return result, nil } 
http://rosettacode.org/wiki/Rosetta_Code
^fixed
^fixed with a regex
C does implement text()
C implements text() by way of the embedded field of type Interface but the zero value of the field is nil so assigning &amp;C as Interface means you have satisfied the interface but you provided a nil value at runtime
What I do is build an api server that handles all the backend functions and data in go. Then you can build a ui or front end on whatever you want to use that utilizes the api
Yes. You never need goroutine ids. If you think this is helpful to debug stuff you write: Come up with something alike.
yeah that's the point. should that be a compile time error, rather than runtime?
Hm, that partly makes sense to me. However, wouldn't then a nil pointer error / segmentation fault be the result and not a stackoverflow? Also I added a print statement and none of the values is nil: https://play.golang.org/p/IqgRW9NvOa Can you please add print statement to show me which value is nil exactly?
I’ve replaced Node with Go, I hate the typed shit but I hate async madness more, and deploying Go on Heroku is kind of crazy but it’s still worth it, IMO
There is no compile time error, because C DOES implement text(). The runtime error is caused by a stack overflow, text() calls itself recursively.
Well, it's not really just that. It's an Dockerize IDE by itself and you basically set up different docker container for the different development environment you need. It is hosted locally but can work remotely, maybe you're thinking of the codeenvy flavor. From my understand its point is to rid ourselves of VM, make it fast &amp; simple to set new coding environment, makes our entire environment portable, and rid ourselves of the multiple IDEs problem. Since you said you were using VM for coding this seemed like a possible replacement and I'm just asking you if you heard about it and why it can/can't replace your VM coding environment. You know, I just learned about its existence so I'm just asking around if it can fit your use cases. I'm not comparing anything, I'm asking you to do it :p .
If you're trying out Go, I'd suggest going through https://github.com/astaxie/build-web-application-with-golang. Apart from basic syntax, you can find some useful examples and see how amazingly Go solves them.
I love go, but I have not found many projects that are really clean to use for web dev and go. React frontend with a go microservices is probably the cleanest solution. With repeated code for crud and such, generators like jhipster and Ruby on Rails are way ahead of the curve. I have not found anything comparable in go :( Again, I contribute to kops and k8s, so I am a gopher. I love the language. But can someone build us a program like Ruby on Rails or jhipster for go?
Microservices?
Can you please go into into detail a bit. I mean it makes sense from the stack overflow kinda but how exactly does `type C1 implement `text() string`? I mean I don't see a single concrete function for text() in your or my examples. Is this some how auto generated. If yes, what are the exact rules for that?
Lawyers hate that. Not a lawyer, but dealt with lawyers. Pick one live with it.
You lost me at the word xml, do you consider supporting markdown?
No need for Sleep when working with channels. There's sync.Waitgroup{} that gets the job done..
Your example isn't that clear for the question you're asking. Here's a better example: https://play.golang.org/p/0KOTwz19RM This reason for this occurring, is because Go doesn't have true inheritance, instead there's a bit of syntactic sugar going on. When I call `a.Greet()`, it first checks to see if the `Person` struct implements the `Greet` method, which it doesn't. So then it falls back to the embedded value, which you have provided to be `Person`. So it attempts to do `a.Person.Greet()`, because that is theoretically valid, because `Person` should implement the `Greet` method. However, `Person` has not been initialized. Therefore it results in a SIGSEGV as you attempt to access a nil value. This is why it's a runtime error, and not a compile time error.
https://talks.golang.org/2012/10things.slide#3 or search "golang anonymous struct field"
In Go, interfaces [are satisfied implicitly](https://tour.golang.org/methods/10). type base struct { Instance } Here you have a concrete type that embeds and interface whose sole `text()` method is never satisfied. But the compiler cannot know that because of the interface. By doing `c.Instance = c` you have created an infinite chain that never stops because C does not have a `text()` method. So when you call `base.text()` it attempts to "call" `c.Instance.text()` so to speak, but you have set that to be `c` so the loop starts all over again.
Microservices yes. I count them in web services. Its really subjective to draw a line between the two. APIs == services, ... micro/web/cron, choose your word.
Thanks for the detailed answer. You simple example makes total sense with your explanation. However, what I don't understand is why in my example I don't get a SIGSEGV but a stack overflow instead. Can you please elaborate on that?
What I don't understand is why the assignment `c.Instance = c` is even valid wit the implementation if a `text() string` method ? I mean in the example you liked ( https://tour.golang.org/methods/10 ) you cannot remove the these lines without a compile time error: `func (t T) M() { fmt.Println(t.S) }`
&gt; golang anonymous struct field" Well, I know that what I'm using are _anonymous struct fields_. Unfortunately, neither the slide nor the first results of the google search yield a detail explanation on the code generated to produce the stack overflow. Sorry, I keep asking but I'd really like to understand the issue here completely. Unfortunately none of the answers helped me to grasp every aspect.
It would have been in beta for around a year then, I wouldn't really call that soon, but I am actually very happy it has been so through such a long beta period anyway.
https://gobuffalo.io ?
That work is being done in a branch, sure. You do realize using external coordination services like etcd and Zookeeper is a conscious trade-off? NATS using Raft directly doesn't remove the need to manage a consensus cluster.
Structs "inherit" methods defined on their anonymous struct fields. In this case, your struct embeds an anonymous interface (Instance) which defines `text()`, so thus the struct "inherits" `text()` as well, making it satisfy the `Instance` interface. The runtime error is a stack overflow because c.Greet() invokes c.text() which is actually c.base.Instance.text() which is implemented by c.text() (because you've set `c.Instance` equal to `c`in `NewC()`). The compiler isn't catching *this* error because it doesn't know that you don't want to infinitely recurse into c.text() (it could catch this sort of error at compile time in egregious cases like this, but the cases that are trivial to catch are also very rare in practice).
What you usually want to do is this: type Instance interface { text() string } type base struct { } func (b base) text() string { return fmt.Sprintf("text") } If you remove the method `text` from type `base` then it no longer satisfies the interface and you will get a compile time error. Please read [Go Data Structures: Interfaces](https://research.swtch.com/interfaces).
You're correct, /u/marcelmolina is wrong. `nil` isn't the issue here; you're setting `c.Instance` equal to `c` in `NewC()`, which means `c.text()` calls `c.Instance.text()` which calls `c.text()` which calls `c.Instance.text()` ad infinitum. Each of these calls allocates some stack, so you very quickly consume all of your stack limit.
Removing that line means that `T` no longer implements the `I` interface (because `T` no longer has an `M` method); however, in your example, `C` *does* implement `Instance` because `C` has a `text() string` method that it inherits (via anonymous struct embedding) from `C.Instance`. So `c.text()` evaluates to `c.Instance.text()`; however, `c.Instance` points to `c`, so it tries to run `c.text()` and the cycle repeats indefinitely.
Compared to Rider it is soon I'd say. 
I don't think so. You're never severally dereferencing a nil pointer, but continually doing lookups for `text()`. That function is never actually called (it's nil), so it doesn't generate a nil pointer exception. I think Go's compiler should be a bit more intelligent for things like this, but it's not a violation of anything in the Kenya's the spec AFAIK, so it won't generate a compile error.
https://github.com/sauerbraten/pubsub/blob/897f02c5bb09f88057cbb2178cd3804deaba2e30/broker.go#L18 &gt; μ sync.Mutex Ugh.
https://github.com/BurntSushi/xgb is nice and portable.
Nothing about this seems to be about Go.
Thanks, your answer covered all missing points I think. I still think `c.Instance = c` should give a compile time error since it _could_ be caught at compile time. However as your answer says, the compiler simply assumes it to be implemented by the forwarding call which then yields to the stack overflow.
Maybe, but Go's compiler never attempts to prevent infinite recursion (or infinite loops, for that matter). If you want to recurse indefinitely, that's your business, I suppose. Probably better off leaving it to a linter. Besides, this error is easy to catch because there are no branches in the call path; however, such errors certainly are nearly non-existent in practice, so why slow the compiler for artificial problems? The common stack-overflow/call-depth errors that occur in practice contain branches, and most of these are impossible to statically preclude (for example, a function that checks for user input and recurses if none is found). In practice, the compiler rarely (never?) looks through an interface; it just compiles in the dynamic dispatch code and carries on. I think this is too bad, because it seems like this could unlock a lot of useful optimizations (statically-dispatching [and thus possibly inlining] interface methods when the compiler can prove the interface type doesn't change, for example).
/u/tv64738 I know that project. This proof of concept served a different purpose - I'm looking into the feasibility of mechanically translating the GTK+ library to Go, similarly as is being tried with Sqlite. Lot of work ahead, don't know if I can ever get there with all the limitations around.
Why not just HTTP handlers and Gorilla MUX? What do you need from Rails if you want a SPA in front of it? Go is really clean for API's
This was good. Thanks.
Hey, thanks for this link. Touches the important parts on learning how to use Go for your web server and how Go does that for you bts.
I am not sure what you mean with the last sentence since NATS is the consensus cluster because of Raft. And I think the less moving parts the better. 
You break from the `for` loop that has the `select` in it, but returning from that function only ends that goroutine. The main goroutine is still running.
You do realize you're talking to Rob Pike?
The phase web service has permanently burned a dark hole on my soul. 
Don't disagree, but it is a lot of repetitive code that could be generated. Fair? 
No but that sounds like a good feature,,, to write HTML pages or code?
It is valid because methods can be inpure. The first call to `text()` may make the second recursion terminate. In your case it doesn't.
This is great. Reminded me of the introductory CS class I took in college where the professor gave us interesting mini projects to solve in Python.
I didn't know that import aliasing was a problem...why would you want them removed?
HTML 
Good idea!
I know how to read and I also know that they are clearly a shit developer if they think this meme syntax is good. Just because some random guy did a few mildly important things 50 years ago or whatever doesn't mean they are right. Everyone sucking them off whenever they suggest anything just gets them into the mindset of no, it's the children who are wrong.
I go into this a little bit in the [purpose section](https://github.com/alexkohler/unimport#purpose). More often than not, there's not a good reason to alias an import - it will make your code harder to read.
I've got a link to a Go Playground setup in the other message I posted. Show me. Please.
Seems like you need a new partner. A programmer who isn't interested in learning something new isn't worth the chair they sit in.
Hmm, I am still not clear. When Ctrl+C i clicke, I can see the text: log.Println("Producer closed") being logged. So this means, the ProducerLoop and the defer in it executed and returns. When I did an strace, I can still see the app being still blocked on the select(..) call so preseumably the ListenAndServe() is still running. Is this what you meant by the main goroutine? This means the signal is handled by the select but is then not propagated to the ListenAndServe() method?
I like the Wikipedia project. What do you mean exactly by common paths? The shortest path from article A to article B?
Understood. I will have to check it out.
Why not just write an actual interface for your db functions then you can pass in a mock/dummy version in your tests?
Agree. Use Buffalo Go. Once you understand the basics of Go you'll want to create a project. I started developing in go two months ago. Make sure you understand how to set up a workspace.
Ah, that's a really good point. I've updated both the blog post and the example to use anonymous interfaces. Also gave credits to you and @ar1819. Thanks a lot!
You would want to use an interface here. A common pattern used to abstract away where the data comes from is the repository pattern. ``` package user type User struct { ID int64 Name string } type Repository interface { Find(id int64) (*User, error) Store(u *User) error } func ChangeUserName(id int64, name string, r Repository) error { u, err := r.Find(id) if err != nil { return err } u.Name = name err = r.Store(u) return err } ``` Now you are able to pass in any struct with the methods matching your `user.Repository` interface. For example: ``` package mysql type DB struct { *sql.DB } func New(db *sql.DB) *DB { return DB{db} } func (d *DB) Find(id int64) (*user.User, error) { // mysql stuff to find user } func (d *DB) Store(u *user.User) error { // mysql stuff to store user } ``` ``` package main func main() { // ... // conn := code to open *sql.DB connection db := mysql.New(conn) err := user.ChangeUserName(1, 'bob', db) // ... }
It seems odd to shutdown a server after an HTTP request to a specific handler, but in any event, interfaces can have receivers: type Env struct { Server *http.Server // any other environment variables } func (env *Env) ShutdownHandler(w http.ResponseWriter, r *http.Request) { env.Server.Shutdown() }
I made it as far as ‘Basel is seriously amazing’. Moped out of there quick. I defy you to compile tensorflow from scratch.
But the infinite recursion is a red herring. If C wasn’t being used recursively but instead something like C with no concrete implementation of the embedded interface you’d still compile and fail at runtime with a nil pointer.
You beat me by 3 hours, but in my defense, I was reading on my phone or I would have responded here :)
I need to do this too. I couldn't find any Go libraries that have come close to doing the considerable work PDFBox has done on text extraction. Exec'ing PDFBox from a Go program works fine so I am not worried about the lack of a native Go library for doing this. 
Thanks. That's a far easier solution than I was expecting. I was so hung up on finding something in the net/http package. Thanks again!
I gave them a spin. I found rsc/pdf to barf on some optimised PDFs, and unexpected page counts. The rest of the packages weren't appealing. I suspect another language is required here for better support.
I have forked from rsc/pdf to https://github.com/ledongthuc/pdf and support some funcs to read data from PDF. The idea's I want to get data from Linkedin Profile. So hope it's useful for you
To the questioner, this is most likely the way to go. It's more than just "parsing" the PDF; PDF is a program whose output is how to put pixels on a screen or ink on a page. Certain projects are so large that you don't necessarily expect every language to put out an individualized solution; this is probably in that category.
I have seen numerous issues with compiling tensorflow. And isn't tensorflow C++?
I'm also exploring it a bit. It seems pretty "experimental" at the moment with a whole bunch of undocumented things. What makes me interested in it is maybe being able to make a reproducible coding environment (if possible) so I could set up different machines and get people coding asap. At the moment, I code on Windows (not just in Go) but I'd prefer to code on Linux so I can use ``make``.
It is c++. They use bazel to build it. I’ve had Pretty much zero success compiling tensorflow with gpu support and I couldn’t even begin to tell you why because bazel masks the true issue with a whole lot of pointless crap. Literally the closest you can get to support is a bunch of people telling you to arbitrarily turn down memory and cpu limits until it maybe works. I honestly can not work out what bazel is enhancing. I have zero issues with gnumake for complex builds. Not to mention how beautiful and streamlined the go build process is already. 
The justification is that good package names don't need to be renamed. In my experience I have had some packages that have had perfect names in that they are perfect descriptions of the package, but were a little long, and if I was importing one of them and using it a few hundred times, I wanted to rename that import to something shorter. I don't know what the general opinion is on that case, though.
All good points. I am enjoying go test times reduced from 6 min, to less than a second. To each there own.
I can't imagine a build framework implemented in Java will actually make go build faster.
I was able to spin up my own authentication method really easily for an angular frontend and golang backend using jwt through AWS. Front end grabs a token from cognito and the back end just validates it against a public token key store. This approach could easily be expanded to any token issuing authentication method that your frontend can talk to, including another golang server that issues tokens to validate users. Feel free to PM if any of this might apply to your project, I'd be happy to share them outline of my implementation!
&gt; use caching inside your CI tool. Without caching you loose ALL of bazel’s performance. Frankly you may as well use go build. Which makes me wonder - did you try `go build -i`? If it is just a caching issue, then you probably might not have to throw a large, complex build tool at the problem.
The blog post you referenced to actually inspired me to do a simplified writeup of the basics of [using dependency injection in Go](https://appliedgo.net/di) a while ago. It is basically what you laid out in the code above - an interface to define operations, a „real“ package and a „mock“ package, and the required injection happening in main() or in the test function, respectively. Bam, decoupling done.
I read like I want to read, didn't even read you line about generators. Go is verbose. If all you are doing is CRUD though, GORM (orm mapper) is a decent choice.
This is awesome! The fact that we need a tool for this is more evidence that naming things properly really is one of the two hardest problems in CS.
I think you should still avoid renaming wherever possible, but sometimes it's necessary to fix mistakes made by package authors. Eg. if someone has a package named `util`, obviously that's going to make my code really hard to read and refactor, so I will come up with my own name for it up front (if I can't fix the name myself).
&gt; Is this what you meant by the main goroutine? This means the signal is handled by the select but is then not propagated to the ListenAndServe() method? Yup. If you want the program to exit, you have to do that yourself because you captured the signal.
Crazy right?
Bazel comes from Google's internal build system used for their monorepo. IMHO you'll probably only see the real benefit of bazel if you use it in a monorepo context. It provides lots of features that requires tooling when using a monorepo
The main performance increase is with the caching of tests, and Caching on Travis is actually really trivial. Caching with bazel locally occurs automatically. With the main project I work with, we will be using bazel to build containers as well. There is performance boosts for using bazel with a container as well. Yes, it is large and complex, and the learning curve is not trivial.
Thanks. That makes sense now. Any idea whats the golang way to do this?
You mean something like this ? https://github.com/daptin/daptin
Exactly although if you are doing a smaller project or even a big projects . I find it easier to start from standard library and build my own endpoints that expose data in json.
What problem does this solve? Not trying to bash it or anything else, but I have limited time and in 5min I haven't quite figured out why I would want to use this. What problem might I have that this would remedy? I *think* it is a tool for generating all the boilerplate of a web application but I'm not really sure. It would be great to see a section on the landing page that discussed that before jumping into features and examples. Best of luck with your project and congrats on shipping it :)
May I ask what is the use case here ? as you would probably make this linux only ?
Yeah, and maybe we need a go vet for the third of the two: off by one errors.
I've used goautomock to generate mock implementations for testing, and so far I'm quite happy with it: https://github.com/ernesto-jimenez/goautomock
My usual advice is "Write fakes, not mocks". If nothing else, it makes writing Mocks easier. So, instead of creating a MockDirService, you write, e.g. type FakeDirService struct { dirs map[string]bool } func NewFakeDirService() *FakeDirService { return &amp;FakeDirService{ dirs: make(map[string]bool), } } func (d *FakeDirService) Create(path string) bool { exists := d.dirs[path] d.dirs[path] = true return !exists } You can then use this fake in any tests you have to get isolated behavior. If you want to inject errors, you can selectively mock out methods: type MockDirService struct { CreateFunc func(path string) bool DirService } func (m *MockDirService) Create(path string) bool { if m.CreateFunc != nil { return m.CreateFunc(path) } return m.DirService.Create(path) } func TestFoo(t *testing.T) { f := NewFakeDirService() m := &amp;MockDirService{ DirService: f, CreateFunc: func(path string) bool { if path == "/inject/an/error" { return false } return f.Create(path) }, } DoAThing(m) } Now, all of that being said: In Go, there usually are no "canonically correct patterns". In general, you should try to use the actual dependencies as much as possible and use fake implementations as far down the stack as you can. That way, you prevent a lot of bad test-outcomes, like testing implementation, instead of testing behavior, or testing your *Fake*, instead of testing your production code. Especially, if the thing you are faking has significant business-logic that you'd need to duplicate - in that case, it would make more sense, to use the real deal, but maybe fake out *its* dependencies. For example, if you are using a Database, it probably makes more sense, to start the actual database on a temporary directory and pass a connection to it to your production code, instead of creating a fake (or mock). In particular, I would only use mocks if you want to test the error-handling (and don't just inject errors to enumerate to your error-handling paths, but check actual pathological error conditions, like interruptions or corrupt data). Writing good tests is hard. And there isn't "the right" way to do it, sadly.
Idiomatic Go code uses blocking reads and writes, and implements concurrency via launching one goroutine per blocking operation. This is how it looks to the Go programmer (and future readers of the code) because it is a simple model to reason about, which makes bugs more rare and maintenance cheaper. It is up to the runtime to arrange that request for blocking I/O is then implemented in an efficient way. For networking file descriptors, they are actually set to nonblocking, and the runtime uses async I/O to multiplex the I/O onto one or a few system threads. I am pretty sure that this does not yet extend to file descriptors opened via os.OpenFile. In that case, each blocking read/write will result in blocking a system thread. Depending on the setting of GOMAXPROCS, the runtime may arrange that other goroutines start running while the one that is blocked on I/O sleeps. If those in turn also block, you will eventually end up with GOMAXPROCS system threads that are blocked in I/O. The effect is the same as async I/O, but maybe with a lower cap on concurrency that you might have implemented via async I/O. As always with performance tradeoffs, you need a real use case with a real measured throughput to decide if you want/need to do extra work beyond programming it the simplest way possible. -jeff
Logged the request: https://github.com/nuclio/nuclio/issues/280 I would be inclined to contribute once I manage to get through the initial learning steps and start trying to use it in production 
Please No! Stop it! This hurts! You have a function which's purpose is to create a directory or fail in certain conditions. If you want to test that you will _have_ to create a directory. Stop that mock nonsense and that "unit test must not access whatever" crap. If the sole purpose of the unit under test is writing to the filesystem you have to write to the filesystem. The go tool handles the directory "testdir" especially: You can add test files and directories to it and it is not considered a package. Very handly. Set up a file structure which contains all the cases you are interested in testing, like "directory does not exist but parent is write protected" or "directory already exists". Then write test. The only thing to remember is to clean up created stuff. That's simple, defer that code. Take a look at how the standard library of Go does it's testing. There is no ultrasharp and clear border between "unit" and "integration" testing. Just stay sensible.
I'd happy to get in touch and discuss this project (please inbox). As a web developer I automated most of things I felt were repetitive. Each day I find more things to automate as well.
need help
The context allows you to forget about goroutines and concentrace on requests. The context was specifically invented to make it possible for some request-related data "to cross API boundaries" — as stated in its documentation.
Thanks, your problem is not quite clear to me. Unfortunately, what you're actually after is wanting a global variable. You can call it whatever you like ("attaching something to a goroutine and then getting it back") but that's merely it: you want some global state to be available because there's no (apparent) way to somehow sneak the extra data into gob decoding (which appears to be "purely functional" by only considering input data). May I ask you to raise this question on the [Go mailing list](https://groups.google.com/d/forum/golang-nuts)? Please don't say anything there about goroutines and their IDs—just state why you'd like to make certain global state available in a gob-decoder.
Yeah! Awesome! Now we need context everywhere instead of gls! By the way, the `WithValue` is much more flexible so we need type checking on our own!
Please try to actually ask the question. I, for one, fail to parse "why coming channel concept while explaining method concept" as a question. That's absolutely okay that English is not your native language but still we need to bring your question up to certain form for it to be comprehensible. Try not to cram many words in a single sentence. It's OK to have multiple sentences stating what you have/see and then another one—asking a question based on the stated facts.
`*plonk*`
I see the benefit of having one tool that can be reused across a complete, multilingual development ecosystem. Frankly, if I had Bezel around (and would be familiar with it), I would probably also just throw it at any slow Go build that I come across. Problem solved! And solved in a pragmatic way just as we Gophers love it. My point is more that if I only have the problem of build speed in Go (and no Bazel or other build tool already in use), then I would first try to find ways to improve this with the language's own tools and features before considering to deploy (and maintain) a full-fledged build/test framework. But then we clearly talk about different scenarios here!
so yeah you mean for fs operations, there is no need to use mock objects, but what about db operations and api calls ? should send a request or insert a row everytime when testing?
If you're testing a function, that does a filesystem operations - you need to perform filesystem operation. However, if you're testing a function that only consumes a result of a fs operation - you can fake it. It's similar with testing API. If you want to test if API works, you need to make some API calls. But if you're testing a piece of code that only consumes some API response, you don't need to make any calls, just provide that function with some prepared fake response. If you're testing a function that actually writes to DB, you need to have a test database and perform a write operation in order to test it. If you'll fake all r/w operations with `return true` or `return false` you're not testing them at all - you're just testing if your code handles the succesful / non-succesful cases correctly. So, it you're testing a code that actually reads from DB, you need to execute a `select` query on a test DB, but if you're testing a code that just consumes some data that came from DB, you can fake it. There's nothing wrong with setting up a DB for test purposes. Have some test schema and data prepared beforehand, set it up, test all the stuff and perform a cleanup. Nice and easy.
Watching these videos has really improved my Go programming in so many ways. Thank you, Francesc. You're awesome.
The best demo I've ever seen of the Go tracer :)
Thank you. Could you also return the positions of the submatches? That makes some kinds of apps possible.
Don't focus on one particular language for this kind of a problem because the problem is really hard. table/text extraction from pdf is really hard because of the way pdf are created and rendered. its not necessary that the line you get to read in a rendered pdf is necessarily also a line in pdf. I choose tetpdf(c executable) + tabula (java lib) and invoke them using os proc, getting their output in a file and then reading that file in golang/php, and making my pipeline on top of this extracted file.
The position of submatches is already available. Please see the `fuzzy.find` returns a sorted list of `[]Match`. `Match` contains a `MatchedIndexes` field which contains what you want. See https://godoc.org/github.com/sahilm/fuzzy#Match. P.S. I guess this wasn't clear from the docs. Any pointers on what all I should add? Thank you :)
Great to see this -- the tracer is at the intersection of incredibly powerful, but very underdocumented.
What's the other problem? Getting things done? ^^,
That is one option; I had a buddy do raw "shortest path between two articles" for a college project in C#. Another variation is simply mapping N depth out from an article. This is sorta vague but I feel it offers the best use of concurrency if you wanna explore that. If you found a way to share what links were already hit and cull those dead ends, that might be neat. Finally the last might be some variation on "six degrees to Kevin Bacon" where you find articles or subjects that share some strange common thread. Like how many heads of states can you find from the Holy Roman Empire page or something silly. Ultimately what makes a junior versus a senior developer is being able to be self directed, so pick a goal and hone that problem solving! Hope it is a success.
&gt;I am pretty sure that this does not yet extend to file descriptors opened via os.OpenFile. In that case, each blocking read/write will result in blocking a system thread. This is my understanding as well. &gt;Depending on the setting of GOMAXPROCS, the runtime may arrange that other goroutines start running while the one that is blocked on I/O sleeps. If those in turn also block, you will eventually end up with GOMAXPROCS system threads that are blocked in I/O. This does not match my understanding -- I'm under the impression that any thread blocked on i/o sleeps does not count toward the number of runnable threads -- that is, the runtime will create or re-use an existing thread for the io operation and mark the goroutine as sleeping, but still keep GOMAXPROCS threads/goroutines running (This would apply to all syscalls). I believe there's a maximum 10,000 thread limit. &gt;The effect is the same as async I/O, but maybe with a lower cap on concurrency that you might have implemented via async I/O. Very close, but not quite, I don't believe. I think if it were async i/o, we might be able to have better options for timing out/setting a deadline on a file read/write. As it stands, it's _sort of_ possible. You can do the file operation in another goroutine, and use a channel to signal it's completion -- at that point you can use `select` against that channel, and a context, and time out -- the actual i/o would still be underway, but the user-facing end could move on. (Use case here would be, say, properly being able to return a 5xx response if a file operation took more than N seconds). The behavior can be particularly obnoxious if the underlying drive fails, and all threads doing i/o operations against it get stuck in an uninterruptible sleep -- you have to wait for the kernel to time out the i/o operation, which is usually longer than you want to wait. I suppose you could argue the above behavior is an implementation detail -- you could specify a timeout while doing synchronous if the kernel supported it.
It's indeed a lot of code to write for such a simple scenario. But for DB operations/API calls, I usually do what /u/TheMerovius suggested. If I have a PostgresUserStorage, I'd then have a InMemoryUserStorage that is used during unit tests to make testing faster and more reliable. That being said, I also have tests for PostgresUserStorage to make sure the SQL commands are working ifne. Before each testcase I initialize a PSQL (inside docker) database with a well known set of records so that I know what to expect from my tests. This is by far the slowest package to test, usually 30 seconds to run while the rest is &lt; 1 sec
The trouble with this approach for me was that I had two almost identical structs. With slightly different field types. Such as string and bson.ObjectId for MGO data structs. I'd have to write code to manually iterate through nested datasets, converting string to mongos proprietary id format. Etc. It was really tedious so I just found a way to reuse the structs for both purposes. But actually I never found a way to generate the mongo custom id field. How do you approach having to convert your PB messages to your db structs?
There is never an absolute "need" for anything. It all depends and requires judgment. In your case there is not a tiny bit of need for a mock (or a fake). If you ask about a specific example regarding a "DB" iI might come up with an answer but don't try to get a "for DB you always and must do ..." statement. That's not how it works. 
I would love to see an example of Bazel+Travis+Go and how it all ties together. Adding a `.travis.yml` or a follow up blog post would be great. I'm trying to better understand how Travis+Bazil compares to Travis+`go build -i`
I went to play and I made this: https://play.golang.org/p/Gsp9qzGbdv Using it I was able to look at the execution traces for parallel io.Copy. I found that the call to os.Remove caused the goroutine to be suspended while the potentially blocking call was shunted onto a system thread. But the calls to Read/Write inside of io.Copy are implemented without any preemption, and are actually calls to internal/poll.(*FD).Read:121 and internal/poll.(*FD).Write:218.(See https://github.com/golang/go/blob/release-branch.go1.9/src/internal/poll/fd_unix.go#L121) TIL: Something like the netpoller now exists for regular file IO. The execution traces show full utilization of the processors, driving reads and writes. I suppose it could be interesting to compare wall clock timings for 100 file copies with GOMAXPROCS==numcpu and GOMAXPROCS==numcpu*2, but I'm going to leave that to the OP. Tell us what you find!
What I learned about the execution tracer from this video I just put to use answering this question: https://www.reddit.com/r/golang/comments/785jgj/tools_for_async_file_io/ 
[removed]
Not that I know of. My company is using a lot of legacy SOAP services, that some new Go programs need to interface to. After looking into a lot of solutions we got three prevailing solution for different cases: 1) https://github.com/hooklift/gowsdl - more or less works, but some types of services fail for silly reasons. You will sometimes need to adjust your SOAP services to support the formats that gowsdl requires. For instance, we have found that that functions with parameters that are complex types - the name of the parameter, and it's type have to be the same, otherwise the XML gowsdl creates is invalid. 2) Send raw POSTS and create/parse XML manually - sometimes easier than gowsdl. 3) Re-write the SOAP service in REST or smthing easier to interface with, or find a way to live without said service altogether. (This is the most common solution btw). I know, all the above solutions are terrible, but that's what you get when using legacy technologies in a relatively new language.
[removed]
&gt; May I ask you to raise this question on the Go mailing list? I've posted it, along with a bit more specific context as to the reasons why. It may take some time to appear as I've never posted before. Also, I'm generally in the "be more civil" squad myself; if I didn't like and respect Go I wouldn't have gotten far enough to have this problem. (My position on "generics", for instance, is actually that I'd like to see a solution to the abstract data type problem, whatever it may be. "Generics" as a whole is not my issue; I miss being able to go grab "a red-black tree" or whatever fancy thing I need.)
Haven't watched the full video yet but during your talk last week I noticed proc1 was missing from the web view of the trace for the goroutine-per-pixel. Any idea why that might be?
just a note... the directory name should be "testdata" not testdir. Also applies to any folder starting with an underscore or period. Any of those will not be matched by pattern matching such as `go test ./...` so you can safely store whatever files you need. I agree with the above... the *only* thing this function does is create directories... so you can't really mock it out. However, it's also really quick to create directories, and you always have a filesystem you're running on, so it's not a big deal. It's not like it makes your tests require a running database server or something.
This makes me far more likely to use the tool. Do you still use a transit relay for all the data?
Unit testing: Import test. Mocking: Code to interfaces.
[removed]
Call os.Exit to have the application exit.
Given that this is /r/golang and somehow nobody else has mentioned it, check out Gogs. It's a self-hosted Github-alike written in Go. 
done.
From the [Go 1.9 release notes](https://golang.org/doc/go1.9#os): &gt; The os package now uses the internal runtime poller for file I/O. This reduces the number of threads required for read/write operations on pipes, and it eliminates races when one goroutine closes a file while another is using the file for I/O.
Kudos for being calm and to the point!
I had so much trouble with generating structs from a huggee XSD at my old job I wrote my own recursive generator, I should polish it up and put it on github... or just put it on github and let people fix it ha
Is all the data going through the relay? Or does it do some sort of TCP hole punching wizardry to turn it into a p2p connection (https://en.wikipedia.org/wiki/TCP_hole_punching)[https://en.wikipedia.org/wiki/TCP_hole_punching]
Thanks for the correction. I stand corrected. I spoke like a true novice. Glad that things are fixed in proto3, unfortunately we are stuck with proto2 in near future and will need a serious overhaul of messy codebase to move away from proto3. 
I use this approach actually because I found I had to write slow complex code, iterating over all my generated protobuf structs, to convert them into almost identical structs for the database. Having said that, re-using these structs didn't work with Mongodb, as Mongo has a custom data type for Id's (bson.ObjectId). If anyone has a solution for converting between protobuf types, and internal structs such as for databases etc, I'd love to know how you handle this! 
Mew-tex ha funny
I just threw together something similar to this using io.Reader/Writers ha https://github.com/pborges/iopubsub not sure why
Yeah, we're not really programmers, which is probably the biggest problem, but I agree. We're both production engineers recently graduated. He is a data analyst and learned R from uni, and I'm a process engineer. I taught myself C# during uni and learned Python to do analysis for my final project. As an analyst, I don't understand why he wouldn't want to learn new languages. I would love to have a group that could switch from one language to the next whenever. Unfortunately, I think him and I are the only two non-managerial staff that know any languages. We work at a company with a lot of old engineers who think its amazing that I can edit text files with a python cli script.
I'm using [manul](https://github.com/kovetskiy/manul) at work which solves the dependency problem with Git modules as well, but I'm migrating to [dep](https://github.com/golang/dep). One problem I've encountered is that using Git modules code un-`go get`able (since 1.8, see [#17522](https://github.com/golang/go/issues/17522)). Also non-Git managed code obviously can't referenced with Git modules, though I've yet to find such code.
/u/Kohlerbear, have you considered using https://godoc.org/github.com/kisielk/gotool instead of making a copy of imports.go?
This will sound like a dumb question but is there a point in buying gogland if you already own intelliJ then?
That's a great idea! I hadn't considered that, I absentmindedly grabbed that file awhile back.
Cool, thanks for the detailed explanation! Fun fact: I found out that this is actually called Wikiracing: https://en.wikipedia.org/wiki/Wikiracing
There are so many projects like Pyston, Unladen Swallow etc that have fallen by the wayside. I'm just wondering what the thinking is? Cross compile to make things faster, but what makes things threadsafe in a language that doesn't usually deal with it? Assume that we're swapping out something that's stateless?
I don't think Gorm supports adding column to join tables. I recomment you to create a dedicated struct to the join table. Then you have the flexibility to add column and write any SQL you want.
Seriously. I'll often learn something that's not specifically what he's talking about. For instance, I could not, for the life of me, figure out WaitGroups. Then I watched this, and seeing him use it, even without explanation) was enough for me to just *get* it.
Nice, you should be able to simplify your tool as a result! Most (all?) other tools use `gotool` as well, so you can be sure it's well supported.
Let's take a step back - Cancelling on an os Signal is an application concern that shouldn't be down at the level of your Kafka workers. You are far better off (imo) passing down a https://golang.org/pkg/context/#Context that you can cancel for whatever reason you want. If you use https://godoc.org/golang.org/x/sync/errgroup, you can easily catch errors from any one of your Kafka objects, cancel all of them, and wait on them all exiting. Similarly, you can put your http.ListenAndServe in an errgroup goroutine, but you'll need to explicitly stop it. You can handle that by having another goroutine listen for the context.Done, and to call https://golang.org/pkg/net/http/#Server.Shutdown 
Because this would be too simple. OP needs an involved solution that's very complex because his problem is super unique.
I've only used Mongo in C#, but [goinbigdata has an example](http://goinbigdata.com/how-to-build-microservice-with-mongodb-in-golang/) that looks pretty good. It uses Goji, but if you wanted a different router, that part shouldn't be hard to swap out.
How does this compare to fzf? https://github.com/junegunn/fzf
The OpenSPF test suite includes a DNS zone data section and requires the test driver to provide a fake DNS server to handle the zone data. Are there any test suites that do not require a fake DNS server?
Need some more tweaks in the code base to test bazel in travis properly. Caching seems to be working well, but I want it to be stable before I post.
fzf is a tool with a much larger feature set. fuzzy is just a humble library that you can add to your code.
Here's a basic example: https://play.golang.org/p/MrI29X_Djp You will need to study both the MongoDB and MGO docs to really learn how to use the more sophisticated features.
This is what I use. Works well.. https://github.com/codegangsta/gin
I'm the author of this package. Thanks for the mention :). I developed this package out of frustration with dealing with an Apache Axis2 application (BT Diamond IPControl) using python and the 'suds' module. Ironically I changed jobs before I got a chance to use my own package. I continue to work on this because I know that it's dirty work that nobody wants to do, but that a great many people would benefit from. I've gotten a burst of motivation recently by tricking myself into believing I'm writing a compiler of sorts :) Let me enumerate all the caveats (that I can think of right now). * It is not as battle-tested as [hooklift/gowsdl](https://github.com/hooklift/gowsdl). It probably won't handle all the WSDL that package can handle. * The `wsdlgen` utility is much less mature than the `xsdgen` utility. * It does not handle sum types like `&lt;union&gt;` and `&lt;choice&gt;` very well. For `&lt;union&gt;` it just uses a string, and for `&lt;choice&gt;` it builds a superset of all sequences. * I strongly favor ergonomic code over conforming perfectly to the XSD spec. * You have to do the legwork of fetching all the XSD/WSDL documents and their dependencies. There's [an issue](https://github.com/droyo/go-xml/issues/35) for that. * The output of `xml.Marshal` on the generated types will be verbose. Lots of redundant `xmlns` declarations, and empty sub-elements. There are issues opened for this. That said, when it does work, I'm quite happy with the quality of the generated code. Generated code is free of external dependencies, and the type declarations look like normal go code. For example, a type with an XSD `DateTime` field will use `time.Time` in the Go declaration, and a `base64Binary` type will use a `[]byte`, encoding/decoding at Marshal/Unmarshal time. If you want to help, the option with the lowest effort/impact ratio would be to follow https://github.com/droyo/go-xml/tree/master/gentests to provide example schema &amp; documents to test against. I've had trouble finding example data that is sufficiently complex, realistic, without being too sprawling.
You can use `go test -i` to compile test dependencies.
1 Reading full configurations from Consul into a Go map that I can later pass around all the functions that need to create resources/components based on this config. 2. The reverse is to stage consul with a full configuration map. I come from Clojure where code is data, so I might be a bit off on `#2`, but I see no alternative to `#1`, is there any?
I'm really thankfull. it seems to be working. If im not asking for too much, can you give an example of inserting data into the db?
Was it maybe `realize`: https://www.reddit.com/r/golang/comments/76zg1l/realize_15_manage_your_golang_workflow_with_ease/ and https://github.com/tockins/realize
please do share the outline 
 aPerson := person_doc{LastName:"bower", Zip:"71234"} // _id is auto loaded if not Id not set err = collection.Insert(aPerson) if mgo.IsDup(err) { // got a duplicate key error, shouldn't happen with auto loaded id } // update err = collection.UpdateId(docId, bson.M{"$set": bson.M{"last_name":"bauer"}} Hopefully that works. I usually set the key value using: doc.Id = bson.NewObjectId().Hex() That way I know what the key value is up front and it is a simple string that is easy to work with. 
Thank you
Now, it's being documented by /u/campoy :)
Obviously you should use git submodules to do vendoring. Make development easier. I just do it manually though, but cool if you've got a helper script!
I really don't understand why everyone keeps trying to unmarshal xml, it's a dom and needs to handle xml like the html package does. Parsers and lexers for xsd though... tough one.
I think everyone keeps trying to unmarshal it because it's convenient, works for simple cases, and lets you pretend the XML doesn't exist :). I agree it's not always appropriate. There are limitations, and you lose information going from a document tree to a Go struct. For example, to write the xsd package in this repository, I used the [xmltree](https://godoc.org/aqwari.net/xml/xmltree) package to preserve and manipulate the tree structure of schema docs. It would have been really cumbersome otherwise.
I will be able to in a couple of hours. I'd like to clean it up a bit and add some comments so that it can hopefully be helpful to you.
I'm just getting started with Go and was looking for a similar tool the other day. Settled on this one: https://github.com/githubnemo/CompileDaemon It's really basic with not a lot of bells and whistles but it does what I need at the moment without being overwhelming.
Non-Git managed code cannot be pulled by `dep` either. And submodules are as `go get`able as `dep` vendored code. The actual issue with Git submodules is if your dependency is managed by Mercurial or Subversion. You can still mirror those in Git and submodule from there though.
You could mock out a resolver interface to resolve against a hard-coded list of records.
always looking for help with Ponzu: https://ponzu-cms.org :)
I thought this was pretty interesting. Lots of companies are using Go, which isn't a huge surprise. But I did find it useful to see their dev process, tools, and what other languages they are using in various domains. 
If you don't want it to think that a record is new and needs to be inserted, you need to set the ID field in the struct to the ID of the existing row.
Note that actors is independent of akka and is used in other languages such as erlang. FWIW, I prefer actors over csp channels.
Thank you so much! We actually just moved off of AWS and I'm not sure we would want to use Cognito. I've explored Auth0 and it seems like this is exactly what they do themselves (with single sign on through the Auth0 platform).
yeah. actors are more composable. see erlang actors.
Oh yeah, I totally get that. I'm going to be moving off of cognito as soon as I can in favor of my own solution for jwt auth, but it was a quick way to get auth going and make the clients happy. Sorry to be OP-doesn't-deliver, but I think it will actually be tomorrow, because of those selfsame clients :P
As long as you have some way to issue tokens, and a public key store for the token set then you should be good to go :)
Yes, I have a public relay setup. It would be cool to figure out how to use NAT so once the two computers are identified they can directly communicate. Right now the relay just glues the TCP connections together.
Right now all the data goes through (encrypted). But I would like to do this!
The comparison left me seeing the actor model as notably faster than csp for the most basic case, but lacking regarding composition flexibility wherein the speed difference is negated by additional user-designed control flow. What might I be misunderstanding?
This is the only one that made sense to me quickly and helped me get my vanilla Go recompiling in a VM quickly. 
There are also [actor implementations in Golang](https://github.com/AsynkronIT/protoactor-go)
Perhaps it is clearer if you don’t embed the interface and struct, like https://play.golang.org/p/BriWS02Jmb Compilation now fails as you were expecting. When you embedded Interface into base, the compiler generated a a new method, (*base).text. When you embedded base into C, the compiler generated the (C*).Greet and (*C).text methods from base like this https://play.golang.org/p/w7Y7ivco-f Run that code and you will see what is going on. 
The testing and CI tools were very interesting 
The distinction made in this article applies only to unbuffered channels. Buffered channels are not confirmed to the sender and can take arbitrarily long. Buffered channels and goroutines are very close to the actor model. The real difference between the actor model and Go is that channels are first-class citizens. Also important: they are indirect, like file descriptors rather than file names, permitting styles of concurrency that are not as easily expressed in the actor model. There are also cases in which the reverse is true; I am not making a value judgement. In theory the models are equivalent. This misunderstanding has been circulating too long; this is only its most recent appearance.
+1 to Lyft for using emojis as commands for the pull request management tool. (I know, that's a completely irrelevant aspect of a developer's work day, but I like the idea.)
&gt; Monday, March 11, 2013 - by Dominik Honnef 
https://johnsogg.github.io/emacs-golang Also good. Godef-jump is nice :-) 
Why not submit these as changes to Go itself?
The saying is the only two truly hard problems in CS are cache invalidation, and naming things. Theoretically if you can do both of them perfectly, you can solve almost any problem quickly and elegantly. And they are both really hard. If you ask 10 knowledgeable people you'll probably get 10 answers about how to handle each of them.
&gt; FWIW, I prefer actors over csp channels. I'm curious why you think so. I've spent a lot of time building systems with actors in a proprietary system. I've seen unbounded queue growth bugs hit the production servers a couple of times and it was always quite hard to pinpoint the real cause. Nowadays I would rather debug channel deadlocks (easy to see what went wrong because the processes are frozen!) rather than actor queues going haywire. Also flow control is automatic with channels.
Yeah... it sucks. If you can find a way to make the structs work together, then that's awesome! For my code, I've found it doesn't take a very complex message to ruin the whole scheme. I have messages nested in each other, with slices and maps, and also timestamps - which are extra annoying because decoding a timestamp can fail, at least in the Go implementation. To be clear, I don't think if you use the generated structs a lot you're by definition writing bad code, just that it might not be a good idea. It's probably worth having someone who hasn't looked at the code before try to understand it to make sure you aren't making code too hard to read. I could see it being fine for a small program (25-50k LOC) but larger than that it might make code harder to understand and change.
thanks. In that trivial example definitely. Unfortunately in the real case I'd manually forward a lot of function calls which is why I decided to keep the anonymous struct/interface at the cost of run-time errors in case I don't implement specific methods.
Have a job queue in the manager. The manager starts a job to update the status of a given agent - if the agent did not finish queue the task again. If it is finished update the status in the database. I don't know of a go project that supports rated queues, but you may find one. And extending an existing worker/queue library might not be hard. You could also go with a looping/sleeping adhoc goroutine, but handling a lot of jobs roughly at the same time will considerably worsen the performance.
I don't think he's learnt it yet :(
Thank you!!! Realize was what I was looking for. Much appreciated
Good point. Problem numbers are clickable now.
Thanks, are their any you struggled with or found extra interesting? Maybe a highlights section for the ones that were solved more elegantly due to Go features (or more difficult) would invite some more discussion next time you share. Kudos again to the dedication here.
Thanks, we are working on some major UI improvements to support all the configuration in the CLI + add new stuff (e.g. load code &amp; deps from zip/S3/git, configure event triggers via UI, and add all the function.yaml fields which include runtime, resources, ..), part of that we will make sure the shell runtime is exposed and tested 
How does Bazel compare with Nix? Nix also caches tests or anything else.
There are a few UDP hole punching examples in golang already, I havnt had time to play with em either :P
Maybe it will be useful to someone else
Concurrency in Go is a good one. JustForFunc videos are good too. More importantly, just do simple projects in them. 
I know some large games studios using Go for their online services.
[removed]
Advent of code is coming up! I always do them in go to freshen up. Also if you work with other code during the day, I always find myself writing tools in go to help with everything, day to day work... I have like 10 tools that I wrote. Get into the concurrency stuff. Write a simple website. You'll probably need gorilla web toolkit
Thanks for commenting on this. I also had the same frustration in the past, with legacy commercial SOAP APIs and ended up with https://github.com/fiorix/wsdl2go at the time. Been getting pull requests quite often with various features and fixes for corner cases, data types and so on. Feel free to copypasta or use as reference.
Your first paragraph nailed it. I don't really see the point in just using bazel for your small project. Instead, it makes a lot more sense for larger multilingual code bases. We use buck at work, which is similar to bazel.
Try to solve a real problem that you have, or create a platform that you will like to use, no more blog o todolist projects please
Is Go reliable enough to write complete websites in it?
Does [this](https://play.golang.org/p/ii7aB7uWMA) help a bit?
The new slice is given by the return value of "append". https://blog.golang.org/slices
Gorilla isn't the best choice really.
Sure!
to explain: * `map[int][]MyData` is a type, read it as: "`map` from `int` to slice of (`[]`) `MyData`" * `make(T)` will create a new value of type `T` - in this case, above map. So it's equivalent to the `{}` from the first line of your python code, just statically typed * `age_map := …` declares a new variable with name `age_map` and assigns `…` to it. See [the spec](https://golang.org/ref/spec#Short_variable_declarations) for details. * In Go, `append` is not a method on slices (which is the correct equivalent of a python list; in Go, an array has a fixed length and is something different). Instead, there is a builtin function `append`, which takes a slice and some elements and returns the slice with the elements appended. So, it doesn't work in-place and you need to assign the return value to use it.
This did it. I was confused by the append syntax. Many, many thanks.
Try searching GitHub open issues: [good first issue](https://github.com/search?utf8=✓&amp;q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22+language%3Ago) or [hacktoberfest](https://github.com/search?utf8=✓&amp;q=is%3Aissue+is%3Aopen+label%3Ahacktoberfest+language%3Ago).
&gt; Submodules are as go getable as dep vendored code. Oh, you're right. I must have misremembered and just noted the issue number. 
Yeah. I put Nginx up front and proxy to the go app for backend processing. It's super stable. Multiple ways to skin that cat though.
Oh really? I'd be happy to hear about alternatives. I use the mux and the web socket libraries. They work as advertised, in my experience.
I guess ideally it'd try using IPv6 UPnP port mapping to create a connection, then try IPv4 UPnP, and then if both of those failed it'd use a relay. I don't know if the Go UPnP libraries are any good, though, or how to use them to create a port mapping...
How does this compare to something like ES?
“Ultimate Go” class from Bill Kennedy (ardan labs) is an amazing resource. You can find a video series on safari, and they also offer in person classes. Highly highly recommend all of Bill’s work 👍🏿
Simple and efficient, also need to make persistent efforts.
I prefer Chi as a mux/framework over Gorilla Mux, but still mix that with other Gorilla components for example Gorilla Sessions and Gorilla Websockets
Hi /u/dlsniper, The links in the gist to the Github issues show there *are* outstanding patches in review. The network patch was for an earlier version of Go, which is why I updated it in the Gist. The crypto patch was copied verbatim.
There is a lightweight Go library to create a GUI window with web technologies (HTML/CSS) - https://github.com/zserge/webview It's a thin wrapper over Gtk-Webkit, Cocoa-Webkit and MSHTML so it runs on all modern operating systems and uses decent browser engines (on Windows it's IE11).
cool! have you benchmarked this against `encoding/csv` on tip? it just recently got a perf boost
I believe TCP library https://github.com/kshvakov/clickhouse/ should provide even higher performance, as it basically is a RowBinary format with meta information header. Although this library most probably is the fastest method to read the response via the HTTP.
are you asking me about a demo I gave a week ago? haha watch the video and let me know if it happens again and point me to it, please
thanks!
So why not just link to them instead of putting them in a gist. No offence, you might have the best intentions but I don't trust random links to patch the crypto package. And if they are outstanding patches, why aren't they reviewed and merged already if this is a problem? Lack of reviewers? Or other problems with the patch?
[removed]
The best option for Linux is inotify, but this has an upper limit of the number of files that can be watched. This limit is quickly reached on macOS (I believe it is as low as 256). On Windows, there is no equivalent to inotify, as far as I know. The alternative to these is to loop through all the files "manually" and check if they changed since last time.
You’re absolutely correct. I removed the link from the net patch as it was no longer up to date. I decided to just make the crypto one consistent. Still, great point. I’ll update the crypto patch to point to the Go hosted version.
Good catch. I’ll update that. Thanks!
Sorry, I should've pointed it out at the time! I didn't spot it in the video so perhaps it's OK.
Hi /u/epiris, Thank you for catching this. I've [pushed a patch](https://github.com/akutz/sortfold/commit/93f4d3fd2fc0632e7a625b216d042827ce934be4) that contains your recommended changes. FYI, your own LICENSE file is missing the final line of Go's license. &gt; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
[removed]
Hi /u/dlsniper, I've updated the gist and linked the original patch. Thank you for the feedback! 
The link to the distributed indexing and search Chinese text in it. :) How many nodes do you run, or how many nodes can it run? Does it have node types (master, data, client) like ES?
Cool! I wonder if previous time was a weird bug
Never used nix.
Rewrite some of your old stuff in Go!
Int to string is a well understood conversion, there's nothing uncommon about, it's boring. String to int brings the following issues: overflows, invalid strings as numbers, strings starting with numbers then characters, empty strings. All of these are cases which can happen, and, sooner or later, will happen. How should the runtime handle this? Panic? Silent error? There is no error returned from casting so silent would be the only option. But then what if you could handle this better than the runtime chooses to do it? That's why it's not always possible to have a reversible cast operation. Also see https://godoc.org/strconv#Itoa and https://godoc.org/strconv#Atoi and their implementation. 
What mind of string is produced by that? I guess it makes sense as a convenience for ASCII codes and such to be castable to strings, but I agree that this operation is somewhat awkward compared to casting int to rune.
It seems like a natural consequence of a) having rune be an int-type, meaning untyped integer constants can be used for them (and `'x'` being effectively an untyped integer constant) and b) enabling converting runes to string, i.e. enabling `foo(string('x'))`. Honestly, it seems like an edge-case, but one that won't make a lot of problems in practice, so *shrug*?
We have new and more advanced license management in 4.4 (Nov) of AppD. Also, you can setup alerts easily for this in AppD.
I meant posting those things on the project page would help others decide, "Is this project going to be useful for me?"
Do have problems with it... Recently changed a variable from int to string, and was hoping for a build fail for all situations and tests. Because of this conversion, there's no check for that and I'll have to comb a lot of code for this.
Gorilla Sessions uses global map, which tends to lock during high RPS surges. Context-based solutions are better for this overall (or really anything with structures having real per-request lifetime).
While I agree that int-to-string is kinda boring, and maybe well understood, I don't see any good reason for it to be accepted by the compiler, especially in a language that is so strictly typed. I can understand a int slice, since it's the same as a byte slice, but a single byte does not make a string... As for reversible, I did not mean that I expect int(string) to work. That was bad wording from my side. I would much prefer non-reversible type casts to be not allowed, than have something like this.
&gt; At the very least, I expected all cast operations to be reversible, as it is with all other types I know. What does "reversible" mean? There's `[]byte(string(b))`, which will return a value that's different from `b`, so that's not really reversible. Or there's `float64(int(math.Pi))`, which isn't equal to `math.Pi` - or `float32(float64(math.Pi)) != float64(float32(math.Pi))`. On a statically type-checked level there is `io.Reader(io.ReadCloser(r))`, which works, while `io.ReadCloser(io.Reader(r))` doesn't. Or, similarly, `io.Reader((*io.PipeReader)(r))`. We have `(chan&lt;- int)((chan int)(x))`, which can be okay, while `(chan int)((chan&lt;- int)(x))` can't. 2 of these 6 combinations work, the rest don't: u := []byte(string([]rune(""))) v := []byte([]rune(string(""))) w := string([]rune([]byte(""))) x := string([]byte([]rune(""))) y := []rune(string([]byte(""))) z := []rune([]byte(string(""))) A bunch of these are nit-picky… But I really don't think the generalization you made is valid that way :)
That seems admittedly unfortunate (though the problem only seem to matter in cases where you'd convert that variable to another string-type again; I agree, that it can't be excluded though). It might warrant a bug filed to consider changing this for Go 2.
That doesn't work, but this does: int(rune(string(65)[0]))) Strings aren't sized, where runes are. What would the type conversion for "aaa" be? Do you add the value of the UTF-8 characters together? Do you just concatenate them like strings? There's not really a sane answer. If you convert it to a single rune, you know it's only one character, and you can convert that to an int without all of the strange questions.
Good point here. What I meant was to be able to do type1(type2(type1)) without the compiler complaining. I probably went a bit overboard with the reversible part. Losing some fidelity with going from a bigger type to a smaller one is understandable, but float-to-int is more or less in the same ballpark compared to int-to-string. As for your examples, most go from a specific type to a more generic type. Where as int to string kind of jumps the gun, string not coming close to being a "general" kind of int. But they do show that not all conversions are type acceptable. 
Sorry for the confusion on the reversible part. That was bad wording. I would prefer that string(0) not be allowed. I agree that int("ABC") is dumb.
Go is a lovely language. Fingers crossed it'll increase market share over Java.
[removed]
string(0) has a logical conversion though. You're thinking of it as passing in an int, which is what you're doing in a literal sense, but in the contextual sense, you're passing in the value of a UTF-8 character. It's basically just letting the compiler know that it should start interpreting a given block of memory as a UTF-8 character rather than an int. They could add a UTF8Value type, but then you end up doing this: string(UTF8Value(0)) Which doesn't really accomplish anything, is harder to read (I think) and adds a few key presses without getting any benefit for it.
[removed]
As I wrote, ch-encode only generates data for insertion. You need to use writers from https://github.com/sirkon/ch-insert to actually insert data into Clickhouse. There're three of them there: 1. HTTP level inserter which should only be called by Flush in buffering objects 2. Special bufferer as the standard `*bufio.Writer` will not work 3. Writer that tries not to write more than 1 time per second (official recommendation). It works upon the bufferer.
A string is a slice of bytes. A UTF8 character is just that, a character. Not exactly a slice. It would've been more logical to do: string([]byte{1}) Go already makes the programmer write pretty verbose and sometimes hard to read code. Adding readability and saving a few keypresses for a relatively strange edge case is kind of a moot point.
Integers and floats have well defined number ranges. Formatting them into things like currency or scientific notation are specific use cases, so I don't really see what's the reasoning behind disallowing `string(int)` aside from your preference. Can you come up with some examples where the conversion from 123 to "123" (or whatever number you have) wouldn't be wanted? Currency types wouldn't (must not) use a float value as the representation because of rounding errors, there is [arbitrary precision arithmetic](https://golang.org/pkg/math/big/) and [scientific notation](https://www.nyu.edu/pages/mathmol/textbook/scinot.html) to represent big numbers, and if you wanted to format numbers according to locale rules, you'd resort to such string formatting specifically for the currency you're working with. You wouldn't use any of these in usual programming unless you had a very specific use case for them.
https://play.golang.org/p/Ehzlsh6234 - if you want a null terminated string, string(0) is as good a way to produce a null character as any other options. No?
Just to make sure-- string(123) will -not- result in "123", but a character, specifically "{". This is equivalent to something like [python's `chr`](https://docs.python.org/2/library/functions.html#chr).
I stand corrected. Also equivalent to chr/ord in PHP. And I guess many others. Somebody already mentioned that you can convert back from a rune, so you'd have to do something like `func ord(s string) { return int(s[0]) }`
Appending to 0 a []byte would make more sense, though, both from a intent perspective and from a performance one, as the string concat will result in the string being copied to anther memory location.
Become a go contributor: https://golang.org/doc/contribute.html Seriously, reading the std lib will make you a better Go programmer, and picking up issues and solving them will force you to read the std lib.
Append allocates, and I'm reasonably sure that `string(0)` might be completely optimized away by the compiler. Go isn't a scripting language ;)
I know, I’m a consultant with AppD :D Just improving my Go skills while playing with the Api
The conversion string(int) was added at the dawn of time because it provided, before fmt, the simplest way to convert an integer to a string. In other words, it was just a hack, nothing principled. I think it should disappear in Go 2. https://github.com/golang/go/issues/3939 
It's so that you can do `string('C')`, I would assume.
And now you have that raft cluster to maintain. For infrastructure that already runs etcd, that's *more* moving parts.
Yes, I've been following the C-&gt;Go machine conversion work. I guess the reddit submission is misleading, though, and could lead people thinking this is what they should do to interact with X11.
Yes. Definitely. 
&gt; A string is a slice of bytes. A UTF8 character is just that, a character. Not exactly a slice. If you go further down, a byte is just a type alias for uint8. So a string is a slice of unsigned integers. &gt; string([]byte{1}) That doesn't work for non-ASCII characters. byte is an alias to uint8, so it's maximum value is 255. UTF-8 characters are up to 4 bytes, so they can be way higher than that. If I pass a UTF-8 int in there, it overflows and wraps around. That's also not to mention that that code snippet is what Go does under the hood. Take the int, convert it to a uint8, and then use that memory as a string. Go is just saving you the step of explicitly converting to a uint8. To be honest, I think this is the sane way of handling it. Yours is much harder, and involves segmenting an int on memory boundaries to handle non-ASCII characters. In addition, if I work with ASCII and UTF-8, your solution requires me to have different code paths for each due to the differing lengths of characters in those encodings. &gt; Adding readability and saving a few keypresses for a relatively strange edge case is kind of a moot point. I don't think it's really all that strange of an edge case. Keyboard input is commonly addressed as the ASCII code for the key that was pressed, instead of the character as a string. It's also a feature of C, so I think they preserve it for feature parity.
We offer mentoring for new contributors to https://github.com/purpleidea/mgmt/ Join us in #mgmtconfig on Freenode if you're interested. Ping me and stay in channel.
It definitely seems like a hack given how it behaves in some cases. I take it you're quite familiar with UTF-8, so I'll take your word for it :) Thanks for creating the issue and linking it here! Personally I'd prefer to see Itoa everywhere as it's more consistent with Atoi anyway.
Seems like you're mistaking compiler optimisations for actual no-allocation behaviour. Because you're using an empty string and always assigning the same thing, the compiler notices that and optimises it away. You'll have to run this on a local machine, since the playground takes too long https://play.golang.org/p/Aiv4lvO-b5. With compiler optimisation and inlining: $ go build bmark.go $ ./bmark -concat AppendFunc | Total allocs: 63, Bytes Allocated: 6168958912, AllocPerBytes: 0, String: 1000000000 2.57 ns/op Append | Total allocs: 66, Bytes Allocated: 12049299392, AllocPerBytes: 0, String: 2000000000 3.05 ns/op ConcatFunc | Total allocs: 0, Bytes Allocated: 0, AllocPerBytes: 0, String: 50000000 28.7 ns/op String | Total allocs: 30000000, Bytes Allocated: 60000240, AllocPerBytes: 1, String: 30000000 38.1 ns/op Empty String | Total allocs: 0, Bytes Allocated: 0, AllocPerBytes: 0, String: 100000000 10.2 ns/op Slice | Total allocs: 1, Bytes Allocated: 16, AllocPerBytes: 0, String: 2000000000 0.68 ns/op BigConcat | Total allocs: 1000475, Bytes Allocated: 503995716080, AllocPerBytes: 1, String: 1000000 49594 ns/op Without optimisation and inlining. Notice how, for some reason, the empty string variant stays at 0 allocations: $ go build -gcflags '-N -l' bmark.go $ ./bmark -concat AppendFunc | Total allocs: 55, Bytes Allocated: 1034565568, AllocPerBytes: 0, String: 200000000 8.24 ns/op Append | Total allocs: 60, Bytes Allocated: 2526492688, AllocPerBytes: 0, String: 500000000 3.45 ns/op ConcatFunc | Total allocs: 30000001, Bytes Allocated: 120000480, AllocPerBytes: 1, String: 30000000 45.8 ns/op String | Total allocs: 30000000, Bytes Allocated: 60000176, AllocPerBytes: 1, String: 30000000 41.5 ns/op Empty String | Total allocs: 0, Bytes Allocated: 0, AllocPerBytes: 0, String: 100000000 11.0 ns/op Slice | Total allocs: 1, Bytes Allocated: 16, AllocPerBytes: 0, String: 500000000 3.10 ns/op BigConcat | Total allocs: 1000517, Bytes Allocated: 503995719440, AllocPerBytes: 1, String: 1000000 49635 ns/op
It will be interesting to see how Kotlin does here too as it provides a much easier path away from Java for a lot of companies. There's room for both, I'm sure, but Kotlin has an advantage over Go because of interoperability with Java libs while also running on the JVM. I wouldn't miss Java and I love Go, so I hope you're right.
Just an update: got an answer from Rob Pike - https://www.reddit.com/r/golang/comments/78hxd7/why_is_stringint_a_valid_cast_operation/dou5s1g/ I was wrong about the byte part. Still, you can always do this string([]rune(256, 267, 300) So my point stands. As for C feature parity, I don't think Go ever strived for that.
Note I didn't watch 25 minutes of video. I'm just looking at what's in the video at 25:01. There it's not going to block because the fetchDone chan has capacity to hold the fetchResult. The result will be placed in the channel's queue, then the fetcher goroutine exits, and the channel and its queue get gc'ed and we're done.
Well, it depends on the benchmark-- in those comparisons you can see that Go doesn't out perform python on the regex-redux benchmark. Furthermore, the use of channels doesn't make Go faster. If you are comparing a synchonous application and Go with channels to enable parallelism (not just concurrency), then the performance improvement will depend on the number of threads the computer can execute in parallel. Yet still, it'll be faster to use raw mutexes over channels in a parallel system. Channels are not a tool for high performance applications.
65 is a constant not a number, constants have some very special properties. string(65) says cast the constant to a string while int(string(65)) say cast a constant to a string and then cast a string to an int which then fails. 
Go does not have a strong type system, Haskell does. Why shouldn't it be allowed? It will always succeed, there's only one way to interpret the cast (that makes sense) and it's a common operation.
Try this in the playground var d int = 65 c = string(d) print(c) 
Nice article, I enjoy reading performance oriented posts about Go. You can, by the way, speed this up even more if you only need ASCII characters to be folded, as I do in https://github.com/tdewolff/parse/blob/master/util.go#L34
&gt; I'll have to comb a lot of code for this. You should be able to build a pretty simple static analyzer to detect occurrences. As an added benefit, you can run it on future code to make sure the same problem doesn't creep back in.
Well, to some extent, there isn't much more to understand. Go is generally faster than Python. However it is certainly possible to write a program in Go to solve a problem that would be slower than one in Python, for all the reasons any two programs can be slower. What the benchmarks really say is that if you try to optimize, you can generally go farther in Go. (One thing I'll warn you about is that channels, while something a Python programmer would find pretty fast, are nowhere near free. I've lost track of the number of people who post on /r/golang "I wrote a program to add the first billion integers, and then I wrote a program that spawned a goroutine for each addition which it received via a channel and why is that hundreds of times slower?" Well, you see, on a modern processor an integer addition can take _less_ than one cycle (amortized), whereas starting goroutines and using a channel can each be dozens or hundreds of instructions and maybe a few cache misses (depending), so, yeah, that's a lot slower when you do that for each addition. Goroutines and channels do not magically parallelize things for free. I mention this because I see it a lot.)
Sometimes I often really enjoy pretending XML doesn't exist. :) It really does work pretty well in HTML (and we're quite used to it, so imagining something else is difficult), but for other data, I would really prefer data that's simpler.
If you are going to benchmark you should include the obvious orcish maneuver change (maybe showing my age by calling it that -- http://www.perlmonks.org/?node=130021).
Your reply makes me appreciate you even without needing SOAP at the moment. I've felt its sting, and your approach seems quite comfortable and nice.
I like this. Thanks for sharing.
Build an http router /s
Write code. Get lost, discover what you don't know then learn how to fix it so you do know. Nothing humbles you after reading a book faster than trying to apply that knowledge and realizing that it wasn't quite how you thought it was. If you just read books and do exercises online, you're only dipping your toe in and most of the stuff you just read will slip away.
[removed]
python is a language for prompts and extensions, if you use it for something else, you make a mistake
As previously stated, Raft is integrated in Nats/Streaming. That means no external dependancies.
I'm interested to see what gophers and people who come from non-Ruby languages think of this. Usually a post like this garners responses like "Why, when I can just use xxxxxxx?" I'm curious what other people in go are using for this kind of thing. I come from Rails, and Sidekiq is pretty ubiquitous in my experience.
Is there any lint tool to report these kind of conversion in the source code?
Thanks. I will start reading. I did recently came across articles on Context. Seems, an important concept to understand now.
Tell this the Web development, scientific, machine learning, or AI communities and watch their responses closely. (But I guess you were only joking.)
&gt; Yet still, it'll be faster to use raw mutexes over channels in a parallel system. Channels are not a tool for high performance applications. This is a bad way to think of it IMO. Yes, if you optimize all the way down you are going to be using specific locks or even lock-free/atomic magic. BUT Channels are a great way to get the easy wins. Eg. You have a producer doing stuff and yield'ing results to a for loop in python, threading this will suck ... but even a single (go func() -&gt; channel -&gt; range) change is likely to be a significant win, and it's much easiest to have N producers or consumers. 
I just want a real world example a simple one that i could understand on why go channel is awesome. The channel is the hype about go when people talk about it. 
&gt; One thing I'll warn you about is that channels, while something a Python programmer would find pretty fast, are nowhere near free But nothing is, and it's only the very beginner who thinks you need/want to parallelize obviously very serial operations. On the other hand let me introduce you to my old "friend" import multiprocessing.
I like the [concurrent prime sieve](https://golang.org/doc/play/sieve.go) example.
Thanks, I will try this when I'll have enough time.
Allow me to introduce you to https://mholt.github.io/json-to-go/ P.S. You should still learn enough about the encoding/json package to be able to understand and modify the generated structs. Don't just use this tool as a crutch.
I'm going to take a look at this! Thank you!
May I ask why everybody is so fixed on speed? Is this the only thing to consider when choosing a technology? And if yes: Shouldn't the measurement of "speed" be a realistic one (and thus the benchmark probably complicated)? 
Or the obvious ST version. :) Funny that Go doesn't actually have a function to produce the foldcase of a string, though, only one to *compare* strings by their foldcase. That means you even with the package in this article, you can't correctly do, e.g. a case-insensitive map. ToLower will get you 90% of the way there, but the Germans will be mad that you messed up their eszetts, the Greeks will be mad that you messed up their terminal sigmas, Afrikaners may or may not notice that their ŉs misbehave, etc.
I like that more people are working on this. The GUI looks good. I like the emphasis on supporting multiple languages - I think that's really important. I'm a little concerned about the use of an embedded storage system. I would really rather spend as little time maintaining the database as possible, and with this setup I have to learn about how to do backups and some sort of replication. That could be a significant amount of work. Some companies would be okay with this setup, as long as there is high availability. That would mean Faktory needs to implement Paxos or Raft and replicate information about jobs to other instances. Honestly, implementing it correctly is hard (though maybe not as hard as people say?). Most companies would probably prefer if you used something like Google Cloud Pub/Sub or AWS SQS - that way, most data storage concerns can be handled automatically. It would also be good to have some extra "layers" available for scheduling tasks. For example, it would be really helpful to have dependencies between tasks ala Airflow or Luigi. Obviously, with this model, it could be implemented on top - Faktory would provide the low level service making it possible. But it still needs to be implemented. So overall, this is great! I can't use it because I can't efficiently make it highly available (and ofc it's too new to build something with at this point) but I like that more people are coming up with new approaches to solving this problem.
Right, it's a buffered channel, and presumably the GC catches them all. Well spotted, I three bytes makes all the difference `, 1`!
There's such thing as "established practices". At different points of time of the human history people were absolutely sure a horse is the only way to move a cart and ships made of steel would definitely sink. These days you could look see the established practices have little to do with the technologies which disrupted them, eventually :-P
I'm not mistaking anything of the sort. The compiler optimizes some things regardless of compiler options to turn off optimisation, because it's logical to treat some values as literal values. Obviously concat might allocate when the compiler can't resolve something into a literal, like a function call that can't be inlined. The best bet to know if you're in no-alloc territory is to benchmark and report allocs. Of course your way is even better because it can take the destination architecture into account (GOOS/GOARCH) where the compiler might perform different optimisations by default. Anyway, I think we strayed far from the original point. I just wanted to point out that append allocates (and it does that by doubling the capacity of a slice being appended to). In cases where you'd want to null terminate strings for some reason, most likely that will be unwanted behaviour.
If it's any consolation, I've been using go full time for years, and I've never stumbled across that you could do such a conversion. I can't say I wouldn't mind a built in `itoa` for ergonomics though.
Unless there is a really good reason to do it I would caution anyone against implementing a system directly on top of raft. Even if you use a library like [etcd/raft](https://github.com/coreos/etcd/tree/master/raft#raft-library) correctly you still need to figure out the persistence layer to local disk and tune it. Use something built on raft instead like etcd, cockroackdb, or something else.
Unless there is a really good reason to do it I would caution anyone against implementing a system directly on top of raft. Even if you use a library like [etcd/raft](https://github.com/coreos/etcd/tree/master/raft#raft-library) correctly you still need to figure out the persistence layer to local disk and tune it. Use something built on raft instead like etcd, cockroackdb, or something else.
I don't have any experience writing that kind of programs. Can you give me some hints how I can start writing that?
I think soapysops hit the nail on the head. Without a way to make the service HA, it's basically unusable outside prototypes/test projects. These days you're spoiled for choice on distributed storage systems, and owning the layer that manages acks/fails just isn't as huge of a problem as making sure your data is available and that the system housing it is tolerant of failure. So I don't think the statement is so much 'why, when I can just use X'?, but more of a 'why would I risk data loss to work with a sugary queue'? Vertically scaled services don't solve a problem that development teams have anymore.
Cool project, why the virus tho...
I just love these traditionally non-go projects that work in the same problem domain being migrated to go. I'm happy-crying right now. Especially as I like sidekiq as well :)
idk, write some code?
&gt; I continue to work on this because I know that it's dirty work that nobody wants to do, but that a great many people would benefit from. Thanks a lot. Not many people are willing to work on something they won't use. If you ever get contributors that really understand how to build these things (It's hard, I know), you may consider give write access to them so they can keep working on it (if you don't want to maintain this forever).
One of my articles might help you along, if it's not over your head. Take a look at the first heading, "Nested structures when parsing JSON data". https://scene-si.org/2016/06/13/advanced-go-tips-and-tricks/ I'd link to a third party source, but I realize that go by example doesn't really give a good example of something more complex. The way you started leads me to believe that you're an absolute beginner in Go (or programming in general?), and should learn more about the data structures available. A good way to do that is to go over [go by example](https://gobyexample.com/).
&gt; Int to string is a well understood conversion, there's nothing uncommon about, it's boring. Except string(127808) returns not `"127808"` but `"🍀"` (U+1F340 "FOUR LEAF CLOVER" aka the rune whose codepoint is 127808)
I came to go from ruby, but I think it's way easier to implement your own background processing system over a pub/sub mq like amqp, redis, mqtt, etc. than figuring out how to set up faktory. 
Speed to maintain an old app matter ! (and I bet Go will win)
IIRC, they already have an issue where they say they wish they hadn’t made some byte/string/int conversions legal, but the Go 1 guarantees tie their hands. 
Yup, Rob Pike in 2012: https://github.com/golang/go/issues/3939
I just compared performance of https://github.com/kshvakov/clickhouse/ with https://github.com/valyala/tsvreader using the following simple code: package chclient import ( "database/sql" "fmt" _ "github.com/kshvakov/clickhouse" "github.com/valyala/tsvreader" "testing" "time" ) const expectedRows = int(1e7) var query = fmt.Sprintf("SELECT number, number+1 FROM system.numbers LIMIT %d", expectedRows) func TestNativeProtocol(t *testing.T) { c, err := sql.Open("clickhouse", "tcp://127.0.0.1:9000") if err != nil { t.Fatal(err) } rows, err := c.Query(query) if err != nil { t.Fatal(err) } defer rows.Close() var n, m, i int for rows.Next() { if err := rows.Scan(&amp;n, &amp;m); err != nil { t.Fatal(err) } if n != i || m != n+1 { t.Fatalf("n=%d, m=%d, i=%d", n, m, i) } i++ } if i != expectedRows { t.Fatalf("unexpected rows number: %d. Expecting %d", i, expectedRows) } } func TestHTTPProtocol(t *testing.T) { c := &amp;Client{ Timeout: 5 * time.Second, } i := 0 err := c.Do(query, func(r *tsvreader.Reader) error { for r.Next() { n := r.Int() m := r.Int() if n != i &amp;&amp; m != n+1 { return fmt.Errorf("n=%d, m=%d, i=%d", n, m, i) } i++ } return nil }) if err != nil { t.Fatal(err) } if i != expectedRows { t.Fatalf("unexpected rows number: %d. Expecting %d", i, expectedRows) } } `TestNativeProtocol` is 7x times slower than the `TestHTTPProtocol`: $ go test -v === RUN TestNativeProtocol --- PASS: TestNativeProtocol (7.15s) === RUN TestHTTPProtocol --- PASS: TestHTTPProtocol (1.09s) PASS 
&gt; But nothing is, and it's only the very beginner who thinks you need/want to parallelize obviously very serial operations. I'm not just making this up. I've seen this exact issue at least three times here. &gt; On the other hand let me introduce you to my old "friend" import multiprocessing. Well, I'm sure that spawning an entire process, even with fork, with a Python runtime on the other end will be even slower to add two numbers together with. I'm not sure what your point is. Nobody's claiming Python has no solution at all for "multiprocessing", but nobody sane is claiming it's going to perform anywhere near as well as Go. Python is ultimately a single-threaded language, born in an era where that was the norm, and it's got a collection of hacks of varying quality to try to get around that, but there's just no retrofitting it on to an implementation that was already ten years old when they _started_ to think about these issues. That's not a Python-specific criticism; I've _never_ seen a 10-year-old implementation of any language grow any truly performant and usable concurrency support without the full support of a commercial enterprise behind it. Python is in fact doing the best of all the ones I've seen try, so I'm not being critical of Python specifically.
&gt; I can't say I wouldn't mind a built in itoa for ergonomics though. There is `strconv.Itoa`; I don't think the added ergonomics of not having to type 8 extra characters every once in a while would justify a builtin.
As someone who just recently fully implemented a event emitter and request handler on top of raft.. I completely agree. I originally saw the minimal example in [etcd/raft](https://godoc.org/github.com/coreos/etcd/raft) and the larger key store [raftexample](https://github.com/coreos/etcd/tree/master/contrib/raftexample) and thought it looked pretty simple. But once you get into differentiating between restarts and fresh nodes, loading &amp; saving snapshots and creating a reasonable abstraction of proposals into "requests" that get responses it's a lot of work. The entire reason I decided to give it a shot is I wanted the leadership election. I could have gotten a similar result using the etcd server with special keys and the client "watchers" I think, but I would have ended up needing the concept of a heartbeat and stuff like that I believe since the underlying quorum and election state is completely abstracted away as far as I know. That said I am super thrilled with the way it turned out, despite being a bit extra work than I planned. A few core primitives implemented by the main Node implementation have allowed me to develop the rest of the system pretty quickly, i.e.: type Proposer interface { Propose(context.Context, *Request) (*Response, error) } type Handler interface { ServeRaft(res *Response, req *Request) error } type Multiplexer interface { Handle(Type, Handler) error } type Raft interface { Proposer; Multiplexer } type Emitter interface { On(Type) Streamer } type Streamer interface { Err() error; Stop(); Event() &lt;-chan Event; } Most my packages only need one or two of those interfaces, since they are nice and small it was easy to create mock structures for unit tests. If I want to add a new type to the commit log I just create a distinct set of types in the calling pkg such as pkg.FooType = `pkg/Foo` and can emit consistent log-replicated events for other pkgs to register for via On() or use in a Request. TLDR here being despite a little bit of work to get things up and running, etcd's raft implementation is pretty awesome to build on top of.
I'm not really familiar with Ruby/Sidekiq, and I don't feel like the stuff on the site really lays out the elevator pitch well. I think the question for me is - why not SQS or RMQ? (both of which have durability and ack). Why not NSQ, which has at least once, durable, distributed queues with FIN, timeouts and REQ?
You might want to check [this thread](https://www.reddit.com/r/ruby/comments/78fw6e/introducing_faktory_a_new_background_job_system/) where the author replied with some relevant information for you. tl;dr If you like _(rabbit mq or) something_, then use it. Faktory aims for "it just works" and doesn't have additional bells and whistles like clustering at this point. Hey, it's been out for something like 24 hours :D
Define "finishing" the Go Programming Language book. Did you do the dozens and dozens of coding exercises sprinkled throughout the chapters? Simply read that book won't be enough.
Try creating multiple structs type Data struct { rrsets *[]RRSet } type RRSet struct { name string ...etc }
It makes sense once you understand that the ```int``` is effectively treated as a UTF-8 ```rune```. And if you look at any multiple byte character as a ```uint32```, then the comparison of an ```int``` to ```string``` cast is not so different from a ```rune``` to ```string``` as a ```rune``` is just a ```uint32```. Especially as far as the compiler cares about simplifying literals. 
To expand and to help avoid a common pitfall when starting go, a slice is basically a view on an array. 98% of the time when appending, you will want to assign the result back to the very same slice, this isn't a new variable. The view changed but it's using the same array in the back. When you append you add something at ``s[len(s)]`` of the view. If you start to assign the result of an append to a different slice you will end up overwriting values. Demonstration: https://play.golang.org/p/xlQZs7uyNf
Not actually a bad idea, _as long as you give it some feature none of the existing routers have_. For example, an easy way to route based on content type.
&gt; It makes sense once you understand That you're going to rationalise whichever arbitrary decision was made. &gt; is effectively treated as a UTF-8 rune That makes literally no sense. "127808" is the codepoint of FOUR LEAF CLOVER, the UTF8 is 4036988288 (0xF09F8D80), there is no 127808 UTF8 sequence.
I don't feel I missed the point. I intended to say Unicode rather then UTF-8, and yes that is on me and is a mistake i am happy to own. In no way did I attempt to justify the choice to do this type conversion. I am just saying that I can follow the logic behind what is happening and made an attempt to clarify that. That said I can see where you expectation of ```string(1234567) == "1234567"``` as a number of scripting languages choose to do this form of Type Inference for the developer. This tends not work well in more strictly typed languages. Maybe this is an expectation of Type Inference rather then Type Conversion?
Sidekiq/resque/celery are ubiquitous in the Ruby/Python web app world because it's really inconvenient to do async actions there, so if you want to do anything that's not synchronous in your API handler, you're forced to use a job framework. With Go, you can just spawn a new goroutine.
[removed]
What does KCP stand for?
I'm not arguing that this doesn't make sense in Clojure or that Go is better than Clojure. Destructuring and list comprehensions work wonders for treating code as data and vice versa. IMHO I'm not gaining anything in Go by treating it like Clojure and locking my configuration into a map of string types. It feels like I'm losing compile time guarantees by favoring the map's usage at runtime throughout my code instead of the handy bits that come from storing Consul values into fields and referencing struct types and interface types that can be checked and verified during compilation. Every time I use a map I have to allocate a key whereas with a struct I've just got an elided pointer and fields. Finally, maps are not safe for concurrent use so I need to store the values into a struct anyway to make use of them across goroutines. If this is just getting a map in and out of Consul than maybe those things don't matter for this library.
Queues brings more benefits to the table. If your Go comes down you loose everything.
Interesting, didn't expect that. 
I guess this comment is meant for https://www.reddit.com/r/golang/comments/78oprj/moka_a_golang_mocking_framework_built_by_me/
tagging /u/gcapizzi
&gt; That said I can see where your expectation of string(1234567) == "1234567" as a number of scripting languages choose to do this form of Type Inference for the developer. An explicit conversion is neither implicit (I expect you're referring to PHP or JS's habit of implicit conversions between — amongst others — strings and integers) nor having anything to do with type inference (though I guess you acknowledge that part in your edit… it's got nothing to do with comparisons either, neither is involved in the issue at hand). &gt; This tends not work well in more strictly typed languages. Converting an int to a string formats it in "strictly typed" languages like Python or Ruby, as well as *statically* typed languages like: * Java, `Integer n= 123; n.toString()` =&gt; `"123"` * Haskell, `show 123` =&gt; `"123"` * Swift, `String(123)` =&gt; `"123"` * Rust, `123.to_string()` =&gt; `"123"` * OCaml, ` string_of_int 123` =&gt; `"123"` * etc… Tends not to work well in "more strictly typed languages"? Pull the other one, it's got bells on.
[removed]
Yeah It is sorry I am stupid.
Sure, but at the cost of greatly increased deployment complexity. Anything can go down, including redis or rabbitmq.
thanks that site is awesome. type Payload struct { Rrsets []struct { Name string `json:"name"` Type string `json:"type"` TTL int `json:"ttl"` Changetype string `json:"changetype"` Records []struct { Content string `json:"content"` Disabled bool `json:"disabled"` } `json:"records"` } `json:"rrsets"` } how do I initialize the struct? It keep saying too many values in struct initialized and not enough arguments 
5/9 is doing integer division and evaluates to 0, resulting in (input-32)*0. One solution is to do supply floats by adding the decimal: (input-32)*(5.0/9.0) Another option would be to cast the 5 or 9 to a float: (input-32)*(float64(5)/9)
I have looked at kcp and while it's interesting I think Quic ultimately has more potential. Check out quic-go
Take a moment to look up division of integers vs division of floats. Do not quote me, but I believe that if your divisor is an int, the result would be an int (no floating point). Do check Go's specific rules. I learned to use floats as divisor and dividend back in my early C days, and apply the same logic across languages without thinking too much these days.
While 5/9 is not a terminating decimal, 9/5 is. So you might find this option to be more readable. (Type inference lets you declare the type implicitly.) output := (input-32)/1.8
Using a cloud only based database is definitely not the way to go. Better to aim for something universal like postgres or mysql 
This was an interesting way of thinking about Channels, but I thought it suffered by not talking about sync.WaitGroup and not close()'ing the channel in most of the examples.
... it's still a Raft cluster that needs to be managed.
I'm posting this here for two reasons: 1. The story will likely only make sense to Gophers since it involves people/events from the Go community. 2. The app was created w/ Go and you can watch the screencasts at https://gophercises.com if you want to see how it was created. Hope you enjoy it!
FTR, I disagree that rpcx competes with gRPC (or, more specifically, can be considered a replacement). It's missing several critical features for that, like an IDL, or language-independence, from what I can tell.
Your question intrigued me, but after like 20m of digging the only thing I can find out is that it is a "A Fast and Reliable ARQ Protocol". Perhaps somehow "ARQ Control Protocol" became KCP somehow? Or something was lost in translation? ¯\\\_(ツ)\_/¯
this question is going to keep me up tonight. I just read over the docs in at least 10 diff KCP related repos expecting to find some kind of answer... nope.
I wrote something similar some time ago https://github.com/phonkee/go-pubsub
It is one cluster and not two, as Nats and Raft are in one binary/process.
FWIW, a fair amount of thought has already been put into updating the `sessions` package to take advantage of proper request contexts that landed in Go 1.7. Looks like they're waiting for dep to hit 1.0 first, though. https://github.com/gorilla/sessions/issues/105
What does pprof show if you run go test -v -cpuprofile cpu.out go tool pprof *.test cpu.out 
As someone that has previously used Beego: Chinese gophers have been putting out some super high quality libraries. That said, I'm less likely to use them because their issues, pull requests, etc... tend to be in Chinese (understandably). The language barrier just makes hunting down issues more difficult.
I have been thinking a lot about mocks lately, and I must say I am still fumbling as to when to use em. take the case of test fixtures — in most cases it's so cheap to for instance spin up a docker with e.g. a database, and on e.g. kubernetes it's so easy to spin up pod(s) of interconnected services/dependencies if u need that. what am I missing?
[removed]
I don't think mock were ever intended as a way to replace "expensive" dependencies in tests. Mock objects are a design tool: they help me to define the contracts between the objects in my system and they give me lots of useful feedback on my designs. Too learn more about using mocks as a design tool, I recommend: * [Endo-Testing: Unit Testing with Mock Objects](https://www2.ccs.neu.edu/research/demeter/related-work/extreme-programming/MockObjectsFinal.PDF) * [Mock Roles, not Objects](http://www.jmock.org/oopsla2004.pdf) * [Growing Object-Oriented Software Guided by Tests](http://www.growing-object-oriented-software.com/) * [Integrated Tests Are A Scam](http://blog.thecodewhisperer.com/permalink/integrated-tests-are-a-scam) * [Test Isolation Is About Avoiding Mocks](https://www.destroyallsoftware.com/blog/2014/test-isolation-is-about-avoiding-mocks) * [Mock objects in Discovery Tests](http://blog.testdouble.com/posts/2014-05-14-mock-objects-in-discovery-tests.html) 
I don't think 3 libraries are that many. I use the same amount of libraries in the Java ecosystem (JUnit - Hamcrest - Mockito). Also, ironically, most people in the Ruby/Rails ecosystem use RSpec, which is a single library providing all 3 functionalities (testing - assertions - mocking).
[removed]
I'm thinking of using the two: 1. QUIC is still being discussed by IETF and there are making some major changes to the protocol 2. KCP has FEC, which is a really nice addition when working on mobile networks
Well done! Simple to understand what you have done. Just one question, why not be able to download pictures and videos at the same time.? Is there some limitations?
Quic has fec afaik. 
I've seen the draft, but it's unclear if it's been implemented at all
Ever heard of reactivesocket? Or rsocket, as it's called these days. Been playing with it for a while, will eventually open source it.
Great job gophers!
Great job, gophers!
Super helpful, thank you :) One intuitive but missing instruction from the article is to edit line 6 in the default Go CI template: # Please edit to your GitLab project REPO_NAME: gitlab.com/namespace/project 
There aren't any limitations to do so, the author most likely only wanted images in this case.
Released today (2017-10-25)
+1
&gt; it's so cheap to for instance spin up a docker with e.g. a database what you are missing is that you don't know what a unit test is. Mocks are tests. They are not here to replace the database.
Can anyone show me how to initialized a `[]struct`? I googled everywhere I can't find the answer. type teststr []struct { Name string }
 type MyStruct struct { Name string } var teststr []MyStruct
&gt; type teststr []struct { Name string } Try this: https://play.golang.org/p/fwxg3bBSmO tests := teststr{ { Name: "first", }, { Name: "second", }, } 
Thanks, didn't want to make a new post just for this simple question.
interesting. I am a little over a week into Go, so I appreciate the feedback and the "Go way" comments. I'd like to ask you a couple of follow up questions: &gt; _handy bits that come from storing Consul values into fields and referencing struct types_ 1. Isn't everything that lives in Consul KV a string? i.e. you make an HTTP call that return you a '[]byte' which later needs to be cast / parsed into a strong type anyway. Hence the next question &gt; _and interface types that can be checked and verified during compilation_ 2. Getting values from Consul is "runtime": i.e. yes, once you get a typed struct, you have some guarantees that `number of x` is an `int`, but if it is written into Consul as `42a` compilation guarantees nothing. ? &gt; _Every time I use a map I have to allocate a key whereas with a struct I've just got an elided pointer and fields_ 3. This is an interesting point, and I certainly agree with a general struct preference in C/Go type languages, but in case of an application config [a few dozen keys for the whole app created once at startup], does it really matter? &gt; _maps are not safe for concurrent use so I need to store the values into a struct anyway to make use of them across goroutines_ 4. Firstly there is [sync.Map](https://golang.org/pkg/sync/#Map), but also app config should really be immutable and read only, i.e. it is this "one time" application configuration, would you agree? 5. And lastly, I'd like to understand what would be a recommended "Go way" to write / read a _nested_ structure from Consul to a Go application? i.e. I suspect it is reading it into some kind of "structs of structs of structs" (since it is nested), but how? Read JSON or each K/V from Consul and parse each value into a struct field? 
So I hate to disagree, but that's not really true. If you simply launch a goroutine, you lose pretty much of the features of a proper async worker setup, and most of the time you need at least some of them. For example, maybe you want to send an email to every user after they create an account. If you return from a request and say "Yes, you made an account" and launch a separate goroutine to send the email, the server process could crash in between and you'll never end up sending the user anything. Also, what happens if the email sending API stops working. Do you just give up? Do you keep making new goroutines until the API starts working again? There are limits to the amount of memory you can allocate. You'd probably setup a cronjob that checks your database every night for emails that need to be sent. At that point, all you did was recreate an async task queue, except in a really awkward, slow, and error prone way that puts more load on your database. Also, most people want to be able to scale their web workers independently from their async workers. You can save a lot of money if you process the enqueued jobs at night, for example. That's not possible at all if you do everything in one process. So Goroutines can help increase concurrency and deliver each request more quickly, but by no means do they replace async task workers.
[removed]
[removed]
&gt; a unique code is generated and sent to this email triple check your uniqueness, better yet, add a unique constraint on the code field in the db; while you're on this, ensure that it will be activated once can the cookie be hijacked? i.e. you auth normally through the browser, and try to login in incognito, by copy-pasting the cookie
The first sentence of the README says "KCP is a fast and reliable protocol". Fast and reliable in Chinese is "kuaisu" and "kekao". That's probably where the K came from. Fast/reliable control protocol.
Maybe I just haven't been keeping up but why are there 2 versions?
In Go, both operands must have the same type.
Because it is a bug fix that applies to both the 1.8 and 1.9 releases.
thanks!
Please at the very least read this instead of hijacking threads to ask basic questions : https://gobyexample.com/ And your example is syntactically incorrect at first place. Take the time to learn go. You're not going to learn it without learning the syntax first.
"advantage" and "jvm" are mutually exclusive
[removed]
It makes sense to me. I was never a "gotcha" that I had an issue with. Not even what I would consider quirky behavior but the horse is dead. I was hoping to be friendly and offer a potential explanation. Seems that was a mistake. You seem to have an axe to grind here and I'm not going to be your whetstone. Have a day.
:/ godoc -play still looks broken: $ godoc -http=:6060 -play 2017/10/25 22:00:11 godoc.html.Execute: template: godoc.html:58:8: executing "godoc.html" at &lt;$.Share&gt;: can't evaluate field Share in type godoc.Page
A channel with cap=1 for this kind of pattern is pretty standard. It's either that or a select with two cases: deliver the reply or notice a cancelation.
No probs, can happen to anyone...
And why are there two releases? What’s the difference between the two?
+0.0.1 actually
One has 1.9 features, the other doesn't.
https://github.com/golang/go/wiki/Go-Release-Cycle#user-content-release-maintenance &gt; Minor releases to address non-security problems for Go 1.x stop once Go 1.x+1 is released. &gt; Minor releases to address security problems for Go 1.x stop once Go 1.x+2 is released. For more about security updates, see the security policy. 
That’s not what I was asking about.
&gt; [Edit] Clarification: What is the difference between 1.8 and 1.9? They differ in features mostly, see 1.9 changelogs. Older major releases are still maintained and patch if there's a need, that's why there are not "only" 1.9.x.
1.8 is just an older release. I can't remember the exact wording, but essentially the go release policy says they provide security fixes for the current release and the previous release. Although these releases fix non-security issues in an old version (i.e. a deviation from the policy) i guess they chose to break from the policy here because the breakage is important enough.
Thanks for that explanation. The Gorilla sessions v2 sounds good for the future, but also I starred this a while back which looked good: https://github.com/alexedwards/scs
One crucial missing is the comparison of this project with the existing ones (such as `gomock` — to give just one example).
It still has a ton of issues if you want to do any sensible NAT punch through. I've been trying to wedge it into syncthing for a while. Furthermore, it has toomany knobs to tweak to make it performant in all scenarios.
Great point! I'll definitely add a section to the README. 
you can try to download paralel with goroutine.
things that are missing or bug me: * startup speed of IDE * indexing speed of project, especially with a lot of vendored projects * memory usage is too high (vs code is less but high too) * automatic unit test generation (table driven etc) * in code git stats, links etc (git lens plugin) * debugging just by hitting F5 if you have the main file open (instead of having to setup configurations) * ctrl+~ opens a terminal at the bottom OOTB * very vibrant community * fast updates * gogland is terrible name (i know you are looking for a new one, fingers crossed) * minimal files in solution folder (the .idea folder has a lot of files. which ones to add to git??) * vs code can do more than just go. One editor to support multiple platforms (gogland, rider etc) * free although 89usd is not that much for 1 year * recent changes with file watchers did break something "mkdir C:\WINDOWS\go-build808371703: Access is denied.". Really in c:\Windows? * It's not production ready due to changes in order to get a final product. It is still EAP. nice things in gogland (like mentioned before) * refactoring seems to work much better * integrated db query tool * code coverage is nice with information in the file view neither have good support for large files! I will keep a look on future releases and hope that it stabilizes, goes to production.
Amen.
you can try to download paralel with goroutine.
Downvotes? That really, actually, wasn't what I was asking about. I am sorry if the original question wasn't very clear. I honestly thought it was. I will try to try harder in the future!
Somewhat recently, the policy was changed, so that 2 most recent major versions are maintained. This is to soften the transition period: it's often not viable, esp. in bigger corps, to transition the whole codebase to new major version *immediately on the day it's released*. Some testing may be required in meantime, etc. etc. You may want to run 2 binaries in parallel for a while to make sure nothing did break with the new version. AFAIR there was some issue where this was proposed and accepted.
There are many opinionated blogs and videos about testing giving lots of (mis)information. But there's one undeniable truth: pure integration testing does not scale when the application gets bigger because intra-process RAM access is incomparably faster than any out of process DB access. A simple for loop in a single test can add minutes to your tests when you're accessing DB. So you to replace this: TEST(read from db + do something with data) to TEST(read from db) + TEST(mock -&gt; do something with data) This way you keep tests that use DB to the absolute minimum.
[answer here](https://www.reddit.com/r/golang/comments/78o2qa/chinese_gophers_have_been_busy/dowefih/)
[answer here](https://www.reddit.com/r/golang/comments/78o2qa/chinese_gophers_have_been_busy/dowefih/)
[removed]
Nice, I only looked at the code and missed that you don't need to have a flag specifying the media you want. :P Glad to see that you implemented the possibility to also do both flags. If the code ever grows with more use cases that just makes sense. :)
&gt; What is the difference between 1.8 and 1.9? You can read about the changes here: https://golang.org/doc/go1.9
I understand your defensiveness, and I mean that very seriously, but bear in mind that _if_ you desire this to become a popular package, this is your customer feedback. You will probably find yourself unable to argue them out of this. If, by contrast, you're putting this out for some other reason, then your defense is fine. It's always hard to discuss open source "success" because what "success" is changes from person to person and project to project. (I say this fairly neutrally, because I'm not in the market for a mock library anyhow.)
I understand your point, which boils down to the fact that lots of people make technical decisions using far from rational criteria ("3 imports are too many!"). I don't think I'm interested in chasing those criteria tbqh. 
Sure, and, more importantly IMHO, it gives you feedback about how coupled your system is to that DB. 
Hey, for what it's worth, consider checking out the gophers slack. Lots of friendly folks there: https://gophers.slack.com However, since it looks like you might be pretty new, it might be considerate to run through the tour first, if you haven't already: https://tour.golang.com
You've enumerated the benefits of a separate persistent async job worker pool, none of which I dispute. My point is that none of that is free; the cost is greatly increased operational and deployment complexity. Whether the benefits are worth the cost is a situation-specific engineering decision.
And there's a nice way to keep the IDE always up to date as well: https://blog.jetbrains.com/blog/2017/10/26/toolbox-app-1-5-staying-up-to-date-has-never-been-easier/
There's always something like cockroachdb.
I made a library that uses go-routines, packaged up in struct and called "processes" with channels as struct fields, and a bit of helper code, to create an "implicit task scheduler" for scientific workflows of command-line applications: https://github.com/scipipe/scipipe (http://scipipe.org). ... and it is not only a super-simple implementation of a scheduler - it is advanced too - supporting on-line scheduling (scheduling tasks based on available inputs, while the workflow is running), where most workflow tools completely separate scheduling and execution. Go's concurrency primitives really really shined here, and helped to make the implementation of this super small. It cLOCs in at 1376 lines of code, excluding tests, comments, examples, and closing parens :)
Does it have an equivalent to `go doc`?
Build a highly scalable public, group and private chat.
Yes, you can invoke quick documentation on any element in the code, both under cursor or in the completion list, as well as an option to open godoc.org for any element.
Is there an issue for this ?
I've only looked through `find`, but your functions `Find` functions return the index of the last item if they don't find what they're looking for. Isn't that counter intuitive? This also means that your `All` will return the incorrect, even if the last item isn't true? Tested them out, and got some [undesirable results.](https://play.golang.org/p/OaNh3CEjYc) I suggest evaluating these Find functions to an index not in the slice, like -1 or something. Or even returning an int and bool.
[removed]
The program godoc is not part of the Go repository but belongs to the Go tools repository. See [here](https://golang.org/doc/install/source#tools)! 
I built a library to automate querying OFX data from your bank (what Quicken): https://github.com/aclindsa/ofxgo The way encoding/decoding XML to/from structs works in Go made this much easier than many other languages: https://golang.org/pkg/encoding/xml/. After defining my terminal data types, all I had to do was ensure my structs and their tags properly matched the OFX specification. My main reason for using Go for this library was because I wanted it to inter-operate with my other project: https://github.com/aclindsa/moneygo. So I'm not avoiding the question, I've enjoyed using Go there because of its simplicity and the ease with which I can deal with handling web requests and marshaling data to/from JSON.
Right now it is still slow than vscode+go plugin for me. The only thing that I regularly hop into it for is code refactoring which is in a typical jetbrains way totally awesome to use. Once the performance gets better I may consider switching over full time. 
&gt; Right now it is still slow than vscode+go plugin for me. The only thing that I regularly hop into it for is code refactoring which is in a typical jetbrains way totally awesome to use. Once the performance gets better I may consider switching over full time. Please help making it faster. Use the information here: https://intellij-support.jetbrains.com/hc/en-us/articles/207241235-Reporting-performance-problems and report the issue here: https://youtrack.jetbrains.com/issues/Go Otherwise it's highly likely that they won't be fixed unless someone else accidentally bumps into the same problems as you experience (and chances are very low for that).
/u/epiris You are absolutely right. I created a gist with the relevant parts: https://gist.github.com/kschaper/0efb060c671ea550976317f58c4afaab Please take a look.
[removed]
I have to say that the document inspection is very good compared to what I am used to coming from sublime. I love how the quick docs can be invoked from more places that just a symbol in code. You can invoke it from items in the proposed completion list as well. And it let's you keep drilling into type links through the doc overlay. 
Been using it a couple weeks so far, and I am also new to Jetbrains products. My favorite aspects have been the fast and comprehensive "Find usages" for symbols which breaks the results down into reads, writes, initialization, etc. The doc support is great. Type hinting is neat, and filling out structs or creating getters is helpful. I still feel it has quirks that need to be addressed and I have been submitting tickets. I think it's a bit clunky if you use it on a code base that is mounted via nfs. The synchronisation takes a while, there are hiccups between when the file is saved and when goimports rewrites it. Seems a maintainer really needs to sit down and work through a large codebase on nfs. 
Cookie hijacking is possible at the moment. I have to set the Secure and HttpOnly flags to prevent this. Thanks for the pointer.
OMG I NEED DIS
I fucking love gabs, you're awesome!
[like this](https://github.com/Xe/site/tree/master/vendor)
minio client: [mc](https://github.com/minio/mc#everyday-use)
For lazy clickers... "These releases include fixes to the compiler, linker, runtime, documentation, go command, and the crypto/x509, database/sql, log, and net/smtp packages. They include a fix to a bug introduced in Go 1.9.1 and Go 1.8.4 that broke "go get" of non-Git repositories under certain conditions." 
This is the cpu profile for `TestNativeProtocol`: $ go test -run=Native -cpuprofile=cpu.pprof PASS ok github.com/valyala/chclient 7.617s $ go tool pprof cpu.pprof File: chclient.test Type: cpu Time: Oct 26, 2017 at 11:58pm (EEST) Duration: 7.61s, Total samples = 7.63s (100.25%) Entering interactive mode (type "help" for commands, "o" for options) (pprof) top Showing nodes accounting for 3290ms, 43.12% of 7630ms total Dropped 65 nodes (cum &lt;= 38.15ms) Showing top 10 nodes out of 75 flat flat% sum% cum cum% 610ms 7.99% 7.99% 4410ms 57.80% database/sql.convertAssign /home/aliaksandr/work/go-tip/src/database/sql/convert.go 460ms 6.03% 14.02% 760ms 9.96% runtime.mallocgc /home/aliaksandr/work/go-tip/src/runtime/malloc.go 420ms 5.50% 19.53% 1070ms 14.02% strconv.formatBits /home/aliaksandr/work/go-tip/src/strconv/itoa.go 370ms 4.85% 24.38% 1020ms 13.37% reflect.(*rtype).Name /home/aliaksandr/work/go-tip/src/reflect/type.go 350ms 4.59% 28.96% 650ms 8.52% reflect.(*rtype).String /home/aliaksandr/work/go-tip/src/reflect/type.go 290ms 3.80% 32.77% 290ms 3.80% strconv.ParseUint /home/aliaksandr/work/go-tip/src/strconv/atoi.go 220ms 2.88% 35.65% 4810ms 63.04% database/sql.(*Rows).Scan /home/aliaksandr/work/go-tip/src/database/sql/sql.go 200ms 2.62% 38.27% 330ms 4.33% runtime.deferreturn /home/aliaksandr/work/go-tip/src/runtime/panic.go 190ms 2.49% 40.76% 7400ms 96.99% github.com/valyala/chclient.TestNativeProtocol /home/aliaksandr/gopath/src/github.com/valyala/chclient/chclient_test.go 180ms 2.36% 43.12% 470ms 6.16% strconv.ParseInt /home/aliaksandr/work/go-tip/src/strconv/atoi.go This is the cpu profile for `TestHTTPProtocol`: $ go test -run=HTTP -cpuprofile=cpu.pprof PASS ok github.com/valyala/chclient 1.206s $ go tool pprof cpu.pprof File: chclient.test Type: cpu Time: Oct 27, 2017 at 12:00am (EEST) Duration: 1.20s, Total samples = 1.01s (84.05%) Entering interactive mode (type "help" for commands, "o" for options) (pprof) top Showing nodes accounting for 990ms, 98.02% of 1010ms total Showing top 10 nodes out of 30 flat flat% sum% cum cum% 320ms 31.68% 31.68% 320ms 31.68% strconv.ParseUint /home/aliaksandr/work/go-tip/src/strconv/atoi.go 140ms 13.86% 45.54% 220ms 21.78% github.com/valyala/tsvreader.(*Reader).nextCol /home/aliaksandr/gopath/src/github.com/valyala/tsvreader/tsvreader.go 130ms 12.87% 58.42% 130ms 12.87% runtime.indexbytebody /home/aliaksandr/work/go-tip/src/runtime/asm_amd64.s 110ms 10.89% 69.31% 430ms 42.57% strconv.ParseInt /home/aliaksandr/work/go-tip/src/strconv/atoi.go 100ms 9.90% 79.21% 820ms 81.19% github.com/valyala/tsvreader.(*Reader).Int /home/aliaksandr/gopath/src/github.com/valyala/tsvreader/tsvreader.go 70ms 6.93% 86.14% 500ms 49.50% strconv.Atoi /home/aliaksandr/work/go-tip/src/strconv/atoi.go 50ms 4.95% 91.09% 160ms 15.84% github.com/valyala/tsvreader.(*Reader).Next /home/aliaksandr/gopath/src/github.com/valyala/tsvreader/tsvreader.go 30ms 2.97% 94.06% 30ms 2.97% syscall.Syscall /home/aliaksandr/work/go-tip/src/syscall/asm_linux_amd64.s 20ms 1.98% 96.04% 20ms 1.98% bytes.IndexByte /home/aliaksandr/work/go-tip/src/runtime/asm_amd64.s 20ms 1.98% 98.02% 1000ms 99.01% github.com/valyala/chclient.TestHTTPProtocol.func1 /home/aliaksandr/gopath/src/github.com/valyala/chclient/chclient_test.go
Yes thanks. Isn't this like checking in other people's code into your repo? Feels a bit wrong
Yes, but it depends on who you're talking to. Decoupling argument won't necessarily convince those who have made a serious bet on their software stack (non-portable hand tuned queries on large datasets, multimaster, etc.). Performance however will affect everyone sooner or later and it's an easier sell.
Yes, it's technically wrong in that regard, but Go tooling kinda ended up needing vendoring as a hack around a proper dependency manager ([dep](https://github.com/golang/dep) is the step in the right direction tho). A benefit of vendoring code is that people can get executables that are byte-for-byte the same consistently using the same source repo at a given commit.
&gt; A benefit of vendoring code is that people can get executables that are byte-for-byte the same consistently using the same source repo at a given commit. Can't you get the same with the version pinning thing that dep does? Also, what about licenses of the packages you've included?
I actually was just thinking about this , I'm working on refining some of the package things to avoid such results and add more testing for edge cases ... thanks for the feedback :) 
Why would you not just handcode your SQL? It is a language designed specifically for humans to declaratively prepare, store and manipulate information in an RDBMS. There's also SQL generators like `github.com/Masterminds/squirrel` but I only use those when I want meta-programming in SQL. Which I generally don't because I generally don't want meta-programming. &gt; how to maybe use multiple result sets to select something as a many-to-many. If you have the relevant information you should be able to construct what ever data type you want. How to do that depends on exactly what that is.
I made a quick update to return -1 if not found
don't violate the licenses :)
I started writing a tool that would output directory info as JSON with the idea that another tool could format it as needed. https://github.com/carlmjohnson/junix I haven’t worked on it in a long time. Could still be a good idea if someone worked on it more. 
I think this is a really good question. We should find two vendor folders that have been together many years and ask them their secret.
Thank you for your feedback and nice words. Please see the responses inline. &gt; things that are missing or bug me: &gt; - startup speed of IDE Please see the "Profiling Slow Startup" section of https://intellij-support.jetbrains.com/hc/en-us/articles/207241235-Reporting-performance-problems and help fixing this by reporting an issue here: https://youtrack.jetbrains.com/issues/Go &gt; - indexing speed of project, especially with a lot of vendored projects Please report that by following the same steps from the previous comment. &gt; - memory usage is too high (vs code is less but high too) How are you testing this? I proved above that Gogland uses about the same as VS Code. Modern operating systems allow applications to borrow memory as they want, even if it's not used. It's released back to the OS when the OOM reclaimer kicks in and gets it back. But unless your OS really needs that memory, it won't be easily / quickly released back. That being said, if you believe that there's an issue with memory usage, please raise an issue and provide a memory dump via ` Tools | Capture Memory Snapshot ` (you can upload it as described in the above link to the JetBrains secure server so that it's not publicly readable). &gt; - automatic unit test generation (table driven etc) This was implemented two versions ago, please see https://blog.jetbrains.com/go/2017/10/18/gogland-eap-16-file-watcher-tons-of-new-inspections-smarter-navigate-to-test-and-more/ &gt; - in code git stats, links etc (git lens plugin) This is available as a basic functionality in all JetBrains IDEs with the Git plugin enabled. &gt; - debugging just by hitting F5 if you have the main file open (instead of having to setup configurations) The run configuration shortcut is CTRL+SHIFT+F10 and you can add your own similar shortcut for Debug, it's just not configured by default. &gt;- ctrl+~ opens a terminal at the bottom OOTB I customize the shortcut to open the ` Terminal ` from ALT+F12 to anything you want via ` Settings | Keymap `. &gt; - very vibrant community Not sure what you'd want to see here. Please explain? &gt; - fast updates You can receive nightly versions of the plugin, register ` https://plugins.jetbrains.com/plugins/nightly/9568 ` as a ` Repository URL ` in ` Settings | Plugins | Browse repositories | Manage repositories `. &gt; - gogland is terrible name (i know you are looking for a new one, fingers crossed) It's the name of an island near Kotlin, which is JetBrain's programming language. It's also close to St. Petersburg, which is where one of their development office is (and where the IDE devs are located). For a codename I think it's a nice pun. &gt; - minimal files in solution folder (the .idea folder has a lot of files. which ones to add to git??) You can read this: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839 - vs code can do more than just go. One editor to support multiple platforms (gogland, rider etc) Use IntelliJ IDEA Ultimate and you'll get almost all languages supported, except C/C++/C#/OjectiveC/Swift (due to various internals). &gt; - free although 89usd is not that much for 1 year How do you propose the developers would be able to work, JetBrains be able to offer the tools they do then? You can view the available discounts here: https://www.jetbrains.com/store/?fromMenu#edition=discounts - For startups: 50% off - For Open Source projects: free - For students and teachers: free - Student graduation discount: 25% off - For user groups: free - For education and training: free - For Microsoft MVPs: free And you can always write to Sales to find out more about these. &gt; recent changes with file watchers did break something "mkdir C:\WINDOWS\go-build808371703: Access is denied.". Really in c:\Windows? This was caused by a bug in the IDE not correctly forwarding the environment variables which resulted in the incorrect location call made by external tools. This was fixed in the latest version https://blog.jetbrains.com/go/2017/10/26/gogland-eap-17-type-hierarchy-call-hierarchy-parameter-hints-vendor-scope-and-more/ and a solution for it was available as well: https://youtrack.jetbrains.com/issue/GO-4722#comment=27-2492674 Manual configurations of File Watchers were not affected by this. &gt; It's not production ready due to changes in order to get a final product. It is still EAP. That's why it's released as EAP. Here's the disclaimer for it: &gt; (info) It is important to distinguish EAP from traditional pre-release software. Please note that the quality of EAP versions may at times be way below even usual beta standards. &gt; nice things in gogland (like mentioned before) &gt; - refactoring seems to work much better This is caused by the fact the IDE indexed your project first ;) &gt; - integrated db query tool I agree, I wrote massive queries, 200+ lines, with it (and even connected it to AWS Athena) &gt; - code coverage is nice with information in the file view &gt; - autocomplete seems to work better here Again, made possible due to indexing (and a lot of smartness in the Platform). &gt; - neither have good support for large files! What's a large file for you? What would you expect to happen? What happens? Please report any issues you have with the IDE so that they can be fixed. However, keep in mind that sometimes large files are just that, large files. Gogland (and other JetBrains IDEs) takes active measures to degrade the functionality when editing those files as it's known there are limits above which the performance would be really poor. Usually large files (more than a couple of thousands of lines) are generated files, which should not be edited anyway. If this happens in files of under 1000-2000 lines, then please raise an issue. &gt; I will keep a look on future releases and hope that it stabilizes, goes to production. Thank you for your feedback once again, I hope my reply will help you.
I didn't downvote, but I can see how your question is frustrating. Go 1.9 was released with lots of new features. You can read the [release notes](https://golang.org/doc/go1.9) to see what was [new in 1.9](https://blog.golang.org/go1.9). Someone making a list of the changes here doesn't really seem like a good use of anyones time. I'm guessing the downvotes was because anyone interested enough to follow along here probably would be interested enough to read the every 6 month release announcement on blog.golang.org, too, so ... "what are you asking again?"
You can't import packages lower than your `.yaml` for appengine. Try putting `main.go` and `app.yaml` in a folder named `server` or something similar.
related: https://github.com/tylertreat/BoomFilters
[removed]
&gt; Failed lookups: 215 &gt; Expected failed lookups: 0 Uh, why is this nonzero? Almost every application of a filter like this depends on the fact that it has a zero false negative rate, so if the filter returns negative you can stop right there, and if it returns positive, you can do a more expensive check. The cited paper says that the algorithm has a zero false negative rate, so is this just a *buggy* implementation of that paper?
If you are looking for something small/simple that uses the FS APIs, then: https://github.com/a8m/tree Or for something bigger maybe add a simple ls over: https://github.com/spf13/afero Or for something really big try that over: https://github.com/upspin/upspin
This is pretty neat lol
https://github.com/ericlagergren/go-coreutils https://github.com/aisola/go-coreutils
Nice! Would be nice if you wrote some documentation for your functions.
I suppose the main problem with handcoding sql is that it tends to strictly fulfil one goal, so as soon as you need some flexibility it gets much harder, e.g. if you have to implement the jsonapi format, you can have a ?include=&lt;some relationship&gt; which requires a join, and if it isn't included you shouldn't do the join. So if you handwrite the sql you would have to have 2 seperate calls just for that one usecase right. And the list goes on and on - and i find that it often leads to just fetching everything from the database, and then filtering it directly in the go code instead of actually using the DB features. I also think it is problematic that everytime you update a struct, which happens quite often, you have to modify code in 20 different locations. So i was just thinking if someone had a github repo or something, where handwritten SQL looks maintainable, also in a big application. 
It's not clear what your issue is. You either use an ORM, generate structs and methods from a database schema with a code generator, or write code manually. And yes it's going to be verbose, because Go doesn't allow any form of meta-programming that is not verbose. That's personally why I'd prototype an app with NodeJS instead of Go, until the data model is stable. Both solutions just can't compare in terms of productivity.
It's seems like being able to version golang packages would be useful...
Fail silently in what method? The docs say you're supposed to use the Err method to retrieve any error that occurred during scanning. Is that not working?
It doesn't fail silently, call scanner.Err() as in the examples: https://golang.org/pkg/bufio/#example_Scanner_lines ...bufio.ErrTooLong will be there.
First off, it doesn't really fail silently since you should always check the `Err` method once `Next` returns false. (See: https://play.golang.org/p/rAoR0C8AMq) Anyway, structuring "iterators" like this: type Iterator interface { Next() bool Err() error // more methods } for i.Next() { // automatic break, so cleaner loop } if err := i.Err(); err != nil { // do stuff } is a lot nicer than type Iterator interface { Next() (T, error) // more methods } for { t, err := i.Next() if err != nil { if err == io.EOF { break } // handle actual error } }
Thanks for the answers everyone. I wasn't checking errors properly. My program finished normally, but the result wasn't as excepted because of long file lines. I increased the buffer and result is now OK. Just got to check errors better now.
You can sorta get the same effect, but there are lots of special cases like what if someone deletes their repository or what if someone hacks in and changes the code for the dependency out from under you? Also, if you have to download all the dependencies anyway to work on a project, why not include them in the git repository and be able to more precisely track changes and build tools that work across not only your code but also all of your dependencies? I mean this really tends to be a polarizing issue. Big companies tend to include the source code for dependencies since they already have good tooling for managing it, and it's more secure - they don't like to depend on anyone else. There are pros and cons to both sides. One nice aspect of Go is most Go dependencies are actually written in go, so it's easy to just compile them when needed. Many other languages actually force users to not vendor dependencies because they need to be pre-compiled or generated with various tools (eg. C/C++ libraries for Python/Ruby/JavaScript). So vendoring (and mono repos) have far fewer disadvantages when your primary language is Go. I personally prefer to vendor my dependencies because it just seems more efficient, but if you don't, then I don't think it's a major issue.
On closer inspection, I think it's because it treats the zero fingerprint as an empty slot. About one in 2^16 items is going to have a zero fingerprint, which gives an expected 253 failures. 215 seems close enough. To repair this, either add a bool to each bin of each bucket to say whether it's occupied (instead of using `emptyFingerprint` as a sentinel), or else force the fingerprint to be nonzero (at the cost of a tiny bit of storage efficiency). I recommend the first option, because the second one is harder than it sounds to do correctly, and doing it *incorrectly* leads to an uneven distribution of fingerprint values, which is inelegant at best, and a potential security issue at worst.
Why make this a server? Why not just CLI that dumps the json?
For what it's worth, generally there's two ways I want a find function to return if the value isn't found, depending on how I'm using them...I think the standard library fails in the second case Find - return index where item would be inserted. Useful for insertion sort. This is how `sort.Search` behaves, and it's great. LowerBound/UpperBound - return `len(n)` -- chances are I want to write something like: `return foo[find.LowerBound(cmp):find.UpperBound(cmp)]` (I'm assuming here that `cmp` closes over `foo` and what I'm looking for - or something along those lines.) if both the item isn't found, then you get an empty slice. This would be great for being able to do a range scan. General point is that if the item is not found, I don't want to do additional branching or comparisons to take a slice.
[removed]
[removed]
I tried running go test but get `industrial:url-shortener ahnc$ go test --- FAIL: TestCreateURL (0.00s) panic: runtime error: invalid memory address or nil pointer dereference [recovered] panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x111e18a] goroutine 5 [running]: testing.tRunner.func1(0xc42006f2b0) /usr/local/go/src/testing/testing.go:622 +0x29d panic(0x12b8520, 0x1465920) /usr/local/go/src/runtime/panic.go:489 +0x2cf database/sql.(*DB).conn(0x0, 0x14435e0, 0xc420010e28, 0x1, 0x0, 0x1, 0xc42000e0b8) /usr/local/go/src/database/sql/sql.go:896 +0x3a database/sql.(*DB).query(0x0, 0x14435e0, 0xc420010e28, 0x131c0b0, 0x3f, 0xc420117d60, 0x1, 0x1, 0xc42006cb01, 0xc42001b440, ...) /usr/local/go/src/database/sql/sql.go:1245 +0x5b database/sql.(*DB).QueryContext(0x0, 0x14435e0, 0xc420010e28, 0x131c0b0, 0x3f, 0xc420117d60, 0x1, 0x1, 0x1521000, 0x0, ...) /usr/local/go/src/database/sql/sql.go:1227 +0xb8 database/sql.(*DB).QueryRowContext(0x0, 0x14435e0, 0xc420010e28, 0x131c0b0, 0x3f, 0xc420117d60, 0x1, 0x1, 0xc42010a570) /usr/local/go/src/database/sql/sql.go:1317 +0x90 database/sql.(*DB).QueryRow(0x0, 0x131c0b0, 0x3f, 0xc420117d60, 0x1, 0x1, 0x1) /usr/local/go/src/database/sql/sql.go:1325 +0x7c github.com/AndrewRMorgan/url-shortener.createURL(0x1443020, 0xc420015300, 0xc42000ac00, 0xc4200e8ea0, 0x1, 0x1) /Users/wdh/go/src/github.com/AndrewRMorgan/url-shortener/main.go:88 +0x243 github.com/AndrewRMorgan/url-shortener/vendor/github.com/julienschmidt/httprouter.(*Router).ServeHTTP(0xc42003bf60, 0x1443020, 0xc420015300, 0xc42000ac00) /Users/wdh/go/src/github.com/AndrewRMorgan/url-shortener/vendor/github.com/julienschmidt/httprouter/router.go:344 +0x813 github.com/AndrewRMorgan/url-shortener.TestCreateURL(0xc42006f2b0) /Users/wdh/go/src/github.com/AndrewRMorgan/url-shortener/main_test.go:24 +0x221 testing.tRunner(0xc42006f2b0, 0x131e148) /usr/local/go/src/testing/testing.go:657 +0x96 created by testing.(*T).Run /usr/local/go/src/testing/testing.go:697 +0x2ca exit status 2` looks like I would need mysql setup and I didn't see any notes about the schema. Can you paste output you are getting? It would also be nice to have an in-memory (no mysql) mode to use for testing. 
I created Blast in order to make millions of API requests from a CSV data source... Here's some features: * Blast makes API requests at a fixed rate, based on input data from a CSV file. * Upon restarting, successful items from previous runs are skipped. * The number of concurrent workers is configurable. * The rate may be changed interactively during execution. * Blast is protocol agnostic, and adding a new worker type is trivial. 
Don't use md5 of time to generate a token. Read random data with crypto/rand. 
Cuz everything is a web service these days :p While a CLI is more convenient for local use, a server opens up the possibility to scale up the service in the future (e.g. run across multiple machines; add a cache for recently crawled pages). Moreover, a REST API provides better programmatic access than a CLI.
What is the error you are getting and at which line no. ? You have to be a bit more specific.
 https://play.golang.org/p/UNjgJC7pcM You have to initialize it like this test := &amp;Big{ small: []struct { A string `json:"name"` B string `json:"type"` tiny []struct { c string `json:"content"` d bool `json:"disabled"` } `json:"tiny"` } { { A : "A1", B : "B1", tiny: [] struct { c string `json:"content"` d bool `json:"disabled"` } { { c : "content1", d : false, }, { c: "content2", d : true, }, }, }, { A : "A2", B : "B2", tiny: [] struct { c string `json:"content"` d bool `json:"disabled"` } { { c : "content3", d : false, }, { c: "content4", d : true, }, }, }, }, } 
I took that approach to basically generate an arbitrary string. This string is stored in the db together with the invitee's email address. It can only be used once. What more security would give me a cryptographically secure pseudorandomly generated token as with crypto/rand? What do I miss here?
[removed]
I have a side project which uses hand coded SQL: https://github.com/kaaryasthan/kaaryasthan 
Love it! Gonna buy it as soon as it comes out :)
[removed]
&gt; Yes, it's technically wrong I hear this argument a lot. But I do not understand it. Maybe you could explain it? If I have to ship or maintain a software product I have to keep the external code used by my own code somewhere as I cannot afford a broken product just because some external dependency vanishes from the internet. So most keep each and every dependency used once in the lifetime of the product in something like Archiva or Nexus. This is accepted best practice. On the other hand keeping the dependency in source control is considered "technically wrong". I understand that it increases storage costs. But if you do not update your dependencies on a weekly basis this is not a game changer. Why is keeping dependencies in Archiva okay and in git not? 
I created a binary parser for Diablo II file formats to be able to read all data on a Diablo II character: https://github.com/nokka/d2s It was my first experience with Go and I loved it, I now work full time with Go. I used work with Node.js, C# mostly but never looked back. The reason was that I play on a private Diablo 2 server called [Slashdiablo](https://www.reddit.com/r/slashdiablo/) where I wanted all characters to be able to be seen online like the World of Warcraft Armory. So I created our own [Armory](https://armory.slashgaming.net/character/nokkasorc#equipped) for Slashdiablo.
Hey, after quick glance at your project i do have few questions. Aren't you afraid of using global variables? I mean Database and Config specifically. Don't you think separating models and handlers would be a good idea? Currently i see yours files are pretty messy, and it only will be worse. Also you should wrap your backend in separate directory, so it won't be hanging out with frontend.
Thanks for the feedback! I just had a discussion about global database handler last week here: https://www.reddit.com/r/golang/comments/77p17c/structuring_go_applications/ After that I started thinking about about changing that approach. When I get some more free time, I will try that. Now I will think about other suggestions that you given here :) 
thanks! &lt;3
I am not looking for a "fit all" solution, i know the limitations of Go and why you would use/not use a ORM. I am just looking for pointers from you guys. Because i think whenever i read blog posts about "idiomatic" db code with Go, it is always a hilarious example of "SELECT * FROM BLABLA"; Which is pretty far from the real world. So pointers/small hints/niceness specifically dealing with ORDER BY, JOINS, converting queryStrings in a good way, etc. is what i am looking for. 
For my side project, most of my SQL is hardcoded. For a few places I use text/template to insert some dynamic bits into a particular SQL, such as an extra join or two, or more where clauses. All in all, I'd much rather write the SQL directly than use an ORM or an SQL builder, since the former is so easy to write and I already know it.
Frankly, I have not yet come across a Huginn alternative in *any* programming language. Huginn is indeed quite unique. I once tried Huginn but it was too large for my small virtual server. (Memory and/or CPU wise, cannot remember.) So if there is no alternative out there, then it would seem time to write one...
Uhmm, did you mean to submit the original link? It's here: https://stxnext.com/blog/2017/09/27/go-go-python-rangers-comparing-python-and-golang/ Perhaps mods could change the url. 
Great, thanks for your answer! Helpful to hear, and will test the performance myself as I would also currently only have a personal need for this, and am not willing to have to spend too much money on a powerful BPS just for Huginn.
As far as I know, it's not possible to change the URL (unless you're a site admin, but I've never heard of them doing it).
I'd suggest deleting and resubmitting with the correct link. It's a good link.
I'd suggest that what a Python developer needs to learn in Go is not "pointers" per se, but "not" pointers, i.e., value structs. Basically in Python, _everything_ is like a Go pointer. It's the fact that Go offers some amount of memory layout control that is the shocker.
I listened to this interview. Now this is always my argument when people start debate using node or not. I'm like "well you know the maker of node says he'd rather use go"
[Here](https://www.mappingthejourney.com/single-post/2017/08/31/episode-8-interview-with-ryan-dahl-creator-of-nodejs/) is it present with the text attached.
Why can't I upvote this post several time?
I've been working on an awesome code generator for databases. https://github.com/gnormal/gnorm Docs at https://gnorm.org Example project with ready-to-use templates at https://github.com/gnormal/postgres-go I build gnorm because I dislike ORMs. You build your database using the tools meant to build databases, i.e. sql and your database's native tooling. Then point gnorm at your database, and it generates the boilerplate to interact with it. In the case of postgres-go, that means strongly typed code that uses no reflection. Super fast, super simple to understand, no magic. 
Already looking forward to 1.9
Closest thing I know of is https://github.com/muesli/beehive
I've never understood people who compare them at all, to me it just makes no sense, as the languages and ecosystems are so completely different.
Node isn't a language.
They are indeed different, but they both can be used to create similar applications. 
I started doing these exercises a couple of days ago and I really enjoy it! Thank you for the work you have done!
You shouldn’t over complicate things when it is not necessary. If I was to scale this up, then I could use multiple processors using Kafka or some worker process that can run in the backend. Writing everything as a micro service is a misconception. Instead create a clean cli with an API that can be used within my project is much more extensible. For example, let’s say I want to pull a CSV file, and find the shortest path. I don’t need a rest api. I just need bash. But now, the extra cost of web processing, cpu needed to handle sockets can and is making it less scalable in my opinion. Not to mention over complicated. Try it out yourself. With and without http and which one uses more memory. Either way, great job. Hope you learned something new. 
Why does it take so long for App Engine to support newer versions?
I understand that, but I don't think that's particularly important. You could also use PHP or Ruby, or Lisp for that matter. Just because the problem domain overlaps does not mean that there is enough to compare those languages to each other. Features and applications of the language, absolutely, that's fair game, but I refer more to people who use arguments like Language A is better than Language B because it has feature X. All I'm saying is I believe that this is not enough to make a case for or against either.
"if you’re building a server, I can’t imagine using anything other than Go"
Awesome, thanks!
&gt; Just because the problem domain overlaps does not mean that there is enough to compare those languages to each other. But it's enough for people to have dilemmas which one to choose. And the fact that this dilemma is fairly common is - in my opinion - enough to compare those languages to each other ;) And I don't mean strictly comparing features etc., but rather comparing more general things like the ecosystem, reliability, possible applications, pros and cons.
Cool, I wonder if you could use https://golang.org/pkg/text/tabwriter/ to do something similar.
The postgres-go gnorm solution doesn't have explicit join support yet, but it'll be coming soon. Contributions also welcome :)
Thanks, I submitted it as a new article because I didn't realize what OP was linking to.
I avoid httprouter because of its non-conformity to the stdlib. If I go with a non-stdlib router these days, I use chi. As for testing, what I've done in the past is something like: ``` e := someStructWithAnHandlerFunction{} rw := httptest.NewRecorder() r, _ := http.NewRequest("GET", "/blah", nil) params := httprouter.Params{} params = append(params, httprouter.Param{Key: "token", Value: "my token value"}) // GetSomeEndpoint is the handler function under test e.GetSomeEndpoint(rw, r, params) // response if got, want := rw.Code, http.StatusOk; got != want { t.Errorf("got %d, want %d", got, want) } ```
I've used a bunch of languages over the years, nothing too esoteric or fancy really and I fell in love with Python when I first started using it (circa Python 2.3-2.4). That being said, it's strong point isn't concurrency and its loose typing leads to runtime issues which you just don't have with statically/strongly typed languages. However, concurrency and static typing are some of Go's strengths and Go manages to be more readable/minimal than languages like C++ and Java IMO. For small projects, CI/CD scripts, rapid prototypes. . . Python is better than Go. For performance critical apps, micro services, etc, I'd say Go is the better option. There's quite a bit of overlap where both languages are solid choices. Also. . . there's this tool https://github.com/go-python/gopy which allows you to write CPython extension in Go, which is pretty damn awesome in my book. :) tl;dr yay Python! Yay Go! 
For the uninitiated, Homomorphic Encryption is a type of encipherment that permits operations directly on the ciphertext without revealing any information to the operator. For example, this would allow you to write a web service that adds 2 to an encrypted number. The service would have no need for the keys to actually perform the addition. It's still an area of active research, and various things are currently possible and not possible with it.
That’s fair, I think you’re right. Sometimes, arguments about languages devolve into holy wars, and that’s more what I referencing, but I think I didn’t formulate my own thoughts well enough.
I've been waiting for a successful memory safe C dialect for a very long time, it seems we finally have one (Go) with enough mindshare to hopefully stay relevant for the next 10 years! I'm also watching Rust closely.
As far as I know, architectural issues that had to be solved. Now it should be quicker to get newer versions.
I wanted to like rust, I realllllyyyy did but theres so much "syntactic sugar" (Like trait annotations?)... I probably would have loved it if I didnt learn Go first, the fact that I was writing effective Go code within 4 hours of starting to learn the language really spoiled me lol. That being said (as primarily a java programmer at work) Kotlin is reaallyyy nice. I can't wait till it can produce native binaries. It even "compiles" to javascript for web browsers.
just create multiple accounts.
The claimed strengths of Node, the reason that you were nominally supposed to choose Node over Python or Perl or Ruby, are things that are much better served by Go. (With the exception of "isomorphic code", i.e., the ability to run the same language on both client and server, which has always been and remains a very marginal affair, with a handful of people swearing by it, but most people who try it apparently give it up fairly quickly.) There may be reasons to choose Node _other_ than the strengths claimed by the propaganda, but in terms of what the Node team explicitly positioned it as, Go is a better choice.
Oh nice. I didn’t know about this.
Neat. I like load testing tools and this one seems pretty simple. If you don't mind some constructive feedback, I would recommend adding some more statistics to it. Average response time is pretty useless by itself. I would recommend adding some basic statistics numbers, like mean, mode, median, etc, to the output. Some other stats like the 90th and 99th percentile would be useful to find outliers. If you make 1000 requests and average is 10ms and your 99th percentile is 500ms, then you've got a problem -- but you wouldn't know just by looking at the average. Have you checked out Artillery? That's what I use now, and it's pretty sweet. It does lack the interactivity portion, though... that's a sweet feature you have there.
I love toy languages. I've been following along with [Crafting Interpreters](http://www.craftinginterpreters.com/), but it's a Java book, so I'm having to translate things into Go and it's... not going well. But Monkey looks like a fun project that could be educational for me. Thanks for sharing!
But these are entirely different things...
Yep, that's right (also combined with team turnover and time for me to get up to speed on everything). We had to rework a bunch of stuff to support multiple versions of Go at once. We now support both 1.6 and 1.8. Right now I'm trying to speed up the compiler service to bring deploy times down, and 1.9 development is happening in parallel.
Our official announcement: https://cloudplatform.googleblog.com/2017/10/announcing-Go-1-8-on-App-Engine-Standard-Environment.html
&gt; For small projects 25-30 lines I guess
There seems to be an explosion of serverless frameworks being posted in these recent weeks. OpenFaaS, Nuclio, and now Fission. I got excited because they came at a time where I have actually started to think about solving an event pipeline and faas solutions cover that domain. So far I have started to look at the other two, which provide different additional featuresets beyond just the functions. Fission so far looks like the easiest to get a function running since you are just pushing code and not containers. And it has an API gateway built in so that's awesome. OpenFaaS has an API gateway and modular support for multiple orchestration solutions. Nuclio doesn't yet have an API gateway (you have to do it yourself through k8s ingress), and it only supports k8s orchestration right now. But it comes with a bunch more concepts like the different event sources (not just http). Interested to try Fission to see how it compares. 
to piggyback off this answer. I was dealing with OP's *exact* issue *all* day yesterday. I read all types of things to try and figure out what needed to be done. I just couldn't grasp the concept, initially. Eventually, I came to the understanding /u/softwaregav is correct. I think AppEngine looks for package source files at and below the directory level that the app.yaml file is declared. Try having your main.go and app.yaml file in the lowest level of that events dir (if you want to keep that project structure). you could also structure your project as prescribed [by google](https://cloud.google.com/appengine/docs/standard/go/runtime#Go_Organizing_Go_apps) and [here](https://stackoverflow.com/questions/35608403/new-project-structure-for-google-app-engine) [thread with same issue](https://groups.google.com/forum/#!topic/google-appengine-go/7cVj5mn1XDI) 
[removed]
great, thanks for the info.
Hey, Go Cloud eng here (along with sbuss). 1.6 -&gt; 1.8 also included Context in stdlib, so there was a whole class of edge cases that we needed to sort out with how App Engine's Context interacted with popular third-party libraries. 1.8 -&gt; 1.9 is much less of a delta, and we expect it to be much quicker.
Actually creating instances of these structs will be much easier if you split it up into multiple structs as suggested by /u/everdev. Then, your constructor can look something like this https://play.golang.org/p/ksaxCDYLFv
Always blame context.Context, that's the right thing to do :D
isnt golang more used than Scala?
But it is an attempt to bring JavaScript out of the browser.
No problem, thanks for the link and thanks for reading [golangnews!](https://golangnews.com)...
"go doesn’t have a ‘xor’ operator for Boolean values, but it DOES have a ‘xor’ operator for... integers." It does, this magic operator is `!=`.
[removed]
(I wrote the code) The `percolateDown` timer sorting function showed up on our CPU profile, and calling `time.After()` on every packet was the obvious source of that heavy load. The functional changes - longer ping delays and nonsensical close messages for malfunctioning clients - were decided to be not too significant. 
[removed]
Not sure if that's a joke or serious. If the latter, there are many "facts" there that `Go` did right and author's sarcasm about them being "not so fun" is misplaced. For instance, while the alphabetic order of package initialization is curious, it has not bearing on anything. Your package initialization should not depend on any specific order, period. The IsNaN() is for a reason - there is no single value, it can be any mantissa but with exponent being all ones. So `==` operator won't work. While debugging concurrent code is hard, `Go` is one of the languages where tooling (race detection) really helps. There are a few personal jabs at Rob Pike, which was uncalled for. Overall, that series of tweets is in really bad taste.
Well, you can look at the code if you want: runSocketWriter in handlecore.go https://github.com/riking/FrankerFaceZ/blob/a900d1521e890ba65f2b936fd55115b1ecf5e447/socketserver/server/handlecore.go#L465 The select cases are: - reader goroutine error channel - reader data channel - send channel - send-a-ping timeout (here, changed from time.After() to a ticker.C) - server shutdown channel So yeah, setting a read deadline in the reader goroutine sounds like a good idea - it could emit a __sendPing or similar.
Feels like compile times are slower with 1.9
I use gogland, template support is a great addition, hire it's not just html/template and supports text/template to
thanks for explaining it. I was confused by the project itself :-)
&gt; For instance, while the alphabetic order of package initialization is curious Notably, the phrasing from the tweet is also just false. The import resolution isn't alphabetical, it's the order *files* are passed to the compiler in (in a single package) that is encouraged to be alphabetical. That, of course, makes #7 even more wrong than it is to begin with. &gt; The IsNaN() is for a reason - there is no single value, it can be any mantissa but with exponent being all ones. So == operator won't work. In theory, you could sufficiently specialize either the syntax (introduce a NaN keyword, that behaves a certain way) or the semantics (specify that == on NaN compares as true) of go in a way that would allow the syntax to work. But it would take significant special casing for comparatively little benefit compared to the function - so the sarcastic "for all it's simplicity" is literally the reason why this wasn't done.
What does this have to do with functional programming, and what does that have to do with Go?
```After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to NewTimer(d).C. The underlying Timer is not recovered by the garbage collector until the timer fires. If efficiency is a concern, use NewTimer instead and call Timer.Stop if the timer is no longer needed.``` https://golang.org/src/time/sleep.go?s=4766:4800#L140 Your use of `case &lt;-time.After(1*time.Minute)` was 1) allocating a new timer on every iteration of the loop, 2) not cleaning up those timers for at least one minute. I wouldn't call this an optimization per say, as much fixing an easy abuse of time.After`
&gt; Fact #14: much like Haskell, go makes the mistake of treating code points as units of text. Unlike Haskell, it wasn’t created in 1998. Are there languages which natively work with characters instead of code points or bytes?
&gt; [These aren’t even facts anymore I’m just shitposting. But anyway,,,](https://twitter.com/pasiphae_goals/status/923856026629279744) This one needs to be way higher in the list, probably at the start. On the other hand I didn't know of the &amp;^ operator.
Thanks! I will add a check for that.
Traits *roughly* do the same thing as Go interfaces. But yes, I worry a bit that Rust is too complex for newcomers and at the same time the remaining C++ developers might simply continue maintaining their huge legacy codebases so the language might not get enough traction in the future.
If we're doing small nits, this is pointless: https://github.com/schollz/progressbar/blob/78c0f3a76704536dd9befc61fdc8f236fd569b65/progressbar.go#L39-L40 Nobody else can touch p until after that return. To make that more readable, consider p := &amp;ProgressBar{ max: max, .... } return p
Perfect! Thanks :)
Sure there's some extra cost that comes with running an HTTP server, but I don't think it's significant comparing to the actual workload of crawling the pages. And writing a REST service really isn't that complicated with a good framework -- with Gin (https://github.com/gin-gonic/gin), I spent ~15 minutes and wrote ~10 LOCs to turn this program into a web service.
Do you have a way to submit go code? Or do you just check against the given output set?
Doesn't html/template just preprocess for text/template? I was under the impression that the syntax was identical.
thanks a lot for everything you've taught us and done for bringing together the community — so far!! best of luck w the startup endeavors!
This I read bio before reading twits. This one's bio is actually sad :(
http://nooooooooooooooo.com/
[removed]
[removed]
I think your conclusion is on point. If I had to write a large system I would follow the chain of Python &gt; Go &gt; C and only drop down to lower levels when I absolutely must. Those 3 share very similar philosophies and patterns of thinking. You don't have to make a huge mental leap between any of them and you get distinct performance advantages as you go down the chain.
You are welcome! Glad you are enjoying them.
Great starter, don’t forget to check out [omgrpc ](https://github.com/troylelandshields/omgrpc) It like postman but for gRPC. 
I really like Postman and that tool looks really useful.
is it just my or does the bar get shorter over time?
Godamn man, thank you for saying this. Everyone that's like. 'develop on Java, Ruby, Python, C#...Node' I just want to scream at and remind them that node is not a language. Just like NET Is not a fucking language...they're frameworks. 
Please... Beego is not "the Go way"
It’s definitely not as full featured! But maybe some day! Would love any feedback / contribution you can give. 
I find that posts like this come from Rustaceans and functional language purists. I find it to be off putting. Rust user: “Go is the worst at all these things!” Go community: “Cool feedback. ¯\_(ツ)_/¯ “ One of the main reasons I love the Go community.
I don't know about that, like if we are talking about making something that just has to handle many persistent connections ie c10k, or can accept open start stop a lot of connections quickly, Go is really great, when we begin dealing with complex control plane issues Go in of itself is meh, granted it's remedied by the shitload of libraries for such problems, but it sucks when you are the guy writing those libraries, particularly doing so in a reusable manner. Like, for example I was writing a set of behaviors, using nothing but the std lib and a consistent hashing library, which I admit it's stlib is one of my favorites I've seen in a lang, one was a relay service for anonymous http communications, a p2p file store, a distributed membership tracker, and a job dispatcher for the overlay network, writing the proof of concept was pretty simple, debugging it and making it modular was a nightmare. Honestly my opinion on Go is it's pretty fucking convenient, but because it's so convenient, people often use it for things that it isn't the right tool for. Honestly, the only reason why Go isn't one of my mains anymore, is it's not very modular, but it gives the illusion of modularity. On the topic of langs, that are great for servers, particularly in the area of complex coordination, Ocaml + C, Erlang + C, Scala is good if you are willing to work with netty. Before you talk shit about Ocamls multicore problems, node has a GIL too, Ocaml + Lwt | Async's story there is similar to nodes but significantly better, and recently it's official multicore facilities became usable, and it's had 3rd party multicore support via message passing for ages albeit not as good as Go's or Erlang. 
May your new endeavor work out the way it has been planned - and may it also leave you enough time for new Just For Func episodes! :)
Good luck with the new journey /u/campoy! You are a true inspiration. 
Definitely does, I think the block character being used doesn't eat up as much space as the blank space character.
You must be fun at parties.
&gt; The IsNaN() is for a reason - there is no single value, it can be any mantissa but with exponent being all ones. So == operator won't work. Isn't essentially the same true for zero in floating point?
OK, thank you for looking into it. I already have got tests but never tried benchmarking in parallel. It's going to be interesting.
the formatting was annoying, but nice lil guide.
That would be my assumption but I haven't looked into it, I'd assume/hope the ide would support both
Thx! Which parts were annoying? I wanna fix it.
I mean the style, too much big text.
Do you mean the headliner or the visuals?
When will you rewrite the appengine local dev server in go ;) , the current one takes minutes to start on my laptop, often never detects file changes, and always sits at 100% cpu. My colleagues always know when I'm deving our appengine code because they can hear my laptop fans from across the table.
The site is unreadable on mobile.
&gt; If Python has been the easiest-to-learn programming language so far, Golang is even simpler. It is much faster to learn and beats Python in this respect. Is learning Go easier than Python? Maybe for someone that already has coding experience. The post doesn't make this clear. With Go, you need to learn about pointers, slices and types which you don't have to worry about in Python. &gt; Some developers claim Golang is almost as easy as JavaScript. So Go, according to the author, is easier than Python and JavaScript according to "some developers" is "easy as JavaScript"? It leaves me with the impression that as far as ease of learning languages is concerned, the order is: 1. JavaScript 1. Go 1. Python 
What's the Go way?
&gt; 5) Top-Notch IDE and Debugging This section doesn't even mention which IDE, so I'll assume they mean Gogland. This IDE is based on the IntelliJ platform by JetBrains, who also provide PyCharm, their Python IDE. I use JetBrains tools daily, PhpStorm, PyCharm and Clion. Let me tell you they are all identical in many aspects. You learn the key bindings for one and know them for all of their products. Yes there are still the language specific differences but the overall workflow is pretty much the same. I'm not saying that they are bad IDEs, don't get me wrong I absolutely love them, but this section makes it sound like there's no good IDE for Python. 
/u/nomadProgrammer I've reformatted it, I hope it's better now.
type Validator interface { Validate(string) error } func ByRegexp(pattern, msg string) rgx { return rgx{pattern: regexp.MustCompile(regexp.pattern), msg:msg} } type rgx struct { pattern *regexp.Regexp msg string } func (rgx rgx) Validate(value string) error { if !rgx.pattern.MatchString(value) { return fmt.Errorf(rgx.msg, value) } return nil } var validators = make(map[string]Validator) func Register(name string, v Validator) { validators[name] = v }
 type Validator interface { Validate(string) error } func ByRegexp(pattern, msg string) rgx { return rgx{pattern: regexp.MustCompile(regexp.pattern), msg:msg} } type rgx struct { pattern *regexp.Regexp msg string } func (rgx rgx) Validate(value string) error { if !rgx.pattern.MatchString(value) { return fmt.Errorf(rgx.msg, value) } return nil } var validators = make(map[string]Validator) func Register(name string, v Validator) { validators[name] = v }
I’m wondering why didn’t they use gobs if the RPC back end was in Go - there’s no reason to use Protobufs here.