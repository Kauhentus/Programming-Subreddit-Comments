Are you talking about early returns? Most Go programmers, myself included, use them a lot. Keep doing what you're used to.
Defer also makes this practice quite comfortable.
I don't understand this logic. Why would it make more sense? What does it have to do with verbosity? Early returns actually reduce verbosity and complexity. Single exit point makes sense only in C where you don't want to miss the cleanup code (freeing memory, closing files), but Go has GC and defer for this.
One would be able to reverse-proxy a go web app acting as its own webserver in a similar fashion to a FastCGI-based implementation using the `proxy_pass` directive in nginx (or similar in Apache). I'm currently using this method to host a few apps that use revel. 
I think OP knows a bit of PHP and was curious about the overview of Go and HTML working together, not finer points of web application architecture. To your point, most frameworks (Rails and Revel both will, certainly) will readily give you json responses if you want, but client-side rendering is not always a win. For simple pages, or on mobile clients it is often notably slower.
Does anyone have good examples of using the lexer to modify source code?
I'm also a fan of `mustache`, there's [github.com/hoisie/mustache](https://github.com/hoisie/mustache). I also maintain a fork at [github.com/drbawb/mustache](https://github.com/drbawb/mustache) which allows you to pass functions to your template's context. (`func(params []string, data string) string`) I personally prefer it over working with `html/template`; but yes OP should definitely be looking at templating. -- It's much more maintainable than mixing logic (PHP code) with your views. 
Now I need to know what it was!!
Mixing code and the document together tends to be very messy, even using templates. The best solution I know of, though I haven't seen it done in Go, is to create the base HTML file with dummy text and stuff, parse it like Clojure's enlive does, and make changes to the parse tree (enlive uses jquery tags as selectors and simple composable functions to clone an element or change an attribute or content) and convert it back to html and serve that. That way the designer doesn't even need to put up with templating tags or anything- it goes straight from lorem ispum to generated content in a couple of function calls.
?
It is possible to use Go as a CGI program. The details are here: http://nf.nfshost.com/ It's this easy: package main import ( "fmt" "net/http" "net/http/cgi" ) func hello(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello from Go!") } func main() { http.HandleFunc("/", hello) cgi.Serve(nil) } 
wow that is easy. thank you!
He's written a number of high quality blog posts. 
I wonder why he deleted it. The gist of it was this: // Set "defined" keyword to check if a template "name" is defined or not templates.Funcs(template.FuncMap{"defined": func(name string) bool { return templates.Lookup(name) != nil }}) templates being the template we are working with. That makes it possible to use {{if defined "thistemplate"}} xyz {{end}} Although you apparently cannot use any more undefined templates in the {{if .. }} ... {{end}} block, even if the condition is false and not executed. It'll cause an error.
in a long function it may be harder to see an early exit point - I agree on the complexity and that is probably while I will stick to multiple exit points in go also. (and it seems to be "idiomatic" go)
I like them but the argument for is that it is hard to read longer functions if they got several exit points. but I feel that I can keep my pieces short enough for it not being a problem. (actually I am asking if someone else can provide with some good arguments for single returns. I am not able enough myself....)
If you have a function which is too long to understand at a glance then it's probably not a good sign to start with. Also, for what it's worth I find it much easier to read early return functions than functions with long/deeply nested conditional blocks.
You won't hear any good arguments, because the "single exit point" style gets harder to read as the function grows in size, unless there aren't any conditionals (and in that case it's no different than early exit style). Reading it is harder because each conditional pushes potential program state onto a mental stack, which rapidly gets harder to maintain, especially as the code grows longer. For me, this style frequently requires me to read down one set of branches, then backtrack a few to remember how I got there, then going back to where I was, then going to the next branch, etc. It feels like I'm reading the code inside-out. With early returns (and error-handling gotos), I can read the code top to bottom, no problem.
Where a function returns is less important than why and what it's returning. Your Ruby code definitely has lots of early returns, you just can't easily see them(exceptions). The single exit point function idea was a trade off of readability against the need to free resources without memory management. In a single exit point function figuring out what and why the function returned requires tracing back through the whole function. Early returns allow you to disregard possibilities as you read the function top to bottom. 
Thanks, you guys are too kind. I am trying to contribute some Go code too, mostly focused around tooling. My Looper project is under https://github.com/gophertown. I'm currently contributing to Chris Howey's fsnotify and Gary Burd's godoc.org. Those guys deserve a lot of thanks.
Godoc is nice but this presents language agnostic API documentation for end users that probably don't care that your back end is written in Go.
Ah in that case yes, I agree completely.
`var p Pointer; (&amp;p).M(1)` is unnecessary, `p.M(1)` will work just fine.
Russ Cox is one of the founders/inventors of GO. I'm pretty sure he just used that syntax to make something clear/verbose.
A more explicit/verbose one: https://github.com/jteeuwen/magic A pure Go one but it's by far not complete (if you care about Windows, you know): https://github.com/bradfitz/camlistore/tree/master/pkg/magic
Another approach is to parse the magic file and embed the results into a Go program. This gives you portability without making external calls to libraries. See: [https://bitbucket.org/taruti/mimemagic](https://bitbucket.org/taruti/mimemagic)
It would have been interesting to see how Go fares against a similarly optimized C++ version, i.e. more optimized tracer() and maybe faster random function. It wouldn't fit on a business card anymore I suppose.
Absolutely. I am not sure if it is evident from the conclusion, but I am looking forward to rerunning the benchmarks against a fully optimized C++ version (hopefully still true to the original algorithm in the business card ray tracer) Sadly, I put down my C++ chops a while back The original C++ version (expanded): https://gist.github.com/kid0m4n/6680629 But what this does do/show: - How easy it is to go from 1 core to N cores - How easy it is to write idiomatic Go code - Find possible optimization opportunities in Go runtime/stdlib - That Go's performance is in the same ballpark as C++ despite the overheads
Did the Go one still fit on a business card?
Currently doesn't look like it. https://github.com/kid0m4n/gorays/blob/master/main.go
Nope :)
I have rerun the benchmarks now after optimizing the C++ version the best "I" could: https://kidoman.com/programming/go-getter-part-2.html Someone needs to infuse some multithreaded love and turbo charge the C++ version further https://github.com/kid0m4n/gorays/blob/master/ref/rays.cpp
Rerun: https://kidoman.com/programming/go-getter-part-2.html Optimized C++ version: https://github.com/kid0m4n/gorays/blob/master/ref/rays.cpp And yep, you supposed right.
I picked the "business card" version not because I was trying to fit the Go code onto the back of a business card; but because: - Ray tracing is highly parallelizable - The code was in C++ (good target to aim for; performance wise) - The code was concise enough not to cause pain when porting to Go - It produces a visual output at the end of the day; always a self motivating factor
Kinda hard given the strict rules around { and ;. Would be definitely worth a shot though :D
I am sorry, currently it'snt. Yeah, you're right, we need more work for making snowcrash binding in Go, like they did for Node.js and .Net. Looking forward for the possibilities (and time) :)
I did give it a shot. But too sleepy to actually go through the manpage and get it going This for loop would be a good target I guess: https://github.com/kid0m4n/gorays/blob/master/ref/rays.cpp#L175
I completed a fairly major revision. Thanks again for the suggestions. I ended up writing my own protocol. https://github.com/tristanwietsma/jackdb The CLI is still pretty rough. I actually broke the data structure out into a separate project (it was easier to test). https://github.com/tristanwietsma/metastore Expect a thorough benchmark effort over the next week or two.
My tech lead at my company decided to try something new and fresh for this new project. We weren't sure between scala or go, we tried both, we liked go a lot better. Our first draft wasn't really that great but after multiple refactoring we are getting really familar with it. 
Thanks!
Hahahah :)
I'm using [goxc](http://www.laher.net.nz/goxc/). I didn't have the chance to test all binaries yet but at least the Linux and Windows builds work just fine.
You can subscribe to this group as a mailing list by sending an empty message to `go-package-management+subscribe@googlegroups.com`. No Google account needed.
Which of these would do [this?](http://www.reddit.com/r/golang/comments/1neukx/how_to_make_a_web_app_with_go/cci8hjy)
The key does not work: "Incorrect enrolment key, please try again"
Defer and named returns pretty much negate the advantages of a single point of return. I'd go as far as to say trying to use single point of return in Go is very much missing the point.
What a waste of time - after having to create an account and confirm it, the key given doesn't allow enrollment :(
They have closed any further enrolments.
Does this mean you can write native GUI apps in Go?
Well, yes. You can. But it's not that easy as if you write them on native environment (XCode, Interface Builder, etc.) Also, there are some limitations in CGO, like absence of possibility of calling varargs argumented functions.
Part 3 follow up: https://kidoman.com/programming/go-getter-part-3.html tl;dr results: https://kidoman.com/images/512x512-3.png, https://kidoman.com/images/2048x2048-3.png, https://kidoman.com/images/4096x4096-3.png C++ is now twice as fast as the optimized Go version
Thanks for the post! If I may ask, how long have you been using Go and how did you start?
Merci :) I have been using/learning Go only a couple of months. Started on it after I chanced upon Semeer Ajmani's Advanced Concurrency Patterns video and extremely impressed with the Go's concurrency chops (I was looking for a better alternative to node.js)
I'm jealous of YOUR chops! Just read part 1 of your ray tracer blog post. So cool! I'm at university right now and started using Go in one of my classes about a month and a half ago. I love learning Go (albeit a steep learning curve for me and my classmates), but I don't know if I could build a program this advanced on my own. You inspire me, and I hope I can use Go to program like this in the future!
Thanks for the post. Although language shootouts are pretty senseless I guess, we always like them, don't we? :-) Also, impresses me again, with how few loc you can get a nice rendering done. I wondered how much the runtime startup for go hits here. And this would be hitting much more when talking about a JVM/JIT implemetation.
Please, stop writing computation intensive benchmarks for go. Go is for scalable business logic with network access, not for number crunching. We had an C network/website application used to be compiled with -O0, and moving to -O1 doesn't improve performance in any way. (And its performance is enough). That is a best candidate to be rewritten in Golang, not the "raytracer" or "scientific computation".
And yet that's what many people are using it for, successfully.
&gt; Please, stop writing computation intensive benchmarks for go. Please, stop telling people what to do and not to do. &gt; Go is for scalable business logic with network access, not for number crunching. That is maybe what I would tell my CEO at the moment, but does not have to stay that way forever. I think Go does very well in this benchmark.
https://code.google.com/p/go-wiki/wiki/MutexOrChannel
It's been said that newbies to Go tend overuse channels, but maybe that is because there aren't enough good explanations on how to use the alternatives, like mutexes. There's plenty of people (myself included) who had zero experience with *any* form of concurrency before coming to Go, after all. We need more clearly written articles like this for absolute noobs on how to use the sync and atomic packages.
&gt; Although language shootouts are pretty senseless I guess, we always like them I realised the other day that that unlike most other bad programming habits, premature optimisation has the problem that it's actually *fun*.
For the interested reader: the benchmark is comparing apples and oranges, See [the /r/cpp discussion](http://www.reddit.com/r/cpp/comments/1nrm62/go_vs_c_ray_tracer_part_3/) of this article.
I really believe Go should not be "stereotyped" into being a language made for solving one particular type of problem. Someone has actually made a game emulator in Go. Does he deserve a pat in the back, or a kick in the shin?
I checked it out. I think people are not reading the graphs properly? Is it clear that the C++ version is actually faster than Go; with a &gt; 2x margin?
Tell me about it :) Fun fun fun!
I think you have a typo in your article: &gt; C++ is **not** more than twice as fast than an equivalent Go program at this stage.
Note to self: don't work on blog posts at 6 am in the morning. Particularly if you spend the previous 5 hours playing GTA5
Interesting experiment, but is it really c++ being powerful when you're using architecture specific extensions? How much faster is your code on ARM, or pre-Sandy Bridge x86? 
Oh, the program will run very fast, it'll crash almost instantly. :) But yeah, if this was production code there would be different code paths, runtime processor detection plus a generic fallback version. A huge pain to test and maintain. But sometimes you're willing to pay that for a 5x performance increase. But it would be awesome to have a language where the cost, even if you're willing to pay, was smaller.
Well, similarly, what's to stop someone from writing a vector (SIMD) math package for Go, and get that same speedup? It wouldn't be any less "native" than what this guy did, and would have the same caveats. Now, if g++ was optimizing it this way itself, I'd concede the point.
I found this post to be as moot as the post it is criticizing. So the lesson we need learn is: just because I want to optimize a single-loop using AVX or need to access a particular instruction once (inside a loop), I have to write my entire program in C++? This would make sense if the whole code is made of performance-critical loops, or the whole code requires access to machine primitives. Like the toy-snippet he's using to promote his point. Going back to the *real-life*, Go has replaced C++ in most of my new personal projects. And yes, I do write performance-critical, embedded code. Here's how I do it: * I too have hot-spots which effect or determine the performance of the program, and I use either assembly or C there (with Go, it's easy to do the inter-work. With Go 1.2, you can also link C++ code easily). I assert that 20K lines of Go code + 500 lines of assembly is much faster to develop and more maintainable, readable and less buggy than C++ equivalent of the code in question (40K LOC C++ probably). * If you try to avoid allocations as much as possible (with Go, you do have control over allocations), the GC is not a problem. This is sometimes a challenge in practice (pprof and the testing suite are helpful, but they don't fix the code for you of course and sometimes the changes require some refactoring), I admit, but I find it much easier than dealing with C++ code, memory bugs and the C++ compiler itself. Another thing I found to be dead-wrong is: using Go feels like you're stuck with 70s whereas C++ is modern. Because "C++ can access machine primitives". Tell me it was a joke, or that you're a young fellow born in 80s or 90s who hasn't read history.
I don't think they meant that Go feels like you're stuck in the 70s, only that C++ feels like you're not. But in a way, I almost agree: Go feels like a step back in some ways, but a very intentional step back: They left out a lot of things we think of as modern, like generics/templates, but what you're left with is nice and minimal and simple. I wouldn't say "stuck" in the 70s, but perhaps, "a return to the good old days." Or at least, I imagine they were the good old days. I wasn't there at the time.
While it's important to show that Go and C++ can be in the same ballpark as far as performance is concerned.. I still don't get these kind of comparisons. Languages don't have performances, compilers' implementations do. On one side you have C++ compilers with gazillion of man hours invested into them by several companies and open source groups.. on the other side you have a young compiler with a tiny fraction of manpower put into it. What do people really expect to find running these benchmarks? I think the result is valid already: Go can be up there with C++... now, the point should be about proving that Go really is a better language to use and we are not living a collective delusion. 
My first real worldy language was C (mathematics degree, used it for numerical analysis related courses and then a little research.) C is a language I like because I can go down and do nasty stuff. Maybe I'll blow the heap or whatever, but I can do it. Then, for personal projects, curiosity and some of its own power I got into Lisp and Python as my secondary languages. I liked Lisp expressiveness and the ease that Python left for writing quickly. But ever since I "got" into Go, it's the language I'm using for relatively fast stuff and quick dirty programming where Bash isn't enough. With Go I can go and kind of smash the code until it works (like I could with C,) this was something I was somehow missing with Python. TL:DR; I love the minimalism of Go. I can go (heh), write some code and grok it. With C++ (the little I know) it was always a mess. With higher level (Python) there was always a big black box of inner workings that was harder to imagine than Go's architecture.
This sentence surely doesn't sound like that "[...] expressive enough so not feel completely stuck in the 70s but still enough control that I can predict what the machine will do. Go is not a good answer for those cases..." but I don't care what he thinks of it either anyway. We had macro support in assemblers back then, metaprogramming doesn't have anything to do with 70s either. Also, interfaces (static duck-typing), goroutines (that are more like threads, and unlike coroutines with yield), chanells (CSP, appeared in 80s in languages), non-circular package hierarchy and a mainstream systems language with a garbage collector doesn't ring any bells from 70s to me. As a matter fact, C++ still doesn't properly have these (although, as anything, you can emulate these things, but no, not at the language level). I expect them to be added soon though, it'd be such a shame if C++ doesn't have a feature that another language has. Here's the thing. C++ is Stroustrup's project to make himself a name. It has nothing to do with practice of programming or science. I just think he realized that he has a very limited imagination or no future in computer science (just look at his list of publications), and he came up with the genius idea of adding classes to C, and pushed it as hard as he can, and infected the world with it by sucking up to everyone. There are people in academia like him, and I really can't stand such people personally. They patch known things together or find some piece of obscure method that not even the people who created it use in that way, and make a living with that. Successful ones end up creating a rubbish field that is better off dead. If you throw everything you can find into a language for 20+ years, it surely won't feel like 70s, it just feels like... anyway. Let me quote Ken Thompson on what Stroustrup and C++ really is: &gt; Stroustrup campaigned for years and years and years, way beyond any sort of technical contributions he made to the language, to get it adopted and used. And he sort of ran all the standards committees with a whip and a chair. And he said “no” to no one. He put every feature in that language that ever existed. It wasn’t cleanly designed—it was just the union of everything that came along. And I think it suffered drastically from that. 
Great article, thank you
&gt; Languages don't have performances, compilers' implementations do. Languages don't use computer resources, programs do. &gt; I still don't get these kind of comparisons. The language name is being used as shorthand for some well-known language compiler, that's all.
If you have so many packages, how do you build it? Do you always build each package, creating a lib each time? Or do you have some dependency system, like a Makefile, that only rebuilds pages whose files have changed? I couldn't answer these questions, so I always just put everything into a single package.
I set up a script to build each package in the right order. It's been so long since I've touched a Makefile that it never occurred to me to try that. I'm not sure if it even makes sense to split this up into multiple packages this way.
Has anyone been able to compile it?
yes
Could you share tips or the binary? I ran into trouble and kept getting errors on Ubuntu 13.04 x64
I don't understand why you need a script to build your packages in the right order. Does `go install ./...` not work here?
...well, I feel dumb now. :) `go install` works like a charm - thanks for pointing that out. EDIT: For clarity, `go install` does take care of building the packages in the right order, which is fantastic. What it doesn't do is deal with my view templates, which is my core question here.
What exactly does this tool tell you? What do the percentages mean?
I haven't built any large projects using Go, but what I've done is literally just keep the templates in the src/ directory. That way, if any of them need changing, I'm only changing them in one place. In order for your app to find them, either point it to "../src/github.com/[...]", or just call the executable from that directory (which is what I do).
will fix that, my bad
From what I can tell from here http://tip.golang.org/doc/go1.2#cover all it is doing is calculating what lines of code have been executed by your tests. So it isn't telling you how good your tests are. I would love to see [mutation testing](http://en.wikipedia.org/wiki/Mutation_testing) added next. That would give you a better idea of how accurate your tests are. 
Whatever you do, don't post the errors or anything that would be useful in assisting you.
So who is this William Kennedy dude? Is he a go dev? Will this have an effect on go at all? Any guarantees for it?
I cant seem to get this to work on Ubuntu 13.04 x64... I ran go build and gave the following: main.go:10:2: import "github.com/piotrnar/gocoin/btc": cannot find package I removed that line and ran go build again and got: ./main.go:76: undefined: bufio.NewScanner ./main.go:155: undefined: btc ./main.go:160: undefined: btc
I noticed you did not implement ServeHttp method for **OurLoggingHandler(h http.Handler) http.Handler**. Is it because you type cast it in main function?
Aah, yes. Thanks
Yes, this is correct :)
Anyone here used it? Thoughts?
Read http://golang.org/doc/code.html Then, "go get -u github.com/oguzbilgic/kurnaz" 
I'm always hesitant to get behind working groups that put out a mission statement first, because it seems like a long journey from concept to fruition and if your inclination is to announce what you're doing before doing it, you're not going to finish. Here's hoping *this one* is different. But I wouldn't hold my breath... If the Go devs blessed a group as the "official" one and added built-in support to the `go` tool, I bet you'd get the adoption.
TIL one of the "anonymous" names displayed by Google Docs is "Anonymous Nyan Cat".
He runs GoingGo, and also runs the Go Miami group. He's a pretty cool guy actually.
I am a dabbler too, so to be honest, I don't have any real problem with go get and 3rd party packages. But I do see a **lot** of talk about this subject. It's said in the past, the problem can't be mathematically solved. And I agree with that. When I said this on reddit, someone got furious and said that Go needed CPAN. Ok, problem solved. And on Debian, for instance, they use deb files for it. Great. Problem solved again. In my simplistic view of the problem, other languages face the problem too. Why is Go different? I see a lot of brain damage going on cracking this problem. Nathan Youngman made his document, there is a special group made for it. But all the tools are available, with git as the dominant one. 
While on the subject of XML, do you know you can marshal Go objects into XML? package main import ( "encoding/xml" ) type card struct { Entity string `xml:"enity,attr"` Facts facts `xml:"facts"` } type facts struct { Fact []fact `xml:"fact"` } type fact struct { Property string `xml:"property,attr"` Data string `xml:",chardata"` } func main() { // Set up the object fact_1 := fact{"some_property","This is the data!"} fact_2 := fact{"another_property","This is some more data!"} f := []fact{fact_1, fact_2} facts := facts{f} c := card{"entity_1",facts} // The Magic b, err := xml.Marshal(c) if err != nil { panic(err) } println(string(b)) } &lt;card enity="entity_1"&gt;&lt;facts&gt;&lt;fact property="some_property"&gt;This is the data!&lt;/fact&gt;&lt;fact property="another_property"&gt;This is some more data!&lt;/fact&gt;&lt;/facts&gt;&lt;/card&gt; And once you go one way, its easy to go back the other. c := card{} err = xml.Unmarshal(b, &amp;c) if err != nil { panic(err) } http://golang.org/pkg/encoding/xml/
Sure - he should probably amend the Doc do an iptables like "Who am I and why does my opinion on this topic matter" type affair. With Go growing and growing people shouldn't assume that the community knows who they are.
Ah, okay. Could you give me an example of how do it, if I wanted the xml file to be called data.xml ? And, this writes the blank XML file. But how do I write the XML code to that blank file?
http://golang.org/pkg/os/#Create file, err := os.Create("data.xml") if err != nil { // File couldn't be created. Handle this. } fmt.Fprintln(file, "line")
go get github.com/piotrnar/gocoin/btc
Also by handling the creation of the XML manually, you're leaving yourself open to *possible* security threats, but most likely just a possible way to break your XML output. For example if id was set to `1" secretkey="2e83f6a2b`, when the XML is generated the output would be the following. &lt;card entity="1" secretKey="2e83f6a2b"&gt;... If id were set to `" `, the output would be &lt;card entity="" "&gt;... which is not valid xml.
http://www.reddit.com/r/golang/comments/1nxeb9/an_introduction_to_the_go_package_management_group/
noooo don't do this, use encoding/xml. Please for the love of God do not do this.
I don't understand the hostility. The problem is well defined, I want repeatable builds given some inputs. I'm willing to constrain the problem space to get that. How can I define and operate on the inputs to go and go get (or something like it) so that I can get a repeatable build that is useful in practice? It's like Pike is saying "No, you don't need repeatable builds." 
Interesting - I'll check this out. Thanks. :)
fixed and checked, it's now 'go get'able go get "github.com/abhishekkr/goshare" have refactored the code a bit and usable structure is available at https://github.com/abhishekkr/goshare/blob/master/README.md
will be soon implementing Channel b/w LevelDBHandler to ZMQ and HTTP daemon when run parallel to handle communication better and maintain reliability suggestions/comments/stop-signs
Yeah, I just joined that group yesterday, definitely need some consensus here on how to approach versioning. I wrote gpm because it does pretty much what you would do if you had to manage versions manually: uses go get to download the packages and git (or mercurial or bazaar) to checkout the appropriate version. So it's extremely lightweight, the main logic is 14 lines of code, yet it does the trick. I didn't want to make a huge system that forces people to make choices that mess with the way they work. Hopefully we can get some critical mass behind some alternative, but I don't think that will happen unless the Go team does something.
If you copy dependencies into your project repository into an "external"/"vendor"/"[third_party](http://src.chromium.org/viewvc/chrome/trunk/deps/third_party/)" directory like Google does it then you have repeatable builds.
Something that's not clear in the README: I am supposed to run `gpm` every time I work on a different project, right? Or does it manipulate GOPATH in kind of a way like Python's virtualenv does it with their paths?
I see this in the FAQ now: http://golang.org/doc/faq#get_version They recommend goven, even. 
Is it possible that this does not proxy the http host header? I tried it with a website and I get a response from the wrong virtual host. Also the response came back as plain text instead of rendered HTML.
Indeed, I haven't read that. Also, the library is very freshly baked. :) I'll add some godoc! edit: fixed!
Good point, I should add that in the documentation. gpm is minimalistic and doesn't mess with your GOPATH at all so yes, it needs to be run whenever you switch projects. I'm thinking about changing gopath but I don't know how I feel about it yet. What do you think?
&gt; I'm thinking about changing gopath but I don't know how I feel about it yet. What do you think? Well, it's a step in a direction. Some people will like it, some won't. I can't say what I'd think because I'm really new to Go and never touched a production project.
It should be noted that there is a bug in the second Display method (just before the one using defer). Between the release of the lock and the creation of the return string, it's possible for another goroutine to update the balance with a non-GBP amount, in which case the value returned will show the wrong currency.
I've been using https://github.com/divoxx/goproj for the last few months and it changes the gopath if there is a .goproj in the directory from which the command is run.
Using package "html/template" http://play.golang.org/p/o18VOI56KZ I hope it can help you.
hum, interesting. I'll think about that approach.:)
For the sake of keeping the example simple I avoided including any manipulation of the currency code - but absolutely - if you were changing the currency code at any point then you'd need to be careful to make sure that is locked properly too.
Separate your test code from your actual logic. This might help you: http://golang.org/doc/code.html#Testing Consider using the [`log` package](http://golang.org/pkg/log/). You can set prefixes for example from which machine the output comes. Apart from that, I'd much rather use something based on SSH to avoid running yet another server on the remotes. It could handle firewalls as well.
Thanks for taking the time to actually look at my project! Really appreciate it! This project started off as a school project. Soon (in a week), I started to appreciate the beauty of go routines and just wanted to show fellow go lovers how awesome go routines are. I highly doubt the code is productionalizable. However, I think it is a good foundation for building other projects on top of it. The grep client does print the machine name before printing out the associated logs. Thanks again!
Thanks, BDD library like this was the first thing I was looking for when I first tried Go.
Neat, thanks for sharing this!
Waste of time. After creating account, it does not allow new enrollment.
We've been using the BDD-style tool gospec (https://github.com/orfjackal/gospec) for the Heka (https://github.com/mozilla-services/heka) project for about a year now, and have been very happy with it.
I always look at it that way, yes. You're at the very least building an interface for your future self as a maintainer. I take a leaf out of Scott Meyers's *Effective C++*: interfaces should be hard to use incorrectly. For a concrete example, I was designing a configuration type to be passed all around the inside of an application. I decided to use immutability for concurrency safety, and initially I was just going to export all the struct members and have a contract not to modify them, but it just seemed wiser to remove the possibility of race conditions and not export any fields and provide only accessor methods.
There's also a mysterious man by the name of Brad Fitzgerald, who must be some kind of cross between Brad Fitzpatrick and Ella Fitzgerald; also, seriously - no mention of Russ Cox or Ian Thompson or Dmitry Vyukov or Andrew Gerrand as members of the core Go team? ಠ_ಠ 
My favourite API discussion is [this lecture and associated slides](http://mollyrocket.com/873) by Casey Muratori.
The biggest difference between internal and external APIs is flexibility in how often and how drastically you change them. When you release an API for public consumption, there's pressure to not make mistakes; instability in a public interface is worse than inelegancies. But for internal APIs, you're only structuring it that way for your own benefit. If you can rewrite it and do a search/replace on your own code that uses it, all the better.
So is there any counterargument against having no public API at all when creating applications?
cool notes, updated in my fork: https://gist.github.com/aaronblohowiak/6915539
a GOPATH per project with all deps committed is ok except for: &gt;As a developer who chooses to locally fix a bug in a Package I depend on, how can I push that fix upstream ? 
I would have preferred an API like math/big.Int, which allows reuse without allocation within every operation: func (d *Decimal) Add(a, b *Decimal) *Decimal instead of func (d *Decimal) Add(d2 *Decimal) *Decimal
Actually, the type is so small (two ints), that value reciever/parameter/return types are the better choice over pointers: func (d Decimal) Add(d2 Decimal) Decimal So it's more like image.Point.
Touche! Names are hard
 func (d *Decimal) Add(a, b *Decimal) *Decimal I actually looked into this option, but I didn't like it all. math.big package also for some reason uses variables_like_this instead of variablesLikeThis. func (d Decimal) Add(d2 Decimal) Decimal ints will be int64, still though this might be an option. What are the benefits of this style.
&gt; I actually looked into this option, but I didn't like it all It's the most flexible, allocation-saving and idiomatic API for big types. Each allocation is costly and generates garbage that has to be collected. &gt; math.big package also for some reason uses variables_like_this instead of variablesLikeThis. You mean the single local variable y_neg? http://golang.org/src/pkg/math/big/int.go You can hardly call that a trend. &gt; ints will be int64 A type composed of two or three int64s is not big. Methods like Add only become less efficient than a pointer indirection when the type has at least four int64s. You can verify it with benchmarks (via testing.B) or look at the generated assembly code (go tool 6g -S file.go).
Run this http://play.golang.org/p/CI_0ZhM3JJ via "go test -bench ." BenchmarkThreeAddValue 2000000000 1.54 ns/op BenchmarkThreeAddPointer 500000000 4.51 ns/op BenchmarkThreeAddPointerAlloc 50000000 72.8 ns/op BenchmarkFourAddValue 50000000 60.1 ns/op BenchmarkFourAddPointer 500000000 7.35 ns/op BenchmarkFourAddPointerAlloc 50000000 75.7 ns/op
I tried the GOPATH per project approach for a few months, and it worked, but it caused my "digital organization OCD" to flare up every time I used it (I demand the file structure of my projects to be without warts). If I had a package that was used in multiple projects, I would have to figure out which GOPATH contained the dev package. I have been using https://github.com/mattn/gom for the last few weeks and it works great! It also eliminates the ugly src/github.com/demizer/go-logger paths from my src directory per package. Refreshing.
Yea, it does cause some dir bloat. For shared libs, their canonical storage is in their own project with its own GOPATH set up and then merging them into downstream projects is managed just like upgrading other deps -- pretty ugly but it works. One of the shortcomings of gom and other alternatives that I have seen is git-centrism. We use goamz which is in hg so gom would be a half-measure. I am interested in seeing things from the package management mailing list shake out into some sort of standardization and will probably re-evaluate our strategy then. One nice thing about having everything in the same repo is that you have 0 external dependencies at build time. Running ruby's `bundle` on a mature/large project is brutally slow and I would like to avoid that if at all possible.
I kind of like named return values but I never use them because they make my function declarations too long. I would use them more if there were a standard, gofmt-supported way to break long function declarations across multiple lines.
This works fine for me: package main import ( "fmt" ) func main() { u, v, w, x, y, z := name(1, 2, 3, "a", "b", "c") fmt.Println(u, v, w, x, y, z) } func name( a, b, c int, e, f, g string) ( n, m, o int, l, j, k string) { n, m, o, l, j, k = a, b, c, e, f, g return n, m, o, l, j, k }
Why not zookeeper?
Do: name your returns Don't: use naked returns
It's possible to be in a situation where you have to maintain multiple releases of the same project, and they'd have same dependencies, but pinned at different versions.
Read the article? It's explained there.
I always do this: func something( foo fooType, bar bar, operator func(fooType, bar) int, s squidger, ) (int, error) { // ... } `gofmt` leaves it alone
I use the "naked returns" style consistently with functions that can return an error. Often my functions are bailing out early due to an error, and since I use 'err' for the error value for functions I've called as well as the error I'm returning, it is easy enough to just call return without arguments. My one wish is that `gofmt` would allow me to keep this all on one line: if err != nil { return } 
All this conversation has been great. I invite everyone to join in at https://groups.google.com/forum/#!forum/go-package-management These thoughts, ideas and suggestions need to be heard by everyone. Dave has published the goals document and together we will be working with all the existing tools to learn more. This is an exciting time and I hope all of you participate.
As someone whose background is almost entirely dynamically-typed languages, and not having any concurrent/parallel processing experience, goroutines and channels are absolutely fantastic. Managing concurrent communication has always intimidated me, especially python's `multiprocessing` module (I never could get past why Ctrl+C doesn't halt execution). There is a plethora of presentations, slides, and documentation for complex concurrent/parallel execution and the primitives go offers make implementation relatively straight-forward and simple.
It would be easy peasy
But when 'username' deletes their github account what do you do?
What I *always* do is to first layout the API and write how I'd like to use my library. I.e. I just write code that uses a library that doesn't exist, and I see how I'd like to design the API so it makes sense. Then I already have the methods/functions layd out and have a starting point to implement. HTH
That's a really good idea, thank you! I will borrow this method and use it in the current and next applications I write.
Can someone explain the relationship between QML, Qt Quick, and ordinary Qt? I've read the Wikipedia page, but I still don't understand why Qt Quick was created.
I think it's *exactly* for the reason it's now being used in Go. In Qt, the software generates C++ preprocessor code, which is a pain if you want to use that in other languages, such as Go. With qml there is no C++, no cmake etc. Now it's just a package and you can use the Qt designer to generate qml. Another benefit is that a software engineer can work on the code and a gui designer can work on the gui, thus seperating it, like a mvc. And the final benefit I see is that it's easier to generate cross-platform code.
Wow that informative. So I have very naive questions. Does the developer still need some kind of C++ compiler on their machines? And does the Qt designer have anything to do with C++? 
The package itself contains C++ code. For the compilation of the package is g++ required. But from there on, everything is Go. I thought in Qt quick there is no C++, but don't pin me on it.
How about a link from the package view on godoc.org to directly lint a package?
Everyone always forgets about Robert Griesemer. Twice even, apparently. The guy is one of the co-creators of Go, maintains the specification and is the reason go-fmt exists.
Clean little library. But what makes it "performance oriented"?
Awesome! Seems like a perfect first project for me personally to get into Go, as I love working with AIs I just followed your tutorial and successfully set up a randomizer AI and it played (and lost) a game :) fun!
Excellent! I am happy to provide some measure of entertainment, and I hope your AI grows to wipe the floor with the competition :D
Very Nice :-) It seems like a language like Go would really be a shoe-in for the server component of something like this. It's also great to see the stockholm-ai server component is open-source (unlike berlin-ai's) The project is young and I'm sure if there's some community interest it can ramp up nicely, but my initial impression is that the dev-facing documentation, as well as the UI for "watching" games, is still rough around the edges. Overall great stuff :) I wish you best of luck at the workshop. /author of [berlingo](https://github.com/minaguib/berlingo) - a berlin-ai Go client framework
I started out wanting to use Berlin but the server didn't work as well as I hoped, and I wasn't able to (as you noted) set up a server of my own. SO I just wrote this instead. But yeah, it's quite rough still. I am hoping for some great pull requests :D (I wanted to use precisely berlingo when I started out with Berlin, so thank you for your work there!)
Hey so I've been reading through the server source to understand how the stockholm rules differ from the berlin rules (some documentation of exactly this would be great when you have time btw!) and I noticed that your growth formula gives the most new units when the current units is exactly half the size of the node. Is this intentional? Edit: [Here's a graph](http://www.wolframalpha.com/input/?i=y+%3D+1+%2B+x+*+%281+%2B+0.2*%28100-x%29%2F100%29+-+x) of new units created per turn vs current units, on a node with size 100 and growth factor 0.2. 
Well, since have found no exact documentation of the Berlin rules, I can't really answer that question. But since I don't aim for complete conformity, I have just created rules that I felt were reasonable. The fact that the greatest growth is when the node is half-full is actually something I did sort of intentionally - I figure that the growth rate must be proportional to the extra resources that allow the growth. Edit: I noticed that your AI now beat the shit out of 3 Randomizer at the same time, which is cool! If you don't fear the competition, please post a snapshot of your source :D
If you're familiar with Windows MinGW development and would like to help this project, please write up detailed instructions which cover the installation of this project's Windows prerequisites as well as compiling the sparkle QML example and submit said instructions to the project's maintainer. Several people have spent hours trying to set up MinGW/Qt/Glib when using the existing Windows setup instructions as found on the project page. The issues with Windows installation have been recorded in the project's newsgroup: [Thread 1](https://groups.google.com/forum/#!topic/go-qml/s3nPxytmXwk) [Thread 2](https://groups.google.com/forum/#!topic/go-qml/x6b6lvd83aU) Also, a tutorial which walks through QML's native controls would help speed adoption. Below is a great tutorial on Tk which could serve as a template for someone with the time and energy to evangelize go-qml: [TkDocs Tutorial](http://www.tkdocs.com/tutorial/index.html)
This is a small hobby project to really get some experience with Go. It was really fun to write and will be useful to me at least. Previously I was using a shell script to create tarsnap archives nightly (in the format "nightly-YYYY-MM-DD"), but I was manually deleting old backups when my Tarsnap credit started getting low. This program will create nightly and adhoc backups. Adhoc backups are never expired. Nightly backups will be retained for a number of weeks (configurable). The archive from the last day of the month will be retained for a number of months (again, configurable). Feedback appreciated!
Very cool! I've been looking for something like this. I'm going to try this out :).
The project is called [Tango](https://github.com/fsareshwala/tango). Before embarking on this project, I studied various other Go web frameworks. For example, I looked at [Revel](http://robfig.github.io/revel) to see if it would work for my needs. It's clearly very well put together, but I didn't like that routes were specified in a separate file. I felt that was too fragile and against Go's single binary philosophy. Some history: while working on a side-project, I needed a lightweight web micro-framework. I knew about [Flask](http://flask.pocoo.org), but I really wanted something in Go. Python is great, but I've really taken a liking to Go and all that it has to offer. Unfortunately, I couldn't find anything that someone else had already done so I decided to do it myself. This is my first open source go project so I could really use your comments and suggestions. If you think this will be useful for you, please feel free to use it in your own projects! Please keep in mind that while I am using it for my own website, the code is still very young.
This is a great point. There needs to be way more documentation. I'll add it in as soon as I can. For now, I would use the readme on GitHub to get an idea of what using the framework looks like. Having said that, even that could use some more documentation.
You beat me to replying to you :). Thank you for pointing me to write up the godoc. I hadn't yet read the Go philosophy on documentation. Now that I have, I really like the way Go does documentation.
What is etcd? Could not find an explanation on the linked page...
How do you do long living handlers (like long-polling / async)?
Wow. I do not know what problem these are trying to solve, but when I see that list I do not even want to know anymore.
I tried to keep it simple, no higher abstraction , just the net/http built-in package.
I successfully wrote my own AI, and after tweaking it a little it can now reliably beat your simpleton AI! Yay :) I put the code here in case you'd like to see it: http://pastebin.com/Tpj2TTbj I also switched to Google app engine rather than hosting it from my own laptop which is nice, and it took a few hours but I now have Eclipse + Goclipse + Go Appengine all working together :)
it's used in production so it's not an abandoned experimental tool. it's also been around longer than almost all of the above. GVM for example does something very different (managing go version has nothing to do with managing dependency versions). 
I know there's 10,000 go logging frameworks already out there. However, none of them met what I wanted: a well-tested, simple wrapper around `log` which added log levels. So I wrote my own. If you have comments or suggestions, I'd love to hear them. If you know of alternatives that do the same thing, I'd love to hear that too.
Thanks, although most of the credit goes to the go authors, I stole much of it from log's tests. Next up is figuring out how to test Fatal and Panic. The go test framework doesn't at all deal with functions that os.exit.
Author of mango (mentioned in the post) here, and I agree with this. Body being only a string is one of the mistakes that really bugs me about the library. I'd love to do a massive overhaul, and make it seamlessly complement net/http, but I am afraid of breaking people's existing code. So unfortunately, at the moment it can't be helped.. Also: &gt; An interface that is nicer to code with, but takes away important functions is clearly inferior. Depends how important streaming responses are to you.
Even though your model doesn't adhere fully to my thoughts (seeing that your `Middleware` type differs from the standard `http.Handler`), it has some particular features of its own. For one, if I understood the code correctly, the first middleware has the complete control over the request handling – it calls all the other middlewares that it receives from next(). With the original `net/http` model, say, you have this: finalHandler := M1(M2(M3(myHandler))) Here, while `M2` is in `M1` "jurisdiction" – you get to choose whether call it or not, after you pass the control to it, `M2` can decide by itself whether to call `M3` or not – `M1` doesn't really have an influence on that anymore. I have a blog post on useful Go middleware patterns (using the standard `net/http` facilities) coming sometime soon, you might find that helpful when it gets published.
&gt; API design is really a thing one has to get right the first time, especially with Go package management as it is.. Absolutely. I've been debating doing a mango2 fork to fix some of the bad decisions, but haven't had time/motivation. &gt; taking away functionality, even if it's less frequently needed, is no good Agreed, was just being a bit pedantic.
Wow, inspired by your comment in a different thread, I wrote a similar post but about database/sql: [Built-in Interfaces](http://jmoiron.net/blog/built-in-interfaces/)
&gt; I am afraid of breaking people's existing code. You are too early in development to be worrying about that. No web framework can survive being held to its first design. Anyone using what is, with all due respect, "some guy's web framework", ought to be expecting this outcome. Break it. I wouldn't even do a "mango2". Just break it. Announce to your users, if any, when you finally have some sort of stable interface, and until then, all bets are off. The alternative is simply guaranteed obscurity.
 go func() { self.nextWrite = time.Now().Unix() for { if len(self.Buffer) == cap(self.Buffer) || time.Now().Unix() &gt;= self.nextWrite { Wait, seriously? edit: Professional Tip: do not use this library :)
Fair enough. Thanks for the advice.
Yes you are right. Each middleware can call the next middleware or just return the responsewriter and request. They can also modify them or for example recover for panic. I'm going to push a middleware for airbrake that behaves like this. Another example is adding variables to the responsewriter instance that could be used by the next middleware or handler. take a look at the [Chrome Logger Middleware](https://github.com/pilu/traffic-chromelogger).
There's https://github.com/golang/glog as well but usage documentation is a bit sparse, not sure how well it works.
But then not really, if you consider how much golint complains about the Go standard library :) I guess "Google teams who use Go endorsed" fits better.
Ah ty
looking forward to reading your post!
I wanted to use that initially, but you can't even change its settings without command-line flags, unfortunately.
That's a feature! In a large environment, such as within Google, if many different libraries use the same logging package, you can rope together any set of them into your project, and control the logging behavior for the entire application from one interface. Further, once you have a binary built and running in production that sees some unexpected behavior days or weeks in, you can play around with --v or --vmodule on one or more servers without rebuilding.
@titxrf you are right. I added some doc: http://godoc.org/github.com/pilu/traffic-chromelogger
I like the idea, but does it only work for tasks in the directory where I run gotask? It would be nice if it could evolve in a "plugin" ecosystem a-la Grunt.js. In other words, how can I reuse tasks in different projects, do I have to copy-paste them locally every time?
Thank you for your suggestion. I've updated the code to expose the original ResponseWriter. I also read your blog post regarding this. I think I might eventually end up using web.go's approach.
Taking /u/sjustinas suggestion about exposing the original ResponseWriter, both the original `http.Request` and original `http.ResponseWriter` are available to the user. You can implement long living handlers in the standard way. Unfortunately, you won't get any help from the library here. Someday, the library may introduce features for this.
I did take a look at beego a bit before working on my own. I actually use astaxie's beedb orm in another project and found it that way. I actually almost ended up using beego. I can't remember now why exactly I didn't. Beego is pretty nice :). The one thing that I would say I have a difference of opinion on, and this is purely a matter of taste, is that route paths are defined separately from route implementations. What I liked about Flask in python was that route implementations were right next to the paths that they would be executed on. Again, that's purely preference and not something to completely throw out the framework from consideration. Beego is much more than I needed and writing my own has given me a lot of good experience with the Go language. At this point, Tango is a random web framework out of so many already out there. While I am using it myself, I'm not sure if anyone else will.
Yes, for now it only works for local tasks. You're able to build the tasks into executable and distribute it though (https://github.com/jingweno/gotask#compiling-tasks). The idea of evolving into a Grunt.js-like plugin system sounds interesting. I'm open to suggestions and contributions ;)
That's not accurate. You can control flags programmatically.
fixed it. any more professional tips?
A bit of docs might be nice. I only figured out about using flag.Lookup().Value.Set() from looking at how vitess used glog. https://github.com/youtube/vitess/tree/master/go/vt/logutil 
If you're referring to [this commit](https://github.com/adeven/redismq/commit/c74f4b07ec6e2c243d7c3c97ba7e1a4b3abd98a0), that definitely does not fix the issue.
Wow, that's gross. I'm perfectly happy a new goal for my library to be allowing users to avoid horrible hacks [like this](https://github.com/youtube/vitess/blob/master/go/vt/logutil/logutil.go). Also, in my defense, I'll note that I [was told on #go-nuts](https://botbot.me/freenode/go-nuts/msg/5703207/) that it was not possible.
Thanks, you're correct, I was unable to figure it out. I was also [told by #go-nuts](https://botbot.me/freenode/go-nuts/msg/5703207/) that it wasn't possible.
how about [this commit](https://github.com/adeven/redismq/commit/be428ce00541ff163b9df11ab96ef69164755304#diff-5b31de4e3c43a3eba9088f9c1dc8cbfaR84)? i actually appreciate any input. if you like you can also open an issue so i can address this.
the time interval should be adjustable though...
Flush queue when a package is available. Send all package in the queue in a single roundtrip to Redis. for p := range queue.Buffer { n := len(queue.Buffer) queue.redisClient.Pipelined(func(c *redis.PipelineClient) { a := []string{p.getString()} for i := 0; i &lt; n; i++ { p = &lt;-queue.Buffer a = append(a, p.getString()) } c.LPush(queue.inputName(), a...) c.IncrBy(queue.inputCounterName(), int64(len(a))) }) } Also check for errors. If the connection to the redis serve fails, then the code in the repo will discard all packages with no notice.
thx and yes error checking is next on the todo list. your implementation has a weakness though (i think), imagine: - 1 packages comes in - the package is written to redis - meanwhile 100 new packages come in - the redis commands are done - no new package come in so now you have 100 packages lying forever in the queue the latest version of redismq now checks interval and size (upon each write) to cover all bases. if there is a scenario i missed i'd really like to know ;)
There's not a canned way by which to change Go flag values on-the-fly. Such a feature can be very useful for cowboy heroics and testing, and this would be a good example of that. But what I meant was that in a scenario where you have a bunch of servers running in production, it ought to be generally easy to adjust the command line flags of one replica in place and relaunch it without dropping any traffic.
The example code that I posted does not have the weakness you describe. 
IMO, there's too many of the testing frameworks emerging. While it's nice that the community is growing, the problem is that some/most of these frameworks will eventually be abandoned. I think the the focus should be on one or two frameworks. Then again, this may naturally occur on its own.
…instead of what?
I've honestly been pondering on ways to do this for the past few weeks. If you're interested in my initial scratch work I pushed it up to [GitHub](https://github.com/chuckpreslar/stateful). It's undocumented at the moment but should be easy enough to follow.
Channels for the state control.
Yeah, I once experimented with reflection too. But then I found functions the more simple approach. Most of my solution is inspired by the module gen_fsm of Erlang/OTP.
This sort of comment is extremely unhelpful, unconstructive, and will make people to second-guess their feelings about what is important, neat, interesting, needed, fun, and so forth. As you point out, if a project does not find a community or is not supported by its creator, then it will die out. In any other case, _someone_ is finding value in it. Don't be a useless critic. If you think people are writing too many testing toolkits, then go make an existing one better or write something else altogether.
Another option is to use the Ye Olde C encoding of a state machine, combined with a struct to hold the appropriate data. Here's a manual state machine that replaces one run of "b"s with a single "b" ([play here](http://play.golang.org/p/T1EwVfdUdn)): package main import "fmt" type Data struct { input []byte output []byte } func main() { d := Data{[]byte("abbbbbbcde"), []byte{}} d.Go() fmt.Println(string(d.output)) } func (d *Data) Go () { INITIAL_STATE: { next := d.input[0] d.input = d.input[1:] d.output = append(d.output, next) if next == 98 { // 'b' goto BEES; } else { goto INITIAL_STATE; } return } BEES: { next := d.input[0] d.input = d.input[1:] if next == 98 { goto BEES; } else { d.output = append(d.output, next) goto REMAINDER; } return } REMAINDER: { if len(d.input) == 0 { return } next := d.input[0] d.input = d.input[1:] d.output = append(d.output, next) goto REMAINDER } } Old-school? Sure. Effective, though. And if you care about performance, probably the single fastest option you'll get; in tight loops this will cream functions or methods or any other fancy encoding. (I consider this one of the valid uses of GOTO; at this point, you are deliberately no longer using a stack as your organizational principle, you are using a state machine. Yes, you're playing with fire, but it is manageable.)
Pike showed pretty much the same kind of fsm here http://youtu.be/HxaD_trXwRE?t=12m18s really nice way of doing it.
[IMO there's no reason to use all that function boilerplate](https://github.com/streadway/handy/blob/master/breaker/circuit_breaker.go#L65).
python
 func (middleware *AirbrakeMiddleware) ServeHTTP(w traffic.ResponseWriter, r *http.Request, next traffic.NextMiddlewareFunc) (traffic.ResponseWriter, *http.Request) { defer func() { if rec := recover(); rec != nil { —https://github.com/pilu/traffic-airbrake/blob/master/middleware.go#L14 Sigh. HTTP handlers, just like any other piece of general-purpose code, should _never_ panic as a mechanism of control flow. Packages which enable that antipattern should be shunned.
If the functionality of each state is small it can be done this way. I prefer the way using methods when the amount of code per state grows. It's better closed and maintainable. Together with commenting I don't get one huge function but multiple smaller ones. But as said, it depends and there are surely many other solutions.
A the maintainer of the Redis client above I have to note that the location has changed (and the code has been improved). See http://www.tideland.biz/page/367/google-go and there in the section Go Data Management. On this page you by the way find other helpful code too. To browse it got to http://gitweb.tideland.biz. I also can recommend the MongoDB client, it has been developed by a colleague and we're using it for our Juju cloud provisioning and configuration software.
Thanks for pointing that out, I updated it in my post!
I'd like to add http://www.gorillatoolkit.org/pkg/schema to that list, shaves a lot of boilerplate when you're deserializing url.Values to structs.
Second that. Gorillatoolkit is great (especially mux saves me a lot of work) and I've had no Problems with the MySQL Driver. Note though, that it is not likely that you will find a good and "go-ish" ORM. Thats where Python/Ruby and the various frameworks for them shine.
Use a JS framework (EmberJS or AngularJS) for the front-end and have the Go server just act as an API for the front-end. 
Came here to say PHP. It's an extremely robust way to build e-commerce sites with a huge amount of library and community support, as well many small to huge examples of it in the field. Python is the same but to a lesser extent. Java is also not a bad choice, but compared to PHP is harder to get right since you have to deal with JVM crashes and memory leaks in a way that PHP just completely avoids. PS I also love Go but it's virtually my last language choice for an application like e-commerce. 
yeah - doing templating with go is not that fun
I have found the go community to be very helpful. questions at stackoverflow or with the #golang twitter hash is answered in a good way. googling for help is not of much use though....
Oh, the community tries its best, as always. But since there aren't many e-commerce websites built with go (I know of none), there isn"t much experience with it. Rails and Django on the other hand... 
I ask you back, what happens If you delete your gem from RubyGems.org or you python package from pip?
Sadly i have to agree.
The glog package has var exitFunc = os.Exit and then overwrites that from the testing package. Fatal() and friends call exitFunc(). I wonder if you could do the same thing with panic?
Brilliant, I definitely will do that. I should probably do the same for golang's log module and submit a patch, since it's untested there.
or Rails with ActiveMerchant
I've done a few e-commerce sites in PHP, and I've come to hate it. All of the reasons (and more) for why I don't like PHP are echoed here: http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
I have to agree, I'm no longer a fan of PHP after finding Go. Even though you can't really directly compare the two I'd still rather use Go and have a harder time writing something than use PHP and have it done quickly.
In addition to or replacement for several of the lower level packages mentioned here, I believe the Revel framework would be an excelent way to get building sites quickly. It's similar to Play for Java, and Django for Python. http://robfig.github.io/revel/
IMO, saying there are too many testing frameworks emerging is like saying there are too many automobiles emerging. :) Are you saying that you do not like choice? Are you saying that you do not like competition? Of course testing frameworks will come and "go" (see what I did there). Each one will be tried, weighed, and measured. One or several will probably eventually emerge as the most popular and become "standards". This is how standards are born. Join in the fun!
Revel looks really really nice, thank you.
A build an e-commerce website for a living, I've considered Go for our new platform, I still am. The issues I see are the current HTML templating. It's nowhere near as flexible as Djangos templates or Jinja2 ( we currently do Python, so that's my reference ). Pongo tries, but it's no even close to what you'll need. Technically there's nothing wrong with writing a e-commerce site in Go, but as soon as you'll need to deal with the marketing tools ( basically tracking ) and SEO, you'll start missing the flexibility of stuff like template tags from Django. You can do a e-commerce site just fine, but you'll end up writing a ton of code and dealing with brain dead third party expectations. Even with Djangos templating language we often run into third parties asking "PHP or .Net?", or "just place this on the following pages" from someone who doesn't understand that templates and order processing logic is completly seperate. I understand why you would want to write a e-commerce site in Go, it honestly makes a lot of sense, but the HTML templating just isn't there. Gorilla Toolkit or Revel will help with much of the basic stuff you'll need, but depending on you desired feature set of your e-commerce site, you'll still need to write a lot of basic stuff youself. 
A thought: You can reuse tasks like you reuse functions in packages. Just call an exported function from your task function. It's not clear you need any more reusability than that at this point.
Thankfully this would be a site used by myself and fellow programmers, not something we'd try and sell to third parties, so a lot of the headaches you mentioned shouldn't be big problems. 
I like the idea. Would be neat to see some real-world scenarios put into practice.
Stripe and Braintree a bad suggestions for processing credit cards for an e-commerce site. Just get a merchant account with a bank and pick a payment gateway that will support that merchant account, it's much more cost effective. Stripe for example wants 2.5% per transaction, I would never pay anything but a fixed fee and at most 1% for the merchant account, so effectively half of what Stripe wants. Of cause it depends on what you're selling. We make 5% on some items, so 2.5% for payment processing isn't brilliant. 
As long as you're not going to deal with weird ass marketing tracking, you can make Go work. I have to implement tracking stuff, which means adding a blob of Javascript here, a tracking pixel there and so on. Uber Tags, Google Tag Manager and other similar service helps, but still, you end up with some weird ass shit in your templates. We have stuff buried in template tags in Django, because I don't want that crap anywhere near the main logic of our site. 
Let me save you hundreds hours of work: shopify.com Although it could be a fun / novel exercise, part of being a software developer is using the right tool for the job (which I highly suggest if you are doing this for a client).
I coded that solution, but I wasn't happy with it. Instead I [wrote a bunch of small programs, run them, and make sure they die properly](https://github.com/llimllib/loglevel/commit/0a9f8f38f03a8c3666e52e6ccb8f0469fd1dd531).
When there are too many choices it takes more time to evaluate which one to use. The choice of picking the library that gets discontinued (is no longer maintained) is a stinger too. I've seen this happen quite often in the Rails community. I would prefer that the developers unite on one or two projects, for a particular problem, and help grow and improve them.
And some things are unfixable because of the compatibility promises (e.g. ID vs Id in exported identifiers).
Yes, your points are all valid. I don't have a very good feel for the traction of any of the existing go testing libraries so I don't even know what the chances of adoption for GoConvey are but I have high hopes. The good news about GoConvey is that it's being sponsored by [SmartyStreets](https://github.com/smartystreets) because we have a vested, long-term interest in it. While I have spent significant personal time developing GoConvey I've also been able to include coworkers in the design and development and we've been given significant company time to bring it to fruition. So I don't see the project fizzling or being abandoned any time soon. Just curious, what do *you* think of GoConvey specifically? Is it a project you would use and/or contribute to in favor of other existing alternatives?
http://imgur.com/Lzcetcw
And use a load balancer. So you can gracefully plug, unplug, update etc.. your app servers/processes. 
Gingko is unique in its feature set and has a nicely crafted BDD-style DSL, comprehensive set of matchers too (from gomega). I hadn't yet seen that one (yet more evidence that there are too many of these libraries...). I'm interested to know how they stack up for you.
lol 
wow! This package looks awesome. Thanks for the tip ! :)
Sweet! Why don't you put the code on github, so I can link it in the about-page as an example? :D
A toplevel object somewhat akin to Go's Router or Flask's Blueprint seems like it'd be useful to have. That would simplify the API because things like: http.ListenAndServe(":8080", http.HandlerFunc(tango.Dispatch)) could be simplified to: http.ListenAndServe(":8080", myTangoRouter) as long as myTangoRouter implemented the http.Handler interface. This is the approach that Traffic (https://github.com/pilu/traffic/) and some other frameworks use. The other benefit is that you get namespacing and composition in case you want to build a fairly complex app that might have multiple Tango components. This is the beauty of Flask's Blueprints: different blueprints could come from different modules or even different libraries but you can combine them all together into a single app. As Tango is now I don't think this is possible because you interact with it mostly through global function calls.
Done! https://github.com/miridius/ai
"Runtime exceptions" in Go take the form of errors returned by functions, not panics.
It does if you want client-transparent upgrades to the underlying service. Crashing out a TCP connection and re-establishing from scratch is a user-visible change. Further, while your persistent-socket service must always be able to deal with a total reconnection scenario (as that may still happen for reasons out of your control), it can still be expensive to reestablish certain types of connections unnecessarily... and SSL is probably the single biggest reason for that. Of course your system must in general be architected to deal with the fact that at any moment, the network may fail, but that does not obligate you to incur the relevant expenses unnecessarily. It's merely a very attractive choice, but the tradeoffs would be quite different if there were an established framework for creating a "migrateable connection".
The professors usually don't give ideas. That's up to you. Maybe you have done something in the past that you can use and make that better? Just make a short list of things that *interest* you. And ask yourself the normal questions: What is the problem? What should be done? Is it feasible within the timeframe? Is it high level? Who are the experts on this subject? etc.
Ideally the protocol that you are using over the persistent socket supports reconnects that are not visible to the end user. If you are stuck with a protocol that makes reconnects visible to the end user, then you should consider separating connection termination from application buisness logic. With that separation, you can upgrade app business logic without dropping connections.
You appear to have forgotten to consider the case where the end-user is also the direct user of the socket in question. If, for instance, an IM system drops all your connections and needs a moment to reconnect, that is, irreducibly, visible to the end user, as they will neither send nor receive IMs. (Hopefully the client still does something sensible, but still, they will not be able to send or receive IMs, regardless.) Not everything is a backend system. Not everything is a batch system. Not everything is the easy case.
Don't expose the socket directly to the user. Layer a reliable stream over unreliable connections. Expose the reliable stream to the user. If you don't have the flexibility to change the protocol, then you might be stuck as I already noted.
Why don't you replicate some of the functionality from Python's Natural Language Toolkit in Go. Example: Tokenization, Part of Speech Tagging, etc. I don't know how difficult these tasks are, so maybe its not a good subject. But certainly it is an unmet need in the ecosystem. 
Are there open source HLS streaming solutions? Make an MPEG DASH encoder. Or a server and protocol for interacting with Media Source API video players (ChromeCast).
Cleaner/clearer than that? I don't think so. Shorter? Depending on what you're doing you can handle the errors in different ways. Have a look at my talk about this (and other) best practices in Go: http://talks.golang.org/2013/bestpractices.slide Cheers
(OT - sorry if this is hijacking your thread) I'm doing a 2 day hackathon with a colleague for his bday, for something very similar to this project. We're going for a zero-install, pull from your github repo, automatically hosted version of something similar to what you've built. I'd love to get your feedback and/or hear what you think about our efforts. (Or just stop in to say hi -- any/all encouragement keeps us motivated!) For more info on the project, visit http://www.onlinemarkdowneditor.com/docs/tbrianjones/ome-docs/DOCUMENTATION.md#online-markdown-editor-ome You can stop by our chat room at http://tlk.io/ii_hackathon Sorry if this is off topic and a bit of a hijack. Have a nice day.
No, this is very clean and understandable.
This seems like a good project to tackle regardless of the final year project, thanks for the suggestion.
I was going to implement the jade html template parser in go (the templates it consumes are *really* nice and succinct imho), but you're welcome to beat me to it.
Make a chatbot that lets college kids order pizzas via text messages.
How about an encrypted personal financial app that you can track your finances with that you can use from anywhere? I am planning on building this for my family when I have the chance. The std library has a bunch of nice crypto api's, not pounded on yet though...
&gt;I hadn't thought of something to do with ChromeCast, thought they were closing down access so it would basically only work with their software? Don't get me started. As someone who actually built something, used the ChromeCast receiver app before Google modded it to fuck all of us over. I think I know what the API will look like when they get done completely radically changing the innards of the ChromeCast. It's another product launched too early with idiots leading the public rollout strategy. But anyway, yeah, the main video receiver app, before it was pulled, included an HLS streaming and MPEG DASH streaming implementation in Javascript that fed a Media Source API player. A server side component to line up with that component would be nice. But then again, the ChromeCast may go the way of the Nexus Q and this might be a pointless discussion. (But yeah, HLS is used other places, so it would still have value IMO)
Don't confuse "clean" and "short". 
The middleware recovers from panic, and sends the error to airbrake. After that, it panics again with the same error. Doing like this, the application flow doesn't change, but we are able to send the message to airbrake letting the rest of the application panic or recovering in the same way with or without that middleware. This is the reason why a panic is used. And this is the only way you can do it without changing the middlewares stack.
I would absolutely love to see a refactoring library for Go (rename anything across packages, extract method/variable/field, inline method/variable, invert if statement, etc...). Even better would be a plugin for a text editor like Sublime Text or Vim that provides the refactoring tools via keyboard shortcuts.
I put together a little hack, just for experimentation. http://godoc.org/github.com/tcard/tryck I actually don't think it's that bad.
If you're just writing throw away scripts where you don't need error handling, you can always write an [orDie func](http://play.golang.org/p/o9s5nLOVdt).
I'm gonna port some of my existing rake tasks to gotask: https://github.com/jingweno/gh/blob/master/Rakefile. Stay tuned :)
Could you implement routes in a different file, maybe even on plain a text file?
I like to predeclare my variables when I'm going to be doing a lot of error checking, which allows me to do something this this - https://gist.github.com/chuckpreslar/7041607 
Because many people find channels more aesthetically pleasing than mutexes. And [aesthetics are important](http://www.paulgraham.com/knuth.html).
Please **don't** write code like that.
i think you may have a race condition in chihaya because your ServeHTTP will be called in a new goroutine but may be enqueued for running when the waitgroup.Wait() is called. this means that the .Wait() could occur *before* the enqueued goroutine has the chance to call .Add(1).. In the wiatgroup docs, they suggest that you .Add(1) *before* launching your goroutines to avoid this race.
You're completely correct. I read over the source to server.go in net/http again for ideas, but I'm considering just removing the stop functionality until Go supports it out of the box. Thanks for the spare set of eyes!
In a world where there are thousands of 3 and 4 letter abbrs and where technology has such diversification, wouldn't it be better to explain what (G)NATS means? I think a lot of people don't know that.
&gt; mysql library of Go needs to be improvement The relevant packages he used. database/sql github.com/go-sql-driver/mysql
That applies only to mysql tests. If you look at the memcached tests, go performs very well when using msgpack but falls behind both Ruby and Perl when using JSON.
Agreed. The readme links to https://github.com/derekcollison/nats which says &gt; A lightweight publish-subscribe and distributed queueing messaging system. which doesn't necessarily tell you a whole lot.
Go and JSON is really not slow, the bottleneck there is the mysql driver. For a more comprehensive benchmark, take a look on this: http://www.techempower.com/benchmarks/ It has been improved and refined over a series of rounds with contributions from the specific communities.
So is the encoding/json lib slow?
Eh? I'm looking only at the memcached benchmarks. See this response. http://www.reddit.com/r/golang/comments/1orihh/go_rest_api_server_shows_poor_json_performance_in/ccuv5i5
I am not the author of the benchmark. From the source code, nothing seems odd. The JSON libs of ruby and perl are C bindings, but the ruby msgpack library is a C binding too. I shared here to see if anyone can explain the difference.
What's the added value compared to https://github.com/bitly/nsq for example? 
Removing database access shows, that json has equal performance to msgpack. Conclusion: author made mistake when did it's benchmark, and put numbers of json+mysql inplace of json+memcache.
&gt; mysql library of Go needs to be improvement ? This benchmark needs to be improvement 1) This claim, unless I misread (highly likely) is unfounded. Looking at the benchmark, it's clear that the following 3 tests have the same timings: `Go + msgpack + memcached`, `Go + json + memcached`, `Go + json + mysql`. IMHO, the only conclusion that be drawn from this is that the entire benchmark is flawed. Especially given the small times(milliseconds), which might very well be dominated by constant overheads. also. 2) These contenders don't do the same thing. One uses a prepared statement, the other concats strings to make the sql: `.pl`: "select name,mail from user where id = ?"` `.go`: "SELECT name,mail FROM user WHERE id=%d" 3) The code is buggy. The following copy-pasta work together to yield a data race id++ if id &gt; 10000 { id = 0 } 4) The Go handlers don't do the same thing. One uses strconv.Itoa(), the other uses fmt. BenchmarkItoa 10000000 217 ns/op BenchmarkSprintf 5000000 765 ns/op
I think this [thread](https://groups.google.com/forum/?fromgroups=#!topic/golang-nuts/2Xluuq6hmc4) answers a lot of questions. Take a look at the answer from minux: "i believe the way to go is import all 3rdparty code into your repo. (you can't rely on some github project be there forever [i remember at least one project disappeared], so you must store it somewhere else that you can control anyway.) git's subtree merging makes this very convenience."
I've found Go's JSON performance to be the bottleneck in a couple of my applications now, which was somewhat disappointing, however it was still plenty fast.
Not that such a benchmark proves anything at all... but observe what happens when you start to make things more realistic by simply changing that map of `interface{}` to a struct. I think everyone know that the json pkg could be optimized some more. But let's not get carried way with flawed benchmarks
You should try upcoming Go 1.2, it offers simnifically improved JSON performance.
Go is developed and backed by Google, who use it for multiple internal projects among other things. The source code is out there, too. There's no reason it would just die.
[Google Trends](http://www.google.com/trends/explore?q=golang%2C+nodejs#q=golang%2C%20nodejs&amp;cmpt=q) - Seems fine.
I see it only growing honestly. I started to play around with Go when it initially came out. The tooling back then was really bare bones (manually invoking platform specific compilers etc). Since then the follow changed rapidly (to my surprise): * The tooling became superb (go fmt, go fix, go get) * Cross compilation is superb (try out goxc) * Even relatively new land is covered quickly (I currently deploy Go code to ARM 7 devices and it works perfectly) * The code quality emitted by the compiler keeps improving bringing speedups * The standard library (especially network related stuff http, json etc) is of amazing quality and pure go (no bindings brinning new dependencies) * Community support is amazing #go-nuts on freenode is really helpful * Online materials (documentation, videos, blog.golang.org) are of superb quality Was I hyped about Go when it came out? No. I ended up with it by accident and don't regret it. In my case I kept finding out more and more use cases that fitted the tool perfectly to the point where I write most of my stuff in Go now. To give you an overview of what I am working on (not everything from this is open source yet). Big picture: I'm writing a management/monitoring service for ARM 7 devices and the software running on them. This includes: * monitoring software on the devices * upgrading software on the devices * configuration of the devices and the software There is a central server component providing a 'live' web interface via websockets and some javascript (written in Go) that manages the monitoring software (written in Go) running on the actual devices. The server side communicates with a python jsonrpc webservice and directly via go with a redis database for live stats. It works out really nicely so far. You might also consider that I think of myself as a newbie in the language so I guess stuff will get even easier as I get more used to the language. Here are some libs I released (and keep working on) while developing this software: * github.com/mulander/gojenkins - to obtain binaries for the arm 7 devices * github.com/mulander/gosum - to validate the binaries * github.com/mulander/gosnitch - basic monitoring via top Feel free to ask any questions I'll answer as many as I can without exposing details I can't yet release. 
I agree with most of your points. However, I have found the community support (particularly the go-nuts mailing list) extremely lacking. Most of the threads I've read involve someone asking a question and someone else responding in the most abrasive way possible, with the text carefully designed to demonstrate their vastly superior knowledge and wisdom. There are some features that I would like to see added to go, but based on my experience just reading go-nuts, there is no way I would ever submit the idea or a patch. I'd sooner fork the whole project.
I was referring to the #go-nuts IRC channel. The only time I go to the mailing list is from a search engine result :) The IRC channel gives great feedback.
Dude, you are comparing apples and oranges. Node.js and golang are languages with very different intended uses (and crowds). Node.js is more like PHP: a language where you can prototype and move forward quickly. It is great for things like developing 'a social app' with your roommate or basic CRUD application for local farmers market and all that. Golang shines for heavy stuff. Like thousands of servers with hundreds of contributing developers serving millions of people with recommendation engines with bananas hardcore machine learning algorithms. You know, like stuff Google does. Different tools. A hammer and a screwdriver.
OK. I'll give it a shot next time I need something I can't find.
Are the 'huge' static binaries a problem for mobile devices?
Not in this case. The devices run Yocto (https://www.yoctoproject.org/) and have decent storage / power. Go footprint isn't a blocker here in any way. The main benefit here was deployment ease (goxc + static binaries).
I think that's a poor characterization. Go also bills itself as a web micro-framework; it often totes downloads.google.com as the poster child. It's just an order of magnitude (easily) worse in terms of active developers, libraries and completed products in the 'web app' space. Node.js *has* hundreds of contributing developers. Go doesn't. It's true to say that go is more performant in many cases (although as threads recently have shown, worse in others; for example, serving web simple content; node has a very carefully constructed server stack) and that people are finding it to be an excellent tool for writing system utilities and things in, and in that sense you're right, apples and oranges. 
I find this an interesting comment that turns up on the golang-nuts too. What nonsense! It google stopped backing go, the core developers would spend significantly less time on it, and since the core developers are pretty much the only ones who contribute significantly to the source (many tiny contributions from various people does *not* count as having many contributions from different sources; the commit log is quite clear about who's working on go)... the language would stutter. Die? Perhaps not; I'm sure some community efforts would step in to help, but saying 'it won't die, it's open source' isn't right, even if people keep saying it. Without active developers, projects die. Even open source ones; look at wave for a great example of *exactly* this happening. 
Have a look at the list of contributor and tell me how many of them are paid solely to work on Go.
TL;DR - I rely on Go staying around for my job and I'm not worried. The community for Node.js and Go are very different, but I've found neither to be terribly lacking. **Node.js:** * community made up of a lot of ex-Ruby developers * culture for lots of small modules and small standard library * some packages pull in dozens of dependencies * asynchronous design partly to blame (my experience only here; not a bad thing) **Go:** * large standard library, less dependence on modules * community more focused at ex-C programmers * core developers more terse and technical, less forgiving if you haven't done your homework (not rude, just terse) I use Go for embedded development @ work, and it's remarkably better than Node.js in that space (less memory usage, more concurrent connections) and the type of data I work with benefits from background threads (more CPU time spend in data crunching than I/O). In my ~10k line project, I think I have ~5 external dependencies, most of which are maintained by members of my team. Since the standard library is so large, most of what I need is already there, which is probably why you don't see as many public Go projects as Node.js projects. I've had very few questions, but the questions I did have were resolved pretty quickly on either their issue tracker or mailing list. As noted earlier, their core devs are *very* different from Node.js devs, but I actually prefer this. Anyway, feel free to ask me anything, I'll try to answer what I can.
I would rate Go as the best development technology of the last 10 years! And this is worth a look: http://www.google.com/trends/explore?q=golang#q=golang&amp;cmpt=q
Oh please. Read the commit log; it's pretty obvious who the main contributors are. 
Node may be larger than Go today, but in the long term, it's going to be a flash in the pan. It is critically hobbled by the choice of Javascript as the base language, and events as the core abstraction. If you assemble the right stack of hacks, you can, with much sound and fury, _almost_ write something as simple as Go, but as you scale up it starts getting more complicated, or requires a bizarre stack of libraries, or whoknows. To see what I mean, consider not the present state of Node, but its history. First the community insists that everything is just peachy with Javascript and events and its way better than everything else ever (despite being a literally 30-year-old model). Then the libraries start creeping to deal with the event system; code to write event handlers as sequences of functions that thread errors! no, wait, this other event handling method! no, wait, promises! no, wait... all of this is the recapitulation of decades of work in other languages, as the mindblowingly immature Node community (filled with web developers who haven't done much else, quite noticeably so) steadily first rediscover the techniques of other communities, then rediscover the limitations of why that technique did not take over the world, only to pick up the next technique... the whole time still endlessly braying about how their approach is so much better than everybody else's even as they follow in everybody else's dust. (And that's _before_ we talk about the dangers to semi-large code base of the sloppy typing in Javascript vs. the reasonable combination of pleasant, yet useful strong typing in Go....) Go is almost where the real languages are ending up. My only objection is that things are trending towards fully isolated processes instead of shared-state goroutines, but it's pretty close, while at the same time being an Algol-descended language (i.e., like C/C++, not like Erlang (Prolog heritage) or Haskell (ML heritage)). Go's advantage will not necessarily be obvious in benchmarks; Go's advantage will be that the code grows more gracefully than Node code can. (There is a presentation nearly called that, but I'm not sure it really makes the point very well... though that's at least partially because you can not show in a presentation-sized format why one language's code base will tend to grow more gracefully than another's once you have a 100,000-line code base...) It's as likely as not to be the Next Big Language as a result. (I do _not_ consider that a sure thing. However, there's no more likely language on the horizon.) Node will not be. If you listen carefully enough you can already hear the rush away from it as people scale it up and find the complexity of the Node approach blows up in their faces. I expect in about three to nine months for it to become less quiet as it slowly becomes more acceptable for people to start writing postmortems about how it turned out not to work without being shouted down in anger and being told about how it must be because they didn't do it right, rather than Node being a fundamentally flawed approach. (Sort of how like the bloom is now quite firmly off Ruby's rose.) People will still be seriously using and starting new projects in Go when saying "I have a legacy Node base to maintain" will get you looks of pity. Incidentally, I say this as someone for whom Go is not necessarily my favorite language, nor do I agree with all of its decisions. I'm not just being a cheerleader when I say I think Go has a very good chance of being the "next big language". (I'm a polyglot; regardless of what happens to Go my career and my ego is not attached to it.) It's just my observation; it's the only language in the wings right now that has that chance, that's all.
To rebut your comment, Microsoft had a lot of backing for XNA, there were whole books published, but support for it was dropped in later releases of windows and for the Xbox One.
I am not comparing, I am stating that because of it's small community I am worried support will be dropped, please re-read.
I enjoyed this answer, I looked into ARMv7 devices to get more context on what you created. I'm also looking into your libraries, if you're just a beginner then I'm going to be amazed when you're an intermediate. Really great reply to give me some closure. I also really liked that you gave me direction to get integrated to it's community, 10/10
So what's the answer to my question? Are you trying to claim that Google can stop people form working on Go in their free time?
IMHO here. Golang is an experimental (new) language with the philosophy that less is more. It was created as a reaction to the richness (or heaviness) of C++. As such, I think people who are drawn to Golang has a certain streak of terseness and lack of fan-fair. This also could mean people who like Golang have years of experience with other systems that have been around longer, with warts and all. Go must feel like a clean sheet of paper for them. Node.js on the other hand is a way for client side javascript programmers to write server side code in the same language. There are huge advantages to this, as data transport becomes transparent, and mental context switching between server and client is eliminated. Dart is trying to do something similar. I think what makes node.js community so vibrant is because the participants are so young (or young at heart). Javascript is probably one of their first programming languages, and being able to use it on the backend must be liberating. And being used to event-driven asynchronous programming on the browser, fast, asynchronous server code would feel much better than synchronous ruby or java. To conclude, if you are a PHP guy doing web applications, javascript + node.js would give you a lot of capability. If you were a python or ruby backend developer, golang's static typing, speed, and concurrency would be very intriguing. If you are a c++ or java person, golang might feel too "light weight" "dynamic feeling", and would be missing out on some cool stuff if you never try golang.
Sure, that's the idealistic view. And I agree that one should mainly design their code to return errors rather than panic. But in the real world, shit happens. Maybe you messed up in a place you didn't even expect to. Maybe a 3rd-party package is done wrong and panics. Surely, in that case recovering gracefully and taking note of the unexpected panic is better than crashing the whole application. Most popular web frameworks in other languages do this. You want to present user with a nice and useful error message rather than crashing the server altogether in case of an uncaught exception. Saying that failsafes like this automatically encourage writing panic-ing is nonsense.
Of course you can check for updates on the original 3rd party repositories. The git subtree command is specially designed for that. But I do agree that when you use a 4rth party repository you need to modify the import paths on the 3rd party package. That's also the case when you move your package to a new location.
I like the middleware concept, but the way it's done in Go, you have to "wrap" the next step of request processing. IMHO it would be better to register a series of handler functions that can modify the request/response in place and signal if the chain should continue with return values. This would allow sharing of context, too, via a map of empty interfaces, for example.
Those are the people with commit privileges to that repository. If you read the commit messages, you'll see that many, many of the CLs are from others.
Exactly. I love the way you can do middleware in the express framework for node. Something like this: app.get('/this/endpoint', app.middleware.ipthrottle, app.middleware.requireLogin, app.middleware.requireAcl('admin'), endpointHandler ); Where endpointHandler is a function that will get called only if everything before it "passes". 
&gt; Most of the threads I've read involve someone asking a question and someone else responding in the most abrasive way possible, with the text carefully designed to demonstrate their vastly superior knowledge and wisdom. That was probably Jon Harrop. :-)
If you needed to deploy more of them, I'd think that you could always always create a multiple-entry binary to save on both non-volatile storage AND shared text segment space in RAM.
&gt; Golang is an experimental (new) language with the philosophy that less is more. Neither the philosophy not the language are new. Go is a bit like Oberon mixed with Aleph/Newsqueak. The difference is that Go isn't nearly as much a "less is more" language as Oberon is. ;-) (Just read the [Oberon-07](http://www.inf.ethz.ch/personal/wirth/Articles/Oberon/Oberon07.Report.pdf) spec to see what "less is more" means to some people ;-)) &gt; Node.js on the other hand is a way for client side javascript programmers to write server side code in the same language. There are huge advantages to this, as data transport becomes transparent, and mental context switching between server and client is eliminated. I'd think that there's always the option of going the other way round and compile the comparatively simple language that is Go into, say, asm.js. You might even be able to transparently detect support for NaCl/PNaCl and supply native binaries to the browser instead, but that depends mainly on how and when NaCl/PNaCl stabilizes as a target.
Awesome! Thanks!
&gt; However I've noticed the community for it isn't really taking off like node.js. Lol, what?
&gt; Most of the threads I've read involve someone asking a question and someone else responding in the most abrasive way possible, with the text carefully designed to demonstrate their vastly superior knowledge and wisdom. You can't possibly be referring to golang-nuts. There's maybe... one or two abrasive jerks on there (Jan Mercl being probably the biggest) but overall the community is incredibly positive and supportive.
[Here's just one example from the most recent thread.](https://groups.google.com/forum/#!topic/golang-nuts/v0DT1H_QFTg) (Note I'm not Russel Winder, but I do agree with him.) Edit: I haven't kept track of who's a jerk and who isn't, but I've seen a lot of really jerk-y posts. Maybe it's the same one or two people in every thread, spreading poison everywhere. I dunno.
package Y is your package (&lt;- == "imports package") package Y &lt;- A, B, C, D package A, B, D &lt;- F 1. You have no idea which revisions of F package A, B and D expect 2. If you do an update of package A, you have no idea, package B and D will work 3. If you vendor by using another import path, you will have to change all import paths all the time 4. If you vendor with the same import path, you can't use go get anymore for those packages (since go get is based on repositories). 5. Also what about different version control systems? mixing branches of different vcs looks not like a good idea. 6. What if you want to push the changes upstream? Now take lots of packages and lots of dependencies an you have a whole lot to do - in fact you might decide to avoid updates at any cost. The dep tool tells you exactly which code of which package breaks another. It has clear rules for developers to communicate breakage in behaviour via changed exports and / or init checksums. It wont disturb you when A, B, and D depend on symbols of F that did not change. There would be no conflicts, if the sets of symbols, that A, B and D are importing from F do not overlap. You could still branch your changes and merge et al. In theory you should even be able to use symlinks to switch between different variants (not tested) I think that is an improvement. 
The 'g' stands for "go" and the 'd' is for "daemon", if you're still curious.
&gt; But in the real world, shit happens. Maybe you messed up in a place you didn't even expect to. Maybe a 3rd-party package is done wrong and panics. Surely, in that case recovering gracefully and taking note of the unexpected panic is better than crashing the whole application. &gt; This is the point: the Traffic framework already recovers from panic to display an error message to the user instead of a blank page when something panics. This middleware recover from the panic, but it doesn't write anything to the response writer. Instead it panics again, then the previous middleware can recover and display a message to the user. do you have any other solution? 
In order to implement middleware that "plugs" into this, would the below satisfy the requirements? (or is there a more idiomatic way to achieve this) type Middleware struct {} func (m *Middleware)ExistingSession(w http.ResponseWriter, r *http.Request) { // Get the session and check for an existing value/type assert // http.Redirect(w, r, path, code) on failure // return on success } http.Handle("/this/endpoint", NewFilterHandler(AccountHandler, middleware.ExistingSession, middleware.SomethingElse)
&gt; You have no idea which revisions of F package A, B and D expect They will (should) state it, in their READMEs or using whatever dependency management tool we settle on. &gt; If you do an update of package A, you have no idea, package B and D will work Why would they break? &gt; If you vendor by using another import path, That's a bad idea. &gt; If you vendor with the same import path, you can't use go get anymore for those packages (since go get is based on repositories). Of course you can: just change your GOPATH. (But you shouldn't be using `go get` in nontrivial situations, anyway.) &gt; Also what about different version control systems? mixing branches of different vcs looks not like a good idea. What? &gt; What if you want to push the changes upstream? Then you... do it? It seems like you're just laying out a litany of random concerns without really thinking through any of them.
You're referring to the "rm (1)" reply? Actually, that sounded more like *"You're probably asking the wrong question and/or failing to grasp some circumstances of what you're asking for, think about the problem in greater detail"* to me. If I got that answer, I'd interpret it as a prod in the direction of rethinking the problem. Edit: And Andrew Gerrand seems to think alike, so I'm probably right. :-)
&gt; Actually, that sounded more like "You're probably asking the wrong question and/or failing to grasp some circumstances of what you're asking for, think about the problem in greater detail" That's sort of the "I'm smarter than you" attitude I'm talking about, yes. It doesn't provide any useful data for the user (it's not even correct for some platforms) as it's incomplete. It's made worse with the follow-up reply "TIL learning two words is too hard." It's like the guy is trying to get points from others on the forum for being the first to shut down a question. This stuff plagues forums, particularly forums with small populations, and drives out people to seek help elsewhere. I don't see the attitude nearly as often on sites like stackoverflow, where real solutions tend to get more attention.
Agreed. Shutdown should be a bool channel or at least not a shared variable 
I have been building messaging systems for around 20yrs, previously doing work at TIBCO on Rendezvous and EMS. NATS is the result, in principle, of my changing thoughts on what messaging systems should be. This is not an enterprise messaging system, like RabbitMQ, or even EMS which I built in the past. NATS does not have persistence, or transactions. It is more like a nervous system, and it will protect itself at all costs and does not have SPOFs. It does publish/subscribe, and distributed queues. One of my nits is that queues are an interest/subscribe operation, not a publish operation. NATS can mix and match these models at will. The other speciality is around patterns of asking questions to an unknown group size who can potentially answer. NATS has built in primitives to actively prune the interest graph during the receipt of answers, which offloads the clients from large unpredictable cpu spikes when throwing away messages. Here is a quora answer that may be useful as well, http://www.quora.com/Cloud-Foundry/Why-does-CloudFoundry-use-NATS-a-specially-written-messaging-system-whereas-OpenStack-uses-AMQP. gnatsd = Go NATS daemon In terms of benchmarks for gnatsd, run the following after cloning the github repo. go test --bench="." -run="zzz" 
Thanks, I added the link to the 'about' page :)
Just a few nitpicks: * `go fmt`. It's obvious (to me) that the code wasn't `fmt`'d because `i ++` should be `i++` * Please consider using the `range` clause. for { r := &lt;-resultChan should be for r := range resultChan { * Please use defer. go func() { // ... wg.Done() } should be go func() { defer wg.Done() // ... } * avg() - This function looks like it's just fighting the language and api with all the conversion. Additionally, you might be losing data with the calls to .Seconds() and then re-calculating... Perhaps, you could achieve the same thing, in a cleaner, and more accurate way by simply accumilating the durations and then at the end, strip away what you don't need. Or, maybe even better, don't destroy any of the data, and instead have a helper function or whatever that strips away the milliseconds. That way you get nice formatting for free with Duration.String(), but without the noise from the smallers values. * I guess this is just a demo. But I feel like you're over-using concurrency. e.g. without running the code, your use of runChan at a glance, looks buggy. You fetch a token from the channel and then start the goroutine. When the goroutine is complete, it sends the value back onto the channel. Meanwhile, you have a loop that continues to re-fill the channel. AFAICS, someone will block - and this is asking for a deadlock. I think what you were trying to do was use a channel as a semaphore. If so, Effective Go discusses this here http://golang.org/doc/effective_go.html#channels * I saved the most important one for last. Your use of the WaitGroup leaves a bad taste in my mouth. * You start goroutines without first calling wg.Add(1) * You call wg.Done() inside a loop (an infinite loop. see #2 above) * You call wg.Add(count) but don't call wg.Done() inside the goroutine. I'm sure it works, given your synchronization with channel. But I can't think of why you'd want to write code like that. It's unreadable. Perhaps what you wanted to do was wait for all the results? If so, then I think you can achieve that by waiting for the goroutines that send on resultChan and then close(resultChan) (see #2) [edit markdown fail]
Kudos to you for constructive critique.
Why not port Cucumber http://cukes.info/ to Go? It's definitly useful to specify and test with non-developers.
Do you have a source for this statement?
Why would you wrap close in a closure?
I extended the post to include the race condition and bug with the shutdown flag. "My initial reason for not securing access to the variable was practical but wrong. I figured that since the variable is only used to shutdown the program when it becomes necessary, I didn't care about a dirty read. If by chance, within the microsecond of glare there was between writing to the variable and reading the variable, if a dirty read occurred, I would catch it again on the next loop. No harm done, right? Why add complicated channel or locking code for something like this?" Yes, Harm Done Living and Learning By My Mistakes. Thanks Everyone !! 
Great idea. I've definitely used `interface{}` in places where this would've been far nicer.
&gt; They will (should) state it, in their READMEs or using whatever dependency management tool we settle on. As you say it should. Also it is much faster having a tool telling what changed instead of checking the documentation again for every update because something might have changed. Also some libraries can have a lot of documentation. &gt; Why would they break? Because the world moves on and APIs might change in incompatible ways. And they do, see gorilla or mgo. &gt; Of course you can: just change your GOPATH. (But you shouldn't be using go get in nontrivial situations, anyway.) Great idea. But I'd prefer to have only one GOPATH per project and not one for every library I develop. Also makes it much easier having to fix the same library in different ways for different GOPATHs if they break in different ways and you notice later that you can't apply your fix to the other part because then other packages break. Good look for the maintenance. &gt;&gt; Also what about different version control systems? mixing branches of different vcs looks not like a good idea. &gt; What? If you simply put your whole GOPATH/src into a single repository like some suggest you either strip the other repository files out, or you have a mix if you also use packages that are developed in other vcs. &gt;&gt; What if you want to push the changes upstream? &gt; Then you... do it? In another GOPATH? Hahaha how much of them do you want to maintain? &gt; It seems like you're just laying out a litany of random concerns without really thinking through any of them. Nice argument. My impression is that you don't use many external packages. Just because the standard library is great and large does not mean that we don't need a working base for sharing (lots of) possibly depending packages. 
David, I made all those changes. Brilliant and Thanks, Question: I have a piece of code that checks syscall like this // Did we get any of these termination events if whatSig == syscall.SIGKILL { fmt.Printf("******&gt; SIGNAL KILL REPORTED\n") os.Exit(1) } else if whatSig == os.Interrupt { tracelog.LogSystemf("main", _NAMESPACE, "Start", "******&gt; Program Being Killed") // Set the flag to indicate the program should shutdown early atomic.StoreInt32(&amp;_This.Shutdown, 1) } If a kill is issued I just want to terminate hard but anything else I want to try and shut down cleanly. What are your thoughts on this?
I'm a little confused to your opinion on interface{} at the end. I always thought it should mainly be used for containers and such, where you don't actually do anything with the value, just store it somehow to be retrieved in some clever way. If you need to check the type or interface of a parameter, shouldn't you just put that interface in the signature of the function that's doing stuff?
When I was translating some C code to Go I also faced the "union" and solved it with interface{}. But I agree, it doesn't feel correct. When you can limit the data types then the compiler does the type checking. That said, it works and with a simple switch statement I get the correct type. It's not that bad.
It might be valuable to downgrade the GADT example to a mere sum ADT like data Expr = I Int | B Bool | Add Expr Expr | Mul Expr Expr | Eq Expr Exp As you don't really need the result typing and this is much more to the essence of a sum type. It does wreck the `eval` example since you no longer have a specific concrete type to return. Extracting that out we have data Concrete = I Int | B Bool | Any -- this would probably use Maybe data Expr = Con Concrete | Add Expr Expr | Mul Expr Expr | Eq Expr Expr eval :: Expr -&gt; Maybe Concrete eval e = case e of Con c -&gt; c Add e1 e2 = case (eval e1, eval e2) of (I a, I b) -&gt; I (a + b) _ -&gt; Any Mul e1 e2 = case (eval e1, eval e2) of (I a, I b) -&gt; I (a * b) _ -&gt; Any Eq e1, e2 = case (eval e1, eval e2) of (I a, I b) -&gt; B (a == b) (B a, B b) -&gt; B (a == b) _ -&gt; Any Which parallels the Go eval a little better as well.
For a real-life example of this technique, [check out the text/template parser](http://golang.org/src/pkg/text/template/parse/node.go). Struct embedding helps make this stuff nicer; it's a good way to propagate common methods across the various structs implementing the interface. (See also how Pos implements unexported(); it's the only type that explicitly needs to because it's embedded in the other Node types.)
I considered that, and broke in favor of "If you don't know Haskell anyhow, I'm better off leaving it in the format explained by the tutorial". By grabbing it from a tutorial rather than making it up from whole cloth there's a clear path to learning if you want to. If I had hunted farther I probably could have found one that did not use GADT, now that you mention it; at the time I was just satisfied, so I stopped looking. :)
Gotcha :)
I had the same thought: http://techno-weenie.net/2013/10/21/http-handler-pipeline/ It's similar to some of the other solutions, but uses the http.Handler interface.
Go doesn't have 'type alias'. If you make new types for everything you're going to get in to trouble and end up with a lot of annoying type conversations and copies especially in the case of slices.
&gt; chan bool can only be so complicated Does that mean sending binary-coded messages over a chan bool is a bad design? ;-)
&gt; That's sort of the "I'm smarter than you" attitude I'm talking about, yes. It doesn't provide any useful data for the user The user also didn't provide any useful data or expectations, so it's at most a Garbage-in, Garbage-out situation. But I really don't see how the response violates the HtAQtSW guidelines to any excessive degree. If anything, the question sounded very much like a "How can I use X to do Y" type of question, which HtAQtSW dispenses with already by explicitly telling you never to ask like that. &gt; This stuff plagues forums, particularly forums with small populations, and drives out people to seek help elsewhere. Either that, or the forum responders have simply done their homework as to the proper question-answering procedure. :-)
No, that's fine, just don't give anyone else the channel or you'll have to deal with spurious bits you won't be able to recognize. ;-)
The language design is excellent and the implementation is also excellent. Technically, it's a winner. People like using it. A lot. Managers and organizations like it because it's easy to learn and produces well-performing programs. But only God knows the future. People are unpredictable. There are a lot of competitors. Accidents happen. PHP is a terrible language, no question, but it has gained wide acceptance. 
No, the former is kinda based on indirect things that they've been saying and the latter is my opinion.
&gt; To use `go get`, please use URL `loveoneanother.at/tiedot`. See INSTALL for more details. Why not use github?
Oh, neat that you used my mmap package. I'd be happy to accept pull requests for the fixes you've made.
There is: {{if pipeline}} T1 {{else}} T0 {{end}} Would that do the job?
&gt; I probably should get in the habit of running go fmt... Get your editor to run it on save. Saves a lot of hassle. You can also run stuff like go vet on save too, and highlight errors by line.
You might have read in the readme.md that I originally made tiedot purely as a programming exercise, therefore I would like to practice Go project hosting as well, and went ahead to configure my web service to work with `go get`.
Hello Kiwi! Your mmap is wonderful to work with, I sincerely appreciate it. I should be able to prepare some pull requests in the next few days.
So how about you stop being a princess and just use github, then. Thanks.
How about you stop being a dick and say thanks for the free code?
&gt; The user also didn't provide any useful data or expectations, so it's at most a Garbage-in, Garbage-out situation. I think the user was very clear on what he or she expected: a way to do the opposite of go get (and remove the files added to bin, pkg, src, which the user spelled out). It's a pretty standard package management feature that, IIRC, is only missing in go and perl's CPAN. Besides, it's not like the people asking well-formed questions (which I assert this was) are going to learn that they did not ask the question in exactly the right way when they get single-word responses. But even setting that aside, Aram could have simply ignored the question if he was so annoyed by it. That's the real problem, IMO.
Another hyperbolic NoSQL engine sprung from a learning-Go exercise (admitted by the author) yeah I think I'll pass. Thanks!
&gt; I think the user was very clear on what he or she expected: a way to do the opposite of go get (and remove the files added to bin, pkg, src, which the user spelled out). What about the dependencies? If package X installs Y and Z for its work, do you uninstall Y and Z, or do you keep them? If you install X (which installs Y and Z), and then install Q (which requires Z and installs W), and then uninstall X, is it supposed to uninstall just X, or X and Y, or X and Y and Z? And how would all this stuff react to version changes in the online repositories? (And as someone noted, doesn't "the opposite" mean instead pushing changes into a repository instead? Because that was my first idea, too, when I saw the subject.) Go people have spelled it out on multiple occasions that *go get* is only a convenience tool. It's definitely not something you should be using to manage any serious large project in testing or production settings. Unix/Linux distribution should be using their packaging system to distribute production Go libraries to users. Ditto for companies doing their own distribution packaging. In absence of that, you already ought to have your own code management procedures in place. The *go* tool can't simply guess what you want. It builds conveniently from the local source tree because that's what Go's authors need. (I'm not even sure that *they* are using that for anything else than local builds - perhaps they're using Google's insane globally distributed build/test system for building their famous 100MLOC Google Unified Source Tree(tm).) Beyond that, all bets are off, and the larger the company, the more likely it is that 1) the procedures in place will be idiosyncratic, 2) the procedures in place won't be amenable to change. Trying to divine them is beyond hopeless.
It is true that Go does not have a "type alias", I will concede I'm using that as slang for things like type TagName string Which isn't a "type alias" as it is in other languages, but it picks up similar (but not identical) functionality from a whole ream of other spec. As for whether it's a good idea, it depends on whether you prefer the type system to tell you you're doing something wrong, or if you prefer to find out at run time that you've screwed up. Having worked in both sloppy type languages and languages that make _Go_ look like a sloppy-type language, I'm definitely reentering the strong typing camp. Anything you can load on to the type system, you should. In general, I'm finding you _don't_ encounter very many annoying type conversions. Non-zero, sure, but as with many things, mostly it's conversions at the fringes, where the data comes in and the data leaves your system, and you always ought to be very careful with the data at those points anyhow. Using strong types is merely one method of dealing with that, and compared to the validation you probably ought to be doing anyhow, not particularly expensive at that point. The rules for deciding what the "same" type is are pretty solid. It's sort of similar to the defense used for why Go doesn't need generics, "Use interfaces better." If your code is suffering from the strong types you're trying to impose on it, you probably need to use types better, including interfaces. The most annoying type conversions I'm encountering aren't of my creation; Go's standard library uses int64 here, int there, uint32 over there, etc etc. Generally they make sense locally but it is annoying. (I hope your code isn't [stringly typed](http://blog.lexspoon.org/2010/05/stringly-typed-code.html); 'tis a horrible thing to do to a strongly-typed program.)
I should add that there's also a sensible middleware implementation here, for when you want to wrap single handlers: https://github.com/bradrydzewski/go.auth/blob/master/auth.go#L206 Useful if you only want to add (say) CSRF checks to a couple of form handlers, rather than adding it to your application and then adding an exception for your other pages. I'm using this to check for the existence of a key in the session when the user hits a /preview/ page with r.Method == "GET" to ensure they have content to display, else I 303 them out.
 {{or (and .Enabled "enabled") "disabled"}}
I had the same thought he did, it's because fortran used those as its comparison operators until 90 as I recall (well, symbolic operators were added in 90). Edit: here, have a link http://www.physics.nau.edu/~bowman/PHY520/F77tutor/07_logical.html
Oh, I thought you meant roff(7), but apparently that syntax is still a bit different. Would have been closer in context to templating though.
Too Bad. Thanks Again for all your help. I changed out all the code and blog posts that used that code. Performed a major code cleanup in the last couple of days. Could not have done it without you !!
[Hacker News discussion](https://news.ycombinator.com/item?id=6598361) (This is not my project; I saw this over at HackerNews and just had to share.) The best part about this is that it is (will be?) Sublime-text _compatible._ Meaning it supports some subset of the available SublimeText themes and plugins. This is a very cool project indeed!
What is sketchy about hosting a project using someone's own domain name?
I'll think about it, thanks.
There's a sense of permanence in hosting it on a well-established site like github.com. What if your domain name expires because you forgot? Etc
Fantastic, I hope this will also help gui development adoption in go! Will watch this project close. 
I indeed agree. How would you go with renaming a Go package? Any suggestions?
I would also suggest just renting a massive AWS instance for a few hours to test. Not that expensive if its just a short time frame.
Which package is this? Is this this std lib package or another one?
Well, there's `go fix`. I'm not at all familiar with it, though.
&gt; Why can’t I open up an issue? &gt; &gt; Because I’m just a single person and I don’t want to offer up my spare time doing support or dealing with feature requests that I don’t care about myself. If you want a feature implemented or a bug fixed, fork it and implement it yourself and submit a pull request when you’re happy with the implementation. That doesn't sound like a good reason not to have an issue tracker. Even if the maintainer isn't going to fix the issues themselves, someone else might, and they can benefit from the issue having an issue tracker. 
I will check it out.
You could probably get some assistance from the various Linux distributions groups, or even hardware vendors. IBM and HP both have programs to use their resources for software porting and optimization on their platforms, I would imagine other vendors can make similar arrangements although I haven't used them. In a past life, I was part of a distribution team, and we were gifted a top of the line server from a major manufacturer (at the time), and that would have been right up our alley.
Here it is: https://github.com/edsrzf/mmap-go For my usage, it does the job wonderfully and is a lot easier to use compare to gommap (another mmap lib hosted on launchpad).
IBM has a virtual loaner program where you can get into a Power system with 1-2 cpus, which may not be helpful to you, although the architecture difference may be worth investigating. You'll need a PartnerWorld account to get it. https://www-304.ibm.com/partnerworld/wps/servlet/ContentHandler/isv_com_tsp_iic_resources_vlp HP's offering is part of their AllianceOne membership, and is called HP Cloud Operating Environment. I am not a member there so I can't really give details on what you are able to get, this is a new program since the last time I needed it. http://h21007.www2.hp.com/portal/site/dspp/menuitem.889e4225d90ac343f77f88e58973a801 Now, as far as community resources... I've been out of the loop for a while, but the answer used to be (and possible still is), join their developer IRC channel and state your case, see if anyone is willing to sponsor you. I expect you would need to have some sort of standardized benchmark where you can demonstrate your progress, and you'll need to be able to state your intentions clearly. They may not be interested, they may redirect you to other contacts, it's hard to say. Remember, when you talk to these groups/companies, they want to see value in both directions. In exchange for those resources, they will want to see that your application works well with their product, and that appropriate steps are taken for them to be a tier 1 platform for it. Also, these guys will likely only have a basic familiarity with Go and NoSQL technologies, and probably won't have heard of your project, so be prepared to give a clear explanation of those! 
Came here to say this. There is no better place for a central issue tracker than the official repository, even if the maintainer does not have the time to handle all the issues personally.
Looks good. Is there a binary version i can download? I don't want to install Python3 etc. for a single build.
Agreed; however an unmaintained issue tracker would be it's own sort of nightmare. Perhaps if this gains traction a contributor will step up, and they could be given rights to open &amp; moderate an issue tracker in the future.
That's what I'm hoping, as well.
No windows implementation yet, contributions welcome.
Even if the creator is the only one to open and close tickets, there's value to having the tracker.
Neat! It's not as pretty as Sublime yet though :'(
I won't pretend there aren't complexities that would need to be dealt with in implementing some sort of "go unget" tool, but the responses tend towards shutting down the conversation before it starts. I don't think that's healthy, but that's ultimately IMO. I do think it's amusing that the line is drawn at "get". Yeah, it's a convenience tool, but some folks on the list act as though asking for a remove tool is this outlandish, unimaginable concept and not just another convenience tool. There are a bunch of threads like this on the list. FWIW, I think I'd settle for a go get that prints out all of the files it creates, so you could easily figure out what files *might* be removable, even if you have to be a bit more careful than just "rm" (as was the original suggestion, heh.)
It replaces the bad character with the Unicode replacement symbol: const nihongo = "日本\xF1語" for index, runeValue := range nihongo { fmt.Printf("%#U starts at byte position %d\n", runeValue, index) } U+65E5 '日' starts at byte position 0 U+672C '本' starts at byte position 3 U+FFFD '�' starts at byte position 6 U+8A9E '語' starts at byte position 7 Program exited. 
Awesome, thank you!
Are you confusing this with KDE? On Arch qt4 takes 81.mb and qt5-base takes 41.77mb (that is installed size, packed size is 20.49mb and 9.25 respectively)
Since the article doesn't, here's what you came to ask: What is ePaxos? source: http://en.wikipedia.org/wiki/Paxos_(computer_science) Paxos is a family of protocols for solving consensus in a network of unreliable processors. Consensus is the process of agreeing on one result among a group of participants. This problem becomes difficult when the participants or their communication medium may experience failures.[1] 
His whole blog is pretty great, if you're into distributed systems. He teaches CMU's undergrad Distributed Systems course (15-440, http://www.cs.cmu.edu/~dga/15-440/F12/index.html) in Go, and wrote up a blob post about it afterward: http://da-data.blogspot.com/2013/02/teaching-distributed-systems-in-go.html
Not only that but a huge focus of KDE5 is breaking this stereotype. Inqlude is being built, etc. Things are only going to get much much better in the Qt5 ecosystem in the next 6 months.
aww... I thought the research into Paxos might be over after Raft... I suppose they do both have pros and cons.
You should set a $GOPATH that you have access to, usually in your home directory. Mine's ~/go. Packages will be installed there.
Thanks! 
I use a different GOPATH for each project to keep things super clean and tidy / avoid version collisions.
native GUI for go, native wrappers and libraries. Anything that can help the golang community move foward would be great. good luck!
I normally just do set -x GOPATH $PWD when i'm changing my directory to where I'm working.
 $GOPATH /home/projects which holds your bin, src and pkg folders go get is your friend. 
One man's duplication of effort is another man's healthy competition. 
@jzelinskie - very different kinds of research, and I -- in my obviously biased opinion -- think that both are needed. The goal of Raft is not really to build a "better" Paxos, it's to make it easier to teach and use one of the foundational distributed replication mechanisms. This is important for a lot of reasons, some of them historical: The initial papers about Paxos are horrible to read for a non-expert. Ok, I'm lying. They're kind of horrible to read the first few times for an expert, too. Raft's goal is good. REALLY good. Whether it's better than the recent work from MIT on presenting a simplified version of Viewstamped Replication (VR is the same as Paxos, co-invented at around the same time by Barbara Liskov) is a good question. Both are worth looking at. ePaxos, and other paxos variants, instead focus on things like reducing the number of round-trips involved in Paxos operations, or achieving higher throughput. This is also important: Paxos is avoided in many situations (see "eventual consistency") because it's perceived as being too slow or too high-overhead. The con of ePaxos compared to Raft is that ePaxos is even more complex than normal Paxos, because it adds a notion of tracking the dependencies between operations. The code is a little more tricky, too. This is a serious drawback when talking about a replication protocol: Simplicity is really nice when trying to ensure that the code is working properly. Its advantages are better throughput and lower wide-area latency.
There are basically two ways to approach this: * Have a single Go workspace (GOPATH) that you use for all your projects. Andrew Gerrand goes into detail on how to set this up here: http://www.youtube.com/watch?v=XCsL89YtqCs * Have a GOPATH per-project. For that, you just set $GOPATH to something inside your project. If you go this route, I suggest checking at least the source of the projects into revision control so you have reproduceable builds. Lately I've gone to a single GOPATH workspace. There's always the concern about versioning and big API changes, but for the most part the Go community has developed pretty good practices around that. Still, if you want to be very strict about it, check your deps into git or whatever.
While waiting patiently for the outcome of The Final Correct Way To Use Go Packages, I've settled into this for local development: go/ lib/ src/ LIBRARY1 proj/ PROJECT1/ src/ LIBRARY1SYMLINK runtime/ EVERYTHING_FROM_GO_GET GOPATH is set to `runtime:proj/CURRENT_PROJECT`. I run godoc with `GOPATH=lib:$GOPATH godoc -http=:9000`. I have .gitignore set to ignore the entire runtime directory. If I want to just `go get` a tool, the fact that `runtime` is first in the go path means it is installed there. I have the relevant "bin" on my PATH. If I want to use a library, I "go get" it, then move the library from runtime to lib. I take the "real" name, which is to say, I strip off the github.com/username etc, because I don't think accidental details about where I pulled it from today should live in my source code. Each project that needs a library gets a relative symlink. Unfortunately, godoc does not follow symlinks, which is why I have to add the library path when I run it. I have shell scripts for setting what project I am currently working on. (Along with a couple of others for working with the coverage tools in 1.2.) I do not intend this structure to last forever, because once there is a "real" package management mechanism I intend to use that. However, until then, as I am working in an environment where reproducible builds are critical, this is what I'm doing in the interim. And it's working well enough. I wouldn't want to try to use 50 external libraries this way, but if you've got a few separate projects that just use a handful of libraries (with some overlap), this does work out reasonably well.
You can also just use gvm (https://github.com/moovweb/gvm). Manages several go installations including their whole working directory setup.
&gt;I would rate Go as the best development technology of the last 10 years! &gt; &gt;And this is worth a look: http://www.google.com/trends/explore?q=golang#q=golang&amp;cmpt=q Just to point out trends mean nothing without a comparison http://www.google.com/trends/explore?q=golang#q=golang%2C%20nodejs&amp;cmpt=q
Any idea on how to do this on Sublime Text, specifically the highlighting a line? I currently just have it part of the testing builds.
Why would it be irrelevant? In early stages, growth is all that counts. Btw, have you even developed in Go?
A line means nothing without a comparative scale/data set, I mean that is basic analytics. Also even though it is frankly very rude/condescending of you to ask, yes I have and do develop in go professionally.
Defensive? I was just asking
I extended this a bit to panic if all Expr types aren't handled and used recover to deal with evaluation errors more gracefully. It shows how an unhandled Expr type and an invalid Expr are dealt with. http://play.golang.org/p/rwIzzEWJ0u
Good talk. Got lost there a couple times, had to pause the video to read the code carefully. lol
yeah, the same thing happened to me :)
The slides are at http://talks.golang.org/2013/advconc.slide
Install Package Control (Google it) and GoSublime.
I use gvm along with [gom](https://github.com/mattn/gom). Both solve somewhat different problems, but is sorta what OP is looking for.
It doesn't highlight the line for me, I'll have to look deeper into the settings.
Set your CDPATH as well e.g. export CDPATH=.:$HOME:$GOPATH/src/:$GOPATH/src/code.google.com/p:$GOPATH/src/github.com:$GOPATH/src/launchpad.net makes life just that little bit easier... • cenuij@dev-macbook [15|515] ~ : env | grep CDPATH CDPATH=.:/Users/cenuij:/Users/cenuij/src/:/Users/cenuij/src/code.google.com/p:/Users/cenuij/src/github.com:/Users/cenuij/src/launchpad.net • cenuij@dev-macbook [16|516] ~ : cd goauth2 /Users/cenuij/src/code.google.com/p/goauth2 ☿ cenuij@dev-macbook [17|517] ~/src/code.google.com/p/goauth2 :
There's a function for the classic fork-and-exec model. I haven't tried it in Go, but the system calls are all there. Open a connection, hook up the plumbing with dup, and exec. Then I suppose you wait in a go routine so the listener can keep listening without blocking. You don't have to double-fork to prevent zombie processes that way. Like I said I haven't tried it in go, but that should be enough information for you to know what you're looking for. http://golang.org/pkg/syscall/
Relevant: https://github.com/nf/webfront (but not exactly what you want, I think...)
For fork and exec, what you want is the os/exec package.
Sure it's possible - whether it's a good idea or not is up to you. Just pass relevant data on a unix socket, handle it however you need to in python, and pass it back.
Like I said, haven't tried it myself. Thanks for the clarification!
Not quite, he had the legitimate requirement of needing a scripting language - generally used to script little things quickly. If you're writing an app in Python, then your WHOLE application will be in Python, there's really no need to involve Go in it. Now, imagine that you would create a web application in Go, let's say for example, a service that distributes ads like Google Adsense, and then imagine that you would let your users decide when the ads should show up based on the visitor's location, some keywords, time of the day, etc... then you decide that you want to let *power users* define their own complicated logic about when ads should show up or not on certain websites... you could let them write a piece of Python code that receives a dictionary with the "ad context" (context["visitor_ip"], context["website_url"], etc) and then the code returns a boolean saying whether the ad should be displayed there or not. You could then use Go-Python to execute the end user's python code whenever you have to decide which ad to display on a certain page (on top of other considerations like competitor's bids, etc). Wouldn't be the fastest thing in the universe, but would work, and this is why Go-Python and GoLua exists - to enable scripting of small tasks that are better written as scripts than hardcoded into the executable.
Can someone redo this video as a blog in simple language? Dude talks very fast and the context is lost everytime the video progresses. Thanks.
I must have worded my original question wrong then. This is very simliar to what I'm trying to accomplish.
Lime is also integrating python interpreter for text editor scripting
You could have it present as a WSGI server, and run the python webapp behind it? Or maybe I am not quite understanding exactly what you're looking to achieve.
What is the godep magic that the article refers to? Is it simply checking out the commits listed in the dependency file?
Sorry, but sub-struct is not supported yet, but already in my plan. Remember gorm is only 3 days old, so there are lots of things need to tweak/fix/add. 
Sorry for being negative, but can't you just make a reddit group called golang-packaging or something?
informative and easy to read, thanks for sharing!
For those running OS X, you may run in to trouble getting gdb working. I followed these instructions with great success. https://sourceware.org/gdb/wiki/BuildingOnDarwin edit: replaced link with correct link
is the link address correct?
no it just links to this thread
sorry, it's fixed now.
Any advantages over heroku and others free hosting service?
Vertical and horizontal auto-scaling, works out of the box (no changes needed), hosted in France in tier-4 datacenters. That being said, their prices are clearly not aimed at individuals, it's business oriented. Although I believe they happily host open-source stuff for free.
This is pretty nice, i'll look into it in a free hour. Even hosted relatively nearby... hmmm if only i hadn't rewritten my website in PHP to not need a VPS.
Thanks!
Well they also host PHP but if you are hosting your website on a shared hosting platform, it probably won't be in your price range.
Just to play around a bit, beta is free.
reddit stole my backticks!! ;) 
Just commented on your gist, then saw this thread. I recently pushed (a very early) sort of "add-on" to net/http that does this (I don't want to call it a framework, cause it really isn't one). The name could use a lot of work, but I already have some basic middleware written. Anyway, take a look if you like: https://github.com/stevan/httpapp
hi, the name gorm already exists, but in the java land: https://github.com/spring-projects/grails-data-mapping/
Gooogle GoLang. Please, get the *fucking name right.* Goddammit.
OMG!!! Yes
[**@nperson**](https://twitter.com/nperson): &gt;[2013-10-30 14:10:02 UTC](https://twitter.com/nperson/status/395553183201628160) &gt;Didn't know [@bitbucket](https://twitter.com/bitbucket) was using [#golang](https://twitter.com/search?q=%23golang). [*pic.twitter.com*](http://pbs.twimg.com/media/BX1Jhj7CEAAJ-Tq.png) [^[Imgur]](http://i.imgur.com/gJ6jRoE.png) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/1pjn0k%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://www.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Because he was an asshat about it. 
You're right, I went for absolute minimum so didn't want to get into sandboxing. Probably should have highlighted it in the post - thanks for pointing it out. There's nothing else on the server - so it's laziness rather than bravery
Because I fucked up big time, thanks for pointing it out, sorted now
Curious, in the case of A how would you handle upstream changes that you would like to incorporate into your fork? And fork might be the wrong word here, it's more of a mirror of upstream with my changes if need be. 
"Reveals" Oh, the scandal! 
:)
I can't tell if you're trolling. I know the language is called 'Go', but seriously I never search for 'go'. It's always 'golang'. I think this is a common enough practice that the Go zealots should relax is someone says GoLang instead of Go.
Well to be fair, "Go" is probably the worst branding I've seen since ".NET" You'd think that a company that runs a search engine could have chosen a name less likely to generate spurious results.
Actually I don't really care about this, maybe because I have never used java... also because it is really hard to find one easy to remember and no one used it before. I guess I did not break any laws, yes? ;)
I suppose we should see an interesting blog post about it soon.
I hadn't considered that. Thanks!
You should check out [my bulk branch of lib/pq](https://github.com/olt/libpq/tree/bulk). Then change: insert into test (gopher_id, created) values ($1, $2) to: COPY test (gopher_id, created) FROM STDIN and (hopefully) enjoy a 10x performance boost. You should get the best performance with a single *gopher* and a table that was TRUNCATED or CREATEd in the same transaction. Please leave any comments here or https://github.com/lib/pq/issues/74
you means get the type? try reflect. typ = reflect.TypeOf(employee) reflect.New(typ).Elem() // a new employee
I believe it's used to show the current value of the employee variable after `Copy(&amp;user, &amp;employee)`. It's not Go code and should be in a comment.
&gt; Some readers of this blog will just think of me as that guy that complains about the Go language a lot. I complain because I care. Keep it up, that's the best kind of feedback. &gt; logger = loggo.GetLogger("project.area") Shouldn't that be a ":=" instead of "="?
I have one directory in my gopath: $HOME/gocode ($HOME/go is where Go itself lives). All my projects are stored on github or bitbucket so I work in the appropriate directory (e.g. $GOPATH/src/github.com/BigKRex/myproject). Any dependencies also end up in that tree. Downside of this is you get one set of packages for all projects, but that hasn't caused a problem for me yet.
Dude thanks. I'll look at this today.
The GOPATH should only be set to your current workspace. I'd highly recommend using Kenneth Reitz's `autoenv`. I also wrote this little helper if you happen to use the Fish shell: https://github.com/zackkitzmiller/gofish
You should (re)read this doc from the golang site: http://golang.org/doc/code.html I suggest reading through the whole thing. (no skimming or skipping around) It explains the GOPATH env variable, how your workspace should look, how your packages fit together, etc.
I'm a little late to the game, but if you happen to use the fish shell, I wrote `gofish` which is basically virtualenvwrapper for fish and go. Could be ported to bash easily. https://github.com/zackkitzmiller/gofish
I use make files to set the GOPATH to the current project directory prior executing any go commands for my go projects. https://github.com/creamdog/golang.skeleton/blob/master/makefile
I've been using [goproj](https://github.com/divoxx/goproj) for a while now and it helps with this. Though I'd suggest having a firm grasp on the history of GOPATH before you use a tool like this, just to avoid any possible confusion.
This video is a helpful introduction to setting up a Go workspace: http://www.youtube.com/watch?v=XCsL89YtqCs If I care about repeatable builds and capturing dependencies I set $GOPATH in my project directory and check the deps into revision control.
GOPATH has similar workspace concept as virtualenv. 
A few comments: * Make the example in the README a runnable program that you can copy-paste. Right now the second half of the code isn't in any function, let alone main() * Make clear what happens with nested structs (they are copied too) * Make clear what happens with pointers (the original and copy both point to the same address) * err is unused * go fmt http://play.golang.org/p/SzxuRu2OPN
Ditto; mine is `GOPATH=$HOME`. No problems with this, although I would probably use different gopaths if I had, e.g., some work project with dependencies that needed to be isolated.
Thanks man, I am moving them now. Is there an example of passing a db handler? It appears that using a closure is the way to go? Is that correct?
Where do you put the non-GO files? For example, in a complex web project I'll have a Makefile that builds a .deb file, the DEBIAN directory and its config files, various notes files, scripts to install into /etc/init, etc. Do these just live inside the src/github.com/whatever source directory? Does the Makefile pull the built binary from ../../bin/whatever?
If they're app specific scripts/config/note files files then it makes sense to put them on the src/github.com/myapp/ directory. The thing to remember is /src/ isn't the source files for a *single app*. It's where your sources for different apps live. e.g. Two different apps and it depends which one you install. bin/ ... pkg/ ... src/ code.google.com/p/go.example/ hello/ hello.go # command source newmath/ sqrt.go # package source github.com/user/ hello/ hello.go # command source newmath/ sqrt.go # package source
Please update your blog with your results.
Awesome, going to use it!
The Makefile should probably *install* the go binaries and then pull them from bin/ That's iff the Go project is logically seperate from the rest of your project. If you consider the Go project to be a dependency, in a sense, then yes, it should probably be separate.
What happens when you put several paths in $GOPATH?
For the first three of those, I'd remind the author that the [testing package](http://golang.org/pkg/testing/) has a lot of support for examples that are tested at test time to work as documented. Don't just write examples... test them!
Olt, I'm wondering what you would consider a valid test. Here is the ground work for something. https://gist.github.com/jfolkins/de2fb1f792b21845e2f0 Do you want to have it create a large string? Cat a file into STDIN? Adding to the gist would be helpful for what you envision. Thanks
How hard would it be to implement a [render() like PhantomJS has](https://github.com/ariya/phantomjs/wiki/Screen-Capture), to create screenshots of web page elements?
These are really good. I hope they keep coming.
Not hard at all. The WebKitGTK+ API function is http://webkitgtk.org/reference/webkit2gtk/stable/WebKitWebView.html#webkit-web-view-get-snapshot. I would love a patch adding that functionality to go-webkit2 (and https://github.com/sourcegraph/webloop) if you are interested. Otherwise, if you want to get notified when I add it, just post an issue over at https://github.com/sourcegraph/go-webkit2/issues.
I'll post the issue but will also try my hand at implementing that, thanks!
Awesome. I'm happy to help however I can.
Actually, I think README is README, not a program, it is a place let others know the package and usage quickly. If you want to see how it is going? checkout the tests, sources code, or try it in your local. // err is unused. yes, this is a problem. // go fmt? Are you serious to use go fmt to format a document? ;) but yes, the code is already formatted with go fmt.
normally this is at the top of the file in a var block, so normally: var logger = loggo.GetLogger("project.area")
We use the following in Juju: Since we use gocheck, we have setup and tear down... --- package testbase import ( "fmt" "time" gc "launchpad.net/gocheck" "launchpad.net/loggo" ) // LoggingSuite redirects the juju logger to the test logger // when embedded in a gocheck suite type. type LoggingSuite struct { CleanupSuite } type gocheckWriter struct { c *gc.C } func (w *gocheckWriter) Write(level loggo.Level, module, filename string, line int, timestamp time.Time, message string) { // Magic calldepth value... w.c.Output(3, fmt.Sprintf("%s %s %s", level, module, message)) } func (t *LoggingSuite) SetUpSuite(c *gc.C) { t.CleanupSuite.SetUpSuite(c) t.setUp(c) t.AddSuiteCleanup(func(*gc.C) { loggo.ResetLoggers() loggo.ResetWriters() }) } func (t *LoggingSuite) SetUpTest(c *gc.C) { t.CleanupSuite.SetUpTest(c) t.setUp(c) } func (t *LoggingSuite) setUp(c *gc.C) { loggo.ResetWriters() loggo.ReplaceDefaultWriter(&amp;gocheckWriter{c}) loggo.ResetLoggers() loggo.GetLogger("juju").SetLogLevel(loggo.DEBUG) } 
Am enjoying these. Thanks pheelicks!
To be even more exact it's similar to PYTHONPATH.
My understanding is that [HyperLogLog](http://godoc.org/github.com/eclesh/hyperloglog) is more accurate at cardinality estimation than bloom filters. See: https://github.com/echen/streaming-simulations/wiki/Cardinality-Estimation%3A-Bloom-Filter-vs.-HyperLogLog Is there a reason to use this over HyperLogLog?
I think it's sad that the current implementation of the Go compiler doesn't perform any of the really useful optimizations. Given that any generic code in Go heavily depends on procedural reflection (which I *don't* see as a bad thing), there's an awful lot of low hanging performance fruit to be gained by optimistic inlining, inter-procedural control flow and data flow info propagation, and specializing the inlined routines.
This is not necessarily true. I have only one gopath location and it works just fine for me. You can use gopath to segregate your various workspaces but it's perfectly fine to have just one workspace with all the code in it.
What is the cardinality of a stream
Please enlighten me. There are 10 gophers and each gopher doing 100,000 for loop entries. So the total is 1 million entries. How do you still get performance? Shouldnt the program need to divide the entries into 10, that is to say 10,000 for each gopher?
Number of unique values seen. The only perfectly precise way of determining it is to store every value seen in a set, which obviously becomes difficult to impossible for streams with a high number of unique values (high cardinality). Therefore probabilistic algorithms like HyperLogLog and bloom filters are very important for data stream analysis. Edit: Have some links to resources! * The mathematical definition: http://en.wikipedia.org/wiki/Cardinality * The http://en.wikipedia.org/wiki/Cardinality_(SQL_statements) page explains it in terms that are easy to understand if you know SQL.
You can have 1 gopher operating on 1 thread, inserting 1,000,000 records. Or you can have 10 gophers operating on 1 thread each, for a total of 10 threads, inserting 100,000 records a piece. 10 gophers are working in parallel. That is why the performance is better. I am trying to work through a test using /u/olt 's suggestions. Does this help? 
Thank you. That was very helpful. 
Thanks. However your non-goroutine has 100,000 loops. And your goroutine version has 10 gophers each has 100,000. So that becomes 1 million. So former version only has 100,000 hwever the latter hsa 1 million even though its on separate light weight thread.
Oh, I see. Typo. My bad and thanks.
Thanks.
WebLoop is built on [go-webkit2](https://sourcegraph.com/github.com/sourcegraph/go-webkit2/readme) ([recent reddit post] (http://www.reddit.com/r/golang/comments/1pig1q/gowebkit2_webkitgtk_v2_bindings_for_go_wheadless/)) and exposes a more Go-idiomatic API for WebKit. It includes an [http.Handler StaticRenderer](https://sourcegraph.com/github.com/sourcegraph/webloop/symbols/go/github.com/sourcegraph/webloop/StaticRenderer:type) that you can use to transparently render static HTML from a dynamic app, for search engines, social previews, etc. There's an example application of this using an AngularJS app. There's also an included [static-reverse-proxy](https://sourcegraph.com/github.com/sourcegraph/webloop/tree/master/cmd/static-reverse-proxy/static_reverse_proxy.go) program that reverse proxies a dynamic app, returning statically rendered HTML. We use it to support search engine crawlers at https://sourcegraph.com. See the [README](https://sourcegraph.com/github.com/sourcegraph/webloop/readme) for usage info. I'd love to get feedback on this library and get other folks involved!
COPY is indeed fast. Nice work /u/olt! Anyone else reading this, please know, the COPY command isn't the most intelligent thing in the world so be careful :-) Single gopher inserting 1M records. $ go build test_copy.go $ ./test_copy Gopher Id: 0 || StartTime: 2013-11-01 15:30:14.84791841 -0700 PDT Gopher Id: 0 || StopTime: 2013-11-01 15:30:18.356639398 -0700 PDT $ testdb=# select count(created) from test; count --------- 1000000 (1 row) testdb=# 
Is there a way to generate screenshots of pages?
Not currently, but it would be a great addition. It is possible to do in the WebKitGTK+ v2 API. 2 other people have said they want screenshot capabilities, too: https://twitter.com/ymotongpoo/status/396397802160275456 https://github.com/sourcegraph/go-webkit2/issues/3
There's an implementation of HyperLogLog in https://github.com/dustin/go-probably . 
"Go" is only for spoken language; always use "golang" in writing - especially indexable text.
Not that I personally think it is a big deal, but there is already a pretty well known Gorm library for Groovy/Grails http://grails.org/doc/latest/guide/GORM.html My intentions are more of a 'heads up' than a critique. Great looking library. 
Is there a way to shut off pluralization? I just started looking at the source, but didn't see it right away.
Nice, I was about to play with Gorm + Revel bundle!
That has been the discussion, not xslt. I removed the binaries and changed the code and post. 
There's also someone working on a pure-Go XSLT library - https://github.com/jbowtie/ratago Seems to work fine for simple scripts though judging by the TODO list it still needs some work before it can be used for anything complicated. Edit: It uses Gokogiri, which is a cgo wrapper for libxml2. So not quite pure Go.
Which is not supported yet, but planning, should be supported in the following few days.
Hope you could enjoy it!
Just updated the project, now it support database postgres, mysql and sqlite3.
I'm not the OP but we do compilation in our server environments because most of us develop on Macs but we have to link against native libs and cross-compiling cgo doesn't really work. We compile once though on a "build server" and move the binary along to dev, staging, prod with Ansible.
Hey guys, if anybody has any questions or comments about what we're doing, please let me know - I am the author of the blog post.
Most of the puppet work was to setup internal conventions for deploying Go apps, since we've never done it. 
Typically the problem has been the reverse: the version of Linux we're running (Ubuntu Lucid) is so old we have to build the newer versions of software that's more readily available in homebrew. We're running most of our new services on Precise now, so this is lessened, although I think a new LTS is due out in the spring? We're generally aware of this ahead of time, and we iron it all out when we deploy to dev.
My bad on the "go fmt" point. Copying from Github to play.golang.org lost some of the indentation. Go choosing tabs instead of spaces is easily the worst thing about the language. :) My point on the README was simply that it looks like a runnable code fragment, but it isn't. If it's meant to be a document, that's fine, but break the code fragments up with prose. Your README in gorm is a great example.
/u/olt my comment wasn't directed at your code. It was directed at the Postgres COPY command. There are some gotchas when dealing with COPY and I just didn't want devs to see something fast and think it is perfect for their use case is all. http://www.postgresql.org/docs/9.3/static/sql-copy.html Thanks again for your work! 
&gt; although I think a new LTS is due out in the spring? Yup: 14.04 LTS (Trusty Tahr).
&gt; Why Redis? &gt; They say it's fast. They say it's stable. They say it's simple to model your data. They say it's persistent. They say it requires zero configuration. They say it's basically memcached plus more. Out of the box you get the basic key/value storage just like memcached in addition to: hashes, sets, sorted sets, lua scripting, atomic counters, and a boat-load of other convenient functions. What they don't say is the huge iowait which happens when writing to disk if your db size is too large
I was reading about this earlier, it's exciting to see GitHub really starting to use Go in production.
I think the point was - it's a native executable, deployment should just be a file copy. It sounds like it's not really a question of deployment so much as building for production that was the issue, which makes more sense.
If this mirrors python Requests, fantastic...and it looks very similar.
Cute!
See also http://www.reddit.com/r/golang/comments/1pvlqz/keyvalue_logs_in_go/
Unfortunatly the live playground does not seems to work at the moment. * http://play.influxdb.org/ I can't find any picture of the `Built in explorer`. It would be great if someone could post few of them.
play is back up now. Although the interface you see is very basic and you won't be able to do much until you write some data
It's written in Go. [here is the source](https://github.com/influxdb/influxdb)
Except they didn't.
I'm curious about performance characteristics of this thing. How many writes per node it can do? How effectively disc storage is used (amount of disc space required relative to amount of useful information stored in this space)?
I need this for more than one of my projects, so I figured I'd break it out into a library and document it in case anyone else wants to build any low-level virtual hosting stuff themselves. Questions/feedback are appreciated.
Possible to do this now with `db.SingularTable(true)`
My understanding is that, there is an assumption that most developers know the technical know how of a virtual host, because I dont. Can you explain exactly where does this piece of software sit in the server? Kind a looks like that this acts like a reverse proxy or something. Not sure though. Thanks.
You've basically got it. You can configure multiple domains to point to the same IP address. In my case, I point both inconshreveable.com and ngrok.com to the same IP: $ host ngrok.com ngrok.com has address 173.255.204.192 $ host inconshreveable.com inconshreveable.com has address 173.255.204.192 So when the program running on 173.255.204.192 receives new data on port 80 (the standard HTTP port), how does it know which website to serve? The answer is that you can tell by looking at the headers of the HTTP request. Here's one I made: GET /articles.html HTTP/1.1 User-Agent: curl/7.22.0 Host: inconshreveable.com Accept: */* So the web server sucks out the first part of a request until it finds a "Host" header and says, "Ah! You want me to service a request to "inconshreveable.com". So it looks in the configuration files you started it with for instructions on what to do when someone requests inconshreveable.com (read the file out of a directory in the file system, reverse proxy a different server, send a 301 redirect, etc). If it doesn't find a configuration for that Host header it just returns a 404. It turns out a couple other protocols support this same concept of letting a single IP/Port handle requests for completely different domains by including the name of the domain you're trying to get to in the request. TLS does (via an extension), as well as SMTP (for delivering mail) and SIP (for establishing media sessions). There are probably others. Some notable ones don't, like SSH. This library is a basic building block for supporting that behavior. Basically you pass it a connection and the protocol you are running on that connection. It then reads the first part of the connection out to determine the name of the intended destination and hands it back to you along with a connection object that *appears as if nothing had been read from it* (since the library has to read bytes off of your connection in order to determine the name).
Looks cool, I would love to poke around at a possible graphite replacement. Would it make sense to build a drop-in replacement for statsd that talks to influxdb instead of graphite? I'm also curious about how easy it is to backup influxdb vs graphite's whisper files. Cool project!
it doesn't use the same type of file format. Under the hood it's LevelDB. The pattern for that would be to set up continuous queries that perform the type of rollups you want and have the db clear out old raw data every evening.
it's all LevelDB under the hood so you'd have to back up those files. The other option is to set up a cluster (once we have that released) and have a replication factor of 2 or more so you can replace downed nodes. For statsd we'll definitely want to create a backend that talks to InfluxDB. Statsd actually lets you post to multiple backends.
Somewhat relevant... https://github.com/oguzbilgic/dondur
Interesting data: how popular are packages? https://sourcegraph.com/code.google.com/p/go/tree Almost no-one uses complex numbers?
Saw the creator give a talk on this tonight-- looking forward to trying it out a little bit tomorrow. He mentioned that they're looking into allowing private repo access in the future, which will be awesome.
Is there a link to the video of the talk ?
(Sourcegraph creator here) It's possible that many Go packages that use math/complex use cgo with a C library that we don't have loaded. In that case, the package and all of its downstream consumers wouldn't be counted in that tally. If that's the case, just let us know which Ubuntu package contains the requisite C library and we'll install it on our build VMs.
It would be nice to have this search feature available through vim via gocode.
Why not? 
"pythonista" just sounds like you're making fun of them, like a "barista" at starbucks. One is a python developer, the other makes coffee drinks, there's no reason to get fancy.
That's the name the python community chose, and I think it's awesome. E.g: http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html 
Not yet, I'll add it at some point soon
thanks ! :)
Appreciated.
Related: a guy commented on a question of mine on StackOverflow before with what implements the interface I was asking about, and linked to the [command-line tool he made called Implements](https://github.com/dominikh/implements)
Check out vim-tmuxify, its great for automating the kill/recompile/run stuff: https://github.com/mhinz/vim-tmuxify
On Slide 6: "check out Guido's mypy". Who are you referring to? Lead mypy dev is Jukka Lehtosalo, see http://www.mypy-lang.org/about.html. Also, when talking about statically typed Python, Cython deserves the first mention.
A few weeks ago I wrote a web service. Like OP I used to have short feedback loops in PHP, usually to check for typos bugs or unintended behaviour. With the project I wrote pretty much the whole code (6 files of several hundred lines each) without compiling or testing. In the last hour I compiled, fixed a few typos, tested, found one issue, and deployed. It's really nice going back to a compiled language where the syntax makes sense and the compiler catches the typos.
A very common pattern in Python (at least for me) is storing dicts of objects. The Go version, maps of structs, looks similar, but the way maps work makes this strategy hurt. Here's an example I wrote today for a small data-mining project. This is just my second Go program, so any tips are welcome. I was shocked that students[alt_id].foreign += 1 doesn't work. package main import ( "fmt" "io" "os" "neilc/mapreader" // like csv.DictReader in Python "encoding/csv" ) // silently ignoring missed keys sucks func get(this map[string]string, key string) string { value, ok := this[key] if !ok { panic(fmt.Sprintf("Key '%s' not found.", key)) } return value } type Student struct { alt_id string last string first string foreign int } func main() { students := make(map[string]Student) for _, name := range []string{ "admit200740.csv", "admit200840.csv", "admit200810.csv", "admit200910.csv", "admit200940.csv", "admit201010.csv", "admit201040.csv", "admit201110.csv", "admit201140.csv", "admit201210.csv", "admit201240.csv", "admit201310.csv", "admit201340.csv", } { fmt.Println("Reading", name) file, err := os.Open(name) if err != nil { panic(err) } defer file.Close() reader, err := mapreader.NewReaderHeader(csv.NewReader(file)) reader.Reader.TrailingComma = true for { // This is much worse than using an iterator. record, err := reader.Read() if err == io.EOF { break } else if err != nil { panic(err) } else { alt_id := get(record, "ID") student, found := students[alt_id] if !found { students[alt_id] = Student{ alt_id, get(record, "LAST"), get(record, "FIRST"), 0, } student = students[alt_id] } if get(record, "RESD") == "F" { // this is ridiculous. student.foreign += 1 students[alt_id] = student } } } } out, err := os.Create("foreign.csv") if err != nil { panic(err) } defer out.Close() writer := csv.NewWriter(out) // This sucks! Why is csv.Writer buffered? Let me decide that! // And why isn't that documented? Why does the buffering implementation // suck? Is the below code really what I must write? defer func () { writer.Flush() if err := writer.Error(); err != nil { panic(err) } }() writer.Write([]string{"AltId", "Last", "First", "Foreign"}) for alt_id, student := range students { result := []string{alt_id, student.last, student.first} if student.foreign &gt; 0 { result = append(result, "Y") } else { result = append(result, "N") } writer.Write(result) } } 
Yes, implements is awesome for local code. There's also [Pythia](https://github.com/fzipp/pythia), which is a frontend for [Go Oracle](https://groups.google.com/forum/#!topic/golang-nuts/CwdIJZs6Tfc). We use [go/types](http://godoc.org/code.google.com/p/go.tools/go/types) to perform the type analysis you see on Sourcegraph, which Go Oracle is also based on. 
(Sourcegraph creator here) We'd love to make a command-line util that exposes this and other info. We're really strapped for time/resources right now, but we have a fairly straightforward REST API, albeit currently undocumented, that someone could use to build this tool. If anyone's interested, post an issue over at https://github.com/sourcegraph/sourcegraph.com/issues or email us and we will post API info and help out.
(Sourcegraph creator here) We'd love to add this, but we are super busy. If anyone wants to use our REST API (currently undocumented) to add this feature to gocode, post an issue over at https://github.com/sourcegraph/sourcegraph.com/issues or email us and we'll help out.
Definitely just write tests, and automate all the things.
I guess you could `type void struct{}` and then use `map[string]void`.
Yeah, but you should still have to write m["hi"] = void{} or funny enough: m["hi"] = m["hi] But don't tell anyone I said that was nice code :-)
Thanks! I guess maps really are the way to go then.
Yup, I guess maps it is then.
There are different sets implementations out there, backed by hash maps, trees, etc. Depending on the amount of objects and usage different data structures will provide different benefits. Another option is to use bloom filters, which have limitations but it's much more compact.
When sharing code, [link to the Go Playground](http://play.golang.org/p/K1zlxhG2J9).
I'm interested in seeing any quick responses to the issues you point out in your comments. I'm just getting my feet wet with Go as well.
[Make a class](http://play.golang.org/p/KeyUW2wRNa).
Values in maps are not addressable. If you want to modify them use pointers.
My workflow when using Go: 1. Implement some feature in the project I'm experimenting with far less effort than expected and that works as soon as I fix all the compilation errors. 2. Spend far too much time talking to my colleagues about how fucking amazingly easy and good go is. All my productivity increase is eaten by being amazed.
Speaking of vim + go, if you're not using gocode and it's associated vim scripts I highly recommend them. CTRL-X CTRL-O starts omnicompletion and lets you select from possible methods, variables, etc on a type along with their signature. It helps me dive head first into a program without switching to the package documentation nearly as much. https://github.com/nsf/gocode
I use inotifywait to watch the directory for changes to Go source files, then recompile automatically. Saves me a lot of jumping around
Thanks!
It depends. If N is small, encoding the objects in a O(N) data structure like a linear array is probably faster than allocating a hash map. 
I make do with gotags https://github.com/jstemmer/gotags But gocode looks awesome
Given that the code is on github, perhaps you should open a bug ticket?
I couldn't find anything like this, so I took a few hours to write one myself. It seemed like an obvious "need" for sql drivers and ORMs. It's only for MySQL and not very flexible, but it beats writing all those structs by hand.
There's lots of ways to do this. Your channel could be of struct{resultTyp; error} And you could check at every read. Or you could implement a Next method on your Reader returning resultTyp and error.
Multi-author virtual host based web servers would require separate GOPATH's
Hi Evmar, can you elaborate more on how that is an deadlock? It locks both for s and t, does the checking and then unlocks them. I would be happy if you can give more details. Regards - fatih
Looks handy. Bookmarked it.
[Gom](https://github.com/mattn/gom) seems to be the most active dependency manager and highest rated on GitHub as of the last time I checked. I've been using it for quite a while now - mattn is a very smart guy (check out his other repos). If you're looking for things you can *package* with something like Gom, just look at GitHub and Bitbucket in general (and google code). Most of these dependency managers do the exact same thing as go-get/go-install and so you shouldn't have any issue using anything those commands support.
Well, Lisp essentially does.
I think i am looking for two core problem groups. 1.) Versioning and/or freezing - Many of the go PMs out there handle this well, in varying ways. `go get` seems to be a pretty great tool to begin with, and version/freezing is just a slight extension ontop of it. #1 seems to be an easily and common problem to solve. 2.) Safety from package authors - This is one that concerns me a bit more. Perhaps Go will be different (i wouldn't know), but in the past my experience with other languages and projects is that owners of projects don't feel that their repo is part of a dependency chain. They have varying opinions of how their repo should be managed (what master really means, etc), and they move/rename/etc their projects without issue. Solving #2 seems to be more complex, and a central package repo seems to be the only solution that i can see, like pip/npm/etc. GoNuts uses this method, and i like it, but the project age/etc worries me. Another issue with this is the conceptual divide between Golang's `go get` and the GoNuts style of project hosting. I can understand, and sympathize (possibly even agree) with peoples desire to stay away from a central PIP style repo, in favor of the style that is *built in* to the language. At any rate, #1 is my top priority, and a solid solution for that is my primary concern. Thanks for the info regarding Gom, with all of these duplications it's at least nice to know what is popular, even if i don't agree with it hah 
What? Google neither created, not named the language. I'm not sure what else there is to say about that.
&gt; Go, also called golang, is a programming language initially developed at Google[6] in 2007 http://en.m.wikipedia.org/wiki/Go_(programming_language) Edit: Admit you were wrong! :)
I'm not aware of one?
Good work! Is it possible to encode / decode interface{}?
Thanks. It's really too bad channels can't return multiple values like functions. Then there's be a nice obvious way. I started with the struct of result and error, but I didn't like it. I ended up passing in an error channel, which can be checked after the loop ends to see if any error other than os.EOF happened. Moreover, none of the suggested approaches (or the one I adopted) force me to check for error.
Thanks for your post, it's great! It wouldn't be fabulous to have something like SQLAlchemy Core? Most of the projects need connection pooling, transactions and that sort of things but I find using an ORM excessive for most of the projects. Shall we start a clone of SQLAlchemy Core? :D
*Sql databases Not trying to be snarky, but there is a lot out there that's beyond the world of SQL.
True that. I hadn't even thought about NoSQL, but SQL is definitely what comes to mind when most people think of databases.
Thanks! SQLAlchemy is a very cool library. I'd barely ever used it but picked it up for something a while ago and it proved useful in minutes. Maybe someday there will be a GoSQLAlchemy :D
not sure if Bank of america uses Go or not. Today just saw when I tried to login. https://secure.bankofamerica.com/login/sign-in/signOn.go
[Cowboy gopher](https://rawgithub.com/ianremmler/atxgolang-logo/master/atxgolang.svg)
Sorry about the resubmit. The previous one I misspelled cityhash so had to update it. Also sincere apologies to the folks who upvoted this earlier. Hopefully you will upvote this again. :)
Nice! 
Go's birthday was the day before mine? Cool.
Exactly.. I'm becoming a god damn Go-evangelist to my friends..
You mean someone having coding with it since its inception ? Actually, the blog authors probably did.
Why you didn't use templates for generating structs? then you can deliver templates for common orm's...
I am not gonna tell the extension of the interface files to the D language.
This is unreadable on my phone. Firefox 25 on galaxy s4
What? Where in that things does it say that **Google** named the language? or that **Google** created the language?
I've been using Go for just about 1 year. I had initially dismissed it when I first heard about it a couple years ago, because it didn't seem very ambitious. However, it has won me over, at least for now. It still doesn't seem that ambitious (as opposed to Haskell, for example) but that's OK. It is all the little things that add up to a nice and pleasant development experience. I was recently in some discussions about C++, and there are so many dark corners in that language, I would not seriously consider it for new projects... ever. There are so many different paradigms for how to use C++, and there are more with each new revision of the language. And there is continued, fervent debate even among experts for how to use C++, and what features of it to avoid. In contrast, with Go, I haven't found any dark and nasty corners to the language. Sure, there are things that can (and hopefully will) be improved, but there's nothing major that I'd say to a new programmer: "Hey, feature X of Go, avoid that at all costs." Everything fits together well, and that's what impresses me most about it. At any rate, on an anniversary like this, it is time for me to say "Thank You" to: the core development team, to all the great people making useful libraries and applications, and to the community as a whole.
I love the concept of Go, but I'm still searching for a project to use it with. Heh. All my web stuff now is python. 
happy birthday to you!!
I've found some odd things that I'm on the fence about. Sometimes I find myself making a lot of effort to make sure all my return statements are unadorned ('blank') due to pre-initialized return parameters. This results in using it in places where I haven't implemented such functionality, so I get the occasional compile-error hiccup. Sometimes I'm writing functions such that the last parameter returned is the `err` value, but other times it's a struct field. Another compile-error hiccup. Another one is returning one of the function parameters, ie: func Blah(locale Locale) (locale Locale) {} I can't do this because Go tries to initialize the return variable *but it already exists* due to it being a parameter. This comes from the first issue I mentioned above.
Hopefully I'm not just reading too much into a generic example, but I don't think you should name your return parameters if the name doesn't add any documentation. I'm mainly surprised that you use named returns frequently enough to make it a habit; nobody else seems to.
&gt; I'm mainly surprised that you use named returns frequently enough to make it a habit; nobody else seems to. I used named returns a lot. In ihsw's example, I'd probably do something like this: func Blah(locale Locale) (updated_locale Locale) {} It might be 'cancelled', 'revised', or some other prefix to correspond to what Blah() actually does.
Man, gorm gets better and better every day! Great job, Jinzhu!
Red October sounds interesting.
Heh, I had no idea CloudFlare was so into Go. I recently started using them, and wasn't terribly impressed by the suggested Perl script for Dynamic DNS updates so I [wrote my own in Go](https://github.com/retzkek/cloudflare-ddns).
I'm curious what the advantages/disadvantages of this are vs Gorp https://github.com/coopernurse/gorp
Be honestly, I haven't use gorp but tried hood, what I know about gorp is from it's README. First, here is those reasons why I don't use gorp but hood. * Don't like gorp's query API. * Have to set CreatedAt, UpdatedAt in every struct's PreInsert, PreUpdate. (Which is so common used when writing a website) * Hood looks more promising from its README... XD So I start to use hood. But use it more, got more problems: * Can't find one record * Have to do type covert each time when use record's id * Seems Developer don't response issues or pull requests in github * Another big issue. goroutine UN-safety! You have to create a new instance in each goroutine. The last issue is the immediate cause that I write a new orm. So I start to build gorm aims to fix above issues I got and based on rails's philosophy. &gt; Ruby on Rails is intended to emphasize Convention over Configuration (CoC), and the rapid development principle of Don't Repeat Yourself (DRY). Here is a compare, how gorm reduce more than 20 lines codes written with hood to 3 lines. http://i.imgur.com/OeF3STZ.png?1 (the code is form a real project, but optimized to be a example, it is means, if user have never subscribed a service, subscribe it, if already unsubscribed it, change the state to subscribed)
That's really not idiomatic. You should only name your return values when it's for documentation purposes. You shouldn't put underscores in your variable names. You should avoid stutter. No: `(updated_locale Locale)` Yes: `(updated Locale)`
That's right, I have! :-)
More discussion: https://news.ycombinator.com/item?id=6713295
Sounds like a good idea in the first place, but there remain some caveats. How do they make sure that they don't miss any features that were present in Java? Go is still a changing language. How do they make sure they have some sort of continuity?
net/rpc is awesome if you are only doing Go &lt;--&gt; Go communication. No need to do anything different. If you ever intend for there to be other languages at the other end, you've got to use something else.
if both programs are written in Go, I would use channels over a network. http://jan.newmarch.name/go/channel/chapter-channel.html
Is net/chan still in Go? The page seems to suggest that it was removed in 1.0 and that we should not use it. Do you think I will be in trouble if I use the old API? I do like the idea of just using channels. It is much easier for me to think about channels than rpc.
Yeah, its just Go to Go. The external user interface is REST.
How about writing a proxy server in go, then run the python app and let the golang program proxy connections to it. User &lt;------&gt;[go lang proxy] &lt;---------&gt;[python app] **bonus** run multiple instances of the python app and make go multiplex connections to it, so you'll be able to use all your cores in python.
Thanks for all the hard work, Andrew. Go is a pleasure. If I could just make one request - more videos/blog posts, please :) 
Indeed, it was removed. There is a similar package called [fatchan](https://github.com/kylelemons/fatchan), but no "real" (supports everything, including sending closures) network channel facility.
Not with those actually but we're using cihub's seelog quite successfully.
Depending on what kind of work you're doing, you could use ZMQ, AMQP (e.g. RabbitMQ) or something like that, if you just need message parsing. One advantage of using a queuing system is that one server can fail and you can easily add more servers, again depending on what you're doing. There's also GroupCache (https://github.com/golang/groupcache), if the stuff you need to do is something that would fit that model. 
I have a question on gorm though: why is that the Id column has to be an int64 ? In my case, for example, I would like to set the Id column as an uuid. In gorp I can do this by saying that the Id column is a string and everything will work as expected. So what should I do here ? (note that I'm just playing around with gorm, so I don't know if filing an issue on Github or...) Edit: typo
Do I have to subscribe or is there an archive?
Hi Mirakoolix, we're working on an archive, but at the moment you would have to subscribe. Andreas
Good idea! Nobody uses gcc+java and gcc+go is on the rise.
That's wrong. net/rpc can have custom codecs (via the four-method interface that you have to implement), like json-rpc (which is already included in standard library) or protobuf, which means you can mix other languages to. 
I tried glog, but it has his own awkwardness, like defining the output of the log file via a flag. I think glog is just a replacement for google's internal logger binary and therefore it's not go-idiomatic (also the source code is not open source, see readme.md of glog) I don't know about loggo or golog, but eventually I've decide to try go-logging. Mainly because it's still supported, has leveled logs, you can defined custom formatter, can have multiple outputs, like stderr, file and syslog at once (which is nicely handled via go-logging's api). I like it. 
Here is an issue related this: https://github.com/jinzhu/gorm/issues/8 But as I replied, I don't see much advantages. You could do this also: type User struct { id int64 uuid string } Then you don't lose the ability to search with primary key, also quite convenient to search with uuid by doing this: // find record db.Where("uuid = ?", "xxxx").First(&amp;User{}) // find and update some columns, if not found, then create the record with those attributes db.Where(User{Uuid: "xxxx"}).Assign("age", 99).FirstOrCreate(&amp;User{}) // find and update some columns, if not found, initialize the struct with those attributes db.Where(User{Uuid: "xxxx"}).Assign(User{Age: 99, Email: "xxx@example.org"}).FirstOrInit(&amp;User{}) 
ZMQ does not fit into Go's idiomatic way of writing code. Also all the zmq libraries out there are not threadsafe and obsolete with lots of bugs. The amqp library is mature, but I would not recommend anyone to use zmq with go. You don't need it.
Yes, that's what I ended up doing. This means, however, that I'll have an extra column that I won't be using so, in my point of view, this is not really the way to go in my case. Aaanyways, it's a nice library, good job ! :-)
Working on it!
Use TCP with encoding/gob to start. Throw it behind a service interface. You'll discover the best protocol and pattern along the way. Don't commit too early. Have fun exploring. Don't sweat what the open source community will think about your early decisions. That will drive you crazy...
&gt; ZMQ does not into Go's idiomatic way of writing code. Could you expand on this a bit? I'm a go and a zmq newbie. I know zmq is not threadsafe but I worked around that by funneling all requests through a single goroutine using channels. The channel work seemed pretty idiomatic, IMO.
Regarding "no destructors/cleanups" in testing, you *can*, it's just not built in. You can use [gocheck](http://godoc.org/launchpad.net/gocheck). Or if you don't want the added dependency, and want plain old testing.T: https://github.com/axw/llgo/blob/master/llgo/utils_test.go#L34
I can't speak for the libraries you posted, but I have written my own logging library as a my first usage of go: https://github.com/demizer/go-elog, it allows setting multiple io streams as well as ansi color output. It's a drop in replacement for the standard library log package. It is also tested, but could probably use more tests.
Personally, I do json message passing over websockets - even go-to-go. Nice thing about that is then webapps can use the same interface in js. Less nice thing is message encoding / decoding, but you can abstract it away mostly. There is a nice websocket library provided by the go devs outside of the standard library.
nsq?
I tried glog. It worked fine. Also take a look at cloudflare's syslog wrapper.
Jinzhu, great work. Gorm is quickly become a really useful orm for go.
Nonsense. The two are not opposites. There are plenty of projects that are funded by Google, at least in part, are started by people employed by Google, hosted by Google, mostly developed on the premises of Google and where Google is mentioned in the open source license (Dart, for example). If you are arguing that these open source projects can not also be categorized as "Google projects", you are simply nitpicking. 
i dont think this change will happen this has happened in GCC nearly every year to replace java. Java was a default bootstrap language only because openjdk people used it to bootstrap. But this is no longer the case and gcj development is almost non-existent outside of code maintenance. Its a great project but openjdk is taking off. Gccgo however Ian is a little hesitant to want it to be a default bootstrap language though i think it would be a great idea. I reckon nothing will happen untill gcc 5.0 is in development.
glog is open source. It's just not a project open for contribution. You are free to use it according to its licence (Apache 2.0), such as forking it and modifying it however you wish (e.g. getting rid of the flags).
"The repository contains an open source version of the log package used inside Google. The master copy of the source lives inside Google, not here. The code in this repo is for export only and is not itself under development. Feature requests will be ignored." ^^ this lines makes it for me to be not open-source. With open-source I expect that it get's developed and supported to. They also don't let me contribute.
Yes! Meetups is already planned. We're going to add more specialized topics in the future
I wonder how this compares to the subcommand support that camlistore sorta utilizes. It'd be nice if one of these flag+ packages would "step up" and become the defacto. Sorta like web frameworks. There are a couple rigid, opinionated web frameworks, a few tiny wrappers around net/http or gorilla with almost no added value, and then a few hidden gems like go-restful. But yet web.go and revel seem to get all of the attention. A real shame. Especially Revel, MVC is so tired.
So what's the shit for creating a relatively simple, but dynamic, webpage? 
You can have one channel for results and one for errors. Or panic and catch the panics. But, yeah, I agree. 
I **just** released Martini, which is a layer on top of the http package that supports routing, middleware, and more! http://martini.codegangsta.io/
Author here. Came up with this architecture when I was developing my own web projects and thought it may be useful! Let me know if you have any questions.
Looks really promising! I'll definitely give it a spin.
Did you evaluate revel or beego, and if so how does this compare to those frameworks (besides being simpler)? http://robfig.github.io/revel/ https://github.com/astaxie/beego
Awesome framework you got here. Simple, and easy to use! Congrats
Whoa, exactly what I was looking for. I'm learning go and wrapping my head around some things, especially pointer/reference passing and I think this will help me a lot to make sure I'm doing things the right way. Thanks OP!
First, Martini looks awesome. Thank you for not hiding the standard `net/http` interface away. Though I'd still like to nitpick: seeing how `http.HandlerFunc` is just a kind of `http.Handler` why not support `Handler` itself? Sure, you could just wrap your `Handler` in a `HandlerFunc` and then use it, but it's even better if one doesn't have to do that. Other than that, again, I love how you both support traditional net/http handlers and simple ones like functions returning a string. That extends to your implementation of middleware too: I love how it can be either be of standard interface, or take martini's own `Context`. All in all, martini seems like a great framework. Keep it up!
I really like the look of this. There's some very clever API design going on here, and it's clearly taking advantage of Go's language features rather than just trying to be a clone of a framework from another language. I particularly like the service injection concept. Django forces every view function to take a request object and return a response object. Flask makes these optional, but then requires you to use global variables to access more information from the request. Martini attempts to resolve any arguments it sees by looking up their static type against a service directory. I think that's really clever. The way it allows you to stack up Handlers is neat too. Django does this with either globally applied middleware or per-view-function decorators, but there's something really neat about just taking a list of functions for things like authentication and "stacking" them on top of each other - or having that same function applied as middleware to every request using m.Use(func...). Using Context.Next() to allow that middleware to "wrap" a request (the equivalent of Django's process_request and process_response pair) is clever as well. Colour me impressed! (re-posted my comment from https://news.ycombinator.com/item?id=6731275 )
The type declaration grouping should be familiar to former Pascal programmers: http://en.wikipedia.org/wiki/Pascal_(programming_language)#Type_declarations
The stacking of middleware reminds me a bit of Express/connect in Node.js. It's really neat to write small reusable parts for your web app.
I tend to call the design 'non-intrusive'. Martini tries really hard not to not impose any part of it's API on your handlers. Services get injected by Martini, this makes all your handlers really flexible and testable. This framework is also not taking the MVC approach, it can be closely compared to connect/express.js in it's simplicity. Most of all Martini tries really hard to be complimentary to the Go way of doing things.
Dude, life is freaking great! Right?!
Yup, definitely inspired by the simplicity in the express/connect API design. Martini doesn't want to get in the way of you building stuff.
Almost like COBOL divisions/sections.
Great work, definitely something I will use for my next project.
The last status was https://groups.google.com/d/msg/golang-nuts/7R4lN2P2EY4/GWGwK2mkIVgJ (However, the "next few weeks" have elapsed)
I don't think they're stupid or curious.
Hey /u/codegangsta, Quick thought, I was on mobile initially and thought your project was neat. I put it on my "revisit" list. On my desktop, I went back to your site and clicked demo. I was expecting that it was going to be a demo web interface of some sort. Instead I got a lot of value out of your short and sweet video. I think it is really well done. My suggestion is to make the video visible in the body of the site, right from the onset. Don't hide it behind a link. The video converted me from the "potentially use" category into "must try" for my next project. It is a slick piece of marketing. Thanks for your work!
How would one skip a middleware func for some requests?
Very nice! I haven't fooled around with Go reflection yet and didn't know it offered that level of flexibility. Reminds me of Silex from PHP, given that they are both inspired (directly or indirectly) by Sinatra. Question: which editor/plugins are you using in the demo? I haven't done any Go hacking on the mac yet, and that setup looked nice.
I am using terminal vim and tmux. I have a vim keybinding to stop and restart the go program in the other tmux pane. I highly recommend tmux for a vim user, it is a huge boost in productivity.
I've been using vimux and vimux-golang for a few weeks, they are pretty handy for this sort of workflow.
Great article on profiling and general debugging! Is that a talk that is available somewhere? ^^^^^^^^^*Cumming...LOL
This is a great suggestion! I will look into pulling the video out into a more visible area. This launch was definitely a marketing experiment for me, it is interesting to see what components bring value to certain people. Your feedback is welcome. Stay tuned for more videos of that caliber.
The title refers to David Letterman's old "Stupid Pet Tricks" segment. 
I'm extremely new to go, but I figured it couldn't hurt to *ask*: How does your static file serving handle relative paths? if someone does a typical break-in attempt with ../../../ etc, what does martini do? Side: I love your setup in the demo video, have you written anything about it anywhere?
Right now the Static middleware is not safe in this regard. I just created an issue to fix it. https://github.com/codegangsta/martini/issues/37 Thanks for the feedback
FYI: This bug is fixed and now in master https://github.com/codegangsta/martini/commit/9ed873e1f12459c5cea35a3ff975f0a8c5925054
https://gobyexample.com (https://github.com/mmcgrana/gobyexample) comes in handy every now and then.
thanks for pointing out, added to the list!
1. The community isn't too hot on ORMs, and you cannot create new types at runtime so you can't ever write an ORM that can generate a struct suitable for a query, even given a complete understanding of the data model. Only `gorm` attempts migrations, but it's very young and imho it's far too opinionated and doesn't suit Go. If you are ok with SQL, I recommend using straight up `database/sql` with my `sqlx` package; use `gorp` if you must have more sophisticated data modelling, or `modl` if you are feeling adventurous. My views are still relatively well summed up here: http://jmoiron.net/blog/golang-orms/ 2. Unicode is incredibly well supported, but it doesn't have the depth of built-in encodings that Python does. That said, I think the overall unicode picture is way better than the mess of unicode in Python; the creators of utf-8 were involved in the creation of Go. The [go.text](https://code.google.com/p/go/source/browse/?repo=text#hg%2Fcldr) repos has some encoding support (including windows-1250 and ISO 8859-2) but I don't know if its use is documented. 3. Go's time.Time is pretty simplistic but it's also pretty good, if you give it the offsets it'l handle timezones for you. I don't have a ton of experience with it, there's not nearly the amt of convenience you get with pytz, but you could develop it as an add-on. 4. Not in stdlib because there's no standard hardware support for it. Don't know which library is the go-to. 5. No. 
Re: 2, Go is strongly biased towards UTF-8 because it was made by the creators of UTF-8. Also, you should basically always be using UTF-8 for everything anyway. Seriously, convert legacy stuff at the edges of your app if you have to, but many things that claim to support UTF-16 are broken (because of non-BMP characters), and UTF-32 is too inefficient, so there's basically only one encoding that works. Use it!
Nice! Another question; Router says it takes strings, what about regular expressions for routes?
I used iMovie, which really was a silly choice but hey it worked! My wife is a VO actor so we have a home studio available for audio. I found some good background music on Audio Jungle that added to the mood. Most of all I tried really hard to keep the pacing tight and even adjusted the video speed at various times to make it flow well.
cool!
This is amazing, I love the DI with services! I always preferred Gorilla to things like Revel because it wasn't so opinionated, and this seems closer to Gorilla but with this clever idea of services. I threw together an example app with templating and database access as services, I'm impressed by how concise it is. package main import ( "database/sql" "github.com/codegangsta/martini" "github.com/coopernurse/gorp" _ "github.com/mattn/go-sqlite3" "html/template" "net/http" ) type Post struct { Id int64 Body string } func main() { m := martini.Classic() // Database service db, err := sql.Open("sqlite3", "/tmp/post_db.bin") if err != nil { panic(err.Error()) } defer db.Close() dbmap := &amp;gorp.DbMap{Db: db, Dialect: gorp.SqliteDialect{}} dbmap.AddTableWithName(Post{}, "posts").SetKeys(true, "Id") if err := dbmap.CreateTablesIfNotExists(); err != nil { panic(err.Error()) } m.Map(dbmap) // Template service m.Map(template.Must(template.ParseGlob("templates/*.html"))) // Route using template service m.Get("/", func(w http.ResponseWriter, t *template.Template) { t.ExecuteTemplate(w, "home.html", nil) }) // Route using database service m.Get("/test", func(w http.ResponseWriter, t *template.Template, dbmap *gorp.DbMap) { if err := dbmap.Insert(&amp;Post{Body: "Test post"}); err != nil { panic(err.Error()) } t.ExecuteTemplate(w, "test.html", nil) }) m.Run() } 
And now I have incredibly verbose tests... good thing or bad thing? http://puu.sh/5iRQQ.png
Pretty neat, although I'm not sure how I feel about needing Internet to fetch the fonts in the web UI... can't they just come bundled?
Go can without problems deal with data that is not encoded in UTF-8. There are routines that can convert between different encodings. The important point is that Go likes to represent text as UTF-8 encoded strings (meaning: an array of bytes that is interpreted as UTF-8) internally. All text functions are designed to work on such strings, but there are counterparts that work on ASCII-strings. 
Thanks for very informative reply. Re 1. - what's the best practice for writing DB-agnostic queries? Say I've got an app that should work with mysql, postgresql and mssql - do I have to write every complex query three times?
The go.text packages have everything you need: http://godoc.org/code.google.com/p/go.text All the ISO-8859 encodings are supported: http://godoc.org/code.google.com/p/go.text/encoding/charmap
Except for the icons, all you need is Oswald and Open Sans. Feel free to download them from Google Fonts: http://www.google.com/fonts -- though, true offline support is probably on its way. I could see how that'd be useful. Just gotta figure out if I want to get Font Awesome to render locally (it's kind of heavy).
I pulled the video out onto the page! http://martini.codegangsta.io/#demo
I'll be sure to check it out. I'm a ruby developer by day using Rails, poking a bit at Go for some variety.
I mostly noticed this because noscript blocked the Font Awesome request by default. I'm in the minority of people who use noscript, but there's probably a slightly larger minority of people who might want to use the tool offline, so I mentioned it. Fortunately, there are tooltips on the buttons, so it usable either way. 
Database drivers should help you a bit with that. This is the common interface they must provide: http://godoc.org/database/sql But the rest of it has be adjusted, yeah. If you restrict yourself to a subset of SQL that is the same in the three databases you should be fine, though, I think.
2. I've had great success with this package when dealing with encodings: https://github.com/djimenez/iconv-go 
Long live bugs!
The problem is that simple things like LIMIT are completely different in ms sql (SELECT TOP n). sqlalchemy's query builder (and kind of similar libraries like hibernate) helps tremendously with such stupid little things.
Even the Go ORMs that attempt it do an incredibly simplistic and poor job at query building compared to SQLAlchemy; It's a huge task to come up with a single interface which encapsulates most of what you get with SQL without losing too much from the underlying databases. How do you write a query builder which allows for PostgreSQL json/hstore, for instance? The elegant, simple solution for database independence is only a 50% solution (the 90% solution is atrociously ugly and complex), so few have bothered. database/sql is meant to provide you with access to sql databases, and only features which have to do with its connection pool (transactions &amp; prepared statements) are implemented in that layer. Obviously the set of SQL extensions and even basic types will differ between backends (and between engines for MySQL), but even the bindvars are up to the driver to implement and differ (postgresql requires '$1, $2, ..', mysql requires '?', and sqlite accepts either). `lib/pq` for example has built-in support for `time.Time` values and provides a `NullTime`, which MySQL libs either lack or require a connection-time flag to implement. Current best practices are to stick to the SQL standard supported everywhere for queries when possible, and to hand-craft different queries for different dbs depending on which is in use where necessary. The current driver on a `sql.DB` struct is sadly hidden, but it is exposed with the `DriverName()` method in (shameless plug) [sqlx's](http://github.com/jmoiron/sqlx) variant. sqlx will also handle bindvar differences automatically with `DB.Rebind`; it's not done by default because people might not want to pay the slight performance penalty. There are some serious folks in the community who want to solve this problem, but I don't know of people with money on the line who are working on open source libraries to do it; my library is a quite serious hobby project, but a hobby project nonetheless.
Reminds me of C, where the order of evaluation of function arguments is not specified either. I suppose those are the sort of corner gotchas that can be really confusing if you code yourself into them having never heard of them. On the other hand, I guess these kind of things allow compilers to optimize better.
Looks promising! I'd love to see some more complex examples to see what it looks like in more realistic scenarios.
I plan on doing more videos showcasing some more middleware and realistic examples
I can think of a use case: if you want to switch between the latest stable release and the development version (beta or RC).
Yes, I would be much happier if this held true. When doing math one expects the natural rules of math to apply.
I'm a bit confused by the no bound checking chart - is that performance increase relative to the "base performance" chart at the top, or relative to Java?
The Go code appears to largely be a direct transliteration of the Java code. What's being compared here is not Java vs Go, it's Java running optimized Java code vs Go running optimized Java code. 
Are you implying there is a more idiomatic way to do it in Go that would result in faster execution time? I think elithrar_'s answer is a bit more plausible.
I am implying that highly optimized(though possibly not idiomatic) Go code would perform better than it does in this test. That said, elithrar_ is also correct, with the addition that this is an example of a case in which the JVM is especially good. 
Also I don't think Go is (still) thought as a good number-crunching replacement for Java (or C, for that matter.) I want to port some of my somewhat-optimized C code to render fractals (used for some math papers a while ago) to check how good it might me, but the only good thing would be goroutines to make some parts faster... And I already used PVM back in the days to get a stupidly simple framework to parallelise (essentially split the image in N by M pieces and slave away, simple-and-effective)
PVM?
Yeah, but the natural rules of math don't speak to side effects. `a - b + c` is evaluated in the conventional order, but the subexpressions can be evaluated in any. Math doesn't say anything about the order to evaluate each parenthesized expression in `(a - b) * (c + d) / (e - f)`. In pure math, it is perfectly correct to calculate the middle, then the last, and then the first before multiplying and dividing.
Wasn't the article about all the optimizations he attempted and how he couldn't make it faster than Java?
All the work done on the JVM over the last 15 years has been the best thing that's ever happened for Java. I just wish the language itself had gotten as much work.
Innominate8, you are absolutely correct about the direct transliteration. As stated in the article, "The Java and Go versions of the codecs are almost identical, logic-wise, aside from language differences." I would love it if you can share some tips on how to optimize the Go code even more. 
Thank you for the clarification. This is some pretty thorough testing you've done!
Not being thread safe isn't a problem and isn't unexpected in zmq. This sounds pretty FUDy
Hmm I think it was meant to be Parallel Virtual Machine, a library, daemon and all the required stuff to do local or networked parallelisation via message passing. I didn't learn much, since shortly after starting to use it most parallel people in the department started using OpenMP.
But that only requires the use of hg to download the repo, make.bash to build Go and invoking the right go binary. There's no need to add like 10 commands and hundreds of lines of shell code to do that.
Sure, you can be harsh as long as you are constructive like how you point out areas you think needs improvement. However, I can assure you those are not "for no apparent reason." Let me clarify. The copying zeroed slice (not structs) is to zero out preallocated slices before each use. This is to avoid having to allocate new slices each time, which could cause more garbage collection. There's no equivalent of memzero or memset in Go afaict. I can probably somehow copy runtime.memclr into my code, but the copying of zero'ed slices has not been a bottleneck. The bytesbuffer is to pack bytes and eventually read them back as int32s. It's almost like bytes.Buffer but has a few more functions around it. It also hasn't shown up in my profiling as a hot spot. Not saying this is the only way or the best way, and I am all ears for additional optimizations or better ways to do this. However, to me it doesn't seem to be a major contributor to execution time. The areas I know are taking most of the execution time are functions like nlz1a (number of leading zeros) and DeltaMaxBits, in here (https://github.com/reducedb/encoding/blob/master/util.go). Would love suggestions on how to optimize.
Is there good support for cli watch testing? I love everything Convey is doing in the browser.. except the browser. I love my cli-oriented workflow, and i don't want to open a browser and watch it to see my tests (tmux/etc handle that just fine for me) I am also debating Ginkgo, but haven't decided on either yet.
I like tool like this and GVM. While I could do it myself, tools like these optimize my workflow and make coding more enjoyable. For example, Ubuntu's Go version is behind, so I needed a more recent version installed. Being able to do this with a single command is easier and faster than checking out the code from the repo and manually compiling and adding it to my $PATH.
While I like the concept here, how is this different than existing tools like GVM?
Images all seem to be missing?
oh my, I never thought of that for func's, but that would be so great. Why can't you do that? Seems you should be able to do: func ( (self Thing)test1() string{ return "thing test1" } (self Thing)test2() string{ return "thing test2" } )
Thanks @dgryski! Funny you should suggest that. I just finished updating the code with an assembly version of that function and updated the blog to reflect the improvements. In general I saw a 3-40% performance increase for encoding using the assembly version, which I borrowed from math/big/arith_*.s. The reason for the wide range is because it depended on the size of the delta integers being processed. I haven't tried the builtin gccgo version. Will definitely take a look at that. Really appreciate the suggestion! Will report back. There was no change for decoding. The hot functions are still in the Delta* functions (DeltaMaxBits(), MaxBits(), Delta(), InverseDelta())
Argh..sorry about that. I mangled the URL for some reason. Should be fixed now.
&gt;I just wish the language itself had gotten as much work. psssst scala
Ha. Hahahahahhahahahha HAHAHAHAHAHAHAHAHAHAHAHAHAHAHAHA No. http://www.slideshare.net/extempore/keynote-pnw-scala-2013
Honestly I am not surprised. There was a similar post on the golang nuts list a while back. The benchmark program was a large number of integer additions and multiplications in a tight loop. On my machine the C++ code compiled with -march=native and O3 was the fastest. Go was slower than both Java and C++. Surprisingly Java was faster than C++ compiled with even -O2 on my machine. Like others have noted the JVM is a beast and the Go compilers cannot catch up overnight. Hopefully it happens soon enough. The trend of going down to assembly for simple Go programs or to do absurd black magic in Java to control memory layout is a bit disturbing. I can totally understand it for library code, but IMHO most of the high perf code in Java/Go ends up being more complicated than an equivalent version in C/C++.
You can try using LZCNT instruction instead.
&gt; The areas I know are taking most of the execution time are functions like nlz1a (number of leading zeros) and DeltaMaxBits, in here (https://github.com/reducedb/encoding/blob/master/util.go). Would love suggestions on how to optimize. For starters, you could have used SSE4's LZCNT opcode. :-) From the looks of it, DeltaMaxBits also looks simdizable, although I'm not sure what's the performance of unaligned loads in AVX2 - and you'd need at least one per stride, what with the running difference in the DeltaMaxBits range for loop. What are the usual lengths of buf?
&gt; The Manning book is still in-progress. They've merely renamed it to Go Inaction. ;-)
Video: http://www.youtube.com/watch?v=TS1lpKBMkgg
You might want to take a look on Mozilla's Heka (also in Go) and maybe borrow some ideas[1]. Also, I'd open source it earlier than later. It's way easier to get feedback and have other people excited about the project which can lead them to help the project. Shorter feedback cycle, fail early and fail often, is one of the best advices I can give you. Don't worry about your code not being perfect. No one's is. It's way better to have many projects, even if undone, than having a empty github account. Cheers man. [1] http://heka-docs.readthedocs.org/en/latest/architecture/index.html
How about func (self Thing) ( test1() string{ return "thing test1" } test2() string{ return "thing test2" } )
I'd just like to point out that OpenJDK is somewhat slower than the Oracle JRE. Would it be possible to see some numbers for that?
 peer := &lt;-n.Ch peer.Power -= 5 n.Power = peer.Power Am I crazy? Isn't that a racing bug?
Did you use the zmq library concurrently? I guess no because you would see how you application panics because the go libraries for zmq are not designed thread-safe. Zmq may be thread-safe by nature, but the go libraries are not.
Actually i didn't edit it haha. I actually went with Ginkgo.. *for a short while*. Primarily, i found the assertion syntax to be horrifying. Vastly prefer Ginkgo's Describe() and It() over Convey() and So().. however, `So(value, AssertType, expected)` is so nice and clean, i chose that. Furthermore, i am actually liking the web interface more than i thought. Primarily due to the popups. I can program like normally, and the popups keep me informed (and in my term). When i actually need to see more information, the web-ui ends up being nice since it can cleanly express large amounts of information easily. All in all, based on very early usage, i am vastly liking GoConvey and will heavily recommend it. Thanks for taking the time to comment on my post, but quite simply i think i was wrong. Or at least.. if my previous *opinion* wasn't "wrong", then i don't agree with it enough to explain it hah. **disclaimer**: I am quite a few beers into the night, ignore grammar.
this would be awesome. are you going to post them as well on your project page?
Defining a receiver seems out of the norm of var, import, const blocks, but anything is possible ;)
Love the style of writing and the lighthearted progressiveness. Looking forward to reading about his next project. 
Sorry you had so much trouble with kdtree. Have a look at a [talk I gave a while back that uses kdtree to search a 2D data set](http://talks.godoc.org/code.google.com/p/biogo.talks/illumination/illumina.slide). There's code in the slide that should explain the approach.
Yeah, the project page will eventually have an array for videos to watch
I'm a big fan of Hugo. I use it for my personal (non tech) blog and plan to use it for the Martini project site very soon
Wow, these slides look amazing! The library seemed really powerful, especially the use of interfaces -- I would like to supply my own node type, which it appears that biogo.kdtree supports, but not the library I ended up using. I will take another look at this. 
Thanks for reading!
I've been using https://github.com/vaughan0/go-zmq without issue. There's even examples of using it with channels.
Interesting, I'm looking to use Martini for an upcoming feature in Hugo. I love it when things work out well like this. Everyone benefits. Let me know if you need any help.
I was looking for something like this, I hope it goes more in depth later. Maybe TCP/UDP too.
The more idiomatic way would be yo just have a func Must(s string, err error) string and have the user pass DecodeSignedValue into it
Thanks for sharing pheelicks - I've been messing around with websockets as well but just un/marshalling base64 encoded json images across it for client dom insertion. Do you ultimately have some sort of messaging model in mind for talking to the client side canvas? Just throw me a link if my education is lacking!
True but Must functions are used throughout the standard library as well
Interesting. Just browsing the source (because there aren't any docs at the time of writing), it's hard to see what sets this framework apart. Could you give a brief overview?
How do you like GarageEngine? Does it seem to be pretty usable or was there a lot still missing?
the skeleton seems pretty much like revel, the document isn't there so we can't really compare on the user side. 
Maps in the general case, [bloom filters](http://en.wikipedia.org/wiki/Bloom_filter) for a potential speed up. Probably I would layer 1. Bloom (over all sets), 2. Bloom (for a particular set), map as a set (for a particular set). The 1. layer bloom may help avoid checking all sets, but this largely depends on the sparsity of your data.
Thanks for this explanation, makes lot of sense.
Is there an option to put routes in a separate file instead of adding them in the main function?
I found it amazingly simple to use. The documentation is not that great but with the code samples that come with it and having Go code that easy to read and follow I didn't have many stumbling points.
Sorry for the lack of documentation&amp;comments, but I do happy to know someone is using my library :). I think its pretty usable but there are some places where things could be cleaner/better, the main issue is that each sprite is a draw call. I have a version that use batching and can render 50-100k Game Objects while keeping 60fps, I'm still researching Game Engines in general and OpenGL techniques so I hope to update it soon.
Oh hey I have been meaning to write a git issue on there just to tell you that you have done a great job! It is really great to work with. I only had one major issue and that was loading or adding a font outside of the mainloop or after the initial load. It would panic and crash in the GenBuffer function. I was able to work around it by adding the text in main loop execution though. This may all be because I compiled glfw as a static library though so I will get back to you on that. keep up the good work!
Hey man, looks nice, I plan to take a better look when I get home (only terminal here). I noticed there were some indenting and formatting issues which are normally solved simply by running 'go fmt'. I also saw a (very slight) performance hinderance so I forked your repo, changed it and created a pull request. I hope you don't mind! As luck would have it I'm implementing a somewhat similar client-server game so I might borrow a thing or two ;) What go meetup did you write this for?
Hey thanks I will pull your changes after work and make sure it runs before I merge it. I have always used the infinite for loop you just taught me something new! This is for the Toronto Go meetup Dec 4th
Not to diminish the work but do we really need yet another web application framework for go? It would probably be more useful to polish and improve the existing ones.
I use web.go for the time being, but I can't wait until Revel hits a 1.0 release (hopefully next year) so I can start using it in production. 
Why not `go build path/to/main` for each app instead of building each .go? Why delete the old bins first instead of just doing cp without -n? If not just cp, I'd rotate these to permit rapid recovery from bad bugs. If you wrap all the server-side stuff into a single script stored on the server, then you can execute it in the dev-side script by passing a command through ssh. By the way, it's pretty simple to reduce the deadtime by starting the new process, binding to different ports, changing the iptables prerouting rules to send external ports to the new internal ports, and finally killing the old process.
That's basically what I do, I'm just used to running go build *.go but I'd assume it's the same as running go build on the path. I'm open to running a single sh file to build and deploy server side, I just wanted to know if there is a solution already out there so I'm not reinventing the wheel. I'll need to look into iptables mapping, that looks like exactly what I'm looking to do. I have the port set by a JSON configuration file on binary load, so I'll need to add a feature that can override the port when executing in the CLI. I'm using fcgi w/ nginx as the web server (nginx does a short cache to the data, and I figure I could somehow load balance processes in the future). Sometimes the processes will crash if we get too many connections at one time and the connection to mongo DB goes bad, so I have a cron on startup that basically runs an if process not found then try to start up again function every two seconds. I guess the first step is creating a sh script I can execute when I'm ready to push to production.
I recently started managing a reasonably large application with Go and was writing a post on Medium about our deployment/provisioning scheme. Your post reminded me to go finish it (this is the first time I've linked to it, I'll submit it to this subreddit after I proofread it with fresh eyes): https://medium.com/p/528af8ee1a58 I like to configure/build as much as possible as early as possible to catch any errors so we ship compiled binaries instead of cloning around git repositories.
Why not just push compiled binaries to the production server? There's also zero downtime restart code out there that will alleviate your cp and kill setup.
This looks like it may be a workable solution for us. Instead of goagain for handing off sockets, what I'm looking for is fallbacks for processes that fail (it's often for our application to fail every few days because of a stuck MongoDB query, which is why we're looking to start it again every 2 seconds). Would you happen to have the resources you used for the steps you went through? (Makefile, making a .deb, repository, etc.). Knowing that the resources worked for you, I'd be able to piece it together step-by-step.
All the important pieces are at the bottom in the Tips and Tricks section (including the things you mentioned). I think the only piece that's not there is the upstart script which runs the web server (it's the most basic upstart script ever, it just runs our executable, so pasting in ours wouldn't add to much value). And if you have the `respawn` directive in your upstart script it will be restarted immediately when your process dies. Why does a stuck MongoDB kill your whole process though? Shouldn't it be in it's own isolated goroutine? Are there no timeouts? (I've never used MongoDB).
Thanks, I'll take a look into this.
Ah thanks so much, my fault for not scrolling down. I'm using the `mgo` library, wouldn't placing it in a goroutine make it non-blocking so I can continue to the output? That wouldn't work in some cases as I rely on that output, but I am using goroutines in places where the output is not dependent on DB workers so it makes it non-blocking. I'm still trying to figure out why MongoDB is failing, it looks like it kills itself when there are ~1400 connections...there shouldn't be that many and everything is indexed correctly, and the setup is to the T on how the `mgo` documentation recommends, so that's another problem I'm also looking into.
For *proprietary* Java. I assume you are referring to the ORACLE JVM. 
goxc is not as useful if you depend on C libraries.
Out of curiosity, why web.go and not gorilla? 
Step 1. would normally be a manual step, as you decide when it's time to push the code/go to production. Step 2-4. Start by just putting all the commands in a shell script (pull the code, build it, copy binaries to the proper place and so on), so you don't have to type them all every time. . As you get more experience with what goes wrong, add checks in the shell script (A makefile might be used for this too). As such a script becomes pretty robust, it could be run on a build server (e.g. jenkins), or just from a hook in git which runs the script every time you, say, tag a certain branch. Step 5. Use some kind of supervisor, the new 'systemd' can restart services automatically if configured to, and there are other tools such as launchd, daemontools, supervisord, runit that can do the same.
Great article. Some valuable information here. Appreciate the example for generating a Debian package with a makefile.
Are you using Copy() and Close() on your mgo.Session, and have you set a timeout on database calls? I have a wrapper around httpHandleFunc to do the following: func NewHandleFunc(pattern string, fn myhandler) { http.HandleFunc(pattern, func(w http.ResponseWriter, r *http.Request) { s := session.Copy() defer s.Close() fn(w, r, s.DB("&lt;table&gt;")) }) }
Honestly that's one thing I haven't done with go yet. But I can see your point. 
First of all, why go build instead of go install, and why don't you use the wildcard? go install github.com/yourcompany/... (... acts as a wildcard). Secondly, IMHO, binding up git and the specifics of your deploys is a recipe for disaster. Tons of people do it, but I still think it is a rather ill thought out notion. The process at the end of the day is really three parts. 1) Building. You build your code into a deploy worthy copy. Building should be happening all the time anyway, you should have a good handle on this... cross compiling is trivial, so building on OS-X to deploy on linux is generally fine. go install github.com/yourcompany/... should be good enough in most cases to build all companies files and put them under GOPATH/bin, just add a few environmentals for cross compilation and you are golden. 2) Deploying. The process of actually getting your resources from your dev or stage environment to your production environment. In Go land, this is normally just a copy (yey scp), part of the joys of Go. Might require some extra work if you have a custom bundle tool or additional zip file. 3) Handoff. The process of starting your new process and smoothly handing off connections to your new process. This in most cases is the trickiest, but in the web world is rather easy, because you can just drain and reroute ports, makes it trivial (haproxy is great for this). If you have long running processes, it gets much trickier. 
What I prefer are libraries that integrate well with net/http. That allows me to freely combine things like Gorilla, github.com/fiorix/go-web, github.com/surma/httptools, github.com/bmizerany/pat, and others.
Shameless plug :) https://github.com/codegangsta/martini It integrates well with net/http and everything else that plays nice with net/http. It is a really fun package to use.
Very informative! Thanks for breaking down the pros and cons with deploying Go apps. The goagain tips are also very nice to have in there.
I also didn't think I would need that, but here, I [eventually did](https://github.com/elazarl/hadoophelpers/blob/master/go/lib/readline/setup.c) No one wants to reimplement GNU readline, and neither did I...
This is a large project that gets tons of traffic, I'm afraid to launch and give it a few mil requests/day and have it crash more often than not because of an unforseen bug that could have been handled by the 1.0 release. I'm starting to use it for personal pet projects, so once I can put some stress testing on it I may start using it professionally.
I'll continue to insist that I've yet to see a web framework provide anything measurable beyond net/http and gorilla other than go-restful. It actually has a noticeably different API and different features like a nice syntax for defining self-describing REST APIs. I really wish people would pay more attention to it, so I'll keep blabbering about it when web tools come up. https://github.com/emicklei/go-restful
Thanks. I'm at the point where I'm learning the basic library to build things and looking out for outside things that will help me build them safer and faster. Thanks for your opinion!
I understand what you mean, but the software works. The homepage of revel states that the code base could change before the 1.0 release, so I'd much rather them at least get to a point where they have a RC saying that the code base is pretty much set and no large changes to the structure will be made
Cross-compiling Go is easy using [this support script by Dave Cheney](https://github.com/davecheney/golang-crosscompile).
Oh, that looks delightful. Thanks!
It feels like there need to be more tutorials on how to get up and running with this with simple examples. Are there any plans for that?
Author's here. This program works like Amazon SNS but running on the user's own server(s). It is production ready and there are already several companies using it on their servers. According to some bug report, there is a large-scale android app using uniqush to push millions of notifications to their 6M active uers. 
how is [gobrew](https://github.com/grobins2/gobrew) different from [goenv](https://github.com/wfarr/goenv)?
Ahh... I see your issue. I only call Dial once to get a global session with all the configurations. Then in your getSession, I would call session.Copy() and then use it like you do. See my initial code sample, I use my global session object and copy it. NGO was written by Gustavo, and he's done some very clever stuff with reusing connections etc. so you should hardly ever have to call Clone. 
Ahh, I see the issue now. Use Copy() instead of Clone() and see what happens in the above code. 
add microsoft push and windows phone push :D 
To be clear. Revel is a step in the wrong direction. I am certainly not looking for a more monolithic tool. In fact, most of the pluggable ones still make a lot of arch decisions for you. Go-restful is simple simple layer that isn't a useless wrapper on top of net/http. I really do see it as unique in the go scene. Please don't think I'm seeking out rails or the like. The opposite. I like the small composable tools. Even more than pseudo frameworks that try to be componentized but still ultimately have an annoyingly rigid "formula" to adhere to.
That having been said I'm going to fire up one of my goto web projects and prototype it out...
Definitely agree that small, pluggable middleware is a fantastic way to go. Will look more into martini!
Working on it. Someone has contacted me saying he wants to work on windows phone. My problem here is that I do not have a windows phone nor windows computer. So I have to rely on others to support windows phone.
I see, I looked in the docs and it looks like the only downside is it can make queries wait since it's reusing the connection. The queries I run are pretty quick (all indexed) so the wait time is minimal (sub second). Is that the only fallback you can see? If this works, I owe you a beer! EDIT: I read the docs wrong, .Clone() looks like it keeps the socket open.
This is brilliant. Will be looking into using it ASAP. 
A quick question here: Is there any existing template in Hugo (or 3rd party templates) for free/open-source project's website? I'm currently using webgen (written in Ruby) for my project. But I'm totally OK to switch to Hugo.
No problem, I'm glad I could help :) A shame I live halfway across the globe, this looks like it could be very interesting when you put a bunch of Gophers in the same room.
That's awesome! I'll definitely look into it.
 You make me forget what I was going to 
While I'm quite impressed with your effort, I see one line that may break your neck someday. &gt; I can worry about large-scale databases later! Do you have any plans for scaling, if your product gets popular too fast?
The Pi element seems like a "just because."
I had a similar experience and did start with SQLite3, but it wasn't a good fit at the end of the day. I've been using MariaDB on Raspberry Pi since then (w/ 512MB RAM), without any issues.
I don't recommend migrating to encoding/csv if your current solution works for you. Your home-grown library is almost certain to be better.
Well, if you call needing a cheap, always-on server that can be CPU and I/O slammed 24x7 without hitting throttling or bandwidth charges "just because", then I guess so. In fairness, I haven't yet looked into performance comparison of the Pi with, say a Small EC2 instance. So you may have a point in that the cost/benefit analysis might have pointed to a cloud server solution right off the bat. That'll be interesting to look into as my CPU needs increase. Thanks for chiming in!
I appreciate your vote of confidence in my home-grown library, Horpy ;o) For what it's worth, I've been very impressed with the quality of the Go API libs so far, which is why I'm open to migrating. Perhaps you know something specific which I don't about encoding/csv? Thanks for your comment.
What's really needed is a good templating language, not another web framework. The standard html/template is okay, but if you're coming from something like Jinja2 or Djangos templating language, then it's just to limited. Just adding something simple like extends to html/template would make a huge difference. That and template tags and you'd be pretty much set. Yes, I know Pongo exists, but there doens't seems to be much activity and it's a little incomplete. 
&gt; In fairness, I haven't yet looked into performance comparison of the Pi with, say a Small EC2 instance. And you probably shouldn't. What you should be looking at is one of the many options for running a VM in a cloud, which can go down to be pretty cheap. Amazon's cost/performance is not the best. (They have other advantages, which is why they change what they do.) However, it is true that you should _not_ just look at the cheapest plans; you will need to pay a bit of something to make sure you get a plan that _really will_ let you use all the CPU they say they will. Anything less than $25/mo is probably a problem.
Very interesting. I've been using (and proselytizing) goxc for awhile now. Sadly I disable many of the features in my goxc configuration to end up with what I want. Parallel builds and a slimmer mindset has earned gox a spot on my "must try" list. 
Hi Jerf. Yeah, the last time I looked at their prices, I estimated that a Small (On-Demand) EC2 instance in the Eastern US zone should run between $30-$35 per month. Since I've been happy with the service for a Micro instance I've been running for some time, I'd probably just go with that when the time came. Reliability, up-time etc count for alot too, and I've found Amazon to be pretty good on those fronts.
"Store your sensitive data like passwords, bank account details, *sex tapes involving you and your teachers* or whatever comes to your mind in an encrypted store." ... O.o but, otherwise, looks really interesting!
Have you considered using an API framework like [JAS](http://godoc.org/github.com/coocood/jas)?
I couldn't find a package that already does this, so I wrote one: https://github.com/mccoyst/validate Comments/criticisms/corrections are welcome.
If you're building a business, you should be measuring your MTTR —Mean Time To Recovery. http://en.m.wikipedia.org/wiki/Mean_time_to_recovery What happens when your Pi dies. How long to set up a new one. What happens when your ISP is having issues? This is what most “cloud services” (claim to) offer. I know it might sound like a complicated solution at the moment, but this is what makes a business vs a weekend side-project. Good luck and keep us posted! I kinda envy this freedom of yours :-)
I can see two problems there: 1. you should never panic outside of your interface (or at least that's what I was told) 2. let's say that instead of panic, wrapper will return error code. Because you want to deal differently with opening error and closing error, you still have to write few lines that will deal with those cases. After all, you're not writing less code. 
Note that len(s) can (and will) return a different result when compared to utf8.RuneCountInString, because len() only counts bytes. I recently had to write some server-side validation for POST form data, and yeah it was pretty dirty. The alternative is to do something like this package and use struct tags + reflect to loop over the struct and match the field to the rules. The trade-off here is that whilst you get a more re-usable approach, you may trade speed and fault tolerance for it. Figure out how re-usable this will need to be and make a judgment from there. 
This looks like a solution to a problem that doesn't really exist. And the solution isn't great either. If this is really a problem, I think it'd belong in `go vet` or similar. A simple version could probably have a decent hit rate. Maybe some false positives and false negatives for more complex cases. One of Go's strengths is that it doesn't classify everything as a language problem. It provides a simple language, and an easy way to build tools for it. I imagine if anything solves the "generics" problem for Go, it would be a tooling change rather than language change.
Thanks iampims - that's a really good suggestion. I'm still in Beta mode these days, and don't have a revenue model in place yet ie no paying customers at this point. Are you suggesting MTTR analysis is worth doing even at this stage? FWIW, I take nightly off-site backups of recent data and new users, as well as local ones, ofcourse. Were my Pi to die, I reckon there'd be about a 24-hour turnaround to get an EC2 instance up and running with the same config and sending out reports as before. Not ideal, probably. Perhaps it'd be worth having a backup Pi configured and sitting around once I've got some $$ trickling in. Make any sense to you? Cheers for the note!
Parameter validation is a really hard problem, and any attempt to use a "framework" will often result in significant problems as the framework will end up making bad assumptions that result in you fighting it as often as it helps. For instance, "parameters can be validated in isolation from each other" or "parameter validation is guaranteed to be so fast I can inline it" (not if it may require talking to external resources) or "parameter validation can be done by looking _only_ at the parameters" (ignoring any sort of security context), "parameter validation should immediately return at the first error" (you actually want to receive all errors at once, I've seen this in numerous frameworks), or any number of other things that worked for the original author but may not work for you. Your suggestion to "just tag struct fields" is very likely to fall afoul of at least two of those problems. (Both are avoidable but the most likely "first pass" will have them.) The function signature of your current `Validate` function suggests that it may have the "return first error only" problem, though you may be constructing a custom error object that has all the errors. Before running off to an API, I'd first suggest taking this opportunity to sharpen your DRY skills: Don't Repeat Yourself. If your parameter code is highly repetitive, refactor away the repetition. If you're constantly checking that an input is an integer within a given range, write yourself a `func NumberRange(num string, lowerBound, upperBound int) (int, error)` function. If you find yourself repetitively using _that_, factor it away. Write some tests around this code, rinse, and repeat. (This is also a great time to take as much advantage of the type system as possible. A function that returns `int` is _guaranteed_ not to return nil, whatever horrible inputs may be fed to it. A function that returns an instance of your custom type is guaranteed to not return a string unexpectedly, whatever horrible inputs are fed to it. This is one of the most dangerous things about web frameworks in sloppy-type languages, where you really aren't ever quite _sure_ about what you're receiving. Go could be better on this front, but it's better than Perl or PHP.) If you do this enough, you'll reveal the underlying structure of your parameter validation, and you may just find that the remaining code is not something you feel like you need a "framework" for anymore. One problem with parameter validation is that while it's nice for someone to provide a `NumberRange` function for you, the generic validations are typically the easy part of your validations anyhow. Nobody can provide you your business logic validations, and that's the hard part. You'll probably want a custom "Error" type that can indicate a "validation" error; and remember, an error may be related to multiple fields, so it's probably more like type ValidationError struct { fields []Fields error string } although I feel a bit sick typing `string` there, but I guess right now Go hasn't got a great localization story that I've seen.
In the example I kept the error handling simple. The panic in my case is a stop the world, I can't open a file for reading issue. In this case for me it really is a matter of stopping the process. In framework or library code you don't want to panic because you can bring down the user of your libra bray or framework. I'm also exploring more ways to do error handling...we will see.
ohhh no.. the thought of mixing Go and javascript make me... er.. nervous.. twitchy......
The point of this isn't to architect your code in both go and javascript, but is rather to give your end-users the ability to write little snippets of code in a language they are familiar with to extend the functionality. Imagine you are writing an excel-clone is go, you could let your users use javascript to write their formulas.
I just wanted to let you know I've applied the fix partially across the system, and it's dropped the load probably by 20-30%, a huge difference! Thank you for that tip, I can't believe it was that easy. I would honestly think that `.Clone()` would be the correct way of handling this, since it doesn't need to open new sockets....not sure why `.Copy()` is the answer.
Thanks for sharing dekarep! I found your code interesting - it reminds me a little of using the local lifetime of a c++ object to do some context management. Can I throw some crazy ideas out there? ... Have you considered making your api asynchronous? Would you consider passing-in an on-error callback? My personal inclination is that more indirection makes code more difficult to debug, but I'm sure there are more patterns out there to discover... 
The Heka project (Mozilla) has implemented a sandbox system that currently supports Lua scripts as plugins alongside the usual Go plugins. Seems relevant. https://github.com/mozilla-services/heka/tree/dev/sandbox
Thank you, very insightful, especially wrt the differing security/performance/composition characteristics I may want to have for the validation logic for different API calls. This may well be an adequate enough reason to not use field tags. I really wanted /u/stkfive's solution to work because it would have saved me quite few LoC, while not having to sacrifice type safety. I think I will continue along the same lines as present (maybe a different `Validate` signature), and see whether the field tags are still viable when the API is closer to completion. Edit: That said, it might be possible to use a combination of both approaches
Yeah, the thing I wrote is very simple, but it has the advantage that you can easily use it wherever you want, together with anything more complex.
The asynchronous case I was thinking about was where the cost of creating the context is very high compared to the actual transaction (like building lots of TLS connections for tiny transactions). In this case you might want to consolidate the transactions to reduce TLS construction cost. I think there are other applications as well, like reordering the transactions into a disk queue or managing a bank of elevators in a tall building - especially when you can specify your destination floor on the callbutton (my favourite). Sorry for the tangent... 
&gt; That said, it might be possible to use a combination of both approaches Yes, it absolutely is. I think this is a great thing to hone DRY skills on, and thereby learn exactly what the "shape" of the code is, but once you know it, go ahead and map it on to an existing library, or build your own, or adjust an existing library.
Your Redis example is helpful, because I think when you compare it to the conventional Go way of doing that, the Go way comes out on top across the board. The function that accepts the closure to perform in the context manage introduces a point where it becomes difficult to share variables back, requiring you to do a funky promise-type thing with OnSuccess or OnFailure. This begins to compose poorly, especially if you have to start stacking these things. Contrast this with simply calling pool.Get() and deferring the c.Close() normally: func DoTheThing () { c := pool.Get() defer c.Close() c.Send("MULTI") c.Send("INCR", "Counter") .... reply, err := c.Do("EXEC") if err { // handle it } // use reply } No new datastructure just to move around two values that you already get from the function call, no unnecessary promise structure to the code (bear in mind that Promises are largely a hack over languages with an inferior concurrency model; you see them in JS because it _needs_ them, Go does it much better so it doesn't), no new idioms, shorter code. Slight change to where the connection is closed, but DoTheThing will probably return the result to the actual user anyhow and that fixes that. It seems like it adds a lot of moving pieces and even introduces some new barriers to what used to be a fluent, easy-to-understand procedure. I fiddled with this idea a bit when I was first starting with Go, but I always ended up factoring it away. Whatever complicated teardown there may have been should be factored into a method, and it's just the Go way that you should know when you take a resource you should either `defer` its release, or be really darned careful. I always ended up pulling the "manager" function right back out again after the next refactoring. I also played with the idea of passing back a function that the user was then responsible for defering themselves; similarly, that function should instead be turned into a method on the object and then the user should `defer object.Cleanup()` instead, rather than deferring a closure you pass back. I also briefly fiddled with the idea of suggesting we ought to be able to "defer" up the call stack, so for instance calling an .Open() function or method could automatically "defer" the Close in the caller's context. Then I wrote code where that would have been terrible and not what I wanted, and worst of all I wouldn't have been able to fix it, so I gave that idea up too.
I was wondering this as well.
I haven't seen this in particular, but I've noticed there are many Go packages that A) do what Go already does natively, or B) try to recreate cruft that Go frees the developer from in the first place. I could be wrong here, though
I would say the service injection is the biggest part of it. That mixed with some other features from other frameworks (middleware stack, stacked routing layer) makes for some really cool patterns. I find most all of my handlers are complete black boxes that only depend on objects in their argument lists. This makes testing way easier and modularity a much simpler story when thinking about parts of a web application.
I'd suggest using standard *net/http* first (it really is good enough), maybe just use *Gorilla Mux* for routing. Than you can give libraries like Martini, web.go and others a shot, see where you can be more productive and have more friction-less/fun experience. I like the diversity and ability to chose a workflow to one's liking. I think thats the entire point of these libraries.
I agree this seems to be the case... sometimes. These packages do ease a few pain points, but net/http is a pretty solid starting point. A few features missing from net/http; routing &amp; middleware.
Glad to hear it! And the reason this was obvious to me, is because I went through the same a while back, when setting up our in-house server :)
I'm an emacs user with evil (so I am at the same time in both fields) and use acme to edit go code. Being a geek is cool
Do you write Go code in acme in Plan 9?
Per request. Not sure how you think Gophers are very much against reflection because of performance reasons. The performance overhead of reflection is nominal in relation to the number of requests a particular web app is to realistically serve. In other words, it is unlikely that reflection happening on a per request basis will be a bottleneck. If you are so concerned about performance in that area I suggest you use plain old net/http handlers
Does this work with `cgo`?
No, use plan9ports in a Mac OS. I want to install go in a native (or virtual machined) plan9, but haven't had the time yet
Your structure does not seem right here (I am not sure if this because of RaPi). But this is how you put your codebase. **$GOROOT/src/code.google.com/rog-go/exp/callback** **$GOROOT/src/github.com/hugozhu/rpi** Now when you run **go install**, you will see your binary in this folder **$GOROOT/bin/** Also you will also need this folder **$GOROOT/pkg** And if you dont have these folders, you have to create them.
What's the difference between breaking to a label and goto? (Doesn't goto require the label defined later in the code?)
Package roots for code.google.com usually have a /p/ suffix, so that path should be something like code.google.com/p/rog-go/.... Your lappy is arm? Cool! Which one?
Goto is more general. You can jump to any label in the same function provided this doesn't cause you to enter a block you aren't already in or cause a variable to come into scope that wasn't already. Break only lets you jump to just after the end of a for, select, or switch that you're currently in.
Thought the same, there are not that many arm laptops out there
I glanced over it quickly, and rendering html using fmt.Sprintf is a [no no to me](http://i.intma.in/http://gifninja.com/animatedgifs/32988/john-cleese-monty-python-silly-job-interview.gif). 
I am. GitLab hook queries the build VM, which clones the repo, builds the software and uploads it to our custom Docker repo. Then a message is sent to all supervisors which update the image and restart the VMs. There's ~5s downtime, during which the requests get queued.
How do you handle sql database? Do you mix it in 1 docker image with app, or does database sever get own container?
Thanks for sharing.
I'd *strongly* suggest ignoring whatever the user puts as a filename unless you're sure that you've covered every kind of directory traversal (a bit tricky to get right since you want to be expanding paths and then comparing them to your upload directory). Instead, retain it as metadata (if you want) and save the file with some UUID (and original extension).
&gt; they also believe that it's people who are new to golang who start overusing, and abusing, reflections; while their problem can be solved without reflections. I'm genuinely curious: can you provide an example (even if it's just pseudocode) of how to implement something like Martini's service injection *without* reflection? I'm not asking you build something to validate your criticism, but I'm hoping you can articulate on this beyond "#go-nuts wouldn't like it".
Well, except Erlang, which has a more advanced scheduler. Private heaps, better monitoring of processes (their version of Go-routines). Built in distribution facility to seamlessly connect multiple machines into one cluster. To prove that one can actually build a nice OS just with Erlang (that starts in under a second) one doesn't need a paper published, it has already been done: http://erlangonxen.org/ Sounds like whoever came up with that title didn't do their homework.
&gt; Pretty much any cross-platform language has a runtime that effectively abstracts the platform to the point that it is nearly its own OS Not really. Except for HalVM, how many other ones have actually been turned into an OS. C++ doesn't fit here. What does it mean to boot into C++. Boot into boost? I can see Java, .Net (and clones doing it though). &gt; That flattened interface becomes your "OS" within that language. Alright, then. So the OS you get with any of those runtimes is the equivalent of DOS. Yes, it is an OS, but basically as you said, a parlor trick. C++ for example didn't have concurrency units (threads/processes/goroutines) up until recently. Java,.Net,Dalvik,Mono and GO all have shared heaps. So they rise to the level of Windows 3.1 at most. Erlang has both well defined isolated concurrency units such that neither garbage collection nor memory pointer tricks can break the barrier (like a real OS, not a parlor trick OS). And well, there is an existing project that actually implements that. That was the point of my original post, wasn't it? That Go provides *"... more a fully programmable operating system than just another programming language."* is definitely not true. &gt; It's a good paper despite the title, though. Agreed. Minus the completely ridiculous title of the _post_ it was a good paper. I enjoyed reading it as well! &gt; I see no reason that Go won't be able to continue to improve Well I don't see a reason why any of the above technologies couldn't continue to improve. But how likely is for Go to acquire some the traits of say Erlang? Not very likely at this point. Why is that? Because fault tolerance traits have to be baked in. Having to insert those later in as "improvements" doesn't work well. It is like starting with a bicycle and then adding to the frame, and turning it into a tank. It is not easy. As long as it is not possible to monitor goroutines and see when they die, not possible to kill them, as long as it is possible to share pointers across goroutines, it will be hard to compare the two. &gt; Go is already generally outperforming it from what I've seen due to its superior native code Not sure what "outperforming in general even means. Yes Go and multiply matrices faster than Erlang. But why pick Erlang to multiply matrices to start wit. From my point of view, I see lack of fault tolerance as still not being enough to replace Erlang and just say Go it is "outperforming it". Large concurrent systems combined with shared pointers between concurrency units (where supposedly Go is to be used in) would be as good as a Windows 3.1 (if we want to tie OSes back in). In practice, often, the biggest performance boost your application gets is not from switching to a better algorithm or runtime VM, but when it goes from not working to working. And the number of "matrices multiplied per second" or "requests served per second" often goes to zero when the runtime crashes. [I wrote "often" and not "always" because it is possible to build fault tolerant systems using OS processes and load balancers so overall capacity doesn't actually go to 0, Erlang kind of does that inside the VM, but doing it externally working with the OS works too].
&gt; My point was that Go is not only "not particularly special" but that it is a characteristic of nearly all languages, except actual assembler Yes, and that is why it is not a good at being an OS. That was my point and my comment about how the title of the post is ridiculous. Go is not " a more fully implemented OS compared to other languages". &gt; You have an overly-specific definition of OS, for my purposes. Not sure if expecting multiple concurrency units (multi-tasking) and OS processes to not trample on each other willy nilly (isolation) from an operating system in 2013 is that radical of an idea. I mean yeah, DOS, and Window 3.1 are also operating systems, but it is not 1994 anymore. The title doesn't specify general purpose or not, I'll assume general purpose. Anyway, I think most people understand what an operating system is. Now trying to redefine the term to try to win an argument can work too (maybe C is an operating system!?). So now every abstraction API is an OS. Hmm... &gt; Erlang is a bottom-tier language for performance, Go is a top tier language. Multiplying matrices or tight numerical loops, DNA text searches, spectral norms, Mandelbrot fractals, computing digits of Pi. You shouldn't be using Go, you should use C or Fortran if that is the benchmarks you are looking at. &gt; Erlang's type system makes it difficult to make it performant Those things in the benchmarks will be slower. There is no free lunch. Erlang doesn't have unicorns in it. Isolated heaps means copying messages. Being able to reload arbitrary code at runtime, most likely mean it has to have a dynamic type system. It is also rather surprising that Erlang is still improving at the pace it does. It will probably get maps in soon. There is already a branch that implements that. That is exciting. More so because it is an older established language. So improvement could still come from Erlang, who knows. &gt; It's great that it can recover from a crash, but even better is making crashing code not compile. Have you tried dialyzer? I must confess I am not using it either though ;-) so maybe that answers that question. &gt; I resume my task of replacing my Erlang system with a Go system. If you have time, I'd like to hear more about the experience. Just it is interesting what an Erlanger's opinion of Go is. Others from C++ or other background will find some things to comment on (pointers, classes). I find Erlangers focus on the "select" statement, "goroutines+channels vs Pid", or like I did, fault tolerance. It is just an interesting alternative perspective. If you have a blog post, I'd like to learn more. 
Sorry, why not just use their REST API?
It would be trivially easy to write one...if you really need it, go for it. Their API is really nice.
Puts a smile on my face. Playing with the Mandelbrot set was my first foray in to Go as well. I was impressed by how easy it was to make my code use every core. Code here if anyone is wants it: https://github.com/rciorba/frac
So your database is actually hosted on host, but the database deamon runs in docker?
This about sums up my experience in Go. If it compiles it nearly always works exactly like I expected. But the verbosity does sometimes annoy me. Coming from python, Go does sometimes make you feel like you are writing too much, but it also takes away the doubt about what some functions will do.
While it would be trivially easy to write one, that isn't really what he was asking. What I have noticed is that the Go community is very (too) eager to reinvent the wheel, as evidenced by the myriad of e.g. restful libraries written.
Once you get fluent, I find that on a line-by-line basis the verbosity isn't that bad. I definitely in the _median_ case get line counts reasonably similar to my Perl code (as the author says, on code bases that have grown beyond toy; it is true that Go's line-count problems are the worst there). I'm writing the Perl in question professionally, so I resist cutely pouring tons of functionality onto one line, it tends to come out like Go anyhow. What happens is that every once in a while, Go suddenly bites me. Sorting, for instance, is _awful_ compared to Perl or Python or frankly almost any other language. Declaring an interface with three methods is cute and all, but I can't help but notice that I ought to be able to `sort([]Values, func(a Value, b Value) sortOrd)` (where sortOrd somehow represents less than, greater than, or equal), but Go can't say that. Bear in mind that not only is it inconvenient to have to declare what is probably a new datatype and three functions to implement the sort interface, it also means I have one and _only_ one way to sort that structure, without yet _more_ hoop jumping. It's when I get bitten like this that Go suddenly takes 30 lines to do what I could do in three or four lines of Perl or Python. (Or, at the risk of poking a sore point, three or four lines of Go with templates/generics/something.) Fortunately, this doesn't happen _that_ often, but it is annoying.
Yup. That's the only way to store persistent data in a Docker container.
Good article. Regarding the "reading the first line into an integer", I think the author could have gotten away with: r, _ := os.Open("test.in") var i int fmt.Fscanln(r, &amp;i) // i contains integer from first line
No dark corners? Much less dark corners, but there are definitely pitch black corners for Go, as there are for any real world language: Variable shadowing is an issue recognized by Go's authors. Another one is casting integers to strings. Shouldn't be possible, and recognized as a design mistake by authors. Using slices as vectors for append can also cause a unexpected results. See [explanation here](https://docs.google.com/presentation/d/1PeGN3izAK-YKJ1atMA_MENgOBbjrOWbsKbuka5IZnZk/present#slide=id.g247fa90e_1_16) Mutating method that forgot to receive function pointer: type Counter struct { N int } func (c *Counter) Inc() { c.N++ } func (c Counter) Add(i int) { c.N += i } The last bit I was bitten by, is nil panics would cause your test to succeed. Not very common, but when it happens - it's really surprising. Hopefully will be fixed soon. func TestFoo() { e, err := foo() panic(e) // oops, if e is nil *interface* test passes }
The github repo is a response to a blog post saying "I need reflection to save to appengine's datastore". The answer is not to use reflection but to define interfaces that expose what you need instead.
Good to know. Thanks.
I would have thought removing slashes would fix directory traversal would it not?
Oh, ok. That makes sense. Thanks for the clarification.
Maybe, it kind of depends. Like imagine somewhere else you had something unescaping URL characters that you forgot to strip. Don't take my comment as a security audit :) just be real careful with that part since most HTTP servers have fallen to it at one time or another. 
Do you think stripping all non-alphanumeric characters would work?
I would assume so because then it can't form a path (but my point is that some edge case could come up, when you could just as easily avoid the whole scenario with generated names). Of course, what about other alphabets? You do want Unicode to work right, after all..