Upon further reflection, it sounds like you might just want multiple locks. Have a static amount of locks, say 100, spread evenly across your map. Store then in another map, and then ensure the map is never changed after initialization. Now you don't need to lock the LockMap to find the relevant lock for the section you want to work with.
I use it daily and love it. It's generally very smooth. Updating from v1.x.y to v2.x.y can be a little clunky but Russ has spoken about tooling to simplify it. Really looking forward to proxy tooling too. Also looking forward to being able to replace one dependency with another as described in Russ's blogs. All in all still great though.
Thanks for this, it seems like a reasonable way to structure a http service and I have not been sure how to do it exactly so this is a good starting point
I'm curious, do you put as well everything in Server like configuration, logging ect ...?
logging is just a service like DB so I imagine he does.
I don't know, but that would be really interesting! I'll try to look into that at some point.
But you don't have to do that. You run your whole thing in a sandbox and sanitize the IO. Because you *can not sandbox in a single process in Go* and you will never be able to; but you *can* sandbox the whole process that contains untrusted code, almost trivially.
Nice, that's almost how I organize my server as well. In fact this is probably the only way to make server code DRY in Go. And since go allows to spit up struct definition on multiple files one can have a routes.go file, a middleware.go file ... The only issue is obviously sharing values across requests because one has to make sure dependencies are thread safe. But shared dependencies should be immutable at first place.
So... A shitty project that is against Instagrams terms of use, where the interesting part of code is just another library?
You're misunderstanding what sync.Pool is used for. It's a place to stash objects for later reuse, instead of letting them get garbage collected.
I tried to use it, but I had immediate issues with my source plugins. They expected my source to be within the `GOPATH`, so I had to fall back to using the old go path. I'm not sure what I'll do there to fix it.. nor am I sure how many tools are going to be affected. Will go rename work? gofmt? I don't know.. Tooling is important for me though :)
So I am barely starting out here with Go.. but my main interest lie in replacing Java/Jaxrs/orm code with a go back end that handles API requests (e.g. with oauth2 authentication). I have read a lot about GORM to match java ORM capabilities, and also using gorilla mux for routing. I think I understand what you have going there.. in that you make your handlers composable.. e.g. easy to insert before/after calls for logging, testing, etc.. as well as I assume it is capable of implementing a mock/test setup in say a build/ci environment, and when in production use the actual production handlers... is that about right? How do you route.. are you using gorilla/mux.. if not, why? I ask not truly knowing if there is some advantage or not to using gorilla/mux or not.. especially in the case you are presenting here. 
Very cool. Nice, simple and pragmatic. Perhaps you could make it so that the server struct itself implements the http.Handler interface and have something like: func (s *server) ServeHTTP(w http.ResponseWriter, r *http.Request) { s.router.ServerHTTP(w, r) } Also, I like how pragmatic you were with putting the dependencies for serving a request within the server object. Often I see people write just a handler and then passing the dependencies in runtime using something like request context using a middleware, and I think that's just bad practice since you can't really type check that until runtime.
Here's a tour: https://research.swtch.com/vgo-tour
I do that, there is no problem with it IMHO. alias is a god send, I don't get the initial opposition to it. It solves a LOT of issues when writing go code.
Suppose all I want to do is hash a password and verify it in my DB. The hash is a third party library. How does sandboxing protect me at all? I have to be open to requests and have to connect out to the database to check the hash.
It should work with all modules, and I tested all modules, briefly though, with available examples. Also, you don't have to worry about mp3 support, in this configuration it is handled with well known libmpg123 library that is recently introduced as an alternative to `smpeg` lib (usually people have many issues with mp3 and SDL/C/C++. With `-tags static` mp3 should just work). As for "wheel", and just in my opinion, it is not even fair to compare Go `image` with some C lib like imagemagick. Even `frame` interface doesn't exists, it would take many years of work, many people involved to get to the point where it would not be fair to compare Go frame and ffmpeg. But option is given from the start, to use C libs , link, include .c files, etc. Why ignore that?
Interesting. Lately for Lambda development/deployment, I've been using a combination of aws-sam-cli and GitLab CI/CD. I like using Terraform, but the built-in CloudFormation integration in aws-sam-cli makes it sooo much easier to work with. Hopefully Terraform can provide a similar experience in the future.
Little nit pick: objects that are stashed in sync.Pool are all pruned when GC runs. Only the objects in use (not in the pool) survive. 
Thanks, makes sense.
That way, he can give each handler some state without cluttering the server type.
You're right :)
Oh I see, thank you! Does this approach/concept, of decorating a function with the intent of giving it state, have a name? I've used and seen it before, just never thought of it.
&gt; How do you route.. are you using gorilla/mux.. if not, why? Short answer - if `gorilla/mux` provides some functionality you need (like named path parameters) then use it. I've made countless apps that use it and it works well. If you are doing something very simple sometimes you can just use the `http.ServeMux` at times, and if you really dislike `gorilla/mux` or other routers out there you can try something [like this](https://blog.merovius.de/2017/06/18/how-not-to-use-an-http-router.html), but at the end of the day just do whatever you prefer. It is really hard to go wrong between those options. 
Its called a closure.
&gt; How does sandboxing protect me at all? I have to be open to requests and have to connect out to the database to check the hash. I don't see how either of those constitute a problem. Suppose the hash library is malicious, infecting your service. It is now able to receive requests containing a password and check that against the database. That doesn't seem to be a very effective attack. That's the point behind sandboxing; isolating the code so that even if it's malicious, it isn't able to actually do anything with that, because it can only go wild in its sandbox. But either way, the point is moot. Go is not a language that supports importing untrusted code securely and I don't believe it can ever realistically be made into one. If you disagree, [this project](https://github.com/HogLang/hog) would be happy about contributions. Until then, NaCl is the best tool there is to run untrustred code, even if you don't think it's a good one.
You can also setup AWS CodePipeline w/ Terraform and integrate with GitHub for full CI. However, in the case of building a Go application, not sure how that fits in.
awsome library.
Doh! Thanks for the fix gen2brain!
The readme says &gt; goOutliner.enableDebugChannel: boolean (default: false) - Display debug information into output channel What is the 'output channel' ? 
Awesome blog. I really appreciate how idiomatic your approach is! My team and I have ended up in a lot of similar places. There are so many approach articles from first-time-using-go developers, it’s really refreshing seeing an experienced point of view. 
How do you generally handle multiple middlewares or global middlewares (where every route does a middleware)?
Would go great with fedora atomic workstation
Yeah it's a real drag doing this shit without generics. Using methods instead of functions is a hack around it.
I think there is an error in one of the examples. func (s *server) handleTemplate(files string...) http.HandlerFunc { var ( init sync.Once tpl *template.Template err error ) return func(w http.ResponseWriter, r *http.Request) { init.Do(func(){ tpl, err := template.ParseFiles(files...) }) if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } // use tpl } } Specifically this line: tpl, err := template.ParseFiles(files...) Should just be a normal assignment without the colon, as otherwise the variables will be redeclared in the scope of your inner function, and both `tpl` and `err` remain uninitialized. Nice article with a couple of handy tricks, though!
Great. Nearly same as how I write my services. Combined with gorilla/mux and negroni for middlewares, this is certainly the best way to lay out your HTTP services. Returning the handler is an interesting paradigm. Will try to apply it in future and see how that works out.
I did some image processing but thought the Go's default image package was a bit too basic. But that's easily solved using this package: [https://github.com/fogleman/gg](https://github.com/fogleman/gg) But it probably depends a bit on what you want to do specifically. There are also image magick bindings [https://github.com/gographics/imagick](https://github.com/gographics/imagick) which might be useful.
Just got my first successful build with this feature, hell yes!
&gt; In a sandbox, how is the malicious code prevented from calling home with the raw passwords …because it's in a sandbox. The very idea of a sandbox is, that you can restrict, validate and sanitize how it talks to the outside world. &gt; The container had to be exposed to the internet to accept http requests The Go playground is exposed to the internet and runs code via NaCl. Feel free to try and "call home" using it.
Seems like it's not supported. https://github.com/golang/go/issues/23633
The one advise I have is to not rely on the `image.Image` interface. Which makes me a bit sad. But it implies allocations and interface-conversions on every pixel and I found that slowed down programs using it significantly. Instead, create an `image.RGBA` (for example) and use `SetRGBA()`. It makes me really sad, because API-wise, the interface is *really good*, but the slowdown is actually too heavy when doing image manipulations.
One bit of feedback. The advice on improving startup time comes at the trade off of amortizing your response times. Having seen this at other places, this can lead to higher p99s and might be not a good idea in production where start up time might be small but every restart to your app server will cause a p99 spike. 
The reason it is bad to put dependencies in the request context it is because you should only put stuff related to the current request in the context. 
Well, pratically this is right, but technically "stash objects for later reuse, instead of letting them get garbage collected" is not correct. They will be collected if they happen to be in the pool when the GC runs. Only if the code path with getting and putting objects into that pool is "used a lot", i.e. under some sort of "load", the objects are not collected and do not need to be allocated anew all the time. OTOH after the "load" abates, unnecessary objects (all of the objects in the pool) are collected. sync.Pool ensures there is no overhead in neither re-allocation nor in memory waste by cleverly letting the GC do its job. 
To expand on what /u/joncalhoun said but also provide a different take, my view is gorilla/mux etc are great to learn the basics but try to move past them as your knowledge develops. You can build the same functionality yourself with your own 'router' which will be a lot quicker and only using standard libraries. It keeps the code clean, concise and also allows you to easily encapsulate the routing logic to each component ala the way its done in the OP.
Funnily enough this is more or less how I have done this from day 1 of writing Go. That's because this looks like the idiomatic way of doing it in various languages. Just goes to show how some patterns cut across languages. 
Also, you can use something like Chi which is actually extremely fast, but also very feature rich. Regardless, if your router is your bottleneck in your application, then that's a pretty damn good position to be in.
looks good! great work. I do have 2 questions though: - wouldn't it be easier to install if it were to use `golang.org/x/exp/shiny` for drawing? back in the days, I did write a little `shiny` based backend for `gonum/plot/vg` which is the same kind of API than html5-canvas: [vgshiny](https://godoc.org/go-hep.org/x/hep/hplot/vgshiny) - wouldn't it be easier to interoperate if it were to use `golang.org/x/image/font.Face` instead of your custom `Font` type?
Followup question: Is there any way to group logs from a single request with some sort of reference number? I was thinking of using a goroutine ID or something like that but apparently you can't access them (https://stackoverflow.com/questions/19115273/looking-for-a-call-or-thread-id-to-use-for-logging)
I'm using it in a couple of projects and finally I've a dependency management system that I actually like. It's a bit rough around the edges for some use cases but has got all the core ideas right. It'll only get better. Things that I'd love to see next: * Better, more automated initial setup * Ability to fetch all dependencies without building the program \(must for CI systems\) * Support for vgo in other tools like IDEs, etc. Right now editors cannot find and understand libraries installed through vgo.
You can generate a request id and add it to the request context Example: https://joeshaw.org/revisiting-context-and-http-handler-for-go-17/
Oh yes, I agree completely, but I can't tell you how many times I've seen code that just keeps putting deps on the request context.
I mean, using methods isn't really a hack. Interfaces are way more powerful than generics IMHO. Coming from languages that have an overuse of generics like C++ and Java I think generics are a bigger hack if anything. Just a lot of code that could have been replaced by just implementing an interface or extending an abstract class.
Logging is just like any other dependency, like a \`FooService\` Use DI to pass in your dependencies, then they are easy to test and dont rely on global variables. This might help [https://quii.gitbook.io/learn\-go\-with\-tests/standard\-lib\-essentials/http\-server](https://quii.gitbook.io/learn-go-with-tests/standard-lib-essentials/http-server) 
Go is a general-purpose language. It's well suited for lots of work, not just web apps. Being that it was designed in Google it was designed to handle many of the situations that arise in web and server programming very well, this is why the Go standard library has no many networking, encoding, templating, and other capabilities out of the box and why concurrency is so important in the language. That said, there's no reason from a language perspective why Go cannot be used to create robust desktop applications. One approach is that perhaps you shouldn't be writing the GUI components in Go, but instead use another language or framework for that, like C, C++ or an electron frontend, and have Go be the language that does the heavy lifting of your app's business logic. Go interfaces well with the C language after all, so there's no reason you couldn't use the C bindings for GUIs which almost every operating system and GUI library have.
Go does not have solid desktop GUI solution. If GUI has to target only one platform it is not hard to build. I only ever needed to target Windows. It took about 2 months to build library that targets Win32 via syscalls. Result is this application: [recoink.com!](https://recoink.com) Syscall lets you hook up message loop and do all regular Win32 SendMessage calls. There are also few specific **tricks** when building desktop GUI for Windows: * Embedding icons into binary done via rsrc tool available on github. * Biulding using "go build -ldflags="-H windowsgui" because you do not want command prompt open when app is launched. * Redirecting log into a file. * Error handling requires work since some errors need to be displayed to the user as pop ups or status bar messages. There is basic release.bat file example: rsrc -manifest app.manifest -ico=app.ico,document_empty.ico,control_play_blue.ico go build -ldflags="-H windowsgui" 
There's a reason that Instagram shut off their public API access and this is it. Use your Gopher powers for good, not evil.
The problem is adding anything to the request context is so painful and ugly that you might as well do it once with a strong typed request context. Who thought having to replace the entire request each time you add a new value to the context was sensible programming?
Thank you all for the insights, I was already aware of GUI issue, Qt binding looked quite promissing tho. I'm quite concerned with performance impact of GC in Go and possible hiccups when sweep runs.
I can see this working for smaller applications quite nicely, but have you seen how this scales to larger applications? I usually take a different approach, as I find that things can be quite layered in an application: 1. I'll make main deal with application lifecycle (loading configuration, handling signals, starting up background processes). 2. From main, the next layer is the "resolver" [in my approach](https://www.elliotdwright.com/2018/02/27/directory-structure-and-manual-wiring/). This is a type that deals with the wiring of dependencies, some people choose to do this in main, but I've found this to be more maintainable. 3. The resolver ties together the extremities of the application. Things like handlers, or the router, or database gateways, or API clients are all just things that depend on one another, and they are all treated the same way, but are kept logically separate, on separate types. In a way, the resolver type I use is sort of similar to the server struct you make. The main difference being that things like handlers and middleware are still separate, and on separate types. I'm honestly not a big fan of making everything a method on this one, large server type. I prefer the smaller structs because they convey what they do, and what dependencies they need to do what they do better - making testing things, and refactoring things easier.
Yes. I simply posted url to show how app looks like and what is possible with Go and syscalls.
I was talking about a user id or a parsed token. If you have a strongly typed struct, you couple everything together. I prefer multiple small middlewares to populate their own thing separately. But to be honest, I always only had a parsed JWT in there... 
&gt; That produces low-quality random numbers Define "low quality random numbers". They are okay for every use case that is fine with a 64 bit number. &gt; and has a failure mode It has exactly the same failure mode as your code, just a) less of it (because you are only reading once, instead of on every random number) and b) allows handling the error instead of panicing. If you want to *actually* avoid the error, you can't do IO, so [this](https://play.golang.org/p/wgxNa-A_8oA) is probably as good as it gets (and it's also fine in 98% of cases, FTR). &gt; It also isn't a drop-in replacement for math/rand's shared source. It returns a `*math/rand.Rand`, which implements `math/rand.Source`, so I don't understand what you mean here.
I'd add something not covered by that link; do not forget that [routers are themselves HTTP handlers](https://golang.org/pkg/net/http/#ServeMux.ServeHTTP). If you want a unique ID for _every_ request in a system, unconditionally, you do not have to laboriously wrap every handler you have with the middleware for it... you can wrap the top-level router _once_, along with anything else you want to do for _every_ request. (This is also why you might want to have some router include another router as a target handler, rather than simply routing everything in one top-level router; it gives you a place to wrap middleware around entire chunks of your URL space.)
As others have said: the Go Desktop GUI options are limited. I will add if you are looking for something simple, command line user interfaces can be a fun way to implement a cross-platform desktop app. I've used [gocui](github.com/jroimartin/gocui) before and it was really straight forward and simple to implement. 
For this use, I agree that it can be useful. It is similar to Haskell's `newtype` vs `type`. One defines a wrapper (and distinct type: `newtype`) while the other just a synonym (same type, new name: `type`).
I tend to start out with the default `http.ServeMux`, and if the project starts to grow a bit, I tend to switch to [`gin`](https://github.com/gin-gonic/gin) because I feel like it encourages me to make a nice, simple API while having lots of tools builtin.
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/gin-gonic/gin) - Previous text "gin" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20dyr9l02) 
Very uninformative titles of the videos.
Difficult to use Dep or whatever Cargo-clone after the video of Russ Cox ! With Vgo we come back to the simplicity that we need to keep against all odds.
A little late to the party, but I wrote a little DBMS called Hare \([https://github.com/jameycribbs/hare](https://github.com/jameycribbs/hare)\) in Go that stores each table as a newline\-delimited JSON file, so it is easily editable by external tools. It does not use SQL as it's query language. You write your queries in Go itself.
Damn. Sounds like the same problem i have in C# with slowdowns without using unsafe code. 
Its in Output tab, `Ctrl`+`Shift`+`U` https://imgur.com/a/xkYIU78 It does not output a lot of information, mainly when events happen, and some results to help with debuging. 
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/juokZiJ.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
Good questions. Using shiny may be easier, though I don't have any experience with it yet. Taking a quick look at it it looks like it uses the ```golang.org/x/mobile/gl``` package, so the thing that will have to be done is to implement the GL interface using that. I'll probably do that. As for the Font type, at the moment it's specifically a truetype.Font type. I'm not sure if it could use font.Face as well. I'll consider using it directly though instead of a custom Font type, maybe that is better. Or maybe it would be enough to accept the type directly in the SetFont method, since that accepts interface{} already anyway.
Thanks! Also worth mentioning [this work](https://github.com/dontpanic92/wxGo) on glueing Go with wxWidgets.
It's still safe. Just not as generic.
What? `unsafe` code in C# means unmanaged aka going into C++ tier pointer land for faster manipulation of the bitmap in memory. Theres nothing generic about it (I'm talking about &lt;T&gt; type of generics) However, if you do not go into `unsafe` code in C#, the BitMap class GetPixel() and SetPixel() are super slow. It sounds like Go lang's image package has the same problems as BitMap in C#/.NET framework 
From the article: &gt; I use Google App Engine a lot, so this makes sense for me, but your case might be different so it’s worth thinking about where and when to use sync.Once in this way. If I recall correctly, app engine shuts down apps when they haven't had requests in a while so it is very possible that some of Mat's apps get a request that has to wait for the entire application to boot up. Assuming that is the case, this approach makes complete sense for his use case but likely wouldn't in many other scenarios where the app is running 24/7 and rarely has to incur that startup cost. TL;DR - This is the type of decision that can be good or bad, so you shouldn't blindly use this pattern unless you have a reason to use it.
Decorator is when the wrapping function actually modifies the function being wrapped, isn't it? In this case you create the underlying function right then and there. 
You can apply middleware to entire applications by applying it to a router before starting your application. Eg: m := http.NewServeMux() // ... routes // Apply mw to all routes var app http.Handler = adminOnly(m.ServeHTTP) http.ListenAndServe(":3000", app) You can also use this to apply middleware to specific path prefixes: m := http.NewServeMux() // ... routes // Apply mw to any routes that start with /admin/ in the path mwMux := http.NewServeMux() mwMux.Handle("/admin/", adminOnly(m)) mwMux.Handle("/", m) http.ListenAndServe(":3000", mwMux) This last bit seems weird because some routing logic happens twice, but this is probably one of the most frequent use cases I have for the std library's `http.ServeMux` type.
&gt; What? I meant that using `image.RGBA` instead of `image.Image` is still safe, just not generic. Sorry for being unclear :)
I actually disagree with part of this. &gt; You can build the same functionality yourself with your own 'router' *which will be a lot quicker&amp; and only using standard libraries. (Emphasis added by me) Most people probably don't understand [radix trees](https://en.wikipedia.org/wiki/Radix_tree) and other similar algorithms that can be useful for building a speedy router, so I don't agree that most custom routers will be quicker at all. Regardless, routers are rarely a bottleneck in your application so unless it is, speed isn't the metric I use to determine what router to use.
&gt; They are okay for every use case that is fine with a 64 bit number It depends on how you're using those 64 bit numbers and how many of them you need. As the documentation for math/rand says, it is not suitable for "security-sensitive work". With my package, you don't have to decide if the numbers are good enough because they're always the best available. &gt; It has exactly the same failure mode as your code Not really. As you pointed out, one panics and the other returns an error value. There's a trade off here, but in every case, if my OS can't provide entropy I want a panic. That's why arc4random in C doesn't return an error value. For all practical purposes, the user can assume it will always work. Your sample code also has a more subtle failure mode: it doesn't reseed. As SP 800-90A says, "Generating too many outputs from a seed may provide sufficient information for successfully predicting future outputs". &gt; I don't understand what you mean here Sorry. The article mentions that you can just replace `import "math/rand"` in your code with `import "github.com/mndrix/rand"`. No further changes are required (modulo some not-yet-implemented functions in my package). 
Runs tests on save? That sounds unnecessary to me. Can you give an example how this would be needed?
It's pretty useful when you do TDD. You don't have to go to your terminal and type a command line to run the unit test you are writing. If you write multiple unit tests and want to only run these it's even better. It can display the result of the test in a desktop notification as well. If your terminal is not currently on one of your screen it's pretty cool. In short: it automates running specific unit tests. Automation is good :)
GC in Go is _slow_, but it's slow broken down into very short pauses.
This is exactly how I designed my own package that I use for all of my web projects: https://github.com/zpatrick/fireball
What is the maximum expected number of client connections? If it is low enough the answer might just be a slice. You might also consider a regular map with mutexes, see: https://medium.com/@deckarep/the-new-kid-in-town-gos-sync-map-de24a6bf7c2c 
I want it to be able to have over 10,000 connections at a time and I want it to be able to tell if a connection is alive or not. My current implementation uses sync.Map but I've been reading a lot of articles about the low performance sync.Map has so I've been unsure on whether to use it or switch it out with something else. Thanks for the link.
Same thing with Intellij. Spend 500$ on an IDE that can't update itself. 
Use their toolbox app. Keeps all all nice and up to date...
It's crazy why their Java IDE is almost 5x as expensive as the Go or Python IDE, I wonder why that is.
Picking a reasonable min star count and you can [do this from GitHub's UI](https://github.com/search?l=&amp;o=desc&amp;q=language%3AGo+stars%3A%22%3E+700%22&amp;s=stars&amp;type=Repositories)
Specially if like me you save at every single line end. 
https://golang.org/pkg/strings/#Replace
I don’t do anything in Java, but find IntelliJ is well worth the price, as It provides a full IDE for Go, Python, Dart/Flutter, Android, PHP, JavaScript, Ruby, C/C++, Kotlin and SQL in one app. If I ever DO need to do anything in Java, I guess it can do that, too.
Sync.Map is optimized for maps where keys are only added and don't change much. Your use case is the opposite.
http://www.catb.org/esr/faqs/smart-questions.html
Hey percy, can you provide that information? I just stumbled into this thread..
Exactly! This is why it bothered me. I save constantly
&gt; I'll make main deal with application lifecycle (loading configuration, handling signals, starting up background processes). You do that before anything else anyway and outside the application struct, then you can just pass a context to the struct.
Can confirm. Also some cryptocurrency projects with Go wallets do. The usual setup is a golang daemon with a local socket on the filesystem that the Electron frontend speaks RPC to the daemon over.
Yes I might look for a solution to do that :)
I'm made something similar grouped by topics: https://github.com/orsinium/generated-awesomeness/blob/master/languages/go.md This repository also contains results for other languages and topics. Maybe you can find it useful.
Yeah, I was more using that point to explain I don't wire up in main. It keeps it focused on those responsibilities I mentioned.
Thanks, I will refer to this the next time I ask a question. 
In GoLand you can also work on html, css, and JS, as it's built on top of WebStorm and DataGrip. 
You aren't checking any of your errors anywhere. If something goes wrong building your hash and you end up with HashDecoded being an empty string, then it will always return true when asking if it's contained
I coded this up to help learn Golang before a Summer internship, it explores a simple form of graph database, the ['Hexastore'](http://www.vldb.org/pvldb/1/1453965.pdf). *Triple Store*. It's pretty MVP, so is currently only in-memory and has restrictions on data type. Hopefully something can learn from it :) 
What does Goland bring to the table that I can’t accomplish using Atom plugins?
Thanks a lot for the tips! It definitely make sens
goddamned! Who on earth wants telemetry enabled by default in the sourcode! I want a proxy server and not a "research project data gatherer" Hell, didn't you learn from the header injection fiasko?
When you do TDD you need to go back and forth between your code and your tests. You need to have your test passing to continue writing your production code, so you need to run it each time. Failing as early as you can is pretty good I think. 
... but why?
Just because it is slow does not mean that iti is not useful, I used to love logrus even though it is not efficient and that's why it gets stars, not that it is the most elegant library. But you are right, you should always be critical of stars and libraries
1. A great deal of Go GC runs concurrently with the rest of the program—including a sporadically activated dedicated background task and so-called "mutator assists" (where a goroutine which allocated a chunk of memory is forced to perform a bit of memory scan proportional to the size of its allocation). 1. My experience at my $dayjob with participating in writing a server which sustain a reasonably high load proves you wrong. Of course, as usually, YMMV
Sounds like it is off by default right now: &gt; We are still in the process of proving our systems, so telemetry is currently OFF by default when downloading Caddy from our website or getcaddy.com. For the time being, all data that is collected will be considered expendible (in case we need to do a reset for the health of the platform, or technical correctness going forward), although we hope that won't be necessary. We plan to have any major quirks ironed out by version 1.0. &gt; &gt; We encourage you to enable telemetry, see how it can be useful for you, and to contribute with us in understanding the global Internet a little bit better. Did you see something different?
I am not saying it's not useful, we still use logrus. Remember when they changing the repo name on Github? Twice. That cost half day updating and fixing our environment (CI, deps, etc). This is not an attack to open-source maintainer that listed above. I know how hard to maintenance open-source (I maintained a few of fork, e.g. go-bindata), we are not getting paid, but somehow we feel responsible for it.
Gotcha. Thanks for clarifying. 
https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e is worth a read. Numbers I’ve seen bandied around are that the current Go GC has maybe 8x the overhead of a modern JVM GC.
The suggested solutions where the correct answers. but later i found that one can do the following: import ( "github.com/stretchr/testify/mock" ) type ExampleType struct { ID uuid.UUID Name string } expected := &amp;ExampleType{ Name : "ze" } repository.On("Store", ctx, mock.MatchedBy( func(valInStore ExampleStype) bool { if valInStore != expected.Name { return false } return true }, )).Return(nil) So you can pass a func to mock that will test all the remaing fields except for the UUID or the ULID. Hope this still helps anyone 
Probably the schema you are importing and the schema that created the error are different packages. fmt.Println(reflect.TypeOf(err).PkgPath()) will show you the schema package that the error's type is from. Compare that to your import statement.
https://play.golang.org/p/6s9DIfBIqy- As mentioned - please check schema.MutliError is imported from the same place.
Nice! Might I suggest calling it something more descriptive?
&gt; crypto/rand uses a cryptographically secure source of entropy which usually makes it much slower compared to math/rand That's true. However, in the six years I've been benchmarking Go code, the random number generator (crypto or otherwise) was only a performance issue once. In that one case, quality requirements were low so I did an inline [xorshift generator](https://en.wikipedia.org/wiki/Xorshift).
[Yay, a new JSON pretty-printer each four days](https://www.reddit.com/r/golang/comments/8hn828/tired_of_clumsy_online_tools_json_prettyprinter/)! ;-)
I can't decide if goreplay is an awesome or awful name
I think you meant to hex-encode Hash, not hex-decode the hash. It's likely failing on the line HashDecoded, _ := hex.DecodeString(string(Hash)) &gt; I've ignored all errors and can't figure out why my app is failing Checking errors will tell you what is failing and why. There are some other issues here, like maybe you shouldn't use the password as the salt.
lantern: number 4 and the whole README ain't able to say what the project is about.
Out of interest, what made it clunky? I thought you'd be able to run both packages side-by-side? Or is that what made it clunky for you? Right now I have a problem with dep and glide in that if you make a breaking change, it just completely blows up. It refuses to install the new packages to let me update my code to work with the new changes, so I have to resort to manually vendoring, or using my GOPATH.
I thought projects without a go.mod file should work like they do currently, and still be allowed?
That pretty much is what it is. Major versions will be appended to the end of the import paths. So if you are using a Go Module and it's major version is 3, it's import path would be something like: github.com/foo/bar/v3 You can see an example of this here: https://github.com/peterbourgon/vmain/blob/master/main.go The argument is that anything other than the major version shouldn't matter in the import path, because it should be BC compatible. Your `go.mod` file will contain the actual version you want, and you can optionally use `go.modverify` to "lock" versions a bit more. I'd recommend taking the whole tour and reading the articles about `vgo`: https://research.swtch.com/vgo
I've never heard of Armor before. What's its differentiating feature(s)?
The main clunkiness is when I move a module from v1 of something to v2, I normally want to migrate wholesale, so I just modify the requirement in go.mod and run `vgo test`, but unless I remember to change all of my import paths to include v2, vgo will add both v2 and v1 as dependencies. What would be nice is tooling to update go.mod and all of the import paths to the new version in one go. I don't use glide or dep so I can't comment on them.
Right? Projects that do this really annoy me.
GitHub stars have a double purpose - actual starring, and bookmarking. (This double purpose is described in the GitHub docs.) Hence no one can tell if a repository has been starred a lot or just bookmarked a lot.
OP, if you can't be bothered to do the most basic debugging, why should we? Stop dropping `error`s on the floor! Check and log each of them as a bare minimum.
Indeed, the required performance always depends on the use case.
Thanks, now I get what's happening. They're the same package, but have different paths: Here's my structure: `$GOPATH/src` `└── foo` `└── vendor` `└── gorilla/schema` `└── bar` A function in `foo` returns an `Error` \(of concrete type `schema.MultiError`\) I want to do a type assertion in `bar`, however as bar has `import "`[`github.com/gorilla/schema`](https://github.com/gorilla/schema)`"`, the types don't "match" because of the different package paths \(`bar/vendor/foo/vendor/gorilla/schema` vs. [`github.com/gorilla/schema`](https://github.com/gorilla/schema) or something like that\). It won't let me do `"import foo/vendor/gorilla/schema"` so now I'm stuck
It says in the doxument, they target it to 1.11
I wrote a quick and dirty reverse shell a few days ago that had to do this. I just used a slice and a mutex. https://github.com/fharding1/rsh/blob/master/server/server.go
i did not know about that, but it is really good. I think it would be extremely helpful for new developers looking for a project to contribute to.
i bet that was the intention, but tbh i read it gore play too :D
Sigh. You're welcome, for the free software.
Hi! Sorry I forgot about this request. Here comes an answer :) The tip he gave was creating a container for all our handlers inside a map. var websocketHandlers = make(map[string]func(*websocket.Conn, []byte) error) Its a map that contains functions that can be used to handle the websocket requests. You can initiate that in the beginning /startup of your program, like this might be a good function func setupWebSocketHandlers() { websocketHandlers["broadcast"] = broadcastHandle websocketHandlers["remove"] = removeHandle websocketHandlers["update"] = updateHandle } In my main function i setup a http.HandleFunc to /ws which is were we will wait for all our websocket requests. http.HandleFunc("/ws", handleConnections) In that handler we will check if our Handle map will contain any of the request. A request is specified in the websocket msg, in this case i require the websocket message to contain a field called "kind" handle connection is just a websocket upgrader like this, func handleConnections(w http.ResponseWriter, r *http.Request) { // upgade request ws, err := upgrader.Upgrade(w, r, nil) if err != nil { log.Fatal(err) } defer ws.Close() // listen for new messages for { var msg APIMessage // read json message err := ws.ReadJSON(&amp;msg) if err != nil { // error handle log.Printf("error: %v", err) break } // Check if the applied Kind is a handler inside our handle MAP, if the map contains the handle key it will continue inside the if if f := websocketHandlers[msg.Kind]; f != nil { // If our map contains the handle, it will return the function(handler) into our f variable. // Callback is the applied function so f is a function which we here run, we pass the msg.data field in as a Byte array. if err := f(ws, []byte(msg.Data)); err != nil { // Successfully terminated functions should return nil and not trigger this part // This is for error handling log.Printf("error: %v", err) break } } } } The great part about this is that if you want to add new handlers, you just have to modify the setupWebSocketHandlers function 
I would strongly recommend trying to resolve the "sometimes `schema` is from vendor/, sometimes not" problem as it will likely cause you other trouble. My recommendation would be to move `bar` into `foo/vendor/bar` - either vendor/ everything (recommended) or vendor/ nothing. Once everything is vendored, the problem should go away.
Any suggestions? :)
Actually, I searched for such tools before writing this one but couldn't find one. Maybe I didn't search that much. And I use `jq` quite a lot as well but this one actually works with https://github.com/wercker/stern (which I use heavily) and in "follow" mode such as `tail -f xxxxx` or `kubectl log -f xxxxxx`.
I am grateful, however I don't need to agree with everything you do. (And yes, I read all the blog posts about it, but I strongly disagree with your opinions about it) What I fail to comprehend is why you are essentially adding unrelated functionality to a product advertised as a secure proxy server. I understand that data like this is interesting for you, but for me it's private data you have no business messing with. Same as with the "sponsor" header injection, while it doesn't really matter for the functionality itself, it still wasn't received well was it? Smae applies here, not everyone wants this (nor agrees with your opt in mentality)
Go has two important features that make it stand apart from Python: 1) Threading first class and easy to implement. 2) You can compile binaries and run them on your architecture without worrying about having to install other libraries. This makes deployment extremely easy.
Legit question, what's wrong with gorm? Besides the obvious overhead of being a an ORM
Do Tour of Golang and start making some smaller programs. Can't recommend anything about Go but you probably should grab some book about the use of structures, algorithms and etc. Since most of it is done in Python automatically. 
+ Type safety + A more consitent, better documented and more readable std lib + Performance++
Don't be a "go dev" or a "python dev" or a X dev. Learn to be a developer. A language is just a tool. The protocols, comp-sci behind it don't change.
Go is amazing for anything backend. But as others have said don’t focus on languages. Focus on the correct tools for the job. 
go is "easy" to get started with. It really depends on what you want to do. In my opinion go flourishes in distributed applications and some systems programs. Docker, Kubernetes and Ethereum ( to a big extend) have been written with it. I would not learn Go if you want to develop games, GUIs, Data Sciene/Machine learning applications, hardware programming, simulation stuff
Note that it was "modern" as of 2016. It is 2018 now and Go GC has significantly improved.
Personally, I don't like ORM in general. That's unpopular opinion that most of devs will disagree with me. This dislike caused by some ORM implementation select all row and and do filter internally. For example, if you do `select on table A where Id = 1`, a bad ORM implementation will select all row in table A (which cause large memory usage on your application) and then filter the result internally. That is just select operation. If you use a lot of join, it would get worse. Gorm maybe not like that. Not all operation is just select, update, and delete. Sometimes we need subquery (select from select) or complex join that requires more time to debug and test when using ORM syntax rather using plain SQL. GORM maybe not lolike that. We build web apps with microservices. Current data flow with gorm is: db -&gt; gorm -&gt; protobuf -&gt; JSON. I still can't understand why we need middleman (in this case gorm) while we can bind the result of query to protobuf struct directly, so the process could be simple: db -&gt; protobuf -&gt; JSON. Gorm will not update column if the value is false. The documentation about this feature is deep down on their docs, you will not find it until you get bitten by it. Either you end up using map (which is worse performance) or you use db.Raw SQL for update directly. In the end, in my personal conclusion, the promise that any ORM provided is not worth it.
Their website is down for some reasons but it's a VPN service.
Someone would say, you should learn go because it's concurrent, but I would say you should learn it because of it's simplicity, not because of it's features. Go is different, it's about less is more.
Like any artistic medium, you don't really know if a programming language fits you or not unless you try it. Particularly early in your career, you should try as many languages as you can to see the ones for which you have an affinity. So try it for some small project and answer the question yourself.
I want to add that it’s useful to learn compilers and formal grammars to have a higher level view on languages. So when you hear that go is a statically typed imperative language without knowing anything else you already have an idea what it’s like. Also formal models of concurrency. Cuz it’s just a fascinating topic and useful to know where modern languages like Go are coming from. 
Yes, I didn't want to use the password as the salt because then the end user would have to carry a salt with them as well as a username and password. For the hex.encode issue. I just made a hash on another file and hex.encoded it, so I had to hex.decode it. Anyway, thanks for the answer!
I will debug as much as I need to for a while before giving in. What is the best way to log errors IYO? Thanks!
Go doesn’t have threads, per se, it has asynchronous execution and messaging intrinsics. Critical to use correct vocabulary with newbies.
I have goland ide
solved, hex.encode in server. simple mistake, sorry to waste you guys time!
There are a few ImageMagick "implementations" available for Go, that's a pretty nice lib but I don't know what your experience would be like.
I have never skipped any version and this time, GoLand can't update itself. 2018.1.2 build 181.4668.90
I agree. Today I coded Node.js, React JavaScript, Scala, and Go. I call it a hat trick.
Thanks for your thoughts :)
Well, I think it's good to focus on being a "python dev", or a "go dev". Over time one might become a "python dev" and a "go dev", and a whatever else dev. It provides a focus during that period of your career. Each language has a style, idioms, a way of thinking and a culture attached to it. By embracing, say, being a "python dev", you immerse yourself in that world and become a part of it. You become proficient at it. Sure, they're all tools. But it's non-trivial to get yourself to the stage where you're happy with what you write in any given language. For me, it's years before I feel I have a solid grasp on a thing. Between the language itself, the implemention, tooling, libraries there's a lot to cover to do a good job. And sure, computer science doesn't change. But, a developer isn't a computer scientist. Though, they should know some CS, but which subjects in particular seem to hinge significantly on what language they're writing in. A C developer, might be expected to have a far more intimate knowledge of implementing associative arrays than a Python developer.
Who said our hypothetical X dev can't adapt to become something else? I encourage them to try becoming Y and Z devs! They might enjoy Y and Z more. They might even learn some tricks they can bring back to X. I specialized in my career, though the specializations changed over time, it has worked well for me. I look for jobs that intersect with my specializations, then end up ranking quite well because frequently interviews will focus around specific technologies. Perhaps my opinion is at least partly driven by the common attitude in the work place that developers can pick up languages on the job - so they do, and for the first six months much fun is had. The amount of undefined behavior one might incorporate in even a short C program has left me with a sense of wonder as to how it ever ran in the first place. And while we're on the topic, we should give a nod to all those .py files with Java inside! Now my previous post started off with "Well, I think...". Maybe you're right, though I'll keep going down my path of focusing on specific languages, I'm enjoying it!
I'm unsure if there are any other issues, but specifically to the point of exiting the server gracefully: Your program needs to appropriately handle SIGINT (the interrupt signal) as per https://golang.org/pkg/os/signal/ this documentation. When you get SIGINT, you need to call Shutdown on your server as per https://golang.org/pkg/net/http/#Server.Shutdown this documentation.
I’ve run into this before when vendoring pkg/error and then attempting to assert on its types from a package that also vendors it. The two are different types, because they come from different packages. There are different solutions to it, but the easiest it to avoid vendoring in libraries and only do so for binaries. 
What do you mean by "locks the GUI"? What are you running it in?
Possibly because you are starting the server before handling the error from `net.Listen`. Check for the error first and then perform other functions. Also, you are not checking the error from `http.Serve`. Hence, the code does not know of the cause of a failure in case the call failed.
Here is code I use that handles SIGINT. This is using TLS. Try using this approach in your code. // interrupt stop := make(chan os.Signal, 1) signal.Notify(stop, os.Interrupt) // server server := http.Server{ Addr: ":1337", TLSConfig: nil, } go func() { if err := server.ListenAndServeTLS("server.pem", "server.key"); err != nil { log.Fatal(err) } }() &lt;-stop server.Shutdown(context.Background())
&gt; Who said our hypothetical X dev can't adapt to become something else? I encourage them to try becoming Y and Z devs! They might enjoy Y and Z more. They might even learn some tricks they can bring back to X. You don't adapt by becoming a "X dev" in exclusion of every other languages, that's childish and shortsighted.
I get what you're saying and disagree less wholly than some, but I do think the difference between a browser or OS (which has one user for the application) vs a modest web server with hundreds of simultaneous users is a bit of a jump. But your stuff is configurable and you've adjusted when people have disagreed with merit, so I don't see a reason to complain. Your software is still very nice. I also disagree with your business model when I feel like Nginx is only a bit less convenient but far cheaper. But then, you aren't licensing the project--just the binaries which come from a build server (which is much more expensive to maintain than, say, a static site). So yeah, I disagree with some things, and sometimes I mention them, but usually it's to point out that they are non-issues. People need to stop caring so much about small things in tech. :-p And need to start appreciating smart people that add a lot to the tech community. Thanks.
Awesome, I was just using the news API for a project. One comment I have is I would remove log.Fatalf() as this is meant to be used as a library and calling os.Exit() will be problematic.
Stuff like this: [https://github.com/jinzhu/gorm/issues/1407](https://github.com/jinzhu/gorm/issues/1407#issuecomment-325438115) I'd consider [https://github.com/go\-xorm/xorm](https://github.com/go-xorm/xorm) instead.
Yeah that's why most companies don't care what language you make their 1-hour assignment in, as long as you solve the issue. Problem solving, data structures and algorithmic thinking translates to every language out there. 
Sounds good.
speed
Thanks, friends. I will give it a try.
I'm the author, all comments and feature requests / PRs are welcome.
I value a different focus and approach to yourself. My position is an opinion, as is yours.
Came across a really fun card game that teaches programming - Potato Pirates. My kids really enjoyed it! http://www.potatopirates.game 
I'm pretty sure that what /u/gcstang ment. All of them are one Intellij family of products build on top of IDEA.
You can have all the functionality of PyCharm\Goland and other products in IDEA. 
Your s much better, cleaner. No duplicated code. 
I apologize if I come off as rude, but I honestly do not understand this statement &gt; But please don't misuse it as your personal playground just because it's successful as a project. Why not? Its his project, created on his time, with his resources, which he has graciously provided without strings attached in such a way that allows you to build on his work in a way that fits your views. So once again, Why cant he use his project as his personal playground? Why should he be responsible for the needs or wants of people, who aren't a part of the project? I don't always agree with mwholt either, but I think we do ourselves a huge disservice when we fail to acknowledge a gift freely given no matter how imperfect.
Thanks! I still need to add unit tests to it though
Weird, I wrote something like this three days ago. https://github.com/BenOvermyer/news Mine was just built to scratch an itch, though, not for anyone else's usage...
I like Golang simply for it's ease of static compilation and lack of dependency requirements on any computer I send it to. The ease of cross compilation was a deal maker: ```golang GOOS=windows GOARCH=386 go build main.go ```
Not really, it's an IDE that can run pretty much anything
Some rather specific reasons: - to use the best-maintained API clients / libraries for apps written in Go (e.g. Kubernetes, Prometheus, Docker, Terraform) - to read Kubernetes (Prometheus, ...) source code when the docs don't tell you what you need to know. - to write portable CLI tools in a language that is not C and not exotic
`jsonfmt`? `jfmt`? Not particularly pretty, but it manages expectations quite well!
it reads all of the request body into memory, this is unsafe
Go, like Python, is very easy to learn, you don't need to ask yourself if you must or not, just do it and see...
&gt;Nginx is only a bit less convenient but far cheaper What? [https://www.nginx.com/products/pricing/](https://www.nginx.com/products/pricing/) Nginx is \_much\_ more expensive. Nginx is \~$200/instance/month whereas Caddy is $25/instance/month
It's right in the article. There's a section called "Benefits and Goals of Telemetry".
It requires the Go team to ship it in the language. I think this is the tracking issue: [https://github.com/golang/go/issues/9671](https://github.com/golang/go/issues/9671)
You aren't comparing apples to apples. The Nginx open source free download offers at least as much as Caddy (but with less convenient defaults and more config) but Caddy doesn't make a free download (usable for business) available. I've never worked for a company that paid a penny for Nginx. Sure, I wish they had contributed back, but that's not my decision. Meanwhile, for freelance work, a lot of clients in the small business sector will jump for $5 / month hosting and thing $10 / month is too much. It sounds crazy (it is), but there are thousands of Wordpress devs in town that can get their small websites with cheap unmanaged hosting as a selling point. They would never pay $25 for one bit of the stack when Nginx is free. It's impossible to sell a non-technical person on the difference. And I love Caddy, so I felt very strongly that small businesses (the type that hire Wordpress designers and pinch pennies) are the perfect small business user for Caddy to build a big base. Sure, it's giving the product away for free, and you need to support the project, but a bigger company that thinks $25 / month / instance is pocket change also has a full time in-house sys admin who can configure Nginx just as fast as Caddy. The best market for Caddy (Wordpress devs and people doing freelance for startups with one to five employees) is lost because there is no way to run it for free.*** Therefore, I don't think Caddy will ever get critical mass because it avoids the masses! It might make more money when the project is small since there won't be many large corporate backers paying, but I don't think you'll attract the large corporate backers without the noise of thousands more small devs in the community. *** You won't get a this crowd even considering for a second building their own binaries. I DO think you could sell them on a free business-licensed build with no non-core plugins, but not on them building it themselves. Half the Wordpress people I've met probably don't even know how to install PHP on their own computers! :-p
I have no specific familiarity with this package. That said, GUI frameworks in general tend to have strict rules for what should run in the same vs different threads (in this case, goroutines), and you need to follow them. (For example, Java Swing runs its own event loop, and you need to run most of your things off of that thread, except for anything UI affecting, which you need to dispatch onto that thread using specific helpers.)
You don't even need to build it yourself though. Just need to use a source where it was built somewhere other than caddyserver.com. Docker images for example, or package repos that build from source. Scripting that is really easy and it's already been done.
yes it does, it will multiplex goroutines over avaiiable cores.
Thanks, but I just remembered. I'm actually planning to add support for yaml as well. StackDriver/gcloud has a lot of those and `pretty` seems more "generic" a name. :)
Middleware for compression implementation is broken. For each request, echo server will create new gzip writer [1][2]. Also, there is memory leaks somewhere, that we can't track. If you run `pprof` every `x` minutes the number of heaps will always increased even if no request. Default server is without timeout [3], it can be customized, but it's bad practice, even nginx and other well-known HTTP server have default timeout values. I will just stop there. I don't want that guy who always complain but showing no code/PR. I do, sometimes, only if worth it. [1] https://github.com/labstack/echo/blob/f867058e3ba4fa4504e3ca976b31012db3ce1555/middleware/compress.go#L72 [2] https://blog.klauspost.com/gzip-performance-for-go-webservers [3] https://github.com/labstack/echo/issues/590
What you say makes sense for other projects that target developers, but Caddy started off with the aim of targeting people who didn't feel like they could handle the complexity of nginx and apache. For example, it talked about a UI for administration and simpler config and sensible defaults. This makes a tool accessible to the hordes of Wordpress developers developing for small business. I generalize a bit because of how many Wordpress devs / teams I know personally, but they all work on live PHP environments on their servers and have never heard of source control. Telling them they could build Caddy from a script somewhere would get them telling me they don't need the complexity on such simple projects. It's easy to forget this part of the market because as experienced devs, we often discount people making sites who don't use source control or understand how to run a script or ssh into a server, but Wordpress and the somewhat non-technical developers that use it control the majority of small development projects. You can hire a Wordpress developer in the US for a fifth the cost of a .Net or Go developer, and that's partly because the barriers to entry are lower. A Wordpress dev is sometimes only configuring plugins, all in a GUI, deploying with a gui, etc, and they aren't going to discover an alternative to caddyserver.com easily (and certainly won't have heard of Docker).
Ahh i see. i'm new to golang so i'll definitely be fixing it up a bit. thanks though
I'm using dbr right now, and while it's kind of nice to work with, you often stumble and have to write raw sql anyway.
I'd put type safety as first.
I mean, Atom is slow as hell, but I wouldn't say GoLand is fast (judging by PyCharm, might not be entirely the same).
If you have as many -- or more -- goroutines running and they're all busy, you'll completely bake the CPU. :-)
Actually it's fine to leave main.go in the root of project while it's only a single binary so far. It's idiomatic to have a "cmd" folder when you got multiple binaries.
Yes. You can call ListenAndServe in a goroutine. Make sure to check your errors. You should still create the server in the main goroutine so that you have a reference to the object to shut it down. But the blocking call to ListenAndServe can run in another goroutine. 
what do you use it for?
3 good reasons to learn go: 1. it's trendy 2. it's a typed language, which is a good thing to have experience with 3. it's easy to learn
Changing the cookie did not work for me. But after commenting out the OAuth.popup(provider) block and instead call only openingScene() worked.
Our backend is in Go and frontend is in Typescript + React, we often had to manually type out the interfaces in TS to match the backend. I was in charge of that, so instead of typing out 30+ structs by hand, I wrote this in 3-4 hours. The plan is to eventually move to something like GopherJS but that's for v2.0 or v3.0 of our product.
Using your "toolbox" on Ubuntu (Fedora, Arch, whatever) is a joke. We Linux users have unified approach for such kind of tasks and we don't need alien-looking memory hungry Java stuff in the background. Google supports 3rd party repository for their Chrome, Slack technologies supports 3rd party repository for their Slack, etc.
[removed]
&gt;stop := make\(chan os.Signal, 1\) signal.Notify\(stop, os.Interrupt\) // server server := http.Server{ Addr: ":1337", TLSConfig: nil, } go func\(\) { if err := server.ListenAndServeTLS\("server.pem", "server.key"\); err != nil { log.Fatal\(err\) } }\(\) \&lt;\-stop Your code does not work for me. The server still continues to run!
Yep, that worked! Thanks so much! The stop function doesn't work though, I send the signal and the server continues to listen!
That is because your startStop function has a bug. You were always creating a brand new server instance every time. Calling shutdown on a completely new server doesn't sound like it would have the intended effect of stopping the previously one, does it? ;-) 
How can I fix this?
Atom in 2018? Atom has been completely replaced by VS Code
I was using it for Python data analysis when I first started programming because I liked using the Hydrogen plugin. Despite that atom can be slow, I never found it so overbearing that I thought to switch. Is vscode really that superior that you recommend switching?
Yes
I honestly don't know a single person that hasn't switched to VS Code over Atom, it's honestly that overwhelming. Try it out and see what you think :D
Yes! I personally think it is a great first language, the only thing that would confuse beginners are pointers. But you can still use Go without that. Python may arguably be a little bit easier to learn because of the lack of pointers. But just getting your feet wet with if statement, for loops and simple logic any language can work. Go in my opinion has a great introduction tutorial that will help anyone of any skill learn Go. https://tour.golang.org/welcome/1 
No. It teaches you bad programming practices. It’s good for one thing - readability. It doesn’t go into how things work. The point of your first language is to learn how things work. I always recommend C. Starting with the wrong language can seriously affect your future learning curve. This is going to be unpopular. However, I’m creating programming languages now, and the ones who started with python are writing web apps. Sorry, not sorry. 
I'm going to incur the wrath of the circlejerk and say, no. Go's a good language but not a good *first* language. If you learn Go first then the typical things that other languages do are going to seem weird, and they outnumber Go in the programming world. Go has only one loop type. It has type safety but you have to deal with it in an odd way. It doesn't handle exceptions the way other languages do. Now it has good reasons for those things, but if your intent is to learn how to deal with multiple languages, it's not a good teacher because it's so up its own ass with the 'right' way to do things. It would be like learning to drive in a Tesla, then having to rent a Ford Focus and freaking out about "starting the engine" and "filling the gas tank". Start with Python or Java (or C++ if you're feeling masochistic). Not Go. They're easier to get your feet wet, then when you've got some varied experience, learn Go.
I think it's important differentiate between programming and computer science. If your goal is develop software, having good practices is better than knowing how it works low level. 
You might get a more reasonable answer if you ask in /r/programming the answers here are somewhat biased. I think Go is a good language to start, but you should definitely switch to something like java to widen your horizon after a while. Java can be fun and teaches you so much interesting stuff like generics, inheritance or creating your first simple GUI
I'd also say no. You can't appreciate it if you haven't pulled your hair out with another language. I came to go after many many languages. I worked in other languages for 15 years before I found go 4 years ago. It made programming fun again. I'd not wish that someone programs for 15 years in other stuff before go, but it's like living in a world where you have to buy tapes, then CDs, then collect hard drives of mp3s, and now you can stream any song at any time.
&gt; the typical things that other languages do are going to seem weird So? &gt; and they outnumber Go in the programming world. Who cares? The best language for you to learn to code in is the one that makes the most sense to you. I recommend you lick them all and bite hard on the one that tastes best.
As a language I think it is a fine option. Some people started with BASIC, some with C, some with Javascript, each group had their own struggles. I think Python is probably the better option though, there's more never-programmed-before level learning resources and a much greater selection of mature libraries.
I think python is the best first language. It's duck typed so you can move fast and get a feel for how common patterns work. It's got functional aspects, traditional OOP aspects, lambdas etc. It's very well rounded. You can jump directly from python to java or any other modern OOP language and do just fine. I don't think that can be said of go.
There has to be a better way to phrase that 
This is pretty much also why I think Ruby is a horrible first language. It maintains a complete set of it's own idioms that do not translate to nearly any other language.
&gt; It’s important to know that starting with the wrong language can seriously affect your future learning curve. I believe the phrase is "citation needed"! Kind of surprised you recommend C yet suggest Go would be damaging. In terms of abstraction, complexity hiding and being able to split problems in fluidic ways, they've felt in the same ballpark to me - Go feels like a modernization of C for me. Sure, C lets us do arbitrary things with memory in a way that more recent languages do not - but that is due to lessons learned from the enduring damage C's unsafe nature has caused. C does have decades of learning resources on the Internet, though, and is widely spread and will be for a long time. I like C, I think it would have been a fine - though at times frustrating - first language for me. (Never received a SIGBUS while learning Python!)
Go is a language that is only fully appreciated once you have experienced the ugly side of other languages, like C++. A lot of it's beauty and elegance can only be appreciated after experiencing the difficulty associated with typical OOP. So if it is your first language, it may spoil you and you may find it hard to pick up more languages. I'd recommend Python. You'll learn about one nice way of doing things, but you'll see you're limited by performance, concurrency and runtime dependencies. That's when you're ready to try Go. If you want to start at the low level, start with C, then C++ and then Go.
Bad advice. 
&gt; The core of good programming comes from abstractions, complexity hiding and being able to split problems in fluidic ways. … The point of your first language is to learn how things work. I always recommend C. Are you familiar with the old robot expression “does not compute.” Hate on Go if you want but then don’t pretend like C is any better. 
I learned BASIC at age 8 and I didn’t get a job programming for another 22 years, so maybe he has a point. 
Seriously. Start trying Go. If it sucks and you get stuck, try Python, or R, or Lisp, or BASIC, or… It does not matter where you start, just where you end. 
Not sure if this helps you. I needed to connect to a db through socks5 //InitDB starts the db connection func InitDB(c *Config) (*sqlx.DB, error) { fmt.Println(c.DBsocks) fixieData := strings.Split(c.DBsocks, "@") fixieAddr := fixieData[1] authData := strings.Split(fixieData[0], ":") auth := proxy.Auth{ User: authData[0], Password: authData[1], } dialer, err := proxy.SOCKS5("tcp", fixieAddr, &amp;auth, proxy.Direct) if err != nil { fmt.Fprintln(os.Stderr, "can't connect to the proxy:", err) os.Exit(1) } mysql.RegisterDial("fixieDial", func(addr string) (net.Conn, error) { return dialer.Dial("tcp", addr) }) cnx := fmt.Sprintf("%s:%s@fixieDial(%s:3306)/%s?allowOldPasswords=true", c.DBuser, c.DBpass, c.DBhost, c.DBname) fmt.Println(cnx) db, err := sqlx.Connect("mysql", cnx) if err != nil { fmt.Println("Could not connect") log.Fatalln(err) return nil, err } fmt.Println("Connection to db succeed") return db, nil }
I think Java or Python are better to start out with. Go is well documented, well supported, and easy to learn, but its quite revolutionary in a lot of ways and it might be difficult to understand other languages if you first get used to the problems that Go solved. 
Having your project code at the top-level alleviates the need to put package level code into sub-packages. Or otherwise you have to dump everything in main package. Also, tools like godoc explicitly look for a "cmd/" folder and will think of that as a command. Therefore, your documentation becomes more natural.
I personally think it could be a fantastic first language. My favorite proof: https://www.youtube.com/watch?v=fZh8uCInEfw.
I'd say start with C++ or Java
I tend to agree with you. But there does exist some positive points of learning Go as the first language: 1. Unlike C++/Java, you don't have to handle too much bureaucracy like setting up a build system (Makefile, CMake, Ninja, Gradle, Maven, Ant). Granted, you don't have to bother them if what you want is not beyond a hello-world or some algorithm puzzles. 2. In Go, learning by reading others' code is far easier, even when reading into the standard library. That is not quite possible with say, C++ (library code is only for the "experts"). 3. The specification of the Go language is *actually* digestible and useful for programmes. Unlike C++, its primary audience seems to be the book authors and compiler implementers.
To be fair.. ruby is a horrible language regardless
As someone in the field for over 2 decades and having worked with c, c++, prolog, pascal/delphi, basic, assembly, python (a wee bit), perl (as little as possible), ruby (run far away from this one), java (for the past 20 years) and Go (learning still), from my experiences, despite not having a lot of day to day with it, python is probably the best language to start out with today. As many said, Go does a lot of things right.. and it is still a very new language with a long ways to go. Java, while a fantastic language for most things, does have a lot of painful idioms and crap to deal with, even 20-odd years later. It has gotten a lot better, and with the new 6 month release cycle I suspect they are trying to keep up with the newer languages so as not to lose as many people to them as they have been. That said, Go has a lot going for it, and while I would say it is not the best language to start with, it wouldnt hurt if you can grasp it as you work through it. Like other said, languages like c/c++/java and even go to a lesser extent all have similar syntax, concepts, etc. Go has taken a lot of the good parts from various languages and made them better... but without truly learning/appreciating those parts in other languages, you would miss out on the "oh wow..that is so much better" that so many of us are or have discovered with Go. That doesnt mean you should hold off and learn another language just so you can come back and enjoy the good things Go brings to the table. But python, maybe even Java to some extent, are a bit easier to learn out of the gate. 
Ruby is a bad platform, and I agree that's not the best first language for a working engineer, but I have to say I think it's a beautiful language. I'm not even talking about the clarity of its syntax (which IS nice), but the consistency of its object model. It's basically the perfect OO language, imo. It's not too far gone like Smalltalk where you can redefine an integer, but it's also closed on the `#class` call, has useful eigenclasses, and is expression-oriented. I think those are gorgeous language features.
Absolutely not
Or use a JetBrains IDE if you want to have the features available months or years before vs code copies them over.
better advice, get in a good school and learn the whole science, not worrying about which language, master Java and OOP, learn the science behind databases and get good at SQL, learn algorithms and data structures, learn about testing, learn business and systems, understand some linear algebra/discrete math, get a whole rounded structured education... there are no shortcuts to doing this properly, it takes time but after you dedicate that time to learn and learn properly, you are much further ahead and much more valuable 
Looks like a great first start, I would suggest reviewing how you are going to be handling errors from the API. I would never want a package to log.Fatal and would much rather it just passes me the error to handle it how I see fit. Also please don't forget that json.Unmarshal returns an error and it's important that you handle that error. 
Start with Python. Or better yet, if you are new to programming, try Scratch.
Yes and no. I disagree with /u/pobody regarding the LACK of features being a negative in learning with Go as a first language. To me, the best reason why Go *would* be a good first option is the limited surface area. A 'for' loop isn't all that different from a 'while' or 'do while,' and realistically the other forms are simply a formatting change to things you can do with a single loop structure. Better to learn the concept of a loop in isolation, and *then* learn variations of form. So I'm general, the simplicity of the surface area for Go is a huge plus in being a first language. That said, I don't recommend starting to learn programming with a statically typed language unless you are coming to programming from electrical engineering (as hobby or more). I find that there's two approaches to learning computer stuff - low level upwards through abstractions, or from higher abstractions down to lower levels. Neither is "better" - it's more just where you are starting. Most people only know about computers from the highest levels of abstraction (usage of software). So I think for these users, needing to learn things like "passing by value vs passing by reference" gets in the way of learning the general idea of logic structures and solving problems. JavaScript used to be a good option as a first language (even though I think it's a terrible language) because of how quickly you can "do things" with it, but now the tooling around the language is such a steep learning curve I wouldn't recommend it. Which leaves Python. It's simple to get up and running with, extremely powerful, and can be used for all sorts of tasks even once you've learned other languages. And perhaps most of all, there's a standard format for how the code should look that most code conforms to, so it's easy to read other people's code (one of the huge benefits of Go as well). In my opinion, anyone who isn't an electronics hobbyist should start with Python as a first language.
What doesn't help is that the general state of Ruby documentation is usually lacking so you have a ton of idioms with no reference. 
Go is a good first choice. Java mixes too many concepts, C++ is far too complicated, C is unnecessary wired, so don't go with it either. Python might be another option, but it's a scripting language and therefor much slower than Go. Beside those language one of the most simplest and powerful languages is Lisp. But since the tools assume some level of computer knowledge, it might be better to not start with it. Otherwise I would say that Lisp is a must know language, it is simple, pragmatic (something that can't be said about a lot of programming languages) and super powerful (no other language matches Lisp in this regard).
Hey, Paradiesstaub, just a quick heads-up: **therefor** is actually spelled **therefore**. You can remember it by **ends with -fore**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
[removed]
delete
Class inheritance turned out to be a pretty bad design pattern in the long run. I don't see why it's a good idea to teach it to absolute beginners.
See shadowsock protocol
If just starting out programming, I'd not worry too much about what the language is. I'd just go to the local University/College book shop, and see what they have available for complete beginners in programming. Something that will hold your hand from install to doing more complex things. That'd be the fastest way to get from crawling to walking without falling over too much. Worry about running later :) Once you've gotten your bearing in one language, learning another is not too complicated. As for the question itself, is Go a good first language? Yes. It is different though. If all you want is to have fun with programming, then certainly few languages can compete with Go. 
Isn't that criticism usually brought up regarding Rails rather than Ruby itself? 
When I was learning to program on the 8008, I had to learn Machine Code. Macro Assembler was so much easier. Then came Forth and I could do any thing but no one could understand my code. Back in the 80s I recommended UniComal for first time programmers, similar to Pascal but with a run time compiler, each line had to be correct before going to the next. Today, I recommend Scratch for first time programmers. You create a program by dragging code to a flow chart. Great for kids. Recently I was tutoring a Computer Science student in C++ who had written a 1k line program for a class assignment. To check her results, I wrote a two line bash script that used sed and awk. C++ has the advantage of having some mature GUI libraries. If you are going to be a Web Dev then forget the other languages and just learn Go, TypeScript, HTML5, and CSS3. The problem is that you will need all 4 in today's market, plus Kotlin if you do Android apps, PHP if working on legacy sites, Python if you have need for dynamic typing and it is easy to learn, most of the financial institutions use COBOL. There are a lot of different languages out in the wild, nearly all of them are the best solution for a certain type of problem. If the only tool in your tool box is a hammer, every problem looks like a nail. Every language gives you a different view of the world. Learning new languages means learning new ways of thinking. Today, I prefer programming with Go but it is not always the appropriate solution.
I've been writing go for a bit now, but this is my first actual library. I really tried to conform to all go standards (gofmt, godoc, ...). But it's possible I missed something. Please point that out so I can adjust and improve.
Completely agree. For a first language, Python will come much easier to noobs than Golang for sure. 
I don't really know what you mean by 'closed on `#class`' or what is particularly useful about eigenclasses. Could I trouble you to elaborate somewhat? I've never truly delved into Ruby.
For me the magic is "where the hell is this variable (or is it a function? Can't know without digging into it) Defined? Is it an included module, a superclass, or a superclass of a module.
There's a beautiful sculpture inside every slab of marbel. However if you're not Michelangelo it's just a damn rock. There's beauty in Ruby, but the problem is the rest of the language around it.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/docker] [GCC-compiled executable doesn't run my C function in Alpine container.](https://www.reddit.com/r/docker/comments/8j3pss/gcccompiled_executable_doesnt_run_my_c_function/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Another thing that bothers me is the incessant redefinition of terms in Ruby. Eigenclass is functionally a singleton, same as any other OO language. While the implementation may be more "pure" than others, to the end user there at rarely differences that require accounting for. //End poinless rant.
No. Go has a lot of promise, but it lacks a lot of things well established languages have that make them easy to use. These zealots like to believe that isn’t true, but it is. Learn Python. It’s super easy to get started in, and that’s the whole point. The more you code, the better you are. Because Python is so easy, it will give you the confidence to build things. It has its limitations, but you won’t feel that pain until you’re very experienced. Eventually you should transition to JavaScript, because it is the most popular language. Everyone needs to know JavaScript to be a web developer, backend and frontend. Maybe after you have a strong grasp of Python and JavaScript you should transition to Go.
Sure it should be slower than writing raw SQL and mapping to structs by hand. Any ORM will use reflection, and that means a performance penalty, you should be aware of that. That said, I don't think Gorm will be too slow for most apps. I've used it without any performance issues. It should be worth if productivity matters more than performance for you. Try not abusing it, though, you can always write raw SQL when you want, and still use Gorm for most queries/inserts/updates. I don't recommend Xorm, Gorm is much more stable.
The language does not enforce use of short _variable_ declarations. Anyone is free to please her heart and write the readability-unhampered version var myObjectFactory objectFactory.ObjectFactoryObject = objectFactory.NewFactoryObject(42) 
stat (2) on Unix does not open the named file in its argument. `os.Stat` can use that sycall. OTOH, the argument of fstat(2) on Unix is the opened file ID. `f.Stat()` can use that syscall. No idea about other OSes.
Congrats. I use Colly because it has great docs and everything about the developer experience is polished. Colly's missing a couple of things but I can only see it getting better in the future.
By "closed on `#class`" I mean that every entity responds to the instance method "class". This leads to confusing utterances in sentence form (such as "The class `Class` is an instance of class `Class`), but it leads to useful manipulations. Eigenclasses are useful because they allow me to do runtime manipulations of an object's feature space. I can open up an object at runtime and manipulate its methods and attributes dynamically. This can let library developers do extremely powerful things while still exposing very simple API's to application developers. It's basically the bread-and-butter of Ruby's metaprogramming model.
That's not quite right, though. While the eigenclass *is* a singleton (so much so that the preferred phrase in the Ruby community is "the object's singleton class", and I prove myself to be an old fuddy-duddy with the use of "eigenclass"), to say it's merely a singleton is inadequately descriptive. In most cases in Ruby, my class definitions are also singletons. Non-class modules are always singletons. `TrueClass`, `FalseClass`, and `NilClass` are singletons. But none of those are eigenclasses (although they all HAVE eigenclasses). Eigenclass are a kind of singleton: they are certainly singletons, in that the object for which it is the eigenclass is by definition its only instance, but it's a singleton that gets generated at runtime for a specific object and has certain specific properties and has a certain well-defined position in the method resolution chain.
Very cool. I'm an old C dev that uses mostly python now and manage multiple teams. Been looking at Go but haven't been compelled to use it over other languages yet. This seems like a good explanation and reason to use in devops, so thank you for they post. 
Where I work we had this exact discussion. In the end for us the performance hit of gorm was big enough that we wanted an alternative. So we ended up writing our tool (https://github.com/LUSHDigital/modelgen) which can generate models and migrations based on your database schema. Pair it up with a package like https://github.com/golang-migrate/migrate and you've got a very nice pattern. The tool will generate a lot of convenience methods for performing CRUD operations on your data. Anything more than that and you will need to write some SQL manually. But for us this was a small price to pay. 
Yah... no. I just dont get it I guess. I cant stand perl and ruby reminds me too much of perl. I found the syntax so so different than java, c, etc that it was frustrating to figure out. I do know of people that love it.. but then.. it is a slug on performance. It has gotten a lot better over the years.. especially when using JRuby and a modern JVM... (or is that no longer around?) but otherwise, why people would use it to say provide a REST API and back end db/logic code over java, go, c#, python.. I have no clue. Only thing I saw a splurge of use in was with devops deployments.
All of the information about a file, its metadata, is stored in the directory in which the file is located. The only thing not stored in the directory itself is the file contents. Depending on the file system the directory entry also contains a few pointers to the first N file system extents for the file. If it’s a large file the directory entry contains a list of pointers to the file data, and then a pointer to another extent list.
Okay, so I've got a [link](https://dev.to/quii/learn-go-by-writing-tests--m63) to an article that taught me a very cool feature in Go's testing toolkit: [T.Run](https://golang.org/pkg/testing/#T.Run). You define your test function like so: `func TestWhatever(t *testing.T)` and then within your function you can call `t.Run("someString", func(t *testing.T) {})`. They call these "sub-tests" and it seems like their primary use is for group test results related to each other. You can also use it to perform setup/teardown inside the top level function, and then each anonymous function you pass to `Run()` is a closure with access to your setup values. [This](https://github.com/therealfakemoot/go-quantize/blob/master/test/domain_test.go#L44-L70) is a library I'm working on ( spoilers: it doesn't actually work yet, but I'm getting there ). Of particular note is that the `Run()` call can be nested more or less arbitrarily deep. I've used `Run()` to group together results for each "row" of my "table driven tests", a concept written about at great length by a variety of sources. Each Domain has multiple aspects that need to be tested, so I've got a `Run()` call for each Domain. Then within those tests I've got more `Run()` calls to categorize the difference facets of the Domain functionality I'm testing. The results end up looking like [this](https://gist.github.com/therealfakemoot/47c468b09fc324bec276c7c026625cd5). Now, for your question of "global" setup. I'd argue that you probably don't actually want a global setup, in the sense of the same setup being done for the *entire* test suite. The best solution is almost certainly to factor your setup code into a function, and call that function at the beginning of your test functions. [Here](https://gist.github.com/therealfakemoot/77583efa1e389c64b23d3c70ba2a4bfb) is a rough draft of what that could look like. I'd advise against doing something that's truly "global" because IF this setup truly is universal and identical for all tests, you probably want to group them all into one test function via the `Run()` function. Additionally, it's very possible that in the future, that setup *won't* be identical between all your test functions. Having separate setup/teardown functions will allow you parameterize the setup, you can pass in whatever values are necessary *per test*. Some day, you might want to test against YAML vs JSON file formats, or test files with different quantities of data in them ( testing the memory limits of your algorithm or whatever). You can even do some neat stuff with closures [like so](https://gist.github.com/therealfakemoot/0064b2c71efffba5615d724ac4767807) to make cleanup even easier!
I'm sorry, but I think you are maybe misreading the documentation. What you did there was initialize the PRNG with a cryptographically secure seed. That does nothing to make the PRNG itself cryptographically secure. OPs solution is actually good if you need secure numbers, though it is slower.
This is awesome, thank you for the contribution.
I think there are a huge number of assumptions happening in this thread. In general the response "Don't do Go first because it's so much easier and better than everything else" seems insane ... but if you assume that you'll have to end up programing in Python/Java/Not-Go eventually then maybe there is some merit in not being shocked by how different things are. There certainly are concerns about the fact people mostly learn languages to communicate and while I think Go will be one of the major languages in 10 years, it's still not going to be the biggest no matter which platform you are on.
Then I revert to my original comment: "pretty" is rather un-descriptive, IMHO. It doesn't really help me remember what it does. `strmfmt` perhaps? 
It's definitely a readability/writeability tradeoff. Personally, though, I'm a large fan -- I really appreciate the convenience, and I find it very easy to just use godef to jump to the initializer definition when I'm unclear about what the type is. It's still a whole world away from dynamic typing where you might have to run the program to figure out the type, and even then, you might not know all the types the variable could be, because it could depend on input data!
I just tested the integrity and compatibility of glibc in Alpine as it fully supports libc.musl. Because I don't want any dependencies I went on compiling statically. Gcc compiled executable works just fine in shell but is having problems when run directly. I don't know why.
Why not rewrite the hot path of your application that is causing you the performance problems utilizing GORM then benchmark, profile, and see if it provides the improvements that are necessary or if it introduces any problems in the process? This will also prove that Go is going to actually improve on your problems over Node, or if the problems lie elsewhere.
+1 for Python. It's nice to learn logic without fighting the language. 
What functionality are you looking for? Some examples from what I saw in the readme: • json: stdlib • validation: lots of options e.g. https://github.com/go-playground/validator • other serialization: protobuf, gob (in stdlib), msgpack etc
Yes. No.
I am looking for a library that implements these functions: * Defining a model field's types * Validating * Converting a model into JSON/msgpack representation I understand that I can do all of these functions with the Go's standard library and some community packages but it would be more convenient if it would be one package like the Python's schematics package. 
Colly is just for web scraping as far I can tell. Yes, if the website changes you'll have to refactor. As far a legality if you abide by robots.txt then you aren't even in the gray area. If you don't follow robots.txt it is a little more iffy but generally fine as long as you aren't scraping enough to be harmful to the site (acting as a DDOS). The general sentiment, and it seems to hold up, is that the crawler is acting a visitor and simply collecting public data.
The [docs](http://go-colly.org/docs/examples/instagram/) advise taking a closer look at javascript pages. Often times they have fairly simple patterns that can still enable you to scrape them. Bonus is that you get much better performance this way as you aren't executing actually waiting on JavaScript execution. :)
I've been using this lately and I confirm that it's pretty great! Well documented, super fast, and constantly getting better.
To let the authors know that you like their work. IMHO it was not the best decision by GitHub to [use stars for both purposes](https://help.github.com/articles/about-stars/).
I want to add some thoughts. The schematics library is really useful tool in the Python world and I can found many fields where I can use it. Tasks in Go also are the same like in Python, so it will be a good library in my toolbox. 
Hi Everyone, I am the developer of Dataviz, visualization library. I encourage all of you students/Cs educators to use it and make interesting visuals. Please do let me know if you have any comments on this or if you want additional features. 
I've used Gorm in a couple of projects so far and I can say that as long as you stick to the basics, Query, Update, Delete, Where, Create, Exec, Raw you should have no performance issues. In other words if you use Gorm as an SQL builder library you should be fine. FYI A better SQL builder in my opinion is "gocraft/dbr". A word of caution, It has been my experience that once your SQL query requires more than a single join you are better off writing the sql your self and using db.Raw (you get zero surprises this way) For migrations, nothing I've found so far beats "golang-migrate/migrate"
Is there a chromeless backend instead of Splash for Scrapy?
That makes sense. I was thinking of a site like zipcodes.com where u can sign up and pay to use their API monthly but instead you pay for a month and then scrape all their zipcode data and store it yourself. After the month you dont ger updates but you now have the full zipcode data in your own db.
https://golang.org/pkg/io/ioutil/
I understand what you are saying. I have been told this before by others. Why cant I take my ready working java or go app... copy and paste it to a new project and get to work on specifics for that project. That is my counter to the whole it's the fastest to market. I am far from an elite coder but I can design build and deploy a microservice with api db messaging service and more in a few hours... in a scalable docker setup. I have that working already so it's simple enough to copy and paste and remove some code tied to my other project. So I am sure others do this and it's not something I just came up with and have no doubt ruby developers do the same. I just dont see how it is any faster or slower. 
If you opened the file yourself, then you already had the name. But if you were passed an *os.File, then you can get the name from it: https://golang.org/pkg/os/#File.Name
God no, not java. It is the worse first language to learn. Lots of hard to grasp concepts for a very beginner, forces to deal with OO which is weird for beginner programs, etc. I've been teaching programming for 15 years now, and always fought java as a first language. Python, on the contrary, is a solid choice, and is the language I would advise to anyone who wants to start programming. (and surprisingly, C++ is not that bad if you really want to get your hands dirty. Stroustrup does a good job at teaching this language in a top-down approach.)
Hierarchy-based, pure OOP is hard to grasp when you have no experience in programming, and quite counter intuitive except in very limited cases. I think, when you start programming, you should stay as far as possible from OOP, then include it when you master procedural or functional programming enough.
The job market is not relevant for a pure beginner. I think it's better to learn and understand basic concepts in, say, 30 hours in an "easy" language, then spend 30 hours to learn an industrial language, than go the hard way, fight the industrial language for 60 hours without fully understanding all the underlying concepts.
On Unix the above is confusingly wrong. You may be confusing a specific filesystems optimizations for the more general theory, but even then it's still not good to say "calling stat on the file actually opens and reads the directory rather than the file" because there is a huge difference between r and x permissions on a directory.
&gt;&gt;It’s important to know that starting with the wrong language can seriously affect your future learning curve. &gt; I believe the phrase is "citation needed"! Not OP, and I have no citation, but experience taught me that starting with the wrong "first" language makes learning much harder. However, C is usually not a good first choice. Pointers are a difficult concept, yet you must learn them to understand arrays, strings and functions, plus the compiler is extremely unhelpful. That's a lot to learn at the same time for a very beginner ! I have seen way too many beginning students burned by C (and by Java, for other reasons) to advise it as a first language (except in some cases, like people interested in electronics / embedded devices in the first place, because they have one more motivation).
I used it to crawl and find invalid links that needed to be changed (due to a change in URL scheme at some point historically) on a fairly large website. The web guy there that was meant to be updating or redirecting said links kept saying it was done, so after that initial crawl I could use a simpler script to visit and get status codes for those urls, and email him the currently missing ones with very little time from me.
I think crawlers aren't allowed to login if I remember correctly.
Sure, I can see that. And if that's the tool suite that you are personally the fastest and most efficient with, fuckin' go for it! We're all Turing-complete out here! We really are talking about edge-case and final-mile kinds of analyses here.
Hi Bradley, Memviz certainly was an inspiration for this project and I really admire all the work you did for it so thanks a lot. As for the advice about growing, I think that is certainly a very true. The heap gif is about taking elements away from the heap one by one to show the minheap property. At least for array implementation when you take out the min there is a lot of re\-arrangement, so it's hard to show that but for many other data structures it's certainly possible. Similarly even for heap, when we try to grow it from scratch the un\-affected nodes wouldn't change place. Thanks again for your work on Memviz. 
Have you had a look at [https://github.com/stretchr/testify](https://github.com/stretchr/testify) yet? testify, apart from having really nice assertions, offers test suite support. You can define Before/After functions that are automatically executed before each test in the suite... as well as BeforeSuite/AfterSuite functions for more "global" initialization and teardown.
Go is a great first language. Everyone's saying "learn Python first". Well, I did that and it set me back years. Here's why. It's really easy to write scripts in Python that are useful to just you, but it's really hard to share you code with other people. With Go, you can cross compile a static binary and put it on any server and it _works_ and it's _fast_. Compare that to something like setup.py? It's a nightmare. That's binaries. With libraries, all you need to do (at first) is push to github. Now you've published a library. Amazing. Python has a reputation for "batteries included", but that's a context from 1991. With Go it's more like "rocket engine included". You'll learn more faster. For instance, almost all of Go is written in Go. You can dive deep into the source code of the standard library, or any library. In Python, you will either hit a C binding, or you'll be reading some really wacky meta programming stuff. Readability is really important. Consistency is important. Beginners want to write websites. Well, in python that means Flask or Django. Those frameworks are really opinionated and actually hard to understand. They're optimized for advanced users, not beginners. In Go, the net/http library is built in, and it's actually really good, and _runs production sites_ for many companies. Also: you are actually learning http, _not_ some And finally, when the new programmer is ready, Go can give them the power to do _real_ async/concurrent programming. Unless you're doing a lot of complicated data analysis. Use Go. I would pick it over any other language mentioned here.
He asked if Go was a good language to learn to program in, not which was most popular. Which language is the smallest part of learning to program, IMHO.
I'd say you are comparing two very different things in the "web" paragraph. No one is writing websites with go's standard library. Backing API's for a javascript app maybe.
That's a fair point. It can do both, but is optimal for apis.
Sorry I misspoke slightly. According to Advanced Programming in the UNIX Environment, section 4.14, the i-node contains all the information about a file. Most of the information returned from the `stat` call is obtained from the i-node. The directory only contains the base name of the file along with the i-node pointer.
Execution speed should be way down on the list when picking what language to learn with (not to be confused with "learn to"). Both go and python are relatively quick to start (from code) and thus great.
Found this and it's nice for automating bash. https://mholt.github.io/curl-to-go/
Very nicely done! Visualization helps with debugging too - yesterday I ran into a bunch of problems with a freelist of memory blocks and I wrote some throwaway methods to generate dot-formatted svgs to visualize. I really like this library!
I Read your Post and now I really agree but just thought it was funny they posted a question and everyone in /golang sub says not this learn golang. We are a different bunch I'm guessing.
Thanks a lot. Do try it out.
I've been writing go for awhile now, this is my first public application. Any feedback welcome :)
[removed]
I think you've proven my point here. Unless you're on the ruby core team, it's not a distinction worth making, yet if you Google "eigenclass" you get a ton of people posting about them... But only with regards to Ruby. The concept is not unique to Ruby, but referencing them as such is a unique idiom to Rubyists, which is what bothers me - it makes the community less approachable due to the preceived snobbery.
I would not recommend rewriting any code in another language as an early solution to performance problems. I would do many many things before rewriting a service. We use it in production. It’s fine. I don’t use it for automated migrations. 
I did (at first), but as we are very likely operating on the same slice as sort because it needs to be sorted anyway, we get a name conflict for 'Less'.
Is there a plan to integrate colly with something like chromedp? General question - is this even desirable? I'm using chromedp + goquery, I'm wondering if there's any benefit from switching to colly.
&gt; The like function of it is just a footnote Indeed, based on the position (last) and wording it can be considered as "footnotey". Anyway, my point is that stars can only show which repositories are *popular* (for whatever reasons) but not which ones are of high quality. (My first comment fails miserably at arriving at that point.) I think this applies in any case, whether GH stars are considered bookmarks only or dual purpose flags.
One should note that the OS doesn't have to wait upon issuing the kill signal for the process to do cleanup. Any function shouldn't be relied upon to be called or fully executed if this signal is received. 
What do you want such a plugin to do?
On which signals this happens? \(for examples signals that are sent via `kill --signal`\) Are all of them like this or a few special ones? Is this a corner case or the common case?
As per usual, good commentary on HN: https://news.ycombinator.com/item?id=17061713
&gt; That does nothing to make the PRNG itself cryptographically secure. Using it to generate 64 bit numbers is antithetical to a cryptographically secure PRNG. There's a reason `crypto/rand` doesn't provide that API and it's not "the Go team couldn't figure out how to generate int64's". Doing something like this is an example of security theater: It may look like it makes intuitive sense and it adds significant cost but it doesn't do anything to actually improve security in a meaningful way. If you need cryptographic security, use `crypto/rand`. If you just need a properly seeded PRNG (which notably is OPs stated goal) use a properly seeded `*math/rand.Rand`.
Nothing can stands in the way of SIGKILL! But in other cases, this lib helped me greatly to do some app\-level `defer`ed\-like clean\-ups. It's for some time that I am using this and I felt happy with it. There are tiny things like this that if were a part of standard library, would same a huge amount of time \(and unnecessary discussions!\). 
No.
&gt; he most obvious example of that is semver enforcement: a hosted registry could reject attempts at releases that do not follow API-level backwards compatibility rules. Things like this have been promised repeatedly (a variant of that are tools that suggest semantic versions to use, when changing the API). I really wish, someone would finally come up with an actual implementation of how that should look. I'm pretty sure [it's not possible](https://blog.merovius.de/2015/07/29/backwards-compatibility-in-go.html) in Go as it is. The famed go1 compatibility guarantee serves fine as a promise, but only when interpreted by humans and with a certain amount of leniency. I'd argue that as soon as you are trying to build an actual algorithm around it, you'll notice it's short comings.
Your best bet should be to use several packages, depending on your needs; - [jmoiron/sqlx](http://jmoiron.github.io/sqlx/) for database access (mysql, postgresql - based on driver packages) - [gomodule/redigo](https://github.com/gomodule/redigo) for redis client (caching) - a queue can be implemented as a data structure, you can implement your own database backed queue, or you can rely on any number of external services that provide it (rabbitmq, nats,...) and just pick a client library that works for you In terms of API-first design, I cover most of this stuff in [API Foundations](http://leanpub.com/api-foundations/c/FREEDOM). Link includes a coupon code for a free copy (limited to 4, so somebody else can also grab it). Also, there are several examples of working APIs on my blog (https://scene-si.org - check out the last few articles), or peruse https://github.com/titpetric for the examples (pendulum, sql-as-a-service,...).
&gt; MVS, though, absolutely cannot exist without SIV, as it cannot make sound decisions without the compatibility invariants SIV is supposed to provide. This statement (in particular its contrast to gps) confuses me. In fact, I also was confused how much rsc emphasized SIV. To me, at least as far as the version selection algorithm is concerned, SIV is just a restatement of semantic versioning. Yes, MVS will fail if you break compatibility without changing import paths. But so will gps if you break compatibility without bumping the major version. In general, it would seem to me that you can have MVS without SIV by modifying the input to the algorithm appropriately (and feed different major/breaking versions as different nodes in the graph). What SIV *does* enable is having multiple versions of the same package in one program, by making the version part of the import path. And it simplifies the problem statement and explanation of the solution somewhat (but not by a lot).
I'm in no way an expert on the all these algorithms but as a consumer, I love vgo's MVS. If there is one thing I hate about software development right now, it is coming back to a project after a few months and find it not building because of automatic minor version upgrades. I explicitly pin exact dependencies in all my Python and JS projects to avoid this and still things break from time to time. On the other hand, purely as a consumer of apps, I like automatic version upgrades. I like to run the latest and greatest of firefox, Gnome/KDE/macOS apps, etc. I actually think this has something to do with the desire of average developers \(like me\) to have their dependencies automatically stay up to date. Most of us grow into being developers after being computing enthusiasts for years and IMO, it's that desire to run the the newest \(often alpha/beta\) version of our apps that makes us want our code dependencies to stay up to date as well. Only valid argument against MVS I've come across is automatic critical security fixes. I personally don't think it's worth it. Security is too important to be left to automatic minor version updates of dependencies. If I build and deploy a service and later a vulnerability is found in one of the libraries I use, automatic version update will not help me unless I come to know about the vulnerability, and then rebuilt and re\-deploy my service to get the fixed version of the library. It'll only help \(silently\) if the project is in active development, and even then I don't see it as a good practice to silently patch security vulnerabilities. I think MVS \+ tooling around security will be a much better approach. Tools like \`\`\`\`vet that scan project dependencies for vulnerabilities and notify the authors. Such tools can be automated to run periodically even if a project is in maintenance. I think this model of explicit security checks and actionable alerts is much much better than automatic minor version upgrades. I personally think the desire for automatic minor version upgrades is misplaced. As "geeks", we love to stay on the bleeding edge and that sense of always wanting the latest has creeped into our software development practices as well. Just how I see this issue.
Yes, it uses mark-sweep GC which copes fine with circular references.
But why? Packages in go tend to follow the unix principle of do one thing and do it well. That goes hand in hand with favouring composition: just hand pick the packages that do the job, and who knows, one day you might find a package that does the job better and you'll thank yourself that you haven't bought into a huge lib. 
Overall, I found the article disappointing. And confusing, given that ultimately the two approaches [aren't that different](https://github.com/golang/go/issues/24301#issuecomment-375992900). Most of the actual "meat" of the argument is deferred to later articles, relying on broad assertions for now. Some of them seem to be exactly *contrary* to the point that he is trying to make. For example &gt; When apparent incompatibilities arise, it can take considerable time to even sort out what’s happened - where is the problem? is it a bug? an intentional change? Will the upstream maintainer fix/revert the change, or keep it? It would seem to me, that this criticism is fundamentally *in favor* of vgo's approach over dep's (as far as there actually are differences between the two): One of vgo's declared (and adequately explained to be achieved) goals is that a push of module A will never break the build of module B, until its author has the time to upgrade it and resolve the issues. AIUI this is exactly why Russ defined "high fidelity builds" and while a later post might explain how dep can still solve it, at least *today*, dep seems to be the solution that is lacking here. So why even mention this? Personally, I'd have hoped for an article that has been months in the making, to be a bit more clear. Incididentally, this is where the vgo article series really shines: It introduces clear terminology with concrete examples and then goes in-depth how the different parts relate to each other. This article seems to do the opposite: Make broad, vague statements relying on implicit understanding of the differences between the two approaches. I'm looking forward to get more in-depth explanations of the points made in future articles though :)
&gt; Only valid argument against MVS I've come across is automatic critical security fixes. Note, that if using lock-files, you don't get these with traditional approaches either. And most people are using lock-files, exactly because they want reproducible builds (which are antithetical to automatic security fixes). Personally, [I don't believe](https://github.com/golang/go/issues/24301#issuecomment-375992900) vgo differs significantly from traditional approaches here.
Yeah sure we went through a PoC stage with our modelgen tool. Benchmarking modelgen vs gorm isn't a fair comparison, gorm is using reflection to build queries whereas modelgen has generated the queries and code before runtime. You'd effectively be benching gorm vs database/sql. Which as you can imagine is mostly pointless because gorm is adding layers of reflection etc on top of database/sql. It all depends on your use case regards how slow you'll find an orm. Memory usage will always be much lower without an orm, and most of the time the ns/op will be a significant amount lower.
I don't know about Go's GC, but in general a GC will start from a set of known references, such as all static references and references on the stack. It will mark the objects referenced there as good, and then go to each of the objects referenced by those and make those as good, and then keep descending through references until it's run out of references. It will then iterate over the set of all known objects and those that are not marked as good will be collected. So in your situation, you have objects A and B which each hold references to each other. Let's say that you held a reference to A on the stack, but that reference has gone out of scope. Next GC cycle, since neither A nor B can be reached neither will be marked as good, so even though they hold references to each other they will still be collected.
But even with lock files, I've had instances where the build system failed to guarantee reproducible builda. IIRC, it was with npm5. May be I didn't use it propeely. Also, if we agree that lock files must result in exact versions being used and guarantee reproducible builds then vgo does get it right without the need for lock files (like you said). (Thanks for the link. Will check in a while as I'm on mobile right now and the sync app doesn't render it properly. )
I think the problem you are hinting at mostly occur in languages which use automatic reference counting. Since doesn't, it's not a problem. 
[The spec](https://golang.org/ref/spec) does not know about "function fields" and "field meta-data". I have no idea why the post's author wasn't careful to not invent new names for existing things—adding to possible confusion a post such as theirs should have been supposedly targeted to remove.
If you want truely reproducable builds with npm, you have to use `npm ci` which was introduced in npm 6 i think
&gt; still things break sometimes Is it because the dependencies of versions you've pinned are minor version updated as well? Honestly I'm caught between wanting the latest version since security updates won't be brought in automatically, but for a living project it shouldn't be an issue to have security updates on packages included in your project sent to you. Does anyone know the best way to subscribe to security updates related to packages? This issue really expands past go, but vgo prioritizes build reproducibility over retrieving the latest version so it's particularly important I suppose. A manner of doing so for npm/python would be cool too, if anyone is familiar. 
I don't see anything new, we already know the promises of cargo-dep-pip-whatever approach, using it in others languages and even with Go with glide and dep. We know also why it was not added in the go toolchain in the begin and how go get with all his drawbacks was immediately a killer feature. This analysis is, and confirm what we dislike with theses tools namely, very confusing (like sometimes versioning of big project). The vgo approach at the opposite doesn't hide the complexity of versioning under a magic algorithm. If rsc didn't need to compare vgo to others legacy tools he's proposal will be very short and immediately easy to understand (like Go). Easy to understand because it's what we have in head when we build an app. I can confirm that my app can be build with theses minimal dependencies. Maybe it will work also with new releases if they respect semver compatibility promises but it still to test. Don't believe it can build magically with a range. I believe the Go team are aware of the concerns and hope they will not be stopped by the inertia of legacy approach. The community are eagerly awaiting for this !
To cripple the compiler's ability to detect some common bugs from mistakenly never using a declared variable.
&gt; Unfortunately, SIV is not a zero-cost abstraction. In some cases, even &gt; “high-cost” would be charitable. The costs of safely allowing multiple major &gt; versions of a module in a build are all of the same form: increasingly &gt; complex logical abstractions. My concern is that enforcing it universally &gt; might be prohibitively costly - especially for an ecosystem and community &gt; that has been operating without it for most of a decade. I don't understand this argument. gopkg.in is already well established in the go community. SIV sounds amazing to me, and I've experienced pain caused by lack of SIV in both python and ruby. Multple major versions of the same module cannot have the same identifier in the code, so they are two separate modules in every way. What's "high-cost" about that? &gt; When incompatibilities with new versions of your dependencies arise, MVS affords you only extreme options What does dep do differently here? &gt; By blindly assuming compatibility, even in the experimental v0 range, MVS &gt; creates a hostile environment for experimentation. Doesn't vgo avoid assuming compatibility in the v0.0.0 range via go.mod version specifications like v0.0.0-20180116225909-922ceac0585d?
Russ discusses this problem in this blog post: https://research.swtch.com/vgo-module Search for "Deprecated Versions".
Not really, just to auto comment lines with unused variables, not cripple anything.
That sounds like a bad idea. I'd follow the compiler errors and either use the variables or remove them.
Excellent, thank you.
To be honest, I think that this feature would be better suited in go vet or another linter rather than inside the compiler.
Exactly my feeling after having read and tried to understand the article.
Just a nit: &gt; [...] given that ultimately the two approaches aren't that different. That's not a given, that's just a link to your own opinion.
I'd be curious if that would have failed with Yarn. Your post definitely makes me not want to trust NPM lock files though. .. and I already had trust issues with NPM lol.
&gt; We know also why it was not added in the go toolchain in the beginning Do we? Can you link me to them? Genuinely curious.
https://golang.org/doc/faq#get_version 
I'm aware of the FAQ. It says Go has no concept of versioning, but it doesn't say anything about "**why** it was not added in the go toolchain in the beginning" (emphasis mine).
I would also mention [this classic piece](http://prog21.dadgum.com/93.html) to reinforce the point you made.
You can use [`strings.Split`](https://golang.org/pkg/strings/#Split): package main import ( "fmt" "strings" ) func foo() string { mana := "100.met" return strings.Split(mana, ".")[0] } See https://play.golang.com/p/U2XgVESbx5u func main() { fmt.Println(foo()) } 
One [link](https://golang.org/pkg/strings/#TrimSuffix) better than a thousand words
I would partially disagree with the Docker setup, because you could use multi-stage Docker builds to make a smaller Docker image :) See: https://medium.com/travis-on-docker/multi-stage-docker-builds-for-creating-tiny-go-images-e0e1867efe5a
Link doesnt work and i cant find the repo. Just me or someone elese experiencing this? 
Neither of the links are working for me either.
No. ["Never inspect the output of error.Error"](https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully). That's because strings are for reading by humans, and are hence unstable by definition¹. A proper solution is to rely on `github.com/lib/pq` providing an [extensive `Error` type](https://github.com/lib/pq/blob/master/error.go#L22) which has everything you might need to do a proper check against—including the [error about violation of a unique constraint](https://github.com/lib/pq/blob/master/error.go#L178). To use it, you need a type assertion: err = row.Scan(&amp;deviceID) if pe, ok := err.(*pq.Error); ok { // Here, the pe variable is of type *pe.Error if pe.Code.Name() == "unique_violation" { // OK, that's the error you're looking for. return nil } } return err P.S. Downvoted for the screenshot instead of actual code (Reddit supports code formatting). ---- ¹ Well, sometimes you need to deal with a poorly written library, where you have no other option, but such code must be put into a dedicated function and extensively commented. 
… Also Go does not have exceptions (for good).
[Working link to the GitHub repo](https://github.com/src-d/go-mysql-server)
Indeed I don't remember facing this issue with yarn. With npm5, I was taken by surprise when running `npm install` modified the lock file itself.
Yes, as it turns out, there is no such thing as objective truth and everyone is just stating their opinion. But so far, no one argued differently AFAICT (at least that comment did not receive any answers to the questions it posed).
worked for me. but as the godoc link was pointing at the `github.com` import rather than `gopkg.in` one, I modified the post to point directly at the github repo...
True
Go can do everything that PHP can. Some things may be easier with PHP, some things may be easier with Go. For the things you want, if it's HTTP-based web service APIs then Go is an excellent fit for this, and you may find you can produce leaner services that are also more performant. Those things you've mentioned are all possible. There's AMPQ libraries for queues, database support is built-in with drivers available as libraries (including for MySQL / MariaDB), and caching can be achieved similarly to PHP using things like Redis and Memcached, or even by storing things in application memory (though, be wary of GC). As for examples, I always struggle with this off of the top of my head. Upspin is a popular example of a good Go codebase at least: https://github.com/upspin/upspin
Gross.. most people check in lock files. That's a bizarre practice 
Doesn't work for me either. You included `:` into the URLs. 
This article is confusing because the authors goal is create dissent for vgo as they have been doing since it’s announcement. Dep is a project which uses [activism and misinformation](https://www.reddit.com/r/golang/comments/80z3rb/show_rgolang_video_introduction_to_vgo_new_go/dv0kpo7/) rather than merit to _acquire_ users. The readme still says “dep is the official experiment, but not yet the official tool. Check out the Roadmap for more on what this means!” If that tells you anything. I was hoping everyone could join forces for the better of the Go ecosystem but it looks like I can now stand behind the more critical points of my prior post with certainty.
Are you on mobile like me? In seldom cases my app doesnt render text exactly like the website. 
Why not try to automate this? https://mholt.github.io/curl-to-go/
I don't get why golang is not able to decide on a "feasible" solution for pkg management and versioning while almost all other languages seem to find a way. For example, why not just take cargo, build on it and use it?
In the run configuration, under the ` Go tool arguments: ` type: ` -o module.so ` and this should work. The file will be produced relative to the ` Working Directory ` folder.
I tried that, but still lib will end up in bin directory name "module\_so", weird...
&gt;Is it because the dependencies of versions you've pinned are minor version updated as well? Yes and sometimes the minor versions actually break things in ways unexpected by the author and other times they change their own dependencies which results in even more library changes and in some cases the combination of different things pulled by different minor version updates in the main deps results in broken builds or worse undetected bugs. \&gt; Does anyone know the best way to subscribe to security updates related to packages? I use this in my python projects. Schedule to run it every week in CI and also run it before every CI build. Has helped me a lot in making sure the projects don't use vulnerable libraries.
When I'm working on code, one of the following is true: a) I'm working on a minor update -- in which case I don't want to update any dependencies from the versions that were locked in for the previous version. b) I'm working on major changes -- in which case, because I'm probably breaking things anyway, I want to go and get the latest version of every dependency. So in practice, whether it's with bundler or dep or something else, I often carry out option b) by deleting the lock files and running dependency resolution from scratch. It sounds from that Github comment as if vgo is designed for my way of working. Maybe it's the wrong way of working, or there are better ways, but if so then I'd like some clear and concise explanation as to the alternative and its benefits. That said, I'm impressed that the dep team are continuing to work on the problem, because it seems clear to me that Google are going to ignore the community and do what they like in this area.
This was posted just a day ago. This just seems spammy at this point.
I have built the backend in go with boltdb store as a replacement for disqus for my sites. The first one I have migrated was https://radio-t.com Seems to work ok, users (most of them) like it. 
Seems to the targeting the "cloud native" and "IoT" gold rush...
I didn't look into details but here are my first impressions: * purely structured!: * huge functions nested *7* levels deep with *gotos* * no tests at all Sorry this might sound harsh, but i can understand the reviewer.
First off: Massive bonus points for being open to review comments. Maintain this character trait and you'll be a valuable addition to any team who's willing to let you grow technically. I'm sorry to say I agree with your reviewer: I haven't taken the time to study it for more than 10 minutes, and I suspect your reviewer might not have spent any more time either. Here are some of the things I picked up on: * The folder structure seems unidiomatic. * There is a lot of commented code * There are sections of code with 7 \(!!\) degrees of indentation * The files sometimes have capitalised filenames. AFAIK, there's no need to do this in Go, and it may be a sign of inexperience with Git \- as capitalised filenames can be very painful. * There are hardcoded urls. * There is a `goto` statement
Awesome work
Might I interest you in an extension that can take *any* bright web page into a dark one? It's called Dark Reader, it's really good. (links: [Chrome](https://chrome.google.com/webstore/detail/dark-reader/eimadpbcbfnmbkopoojfekhnkhdbieeh) and [Firefox](https://addons.mozilla.org/en-US/firefox/addon/darkreader/)) It's not perfect as web pages are pretty complex these days, but it does provide options for tweaking the effects per website. But in case of simple web pages (like Go docs) it works really well.
Can you please confirm you are using 2018.1.3? If yes, can you please either ping me on Gophers Slack or Twitter (same @dlsniper) or open an issue: https://youtrack.jetbrains.com/issues/Go Thank you!
to be fair, this was mostly just a matter of climbing on the shoulders of the great library [github.com/jung-kurt/gofpdf](https://github.com/jung-kurt/gofpdf) (anf a bit of glue to tie everything together). but thanks anyways :)
NIT: Historically, an [RFC is a "Request For Comments"](https://en.wikipedia.org/wiki/Request_for_Comments) and not a request for a code review. While the "RFC" process originated with the IETF, it has since been co-opted as a vehicle for floating architectures / designs within an organization.
&gt; Go back to them and insist There are legal reasons why an interviewee can not be given any feedback on his/her performance during the review. Namely, the feedback can be used as grounds for a lawsuit for discrimination in the hiring process. You may be inclined to ask "how would code review comments apply here?" A quick chat with any corporate lawyer should clear that up. Hiring practices aren't something to play fast and loose.
Yes, it definitely can, for anything other than simple types. While decent IDEs/editors will display the type returned from a function, there are times when you're reading source code outside of an IDE, e.g., browsing through source on Github, or reading a printout. For this reason (and as someone who frequently prints out source code, for a variety of reasons), I do *occasionally* declare var type, then assign, rather than do short assignment, in the interests of future readability.
This is actually kinda cool. It does what it says it does rather well.
Yes the issue was the version, on Linux from some reason I wasn't offered an upgrade or I didn't see it. With -o bin/libname.so it outputs file to bin dir as expected. 
Perfect. Thanks for the update.
IMO, those points are not very relevant for a first programming language. The fact that go is simple, OTOH, is a great plus. But Python probably beats it when it comes to learning the basics.
Cool it with the hostile response, there's absolutely no need for such a harsh tone. Since hiring practices are built around [federal anti-discrimination laws](https://www.eeoc.gov/laws/practices/), there's very little difference between one company and the next. I'm not claiming that some companies may break from the laws and roll their own hiring practice. I am claiming that it is an industry-standard practice to deny feedback to applicants that did not pass the hiring process.
Nice. What tools are available to fight comment spam?
There is probably something wrong with the Go implementation, I don't believe that it could be 2x slower than the Node one.
Py is also by default present on all linux distros. So nice ROI on your initial investment. 
There is no anonymous access, so to post anything user has to be logged in with github, fb or google. Admin can delete any comment and block users. This is the screenshot of admin's view http://4dropz.com/Pv9bUtUrRD94 
Doesn't logging in with any of those services compromise the privacy aspect? Even if the app doesn't add anything additional, the service a user is required to be a member of does compromise that privacy.
I'm not sure how this compromises privacy aspect. Using oauth2 providers seems to me be very traditional way to let users in and filter anonymous access. Remark42 uses very limited user info – name and avatar picture. Internally it hashes user id and even source ip. 
As one of the authors I'm really happy to see someone plugging this. It sounds like you have some feedback around what could be improved, any suggestions?
I like to use libs such as https://github.com/go-chi/chi or https://github.com/gorilla/mux These libraries are not huge, and I prefer to use them instead of use Go's default http primitives. So, my opinion in the topic the same.
Looks quite good, but why does it need node for frontend? And why some awfuldb instead of real database?
I just finished reading everything and wow these guys are like an embodiment of the pkg management technics and problems. Looks like they have been think ing about this every second for some time. I feel like if/when they come up with the final thing, it will not only be great for golang but also may completely change the entire pkg management process as we know it.
What problem are you trying solve? Maybe there's a more idiomatic way of achieving it?
https://stackoverflow.com/questions/23030884/is-there-a-way-to-create-an-instance-of-a-struct-from-a-string
Node is only needed to build the frontend. Once the JS and CSS files are built, you're good to go. As far as the database, no external dependencies I suppose could be pretty nice. And it's probably fast enough. The storage stuff is behind an interface, so I suppose you could add a DB implementation if you really needed it.
Yeah, which is was why I was curious. Always looking to see how other people are doing things in this space. We just do a ton of code generation with a hint of reflection to make things easy for users to deal with it. Basing all that generation off the presence of foreign keys in the database for the relationships part specifically.
All I know is, until Sam and Russ can agree on a solution, we're going to stay in dependency management limbo.
but... why? Why not a map[string]interface{}?
I would say no as long as it's not doing things like providing analytics on the visitor other than what is required to identify them. Things like browser, screen size, what add-ons are installed, etc. You would be amazed at what the Facebook buttons on sites can learn about you even if you aren't logged in.
Im working on golang codegen which generates code for server side. API implementors implement server side interfaces. When a rest/json-rpc call is made, i have to deserialize a custom json format and instantiate appropriate structs from custom format and invoke server side implementation. 
“Separate modules in every way” with go’s duck typing seems like a nice combination. 
What type of application development would get you promoted? Just start doing it and demonstrate that you are not only capable, but already doing the work. If you are doing bash and perl I would imagine you are a sysadmin? I would say python and Ruby may be more what you need to learn but obviously any development experience will synergize.
Codegen at runtime? I can't imagine there would be very many problems for which this is a valid useful solution
i wasn't clear. server runtime and codegen. codegen generates structs, so i have control over what structs are generated. It is these structs which have to be instantiated from custom json format. 
the aforementioned `map[string]reflect.Type` is a fairly ok solution then. But I do suggest actually rethinking the problem
thanks! I will be integrating it this week.
The frontend is not my area but as far as I can see node is the usual way all (most?) modern build systems in JS world require. Pls, note - node similarly used in multistage Dockerfile as go compiler used in backend build stage. Both stages produce artifacts for the final image, i.e., no node and no go compiler included in the deployable image/container. Regarding boltdb - this data store looks real to me, fast enough, lightweight and reliable. 
And for the curious… &gt; 2009-11-10 23:00:00 UTC — determining the significance of this date is an exercise for the reader Go became a public open source project on November 10, 2009 [1] [1] https://golang.org/doc/faq#history
Great! I would love to get feedback on missing features or any rules enforced that are inconsistent with your expectations. Take a look at the open issues and let me know if you have any questions. 
Great answer. Go and (sane) Perl have some similarities (heavy use of builtin slices/arrays and maps/dicts) and curly-brace syntax. If you can read and write basic Perl, learning go should be pretty straight forward. But as mentioned above - there might be better reasons to learn python?
This one gets linked often : https://github.com/golang-standards/project-layout
The “Faking Time” section of Inside the Go Playground is a great read! https://blog.golang.org/playground
https://arp242.net/weblog/learning-a-programming-language.html In the specific case of Go, [The Go Programming Language](https://www.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440) is the best book that I know of. It does assume some programming knowledge though. As for Go vs. Python vs. Perl, I agree with the commenters that it would depend a lot on what you're hoping to do with it.
As far as I can understand, you get something like: {"name": "sreeshas", "site": "reddit.com"} That hits an endpoint and you want to do something with it. However, you *don't* want a struct like... type Visit struct { Name, Site string } Instead, you want to be able to send a message to the server and have it create a struct dynamically? So to generate the above struct, someone would send {"/visit": ["Name", "Site"]} Then, when someone hits the /visit endpoint with the aforementioned JSON, it would automatically be deserialized into the runtime-generated Visit struct? If this is the case, there's something wrong. This is all very well and possible, but I can't figure out what you want to do with the struct after that. No code can reference the struct at compile-time, so even if you can deserialize it into a custom struct, what then? What happens with it? I can't do `type thisVisit *Visit` because there is no Visit struct definition until the endpoint is hit. You mentioned "invoke server side implementation", but who is implementing that, and how is it invoked? What are we missing?
 Server.go:60 go StartStopHTTP("Stop", PortEntry.Text()) Server.go:61 ui.MsgBox(MainWindow, "Stopped!", "The server has stopped successfully!") The lie detector test determined that was a lie! Spinning up the Stop call in a goroutine means you cannot claim it has even run, no matter run successfully. Server.go:100 http.HandleFunc("/login/", LoginHandler) You're calling this every time someone starts the server. There is nothing to prevent a server from being started multiple times, plus you're re-registering the handler for that path every time. Small mistake, but worth fixing. if strings.Contains(string(LoginInfoData), Username) &amp;&amp; strings.Contains(string(LoginInfoData), hex.EncodeToString(Hash)) { This is super insecure. As far as I can tell, it means you are authenticated if you use any username that's in the file, and any password that's in the file (even a password of a different account). At minimum, you should salt the password hash with the username provided, but even that is not entirely secure. Client.go:29 if UsernameEntry.Text() == "" &amp;&amp; PasswordEntry.Text() == "" { Shouldn't this be **or**, not **and**? Client.go:32 Get, _ := http.Get("" + ServerEntry.Text() + "/login/" + UsernameEntry.Text() + ":" + PasswordEntry.Text() + "") What's with the empty quotes at the beginning and end? Other thoughts: You're not sanitizing your HTTP parameters. I can cause a panic just by hitting `/login/dead` because you're blindly referencing LoginArray[1]. Also, all of your variable names are uppercased, which is really unusual to see. Overall, this is not very idiomatic Go code. You would do well to have a "Server" struct, with fields for all of the ui elements (at least the ones you use), and also put your globals in there. It's also worthwhile to separate your UI from your actual code, which you've done to some extent (with your methods) but you need to go all the way.
&gt; Import from Disqus Yay!
I think ill be doing something similar to this. 
 For reasons i cannot explain this is what goes on wire { "type": "Visit", "namefield": "sreeshas", "sitefield": "reddit.com" } On the server side, i will parse this data and know i have to instantiate a struct of type "Visit". Somehow if i get Visit struct with those fields There will be an interface type MyVisitor interface { VisitMe(Visit) } There will also be an impl generated by codegen for that interface. type MyVisitorImpl struct { VisitMe(Visit v) { //Not implemented yet. } } When server endpoint is hit with request containing following data { "type": "Visit", "namefield": "sreeshas", "sitefield": "reddit.com" } Server calls VisitMe of MyVisitorImpl. 
This is why people were so insistent on knowing the problem you were trying to solve - your problem is much, much simpler than your explanation led us to believe. All you do is get the json, as a string, and unmarshal it twice. First, into `type JustType struct { Type string }`. Second, depending on the value of Type, you can create a struct of that type and unmarshal into it. I recommend a switch statement, it's much simpler than a registry. Working example: https://play.golang.org/p/5qoWszSsrTZ
Nice. I don't like the way tokens reset/confirm are implemented. IMO [Split tokens](https://paragonie.com/blog/2017/02/split-tokens-token-based-authentication-protocols-without-side-channels) are described in the linked post are the secure way. And while RC it's still time to fix that
Pretty much just boils down to GOPATH and dependancies. It's so different from how everything else works that its another mental hurdle to overcome. Knowing how to place your code into it is against what most people do with having their own special folder to place the code in. I have been helping people learn Go and explaining the GOPATH is the biggest hurdle and complaint that I get. Every other language I work with allows you to create your project wherever you want, import packages and start hacking away.
vgo get fixes that :)
Right right, interesting. From the godoc it seems like you've come up with a nice to use API, so kudos on that :)
After a couple of iterations, the execution time of the Go solution went down to the performance of C++ "shared_ptr" (ref-counted) / Rust implementations! (Though, its memory footprint is still considerably higher)
I believe the problem is that privacy-oriented users would be pretty turned off by needing to use Facebook or Google, even if just as a login method.
Do Go directly if your company already is doing Go. Go works as a tooling language for DevOps/Sysadmin type work too so might as well jump over Python.
What is the alternative solution? Making users to create dedicated accounts on each blog running this comment engine doesn't sound like a pleasant experience. I have considered some ways to use "magic link," but this will involve email, which is problematic for a self-hosted solution.
&gt; What is the alternative solution? I dunno. I don't believe there is a good answer that will actually satisfy everyone.
&gt; Massive bonus points for being open to review comments. Maintain this character trait and you'll be a valuable addition to any team who's willing to let you grow technically. Thanks :) I've updated the code with a lot of restructuring. gocyclo tells that it now about 11 complexity (from the 23 earlier). Would you be able to have a look once again ? Thanks.
Versioning and dependency management are so frustrating this should help us all :)
Try to learn about golang clean architecture, there so many example of it, and everyone is a good example. Just choose the best architecture to fit to your problem
Hello, that's a pretty good idea! I will upload it on [https://userstyles.org](https://userstyles.org/). Thank's
http://exercism.io/languages/go/about
20+ years of Linux skills here too. Done Bash, Perl, PHP, and got into Go about three years ago. All are excellent tools for the job required and how happy you are to use for a particular task. That being said, I really enjoy working with Go far more than other languages, and management teams are becoming very interested in using Go more and more. Get into it. It's an excellent tool.
A few that are commonly referenced: [https://medium.com/statuscode/how\-i\-write\-go\-http\-services\-after\-seven\-years\-37c208122831](https://medium.com/statuscode/how-i-write-go-http-services-after-seven-years-37c208122831) [https://medium.com/@benbjohnson/structuring\-applications\-in\-go\-3b04be4ff091](https://medium.com/@benbjohnson/structuring-applications-in-go-3b04be4ff091) [https://rakyll.org/style\-packages/](https://rakyll.org/style-packages/) [http://jerf.org/iri/post/2929](http://jerf.org/iri/post/2929) And the other day some good guy wrote this:
My uMatrix likes it, too.
Does it play well with hugo?
Devops here. Used to do shell, perl, and python as scripting languages in the past. Did not cut it for me once the scripts got longer than one page. VERY happy with Go, wiped everything else off the table. Compared to Perl, you need to type more. I do type fast, so no worries. Error handling needed some patience from my side. You probably have to get used to the compile cycle though. I just open up two terminal windows, one 'vim' and one 'watch go run main.go'. Nice. The mindblowing difference is when you rollout the script on more than one server: one single binary without any external dependencies. No more CPAN, Python2 &lt;-&gt; Python3 libs, pip, rpm -dev packages. Copy one file - done. Most of my tasks are some sort of glue code, usually performance is not much of an issue. For 10% it is, and Go feels significantly faster to me than scripting languages: https://benchmarksgame-team.pages.debian.net/benchmarksgame/faster/go-python3.html. JSON, XML, REST? Email? Email templates? tar, zip, gzip, bzip2? SHA 1-512? base64? csv? gif, jpg, png? check. All included in the standard library. Get vim, get vim-go, get go. GO.
It's 2018, using an untyped language should be a criminal offense.
Time to retire friend
Time to learn to use the best language for the task , friend. 
What’s he license?
MIT
Thank you for your work. Re-implementing web auth is one of the things that keeps me going back to Django.
This looks great! On an aside, anyone know of any good tools to generate documentation for proto files? We're going to be testing the waters of gRPC soon, and one of the selling points for us is more clear API definitions. It would be nice if we could generate documentation, especially to integrate to a central location. Thoughts? 
Question, Why do you import local/internal packages by their github url? e.g. import ( "github.com/fharding1/todo/internal/respond" "github.com/fharding1/todo/internal/store" ) I've seen a couple other packages do it. Is it because you can't import with relative paths? 
The two I have bookmarked (because, hey, I’ll create some documentation one day) are https://github.com/pseudomuto/protoc-gen-doc and https://github.com/sourcegraph/prototools There’s also protocol-gen-swagger from grpc-gateway, which might get you in to the swagger doc generation ecosystem.
I love Go. It's a great tool. But if your primary job development is focused around bash scripts and automation, Python is most likely a natural next step. I haven't ever written a bash script and thought "I should've written this in Go". &gt; We do a lot of coding at work What kind of programming? Automation? Infrastructure tooling? We really can't answer the question of Python vs Go without knowing this.
:shrug: One thing Swagger is pretty good at is auto-generated documentation, so if you can use those tools without being tied in to the whole swagger ecosystem it might be interesting. (Not that I've anything particularly against swagger, it's just not the toolchain for me.)
Slight segway - have you considered using GraphQL instead of REST? I'm using AWS AppSync to implement GraphQL schemas, which has been very clean. Coding in Go is reduced to just writing Lambda functions that get invoked by a request resolver - the API is essentially the schema and associated mappings set up in AppSync. If AWS is a deployment option it's worth exploring.
The first real site I had remark42 integrated with was Hugo-based. Had no problem at all to replace templates for Disqus with this one. The ticket https://github.com/umputun/remark/issues/27 is about ready-to-use recipes for different systems, hopefully, will have detailed instructions for some of them soon. Regarding middleware - not really. It is SA service with multiple endpoints exposed and some static js assets. I don't see it as a good fit for middleware.
Google's API has a pretty good description why: [https://cloud.google.com/speech\-to\-text/docs/best\-practices](https://cloud.google.com/speech-to-text/docs/best-practices) TLDR; They prefer a lossless format as it results in a better transcript. 
Is this significantly different to: https://benchmarksgame-team.pages.debian.net/benchmarksgame/description/binarytrees.html#binarytrees ?
AWS AppSync + Lambda is exactly what I'm working on at the moment. Throw in Cognito for user management and authentication is taken care of. AppSync lets you mock up queries in the browser, and if hooked up with Cognito, you can log in as different users to test different authorization etc. Time will tell how well this will scale under extreme load, but for my uses cases it is fine.
Nice dependency injection for the DB btw, I'm going to copy your approach. Thanks. So why do you import other parts of the todo app by the github URLs?
Using AWS AppSync for GraphQL completely removes it from the Go code which is just used for Lambda functions you map with a resolver. No GraphQL coding beyond defining your schema in AppSync. Of course that depends on being able to user AppSync/Lambda for your deployment. 
https://github.com/rif/lov3lyme
[https://github.com/umputun/remark](https://github.com/umputun/remark)
Why Not Both Meme.gif 
I remember reading that having a models package isn't idiomatic though
No problem. I import other parts of the app by their GitHub urls because that's where they are in my GOPATH. When you import packages in go, you're telling go the package is in $GOPATH/src/path. So I'm just telling go where to find the other parts of the Todo app.
Yeah, I guess the "maybe" in my answer would be better replaced with a "kinda". AFAIK you can only use relative imports if you're using the compiler+linker manually, not with the actual go build tool. It would be nice for them to be fully removed in Go 2.0 to get rid of the confusion, as well as global imports imo, since use of both is bad practice (well, except for global imports in testing, I guess).
Will be looking at this in the coming days. Thanks for the link! 
When I was building [suture](https://github.com/thejerf/suture), I looked at doing this sort of thing, but rapidly came to the conclusion that even in the case where I was porting Erlang code, you didn't get much value in doing this. That's why the Service interface ultimately ended up being just `Serve()` and `Stop()`. I had an `Init()` at first, but because Go is a mutable language, it became clear that the service code just needed to be written to handle being restarted whenever, so it just got rolled into the Serve function. And message handling via function calls stinks because you lose all type safety. I also found the difference between "call" and "cast" in Go wasn't that useful, because you can't create a generic mechanism to use messages to implement calls, because you'd need, well, generics. Basically, you don't want to structure your Go code this way, _even if_ you're porting Erlang code. (Incidentally, if you are porting Erlang code, look at [reign](https://github.com/thejerf/reign), which was designed and successfully used for exactly that use case. I haven't had the time for the final polish for a 1.0 release, but someone asking for docs would help kick me in the bum for that.)
Yep. This is one of the biggest reasons my last more serious projects ended up being rails. One of my other big pain points is databases and for that I made https://github.com/volatiletech/sqlboiler I mention it because maybe you share that pain not being able to use flask or what have you. :)
To be fair, this is in test code.
VGO wins \- now take my money and deploy it to mainline go !!!!!
Thanks, let me know if you have any issues! There are a couple PRs which fix existing bugs, but I'm waiting to merge until there have been some more eyes on them.
I have registries for this in several places in my code where I want decoupling, such as having several modules plug in support for something. I have quite a few places where I have something like type Registerable interface { Name() string Create() Registerable } var registrations = map[string]Registerable{} func Register(val Registerable) { registrations[val.Name()] = val } func GetNew(name string) { // ignoring missing here return registrations[name].Create() } You can then easily get new instances via the registry and JSON unmarshal into them. You can skip the Create() call if you fiddle with reflect, I tend to just implement the methods on my types. (Theoretically you could do something other than return an empty value, but I'm yet to take advantage of that. You could also theoretically create with a passed-in context.Context that way, but I've also yet to need that.)
Thanks! By the way, if you want to checkout this structure in a bigger, actually real project, [here](https://github.com/pigmice2733/scouting-backend) is an example. It's a bit messier.
I just tweeted this to Alex Gramfort and Gael Varoquaux from the scikit-learn project. Maybe this will get people to contribute? Fingers crossed :)
Another comment has pointed out that you shouldn't inspect the error message. There is a great package to help with error management. github.com/pkg/errors Additionally we don't have exceptions, just errors :)
If at all possible don't do this. Reflection is not idiomatic and most of the time a better solution can be found. Creating an interface and then utilizing that in the call back is a much safe option.
It's already lost information because it was originally in mp3, converting to flac won't bring it back. 
That's not the point, they want it in lossless for best quality. 
It should use `t.Fatal` then.
And also not `assert.Equal()` :)
Yes when you record it. However now that it is already mp3, converting to flac does nothing.
Why not just contribute to golearn? Serious question
The code is beyond unreadable, and doing simple things like creating your own array/slice of features/labels with built-in types is not clear. I tried doing the latter and I ended up having to dump my data to CSV then read it back using the provided helper function. Just try going over the code, and you'll see why.
What's the difference?
A remark regarding ElasticSearch and searching: check out analyzers for fields used in index mappings/templates. If you're working with e-mail addresses, you'll run into special characters (-.@ etc.). Some of those characters are not always used literally in ElasticSearch and you'll need to set up an index mapping with analyzers on those fields. If you don't do any of this, you might run into unexpected results if your search term contains special characters and you actually want to find those characters. 
Why not? :o soz i'm new
Authboss looks very complete and promising. Thanks for your work. I'm wondering what type of overhead this adds to each HTTP request. I see tests but could you add some benchmarks also?
Ok, first off, thank you for all the suggestions but i want to confirm I understand a couple things. First, what do you mean about starting a stop function in a go routine is bad? Should I just not start in a routine? Next, the handle function part, should I check to see if the server is not running then start it otherwise just show an error message? Next, the check username and password part, currently I generate a hash with the password, the salt \(the password\), and then add it to the file, which will then be checked later on. Next, yes, that should but does it really matter, as if they don't enter a username, it will check and pass the first test, but will fail at the password hash check phase which is fine. Lastly, I don't need quotes, haha. Yes, I have experienced the panicking, how can I fix that? What is the best code casing method? Thanks, for the advice, I didn't think about putting ui controls in a struct. Thanks!
Alright, thank you, I didn't think about that when I was developing. Thanks!
Every time I look at bazel, I'm entirely intimidated, and most of the examples out there only ever show you the "happy path". I struggle to look at this sort of thing and understand how I could have bazel build easyjson for a load of packages that have import dependencies, for example.
https://github.com/shurcooL/home
Thanks for your kind comments. In terms of performance in Authboss there's two areas that we can be could be looking at. 1) Authboss routes: this is logging in/out, confirming users etc. This stuff should all be accessed quite infrequently compared to the rest of the site, so I'm pretty unconcerned about performance here. 2) The rest of your site: Authboss supplies a few [middlewares](https://github.com/volatiletech/authboss-sample/blob/96684a765cfb0b28b3f663de7e0c1fc512b60616/blog.go#L228) that you might want to use in your app. One of the main reasons I'm not really concerned about these either is because they're very small and completely rewritable since Authboss doesn't hide anything and also all these middlewares are really doing is querying the database with code you wrote and doing session/cookie management with code you wrote and so the hotpaths would probably involve your own code if not more than Authboss code. So having said that performance isn't really a concern I currently have with this code (mostly because I'm starting on sqlboiler v3 now and I'd like to focus on that). It's not zero allocation because there's context.Context in use as well as a custom ResponseWriter, but I don't think there's anything prohibitively expensive but of course that depends on the use case. All abstractions come at a cost unfortunately. Importantly however, if someone raised performance concerns, or contributed benchmarks like you're wanting to see (hint hint) and things weren't where they should be I'd commit to help fixing. I like fast and efficient things too! Thanks for bringing up the topic.
How does vgo relate to vendoring?
Yeh, that's cool. Just wanted to make sure there wasn't something special you were testing for that I couldn't see.
vgo is a prototype of what go will look like with vendoring and dependency management build into the standard commands (go get, go install etc). vgo gives us (the community) a chance to play around with the future go, allowing early feedback and suggestions, a little taste of the future of go :) &gt; The major changes are: &gt; &gt;* All commands (go build, go run, and so on) will download imported source code automatically, if the necessary version &gt;is not already present in the download cache on the local system. &gt; &gt;* The go get command will serve mainly to change which version of a package should be used in future build commands. &gt; &gt;* The go list command will add access to module information. &gt; &gt;* A new go release command will automate some of the work a module author should do when tagging a new release, &gt;such as checking API compatibility. &gt; &gt;* The all pattern is redefined to make sense in the world of modules. &gt; &gt;* Developers can and will be encouraged to work in directories outside the GOPATH tree. &gt; &gt;All these changes are implemented in the vgo prototype. from https://research.swtch.com/vgo-cmd
My main issue with MVS in its current state is that there's no way for library authors to temporarily use a fork of one of its dependencies or blacklist some specific versions. See this issue I created yesterday for a more detailed description: https://github.com/golang/go/issues/25391
vendoring is going away.
Hi, I know it's far from perfect and that's a reason why contributions are welcome. But if you send me your exemple, i'll try to make doc and code better. Best regards
Why do you have store.Interface? Why wrap the boltdb implementation?
I must admit It's a Good question! - I started it as an exercise. Hum, Ok, Bad answer. I play again - It uses only gonum/mat for data and no proprietary type - it's cgo-free Best regards 
[removed]
Thank you for your answer Re:"It's cgo-free" I am a new gopher old ml guy. So I am still coming to grips with the go ml community but isn't one of the value propositions of scikit learn how it had safely built a package around c-bindings in python to a wide variety of algorithm implementations from papers? Wouldn't the aim be similar here? Or are we just trying to mimic the interface of fit and predict? the most useful thing of scikit learn for me was these great community implementations of efficient research backed algorithmns. 
i perfer the `assert`
The interface of `fit`, `fit_transform` and `predict` aren't very good. It works well in Python because python allows for `**kwargs`. I highly believe that there are better interfaces for machine learning and forcing into scikits learn's interfaces are not helping. 
Coming from python I've noticed it's much more work to do scripting. Please let me know otherwise though, I want to use Go! My recent task was to parse a rather large json response from a webserver and use the presence of a key to decide to kick off another process. Usually in python, I'd: - pop open an interpreter - import requests - requests.get(url), json.loads() into dictionary - if data.get('item'): do_this() It's easy since I can play around in the interpreter and play with the response json before putting this all into a script to use. But for go, I quickly realized I was in over my head. I had to create a struct of the json response. It had a lot of keys, and thankfully I found a webservice that converted json to go structs for me. From there it wasn't so bad. `json.Unmarshal()`is similar to `json.loads()`. But if that json to struct service didn't exist I would have given up on the spot and popped open a python file. I did later find out I could have used `map[string]interface{}` for the json unmarshall which makes things much easier. But it's still been massive trial and error for my other ETL scripts. Maybe I'm just used to opening an interpreter with dynamically typed Python and copying it into a script when I have it right. Maybe I've just been in python land too long. I just haven't found go as easy to use for scripting as I keep reading about. 
Thanks for the feedback! My experience with bazel echoes your sentiments as well, the upfront cost is high and a little intimidating / confusing at times, but pays off incredibly quick when you have a lot of developers working in the same codebase and have to manage docker images, protocol buffs, or targets built in other languages. It's certainly not for every project or package, but it is truly indispensable when it is.
Do we know if vgo is going to be the final decision or is using dep still a viable option for new projects. 
Trying really hard to not be a language nazi here but I got really put off by Bazel being written in Java. A build system in Java? seriously? And it claims to be "fast". So we are using Java to build our Go apps, sigh.
Must be the U.T.I.L.S. framework.
True but vgo is still an experiment. Many (if not most) Go users rely on a stable version of the Go toolchain.
I agree
I agree that dependency injection is important, but there is way too much magic going on for this to be idiomatic. What's wrong with using a combination of nesting configs, sane defaults, and functional options to achieve the same thing? Looking briefly at the dig code, this is definitely not something I'd want to debug when something's fucked in production due to a config bug. https://github.com/uber-go/dig/blob/15c67344e48b1b3317399a647b0ec0069c34321d/dig.go#L143-L186
The nature of DICs tends to be distasteful to most experienced Go devs. We are not unaware of the approach.
I'll probably move to Gin as the http framework. Until then, my main focus is figuring out a decent folder structure and wondering on what the opinions on using the makefile to set the gopath in the way that I am here.
About the folder structure, here is a complete one [https://github.com/golang\-standards/project\-layout](https://github.com/golang-standards/project-layout)
It's a shame it's not a PR so I cannot comment directly on the code. 1. I'm sure you've seen the article about iris sent by /u/alexaandru 2. Regarding file structure you may find different opinions. For instance, I like: ``` build/ // If any /html /js /scss cmd/ // If any pkg/ /post/ /internal.go // unexported functionality /post.go // containing both struct and methods associated with it vendor/ .gitignore main.go // esssentially the routes file README.md // whatnot ``` Again, it's just my choice as it's clean and easier to find things IMO. Many may have different opinions. 3. Don't try to align Go to a language you may already know. You're going to have a bad time :( 4. I think you should avoid stuff like: `/src/app/services/posts/posts.go `, `package posts_service`, `import "app/services/posts"` and `posts_service.GetPosts()` - I've got a feeling this may get confusing quickly. 5. Don't forget those tests :D 6. I find tools like this one useful with a bigger codebase: https://goreportcard.com/report/github.com/alshdavid/go.golong Welcome to Go!
Try out [Auth0](https://auth0.com/docs/identityproviders). It's free for open-source projects and provides a plethora of OAuth2 providers along with a standard E-Mail/Password login which is stored in its own servers.
I think DI is good but I dont think you need containers for it. 
I have found that facebookgo/inject works really well for me
Welcome to the syntax sugar race, heh
I totally agree. I write build scripts in Go with `// +build script` as the build tag, then it's written in something all the devs are familiar with, you can test it, etc. It's more verbose of course, but I can live with that.
&gt;I believe Dependency Injection helps build more robust and testable applications. I don't mind that you don't like what appears to be tight coupling (worth noting that's an OO concept, not a functional one) but **this** statement fucks my goat and fucks it properly. DI is not magic. It's just another abstraction layer. You don't *need* it. You want it. If you write Java code in Go's syntax, sure, you'll run into these problems. But attempting to shunt a familiar concept into an unfamiliar space is a terrible idea.
Using the dig container loses a lot of type safety. Forget a dependency? Call Provide with a non-function? The main() with manual DI won't compile, the container app will crash at runtime. There is even more magic involved when having to deal with dependencies of the same type and it seems like I have to change my code for it, namely adding dig.In to my struct. This is a big no-no. I don't think containers are needed. Wiring up the application is not complicated, because it is just a bunch of instantiations and assignments. This may be some work, but you have to do it anyway. And you can write typesafe factories and other helpers for this.
https://golang.org/doc/articles/race_detector.html is your friend.
Dependency injection is a good idea, even in Go. Using reflection-based magic dependency injection _containers_ is not a good idea IMO - there's a big difference, and I think the author has also confused this here.
If I am not mistaken /u/BeardsAreWeird's comment was directed at `golearn`, not `sklearn` :)
there is value in pure-Go packages: - easily installable - easily deployable - easily cross-compilable - (somewhat more) understandable (than arcane C) that's essentially why [Gonum](https://gonum.org) exists :)
Thanks for the tip, I'll change that :)
[https://github.com/golang/playground/](https://github.com/golang/playground/)
I'd love to hear your thoughts on what a better interface would look like?
These cures are just wildly worse than their corresponding diseases.
Frameworks...frameworks everywhere.
More, less all-emcompassing interfaces would be my guess. 
I believe a `go generate`-based tool, which would emit a regular .go file containing the final concrete "wiring"/"glue"/"resulting structure", would be as close as one can get to "the Go way" when doing DI. Does anybody know if any of the existing DI tools implement this approach?
I feel like remembering [this classic essay against magic in Go](https://stephensearles.com/three-reasons-you-should-not-use-martini/) is called for here, for those newfangled gophers who may be did not have a chance to read it.
The author of this blog post is using a straw man argument to justify this weird bloated paradigm. Functional constructor options work very well at solving the problem they mention in a comparatively simple way: https://github.com/tmrts/go-patterns/blob/master/idiom/functional-options.md
Welcome to Go :) We usually do not have a `src` folder for Go projects. It is idiomatic to have the primary package in the top-level folder. And then to have a `cmd/` folder inside which you have your main package and have the logic to start/stop the app.
Runtime DI?
The first half of the post talks about DI exactly as you described. It is only the last part where the part of a DI container comes in, it seems clear to me they are drawing the distinction between the two. 
The part that makes me think otherwise is in the first paragraph: &gt; I've been working with Java for the past few years and was immediately struck by the lack of momentum behind Dependency Injection (DI) in the Go ecosystem. I decided to try building my project using Uber's dig library and was very impressed. There's not a lack of traction behind DI, just a lack of traction behind DIC libraries. They're not necessary.
That is the author's opinion about traction. What I was responding to was your statement about they confused DI and DIC. They know and articulate DI without DIC.
The author does indeed talk about containers "separately", but even then says: &gt; The term "container" is often used in DI frameworks to describe the thing into which you add "providers" and out of which you ask for fully-build objects. Even this too sounds a little like they could believe that DI is not DI without the container aspect (or another name for it). "DI frameworks" is another thing, because what would a DI framework do? DI takes advantage of language features. Anyway, these are the reasons why I said it _seems_ like they've confused it.
Not sure where you got `sync.Lock` from. There is nothing like that. I think what you are looking for is `sync.RWMutex`, and use the `Lock()` and `RLock()` methods.
Author here. A few points of clarification: * I do understand the difference between DI and DIC. The first half of the post was intended to show how to architect an application using DI without a container. The second half shows the benefits of using containers (which I colloquially call "DI Frameworks" to avoid confusing folks new to the ideas). * I agree that a downside of using a framework like dig is sacrificing some type safety at compile time. In terms of the java landscape, I'd place dig somewhere between guice and dagger. It has learned some of the lessons that dagger has learned from guice (only supporting constructor injection, reduced feature set, simple API) but it didn't go so far to implement the container using code generation. If there was a DI container in go that used code generation to produce compile-time guarantees around injection I would be a happy user, but I didn't find one. Based on the current landscape I believe dig is the best choice. Even considering its downsides, I still believe using dig is a better choice than hand-rolling the initialization of your components. * I knew before writing this post that DIC was considered "non-idiomatic" in go, but I felt it was good to write regardless. I believe it is important for the go ecosystem to experiment with tools and techniques found elsewhere -- especially when these techniques have proven over time to be very useful when building large applications. After all, go explicitly states that support for building large applications is a language / ecosystem goal. Thanks for all the comments so far, I've enjoyed reading them.
Until people really get into creating a full ecosystem in Go (which is partially reinventing the wheel), there's every chance that one of your CI tools already needs Java. Now that we have containers it's at least better than it was in terms of using it, even if it is bloaty.
Indeed, my opinion is language agnostic. I refuse to use frameworks for DI in Scala, Kotlin... anything.
Even with another package manager this is still a problem that will result in a build error. Let's imagine A could say "I only work with 0.1.1" and you thought to do this ahead of time - what happens when you try to upgrade B? Your build fails because there is no valid version of C that satisfies both A and B. No matter what package manager you use, upgrading B requires you to also update A to also use 0.2.0 of C for your code to compile. The only real difference I can see is that IF you thought ahead and limited A to only one specific version of C, then your error will show up in your dependency management tools instead of when you build A with an invalid version of C, and I suspect most people ARE NOT thinking ahead and locking A to a specific version of C since they don't actually know that the new version of C will break backwards compatibility. I can't come up with any situation where vgo will cause an error where something like dep wouldn't aslo result in an error. The only difference between the two might be how that error manifests, but in both cases the error is going to be present. 
I tend to solve this with [environment objects](http://www.jerf.org/iri/post/2929), which I just construct and accept the resulting construction code is a bit messy. (Code shouldn't be more messy than the problem it is solving, but environment construction is a messy problem, so it isn't a shock that the code for that is messy too. In that case it is arguably a problem if the resulting code is _too clean_; it means something is lying to you.) Usually I have a function that creates a default "real environment", and my test code ends up with a function that creates a default "test environment", and mixing and matching is easy because it's all just Go structs and interfaces. Not mentioned in that piece is that they can be modular based on package, too; I'm currently writing an app that has several module, and there's an `app.Env` that has things everything needs, like the database connection, access to the configuration, and other such things, and then the modules can define `module.Env` that composes in the application environment, and adds whatever that module needs. Then the unit tests can have construct environments that only have what the local code needs, without the other modules interfering.
I actually did this before on a project. I think the Go devs separated it out intentionally due to Go being used in networking and systems stuff a lot as opposed to web APIs where frameworks like Ruby On Rails, etc. do this automatically. Not a bad idea though, for those who want that functionality in their webapps. Might be worth noting that people are more and more avoiding third party projects for very simple things like this (ie. you could implement this in a single function and struct) due to the prevalence of security bugs or malicious code distributed to devs in this way through OSS package managers like NPM or rubygems. Personally if I wanted to merge params like this I'd just write it myself.
As a complete package of an IDE, auto imported graphics and other math libraries, I don't think so. You can use golang as a scripting language if you want to make simple programs, and there are some graphics libraries but it's going to be hard to achieve what Processing does with golang.
&gt; Your build fails because there is no valid version of C that satisfies both A and B. Exactly, but that's not what happens with MVS (especially if the incompatibility is subtle)
Thanks for comment
I find it pretty hilarious that the "bad" code is 9 lines of straightforward `main()`, while the "improved" code to show how useful the dig library is, is 14 lines of code (7 in `main()` and 7 in `BuildContainer()`.) Plus, `dig` uses reflection. So basically, if I add 5995 lines of framework code, I can make my application code longer _and_ slower? Also: % go get -u github.com/uber-go/dig ../go/src/github.com/uber-go/dig/cycle.go:27:2: use of internal package not allowed This is the worst sales pitch for a framework ever.
Honestly, I think DI containers confuse people new to DI. All ya gotta say is: put dependencies in some sort of constructor. I’ve seen this for years. How we all choose to facilitate and abstract that is really personal preference. I’m not saying a convention or a framework or a helper or a container can’t make the process easier...but it will never make the concept easier.
Somewhat ironically, this is showing on /r/golang right [next to your post](https://www.reddit.com/r/golang/comments/8jm8pm/justforfunc_34_plotting_data_with_gonumplot_ml4g_1/). It's probably about as close as you're going to get. Golang has the various low-level libraries and bindings, but nothing like the whole package, as poxopox said.
/u/pmassch: do you want to show off how `pa-m/sklearn` fares in this Kaggle challenge ? :) - https://www.reddit.com/r/golang/comments/8jn8z9/kaggle_challenge_on_cern_data/ - https://www.kaggle.com/c/trackml-particle-identification there's a Go SDK :) - https://github.com/sbinet/go-trackml
Don't forget much more brittle too!
Given that the process without the library is: bb, _ := ioutil.ReadAll(r.Body) defer r.Body.Close() uup := &amp;UpdateUserParams{} json.Unmarshal(bb, &amp;uup.Body) uup.SomeGet = r.URL.Query()["someGetParam"][0] (plus error handling), I think the real question is whether you think you can add enough value that people would want to add an entire dependency just to avoid a few lines of code to decode both a body and a URL from a request.
Thanks for the response. &gt; Even considering its downsides, I still believe using dig is a better choice than hand-rolling the initialization of your components. How long have you been using a solution like Dig? I've had to deal with something very similar to it for months now, and I can tell you, it's been an endless source of pain and confusion. Things like unclear error messages, runtime panics, runtime panics that don't occur at startup, cryptic error messages, and just a general lack of clarity all really add up. I can understand that you wouldn't want to make a giant main function, that _is_ confusing, I agree. There are ways to avoid that though by making smaller modules in your code, and creating types yourself that create dependencies. The only time I think a code generating DIC would be useful is if you already have a large enough codebase for it to be a pain to write your own manually. Otherwise, it's really not that difficult to write or maintain manual wiring, and is often quite clear. I can definitely understand the draw towards these kinds of libraries if you've come from another language like Java or PHP, but I just could not sacrifice those compiler guarantees for something that provides well... IMO no benefit, but that's subjective.
Agreed. It's a fantastic format, too.
For the sake of brevity on my phone I call it magical because it hides things, and that certainly can be brittle. As with anything it’s a tool which has an appropriate time and place to be used.
Well Go 'IDE's are in Java and Javascript. CI tools in Java and so on. My feeling is even Kubernetes is Java software in spirit masquerading as Go.
There is a bazel-like build system called "please": https://please.build
Thx! Wich graphics library can you suggest? Especially with some animation features? I stumbled over Processing in Code Bullets YouTube vids about AI (Example: https://youtu.be/BOZfhUcNiqk). I'm trying similar in golang. So, I'm aware of the mentioned CodeOfFunc video (-series).
JavaScript. Oh wait we can’t say that. ECMAScript. ES5, ES6, ES2017... It’s not quite the same thing but Go is definitely not the only language with this issue. 
Thx! Wich graphics library can you suggest? Especially with some animation features? I stumbled over Processing in Code Bullets YouTube vids about AI (Example: https://youtu.be/BOZfhUcNiqk). I'm trying similar in golang. So, I'm aware of the mentioned CodeOfFunc video (-series).
&gt; JavaScript. Oh wait we can’t say that. ECMAScript. ES5, ES6, ES2017... Come on, you forget Java!
Yea I know what you mean. 
I blame google for that. Search for Go &lt;problem&gt;...a whole bunch of irrelevant shit. Search for Golang &lt;problem&gt; ... exactly what I want.
So is mine. I just referenced PHP because of all the ways frameworks have gone about DI/DIC there. It’s a good study on it. It’s also a good example of how incredibly complicated it can all get. My point being, why complicate it?
I hear the game go is increasing in popularity. Now outranking chess!
Google Translate does a good job on this!
Thx! Wich graphics library can you suggest? Especially with some animation features? I stumbled over Processing in Code Bullets YouTube vids about AI (Example: https://youtu.be/BOZfhUcNiqk). I'm trying similar in golang. So, I'm aware of the mentioned CodeOfFunc video (-series).
Code comments are a good thing...
Laravel is extremely bloated. It will take a lot of work to get a Go API up to par with its features. Though I don’t know if you need or want to. Go will be worlds faster and the type safety is wonderful for an API. If you can start out small and slowly add what you need, then I think you’re better off with Go. If you need all sorts of stuff done in a day, you might still use Laravel...though I’d really recommend moving to Go. I was a long time PHP user. I switched. Laravel is not a good framework either. There’s an abundance of issues both in terms of design and performance. I’m not sure where it’s at now, but it was dangerously coupled to Symfony before. It’s extremely bloated and it’s also limited in other areas. The ORM is among the worst of all major PHP MVC frameworks. It was the guys pride and joy, I know...but he left it incomplete and lacking. Maybe It’s in better shape now, who knows. Give Go a try and you may never want to look back. I say this as someone who used PHP for over 10 years and contributed to some of those MVC frameworks. I know that space well.
[This one](https://github.com/fogleman/gg) looks similar to what is provided in processing. 
Some time ago I wrote [similar helper](https://godoc.org/github.com/artyom/httpflags#example-Parse) for personal needs. Though it only takes care of query/form arguments, I also used it few times combined with encoding/json to populate struct fields both from query arguements and json-encoded body, something like this: args := &amp;struct { Name string `flag:"name"` Age int `flag:"age"` Extra bool `flag:"extra"` Email string `json:"email"` }{ // default values: Age: 42, Extra: true, } req := httptest.NewRequest(http.MethodPost, "/?name=John%20Doe&amp;extra=false", strings.NewReader(`{"email": "john@example.com"}`)) if err := httpflags.Parse(args, req); err != nil { return err } if err := json.NewDecoder(req.Body).Decode(&amp;args); err != nil { return err } fmt.Printf("updated args: %+v\n", args) this prints: updated args: &amp;{Name:John Doe Age:42 Extra:false Email:john@example.com} I never felt the need to include automated decoding of json-encoded bodies into this library feeling this would clutter it. In a separate project which relied on such pattern a lot I just copy-pasted code from that package extending it to support json-encoded bodies as above.
golang golang *golang golang* ***golang golang*** for fuck's sake it's **Go** \*goes back to eating rocks and swearing\*
There is `sync.Locker`
You go Go!
Exactly, this is what happens when you use a generic name for a programming language (or anything really). That being said, naming it after the game is cool, it's just a search engine disaster. tl;dr we're stuck with some form of Golang forever for the purposes of disambiguation.
&gt;goes back to eating rocks and swearing I like the honesty.
&gt; Is it safe if I only lock the struct You can't lock a struct, you lock a section of code that accesses the struct.
Great episode! I've posted this in the #data-science channel already but let me post it there as well... - I (and a few others) have also been annoyed with how plotter.XYs forces you to have row-wise data whereas you usually get column-wise data (e.g. extracting data from a db) that's why there's ZipXY in hplot: - https://godoc.org/go-hep.org/x/hep/hplot#ZipXY ￼￼￼￼￼ - `hplot` has a few interesting "extra" plots too: https://github.com/go-hep/hep/tree/master/hplot - https://github.com/go-hep/hep/tree/master/hplot#tiles-of-1d-histograms - https://github.com/go-hep/hep/tree/master/hplot#subplots - https://github.com/go-hep/hep/tree/master/hplot#diff-plots - `hplot` has an `x/exp/shiny`-based backend for `gonum/plot/vg`, to draw plots on the screen and, lastly: - https://github.com/sbinet/go-web-examples/tree/master/07-go-web-plot-gonum-svg: a little web server that display `gonum/plot` SVG plots (transferred over `WebSockets`)
If your threat model really requires that the shell / environment is not secure, then perhaps your best bet is to just read the API key from a secured file, then pass the name of the file as an argument.
 % go get -u github.com/uber-go/dig ../go/src/github.com/uber-go/dig/cycle.go:27:2: use of internal package not allowed This is more of a comment on Go's import rules than anything else. The actual import is `go.uber.org/dig`, it's failing because you're telling Go to put the source in the wrong location.
It's sad, that people let technological limitations dictate their use of language. The rule of thumb "Go for human consumption, Golang for indexing" works perfectly fine and means that there is hardly any reason for anyone to ever actually read the term "golang". Tag your post "golang", if you feel that's necessary for SEO, but use the regular, correct name when you actually talk about it.
I think [`rclone`](https://rclone.orh) by u/ncw [has this implemented just about perfectly](https://rclone.org/remote_setup/).
He probably meant that there is code that is commented out, not being used.
None that I know of. I wonder if a `go generate` based tool would get any different of a reaction, though?
I have, values in protobuf can have a null value so everything is a pointer. It's not code I would write by hand. There are other code generators for protobuf to go that give you more control, but the extra complexity was not worth it the last time I tried, which was a few years ago. YMMV 
It seems idiomatic to me...create a key, and a value of type value, which has a sub value that is one-of these inner value types. How would you expect the structs to look? Go does not have unions and if you want to be strictly typed, you wouldn't want interface{} to be accepted.
&gt; I have, values in protobuf can have a null value so everything is a pointer. Note that OP uses proto3, which fixed this particular shortcoming by no longer differentiating between "zero" and "not provided" (kind of like struct literals in Go are doing). protoc-gen-go now generates simple fields for all non-message types. `oneof` still sucks, though.
I see, one of is union types right? Which is not supported in go, which makes its use awkward. 
I am not complaining about what you enter as a search query. I am complaining about the unnecessary use of "golang" in the article. Google the search engine knows that "golang" and "go programming language" are the same thing.
I think I would mostly like something like this k1 := &amp;test.Key{ Name: "keyname", Value: &amp;test.Value_BoolVal{ BoolVal: true, }, } which could be accomplished with interfaces, I think even with interfaces the package already creates but keeps private, i.e isValue_Value I think I am only saying this because I want a re\-usable one of value, kind of seems like a shortcoming of protobuf, there should be a top level object "type" syntax = "proto3"; message Key { string name = 1; Value value = 2; } type oneof Value { int64 intVal = 1; string stringVal = 2; bool boolVal = 3; } } or something like that, but I don't know how common something like that is
do you mean message Key { string name = 1; Value value = 2; } message Value { int64 intVal = 1; string stringVal = 2; bool boolVal = 3; } because then I would have to add some kind of "type" identifier :\(
It could but you'd have to maintain some stupid ass manifest to declare your dependencies. It don't see the point, just write a fucking factory in Go directly.
I feel like with interfaces It could be less awkward
Done here. https://github.com/volatiletech/authboss/commit/852508259cda11fd66e916ece7ade113e3163331 Hopefully this implementation is sufficient.
Is the protobuf file pre defined or are you writing it from scratch?
The reason it keeps it private is so that it can make sure nothing outside of the package implements the interface but one of the 3 values you have there. Yes, lack of top-level unions is somewhat of a limitation of Protobuf. It has nothing to do with Go. If you want what you that to not go one level deep, then put your oneof inside of Key. if you want it separate, you are asking Protobuf to create a "value" field of Key, and then a "value" field of Value which is exactly what Go does. I hope that's clear...Go is doing exactly what you put in Protobuf and the shortcomings are not specific to Go.
I would just store the value as a byte array, with a separate type parameter to store the type. The benefit is that it allows you to store data types not native to protobuf. But otherwise I don't see how you can do it any better than now, unless you don't need protobuf at all. Another thing you can try is to write the go data structure first, so you get the idea of how it should look and work ideally. You can even just use json or gob to send it. Maybe that can help you decide how to structure it in protobuf too.
&gt; If you want to not go one level deeper, then put your oneof inside of Key. If you want it separate, you are asking Protobuf to crea I completely understand what its doing and why, I just feel its clunky, and was looking for some insight and inspiration, I think I might have figured a way to structure my protobuf file to make it a little less clunky, but I wanted to poll some gophers and see if they have any interesting work arounds or similar experience :P
As you said, oneofs are really clunky in Go. However I still think it's preferable to doing something like this, where you have multiple fields that need to be handled, and no help from the compiler. I use them a lot, and I think with some slightly thoughtful design, you can mitigate the problems (by handling the oneofs alongside the marshalling/unmarshalling so the rest of the application doesn't have to deal with them).
I told my old boss that Go is the future server side workloads. He didn't believe me we made a bet that in 3 years Go will break into top 10 langs in 3 years, that was 2 years ago. Today Go is near the top 10 (12), [http://githut.info/](http://githut.info/)
&gt; Which is not supported in go, which makes its use awkward. The issue isn't really with it being a union (Go can map sums, by using interfaces, as it's doing right now), but that the generated code needs to work well both with anonymous oneofs and separately declared ones (AFAIR). I think there are plans to improve the oneof API, but I don't remember where I read that and what the details of that where.
It's not as bad as C, C++, C#, D (that one uses dlang and d-language a lot), and some other.
thats even better for Go!! Looks like I just won a PS4 Pro
Why would I? It should siphon all required data from source code parsing and analysis.
Working on these bug fixes, how do I prevent from registering handler twice. I have setup a bool if then system so that if it is running it sets a bool to show that and it can't be started again, but if i stop it and then start it again, it never stopped the http.handlefunc method. Does server.shutdown\(\) not do that? What to do?
Parsing and analyzing what? How do you tell a struct that takes an interface as a field what concrete type to inject? 
Can you direct me to the official website?
Too bad the mostly Java shop I work at sees no reason to use Go. They see the type system and the ecosystem as a step backwards, and that’s a battle I’ll never be able to win. 
&gt; It seems like it never stopped the http.handlefunc method. It never "started" it either. `http.HandleFunc` doesn't *start* anything, it adds your handler to a list in `http.DefaultServeMux`. It doesn't *stop* being on the list because you shut down a particular `http.Server`. Just register your handlers once, instead of trying to do it over and over.
I basically only search for "golang" now.
https://mholt.github.io/json-to-go/
little off topic but I did use flat buffers and it was much nicer than tbG
You haven't created a method called `ReadCmd` for your `Bot` type. What are you expecting to happen?
I'm an idiot. Thanks!
PHP is a dynamic language and weakly typed, you don't really need DI at first place. This is just cargo-culting from Java. Now Laravel makes it a bit less pain ful, but Symfony and its YAML config files? lol, Symfony has good bits but it also was always over engineered. Now that more apps are API the bloat is obvious since the whole view layer is completely unecessary (forms,templates and co). 
I work at a mostly Java shop also. Managed to start pushing Go by coding a few small tools here and there. Starting to gain traction, especially now that AWS Lambda supporters it.
[https://madnight.github.io/githut/#/pull\_requests/2018/1](https://madnight.github.io/githut/#/pull_requests/2018/1)
Load your driver and write your statements as you would write them for your DB of choice. Maybe I'm not understanding what you're asking here? Are you just after a tutorial on using Go to work with a DB? 
It expects the SQL dialect of whatever database you’re talking to. So, if you’re using MySQL, send their flavor of SQL, Postgres then Postgres SQL, etc. 
I'd think you would mostly be doing it at preference. Ultimately I try to keep things in position relative to the scope, makes it much easier to maintain
&gt; What are your thoughts about declaring variables in the middle of the code, right before the line they are called Generally, this would be my preference.
Like [gorgonia.org/cu](https://gorgonia.org/cu) ?
I would have never guessed that VimL is above GoLang
Generally var are declared on top along with any other types and then following that functions , receiver methods. But if the file is long enough it would be better to declare it closer. How I would do it is to see if your file is trying to implement different logic in the same file. Then all the relevant variables that are going to be used to implement that particular logic are kept in the same area. Makes your code easy to read and maintain
I prefer to keep them closer to where they're first used (C++ style), not all at the top of the function (C89 style).
This is a [good article](https://stackoverflow.blog/2017/09/06/incredible-growth-python/) on programming language popularity and growth though it's more about Python. [This chart](https://i.imgur.com/nCDNjX9.png) specifically is really useful representing usage on stack exchange. Languages like Python are Java tend to see a significant boost from Academia/students. The Y axis represents year over year growth rate. Java is flat and Go grew 40% year over year. The X axis represents popularity and it breaks into top 10 after removing the things (linux, windows etc.) that aren't programming languages. Go is definitely growing outside just a small niche. 
As a Java developer, I love go for it's simplicity and it's concurrency model. Java isn't as simple because it's ecosystem is shielded rather well by it's tooling/IDE support Go on the other hand, has decent tooling already built in the language. Any editor can just reuse that functionality to integrate with go
golang :), http://go.com used to be a web portal that was trying to compete Yahoo and Lycos but now it's like site map of Disney websites and properties. Buying it would cost a huge fortune. Golang.org is easy enough to find go.org on the other hand is pretty much a parked domain that looks owned/operated by a single person. That one google might be able to buy for a reasonable price. 
I read a bit of your problem statement as you termed it. I did not read your code. Weak areas: problem poorly described, yet you jumped into implementation right away. Learn about requirements. Then ooad and golang duck typing.
Your best bet is to break down that main function into smaller ones so that this is a non-issue. 300 lines is.... excessive. And probably untestable.
With struct tags? Whatever I'd need to express in a manifest file, I can as well express in some "helper" .go file. And I don't see how extra info needed for a static analysis tool wouldn't be also needed for a reflection-based tool. That said, I'd expect the DI tool to try to discover the dependencies on its own as much as possible. If I have to annotate each interface with a name of concrete type to put in it, this gives me no worthwile advantage over just writing it as normal code.
If you've written your resolvers the way you describe in the blogpost then you have a race condition. You need to guard the object creation with mutex, otherwise when run in http/server it can create multiple instances of the same object, from multiple gorutines.
I like declaring the error variable on top, because otherwise if I have something like: err := asdf() ... err = qwerty() and at some point remove the first line, I have to add ":" to the last line, which is a bit annoying.
I usually use the term once in plain text too, like "the go language (sometimes referred to as golang) is yada yada yada".
I think you missed some things and some are overkill. I'll do a PR fixing those and provide explanation later today.
In order to find a quick response to this kind of questions you have to imagine you are reading that code for the first time.. where would you like to find the definition of a variable being used in the current block ? I think it's obvious you don't want to scroll 3-5 screens up for each new variable or function you encounter in code. Code is read a lot more times than it's written.. therefore code should be easy to read, not easy to write.. Also if you notice that you are worrying a lot about the aesthetics or rather minor improvements in performance, you should probably ask yourself if you really work on something important or you are just wasting time. When you solve important problems and work with the users/clients in mind.. a lot of these questions (where should I declare my vars, long names vs short names, how many lines in a function, etc) look like a complete waste of time. Nicely written code is of no use to the users.. but robust code with the right functionality, feedback and intuitive behavior is priceless.
sqlboiler seems awesome, will definitely give it a try! Thanks for your work!
The `database/sql` package is maybe better understood as a database driver abstraction than an abstraction directly over whatever database you are using or a database in itself. It doesn't implement SQL. Read up on `database/sql/driver`; these are the types that a database drivers implements in order to be used by `database/sql/driver`. Then, to learn how to write statements, read up on the database driver you are using. Most likely it'll map very closely to what the database back-end supports.
&gt; Also, having a 300+ line main function sounds like a bad idea anyway. This.
&gt; The downside there is that the user needs to set it in a shell startup script or export it directly in the shell session. Which means it's stored in clear text on disk or visible when the export command runs and also stored in the shell's command history. Doesn't really solve anything, as the encryption/decryption key also needs to be in this environment. There's no such thing as zero-knowledge configuration, as zero-knowledge would mean: no configuration.
There's no race condition in there at present, as far as I can see. The resolver would also resolve your handlers. If you needed a service to be a "factory service" that's created each request, I'd make the resolver function returns a function to create a new instance of the service. For example: func (r *Resolver) ResolveANewInstanceEveryTime() *some.Service { return func() { return some.NewService() } } Things like the logger that are kept as a pointer field on the Resolver instance itself are set at application startup, once. If you wanted to store one of those factory services on the struct... I'd argue that that would be a bad idea, because of the raciness, and you shouldn't need to do it if it's per-request.
Yeah, I read all the docs for the postgres driver. Now, I guess I just need to learn postgres lol
I agree with the Stutter, something I shall fix. About the skipped/ignored errors, I chose to skip only the ones where the function has not errors to return (this happens because I would like to keep the function signature fixed). I will take the strongly typed comment as a good suggestion and create a type for the different command types. Again thanks for your feedback, really appreciate you taking time to critique the code :)
The first example is correct for any dependency that isn't lazily loaded, and isn't a factory service (but even in the case of a factory service, you'd probably not store the created service in the resolver, only for it to be replaced by another request). If it is one of those cases (I may be missing some other cases too), then the mutex approach is ideal. Even for lazily loaded services, you may not always need to use mutexes. In the context of HTTP it's far more likely you won't use lazily loaded services. However, if you have an application with multiple commands, maybe something to handle migrations, another command to start a web server, another to process importing some file or whatever, then the lazily loaded services come in handy because you only initialise what you're going to use for that run of the application. In that case, you are less likely to interact with the resolver in several goroutines - you're still more likely to ask for something at startup, and then just use the things that are initialised from doing that. Essentially what I'm trying to say is, the resolver should only really be used in either main, or some other place like a CLI command when the app is starting up. You shouldn't be passing the resolver around to ask for deps from it, your deps should have what they need injected, and you shouldn't see the resolver again - i.e. no concurrent contexts.
300 lines could be defensible for a function, but if they're asking about var declarations at the top, there's likely a lot of refactoring they could do.
Both Clean Code and Code Complete advocate declaring variables as close as possible to where they're used.
Any search engine worth using can determine these synonyms. 
Speaking of which is there a std method somewhere to say if an interface{} is zero value? Or do you have to do all the checks yourself
The clients in this situation are small embedded micro controllers. I really would prefer something compact on the wire and cheap on cpu
Yea I think you are right. I was trying to take shortcuts and use the protobuf structs as more then the transport layer. Bad developer :( at least if I invest the time separating transport from business now when I get sick of protobuf later it will be an easy switch
Does it work good as a wire protocol? It seems to be more for data files and random access
Close is king in my book. Need to clean up the main as well. 
man that new "Full Stack" langauge/package is surging. sigh. This chart looks to be more about trendy resume keywords.
i perfre to keep them together when declaring variables.
Thanks for your work on this. One thing that has frustrated me in the past is a lack of flow diagrams for handling auth \-\- things like forgotten password, change password, etc. Any chance you could include block diagrams of your algorithms?
It's also been pointed out that with dynamic language scripts for devops, the scripts run fine right up to the line that fails, possibly leaving your system in some indeterminate state. With Go having compile\-time type checking, some of the those problems will be discovered before they wreck things.
That is the book that I read to learn Go about 2.5 years ago. I still look things up in it when using a feature that I have not used much before. Love that book.
&gt; with chmod 600 chown root.root to limit reading this to the root user (docker runs as root) config.json is owned by your user, not root. the docker daemon runs as root, the docker client does not. The docker client doesn't even need to be running on the same system.
Right, the argument here is (probably going to be) that gps2 would resolve the impossibility of predicting the future by either allowing the maintainer of A to retroactively lift the restriction on 0.2 (once you know it does work), or by allowing it to be added (once you it doesn't work). MVS can't handle that, even if you did keep track of this in some kind of global database, because it doesn't allow any restriction on versions that are "supposed" to work based on the version number, and to make matters worse uses it uses a different heuristic than semantic versioning (which considers pre-1.0 the wild west).
If you start using Go for devops, you will probably find that you have several small functions and types that you use often. You can create a small library of these that you then include in new scripts, or even better, just create a \(shared\) gists library and copy/paste the fragments to your scripts. As Rob Pike said in his "Go Proverbs" \&gt; [A little copying is better than a little dependency.](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=9m28s)
I assume you are asking whether the dynamic value contained in an interface is the zero value of its type, without knowing the actual dynamic type (if you know the dynamic type, as with protoc-generated code, the answer is to compare against the zero value of that type). The simplest way to do that is probably `reflect.Zero(reflect.TypeOf(v)).Interface() == v`.
Some first impressions: - It's not idiomatic Go to have a `pkg/...` dir, I'd remove it `pkg` from the path. - Unnecessary line breaks in a lot of places, did you run `gofmt`? - Some commented out print statements that shouldn't be there - Some unnecessary use of goto's for otherwise very linear code; that's usually a smell that the majority of the body should be in a helper function and the caller should include the cleanup/handling. - Isolate "ugly hacks" into standalone helpers that are more obvious, easier to replace, and less buried. - Why not [res.Result = strings.Contains(...)](https://github.com/psankar/network-monitor/blob/master/cmd/minion/minion.go#L128-L132)? - A lot of really long function names that take in a lot of state (.e.g "createDoesContainRequestAndEnqueue"). These could be much simpler if they were attached to a stateful struct that contained all their common state, and the name of the struct could inform the name of the method as well. - In general, the code reads too much like C--perhaps the author hasn't learned how to create structs with methods on them, more on that here: https://gobyexample.com/methods I didn't look at the overall design, and it seems like you have already improved a lot of the code since you first posted it, so good job at that! It doesn't look _too bad_, but I would suggest fixing the above. :)
Go has OOP. It just does not have inheritance. I think \(coming from 23 years of Java programming\), that the lack of inheritance makes Go MUCH more readable.
\&gt; [interface{} says nothing.](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=7m36s)
That used to be required in C. Same people think it's good style because of it. Also, non-strict Javascript, where declarations make a variable scoped to the function from its beginning to its end, regardless of where it was declared. I always refused and pretended the language wasn't idiotic.
Monzo?
\&gt; Then came Forth and I could do any thing but no one could understand my code. Forth, like APL, is a write\-only language. \(I would argue that Perl also fits hat description\).
:\-\)
&gt; You don't *need* it. You want it. That's a meaningless argument as it can be arbitrarily extended to *anything*, e.g: &gt; You don't *need* functions (you have `goto`). You want it.
try it, https://play.golang.org/p/dznC3psTZcG hopefully the error message will be clear
[removed]
This is a function declaration: var myFunc = func() { a, b = b, a + b } This is a invocation of that function: myFunc() This is a deferal of the invocation of myFunc: defer myFunc() This if the deferal of the invocation of an anonymous function: defer func() { a, b = b, a + b }() Without the \(\) at the end, you're not actually invoking the function. You're trying to defer a function \*definition\*, which doesn't work. The compiler is complaining because you're not actually calling your function, you're just defining it.
https://golang.org/ref/spec#Defer_statements says: &gt; A "defer" statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking. &gt; &gt; `DeferStmt = "defer" Expression .` &gt; &gt; **The expression must be a function or method call;** it cannot be parenthesized. Calls of built-in functions are restricted as for expression statements. Emphasis mine. The expression must be a function or method call. That's why you need the (), to make it a function call rather than just a function. E.g., consider if you had a top-level function `hello`: ``` func hello() { fmt.Println("Hello.") } ``` To call that function, you'd write: ``` hello() ``` To have that function called during defer, you would write: ``` defer hello() ``` If you wanted that function to be assigned to a variable, and then deferred, it would be: ``` hello := func() { fmt.Println("Hello.") } defer hello() ``` If you want to define a function and call it inline, it becomes: ``` defer func() { fmt.Println("Hello.") }() ``` Notice how the entire function gets substituted in place of `hello`, and the `()` are always at the end to make it a function _call_. Hopefully that makes sense.
the docker unix socket and the config.json in the home directory are two completely different things. The credentials you are talking about aren't even for the docker daemon, they are for the docker registry.
If often is, but not always. See [this article](http://number-none.com/blow/john_carmack_on_inlined_code.html) by John Carmack.
Ah! So, hypothetically... the func (){} is the declaration of the function, and since it's anonymous there's no name, and it's just (). The name is implicit, right? And I presume, this could be done only once in the code, since you can't invoke a function that doesn't have a name to invoke it by.
 if err := qwerty(); err != nil { ... }
It so much clearer now! Thank you SO much!
&gt; pretended the language wasn't idiotic "use strict"; (() =&gt; { x = 42; var x; console.log("x: %o", x) })() //=&gt; x: 42 (() =&gt; { y = 42; let y; console.log("y: %o", y) })() //=&gt; Uncaught ReferenceError: y is not defined I always liked, that you can define the variables **at the bottom**! /s 
 func (){} Is a function that has no name, takes no parameters, does no work, and returns nothing. It's mostly worthless. Without being "stored" anywhere, it can't be invoked except in\-line, either, like this: func (){}() &gt;And I presume, this could be done only once in the code, since you can't invoke a function that doesn't have a name to invoke it by. Without assigning it a name somewhere in the symbol table \(var, as a parameter, etc\), invoking it at its declaration would be the only way to invoke it.
You're friggin awesome, man! Thank you!
Features: * You can work with several databases in one time * You can visit nested buckets * Minimalistic and simple interface
Nice, I'd been looking for something like this! Hopefully in the future, editing will be possible too. :)
The point of using protobuf is to send keys as small numbers, why are you sending them as strings?
Thanks! Way nicer on my eyes.
Thanks a lot :)
Instead of repeating that you're using a custom configured local user in the docker user group (which is not the default), I'm just going to leave this here: ``` debian@front1:~$ docker login Warning: failed to get default registry endpoint from daemon (Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.32/info: dial unix /var/run/docker.sock: connect: permission denied). Using system default: https://index.docker.io/v1/ Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. ```
becaue you need to defer and actual statement. AKA do something. 
That’s definitely their stack.
There's no syntactic difference between calling a function that is defined (and thus named) elsewhere and calling a function that you are defining at that point in the code, except that, since you're defining it there, you need the function body in place of an identifier declared elsewhere. https://play.golang.org/p/3VuCwfGGM_E
More-specifically this is a web-**based** browser for a boltDB store, though I'd still probably call it a "web-based explorer" myself, just to avoid the confusion.
Code generation or reflection are the two ways to do a DI framework. Both have pros and cons. One example of code generation approach: [https://github.com/fgrosse/goldi](https://github.com/fgrosse/goldi) Keep in mind it requires an executable to actually do the code generation.
or, if you really need separate servers you can spin up and down attached to different routes (and ports, I'm assuming), you need to avoid `http.DefaultServeMux` and spin up your own, per-server muxes. mux1 := http.NewServeMux() mux1.HandleFunc("/foo", fooHandler1) mux1.HandleFunc("/bar", barHandler1) srv1 := &amp;http.Server{ Addr: ":8080", Handler: mux1, } srv1.ListenAndServe() mux2 := http.NewServeMux() mux2.HandleFunc("/foo", fooHandler2) srv2 := &amp;http.Server{ Addr: ":8081", Handler: mux2, } srv2.ListenAndServe() In fact, spinning up your own server is probably what you should be doing anyway. 
It's like you're not even reading the words that I am writing. I tried to tell you that you said something about the config.json that was incorrect, your response to that was a ton of irrelevant information about the docker socket.
Ok, thank you. Maybe "explorer" really would be better, but I think "browser" is nice enough. Nevertheless, I agree that the name should involve **based**. I'll add it soon.
&gt; config.json is owned by your user, not root. false. &gt; the docker daemon runs as root, the docker client does not. in default configuration, false. &gt; The docker client doesn't even need to be running on the same system. again, default configuration, false. You'd need custom configs for any of your statements to become true. I don't consider anything that I've written here false, and I have linked to the documentation explaining these statements and why. I am not incorrect and I linked and quoted relevant docs saying so. I did also repeat several times, that I'm talking about the *default* docker installation, so I'm not sure where you think I'm incorrect here, apart from the fact that you're describing your own *customized* installation?
No big deal, this really is the most minor of nits. I love the idea and I'm excited to see where it goes.
I give up, you keep on believing whatever you want, please just keep your crazy to yourself.
Very cool. Keep up the good work.
Agreed. Jumping straight into using dig or any other framework is an overkill. In the same way that jumping straight into an HTTP Web framework before writing a simple `HandleHTTP` with `io.WriteString\(w, "Hello world!"\)` in also an overkill. However, that doesn't mean that `dig` is not useful, even if it's purpose appears to be lost in these comments.
For a moment, I thought someone brought back the old Bolt Browser that was popular back in the wee days of smartphones. Very nice project!
Hey, thanks for commenting. Please take the time to respond politely and non-insulting, as I have. If I'm asking for clarification (as there's obviously a disconnect between us somewhere), that's no reason to be insulting and I'm definitely not inviting labels like `crazy` here.
For sure :)
So I'm not sure what the scope of this project is, if it's supposed to be the start of something that's going to make it into production, or if you're just messing around to get the hang of go/docker/sql... If you're just messing around, there are a few things you can tidy up. * Make your string literals into constants * Break some stuff up into functions. createUser(), connectDB(), etc. * in a few places you can use if err := something(); err != nil { log.Fatal(err) }
*nitpick* You aren't handling that last err 
Thanks! Well, I'm messing around for now, but I would like to know where I should be headed ultimately as well...is this not the proper way to do the database "migrations". Ultimately, the first "migration" will be just creating the database, and I figured I can just add onto it from there. I'm honestly not sure where I'm going with this. Open to suggestions though.
For a string type, as Talindras has said, it is equivalent, to the point I woudn't be surprised the compiler optimizes both of those into the same assembler. For slices, `len(slice) == 0` can be useful because either a nil slice or an empty slice return a 0 from len, so if you _want_ to treat both of those the same, you can. Since you can't use equality on slices, to check both cases otherwise would be `slice == nil || len(slice) == 0`, which makes the first clause redundant.
It says in readme “runs slowly” and “possibly crash” :)
sorry, responding with single word responses like "false." is not polite, especially when it is not in fact, false. Show me where in the docker documentation where it states that `docker login` somehow magically changes the ownership of `$HOME/.docker/config.json` to root. `$HOME/.docker/config.json` is owned by whatever user ran the docker client. You can keep saying otherwise but it won't make it true. Blanket statements like "docker runs as root" are incorrect. The docker client runs as whatever user you run it as. Considering the original topic of this thread is about storing api credentials, saying things like &gt; When you issue a docker login, it will create a $HOME/.docker/config.json, with chmod 600 chown root.root is misleading and ultimately unhelpful. If someone tried to create a config file under $HOME as a regular user and make it owned by root they would find that this is impossible.
Thank you all for your support! * We just added Python folder and hand coded minimum bindings to our C++ library * Looking to continue with mustache-templates aka handlebars and stubs for targeting data to generate Python/Golang/Node.js bindings to C++ ( currently hand coded) * We are also researching if generators can be utilized to produce TypeScript functional code for AngularJS for targeting data maintenance . If anyone is interested please feel free to contribute to this open-source multi-language project.
Interesting solution. Why not implement this on top of DNS?
I'm curious if you tried [https://github.com/zyedidia/micro](https://github.com/zyedidia/micro) before you wrote this and what, if any, drawbacks you found that led you to write your own.
It does, but I honestly don't know what to do about it. Say I have a server and I need to set bunch of stuff. Some independent, some is used in setting up something else, etc. Of course I offload the setup details elsewhere, but I still have bunch of conf loading, calls, error checking.
/u/sbinet: hi, I'll take a look. Sklean 's port 's probably a bit young for this but it will lead toward interresing progress. 
https://github.com/golang/go/wiki/SuccessStories ?
My personal experience has been somewhat the opposite: "go" is frequently ambiguous or awkward even when just talking to humans. "Python" and "rust" are both nouns that have little relevance to programming other than the languages. "Go" is a verb \(literally one of the most common verbs in the English language, as a matter of fact\), it is an adverb, and it is frequently used in both of those capacities when talking about programming. All those great "go" puns come at a cost. I use "golang" pretty much exclusively now. To be fair, I would probably spend some more time trying to make "Go language" work if I were publishing an article just for the sake of seeming more "official," but I also see nothing wrong with using "golang" in that context. Are people going to get mad at me for using the "wrong" name? Maybe. But it has been concretely better for me, so they are just going to have to be mad. I'm going to keep writing and saying "golang."
For `string` type, they're equivalent and just a style choice. I wrote https://dmitri.shuralyov.com/idiomatic-go#empty-string-check about the style choice. For `[]byte` type, `len(b) == 0` catches both cases when the slice is nil, and when it's non-nil but has length 0.
I always prefer if person.name == "" { //... } since it does the job and gives more information than the latter - I know this is a string and not any other generic container (slice, map, etc)
I originally thought it would be easier to just use an HTTP proxy. Boy was I wrong especially with basic auth. Web socket connections are completely hosed during the initial HTTP CONNECT handshake. I'm actually thinking about replacing Squid with Grimd (https://github.com/looterz/grimd). Thought I'd put it out here for feedback first.
The len version is more typing and it also makes it more ambiguous to the reader -- is it a slice or what? Seems like no pros and all cons to me.
See also [https://github.com/evnix/boltdbweb](https://github.com/evnix/boltdbweb) but this seems quite a bit nicer e.g. able to add databases from the browser and providing custom display methods \(very useful when values aren't simple strings!\)
Not a problem, happy to discuss - and if there is a problem with this pattern I'd love to improve it too! You're spot on there, that's what the pointer is for, otherwise like you said, you'd get a separate instance of a given service each time. Sometimes you want that, sometimes you don't. I think most of the time at least, you can keep this type simple and only use it from a single-threaded context, and just use it for startup. I've toyed with the idea of having multiple resolvers for larger applications too, and have one main resolver that ties them together. My background is also PHP and Symfony funnily enough, I've not spent as much time with it though. I did PHP at Uni because I wanted to learn it, left Uni 4 years ago into an agency job, stayed there doing PHP, some CMS stuff and some Symfony stuff. I learnt Go and Scala around the same time (about 2 years ago), tried to stick with Scala but didn't like it much, I could work with it but I didn't enjoy it and didn't feel as productive as I did with Go. Landed my first and current Go job about 7 or 8 months ago in a lead position and have been loving working with Go.
I met it before. One reason, why I has started to write my own program, was incapability of this solution to show nested buckets.
Yeah. . . that's the problem. I'd like an easy way to set up a short-lived API key which could be written to disk and would eventually expire, somewhat like the AWS CLI generates temporary tokens with assumeRole and STS.
The keys are client defined at runtime
No, of course not, just the auto generated structs can be painful to deal with. How do you guys encode the protobufs onto a tcp connection? What kind of message framing do you use?
I don't get. Your microcontrollers can answer arbitrary queries?
That reflect snippet was what I was looking for thank you!
Thank you for your help. I decided to use [migrate](https://github.com/golang-migrate/migrate).
No, the microcontrollers register arbitrary statically typed key value pairs on the server and update them periodically, theres much more too it but that is the gist.
Interesting to see where this goes, as pi\-hole has been a let down for me personally.
ah purely a disclaimer for now :)
interesting! I've never seen that before. it looks pretty good/polished, but I purely wrote my editor just because I can and I wanted to for a learning experience/bit of fun. the editor i initially wrote as a, "i wonder if i can implement all of the editor behaviour myself with no gui libraries", using Java as the implementation language. then when I started to port things over, go was the language I mostly used - and enjoy writing quite a lot, so I happened to write it in that.
Yea that's probably the best idea. Something to hide the ugly
It's a stylistic preference unless you have EXTREME performance constraints then "len(person.name) == 0" will be faster.
Ah cool. Glad you you are sharing it.
LOL thats the most honest readme I have seen :)
Thank you a lot! It's really open my mind!!! Wonderful. &gt; Downvoted for the screenshot instead of actual code (Reddit supports code formatting). Oh, sorry, I forgot this. Will remember.
To the best of my knowledge, it was faster to compare with "" in earlier versions, but recently it has no differ. I took the benchmark in few weeks ago.
Honestly, mostly you ship them around you Stubby which is similar to gRPC. I don't think I've really thought about it at the TCP level. I'll agree, the structs can be unwieldy for sure.
haha thank you
I'll look into stubby. My implementation needs a c client on a microcontroller. Which takes grpc off the table unfortunately. 
Stubby is internal to Google look at gRPC or anything similar.
Really why? Been great for me
&gt;The editor is written as if it's a game, so it will probably eat up your battery, as well as run possibly quite slow - especially if you dont have a **dedicated GPU** - and probably crash frequently. You need a 3D card for a text editor? Is this /r/ProgrammerHumor?
Well it breaks common websites with the default blocklists, that's a major issue for a tool that is meant to work network wide. It means I'd have to warn everyone that things might break and to remind me when it does and provide the domain, ain't nobody got time fo dat. Also, when I was running into issues, I found that using the function to (temporarily) disable it seemed to have no effect.
[removed]
Doubtful. Do you have a benchmark that supports that?
Is it important that the value of B does not change while a goroutine is using it? Say, if a function is called that reads A and B. Is it a problem if B changes during the course of that function? If so, you'll want a `sync.RWMutex`. That will allow you to take two kinds of locks- a read lock, which will allow other read locks to be taken, and a write lock, which requires that no read locks be taken and allows no other locks until it's released. The effect is that when a goroutine accesses the struct and takes a read lock, other goroutines can still access the struct, but the values of A and B will not change while the read lock is held. If a goroutine needs to modify B, then it must wait until no goroutines are reading or writing to the struct, and importantly, no other goroutines can access the struct to read or write until the write lock is released. This may not be the case, but it is a distinct use case and can be a better solution should you tend to have more readers than writers. The alternative is to have an ordinary mutex that every goroutine locks whether they're reading or writing. If it's not performance critical, this is simpler- particularly if you have a scenario where the read lock is taken, but something comes up where the same goroutine ends up needing to take the write lock. It's very easy to run into situations where between releasing the read lock and acquiring the write lock, another goroutine gets a lock- and that's a great recipe for race conditions.
Recover is a built-in function that regains control of a panicking goroutine. Recover is only useful inside deferred functions. During normal execution, a call to recover will return nil and have no other effect. If the current goroutine is panicking, a call to recover will capture the value given to panic and resume normal execution.
Sorry man, should have checked. Thanks
No - I think it might have be on a github wiki as well but I remember it specifically stating what they switched from (e.g. node -&gt; go)
https://golang.org/doc/faq#exceptions Seems to be good
https://golang.org/doc/faq#exceptions aight, took me a bit of digging. 
You will want to look into codesigning your application bundle before distribution; see macOS's `codesign` tool for this. My latest app [Miln Beyond](https://miln.eu/beyond/) is a web server written in Go and encapsulated in [a Mac interface](https://miln.eu/beyond/miln-beyond-advanced.png). Combining a Mac interface with a Go based core has its challenges but the approach worked well for me. 
If you have EXTREM performance constraints you buy custom silicon.
Is it not sufficient for you to read the BoltDB source (now at https://github.com/coreos/bbolt ) ? What additional information are you looking for ?
hi @fgmarand, i don't have any background with databases and i learn better with tutorials especially with complex topics \(at least for me\) like database
How much do you know about B+trees? Bolt is a key-value store. So a persisted map[byte[]]byte[] ( sorda, kinda). You could also use a binary tree (simpler, but less performant in some cases) to start off with, as you are just playing around. The tricky bit is mapping nodes to disk, allocating new nodes, and removing nodes. From what I recall bolt does not ever shrink the DB file, because that is a hard problem. So start by building a 'map' that is kept in memory and then do the persistence. Might not be the most optimal approach, but it should get you there. 
https://github.com/golang/go/wiki/GoUsers ?
IIRC the compiler rewrites s == "" to len(s) == 0. There is no performance difference.
Darn. Grpc wont work on a microcontroller. I looked into making a library but that would mean writing a whole http2.0 library too
perhaps this shows me that maybe I undersell my editor a lot more than I realise. a lot of whats in the readme is purely disclaimer and me being hesitant, but I'm going to remove that statement since it's false: you don't need a dedicated GPU for the editor to run fast. phi already runs pretty quick on my tiny macbook with a pretty subpar mobile gpu
That is definitely one good approach, and doing searches on a "B tree" will be very fruitful. Another angle that could be investigated fruitfully by a relative beginner is a "log structured database". At it's core, this boils down to: \1. A set of data types representing _changes_ to the database, like type Add struct { Key string Value string } \2. Code that "plays" the log to generate a concrete data structure. This can be left entirely in memory. (Even for real databases, while this is a niche option, it's a valid option.) \3. Code that can take write queries to the DB and convert them into those data types representing changes, and save them to a continuously-growing file containing all the changes to the DB. You can bring something up that "works" fairly quickly (you can have the basics of the above in a matter of hours), but you'll also fairly quickly start running into problems (even before you start trying to work out concurrency), such as the fact my nice-looking Add struct up there is likely not to be rich enough to work for very long, or that "continuously-growing file" becomes a bit of a problem, to say the least. (It then turns out that both my suggestion here and NeoinKarasuYuu's start to have some interesting combining possibilities when you realize you want to be able to efficiently save a snapshot of the "real" data structure rather than completely reconstruct it from scratch on every execution; a lot of "real" databases have something derived from both of these core techniques in their core, trying to get as many of the advantages of both with as few of the drawbacks as possible. I'll also say again that while it's niche, I know of a database that actually does just go ahead and reconstruct itself entirely from the log if it has to restart. However, it's not a general-purpose database; it is working in a specific niche where this is sensible.)
Symbols (+, #) used to be stripped in searches. So, C# searches returned various C and C++ results. I guess, search engines are smarter now or tweaked to add exceptions to the rules.
This is random, but I recently had an encounter with `codesign` that wasn't helped much by reading the man page, but I didn't get anything for my particular use case - in this case, it was trying to contribute to Ruby core: &gt; On Mac, set `RUBY_CODESIGN` environment variable with a signing identity. It uses the identity to sign ruby binary. See also codesign(1). Would you happen to know if I "set __ with a signing identity" means to set the env var to a path to a file or a hash or something else?
That's not true. Both compiles to the same assembly. See my top-level comment.
Typically `signing identity` means the `common name` in the [signing certificate](https://developer.apple.com/library/content/documentation/Security/Conceptual/CodeSigningGuide/Procedures/Procedures.html). As an individual this will look something like `Developer ID Application: Your Name (Apple-assigned-identifier)`. What this *does* is tell `codesign` to look through the default Keychains on macOS and look for a matching certificate to sign with.
(Aside, but I forgot to link to the [ruby docs][0] that I got the quote from) Thanks! That makes sense. The last missing piece for me is that the `codesign` man pages always talk about signing an app: &gt; To sign application Terminal.app with a signing identity named "authority" What things can you sign? Must it always be an application or a binary? In this case, if I'm building Ruby, would I sign the compiled Ruby binary? [0]: https://github.com/ruby/ruby/blob/trunk/README.md
Beyond is pretty awesome. I'm *really* happy you made this. I've been toying with the idea of doing something like this — a Webstar for the modern era — for awhile, and now I don't have to :-)
You would probably sign the compiled Ruby binary. On macOS, `codesign` can sign at least: - most [bundles on macOS](https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFBundles/Introduction/Introduction.html#//apple_ref/doc/uid/10000123i) such as Automator actions, frameworks, and XPC services; - [disk image](https://stackoverflow.com/questions/23824815/how-to-add-codesigning-to-dmg-file-in-mac#37923530) files, `dmg`, for distribution; - …and single file executables. Within [Miln Beyond](https://miln.eu/beyond), the following signatures were needed... - the embedded frameworks - the XPC services - with specific entitlements - the Go based web server - with specific entitlements - the Automator action bundle - …and the application itself - with specific entitlements Much of this *can* be handled by Xcode. I have build scripts to help me do this and to help catch silly errors.
Getting Beyond into the Mac App Store was a struggle. Now that I have proved such an application can exist within the store guidelines, I can more easily justify the time to improve and add features. Want specific features? Get in touch support@miln.eu !
“I hear I forget, I see I remember, I do I understand”
Nicely presented
Some ideas: * presize Bookcontents? * experiment with NewWriterSize and different buffer sizes * Take all of the +"\n" out to avoid the string concatenations and instead call writer.WriteString("\n") after writing each line? Best thing would be to do some profiling to find hotspots to focus on. 
For me, I don't organize my stuffs by language, but by applications, for example, store all AI stuffs in a place, financial stuffs in another, not matter they are in go, c++ or python. So I have several directories in GOPATH.
u/jerf and u/NeoinKarasuYuu, i appreciate all of your efforts in explaining all of these things but i can't comprehend all of the concepts that you're trying to explain. If it's not too much to ask, i would be glad if you would share some example code. Thank you very much for giving me pointers.
[removed]
Lol I was googling about this yesterday. Thanks for sharing.
[Here's a baby log-structured database](https://play.golang.org/p/bF8NIXMlCfN). There's miles and miles between it and production quality, but it really does capture the core essence of how those products work. There's multiple posts on /r/golang about how to unmarshal JSON into multiple different types, which is something you'll need to do if you want to add another type to the unmarshaling process when it loads the DB. And there's some other decisions that you have to make, like, is it the operations that know how to mutate the DB or does the DB know all that? And concurrency in this model would pretty much just be "lock the whole DB with a RWMutex", which isn't great. But, like I said, this _is_ a valid baby instance of a log structuring DB that captures many of the essential aspects of the problem.
Remove the intermediate `bookContents` slice and write directly to the writer. https://gist.github.com/icholy/5f3919e7c043c57cd2c36534fb62f982
Since GOPATH exists, it's set to $HOME on all my dev machines. I never understood the hate against that env var. Even worse, I consider getting rid of it a mistake.
No, but I will often do `GOBIN=$HOME/bin GOPATH=/tmp/whatever go get github.com/cool/new-project/cmd/cli` when I don't want to clutter my GOPATH with random dependencies.
My theory is that if GOPATH were split into GOSRC and GOPKG (there is already GOBIN), people wouldn't complain because it would just be completely normal, like where ever the hell other languages store their libraries. Having to have a src and pkg directory in GOPATH is just the thing that tips people over the edge into hating it.
There's something fishy going on with the bookContents slice. You initialize it, but in the chapter loop, you append to it then, then iterate over it. Each iteration, though, it's going to grow... So you'll keep iterating over the same lines. It doesn't seem correct. Are you sure it's even giving you the right output?
I’m really glad I saw this post. I’m sure there are a lot of posts about this, but this has been a continual trip up for me in learning golang. 
Other option is not using mysql group concat, and do it client side in go. Think perhaps would be my preferred option. 
Yeah, if you have better suggestion for me, I'm taking it. I also have its mega-const to go with it, haha. ```Go const ( // UnicentaProductFields helps to select every fields in the products table. UnicentaProductFields = "`id`, `reference`, `code`, `codetype`, `name`, `NAME_FR`, `NAME_EN`, `NAME_ES`, `DESCRIPTION_FR`, `DESCRIPTION_EN`, `DESCRIPTION_ES`, `pricebuy`, `pricesell`, `category`, `taxcat`, `attributeset_id`, `stockcost`, `stockvolume`, `image`, `iscom`, `isscale`, `isconstant`, `printkb`, `sendstatus`, `isservice`, `attributes`, `display`, `isvprice`, `isverpatrib`, `texttip`, `warranty`, `stockunits`, `printto`, `supplier`, `uom`, `WEB`, `WEB_FEATURED`, `WEB_PUSHPROD`, `SORTORDER`, `ACTIONZEROUNITS`, `ModifiedTime`" ) ```
I have found that any code which involves sql in go is bound to be ugly. Especially when you are building complex queries. 
Couldn't you work something out with reflection, getting all the struct's fields as a pointer array an passing it to `Scan` ? Haven't worked with reflection that much so not sure how you'd be able to get them in the right order though. Also risky if you add a new field. Maybe using field tags? But it would start being a lot of work just to avoid these few ugly lines, not sure it's beneficial in the end.
`writer.Flush` should only need to be explicitly called once before file exit. `write.Flush` is called internally as needed when working with `bufio.Writer`.
This will shorted it up a bit: func (up UnicentaProduct) Fields() []interface{} { return []interface{}{ &amp;up.ID, &amp;up.Reference, &amp;up.Code, &amp;up.CodeType, &amp;up.Name, &amp;up.NameFR, &amp;up.NameEN, &amp;up.NameES, &amp;up.DescriptionFR, &amp;up.DescriptionEN, &amp;up.DescriptionES, &amp;up.PriveBuy, &amp;up.PriceSell, &amp;up.Category, // etc ... } } .Scan(product.Fields()...) But you should probably just use sqlx.
I don't know how to use reflections, and I figured out that adding `.Fields()` to my `struct` was quicker than to learn reflections and *maybe* solve my problem.
Yeah definitely quicker to write and to probably to execute. I'd just change what you did to return a slice of pointers, it'll save you from having to maintain the method signature everytime you change something. You'll just have to add what you need to the slice and you're good!
You have to add `...` after the array when you use it so it's passed as variadic arguments instead of a single one.
I just copy the error message in the signature. Maybe the next person after me won't have this brilliant idea, I should probably tell it in a comment. Haha.
Oh. So now I have `.Scan(product.Fields()...)`, and it works! Next up : Null values. Ugh.
Could pass in the sql.Rows and perform the scan directly. Has some benefits.. like can need specialised code to map data to a struct, but drawback is less useful if populating multiple structs per row (like using a join of some kind). func (up *UnicentaProduct) Scan(rows *sql.Rows) error { return rows.Scan(&amp;up.ID ..... ) } If fan of QueryRow() then perhaps have to define a common Scan() interface so can use either a sql.Row or sql.Rows as the parameter. 
Awesome. I know this wasn't Go related or what you signed up for, so many thanks!
This was a while ago and my setup has changed slightly, but I answered this very question in detail in [How I use GOPATH with multiple workspaces](https://dmitri.shuralyov.com/blog/18).
What about the notion that if your main is getting saddled with too much wiring, maybe your application is doing too much, and should have responsibilities separated? 
Making DB access async with file writing and flushing only before close should combine to increase throughout substantially. If the SQL query can be partitioned, then you could split it into N reader/writer parallel chains which should either bake the DB or disk for some value of N. Multiple files could be combined in a final step — though that make negate the parallel gains. The key here is to do everything you can to reduce the serial one-at-a-time latencies as much as possible, or amortize them across several asynchronous execution pipelines. 
I read that just before posting. Sounds like your approach is the one others use as well.
... and then document it and go through the effort of announcing it on Reddit. Sounds like more work than googling "json format command line"
[removed]
How would that happen accidentally?
Couldn't agree more!
Yea I love grpc I used it to make an API for my home alarm system haha but it is too bad
Is it a home grown soulution to make the proto file? I might be interested in trying that.
That was quick?
From the looks of it, the linked "goldigen" tool still doesn't generate a regular, "plain old" simple Go file, such as if no DI was used at all. Instead, based on a meta file (yaml), it generates only the inputs to a DI framework... now *that* is layers upon layers of complexity :/ ...definitely not what I intended to ask for.
Me too! It sounds really neat. I've always defaulted to Python/PyQt whenever I need to write an desktop UI, but I'm not really a huge fan of that approach. Go could be a great alternative that I should look into.
yeah, alot of room for improvement but has potential. It's so fast i'm not sure if it's 'real' hahahah. Looking forward to contribute one way or another.
Left you a few quick issues with feedback
As a matter of best practice, you should *never* return interfaces. Always return structs
Note that this produces a different result, the original outputs book1, then book1+book2, then book1+book2+book3 ... for each author (your result is probably correct, but it's still different). for authorId := 1; authorId &lt;= NumOfAuthors; authorId++ { bookContents := []string{} for bookNumber := 1; bookNumber &lt;= NumOfBooks; bookNumber++ { for chapterNumber := 1; chapterNumber &lt;= NumOfChapters; chapterNumber++ { for lineNumber := 1; lineNumber &lt;= NumOfLines; lineNumber++ { } for _, line := range bookContents { writer.WriteString(line) } writer.Flush() } } }
It's an interesting tag line but the same is true for a naive hash map; consider the [RUM conjecture](http://daslab.seas.harvard.edu/rum-conjecture/) for why just read performance isn't compelling. Other performance or durability characteristics, like insertion, would be nice to see.
As far as I recall AWS Cognito acts as outh2 provider as well. If that the case it should be almost trivial to add Cognito to the list of supported providers. All you need is one more section in `providers.go` and a couple of parameters in main.go pls PR if you make that work, I'd love to integrate it into origin. 
Hash maps are in-memory only. This one stores data on the hard disk, distributing it across "shards", that are actually just files in the system. It also allows you to restore deleted data before it was permanently removed by calling the optimization function.
To be pedantic, hash maps are frequently used for indexing on-disk data in many DBMS. Arbitrary byte slice to offset structures are terribly useful. I think the project would benefit from an architecture description. ie, how's the what data structures are used and how's everything laid on disk. It doesn't need to be a thesis but it helps understand how everything works at a glance. Also, please add a godoc badge to the readme, its nice to have :)
https://golang.org/pkg/context/#WithTimeout https://golang.org/pkg/net/http/#NewFileTransport
Nice work dlsniper 
Using transaction is not an option?
I wouldn't trust the complexity analysis of someone who says O(2) and then O(2+N). That's not how this works.
can you explain?
It shows that you haven't ever seen a basic intro into big-O notation since these are things that should have been covered within the first hour or so. Also, it's not some kind of amazingly unique feature of a data store to have record lookup being O(1). It's not even unusual to have single index lookups O(n) (n being the number of records returned, I haven't looked at your thing, but you definitely haven't made it O(1)). Those things are trivial and quite far away from what the term "search" usually means.
I wish hegbork had been a little more constructive, but they are right, what you wrote about the efficiency doesn't make sense. Big O notation is used to talk about how something changes, not about a specific value. It's used because actually figuring out the exact value of something is really hard, and often it isn't really necessary anyway. O(1) and O(2) mean the same thing. O(N), O(2N), and O(2 + N) also all mean the same thing, though they do not mean the same as O(1) and O(2). When people say that a data structure does something in O(1), they don't mean to say that it only does one thing and that's it. What they mean is it is amortized such that you can't really tell a difference in the number of operations required as the size of the problem changes. Eg. one could say that looking up a value in a Go map is O(1). This does _not_ mean whenever you lookup a value it always executes the same CPU instructions and takes the same amount of time. Some lookups are slower than others. If you can prove a specific value eg. if you can prove that you only need 1 system call to find something, then don't use Big O notation, just write the number of calls that are required. The exact definition of Big O is complex. Most algorithms textbooks can probably explain it better than most random people on the internet.
Thank you for the broad answer, and you are right, readme file might need some corrections. But what I meant by providing these numbers is how many times the program needs to read from the memory during the transaction process to locate the data (if it was not cached previously) i.e search by a unique key only requires two reads to locate the record (destinations map -&gt; shards map -&gt; data) , when a regular key may contain duplicates therefore amount of reads will be N (destinations map -&gt; shards map -&gt; data array -&gt; data).
Definitely. I will add the visual representation of the architecture behind it very soon!
Is vgo usable? Last time I checked, it's still a proof of concept. 
vgo has improved since the first public release and some of the most important problems have been fixed. But, as I mentioned in the post, there are still some rough edges of the tool, as well as for the integration. So while you can give it a try, if you encounter any issues, please open issues so we can address them or forward to the Go team.
Why not just use ElasticSearch?
The examples for slice-types don't provide multiple values. Looks good though!
Declaring variables in a block at the top of a function comes from assembly language where you need to manage the stack manually. It also makes implementing compilers easier because you don't need multiple passes. Some languages like Pascal then propagated this style of programming as the "right" way. This probably made sense in an era of primitive compilers and tight memory. Keeping variables grouped together made it easier for both programmers and compilers to estimate what resources they were using. But if you're not on an embedded system, today most of your data lives in runtime-allocated (heap) memory, not on the stack. So putting the variables where they are actually used makes a lot more sense, and can actually help modern compilers optimize the code.
Yeah. That makes sense.
I think you have the wrong subreddit. This one is about the computer programming language called golang or go. The people who program it are called Gophers, the language's official logo is an animal that looks like a cartoon Gopher.
A picture is worth a thousand words.
Depends, if you share a photo and they look nice, then I'm interested!
How about grpc? [https://grpc.io/](https://grpc.io/) Clients exist for both node and go, so you should be about good to go.
ᕙ(⇀‸↼‶)ᕗ 
I've considered grpc, but I'm not sure how well it would support my use case. I need multiple clients to subscribe to changes in multiple directories which the server watches.
&gt; HTTP, but I found that limiting since I need the Electron app to update in real-time You can use an EventSource to stream updates to your client if you want stick with HTTP. &gt; I considered WebSocket, but I found it limiting since it's mostly a single connection (so big messages would block tiny ones), and I do need request/response for simple "fetch that file" or "list that directory" commands. You don't typically make synchronous calls over a websocket - send a message of a certain type and params from the client, then send the appropriate asynchronous response from the server. There's no blocking (unless you cause it in your message handling). --- I suspect your problems are with general architecture more than the transport.
Any chance you can add a mount/unmount option (essentially just saving the path) for quick operation? I'm doing testing on my application where I need to view the database after starting I want to do it as quickly as possible.
Also - why do you need a go backend? Isn't it a desktop application?
&gt; I suspect your problems are with general architecture more than the transport. Can you elaborate? In my current architecture, the Electron front-end issues commands that require a response (like "list that directory") as well as listens for changes on directories. So it seems to me that I would need both request/response and publish/subscribe to achieve that. I'm looking at [WAMP](https://wamp-proto.org/) now, a protocol on top of WebSocket which seems to implement both RPC and Publish/Subscribe.
Sure, but I want to build a *fast* FTP client, so I wrote an FTP client in Go that utilizes multiple connections to walk the remote file tree concurrently. I tested it and saw about a 25x improvement in speed with 30 connections vs. a single connection. Now I'm developing a GUI for it. I settled on Electron because it would spare me from dealing with native GUI and it would [look nice](https://imgur.com/a/Zyplxmu).
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/QiswE7o.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
&gt; going through the report also often shows me dead or useless code that I need to just get rid of https://github.com/alecthomas/gometalinter It includes a dead-code analysis amongst many other useful tools.
Echoing a couple others who said to try [sqlx](https://github.com/jmoiron/sqlx). Here’s an example from its readme to give a sense of why: ``` type Person struct { FirstName string `db:"first_name"` LastName string `db:"last_name"` Email string } jason = Person{} err = db.Get(&amp;jason, "SELECT * FROM person WHERE first_name=$1", "Jason") ``` 
&gt; I considered WebSocket, but I found it limiting since it's mostly a single connection (so big messages would block tiny ones) Open another socket?
It is a good idea! I guess I can keep paths in local storage and offer last several paths to the user. I'll create an issue on GitHub. It will be a next task (now I want to finish Search)
Yep, sure if you have previous work that's fine, but node is quite good at asynchronous and parallel programming as well and that would be a more polished architecture
I would implement it in Go anyway, since walking over a file tree with 80K files and 6K directories concurrently with 30 connections would take longer and require much more resources in Node.js than in Go.
Why not ZeroMQ?
Is there any quick overviews or blog posts that describe the differences between `vgo` and `go`. I know that Russ Cox has his series, but that goes into more details that I care about.
n/m. I found https://research.swtch.com/vgo-tour to be helpful.
It's a desktop application, I don't want to require the installation of services. That's also why I use [Bow](https://github.com/zippoxer/bow), an embedded database, instead of an external database like MongoDB.
What you're describing is something you will have to implement. There's no single library that will just do your entire project for you. Websocket, http long polling, or grpc, or even eventsource can all do what you describe. 
can we see pics
My team solved the problem you're describing by using both. We put together a REST API for everything initiated by the Electron client, and put together a very simple Websocket connection to push non-initiated status updates the other way, distributed by an event subscription model. 
So a gopher wouldn't want gopher merch?
wow the only sensible comment on this thread getting downvoted by fan boys. Sometimes i really feel sorry for the go community.
photo is in profile
now I will do everything from the beginning, I'm sorry
For some reason OP decided to keep the pic on her profile. [Here it is](https://imgur.com/a/PumXysp)
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/PMuUyVE.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
Hi) I like to sew toys. They are obtained by such lovely fluffs. Recently I sewed 3 Gophers, they were so cool that I wanted to sew on order with different designs and so on. Is anyone interested in this ???
[removed]
[removed]
It’s not a substitution. At this point of time I would even recommend to use elastic search just due to maturity of the project. I made this code during my time in the college and it was never meant to be an overkill of any popular existing database. The purpose of the project, for myself, was to learn golang more and understand how databases work in-depth.
&gt;Thank you, good to know!
Yep. This is why it’s called shardb
[removed]
Have a look at this wiki page https://github.com/golang/go/wiki/vgo
As a matter of best practice, you should never be dogmatic about best practice. Always use your your better judgement.
Thank you, I'll pass this to the team.
I’m new to golang programming and write this package for one of my project. Please check and share your comments.
[removed]
Unless I'm missing something, I don't see why you can't have a separate request response RPC to list the root directory and a server side streaming RPC for subscriptions. You'd just need a "hub" to listen to changes and push them out to subscribed clients. For instance, when you subscribe to a directory, you'd create a new hub that listens to changes within that directory and a list of clients who are subscribed and just push the updates out to every client on that list as they come.
Check http://aosabook.org/en
First we need to figure out MTTJ
Done: https://github.com/ShoshinNikita/boltBrowser/releases/tag/v1.2 Hope you will be satisfied)
Or, you could use the built in code coverage command to property test for code coverage. https://blog.golang.org/cover
Ok, this is much better haha, I didn't know about this. Thanks!
That's Reddit for you.
Worked! Thanks so much!
Yes, this worked! Thanks!
You could probably set up something simple and very cheap using AWS lambda + SNS
see https://www.techempower.com/benchmarks/#section=data-r15&amp;hw=ph&amp;test=json 
https://ahmet.im/blog/golang-json-decoder-pitfalls/
[Like this](https://play.golang.org/p/IalG2cp-iTg)
New a pied piper
You mean like keep-alive?
not a fair benchmark at all, should remove the JSON parsing from both, golang stdlib is not very good at parsing JSON (there's a few libs like easyjson that provide huge performance gains) while javascript (obviously) is very good at JSON parsing... 
With all the layers involved, this benchmark is not really comparing JSON parsing performance. It is also set up wrong.
if you'd pprof it I wouldn't be surprised if most is spent in JSON parsing. his benchmark result says 15mb/s, quickly grabbing some JSON benchmark data from the easyjson readme I wouldn't be surprised if its pretty close; https://github.com/mailru/easyjson/blob/master/README.md#benchmark-results I'd pprof it myself, but not near a laptop... 
&gt; Doesn't Node's VM use multiple threads to handle requests asynchronously? Not really. Node runs [all JavaScript on a single thread and therefore single core](https://stackoverflow.com/a/40029919). Async in Node only means that while one part of the program is blocked, another can run, but this all happens on a single core. That said, there are some native operations the runtime will handle on other threads, so you’re right that performance would be a different if Node were restricted to one core, but it’s not going to make as big of a difference as you think.
IMO a fair comparison would either run both with a realistic, multi-core setup, or run both on a single-core machine. I think the difference might, again, be larger than *you* think :) Because note that HTTP request parsing (which is AFAICT is the largest cost here) is part of the "native operations" node may handle in a different thread, whereas GOMAXPROCS forces the go server to not do that.
IIRC there is a catch with using json decoder on response body. That is, this way it keeps the connection open. Thus you have to close body (what you have to do anyway) to free resources with out waiting for client side to drop connection. Therefor messed results are probably not accurate.
Right, but these are all separate concerns from the transport that you use communicate these actions. No matter how you send/receive data, you need to implement these patterns in your server. The server code will be very similar no matter what transport you use, the only difference will be how you read/write to the client.
I mostly agree. But Java has it's warts too.
You should use stackdriver monitoring for something like this. There is a free plan for Go on App Engine. It's part of the Google Cloud wide Free Tier. Check out [https://cloud.google.com/free/](https://cloud.google.com/free/) for details.
Will dig into it later. But don't give to much hope to it, as my (supposed) knowledge may be outdated by now.
New new internet
 func IsSliceOfPointers(i interface{}) bool { t := reflect.TypeOf(i) if t.Kind() != reflect.Slice { return false } return t.Elem().Kind() == reflect.Ptr }
Initially the code was in Java and was used also in a graphics library where speed was paramount. When I ported the code to Go, I ported all the Global file. Now, only a few of these functions are used by the compressor: Log2 and Stretch/Squash \(maybe a few more\). The rest is not really necessary and could be cleaned up. As an aside, in general, I do not like to work with floats due to rounding/accuracy issues. Look at the gonuts forum to see how often people get confused by the behavior of floats/doubles.
TIL that Filippo is now working at Google [1] Good for him, the guy has a brith mind. It was nice to chat with him at Recurse Center. [1] https://twitter.com/FiloSottile/status/969342918313107456
TIL that Filippo is now working at Google [1] Good for him, the guy has a bright mind. It was nice to chat with him at Recurse Center. [1] https://twitter.com/FiloSottile/status/969342918313107456
`"use strict"` I don't recall the behavior in loops, but I'm pretty sure it's possible to use a local variable without execution reaching the line that declares it. In classic Javascript, all things are possible.
From what I can tell, the main purpose of this is to parse the path into parts (`/hello/world =&gt; [hello, world]`), then use reflection to find a field and method of the same name (`client.Hello.World(payload)`) If my understanding is correct, I have a few points: 1. I think using reflection doesn't buy you very much here. Ultimately, you're avoiding a single line such as `http.HandleFunc(path, EchoService.Echo)`, but introducing a huge surface of complication. Furthermore, you *still* have to register the handler, by instead placing it as a field in the Client struct. 2. As an implementation, it doesn't seem very well made. For example, almost all of the reflection can be done one time - at load - and cached into, say, a few maps. 3. Methods should be able to specify the format they expect. Even in your Echo example, you're decoding a json.RawMessage into another json.RawMessage. Automatically decoding and setting up the request, to alleviate this work from the handler, might have some merit. However, you would need to provide a lot more than just routing. If the service, or method, could somehow specify what it is expecting, it would allow your library to do more of the work for it. 4. Another reason I can see a library like this existing is for instrumentation, such as timing, counting hits to a path, monitoring errors, logging, all of that good stuff. 5. Finally, overall, I would consider the actual usage signature. There are zero compile-time guarantees about any of this. I would suggest a much less magic solution. Perhaps consider rewriting this to be a regular "http.Handler" that serves as a mux, automatically setting up and passing the request to the appropriate backend. Perhaps the backends are all registered through a method such as `client.Handle(echoService{})`, at which point the library would use reflection to find individual methods, figure out possible instrumentation, etc. I do like the effort, but something like this is generally frowned upon in the Go community. It's attempting to do a lot of magic, in a language and idiom that discourages magic. You're asking people to sacrifice readability, understandability, and verbosity, so you had better have some convincing rewards in return.
Are you looking for more feedback on this, or just notifying of another release? I notice it still has the broken StartStop server logic from the feedback on your previous release: https://github.com/seriousnerve/Licensing-System/blob/v1.0.1/Server.go#L99 And it also still has the issue of just checking if the user name and password hash are anywhere in the data file as opposed to a matching pair. 
&gt; I don't want to rely on a cloud/third party service either, I want a relatively secure and local solution. I prefer "local" solutions myself, but at a certain point you need to realize that a managed 3rd party service is much more secure than rolling your own &lt;whatever&gt;. I liken it to 2-factor auth. What makes it more secure is having multiple steps in the process. If one gets compromised there is still another step. As others have noted- if the local machine is compromised you're toast no matter what. So somewhere down the line you need to have some sort of confirmation with a remote machine- unless you can use a hardware usb authenticator and do it that way. I use github's Oauth2 + [oauth2_proxy](https://github.com/bitly/oauth2_proxy) for this sort of thing. Then you can simply create an access list of emails that get validated, then the user is forwarded wherever you have it configured. I like github, but you can use other cloud providers for login as well. 
Gonna try this out. Thanks!
I went ahead and forked it, then implemented all of my suggestions, then gave you a PR. Now this: var UserMap = map[int]string{} var UserID = 0 type USERS struct{} func (USERS) Create(name string) int { UserMap[UserID] = name UserID += 1 fmt.Println("created", name, "id", UserID-1) return UserID - 1 } func (USERS) Delete(id int) { delete(UserMap, id) } func (USERS) Read(id int) string { return UserMap[id] } func (USERS) Update(id int, name string) { UserMap[id] = name } AddBackend(USERS{}) Allows you to expose these endpoints: idRes, _ := Handler.CallBackendString("users/create", `"daniel"`) fmt.Println("CREATE:", idRes) idString := fmt.Sprintf(`%d`, idRes) res, _ := Handler.CallBackend("users/read/"+idString, nil) fmt.Println("READ:", res) Handler.CallBackendString("users/update/"+idString, `"galvez"`) res2, _ := Handler.CallBackend("users/read/"+idString, nil) fmt.Println("UPDATED:", res2) Handler.CallBackend("users/delete/"+idString, nil) res3, _ := Handler.CallBackend("users/read/"+idString, nil) fmt.Println("DELETED:", res3)
I've worked on both and both have their usecases. I'd suggest go because it seems to have more future than Java.
I made these 3 toys for the first time. Of course, I will listen to your wishes, if you want the same!
Not to mention the incredible number of job opportunities you'll find working in Java. Job opportunities as Go developers are raising so much lately, but Java dominates the field.
I think you should move on. Really. Most likely no one is interested in evaluating your test problem for an interview question. The problem statement is kinda ridiculous and should be solved with existing open\-source solutions. I think you're getting caught up in the fact that your code likely works, but you're missing the point\- such a ridiculous question was probably intended to see how you would organize/structure it, not if it worked or not. Doesn't mean you're a bad programmer. Some people are better than others at software architecture vs. implementing, and you need both in most cases.
From the link: you are affected by this unless you are using Go 1.7
I see Nyah Check is a track speaker. I had the privilege of taking to him a bit last year at GopherCon. He's a really interesting guy and I'm disappointed I can't make it this year. 
Java: tons of jobs. Go: not so many jobs It's not that easy...
If node was reading from and writing to the tcp connection in sync it would be way slower. These are done in different threads by node’s runtime. So it’s an unfair comparison. Also, the built-in JSON parser in Go is quite slow, there’s many more efficient solutions such as Gojay (most performant) or easyjson. 
I wrote [minimon](https://github.com/tomarus/minimon) a couple of years ago, it's a really simplistic monitoring tool supporting most Nagios plugins. No idea if that will run on appengine though.
FWIW, I use [go\-astilectron](https://github.com/asticode/go-astilectron) which allows you to bundle electron js and go in a single app. I know it uses TCP to communicate but i don't know the specifics of the protocol.
I see many more established tech companies switching to Go, than startups. Heck, where I am, I see more startups using Java than Go. They don't really operate in the same space, therefore rarely compete.
You are right, but I think it is easy to enter a job market with Go than Java, because there are less developers (although the job offers are less). I am in the same situation like you, trying to learn Go as quick as I can.
fyi ``` protoc --go_out=plugins=grpc:. *.proto ``` this didnt work for me due to conflict package name. Needed to run each command separately to generate the 2 go files
Afaik the idea is that control flow is more transparent and explicit that way. You know that in the case of errors, what will happen exactly instead of unwinding the stack past a necessary cleanup instruction for something. Defer is meant to be the finally of returning errors.
Essentially, but it's much harder to ignore. Error returns make you explicitly ignore the error. With exceptions, you can wrap several calls and have it not he obvious that one of them could fail. Error values promote handling errors exactly where you might have them and handling them individually.
Changed the JSON encoder \(used gojay\) and Go is almost 2x faster than Node.js. Also, I ran it without GOMAXPROCS=1 on a similar proc than the original version, Go is almost 4x faster. Almost sure if I increase the number of threads and connections in wrk, the benchmarking tool, Go can reach 6 to 7x faster than node... [https://github.com/francoispqt/rest\-bench](https://github.com/francoispqt/rest-bench)
It stems from google's experience with C++, which they have documented extensively. https://google.github.io/styleguide/cppguide.html#Exceptions In short: no, it is not the same as having a checked exception.
Followup: there are lots of arguments against checked exceptions. How do those arguments not apply to returning errors?
The primary con they state is having to examine a function's transitive calls to make sure none throw an exception. But that isn't a problem with checked exceptions
Was hoping to see dgryski on that list ;)
The fundamental issue isn't which one is better but if you go with returning errors, your language needs some kind of facility to keep the flow of a program readable instead of being full of if err!=nil{return err} statements every 2 lines. Go is absolutely half-assed on that matter. Furthermore even the std lib is extremely inconsistant on how it deals with errors. Sometimes it will check the value of the error, sometimes it will make a type assertion... Errors in go definitely were not thought off thoughtfully, especially when you put panic/defer/recover on top of that. 
For anyone taking this guide into consideration, this is old C++ guide made when modern C++ wasn't a thing and they still use it for backwards compatibility. It's not a good reference for new C++ projects.
&gt; With exceptions, you can wrap several calls and have it not he obvious that one of them could fail. &gt; &gt; That's not the case with checked exceptions, you absolutely need to try/catch or the program won't compile. With go errors: doSomethingThatReturnAnError() and you're done. It takes no extra effort to ignore errors.
C++ doesn't have checked exceptions.
It depends on the language. This isn't the case for Ruby or python. 
Really nice work. Just one complaint, go file names are usually lower snake case but I believe it's ported from Java so you're excused.
Oh also, use let's encrypt for your certificate https://letsencrypt.org
Because Ruby and Python don't have **checked** exceptions.
Server side is fine, as long as you have full HTTPS between the client and the server. Using algorithms like bcrypt, you are “hashing” the passwords, not encrypting them. Bcrypt is good, and pretty standard these days. Argon might be the next generation password hashing that we’re starting to use on new projects (argon has some new special features that bcrypt doesn’t). 1. User types password in client in plain text 2. Browser sends password to server over secure tunnel (SSL/TLS) 3. Server crates cryptographically secure random salt, on a per-user basis, and hashes the user password + salt. This prevents the same output if multiple users use the same password and makes it significantly more difficult to brute force. Note: when using bcrypt or libraries, there is a parameter for difficulty. This has to do with the number of thousands of iterations the hash goes through. Make sure you look into setting the difficulty to a secure value... every few years that number needs to be increased as computational power becomes more common. Also note that some hash libraries will help with the salt generation, but just make sure yours does this. 4. The hashed output is safe to save in plaintext - you already did the cryptographic work to keep it secure. Depending on your hash library, you may need to save the users salt separately in a new column (salts are not secret, so you can keep them unencrypted). The libraries I use package the salt + hash in one string, so it’s only one string “blob” to store. Bonus points - apply a DB wide salt, called a “pepper” for extra protection. You can also technically use symmetric encryption (AES) to protect your hashed values after the fact before storing them in the DB. But that’s probably over kill if you’re doing all the precious steps correctly, and just adds too much complexity to the system. Good security is simple, clear and easy to vet &amp; audit that you did it correctly. Hope that helps! 
 The price of checked exceptions is an Open/Closed Principle violation. If you throw a checked exception from a method in your code and the catch is three levels above, you must declare that exception in the signature of each method between you and the catch. This means that a change at a low level of the software can force signature changes on many higher levels. —Robert C. Martin, «Clean Code», page 107 For what it's worth, I think that errors strike a pretty careful balance. They do not introduce a different code path flow (and require more keywords), changes to them do not require large amounts of function signature refactoring if you want to introduce a new type of error, and they work well with interfaces. You have syntactic tools like errcheck (https://github.com/kisielk/errcheck) that can highlight potentially missed errors, and you can ignore errors by assigning to _.
This may seem nitpicky, but `bcrypt` is a hashing algorithm. Encryption is something that can be reversed. Hashing is one way (you can't take a hash and reverse it into the original value). Don't ever use an encryption algorithm on passwords - anything you can decrypt an attacker could potentially decrypt as well. Hashing works for passwords because you don't need to reverse the hash ever, you just need to verify that the hash matches the password the user types when they log in (and you do this by hashing that password then comparing the two, essentially). I'm trying to help you get terminology correct because using it incorrectly in this case could lead to mistakes and security flaws if someone takes you to literally mean "encryption"
Java requires a larger vertical. So in theory, go can save you money on your iaas bill.
Checking an exception is checking a condition- using exceptions to do this is caller dependent. You may check your exception- someone else may not. Maybe they call your function twice in one code block, which one failed- the first or second? So now all callers of your function may abort at various points in their program leading to less clear control flow. You can say each individual exception should be checked, but in practice that is not the way exception handling is used, I've never seen code like this: try { age = Integer.parseInt(inputAge); } catch (NumberFormatException e) { throw new InputFailureAge() } try { price = Integer.parseInt(inputPrice); } catch (NumberFormatException e) { throw new InputFailurePrice() } Instead 99% of the java code I see treats most function code blocks as a single operation which leads to nasty bugs: try { age = Integer.parseInt(inputAge); createPartialStateToHauntYouLater() price = Integer.parseInt(inputPrice); } catch (NumberFormatException e) { throw new InputFailure() } The language lets them do this because while exceptions may be used like conditions, they don't have to be and thus will never share the same clarity as conditional control flow found in `if`, `switch` etc.
thanks so hashing is what bcrypt actually does. So do I save the "salt" in the same table as the password? both of them are stored in plain text?
Bcrypt salts for you already. It is stored in the final "hash" that it outputs. &lt;https://stackoverflow.com/questions/6832445/how-can-bcrypt-have-built-in-salts&gt; explains this further, but the TL;DR is that when you pass a password into bcrypt to hash it, bcrypt will generate a salt for you, apply it, hash the password, then what it returns to you is actually something like `hashed-password.salt-used` (not exactly, but that gives you a rough idea). This is part of the reason why you need to use a function like `bcrypt.CompareHashAndPassword` to compare a hash and password instead of just hashing the login password yourself and comparing values. If you did the hashing yourself it is likely that bcrypt would choose a different salt and it would look like the two passwords are different even though they may not be, because their resulting hashes would each be produced with a different salt.
Thank you very much! And yes I do recommend gokit. The reason I'm not using it here is because it is a lot of extra moving pieces and takes away from the communication aspect. But for all real projects gokit is my go to.
It will need to be done in the beginning... otherwise you will need to force everyone to reset their password ;)
Yes it is. Throws exception 
Yes, I am still looking for more feedback if there is anything you can find. I thought I fixed the start stop? I also used the username as the salt in the hash, that way you have to have the right username and password, not just the password. If I wanted, I could remove the if strings contain part for the username and just have it check the hash. What would you recommend I do for the start stop, as well as the username password checking?
Btw, I realized I missed a part of your question. You would do this work in your app (Go), not the DB layer. And don’t over stress about the pepper part. Honestly if you do the main hashing and salting right you’re in good shape. 
It will be helpful if you can connect some of the dots on the current code. Is the second snippet (`defer wg.Done()` ...) part of `RunMyGoRoutine` or something else? Closing a channel signals that no more values will be sent. Where is the code that closes the channel when more values might be sent? 
Watch this video, then do something else than toying with passwords: https://www.youtube.com/watch?v=8ZtInClXe1Q
Well this really shows that it's hard to build a good benchmark. For most real world use cases you'll see 4-10x improvement by moving from Node to Go.
Sounds nonsense for general case. When an application or platform has a memory leak, it usually doesn't depend on whether it's run in Docker.