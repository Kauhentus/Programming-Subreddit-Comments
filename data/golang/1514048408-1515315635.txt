Cool I'll check it out thank you. Also this is mainly a con for me probably because the rest of our infrastructure is running on AWS no problem, but for this service that is using GRPC we are having to do a lot of extra leg work to get things like load balancing working compared to the other services.
Also Kubernetes
I really think [`dep`](https://github.com/golang/dep) is my favorite project at the moment. It sets out to solve one of the most important problems in Go developement at the moment: sane dependency management. Also the main developer is great guy. I'm glad I've been able to add something to the project with a PR. At my job I've created [`vg`](https://github.com/GetStream/vg), which integrates with `dep` really well. It's made to solve some of the problems that `dep` doesn't solve yet (pinning versions of executables and importing local projects temporarily). Obviously I also think that that's a great project ;) 
Godoc works automatically on any public GitHub repo, and this is a public GitHub repo. So yes there is already a godoc.
[go-ipfs](github.com/ipfs/go-ipfs) 
&gt; The use of remote repository urls in package names drives me up a wall The import path is an arbitrary string and not specified by the language. &gt; to the point where I think if I could, I would buy Github and shut it down just to invalidate the package names on hundreds of Go libraries. The URLs that are used as import paths (by convention) makes the naming of packages decentralized. In theory you can host your Go packages anywhere which makes the system scalable. &gt; I've really had a ton of problems with the Go packaging and layout system. I was unable to understand the actual problems you are having by your post. Things like "rubs me the wrong way" and "drives me up a wall" are way too vague. I highly recommend you to read [Go at Google: Language Design in the Service of Software Engineering](https://talks.golang.org/2012/splash.article) to get a better understanding of some of the choices that affected the design of the language. That doesn't make it perfect or correct. But it gets the job done.
Go doesn't insist on monorepos. Its a nice pattern that you can use if it fits your use cases, but otherwise your GOPATH should just be in some folder like ~/go and your projects should be in ~/go/src/github.com/me/project. Each "project" folder can be its own git repo with its own dependencies. Let's say someone shuts down Github.com. What impact would this have on third party packages that shutting down, say, npm wouldn't have on node projects? - If npm shut down, a new npm could be created. _Maybe_ it could mirror the old npm, but I'm not aware of any method npm offers to export every single package it is hosting. Every developer that uses npm would have to switch their configured global repository to the "new npm". - If github shut down, a new github could be created. Actually, hold up, there are plenty of free public git hosting websites, so that's already done. Package authors would have to transition their packages to a new service, which is a single command from their local repo. They'd have to alert all their users to the change. Go has really good built-in tooling, so we have tools that can rewrite dependency strings across an entire project automatically. Both of these are doomsday scenarios, and both would result in a lot of downtime. The Go one, probably more downtime. The nice thing is, if its a scenario that scares you, you can mirror all the packages you want to have "guaranteed" access to into a self-hosted repo then just reference that. This is *much* harder to do with npm, though not impossible.
goread.io, but I run it hosted on my own app engine instance.
Thanks for the comment, and you cut to the heart of my problem with baking remote repository URLs into the package name. It means a bunch of semantically invalid names if Github were to go away. There’s nothing wrong with using remote paths to resolve package dependencies, but using them as part of the package name feels wrong when you want to, as an example, move from Github to Bitbucket. Now everyone either has a name that indicates to them that the package is hosted somewhere it isn’t, adding semantic overhead, or clients need to change the package name to reflect its new location. To your point about npm, the mismatch isn’t about centralized lookup; many other package managers allow for specifying remote locations independent of the package name. The dep tools manifests can easily allow for lookup of a package at any source, and if the developer needs to move where it’s hosted then clients can change a manifest instead of their source code if they want to update the dependency. 
Thanks for the link, I’ll take a look. With regard to the package naming conventions, I more fully answered the question of why I think it matters. The monorepo question for me is about how I work; I have a lot of locations that I work from based on what I’m trying to accomplish. My working directory at the office is different than my working directory for personal projects and is a different working directory than open source work I contribute to. It means a lot of messing with my environment to switch between projects.
https://www.devdungeon.com/content/web-genome Because it actually got to take advantage of the speed and concurrency on a large scale.
every day i use pretty much all of these: consul, kubernetes, terraform, keybase, traefik oauth2-proxy, drone, Prometheus and countless others.... i cannot possibly pick a favourite, i love them all!!
Feedbacks appreciate 😬
&gt; I more fully answered the question of why I think it matters. Not in your opening post. If you are talking about your comment &gt; but using them as part of the package name feels wrong when you want to, as an example, move from Github to Bitbucket. then you can use [canonical import paths](https://golang.org/doc/go1.4#canonicalimports) which were designed for this exact case. &gt; My working directory at the office is different than my working directory for personal projects and is a different working directory than open source work I contribute to. It means a lot of messing with my environment to switch between projects. If those different working directories are set as the GOPATH in each location then the problem is solved automatically.
Reading about canonical import paths, is my understanding correct here: &gt;"The syntax is simple: put an identifying comment on the package line. For our example, the package clause would read: ```package pdf // import "rsc.io/pdf"``` &gt;With this in place, the go command will refuse to compile a package that imports github.com/rsc/pdf, ensuring that the code can be moved without breaking users." This is something that a repository creator/maintainer would have to anticipate potentially doing and it would break clients if they made the change and a client attempted to fetch the latest package while still importing the package by the old naming scheme, i.e. - ``` import github.com/rsc/pdf```
&gt; This is something that a repository creator/maintainer would have to anticipate potentially doing and it would break clients if they made the change and a client attempted to fetch the latest package while still importing the old package? Clients are always importing the "vanity" import which is enforced by the go command. So no matter where the project moves the import path of the clients stays the same. For example take a look at the [Upspin](https://github.com/upspin/upspin/blob/master/upspin/upspin.go) project. The clients import `upspin.io` even though the project is hosted on GitHub. 
I think I understand that from the perspective of a library that uses the vanity import from the beginning, but my question was around what happens if a client is using a library which used the "github.com/rsc/pdf" package name, but then the maintainer changed the library to use the canonical import path (maybe, in this case, they decided to move the repo to Bitbucket and said, "hey, they added this canonical import path feature in 1.4, maybe I'll make that change to help ease the transition"). So in this case, my question is whether anyone who has been using the previous import path "github.com/rsc/pdf" and tries to update the library to the latest version, which is using the canonical import path feature, will get an error because their code is still relying on the non-vanity import path?
I don't write much Go, but I like [weather](https://github.com/jessfraz/weather) - I'd been looking for something like it for quite some time. 
&gt; Library methods now all expect a Context struct as their first parameter. This just doesn't feel right. Why not just an optional Context field on the request struct (c.f. the new AWS sdk)
I like when people combine two of my favourite things.
It's been answered already, but monorepo is not what go is trying to make you do. Having a preferred location for all Go projects is a great idea in a highly opinionated language. The fact that you're saying you have to change that location all the time is troubling... All your Go projects should be in the $GOPATH/src/ folder. I don't really see a reason why you'd want that to be different in any dev environment. Or why you'd want to isolate projects from each other, really... Maybe your use cases are more advanced than what I've encountered.
The Gorilla team projects have a great standing with me. Their APIs are dead simple, and leave a large degree of freedom in projects that use the packages in. I love frameworks and what they bring to the table, but they add a lot to my load as a student/hobbyist. The Gorilla team has some really simple APIs that I don't have to worry about across the entire application, just a small part of it. I can almost plop them in with minimal work on my park to a pre-existing architecture I've already been writing.
Yes: If the library is already developed/used as "github.com/rsc/pdf", and you introduce a new canonical import, `go get -u github.com/rsc/pdf` will return an error to please change the import path to the new canonical one. Here it doesn’t matter if the new one will be `rsc.io/pdf` or `bitbucket.org/rsc/pdf`, you are forcing your users to update their import paths. The benefit of the `rsc.io/pdf` is that any future code hosting transition to say "https://newhub.example.com/rsc/pdf" will *not* force your users to update it, the correct import path will still be "rsc.io/pdf". You can think of "rsc.io/pdf" as kind of ›symbolic link‹ to the real repository (open `view-source:https://rsc.io/pdf` in your browser to see it youself). This kind of transition has actually happened in the past; for example, when google code closed, the repo `code.google.com/p/go.crypto` moved to "go.googlesource.com/crypto", but it also gained a new canonical import path: `golang.org/x/crypto`. 
I wrote an interpreter using Go that was a ton of fun. I used a book to get started but kept working on adding new language features once I finished it. Should really try and add more to it...
&gt; so that they could provide http2 without tls on it https://godoc.org/golang.org/x/net/http2#Server.ServeConn ?
Their raft library is quite good and most importantly, very reusable. The last thing cannot be said for the raft library of etcd.
Which book was it?
&gt; [go-ipfs](https://github.com/ipfs/go-ipfs) FTFY :)
Nice to see go solving 'the make bug' issue, even piecemeal
[`goimports`](https://godoc.org/golang.org/x/tools/cmd/goimports). I run it hundreds of times on most days, and it makes my life significantly better.
★ Go-kit a toolkit for microservices - https://gokit.io/ 
A bit biased but I quite like the latest design of the [tensor](https://gorgonia.org/tensor). Wish I could be a bit happier about [gorgonia](https://gorgonia.org/gorgonia) tho
Not OP, but I've got this one https://interpreterbook.com/ Pretty good book and walks you from beginning to end while designing an actual language including parser, lexer, and writing tests for it all.
Any criticism or suggestions on how to make my code less shitty is appreciated! One thing I was having trouble with was passing `gitUrl` to my main function without passing it as a return value which ended up breaking my `check404` if statement. Would I make `gitUrl` a pointer, or is there another way to go about passing it?
Databases specifically are an example of where you really should pass in a context. Imagine a slow and expensive query being performed on behalf of a user who has already lost interest and closed the browser tab. https://golang.org/pkg/database/sql/#DB.QueryContext
Yes Go 2 should see if context can be cleaned up. No we don't all agree with every single thing in your article. To pick a sample nit: &gt; but it’s harder to cancel a sub-tree That's exactly what context makes easy! Most importantly, `context` is like `gofmt`. You don't have to love every single design decision in it, but you gotta love agreeing on a single thing.
That "opt-in" thing was largely dictated by FunctionName predating existence of context. You might not want to pick that as a design goal.
Agreed!
This is it! Great book!
If you read carefully, the fact that context makes cancelling a sub-tree easy is exactly what I said in the article.
I saw the link for playing this on another subreddit. After a bit of digging, I found that it was written in Go! It's a really good example of some of Go's strengths, and lots of fun to boot! 
Does it really serve the purpose if you are seeding each go routine with the same time??
You might want to take a look at https://github.com/alecthomas/gometalinter
https://github.com/kyoto-shift/kdot/blob/master/main.go#L13 I think a better name would be verifyRepo or something similar, check404 isn't descriptive of the intent https://github.com/kyoto-shift/kdot/blob/master/main.go#L49 since you generate the URL here, pass that to the check404 func instead of re-creating it https://github.com/kyoto-shift/kdot/blob/master/main.go#L24-L28 A cleaner way to do this is return resp.StatusCode != 404 although I'd use http.StatusNotFound instead of 404 and really is what you want to check for a 200? There could be status codes like 500 or 429 which would pass in the current logic but not be what you likely intended. https://github.com/kyoto-shift/kdot/blob/master/main.go#L55 could be if check404(username) { https://github.com/kyoto-shift/kdot/blob/master/main.go#L62 don't panic https://github.com/kyoto-shift/kdot/blob/master/main.go#L70 the else is not needed since the if statement has a return https://github.com/kyoto-shift/kdot/blob/master/main.go#L74 use a for loop around your logic fetching logic, don't call back into main() 
It's typical for a utility like this to take input from command line arguments instead of prompting the user. Some comments on check404: - A shorter way to write if resp.StatusCode == 404 { return false } else { return true } is return resp.StatusCode != 404 - The program wants to know if the page exists, not that the page does not exist. I suggest checking for status 200 instead. - Close the response body. - Use a HEAD request instead of a GET request. - Panicking is not a very friendly way to handle errors. Print the error to stdout and exit (possibly by calling log.Fatal()). Some comments on main: - See comment re: panic above. - The git command can also fail. Should that also count as a failure like the page not existing? - Recursively calling main is weird. Use a for loop. 
Oh woah haha did not know that. Was looking for that little “godoc” badge in the readme.
&gt; It's typical for a utility like this to take input from command line arguments instead of prompting the user. I really wanted to do this. Like adding a flag to specify a different repository name, etc. How would I go about doing this? I've also added as many of the changes as I could! I'll try to add more when I get home, thanks!
The flag package: https://golang.org/pkg/flag/
&gt; I think a better name would be verifyRepo or something similar, check404 isn't descriptive of the intent I totally agree with that and I changed it! I didn't think I was going to finish this thing, so I didn't change the name lol. &gt;since you generate the URL here, pass that to the check404 func instead of re-creating it I never even thought of that, thanks! &gt;use a for loop around your logic fetching logic, don't call back into main() I ended up removing the whole thing entirely since I want to convert it to a CLI, rather than a prompt for input utility. How would doing this look like? I couldn't really wrap my head around using a for loop in that context.
Use the flag package. Parse with `flag.Parse()`, check that number of args is one with `flag.NArg() == 1` and use `flag.Arg(0)`.
Here is my take of a quick cli version: https://play.golang.org/p/70TRNeQgyVL I removed the retrying, but could be added back in
Isn't GraphiQL 100% frontend?
Are you triggering K8s Deployments with Drone? I'm looking into doing the same thing, have a plan on how to make it work but I'm curious about what others are doing.
`[go-ipfs](https://github.com/ipfs/go-ipfs)` FTFY 8D
Great job! You might heed some of the warnings that https://github.com/alecthomas/gometalinter might emit.
Looks pretty good but there are some things to improve: * snake case is not idiomatic for function names * you aren't checking https://godoc.org/bufio#Scanner.Err * the use of a channel for the scanner is IMO suspect * you're not returning a non-zero exit code on line 70 * you're ignoring the possible error from png.Encode (errcheck linter should tell you this) * it looks like the code hasn't been run through gofmt/goimports (some whitespace oddities) * you have some commented out code in there * the output filename should be a parameter (and probably default to stdout -- https://godoc.org/github.com/campoy/tools/imgcat could be a fun addition!) that's a mix of idiom, error handling, tooling, and style nits -- I hope helpful and gently enough delivered! Welcome to go!
https://goreportcard.com/report/github.com/project-empower/randomart-image
Nice find.
Where's the PR?
There is a default rule in uMatrix that blocks the entire domain. 
[removed]
&gt; The use of remote repository urls in package names drives me up a wall to the point where I think if I could, I would buy Github and shut it down just to invalidate the package names on hundreds of Go libraries. Both in the quoted above and in your later comments there's a repeated strange misunderstanding: Package name has nothing to do with any URL. Package name is the single identifier in the package clause, like `foo` in `package foo`. Import paths are not connected to package names. And preemptively: import paths are not hard-connected to the URL `go get` actually downloads the repository either. You can freely move your repository from one provider to another without breaking anyone's code, see 'go help importpath' for info how to provide a stable import path by serving small metadata.
Quite good for a first stab. Please use gofmt before committing.
Who in their right minds chain ternary operators?
I think the pagination comment was in reverse. If you're needing streaming over plain http, one solution is a type of pagination. In fact, i'm implementing something soon that's in need of http streaming, so i'll likely be implementing it that way. On that note, a bit of an aside, is there a better way that is both simple and works over plain HTTP? I just sort of defaulted *(mentally, no loc written)* to pagination. Is there something you like better?
it's not shitty or pointless. You have to start somewhere. Over time you'll improve. ;) - closing the body of a request is unnecessary, because you don't read a body (which is in fact empty because of a HEAD request) - if username is required, declaring flag doesn't make sense (after `flag.Parse()` check the number of arguments with `flag.NArgs()`). - terminating the program due errors should be like `os.Exit(1)` or `log.Fatal(...)` - don't panic, return error from function and in main function check for error. - for concatenating strings use fmt.Sprintf - variable initializations like `var dotfiles string = "dotfiles"` should be `dotfiles := "dotfiles"` or better yet, specified as a constant outside of main function
Well, not a technical tip but dont beat yourself down about the quality of your code. We all start out with shitty code but no need to give it bad names. Appreciate what you did with your time :-)
Hmmm, I'm trying to understand your use case here. Honestly, If the YAML cannot be changed, and you're trying to only parse out some specific parts out of the YAML document, and also Unmarshal it into a typed object, then you'd have to write your own parser for the specific types. However, maintaining this can be more of a tech debt than a super big yaml doc. If your concern is performance, efficiency, or speed, then you'd be better off by unmarshaling the whole document, and caching it in a quickly accessible location - either in memory/shared memory or over a network. Then you can choose to retrieve specific subtrees like you wanted. If you're still looking to just parse out certain parts into typed objects, then like I said, your best best is to write your own parser for the types you're working with. If you want to do this in a generic fashion such that this would work with any times, then the algorithm for it would be quite involved. If you already know of an algorithm for such problems, and if you're just looking for implementation help, I'm sure people here, and myself would be able to show you the way. 
Features are there to be used.
What do you mean by "The idea of dealing with this GlobalConfig struct isn't appealing"? I would make a "config" package to share across Go apps and just write a tiny abstraction for the unappealing parts. I.e.: (play)[https://play.golang.org/p/xxz6nCc_Vhq]
The seed is not the same: notice the increment at the end of the for loop. OFC, it's not a good randomness source, but for simple simultations it works fine. It's not crypto.
The (un)marshallers in go generally ignore extra fields in both your go type and the file. So while you need the wrapper struct, you only need the data field.
In your example where you just want the data field, you could use: type DataConfig struct { Data struct { Host string `yaml:"host"` Backup string `yaml:"backup"` Password interface{} `yaml:"password"` } `yaml:"data"` }
While I don't understand your situation well, my inclination would be to parse the config once and the pass the configuration sub-elements to the funcs that need it. type Config struct { ServiceConfig struct { Apikey string `yaml:"apikey"` } `yaml:"service"` DataConfig struct { Host string `yaml:"host"` Backup string `yaml:"backup"` Password interface{} `yaml:"password"` } `yaml:"data"` } config, err := parseConfig() // parse the whole thing, checking for required elements, set defaults, etc if err != nil { log.Fatal(err) } someServiceFunc(config.ServiceConfig) // pass in the part of the config the func requires someDataFunc(config.DataConfig)
I still don't understand what streaming has to do with pagination. In the case of a defined set of data, pagination means random access to a subset of the data, where streaming means incremental access to the full set of data. In fact they're completely orthogonal as you can have both at the same time. You can request page 10 with a size of 200 and stream that subset to the client 1 or 10 at a time for example. Streaming in its raw form means the client starts reading and processing the data before the server is finished sending all the data. You can easily stream data over http by keeping the connection open and incrementally reading the data and processing it, just that json is a bad way to do this because it won't be valid json until all the data is sent. I assume there are js libraries that help with this, so instead of sending a single json object over a request, you send multiple, ie you don't put it in an array, then the client can parse 1 json object at a time and use that data before the next json object is finished sending. IMHO I would rather implement something over websocket, but that requires more overhead of dealing with websocket. You can also check grpc-web https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md but I don't think it's ready yet last I checked.
&gt; the use of a channel for the scanner is IMO suspect Yeah, that was not necessary. I was playing with the idea of "reactive" and my little bit of knowledge there is "functional reactive programming". Channels seemed like Go's react like crap. It's definitely overkill. Thanks for the feedback!
This is great! Thanks!
Ooh. Forgot about that thing. I saw it and meant to use it. Thanks!
Same here, we use drone for everything but deploy to our clusters via Jenkins. I think I'm going to write a plugin for k8 deployments, bash plugins look stupid simple to create
It´s possible that the config is a sort of global config for multiple applications where parts are just not relevant to other applications, otherwise I would tend to agree.
Yes, or megacheck https://github.com/dominikh/go-tools/tree/master/cmd/megacheck
To be honest I don't know what the standard practice for triggering deployments is, I'm still really new at this and I don't want the devs in my team to learn how to deploy using K8s manually, I'd prefer to abstract most of the complexity away.
So it's just a simpler version of [beets](http://beets.io/)
Precisely. Also, I needed some project to build in Go. 
Hard to see that on mobile
Good point, in which case the first version would probably be appropriate.
https://github.com/caarlos0/bandep/blob/master/main.go#L54 don't need else since the if has a return https://github.com/caarlos0/bandep/blob/master/main.go#L132 seems odd to print an error message in a utility function and all it does is calling matchPackagesInFS(pattern), could it be refactored out or if an error is relevant, return it as an error https://github.com/caarlos0/bandep/blob/master/main.go#L72-L80 if the if statement is inverted, I think the logic is cleaner since the indentation is less if ! strings.HasSuffix(path, "/...") { return checkPkg(path, bans) } for _, pkg := range allPackagesInFS(path) { if err := checkPkg(pkg, bans); err != nil { return err } } return nil https://github.com/caarlos0/bandep/blob/master/main.go#L185 using log to print and err and fmt elsewhere, should be consistent 
thanks for the feedback! the log thing is code copied from the go lang itself (https://github.com/caarlos0/bandep/blob/master/main.go#L119), other points were relevant though :D Thanks!
Fair. A full rewrite of beets in Go would possibly be more efficient than the Python it's written in Go is fun as well
yup, it's pretty simple to implement but ultimately depends on your needs.. things like rolling back should a rollout fail for example can be tricky.. I'm planning on getting into some helm in January to make things better but you can go a long way with regular deployments and the rollout command one standard i like it that the image tags match the git tags so you can tie that into a timeline and everything that's active all at once
This has nothing to do with Go, though.
Microsoft, can you please stop with the constant breaking changes? In 2016, you went from v2.0.0 to v7.0.1. In 2017, you've gone from v7.0.1 to v12.0.0. If you're following SemVer, that's _five breaking changes a year_. STAHP! A few months ago I had to maintain some code that depended on azure-sdk-for-go. You kept breaking my app all. the. time. Everytime I updated the deps, it was smooth sailing except for azure-sdk-for-go. Don't say I should've just locked in an old version, because I know you're not testing **12** versions of your package to make sure they all work. A lot of your breakages were A) bad ideas, like when you made a bunch of things return error _channels_ instead of errors, or B) reverting bad ideas, like when you tried to move the storage package to another repo, but keep it in azure-sdk-for-go as a submodule. Please just chill.
I don't understand why this is preferable to `errgroup`. &gt; It is somewhat similar to package errgroup, except it does not require actor goroutines to understand context semantics. This makes it suitable for use in more circumstances; for example, goroutines which are handling connections from net.Listeners, or scanning input from a closable io.Reader. So just use `errgroup`, ignore the context, and use your alternative shutdown signaling mechanism. Or, even better, make a context-style `net.Listener` wrapper)
The only way to signal an errgroup to stop is to close the context. Not all goroutines can react to context cancelation. Adapting arbitrary goroutines to respond to context cancelation (one way being, as you say, making your own custom context-style wrapper) will result in a lot of boilerplate scaffolding code, which I find undesirable. Or, tl;dr: I believe the API of run.Group is both more elegant and more usable than that of errgroup.
Loved the blog post, and intend to implement a project using run.Group after Christmas. 
Shaking my head here. This is just sad. Day 1: "This will be so streamlined and perfect that we can get by with only concrete types" Day 1000: "Should we add a code generator to our type registry or should we fork the language to get generics?"
This seem, to me, to be kind of missing the "what is it you're trying to do" part of an experience report. What *is* a `runtime.Object`? Most often, when things such as "type registries" exist, it happens because there is need to map strings to types. Usually because of serialization or configuration. So, they are a way (usually) to "stringly type" where it's absolutely necessary: When dealing with bytes in a file or on the wire. So I'm not very convinced, that generics would be able to remove the type-registries, as they wouldn't automatically come with a way to enumerate types. It might help with issues about needed types not being compiled in though, but even there, I'm not entirely clear on *how*. Whether I do a type-assertion to `foo.Bar` on a `runtime.Object`, or whether I get passed a `foo.Bar` as a parameter - both will require `foo` to be imported and thus passed in. So, from reading this, it's not clear to me a) what's the actual problem that is being solved (what does Kubernetes need this `runtime.Object` type for?) and b) how generics would help it…
It's not up to go users to write experience reports to explain why they need generics. Generic programming is a well understood problem, with plenty of literature and several models as to its implementation. Either go designers themselves understand the value of generics, or they don't. If they don't then they shouldn't put generics in their language,end of story. If they are afraid of the C++ template/ Java type erasure red herring then just have a look at how Ada implement generics, no templates, no type erasure. Having people writing "experience reports" is called an idea parking. It's mostly wasting people's time and not condescending. 
Most of your posts about the issue are strawmen. There is no comp-sci problem one cannot solve without generics, just like there is no comp-sci problem one cannot solve without functions. Yet no-one can argue functions are not a useful feature. Yes you can always tell people they can do without generics, because they can, if it's your point it is completely irrelevant to the discussion. You are just second-guessing. What you don't get is that generics can make some problems easier to solve and simpler than copy pasting the same piece of code while changing a few types. Emphasis on "easier" and "simpler", just like functions make some problems easier and simpler.
&gt; Most of your posts about the issue are strawmen. I don't see how you can possibly draw that conclusion, knowing what a [strawman](https://yourlogicalfallacyis.com/strawman) is - misrepresenting the other's argument to make it easier to attack. I am not *presenting* anyone's arguments here, so I don't see how I could *mis*represent them. &gt; Yet no-one can argue functions are not a useful feature. And [no one is](https://blog.merovius.de/2017/09/12/diminishing-returns-of-static-typing.html). The argument of the other side here isn't, that Generics have no use, but that they also have costs and that the costs and benefits need to be weighed. Which, in particular, means that both have to be *known*, as specifically and detailed as possible. (Which kinda brings us back to the "strawman". Asking what specifically `runtime.Object` is used for to see how generics can help is not a strawman. Claiming anyone would argue that generics are not useful *is*) &gt; Yes you can always tell people they can do without generics That is, again, not at all what I was saying. I was saying, that I don't see how generics would *help* here. You could try and help me understand. You could, for example, start by explaining what `runtime.Object` is used for and in what ways generics would prevent the problems mentioned in the article. To at least a good degree, they are related to required types not being compiled in - to quote: &gt; Generally, these applications crash with error messages like “no kind is registered for the type …” This is not a "generics" problem and generics can do literally nothing to help with this (and to, again, make this clear: I'm not saying generics aren't useful *in general*, I say they are not useful *to solve this specific problem*). That is at least my impression, but I'm fine (happy, even) being corrected here, but please be specific, instead of just vaguely referring to "generics" or "runtime type systems". FTR, this seems to be an issue in understanding that could easily be solved by what the author explicitly avoids: &gt; You could replace this global registry with generics. I’ll resist the urge to invent yet another generics syntax for Go, but trust me, it’d be beautiful! If they would just jot down how this would supposedly look, it would be easier to understand how they imagine this helping. I'm really not convinced it would, though. &gt; What you don't get is that generics can make some problems easier to solve That is entirely untrue. In fact, I am just now using Haskell to solve a problem which benefits immensely from a more powerful type-system. Because it can't be expressed cleanly in Go's lobotomized type-system. I understand the value of powerful types to solve certain problems perfectly well - but I don't see how that would imply that *every language* needs as powerful a type-system as possible. Or how it would refute the argument, that the problems Go is *designed* to solve would suffer more from a powerful type-system, than the average language. I can not repeat often enough, that **no one is claiming generics are not useful**. Claiming we would does not help progress the discussion in a productive direction.
&gt; I can not repeat often enough, that no one is claiming generics are not useful. Claiming we would does not help progress the discussion in a productive direction. Yet you keep second guessing entire teams of engineers describing why generics would be useful for them, pretending they are somehow doing something wrong and they don't really need generics. Don't you think that's not extremely arrogant and insulting to people? I mean you somehow always know better than everybody else. C.F. your post about web-routers.
Then why do they maintain a list of experience reports, include many [directly about generics](https://github.com/golang/go/wiki/ExperienceReports#generics)? From https://blog.golang.org/toward-go2 &gt; For example, I've been examining generics recently, but I don't have in my mind a clear picture of the detailed, concrete problems that Go users need generics to solve. As a result, I can't answer a design question like whether to support generic methods, which is to say methods that are parameterized separately from the receiver. If we had a large set of real-world use cases, we could begin to answer a question like this by examining the significant ones. They have made it quite clear that they want people that think generics should be included in Go to voice those opinions along with solid experience reports. Your assumptions about what the Go designers do and don't understand, as well as want they do and don't want, is the real waste of time here.
&gt; They have made it quite clear that they want people that think generics should be included in Go to voice those opinions along with solid experience reports. I don't believe go designers are talking in good faith. Period. Either you get why generics are useful or you don't. This is idea parking because of the circular nature of that logic: no problem in go cannot be solve without generics, therefore there is no "use case for generics", because they are just a tool to avoid code repetition, just like functions. Asking people for use-cases is insulting people's intelligence. Either you believe generics are useful enough to be part a the language, or you don't. The use case angle is a straw-man. Ada has mod types, which are useful. Can developers live without it? of course, they were put there because the designers see value in it. If you don't see value in something, asking people for use cases when you can always answer them "You can do things differently(which is always true)" isn't honest. A better way to frame the debate would have been: suggest generic implementations with the smallest cost for the compiler and runtime, which is a work only go maintainers and designers can do. I say it again, nobody can come with a single use-case where a problem cannot be expressed or solved without generics. Go designers know that, they are smart, smarter than most people on this sub.
&gt; Yet you keep second guessing entire teams of engineers describing why generics would be useful for them How can you, after my previous post, **still build this strawman**? I don't get it. Like, I really don't see any explanation for this except intentionally and maliciously playing dumb. If you are interested in a productive discussion you *have* to accept that **no one is arguing against the usefulness of generics**. &gt; Don't you think that's not extremely arrogant and insulting to people? &gt; &gt; I mean you somehow always know better than everybody else. So, we graduated from strawmen to [ad-hominem attacks](https://yourlogicalfallacyis.com/ad-hominem)? Feel free to constructively engage with anything I said. Like, please at least *try* not to let your personal animosity towards me keep you from engaging with my arguments. Please stop claiming I said the literal opposite of everything I said. It's infuriating.
Thanks 😚
&gt; Either you get why generics are useful or you don't. This is not how it works. "You are either with us or against us" is not a productive argument. Generics as a language-feature are not a binary choice (there are many flavors and many ways to implement them). And whether or not they are a net-benefit *also* is not a binary choice - there are many dimensions to consider and they are beneficial on some of them and hurtful on others. It's super-frustrating that I have yet to see a single proponent of Generics-in-Go acknowledge their downsidesand I have yet to see a single *opponent* of Generics-in-Go denying the upsides. But strangely, the opponents get presented as the people who refuse to listen or understand the benefits. To me, this presents itself as one side desperately trying to steer this discussion in an actionable, productive direction, while the other arrogantly builds false dichotomies and vilifies their opponents. For the last time: The question isn't whether Generics are useful or not. The question is *what specific incarnation of Generics would be most useful*. For that, you *have* to know, what they are used for, period. If you stop making this such an obnoxious us-vs-them deal and start engaging productively with the debate, everyone would be better off. The steps are 1. Accept that there are many different ways to implement Generics, serving different uses differently well 2. Accept that Generics have cost 3. Thus, start talking about how we can best solve the cost-benefit tradeoff: What flavor of Generics can solve the most relevant use-cases at the lowest cost. *Stop talking about Whether-Or-Not-We-Want-Generics*, start talking about *how* do we want Generics. Like, for all intents and purposes, *you have already won the "if"-debate*. Now you just need to finally realize that and listen to people asking you how you want the thing you so desperately need implemented. And you don't have to actually *agree* with those steps, for the record. You can find them stupid and useless if you want. All we are saying is this is the way you would need to engage with the topic, to be most **effective**, if your goal is to actually get some flavor of generics, soon. The fact that you are ignoring this advice is suggesting, that that is not your actual goal, though. &gt; The use case angle is a straw-man. Again, please look up what a strawman is, you are misusing the term.
&gt; =&gt; Either you get why generics are useful or you don't. &gt; &gt; This is not how it works. This is exactly how it works. Either you understand the value of generics or you don't. It is quite simple. Go designers say they don't. &gt; Stop talking about Whether-Or-Not-We-Want-Generics, start talking about how do we want Generics Ian Taylor Lance already wrote a report on several generic implementations. Did that report move things forward in anyway? no. So please don't act like the question asked is "how". We've already been there and it led nowhere. Don't act like go designers are interested in the "how" when the how has plenty of literature already. &gt; =&gt; Again, please look up what a strawman is, you are misusing the term. No I'm not, a straw man argument is essentially a distraction in a debate, which is exactly what that whole "use case" thing is.
Sounds like java people designed the architecture of Kubernetes.
Why do u dislike the Lambda approach? Sorry, can’t get a clear picture from your comment.
&gt; This is exactly how it works. Either you understand the value of generics or you don't. It is quite simple. Go designers say they don't. You are literally lying here. &gt; Ian Taylor Lance already wrote a report on several generic implementations. Did that report move things forward in anyway? no. So please don't act like the question asked is "how". We've already been there and it led nowhere. Yes. And the [Go 2](https://blog.golang.org/toward-go2) blogpost lies down pretty well why and makes clear, what's missing to progress: Previously, there wasn't a lot of thought put into what the requirements are and experience reports are designed to answer that question. &gt; No I'm not, a straw man argument is essentially a distraction in a debate No, it really is not. A strawman is a *very specific* distraction, where you are misconstructing the other side's argument to make it easier to attack. There are other "distractions in a debate". To give some examples: * A *strawman* would be, to claim that people are denying the usefulness of generics in Go: That is not what anyone is actually saying, so it misconstructs the arguments made. * An *ad-hominem attack* would be, to attack someone's character to reduce their credibility. * A *genetic* argument would be, to thus ignore arguments made, because they come from a source one does not like. E.g. if you where to say "Most of your posts about the issue are strawmen", instead of actually engaging with the arguments made on their own merit. * A *bandwagon* argument would be, to use the popularity of a language feature as an argument for its inclusion. * An *appeal to authority* would be, to refer to "plenty of literature" by experts, instead of actually engaging with an argument. * A *black-or-white* argument would be, to say that you either are accepting the benefits of generics and must therefore be in favor of their inclusion, or you don't favor their inclusion and thus don't understand them. You see, all of these are "essentially a distraction in a debate", but not all of them are strawmen. "Strawman" is not a generic term to be used whenever you disagree with someone to discredit their arguments. It's a specific term used for a specific tactic and not only is it not *correct*, it isn't even a credible accusation, because nothing even close to a strawman is happening here. It would be far more effective, if you would have an intellectually honest debate.
&gt; No I'm not, a straw man argument is essentially a distraction in a debate, which is exactly what that whole "use case" thing is. You with out a doubt are constructing a strawman argument. /u/TheMerovius has gone to great lengths to explain to you how to be constructive. They have also discussed what the question and problem is, however you keep re-framing this to be a Generics vs Not-Generics debate. 
Java people should be banned from projects other than Java
Putting everything that could be useful into a language is how you get PHP. Please don't turn Go into PHP...
Please take no offence (no really, I don't intend to inflict it) but to me, you just seem to be too fixated on a particular feature, and hence your judgement about programming languages is weridly biased. To compare, if we move a bit into a more material world with that "the right tool for the job" statement, and consider, say, hammers, you sound like insisting on using any hammer *but* only if it plays a Britney Spears song while you're wielding it. To get back to the realm of computer programming, when someone (again) asks for generics, the canned response is always "what *particular* task you intend to solve using them"? And, really, this is not just playing smartasses. The real reason is that people much too often have certain fixations on certain features or misfeatures of particular tools (sure, we all do have them). To rephrase, you're stating the dire need for generics *up front* without even writing any code. So I'm reading this, while taking a break from the 100 ksloc Go codebase I'm working on here at my $dayjob. It does not use generics, and I can't remember we needed them. Except from maybe that recent port of some component done by a Java guy. To reiterate, I'm not telling the generics are not needed; instead, I'm trying to convey that they quite often appear to be not that essential in real code. So, it's weird to state "no generics, no Go". That's a distorted view of reality IMO. For a more extreme case, consider [this epic thread — "No Allman style, no Go"](https://groups.google.com/d/topic/golang-nuts/rzLzp_Z74ik/discussion) where a person argues that if Go does not support the so-called "Allman" style of brace placement, it's impossible to use the language. And everyone goes like "Uh... But we're using it to write production code..." ;-)
Speaking of logical fallacies, this one is called reductio ad absurdum!
&gt; That point sounds familiar to me with the generics in Go arguments. Why, though? Generics aren't *new*, I think "missing the boat" isn't really the issue or a claim to be made (right now, the more apt comparison - from a type-system perspective - wouldn't be generics, but rather dependent types or the like. I would even argue, that if anything, the story should be the other way around here: Generics were well established when Go came to be, but it still is a good success so far without them. So, if anything, it seems to indicate that jumping on that boat wasn't really necessary for other languages out there. &gt; What are the qualities of Go that you like, that another language doesn’t have To me, this question is backwards. What makes me like Go is the qualities it does *not* have, that other languages have. Like overly complicated type-systems, syntactic sugar or "magic". FWIW, everything it *does* have that other languages don't revolves not around the language itself, but the tooling. Go-get is amazing, gofmt is a must, fast compilation, good introspection tools for benchmarking and profiling… So, the (to some) uncomfortable answer of why I use Go and not some other language is… Because it doesn't have generics and other type-system extras that make the language a pain to use.
Thanks for your thoughtful response!
Hi, that's a nice and useful project! Do you plan on adding favorite handling? (*or at least a feature to add current playing track to a certain favorite folder*)
The single strongest argument I have seen for generics in Go is for data structure libraries. However they can be done without generics at the cost of additional time complexity due to 'copy paste' of functionality across implementations. That said, I have found that having that separation of functionality offers type specific optimization opportunities that I find are more then worth keeping independent implementations of.
Maybe I’m not understanding what you wrote 100%, but the articles I posted are on the topics of generics, so that’s why this post is about generics and why it seems like I’m fixated on generics. It seems like you think I’m arguing for against generics in Go, is that right? If so, then that’s not what my intention is. I want to know why individuals in the community are arguing either for or against generics in Go and if they consider alternate languages with generics because they’re not supported in Go, without providing my own opinions about the topic. Dave Cheney had arguments for both sides, so I reference them both in an effort to show the pros and cons he’s come up with. I’m also not clear on the hammer analogy you provided, can you clarify? Also, I appreciate you taking the time to post your answer and I take no offense to anything you’ve posted.
At work we introduced Go. As a technical solution it is great. But it takes a lot of effort to get Java/Scala programmers to move to Go. They think it is not worth it without generics. So I would say generics may have a nice side effect where it will push on the line Java/Scala programmers to move to Go. Still waiting for it to happen. 
nitpick: reductio ad absurdum is not a fallacy. it's a valid method of proof, used since antiquity. https://en.wikipedia.org/wiki/Reductio_ad_absurdum what he's doing is more like a *slippery slope* fallacy https://en.wikipedia.org/wiki/Slippery_slope
&gt; DoC and DoB functions call DoA function in some flows. I think how and when DoC and DoB call DoA is an implementation detail and should not be tested nor enforced. If you have an interface with 3 methods and you want to ensure that implementer calls them in particular way or order internally - something smells utterly bad. Aside the comment above, you may want to implement a test utility - a spy mock object, that records and forwards calls to Worker interface.
&gt; Python missed the boat on concurrent programming Except that it didn't; you can write concurrent or parallel code in Python just fine. Yes, the GIL *can* make that harder – or even impossible – in *some* cases, but for many cases it's not an issue. Also the vast majority of programs written are simple single-threaded applications, and I don't expect anything to change there. The GIL speeds those up. So it's a (reasonable) trade-off to make. Is Python the *best* language if you want to write heavily parallel code? No, clearly not. But no language is "the best" at everything. The idea that "every language MUST have feature X or it's outdated and sucks!" seems a bit daft to me.
TheMerovius for president!
If you can’t use code generation because of a combinatorial explosion, wouldn’t a generic type system end up being really, really slow because of that same explosion?
I have a hard time coming up with features that other languages have that I truly miss in Go. Its true that there are times I'll be writing some code and think "this would be a good use-case for a generic", but 9 times out of 10 the lack of a generic isn't forcing me to write more code, its more like the "OO Design" part of my brain is just seeing use-cases for them that will never be used. If I could add one thing, I'd probably add language-native map/reduce on arrays and slices, probably just as global functions like append. If we had generics we could write these ourselves, but I don't think I want generics in Go, so I'm happy tip-toeing toward generics without getting all the way there.
I don't think it's too broad. I think small packages are fine if used in multiple projects. 😊 One suggestion is to maybe change NewBaseN func to New.. basen.NewBaseN is kind of redundant. https://golang.org/doc/effective_go.html#package-names &gt;Similarly, the function to make new instances of ring.Ring—which is the definition of a constructor in Go—would normally be called NewRing, but since Ring is the only type exported by the package, and since the package is called ring, it's called just New, which clients of the package see as ring.New. Use the package structure to help you choose good names. 
"Is this too broad" isn't a language question, it's a design question. Take a look at the Single Responsibility Principle, read Pragmatic Programmer and/or Code Complete to go deeper.
You can’t remember why you need generics? Ctrl+F ‘len(‘ you fucking imbecile. 
Please wait. Let me bathe in the shining of your intellect.
Its here forever, imbecile
I'm not entirely sure as to why you'd want to mock out DoA(). Is it because it performs an action such as a DB call that is not strictly required to test DoB() and DoC()? If that is the case, mocking out the DB seems like the better option to me. Let DoA() execute but with predictable results. Generally though, I think more context regarding DoA() could help in finding a correct answer for your "how to test/mock" question :) 
What happens if the lock server physical machine crashes?
 type Worker interface { ... } func NewWorker() Worker { ... } I believe you might be chasing the wrong problem here. You should try to have your `NewWorker` return a concrete implementation and not an interface. You can then test and pass that concrete type to any function that accepts a `Worker` interface which ideally should have as few methods as possible. Remember two things: * Interfaces in Go are satisfied implicitly * The larger the interface the weaker the abstraction Also the interface should ideally be defined [on the consumer and not the producer](https://github.com/golang/go/wiki/CodeReviewComments#interfaces) aka not in the same package as the `NewWorker`. The interface should have only as many methods as the consumer needs (interface segregation principle). So in conclusion, test the concrete type and only mock the interface of the consumer when you test the consumer method/function. Have a look at: [SOLID Go Design](https://dave.cheney.net/2016/08/20/solid-go-design) 
&gt; Scala programmers to move to Go. I don't mind if Scala's programmers move to Go, but I would definitely mind if Go becomes Scala.
Taking the advice on New()
[removed]
Reductio ad php
Oh nice. . . I'm the kind of guy who pretty much screams bloody murder when I encounter yet another project stitched together with make and a big pile of shell scripts. . . so much so that I'd say that it's a bug to do so. :) There is a time and place for shell scripts but generally, it's a better move to use a *real* programming language. So if you're a Ruby shop, use Rake, Java/JVM shop, use Gradle (not Ant and not Maven). Python? Invoke's the best of the Python based task runners. Node.js, well use gulp and/or grunt and the other node build tools. .NET or PHP? I'm not sure, try switching to a different language/ecosystem. :) But Go. . . well I wouldn't really say Go works well for this kind of tooling but I'm willing to give Mage a try. 
&gt; Adapting arbitrary goroutines to respond to context cancelation (one way being, as you say, making your own custom context-style wrapper) can result in a lot of boilerplate scaffolding code, which I find undesirable. Worst case: go func() { &lt;-ctx.Done() whateveryouthinkisthecancelfunction() }() 
I am unclear on the advantage of using this package over something that provides reading and writing functions in arbitrary bases. Math doesn't change in different bases. Computers already translate between 10 and 2 all the time. Binary Coded Decimal died a while ago.
Hi, here's the blog post on writing a JIT compiler in Golang - https://medium.com/kokster/writing-a-jit-compiler-in-golang-964b61295f
I'm using it to iterate through Base62 numbers represented by the charset 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmopqrstuvwxyz So from 0 -&gt; 4C92 ... etc Ultimately testing hashes of arbitrary strings aga inst a known hash of a password The large numbers would go past int range
You realize parametric polymorphism (allowing definitions to work uniformly on all types) is orthogonal to object-orientation (packaging data structures with the operations that act on them), right? (Ironically, Go *has* support for object-orientation.)
Well, not exactly. The use case is: I have N functions (N goroutines) running concurrently, and I want the death of 1 goroutine to trigger the shutdown of all N goroutines. Here's an N=2 example, these are the two functions/goroutines I want to run: func tokenize(src io.Reader, dst chan&lt;- string) error { s := bufio.NewScanner(r) for s.Scan() { dst &lt;- s.Text() } return s.Err() } func interrupt(cancel &lt;-chan struct{}) error { c := make(chan os.Signal, 1) signal.Notify(c, syscall.SIGINT, syscall.SIGTERM) select { case &lt;-cancel: return errors.New("canceled") case sig := &lt;-c: return fmt.Errorf("received signal %s", sig) } } Here's how I guess it works with errgroup. g, ctx := errgroup.WithContext(context.Background()) g.Go(func() error { return tokenize(rc, dst) }) go func() { &lt;-ctx.Done() // ctx is canceled when first func returns rc.Close() // if it wasn't tokenize, tell tokenize to return }() g.Go(func() error { return interrupt(ctx.Done()) }) log.Print(g.Wait()) I find this a little tricky to reason about. We have to model the complete context cancelation hierarchy in our heads, and think carefully about how it interacts with each function/goroutine. Conversely, here's how it works with run.Group. var g run.Group g.Add(func() error { return tokenize(rc, dst) }, func(error) { rc.Close() }) cancel := make(chan struct{}) g.Add(func() error { return interrupt(cancel) }, func(error) { close(cancel) }) log.Print(g.Run()) I find this easier to understand and reason about. The execute and interrupt code for a given function/goroutine are declared next to each other. Each execute/interrupt pair is independent of the others. And they're all symmetrical, which helps a lot, too. Of course, if don't think it's better, that's fine.
&gt; What makes me like Go is the qualities it does not have This is why I've picked Go for my recent projects. I was doing a lot of Scala before Go, and I've grown tired of trying to figure out what esoterics would express what I want. I'm not as worried about declarative statements, I can still design my code this way, and structs are just as enjoyable as case classes over Java objects.
Sigh, I just hate reading only one side of conversation and rest being [deleted]. 
Try /r/programming
After 4 years of programming in Go with a team of a dozen or so contributers, I can only say that you *must* always stay cognizant of the patterns being put into place. It is absolutely possible to write clean, well formed large code bases in Go. But when developers from other backgrounds, particularly when many of them from a similar background come together and try to re-invent what they know in Go, you end up with something like what we see here. As mentioned in other comments, this article does not really describe the actual problem they are trying to solve. If the author(s) can expand on their intentions, it would be an interesting thought experiment to redesign this code in a more idiomatic way. 
First of all, I think a part of your problem comes from using `io.ReadCloser.Close` to signal the shutdown, as opposed to letting whatever provides that data to close it down "naturally" as part of its termination. You're writing code that only works for some `io.ReadCloser`s. I really don't see that big of an difference between the examples above, and errgroup is what everyone else but you is going to be already familiar with. You use weaselwords like "have to model the complete context cancelation hierarchy in our heads" when it's not really any more complicated than your cancel channel, and more likely to be shared knowledge. Then again, I really would not recommend anyone program like that `tokenize` function, either. You've constructed a generator/iterator with a channel on top of `bufio.Scanner` for no good reason. Your custom `interrupt` function is easy to librarify in a context-friendly way, e.g. https://github.com/markbates/sigtx/blob/master/context.go I'm not exactly sure what you think is confusing, and the way you write your example (naturally) biases the code to your way of thinking. Here's an independent, but similar, example: https://play.golang.org/p/XftgGQzaBKy
&gt; Generics as a language-feature are not a binary choice (there are many flavors and many ways to implement them). And whether or not they are a net-benefit also is not a binary choice - there are many dimensions to consider and they are beneficial on some of them and hurtful on others. This. Is. So. True.
&gt; A Golang function value is just a pointer to a C function pointer (notice two levels of pointers). Can someone clarify this statement? Is it referring to the syscall into the kernel being the C function and not within Go itself? 
Hello, I'm glad you asked this question - I found out about this while reading the Go reflect package source. Specifically https://golang.org/src/reflect/makefunc.go#L55 The C function stack layout and the golang function stack layout are exactly alike in the way arguments are passed into function calls and return values are obtained.
At work I also needed to implement a distributed locking library, but in Python. We wanted to have a common locking interface that abstracted away the actual backend. In our case, the only implementation right now is Consul. Nice thing is that it uses heartbeats and TTL on the locks in case of crashes. And we could always swap it to etcd, zookeeper, or whatever, even for different sites. I also added the abstract concept of storing task state data. The use case is where you have N workers that want to do a particular task. Only one should be able to do it and the others must wait. Then when the remaining waiters acquire the lock, they should be able to check the state to see if the work succeeded and get a value. Maybe the original worker crashed and the task is still undone. 
Thanks for the link. So this is talking about go 1.1 and alot has changed since then. The document refers to a new implementation which would change the layout. How much of this is still valid for Go 1.9?
Nobody has ever suggested this. 
I'm guessing the compiler could optimize out most functions?
Thanks to all that have given some tips. This config doc is in fact some type of global config for a whole slew of unrelated apps. The docs changes daily. Fields are added and removed in a willy nilly fashion. It's a real horror of a design, but that's the way it is. Battling multiple teams and dozens of developers to try to get this on the road to respectibility isn't worth it at this point. Especially since we're hired gone hacking around with Go so they can get a read on whether or not this could be a language of choice for them. Great customer. Odd organization.
As per, feedback greatly welcome. I hit some snags in the road with this part as I was having troubles with managing vendoring within a monorepo. So I had to split it out into separate repos unfortunately, which I feel makes the series a little harder to follow :( I'm not massively happy with this one. But I'm sure there'll be some great suggestions :) 
I've seen a lot of the experience reports on generics and I'm convinced by now that it would be a good thing if they were added to Go (mainly to create type safe and performant container types). However, this experience report is by far the worst I've read on the topic. It actually makes me think maybe generics are not too great, because people actually will be doing horrible things with them if they are added. At no point this experience report explains what Kubernetes actually does with this weird runtime type system they created. It only says that it could be replaced with generics. I'm not saying that they don't have a good reason to have this weird setup. But if they do that should be the core of the experience report. It shouldn't be: We created an ugly mess of code and it could be less of a mess with generics. 
I'm starting to think generics are a bad idea, but generic /containers/ are a good thing. The majority (67% of statistics are made up on the spot) of generics examples are always containers of some type or another. Maybe Go just needs more built in containers than a slice or map.
Ah, that makes sense. This is far more efficient than enumerating an int (or, as you say that is not enough, a BigInt would be needed) and converting each time. I would suggest a bit of a comment to that effect on the Readme.
Your first sentence I can somewhat relate to. But I don't think more containers in the language would solve it. There's just too much types of useful containers, most with their own tradeoffs (threadsafe, complexities for lookup or removal). I don't think it's feasible or desirable to put them all in the core language. If there's a way to allow generic containers (including methods) without adding full generics I think that would solve most of the problems I'm running into though. 
I'm learning go and this is the first time i'm reading one of your series. Why do have Encode/Decode method of a struct? I would either have the JWT secret be data of the struct or write plain function.
Good. 
One popular way of implementing generics is just code generation inside the compiler. So, most likely, the explosion would be just as big, just invisible.
We moved to a monorepo six months and it has been working fine. I wouldn't want split it up again. We are using Glide for dependencies and haven't hit any issues yet. A code comment: Use import "context" instead "golang.org/x/net/context"
Read the responses on medium, this article seems to hinge on a misunderstanding of what `runtime.Object` in Kubernetes even is. &gt; AIUI, runtime.Object is basically the equivalent of proto.Message — it describes API-objects at the RPC boundary, not objects of the language or internal datastructures. It is an artifact of thinking in micro-services, not a hotfix to the Go type system. I don’t understand how you are imagining generics helping this. &gt; &gt; In essence, the type registry isn’t there to create a “runtime type system”, but to map from “some serialized identifier of what this is” to “a compiled in data type of the language”: When an API endpoint receives an Object (say, serialized to json), it will also get an identifier of the Go-type to represent it. It will then look up that type, create a value of that type via reflect and serialize it into it. The error message you are describing means, that the type was not compiled into the binary, so it can’t be deserialized. 
Lots of people have loudly proclaimed their right to have their favorite feature in Go, for years now.
Considering that there's no C left in the compiler, and CGo explicitly creates a trampoline function like void _cgo_41accf25aad6_Cfunc_fortytwo(void *v) { struct { int r; char __pad4[4]; } __attribute__((__packed__, __gcc_struct__)) *a = v; char *stktop = _cgo_topofstack(); __typeof__(a-&gt;r) r; _cgo_tsan_acquire(); r = fortytwo(); _cgo_tsan_release(); a = (void*)((char*)a + (_cgo_topofstack() - stktop)); a-&gt;r = r; } just to copy arguments and return values between C and Go calling conventions, that's highly suspicious.
Looks like a Go function value is a pointer to a pointer (no idea why, without lots more reading), but the parts about C are a leftover comment from days long past. And syscalls are done in straight up assembler (on Linux, and most platforms), C has no role there except when the platform refuses to have a stable kernel ABI (Solaris, Windows).
&gt; This is done using Type Magic — the ability to convert any type to any other type. No magic there, just `unsafe`.
I don't believe that is generally true. Under multiple licenses, all are valid and licenses you don't use have no affect on you. Furthermore, most commercial companies with code that is released as open-source also release it with a commercial license. Red Hat as an example of a multi-billion-dollar company with code dual licensed as GPL or commercial. There are countless other examples.
Personally I have seen such basic mistakes in Viper that I do not consider it to be a very stable or well tested product.
[Removeddit](https://www.removeddit.com/) might be of interest to you 
What does that mean? Or is it sarcasm? If you mean generics will make Go Scala, I don't think so. Scala doesn't own generics. Generics may or may not be the best fit but start coding something complex in a fast moving environment and it may come handy. There are arguments for both sides of the fence. Looking at user reports people do have a use case for it. 
Uh... just because the particles are updated simultaneously at each tick doesn't mean that the code has to be concurrent.
Thank you, will take a look.
What a great blog, you’ve recommended. Thank you.
Can be done, I will look into it and get back to you.
It's not a pros and cons list, but some example to show how it goes https://medium.com/pantomath/how-we-use-grpc-to-build-a-client-server-system-in-go-dd20045fa1c2
For the record: That is me and I was trying to pose a question (the same question I asked here), in the hope that the author of the article would answer it there. I might *very well* be misunderstanding something. (Of course, I'd love to get an actual answer to the question, if I'm mistaken or not)
&gt; I'm starting to think generics are a bad idea, but generic /containers/ are a good thing. Funnily enough, I think generics are a good idea, but I *don't* want generic containers, as they tend to expose the worst of the mental overhead of generics and then permeate *everything*. I.e. one of the things I like about Go is *not* having to answer the question "what kind of Collection&lt;T&gt;/SortedCollection&lt;T&gt;/PriorityQueue&lt;T&gt;/Map&lt;K,V&gt; should I use here?".
[removed]
&gt; 100 ksloc &gt; does not use generics I wonder if there is any connection between the two.
There's [been](https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid) [some](https://neilmadden.wordpress.com/2017/03/15/should-you-use-jwt-jose/) [criticism](http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/) that most people using JWT don't actually understand the security implications of it. It might not be the best choice, unless you've had a good read of https://www.owasp.org/index.php/JSON_Web_Token_(JWT)_Cheat_Sheet_for_Java
I read all your previous posts from this series and didn't check the repo anyway. I find the snippets good enough. I like that I can just change one letter in URL and go to another part.
Ahhh okay, I did see a few others using Glide, they must have solved the problem, whereas dep seems set on not touching the issue. I considered using Glide, but then worried that dep would replace it or become 'official' at some point. Is this a public repo or do you have any resources on how you set yours up? I'd love to know more :) I've had compatibility errors from the new standard lib context from certain Google libraries, but that may have changed. I'll test again using just "context". Cheers! 
That's not what he said 
Unrelated question, but what is the editor/theme in the [background image](https://ewanvalentine.io/content/images/2017/12/Screen-Shot-2017-12-25-at-19.01.14.png)?
Looks kinda like VSCode One Dark Pro
I worry that even to optimize it, you still have to compute the thing first and then reduce it down, but I could be wrong. 
I'll pile on that train: https://storify.com/jcuid/thomas-h-ptacek-don-t-use-json-web-tokens https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/ (yes they're implementation bugs but if the implementation is this hard to get right, what does that tell you)
One issue I found with jwt token's is the inability to de-validate tokens. In order to do that you end up needing some kind of state. In my jwt implementation, I created a restful endpoint that sits behind varnish that outputs the last modification date on a user. If the creation date of the token is older than the last user modification, it gets rejected. However, if that endpoint is down for some reason it will accept the request if it is a valid token. This means I had to create a library for my authentication service. So all my micro services handle validation correctly, but that was probably a good idea anyway. Also the endpoint uses a generated hash of the username so someone could find that endpoint and figure out usernames in my cluster. I bring all this up because at some point you will have to remove permissions from a user, or deactivate them entirely. It would suck to be rushing for a fix when that day comes. 
"I would insult you, but nature already did that." 
Explain Edit: Oh, you're a troll bot. I was hoping for constructive criticism.
No, there is no such connection. As someone else pointed out in this thread, generics are useful when writing *generic* container/algorythm libraries or code like this; we're not writing a such a library. At some point we considered code generation for implementing one particular feature but got away without it (and without code duplication, too).
The majority of users are asking for the same 2-3 feature, which you can see from the annual Go user survey. 
&gt; At some point we considered code generation for implementing one particular feature but got away without it (and without code duplication, too). Does that piece of code have compile-time type safety?
The survey targets existing Go users, not the ones who could never imagine working in a language without `foldr`.
Yeah and that's the reason why you need to question if jwt is the right tool for session handling. If you loose means of session invalidation or leave it up to the client, the given solution is simply incomplete. If you need to track user validity or current ACL, jwt bring nothing to the table except a huge payload on every request. 
Yep, its foolish to implement something without looking into all of your options. Whatever you choose though, implementing a cluster wide, single sign on login/privilege management system is going to be complicated. Unless I'm wrong and there is an obvious way of doing it. If so, please let me know.
God I wish there was but it's nothing jwt can help you with as all you need to transport is a sso idea tiefer with some kind of salt/part that you can control. Jwt has good other usages but handling sso is not one I found to my liking but maybe others do.
I completely agree with this. I started using Go very early on (early 2012) because I found myself without an employer, and unlikely to find one. I needed to make money on my own, and, when you find yourself negotiating contracts, maintaining client relationships, managing your own infrastructure, and handling finances, coding needs to be the easiest thing you do. Go was just what I needed. It was inexpensive to write and run (no paid IDEs required, and it ran on Linux). It was super simple, meaning I spent more time thinking about the problem than the language. It was fast, meaning I spent more time coding than waiting for compilation and tests. Go really is the language the 'as simple as possible, but no simpler' language. My greatest fear is that some stupid demand from the "community" will cause the people with experience and knowledge behind the language to question themselves. Who on Earth really has more relevant experience than Rob Pike or Ken Thompson on the matter? How many people that are begging for generics have PhDs? Go's source is open and available; if someone wants to add generics, go for it. Otherwise, I see nothing wrong with letting the language masters do what they think is best. The generics issue is a matter of backseat driving. The driver is experienced, knowledgeable, insured, and owns the darn car.
Yes. But that's not "it always can be done this way" sort of thing. Just in this particular case it was possible to engeeneer a solution which is type safe w/o using generics and code generation. One may say that lack of generics forced us to actually think, and that is true to some degree, but certainly it should not be taken as some sort of an apology for the lack of generics. (Though I, for one, am ambivalent about their presence or lack thereof.)
I am a bit confused. Isnt bitcoin for example language independent? There are multiple clients/nodes in different languages. I think I saw a client for it on this reddit a little while ago. 
Cryptocurrencies are protocols. It doesn't matter which programming language you use, and any programming language can be used.
Crypto currencies are protocols and algorithms. Not language specific. There is popular Ethereum implementation in Go: https://github.com/ethereum/go-ethereum
There are many other implementations as well. You can look up decred, sonm, geth and even Bitcoin daemon implemented in go on github. 
The most popular Ethereum client, geth, is written in Go.
 unsafePrintFunc := (uintptr)(unsafe.Pointer(&amp;printFunction)) printer := *(*printFunc)(unsafe.Pointer(&amp;unsafePrintFunc)) How will that work if printFunction is a slice, not an array?
Can I see it?
&gt;Then there’s this one sentence in the description: &gt; &gt;&gt;Each tick, all particles are updated simultaneously. &gt; &gt; Could it… could it be? A puzzle where goroutines can be applied to do what they were meant to be doing? Only one way to find out, and that’s to try and use goroutines to solve the puzzle. Um.... yeah, that's not what goroutines are meant to be doing.
Linked: https://www.reddit.com/r/programmingcirclejerk/comments/7m8wc7/one_of_the_things_i_like_about_go_is_not_having/
If you treat it as a concurrent problem, and that's what he did, then yeah it's what they're meant to be doing. But in your first comment, you said he implied that simultaneous update meant concurrent problem, and that's not what he said. He said goroutines **can** be applied here because he saw a concurrent way to solve the problem.
This was posted a few days back: https://github.com/joshuathompson/baton
i hope you will become obsolete with the coming of generics
In my experience, most clients are written in Go and C++. The only time I’ve seen Java was for IOTAs official client.
&gt; The C function stack layout and the golang function stack layout are exactly alike in the way arguments are passed into function calls and return values are obtained. Not sure about other platforms, but IINM, at least on x86_64 the gc calling conventions are not directly compatible with the C ABI.
FTR, the snippet is not a valid use pattern of the `unsafe` package and it is not guaranteed to work across all Go compilers/releases/architectures/platforms.
Thank you to everyone above for taking the time to respond. I am new to most of this stuff, and just joined the Go Reddit page. Already love it. Great community. 
There's also a great implementation of Bitcoin in Go: https://github.com/btcsuite/btcd/ And most of the work on the Lightning Network is being done in Go: https://github.com/lightningnetwork/
&gt; If you treat it as a concurrent problem, and that's what he did, then yeah it's what they're meant to be doing. Dude... what the fuck are you talking about? Just because a problem can be solved concurrently doesn't mean it can be treated as a "concurrent problem" and it certainly doesn't mean that it *should* be solved concurrently.
I knew I had a familiar feeling when I saw this. 
&gt; What does that mean? Or is it sarcasm? &gt; &gt; If you mean generics will make Go Scala, I don't think so. Only partial sarcasm. The context was that the OP needs Go to add some language features to convince Scala programmers to come over. My response is that if Go starts looking good to Scala programmers (meaning, Go looks "normal" to programmers who think in the Scala style), then we've lost the best that Go has to offer. Now I don't think that more featureful languages are _bad_. I've been chomping for a reason to learn Rust, FWIW, but the further Go moves away from where it is now, the less need there is for it.
&gt;so that they could provide http2 without tls on it Why did they want to do that?
Welcome friend. 
I don't get all that cost benefit talk. Many languages have generics so clearly the cost is not that high and the benefits are worth it. At this point this really smells like stubborn unwillingness to admit somebody made a mistake.
Admitting the mistake is easy. Going back and retroactively fixing it without destroying a lot of the ideals of the language is really hard.
I don't like go as a language. I think the syntax is weird, I think it's unnecessarily verbose, I think the error handling is atrocious, I think the type system is archaic. I use go because it's got a good compiler, because it supports a lot of platforms, because the library is rich, because the runtime is fast and efficient. I tell you what though. If the crystal team has the resources of the go team I'd drop go in a heartbeat. Crystal is everything go should be but is not and never will. 
Nem as well, but they’re migrating to C++
Good to know, cheers :) 
Such good links here, you're absolutely right. I'll add a beefed up section on security including these links and double check the algorithm I'm using, see if it's secure, or if there's a better one I could be using. Thanks again :) 
You know about the discord channel, right? https://discord.gg/UVvaZ97
Atom with Oceanic Next theme :)
Yeah that's a good point, and something that made me consider using OAuth for these tutorials. But, it's a lot easier to explain and implement JWT. So figured it was a good starting point. I think it's a solid enough solution overall. Does anyone have any suggestions apart from OAuth? 
You could use either of those approaches, too. I went with my approach as I could encapsulate encode/decode as a single instance and interface it :) 
"I think it’s not possible to send and receive to the same channel in the same goroutine?" Alright,why write articles about stuff you are not certain?
Why is he being downvoted for this?
Anybody knows how can the cursor in the video change from red (maybe invalid command) to green (valid command)? Which tools can do that? Thanks,
finally a sane comment
1. The factorial only applies to `ObjectConverter` (it wasn't very clear in the post) - think `ConvertAToB`, `ConvertBToA`, etc. - it makes some sense that there would be some combinatorial explosion. The other methods would only be duplicated 30ish times. 2. I'm not entirely clear on how many types even have converters defined, but I imagine there are a *lot* that would have no conversion and could be optimized away to error (e.g. `ConvertEncoderToBool`). Even then, `ObjectConverter` is probably one that would not make sense as a generic - languages like C# and Java that *have* generics still leave the object/type converter as a runtime implementation. 3. Not all languages encode generics as code generation (i.e. having multiple copies of a method in the binary). C# implements it as one class with a 'tag' containing the type that differs at runtime depending on what type is inside, so there is only one copy of each method. C++ on the other hand, uses templates to get "generic-like" behavior which does do the copying thing you mentioned. And yes, you're right, if you try and do really dumb and complex things with templates you can get in a situation that blows up your compile time.
That's interesting. I didn't about baton before I made spotctl. One highlight is that spotctl can show the realtime Spotify player: https://github.com/jingweno/spotctl#demo. Maybe I could join force with baton.
I like how baton uses github.com/jroimartin/gocui to handle the playlist etc.. Maybe I could incorporate into spotctl. 
Yeah, I was thinking this too... He just does things that he doesn't understand and tries to figure out why later.
I pressed the p key which plays or pauses current track. There are a few shortcuts that allow you to control Spotify playback when you're in `spotctl player`.
Godoc can be viewed here (https://godoc.org/github.com/vectorhacker/goro). Please give me all your comments. Roast me, even.
I see. Your doing something similar to [empty structs can just be a collection of methods](https://medium.com/@matryer/cool-golang-trick-nil-structs-can-just-be-a-collection-of-methods-741ae57ab262) . Since you never use the repo data of the TokenService struct.
How would adding generics destroy any ideals?
I mean in the video, at 00:03, you type `spt`, then the cursor color was red, after that, you type `spotctl`, and then the cursor color was changed to green. Which tools do you use to do that? :D
is this repo doing the exact opposite of what the cmd folder usually is?
Circle jerkers discovered the thread.
You might also want to checkout Skycoin: [github](https://github.com/skycoin/skycoin)
[removed]
It depends on which kind of generics you want. Most of them would either slow down the compile time, bloat the binary size, require an equivalent of JVM/CLR's help, or make the language difficult to be consumed by humans/machines when the codebase getting large.
It's the pattern described by Cobra (the CLI library used): https://github.com/spf13/cobra#getting-started
It would not slow down the compile time to a noticeable degree nor would it bloat the binary size (not that it matters anyway). I suggest you look at other languages with generics.
&gt; Many languages have generics so clearly the cost is not that high and the benefits are worth it. [read](https://yourlogicalfallacyis.com/bandwagon)
neat, thanks.
I'm the author of baton and I think it's kinda cool to see different approaches to making something so similar. Starred you.
&gt;It would not slow down the compile time to a noticeable degree nor would it bloat the binary size (not that it matters anyway). Then why do the languages I was once excited about like Swift and Rust deliberately slow down their compile times? I believe there is a language with generics which builds faster, runs faster, comes with smaller dependencies, enables more efficient toolings, and lets you and the whole big team write code more productively. But I have yet to learn about it. Perhaps you care more about the convenience of generics and we have different sets of demands.
As the mod in PCJ, I discourage others from doing this. Mutual downvote slapfights tend to lead to shadowbanning for those involved. Just ignore the audience, is what I'm saying.
Didn't someone write one already?
[removed]
[removed]
Correct :) I'm not using the TokenService itself directly anywhere, but I am using the Authable interface which TokenService satisfies. So it is just a collection of methods that satisfy an interface
&gt; More gonic, more efficient Gonic?
Gin &amp; tonic?
Sorry for my misunderstanding of "gonic", I am the repo author, what I'd like to express is more go styled... I am a english learner, can you provide me some suggestions :)
Python is one of my favorite languages and I think the GIL is a feature. I also think that Python failed in terms of concurrency. Instead of having a single clear way of implementing concurrency "There should be one-- and preferably only one --obvious way to do it.", there are many, and IMO they are all lacking. gevent only works with some compatible libraries, concurrency based on threads won't work well due to the GIL, and multi-process based concurrency isn't as polished as it should be: Managing worker processes (and failures) isn't as easy as it should be.
Use the word "idiomatic" instead.
Thx 😃
This is pretty cool! Why do you need both libraries? I am writing a discord bridge for IRC and only use bwmarrin's discordgo. Also: - https://github.com/bwmarrin/discordgo - https://github.com/kz/discordrus
This is very similar to something I did for my old job. I'm a huge fan of Apache Beam and used Google Cloud's Dataflow platform, but I couldn't stand writing Java. I ended up reimplementing part of the SDK in Go, and it worked great at scale processing a few hundred thousand events a second. I'm hoping to see more dataflow frameworks written in Go.
If you like Vim I would recommend trying [Spacemacs](https://spacemacs.org) as a "full IDE" because the emacs Go plugins (flycheck, company) are capable of doing what you say out of the box. 
I use the same plugins you do and could not yet achieve what you want. For the checking you desire, I have to save the file first for the linter to run.
Nice, curious if you can give some feedback on your usage of Event Store with Go, how do you like it and if you've had any issues you had to deal with?
I've found this [question](https://stackoverflow.com/questions/37769882/vim-go-synstastic-errors-not-automatically-displaying-on-save) on SO, which is for vim-go + syntastic. So, running :GoErrCheck will show errors in quickfix window, but without gutter signs :-/
There's also another set of people that scream bloody murder whenever they see yet another poor make clone just written in some other programming language and accepting some other input language. Make's DSL isn't that bad for what it's supposed to do and calling external programs is way more convenient from a shell language than it is from Go.
Echoing, good. This should be the prerequisite read for using Golang.
I really want the new Go sdk for Beam to be good but it looks like there won't be any native go runners for streaming so... I don't want to manage a spark cluster or what have you 
Run gotype on the file. I'm ussing Emacs, don't know how to do this with vim, but I know that's possible. gotype a_tmp_01.go tmp_01.go:11:7: cannot use s (variable of type string) as *string value in argument to echo tmp_01.go:15:7: cannot use &amp;i (value of type *int) as *string value in argument to echo 
Do I understand correctly that Mage totally punts on the question of what targets need to be rebuild on subsequent calls, i.e. the core part of Make? So to avoid redoing expensive tasks again and again, I'd have to reimplement the needs-rebuild logic all by myself within the target functions? If this is correct (and I can't find any code suggesting otherwise in the git repo), then this is not a Make replacement in any way but just a fancy wrapper around 'go run' (not that Make's timestamp-based approach is perfect, far from it!). It's probably a good idea to first understand Make before writing any "replacements". But yeah: &gt; Mostly because makefiles are essentially fancy bash scripts with significant white space and additional make-related syntax. [from https://github.com/magefile/mage]
OP likes vim so you recommend an Emacs variant... got it.
If you like Christianity, I would recommend trying Islam... 
I get the gutter signs with vimgo and syntactic (plus the quickfix stuff). I'm on the toilet on mobile right now, but I'll pm you my vimrc two hours from now. (If I forget, feel free to bug me and I'll get it to you)
Tough crowd you have here, @kidovate. :-) I know you were thinking of the lightweight command-line nature of the two tools even if they have fanatical adherents.
Curious if you've any Go projects on Event Sourcing to refer to I'm very interested in this field and always thought rhwtbGreg Young made a mistake in driving adoption by making a database, but non of the supporting materials about framework/etc
I didn't want to interrupt you sorry ^_^ So I managed it to work after adding let g:ale_linters = { \ 'go': ['gometalinter', 'gofmt'], \} The problem was that it was defined in other vim file and being overwritten. Thank you for your willing to help, appreciate that!
First of all I am suggesting you check out https://github.com/google/go-github/blob/master/github/github.go#L285 To me google has set a pretty good standard in writing net/http client library with this repo. After that, I suggest you check out the like of https://github.com/dghubble/go-twitter/blob/master/twitter/twitter.go who is a bit more adventurous and use https://github.com/dghubble/sling to help make things more readable.
For noobs: http://mqtt.org
This is a Go sub not a Vim sub and the variant I recommended is explicitly designed to support people who like vim. 
This is poor user experience report, it doesn't give me a clear picture of the use case but instead advocates for generics as some type of "catch-all" solution to an ill-defined problem. I'm completely ignorant of Kubernetes internals, but I've seen some variations of "type registries" in other projects and in languages with generics. I can't say for certain the versions with generics provided any additional benefits. 
I'm positive at the very least there will be a Dataflow runner for streaming eventually. I don't know this for a fact though. Disclaimer: I work for Google, but haven't checked on the Go runner status.
ah yeah, iirc there will be. (not a dataflow user myself.) I was more thinking it would be very elegant to have the runner/runtime baked into the binary so you could just drop it inside a container and ship off to k8s. maybe even as a custom resource in k8s. but maybe this is out of scope for the beam project 
Nice, and to think I just had people roasting me for recommending this in another thread. 
That is one horribly named database.
What's great about Go's concurrency model is that it is part of the language and not a library.
hahaha, I didn't name it. Greg Young did. I think he should have named it Oro and gone full in with the Ouroboros theme.
 client.Connect(func(server string, code ConnAckCode, err error) { This is not "More efficient, idiomatic Go".
oh, the client.Request is just a convenience method. It augments the http.Request with headers and parameters specific to the event store, so that I don't have to add those values every time I make a request. Other than that, I have been looking into using sling, but really the end user shouldn't have to care what http library I use.
yes, but I've been using it and it's missing lots of key features that the database has, like projections and competing consumers. I would have contributed upstream, but there was some other changes I wanted to introduce that would have been better off making a new one. For one thing, the way I want to read streams while making a subscription would be by having a channel of events to iterate over.
Most of my company uses Event Sourcing for our projects, as we like to keep a history of everything for analytics and creating new models using it is much easier than any other pattern. Also, most of our customers like the idea of an append only ledger. &gt; Young made a mistake in driving adoption by making a database, but non of the supporting materials about framework/etc I don't think it's a mistake really, it's just his strong opinion that you don't really need a framework, and I agree with him somewhat. Though, some library help would be nice, for things like aggregates and repositories, but other than that a full fledged CQRS/ES framework would just be counterproductive IMHO. Especially when your langauge has functional facilities likes functions as values and type mapping, it's really not needed.
&gt; I'm on the toilet on mobile right now, but I'll [...] two hours from now. You may have overdone the whole Christmas eating thing a bit.
I've been using it with the go.geteventstore library in the past and it's been good enough for a lot of things. Reading events, in that library tho, is kind of a pain which is why I'm writing this one, to make it easier. Other than that, using Event Store is Go is pretty straight forward since it supports HTTP as a first class citizen and it outputs straight JSON. It's been performing well thus far.
&gt; I would like to check my go files for syntax errors. Try the Go compiler, it's really good at spotting syntax errors. &gt; Usually it's about incorrect pointer usage or wrong type. That cannot be usually done just over an isolated file as those are not syntax errors. The type checker needs to access a complete package(s) for that. Once again, the Go compiler is quite probably the most complete and best performing type checking tool available. PS: I have mapped &lt;enter&gt; in normal mode to do exactly this - use the compiler to check the package I'm editing. So my "hotkey" for the check is &lt;esc&gt;&lt;enter&gt;.
I'd be really interested in hearing more, do you blog on this topic? I always had a problem with EventStore "queries" being uploaded JS bkobs jnto DB. I've also never been able to agree with anyone on what an "aggregate" is (most people in my circle believe it's any model that aggregates state., DDD says it's a "parent" or gatekeeper object for collections, seems like CQRS, ES and DDD don't agree on much terminology, also on whether "show profile" for e.g is a query or a command. I tend towards the latter (should leave an artifact, who viewed what could conceivably have a biz value) but I fear I may be alone in that belief.
One could be say something similar for function overloading or operator overloading,but they were intentionally left out of the language to keep Go simple and clear.
Interesting! I've had a look at cloud dataflow when it first was released as open source, but was also a bit put off by the Java API. Did you release Go SDK stuff as open source somewhere?
&gt; It's not about what you eat between Christmas and New Years, but what you eat between New Years and Christmas. That's what "all" just taught me, I'm still in the acceptable threshold!
&gt; It actually makes me think maybe generics are not too great, because people actually will be doing horrible things with them if they are added. That's probably true, OTOH I wouldn't consider this a point against generics, since people are going to do horrible things with or without generics. IMO It's a problem that unfortunatelly cannot be mitigated by either language features or lack thereof. 
My understanding would be that you could certainly record "show profile" somewhere, but that from the point of view of the event storage they're non-functional and wasteful since they probably don't mutate state in any way. Also, consider that by mixing queries with commands, you're potentially increasing the demands on your system quite significantly (since in many systems queries outnumber changes), and that if you have different retention requirements, you're now either doing weird pruning, or have to go with the most stringent retention requirement of the union of use-cases.
&gt; It is absolutely possible to write clean, well formed large code bases in Go. This makes me curious. Could you provide an example? Preferably, I'd like to see an example that is not either: - Code from inside Google (Google is a very rich company that can afford top notch programmers. Since they are able to write quality C++ code, they are pretty much guaranteed to also write quality Go code, yet neither is predictive of a more typical real world situation) - Docker / Moby (I don't have a very good experience with Docker. I'm running into bugs fairly frequently and the error messages are typically just relaying what the OS said and don't provide much useful context. There are also no backward compat guarantees.) - Kubernetes (I guess? Given the topic at hand.) 
No, sadly it is property of my previous employer. Beam does have a pretty slick Python API though. Give it a shot!
This Neugram language has less and less to do with Go, the more it gets actually implemented. Go syntax is not appropriate for a REPL, and pretending these scripting languages have much to do with Go is just silly.
Took one look at Crystal, saw Ruby-based syntax, threw up in my mouth a little, closed the tab. I will never understand why some people are so fond of that particular mishmash of ideas from Perl and Visual Basic.
If you want more structured data than a string, use more structured data than a string. Inspiration: https://golang.org/pkg/os/#PathError https://golang.org/pkg/net/#DNSError
The packages have benchmarks. E.g. `go test -run=- -bench=. crypto/tls`
Please stop calling `unsafe.Pointer` conversions "type magic".
https://github.com/goiiot/libmqtt/blob/master/client.go#L125 There are a bunch of panic calls and no use of recover, so it will cause the main program to panic if an edge case is hit. See https://github.com/golang/go/wiki/PanicAndRecover &gt; By convention, no explicit panic() should be allowed to cross a &gt; package boundary. Indicating error conditions to callers should be &gt; done by returning error value. 
Probably [zsh-synatx-highlighting](https://github.com/zsh-users/zsh-syntax-highlighting).
I've been working on a PR to ale that does what you ask: https://github.com/w0rp/ale/pull/1099 It works pretty decently, but test files are not supported yet
Hey, thanks for pointing me to the twitter api, it's really good. I changed mine to use sling, it works really well this way, it's much cleaner.
Interesting, probably I'll give it a try. Thank you!
Looks good, but unfortunately my setup is non-standard and gotype not always works for me. I've managed to configure my workflow with `gometalinter`. Thank you.
If you don't mind saving the file it is indeed fine to use gometalinter. The main reason I tried this to work is to get type checking to work while I type. 
Thanks 
LN is so exciting. As I understand it, this will also enable new services and/or the possibility to make refunds. LN can't come quickly enough. :)
you mean like lisp has had for many years? The ones that C++ watered down to make templates? I don't think generics are making or breaking any language any time soon. 
So, the article is is Portuguese, just sharing for portuguese gophers. Sorry for other language speakers :/
I can spot a few places where an invalid packet will cause a panic due to out of bounds slice access. You should fuzz your decoder.
gometalinter supports `gotype`; not sure why an extra linter is needed?
ALE can do this; I think the defaults are fairly conservative, but check out `g:ale_linters` and `g:ale_go_gometalinter_options`. I use this: let g:ale_fixers = {'go': ['goimports']} let g:ale_linters = {'go': ['go build', 'gometalinter']} let g:gometalinter_fast = '' \ . ' --enable=vet' \ . ' --enable=golint' \ . ' --enable=errcheck' \ . ' --enable=ineffassign' \ . ' --enable=goimports' \ . ' --enable=lll --line-length=120' " These are slow (&gt;2s) let g:gometalinter_slow = '' \ . ' --enable=varcheck' \ . ' --enable=interfacer' \ . ' --enable=unconvert' \ . ' --enable=structcheck' \ . ' --enable=megacheck' let g:ale_go_gometalinter_options = '--disable-all' . g:gometalinter_fast
Thanks for the feedback and for dropping the direct links to the upstream projects, they deserve the exposure!!
See my other comment, ALE only does gometalinter on save, not while typing. 
Isn't that something that can be fixed? I normally disable the check-while-typing stuff (as I find it annoying as hell) so I hadn't noticed that.
Maybe some of the HashiCorp stuff? https://github.com/hashicorp/vault
[removed]
[removed]
While it's nice to see the template packages documented like this, it's sad to see, once again, the tyranny of "struct". The template language supports maps, functions, slices, methods, and so on and so on. This post mentions none of that. The word "method" appears only in the first sentence and has nothing to do with methods on data types. For instance, you can say {{.Method}} to invoke a method on "dot", and have the value of the method invocation appear in the output text. For a really good example of this feature in use, see the documentation for "go list" and Dave Cheney's blog post https://dave.cheney.net/2014/09/14/go-list-your-swiss-army-knife. The template package is so much more powerful than this post would have you believe. I realize the post is more about the API to create templates than about the template language itself, but still... Whenever you see someone in the Go community use the word "struct" but mention no other types, have your guard up. And for the record, someone who shall remain nameless argued for an architectural change, just before the package rolled out, to simplify the API by removing the idea of a template set, but in the end that complicated the model and especially people's view of the package too much. It was a bad decision and I apologize for that.
Thx, I am working on it, and the current code just works 😥
Well, can you provide more suggestions on that? This is my first time to make a library 😣
I was told "just leave it broken", and I thought a bad TLS configuration should not be used 😢, better idea for that?
return an error
This is my first try to write library things, I am really really sorry for my bad code quality and not so idomic go, however, it's just the very beginning of the project, I would like to introduce more features to it, make it modern and suitable for everyone use, that's it 😉
Thx, on my way to fix it 😃
The community does its best to write good Go articles but they rarely reach the quality and depth of the articles we used to see in the Go blog. I am saying "used" because official Go technical articles are rare (the latest one was HTTP/2 Server Push in 24 March 2017). Meanwhile the community is growing and the need for technical articles that showcase the proper use of the language is higher than ever. I realize that the team is super busy but I am pretty sure the community would be delighted to see some new official Go learning material.
[removed]
Comments and criticism are welcome!
Was just looking for something like this, thanks
It could probably be fixed for `gometalinter` as well in a similar way I'm doing it for `gotype`. But wanted to try it out with `gotype` first to keep it easy.
&gt; Code from inside Google (Google is a very rich company that can afford top notch programmers. Since they are able to write quality C++ code, they are pretty much guaranteed to also write quality Go code, yet neither is predictive of a more typical real world situation.) I've actually seen some Google developers(formerly from python) writing stupid Go and even giving bad advice at Go Conferences. I'm sure that without mentoring and and jumping straight from C++ or any other language into a big Go project(from scratch) they will mess it up. What am I talking about..??? do you want to see some ugly Go code? Look no further than the old/classic Google Appengine SDK. Not having any experience with Kubernates dev but just skimming the blogpost and seing runtime.Object and all that crap makes me thing that's just another mess like the old appengine.
This is an awfully rust article for a golang forum
Even though it is not written with Go in mind, I thought it was quite applicable to Go language design discussions as well.
I believe you're wrong: ALE by default runs all linters after small delay , but this behavior can be changed. Please see [comment](https://github.com/w0rp/ale/blob/e43e7065da17f45e4cce127a319ceee0a0311883/plugin/ale.vim#L87-L90) in the code. In this [article](https://dmerej.info/blog/post/lets-have-a-pint-of-vim-ale/) the guy describes his ALE setup for python and he changes settings to be executed only on save: `let g:ale_lint_on_text_changed = 'never'`
You're half right. Most ALE linters work like that indeed. However if you look at the list of supported linters you can see that the ones with `!!` behind them only work on save: https://github.com/w0rp/ale#1-supported-languages-and-tools `gometalinter` is one of those (as well as most other go linters).
So much hidden complexity especially in the `string_processing` function. I wouldn't be surprised if it was accidentally quadratic and could bring the whole program down assuming a large enough input. This is probably a bad Rust article but it made me less excited to learn the language and made me appreciate Go even more.
&gt; re half right. Most ALE linters work like that indeed. However if you look at the list of supported linters you can see Ah, you're right. I was confused that it works after the file is opened. But when it changed it's not updates, only after saving. Thank you :)
Maybe I'm missing something obvious, but I really don't see how the `string_processing` function could even be close quadratic, as far as I can tell it's only O(N). `split_whitespace` and `filter` are (lazy) iterators, so they are only executed when you loop over the substrings, so O(N). Parsing the substrings is also O(N) in relation to the original string size. `starts_with` is at most O(N) as well, since it's O(1) called at most O(N) times. So it's a constant * O(N) = O(N).
&gt; So it's a constant * O(N) = O(N). Fair enough. Still my point about hidden complexity stands.
Sorry, not completely (I'm under an NDA for obvious reasons) but the general idea is as follows: we wanted to implement pooling of "compressors" (and decompressors) provided by the excellent `github.com/klauspost/compress` library. The point was in that initalizing a freshly created compressor instance which happens lazily on its first use for compressing takes noticeable time, so there's tangible gain in pooling the created instances—taking them off the pool and resetting when another goroutine needs to compress the payload of the HTTP response it's generating or decompress that of the HTTP request it handles. Since there's several standard compression methods available for HTTP, and `github.com/klauspost/compress` supports `deflate`, `zlib` and `gzip` (actually, HTTP's "deflate" is `zlib` here), the first draft idea was to use code generation to produce several implementations of "pooled" compressors/decompressors from a single "template" — parameterized by concrete types provided by the different packages of `github.com/klauspost/compress` implementing the particular formats/algos. The actual solution was to get away with a "generic" type which looks like this type Compressor struct { Format string readerPool sync.Pool writerPools writerPools makeReader func(r io.Reader) (io.ReadCloser, error) makeWriter func(w io.Writer, level int) (compWriter, error) resetReader func(rc io.ReadCloser, r io.Reader) error } and have several variables of it exported from our utility package. The relevant fields of each of these variables — `makeReader`, `makeWriter` and `resetReader`, — when created, are set to concrete implemenations calling out to particular packages of `github.com/klauspost/compress`. Each function is pretty thin (3-5 lines, including error handling). The resulting utility package exports shared variables implementing particular compressors—such as `Gzip`, `Zlib` etc. Not sure this explanation is what you expected but that's all I have. ;-) (BTW it's really interesting why previous post got 7 downvotes; I fail to fathom any reason for them.)
&gt; I did that and I came back to building and inspecting types with reflect I'm not sure how that is different from what the Kubernetes guys are doing... I mean, both are runtime type checks, no? 
[removed]
Hello, Not sure if I get your question right. Maybe the use of fmt.Println on the last line causes the unwanted newline ? Try fmt.Print instead or even better use fmt.Printf( ) and get rid of the variable outputPrnt. (I assume that it is not used any further. ) Sidenote: In Go it is not common to write the ; symbol at the end of each line, the compiler handles this itself. Try to use gofmt before publishing code.
The simple answer is that your last line is most likely `.*\\nEOF`, so it doesn't match the \\n\\n regex. Following on from that, regex is not the most efficient way to go about this. There are several options (as always)... one of the simplest to understand, which will also likely be faster than the regex matching would be to cast fcone to a string, use strings.Split(fcone, "\n"), then range over the resulting slice to clean each line...
I agree. The first thing that comes to mind is [the proposal for untyped composite literals](https://github.com/golang/go/issues/12854).
e.g. https://play.golang.org/p/LA098YgJa6C I would recommend running a benchmark over both variants with a couple of your input files and see if there's much difference.
Ok, interesting solution. Thank you for taking the time to type this out and to explain it to me. But this is not generics.
each of the distrilock endpoints is an NFS client, but they share a SPOF on the NFS server, yes
I have a similar use case, but without the check on success. I do not advise using distrilock though, unless it's for experimentation purposes.
For what it's worth I did not coin the term "syntactic salt" - https://en.wikipedia.org/wiki/Syntactic_sugar#Syntactic_salt
&gt; BTW it's really interesting why previous post got 7 downvotes; I fail to fathom any reason for them. Your comment was discovered and mass downvoted by the circle jerkers: https://www.reddit.com/r/programmingcirclejerk/comments/7m9ezz/one_may_say_that_lack_of_generics_forced_us_to/
Thank you.
Well, the point I tried to get across is that at first the idea which was getting kicked around went like «well, we could have `type PooledCompressor&lt;class Encoder, class Decoder&gt;`» which then naturally progressed into something like «we could have codegen to have that», and IIRC the person who led the implementation of that part back then squinted seriously at `github.com/cheekybits/genny`. Then we came to that idea of having a single common type instances of which are indeed parameterized by concrete implementations of three interfaces. Sure, "this is not generics", but there's no generics in Go, and I did not claim we somehow had them; quite the opposite. ;-)
&gt;see yet another poor make clone just written in some other programming language and accepting some other input language Fair enough, trying not to take your troll bait. For me, rake, Gradle, etc are far more flexible, pleasant and readable than make. Also, while they all have their own DSLs, they're not too complicated or extensive and you can effectively write most, if not all, logic in their target programming languages. I say this as someone who has written a million makefiles and shell scripts. Sure, make's a true and trusted veteran but the other tools I mentioned are a huge improvement. . . for me. Your mileage and taste obviously vary. I suppose we somewhat agree about Go, as it's a strongly type and compiled language, it does not seem like a perfect fit for a task runner. However, and this is huge, it's still a big win to be able use the same language in your CI/CD infrastructure that your application is written in. Or one of those languages. No one writes real applications in Make or bash.
Not only SPOF, but all lock state is lost when the server crashes or restarts.
I feel like you missed the whole point of the article. In Go, adding one string to another will implicitly allocate a new buffer and do two string copies. If you were doing string addition in a loop, this would have terrible performance. "Hidden complexity!!!" you shout... but the whole point of a programming language is to hide complexity -- to build abstractions. [Even Rob Pike himself has proposed for the standard `int` type in Go to be arbitrary precision.](https://github.com/golang/go/issues/19623) Is that not hidden complexity? Rust iterators are lazy. Once you know that, it's no longer hidden complexity. It becomes *obvious* that the function will not have quadratic runtime, just like it's *obvious* to any knowledgeable Go programmer that adding strings in a loop is a bad idea. The complexity is still hidden, but that's the price we pay not to be writing assembler all day.
Cool project.Thanks for it.Maybe will be using in the future.
Would you mind expounding a bit on why?
There is no need to apologize, thanks for working on this.
Hey, I think it's cool how you provide an API for piping like this but I do take issue with the API from a security perspective: // func NewProcess(command string) *Process p := procs.NewProcess("kubectl get events | grep dev") So the issue with this is when a developer wants to grep from user input. There is historical evidence that developers WILL do things such as: p := procs.NewProcess(fmt.Sprintf("kubectl get events | grep %v", untrustedName)) So it's widely adopted to provide the API the standard library does **(cmd, []args)**. Since this convention is both simple and consistent across across languages developers tend to use it correctly. By creating a new API to execute commands you are at an immediate disadvantage because it is foreign to the reader they need to learn how to use your API to write secure commands. I'll take a few moments to do that now. Okay- so what I am picking up here is you did not write this with any security considerations in mind. I may be wrong, but I'll explain why I came to this conclusion. You have no tests that check escaping in any way, you also do not have any examples to demonstrate this. Finally the words "security", "securely", "escape" are not mentioned in the Medium article, Godoc or the github repo. I'll try to use your library securely despite these facts, the only reference I can find to **args []string** is you comparing the shell expansion API you provide. Many developers may think it is safe to do something like: p := procs.NewProcess("echo $FOO") p.Env = map[string]string{"FOO": untrustedData} But this is very dangerous because simply replacing $FOO does not give the context needed to ensure safe escaping semantics for POSIX shells. In addition it adds an entire new classification of attack vectors through the environment, the bad actor can attempt to pass strings that may propagate results for their display. Here's a few example attacks, things could get much more sophisticated though: os.Setenv("VAR", `foo | rm -f /`) // inject var with cmd fmt.Printf("%q\n", procs.SplitCommand(`echo $VAR`)) // ["echo" "foo" "|" "rm" "-f" "/"] os.Setenv("VAR", `foo" | rm -f / "`) // using quotes won't help fmt.Printf("%q\n", procs.SplitCommand(`echo "$VAR"`)) // ["echo" "foo" "|" "rm" "-f" "/" ""] // Exposing a secret in ENV: userSuppliedContainerName := `my-evil-container-$AWS_API_KEY` os.Setenv("VAR", userSuppliedContainerName) // inject var with cmd fmt.Printf("%q\n", procs.SplitCommand(`docker restart $VAR`)) // You propagate to the web ui: // Error response from daemon: No such container: foo-YOUR AWS API KEY So currently I would say this library is not safe for use as is. I like the *concept* of the API that you are trying to achieve with piping and a manager process, but it needs more testing and more thoughts around security. I've written a similar API for piping and I did something like the below, here is how it could look for your library if you shortened NewProcess to New to get some chars back from the extra parameters: procs.Pipe( procs.New(`foo`, `arg1`), procs.New(`foo`, `arg1`), procs.New(`foo`, `arg1`) ) 
[removed]
[removed]
Thanks
Is there a document of concerns with the stdlib, and what this does to address those?
Pain in the a..? Really? I found the golang HTTP client to be incredibly nice to throw together quick microservices. I actually moved from doing so mainly with Python to starting a Go project any time I need to write one up! Though more description and I might get convinced to use this, maybe. 
stdlib HTTP is awesome, what are you talking about?
I see you returning body data from the call. That's all good and well when you expect little body, or no body, but if you're expecting a neon blob or stream that you're going to pass on to json.NewDecoder then that's not so good and is in fact a great way to waste memory. You should also probably want to think about size limiting your body reads (io.LimitedReader) in case something goes wrong with whatever API you're calling and it decided to send 30gb at you
yea that's why in the client#Send we can pass the read = false. Therefor we can read the res.Body reader whenever we want.
This is typical young programmer speak for "different than what I expected" and/or "I'm not willing to learn something new" 
Note: Kubernetes is from inside google and has an absolute shitshow of a type system. Also, C++ essentially has generics so, google being full of C++ coders is not necessarily a good thing for being able to keep Go idioms. Passing a google interview generally means you're smart and good at algorithms and math. Being able to maintain large code bases is not something that is easy to interview for.
Thanks for taking a look and providing some feedback. First off, you don't have to use a string. You can just as easily provide the list of commands. p := procs.Process{ exec.Command("echo", "foo"), exec.Command("grep", "foo"), } Similarly you can also do any extra setup you'd like when adding those `*exec.Cmd` instances. Regarding security, this is actually something I've thought about. I'll share my thoughts with the caveat I'm not an expert have consulted experts and found my conclusions to be reasonable. The reason for parsing the command into parts and calling them explicitly is that we avoid using the implicit dependency of a shell. It is possible for that shell to be compromised in which case you are exposed to a bad MITM attack where you *must* pass in the entire environment that may contain secrets or data an attacker is after. Other libraries that offer the convenience of a string often end up using a shell rather than deal with the parsing. On the environment front, most of the time when you do use a shell, you often need to inherit many of the parent process values. Things like the PATH are often necessary as the underlying shell will need to find other programs, which again, offers some avenues for attack. For example, a programmer when calling a command (I know b/c I have been this programmer before!) realizes the PATH needs to exist so rather than calling the command with explicit env vars, I just set env vars in my program with `os.Setenv`. In this case, I think the ability to manage env vars in a `map[string]string` should be helpful because you have a better data structure for validating things over time and testing them. As for the expansion aspect you mention, you're making an assumption that `echo $VAR` would get expanded into a pipe. That is not the case. The `$VAR` would just be repalced. Pipes are not added, but simply supported in a command. Finally, the point about letting secret env vars escape is something that is difficult in all libraries. I try to make it easier to avoid that by using a `map[string]string`. You could set up blacklisted names that will protect those values from the output pretty easily that doesn't have to rely on regexes and `[]string`. I will also mention that the attacks you mention are based on the opportunity of exposing directly the input to the commands. I think in any scenario you will need to do extra work to make sure that is safe, regardless of the library that will be executing things. While I'd love to try to make that safer for everyone, the best I can hope is to make it easier to be secure, which I've done by skipping shells and allowing a better data structure for managing the environment. Thanks again for the feedback and I hope that clarifies my assumptions more and how to use the library securely!
go allows us to access low level things but when we need some quick hacks, it's really inconvenient 
We already have this s… Well, I mean, stuff. https://github.com/lafikl/fluent and https://github.com/GiterLab/urllib — off the top of my mind. 
Can you give some examples? I'm not trying to be a dick, I'm genuinely curious. I've been using Go since 1.2, so my perspective on what is easy/pain-in-the-ass is a little skewed. 
Is it though?
glad you ask. can you show me how you send a GET and POST requests. i can will try to explain on that then. ps: i willing to explain for the people who really want to know about the code rather than about the "pain in the a...", like the other comments
&gt; I feel like you missed the whole point of the article. "Hidden complexity" is not a useful term in discussions. It's entirely possible that I didn't explain my opinion very well. My problem with the Rust code is that there's hidden loops in the code. I'd much rather write an explicit for loop myself. But in the end this is just my opinion. We don't have to agree. &gt; If you were doing string addition in a loop, this would have terrible performance. Have you actually tried to benchmark that? [You might be surprised at the result](https://syslog.ravelin.com/bytes-buffer-i-thought-you-were-my-friend-4148fd001229). :) &gt; "Hidden complexity!!!" you shout... Who's shouting? &gt; Even Rob Pike himself has proposed for the standard int type in Go to be arbitrary precision. Is that not hidden complexity? This is a much different case than hiding for loops behind filter functions. &gt; just like it's *obvious* to any knowledgeable Go programmer that adding strings in a loop is a bad idea. Again... ehm. P.S Hi cmov! Thank you for contributing so much into making Go more and more popular. Keep up the good work little buddy! P.S2 Hi to the rest of the circle jerkers! lol no generics!
&gt; can you show me how you send a GET and POST requests. First few lines in https://golang.org/pkg/net/http/ for simple cases, `http.NewRequest` for the rest.
quoting from the article: &gt; It turns out the compiler spots string additions and passes them to this little function So the compiler has *special cased* this exact scenario. How is that **not** hidden complexity? 
&gt; But in the end this is just my opinion. We don't have to agree. Agreed. I can't argue with this line of reasoning. I believe a filter function is *very* clear and obvious, but whatever. quoting from the article: &gt; It turns out the compiler spots string additions and passes them to this little function So the compiler has *special cased* this exact scenario. How is that **not** hidden complexity? &gt; This is a much different case than hiding for loops behind filter functions. It may be different, but it isn't better or worse, unless you want to elaborate on why you feel that way. Personally, I love the idea of having the default integer type be arbitrary precision, and I'm super excited to see if that happens in Go 2. I wish Rust would offer a similar thing. I actually use Go for my full time job. I also really enjoy using Rust. Have you ever *actually* given Rust an honest try? You talked about wanting to try Rust even less in your highest-level post in this thread... but I've been around /r/golang for a reasonably long time, and I know who you are. You seem to love Go so much that to me it almost feels like your statement was just an excuse to bash Rust, not an actual sincere statement of interest in trying Rust.
actually, this is hilarious. Have you looked at [the source code for concatstrings?](https://golang.org/src/runtime/string.go?s=625:675#L10) It literally has a for loop. So, when you're adding multiple strings together on the same line... *dramatic drumroll* there's a hidden for loop!
With ``http.Get`` or ``http.Post`` it use ``net/http`` default client which has no timeout. I read the it's default transport also it has some limitation, you can follow by the link below, remember to check the comments https://medium.com/@nate510/don-t-use-go-s-default-http-client-4804cb19f779 Same with ``http#NewRequest`` if you use the default client. Most of the ``http.Request`` properties and methods is for server side that cause alot of misleading. such as: * when you want to set the client cookies. you cant use the ``Request#Cookie`` by the name it set the request cookie only(this cookie is not saved in the cookie jar for the following requests/session). to really to do it you need to create a custom ``http.Client`` with the cookie jar and use the ``Jar#SetCookies`` * how to remove a cookie in the cookie jar? you can read my code * do you know that golang doesn't reuse the connection if you send a request by never close it? * for POST requests if you set the body/data with ``Request.Form``, ``PostForm`` or ``MultipartForm`` all is wrong. the only way you can do is set the ``Request.Body`` which is a reader * some more if i have more time :D
&gt; So the compiler has special cased this exact scenario. How is that not hidden complexity? It's much more natural to concatenate strings using the "standard" method than needing to be "knowledgeable" enough to know implementation details that can lead to premature optimization. &gt; I believe a filter function is very clear and obvious Sure one filter function on its own is. How about many of them chained together? As always the real problem appears at scale for which Go was designed for. &gt; It may be different, but it isn't better or worse, unless you want to elaborate on why you feel that way. We won't know if it's better or worse till it is implemented and see it in practice. As to why I feel it is different, the best way I can explain it is to think of code at scale where features can easily be abused unintentionally or not. Some examples: * compiler error on unused variables = good * ternary operators (also chainable) = bad
&gt; Sure one filter function on its own is. How about many of them chained together? As always the real problem appears at scale for which Go was designed for. If there are multiple filter functions chained together, it will do the same amount of work as if you have a for loop that has to manually check for multiple filter conditions itself. If you only need a certain set of elements... you only need that set of elements. Whether you have the filter function or not, you're going to have to do those conditional checks. The Rust compiler will be inlining everything heavily, so you won't have additional overhead from function calls or anything. Chained filter functions will scale just fine. There won't be any "accidental quadratic complexity".
pls follow here https://www.reddit.com/r/golang/comments/7mnqlz/comment/drvashc
pls follow here https://www.reddit.com/r/golang/comments/7mnqlz/comment/drvashc
what is something new? typical programmer uses libraries without knowing how it works
A screenshot would be swell!
My bad. I added a simple screenshot to github with the current weather condition icon and the information that appears when your mouse is hovering the icon
thanks for those packages. how about mine?
yes it is xD
&gt; My problem with the Rust code is that there's hidden loops in the code. That Rust code only makes one pass over the string: the `for` loop is the *only* loop in there. (I don't want to mislead you: certainly, there are iterator methods that have to run the iterator, like `sum` or `collect` or `fold` and they are idiomatic. But methods like `.map` and `.filter` that don't need to run the iterator don't run it.)
No reply, /u/shovelpost ? Sadness.
&gt; If there are multiple filter functions chained together, it will do the same amount of work as if you have a for loop that has to manually check for multiple filter conditions itself. &gt; If you only need a certain set of elements... you only need that set of elements. Whether you have the filter function or not, you're going to have to do those conditional checks. &gt; The Rust compiler will be inlining everything heavily, so you *won't even* have additional overhead from function calls or anything. Chained filter functions will scale just fine. There won't be any "accidental quadratic complexity". Honestly the issue goes to much more depth than just hidden loops and chainable functions. There are also issues of simplicity, readability, maintenability but those are quite hard to quantify and can occasionally be subjective. It is the combination of features (or lack of) that give a unique flavor to each language. Rust is a very different language than Go, designed for a different problem domain. In Rust filter functions work because it supports parametric polymorphism which adds significant complexity to the language and its tooling. For a language like Rust, that is designed to write browser engines, the benefits of having this feature most likely outweigh the costs. I don't wish to get into a discussion if this feature is a good fit for Go or not. But right now, Go doesn't have it. One of the effects is that we need to write simple for loops. There is an undeniable minimalism to that which I tend to prefer. Reading the article, going through the Rust code and reading some of the standard Rust documentation in order to understand the code, made me appreciate the simplicity of Go even more. This is what I felt when I read the article and that's what I tried to express even if I did it poorly. That is all.
This is a comment I can agree with.
I've updated the code to be much cleaner now
Very good question. Any chance you could look through and see if there are interesting/important features in those packages that haven't made it into yours? Any techniques in those that are particularly different from your and that yours might benefit from adopting?
&gt; Thanks for taking a look and providing some feedback. First off, you don't have to use a string. You can just as easily provide the list of commands. The procs.Process in the version I reviewed was a structure, I don't think what you showed here would compile. &gt; Regarding security, this is actually something I've thought about. I'll share my thoughts with the caveat I'm not an expert have consulted experts and found my conclusions to be reasonable. &gt; &gt; The reason for parsing the command into parts and calling them explicitly is that we avoid using the implicit dependency of a shell. It is possible for that shell to be compromised in which case you are exposed to a bad MITM attack where you must pass in the entire environment that may contain secrets or data an attacker is after. Other libraries that offer the convenience of a string often end up using a shell rather than deal with the parsing. Perhaps some of the feedback from the security experts you are referring to here was lost in translation, but what you are saying here makes no sense. If your users shell is compromised it is already game any modern Linux distribution will only allow wheel to modify any binary in bin/sbin. Even your default shell may not be changed unless it was you or wheel. If someone has access as your user they can simply see the commands you are executing and replace them with something nefarious. Now even if this was a risk someone felt they needed to consider, you are adding FAR MORE risk by implementing the POSIX Shell Command Language specification to simply support piping. When it would be FAR easier and safer to simply use an API like I already showed you and only have to follow the relatively simple semantics of POSIX pipelines. I.E.: procs.Pipe( procs.New(`echo`, `one`, `two`), procs.New(`grep`, `one`) ) &gt; As for the expansion aspect you mention, you're making an assumption that echo $VAR would get expanded into a pipe. That is not the case. The $VAR would just be repalced. Pipes are not added, but simply supported in a command. That is the case- I do not assume things nor do I make assertions without validating my claims before hand, you should take a hint from this and write tests before you attempt to discredit assertions. Here is proof of you being mistaken: // os.Setenv(`VAR1`, `FOO | dormcmd`) // p := procs.NewProcess("echo ${VAR1}") // fmt.Println(p.Run()) // exec: "dormcmd": executable file not found in $PATH So- based on the above it is safe to say the environment is unsafely parsed. Proving your statement **The $VAR would just be repalced. Pipes are not added, but simply supported in a command.** to be incorrect. &gt; I will also mention that the attacks you mention are based on the opportunity of exposing directly the input to the commands. If you want to take the stance that your library expects all input to be trusted including environment variables, the command string, even if properly escaped while also being subject to variable interpolation attacks as well that's your prerogative. But I do not agree with making no mention of such an extreme, unconventional position in a security sensitive context in any of your documentation, examples or blog post. Honestly it really seems like there was little thought put into security, which is fine, that is why I posted. I just think it's a waste of both of our time that you chose to form baseless justification and unverified assertions against my claims instead of acknowledging them and moving on. It would have been eloquent and natural for you and I wouldn't have had to waste time defending my audit of your code. Anyways I have nothing else to add good luck with your project.
For piping, I like gopkg.in/pipe.v2
The replacement for not using the default client is to instantiate your own client and call functions on that, which resolves most of your issues.
my issues are not only about the client. it’s also about the cookies, headers etc everything about http request. i can show you one of them, do you how to remove a specific cookie from the jar?
Yes, that's the one 
Well, I always set an HTTP client for each service which requires it. We build in a very modular fashion, so all various components of a system is it's own sub-service. Within the struct of said service will contain an HTTP client. If cookies are needed (for logins to external services), we implement the cookie jar in the same manner. 
**Due to popular request: Enable piping to another process! \ö/** [v1.2.2](https://github.com/eliukblau/pixterm/releases/tag/v1.2.2)
This is great! Could you elaborate on: &gt; Hashers based on bcrypt are not implemented because golang.org/x/crypto/bcrypt is not yet compatible with Python's bcrypt. 
Please can we not have new codebases that use `md5` or `sha1` on passwords? I know there's legacy stuff out there, but let's not make the problem worse.
The `return bytes.Equal()` should probably be replaced by [`return subtle. ConstantTimeCompare()`](https://golang.org/pkg/crypto/subtle/#ConstantTimeCompare). The reason for this is that comparing `aaaaaaaa` with `axcbvxcb` will be faster than comparing `aaaaaaaa` with `aaaaaaab`, as in the first case `bytes.Equal()` will bail out after the first match, whereas in the second case it won't bail out until the eight characters. The difference may seem insignificant, but it turns out that if you try this enough time you can actually guess characters.
Found this awesome WIP terminal GUI for Kubernetes. Seems to be unfinished but still a great contribution!
[removed]
The naming of your APIs looks like shit and doesn't make logical sense. 
I'm not sure exactly what you're doing because I haven't seen your code, but does [this stackoverflow](https://stackoverflow.com/questions/20890850/why-is-a-invalid-indirect) represent your problem (and solve it)?
Hey all, I'm the author of this repo, happy to answer any questions! Writing `kubectl get pods -n kube-system` a thousand times got me thinking of a more intuitive solution to Kubernetes management. The repo is still in its infancy, and I wrote most of it over the Christmas break. It took a few refactors to get the state management to be satisfactory. It now works with a redux-style state flow with actions, reducers and stateless components (this might be a good topic for a blog post in the future!. Contributions are welcome! There's still a lot of work to be done, supporting more resources, and more detailed information. 
Make sure that you're using `&amp;` and not `*` to get the pointer of your struct. https://play.golang.org/p/7342qnxZeHS
Sorry if it sounds like I'm dismissive. That was not my intention. I also didn't get a chance to read through my response very closely. My example I posted should have been: p := procs.Process{ Cmds: []*exec.Cmd{ exec.Command("echo", "foo"), exec.Command("grep", "foo"), } } Here you can build the commands using the model you're more accustomed to. You can see examples of this in the tests. My point regarding the shell access probably wasn't clear as well. If your program is meant to support more complex commands, your options are either to use a shell and treat the input as a script, or do a bunch of work to parse and ensure the input is safe according to your use case. My understanding is that by depending on a shell, you create an implicit dependency on the upstream system, regardless of the care the programmer took in ensuring the safety of the script. For example, if a developer was building a docker container on an untrusted network that managed to pull in a bad version of a base image where the shell was compromised. Therefore, procs avoids using a shell while supporting more complex commands. All that said, I'm not going to argue that your points are invalid in the slightest. There is nothing I or anyone else can do to force programmers from taking bad input and using it blindly, so I didn't try. My use cases are for supporting reasonably safe input from known sources and not to handle arbitrary input. My example of using the knife command from Chef is a good example where the commands already require a trusted client that can impact an entire fleet of machines. I could have implemented the functionality using bash, but then I'd miss out on benefits of a real programming language like Go with it's compiler and tests. Thanks again for the feedback. I think it would be good to better promote the ability to use `exec.Cmd` instances to help avoid some of the issues you mentioned. 
my issues are not only about the client. it’s also about the cookies, headers etc everything about http request. i can show you one of them, do you how to remove a specific cookie from the jar?
[removed]
*The Go type system for newcomers?* Go doesn't really have a type system folks. Good bye and see you next time.
&gt; Go Experience Reports are waiting for user input to see what kind of use cases could have helped the Go users if Go had generics. I’m just lost now. This is almost like saying: “We don’t see a benefit of generics in typed languages yet”.
That is an unconstructive lie and no way to have reasonable discourse.
&gt;This is similar in principle to the concept of ‘boxing’ in other languages, where we can use a parent type (type ‘Object’ for example in Java) to represent all child types, then figure out at runtime how to get the child from parent. This typically comes with some price in performance. Generics, on the hand, don’t work this way. For generics, the type ‘conversion’ happens at compile time, and has no visible overheads at runtime. That's actually not what happens in Java. Generics (mostly) only provide compile time type safety and are translated into untyped Objects. Also generic methods over primitive types are boxing into Object in Java. Working with interface{} in Go is almost exactly the same as working directly with Object in Java. No one wants that. 
This claim has been refuted over and over again. There is a difference between "we don't see any benefit" and "we are unsure which benefits are most important". There are many different flavors of generics with very different benefits and it would be super-duper constructive if the proponents of generics would start listening to the designers and start talking about what flavor they want.
&gt; Don't follow your dream, follow my github. You must be trolling.
yes it's the only way but they only give you ``#Cookies`` and ``#SetCookies``. i solved the remove a cookie. i just doubt if anyone else is struggling with it like me before with their provided stdlib
I liked how the article is explaining it in the simplest way. A minor issue is with these lines: &gt; The mystruct type becomes automatically a child of the myinterface interface &gt; However, since mystruct is a child of myinterface While this makes sense from the perspective of a Java developer which I assume is the intended audience, I am not entirely sure that this is a technically correct term in Go. A more appropriate term would be "satisfies the myinterface". &gt; Modern Golang Programming Also I don't know if this is a real book or not but please don't write the language name wrong in the title of your book. :)
Thanks for your work - it looks interesting! Are there any screenshots of the GUI in action? 
Thanks for the feedback.You right, the language may need some tweaking. I put conversion between quotes originally to indicate that this is more of a metaphor but now looking at it, I can see how that this may added confusion
Thanks for the feedback. Yes, you are right, I was trying to explain it in a way that would make sense to a Java developer. For video course name, I typically use 'Golang' instead of Go because it is more SEO friendly. Most Go courses try to place the word in the title as much as possible or else the course becomes almost unsearchable for the intended audience
Sure, there is a screenshot in the readme! If you'd like more just let me know :)
and what are you waiting for lol
You can't hash passwords with it, just check existing passwords.
In recent years Go has gained a lot of interest amongst the mobile app developer community owing to its type safety, easy refactoring, speed and easy deployment capabilities. We bring to you some interesting information about how you can go about building fast applications with Golang with this blog.
&gt; I typically use 'Golang' instead of Go because it is more SEO friendly. You should not write an incorrect word for SEO reasons. You can use meta tags (keywords, description etc.) for that. Quoting the [MDN docs](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML): &gt; Specifying a description that includes keywords relating to the content of your page is useful as it has the potential to make your page appear higher in relevant searches performed in search engines (such activities are termed Search Engine Optimization, or SEO.) &gt; 
Until enough people request the make password function, as mentioned in the README.
This is just useless spam
Thanks for your work! Which Terminal GUI is this in the Readme? It looks fancy
nice, will try this in the new year. "k" is a bit short for a name, especially seen as single letters are generally used as aliases, e.g. I have kubectl aliased as k and wouldn't really want to change that. Of course I can always alias your k as something else but my suggestion would be to name your program something like kui for e.g. . I'm not sure about everything it can do but I doubt this would completely replace kubectl, so when I still need to use kubectl I would want to use k. 3 letters instead of 1 is IMO fine for opening a long running program.
It uses [gocui](https://github.com/jroimartin/gocui). I went through a huge bunch of them and I settled on gocui because of its simplicity and also great documentation.
Which doesn't mean it will include md5?
Great point! My `kubectl` is aliased to `k` as well. Just shows how often you have to type it out and that its frustrating enough that people have to alias it! I'll rename it to `kk`. This will be a bit of busy work but I think it'll be worth it. 
Hopefully not, if enough people advise against it =)
Thanks for your response! I was referring to the Terminal Application. This one: https://github.com/nii236/k/blob/master/static/screenshot.png
For checking existing passwords more hashers are better, but for creating new passwords I consider if I should give the choice at all. Most of the Django apps will work with `pbkdf2_sha256`. What do you think?
Oh right it's just iTerm on MacOS :) On Linux I just use gnome-terminal.
&gt; Also, C++ essentially has generics so, google being full of C++ coders is not necessarily a good thing for being able to keep Go idioms. Go has idioms? As far as I was aware until now the advice was just "spell everything out or use the empty interface"... 
This is a good point. I'm not sure how visible is timing attack on pbkdf2 password (which is using thousands of iterations) when user doesn't even have access to his salt. I will add benchmarks to tests and see how much slower `ConstantTimeCompare()` can be.
Yeah, `pbkdf2_sha256` is fine for password hashing, but raw cryptographic hashing functions like `md5`, `sha-1`, and `sha-256` aren't. Allowing them for checking existing passwords (as you have here) is fine, but only so that people can migrate to newer, more secure algorithms. Therefore I'd strongly recommend only providing secure algorithms in the make password functions. This would be useful for checking an existing password (which might be stored insecurely if the user hasn't signed in for a long time), then rehashing it with a secure algorithm if necessarily.
Gah, sorry I missed that! (I’m on mobile). Thanks again :)
&gt;Go is considered as an object-oriented language even though it lacks type hierarchy. It has an unconventional type system. Um, no
Just a quick FYI. When using ConstantTimeCompare() check that the slices are of equal length before the comparison. It's in the "subtle" package for a reason 😀
https://github.com/marcusolsson/tui-go/blob/master/README.md I was curious as well 
&gt;Those condescending edits. Don't use sarcasm, it's hidden complexity. Learn Lojban, while you're at it, so that your language usage doesn't have hidden complexity.
I don't intend to discourage but speaking for myself, I find packages like these being discussed useless (for me). There are two reasons I can put forward: - For throw-away code they don't buy much because they save like maybe 5 to 10 LOC per HTTP "call". No, really, `resp, err := http.Get("http://example.com/path"); if err != nil { handle(err); }; defer resp.Body.Close(); // now read from resp.Body` — I'm not sure what's hard about this. - For production code, such libraries are useless *completely* because there you typically have sophisticated policies to deal in different ways with accessing different resources etc. I'm afraid you might (or might not!) have failed victim of the well-known fallacy of dearly needing something you've got accustomed while working with your "previous"/most used language / environment. Please consider watching this short fun video: [Blake Miserany - "Three fallacies of dependencies"](https://www.youtube.com/watch?v=yi5A3cK1LNA). There, he debunks the problem quite nicely and in entertaining fashion :-)
The article didn't do that. 
Uhm, most definitely yes. See the articles and talks about this. Please... read before being a condescending, uninformed, person.
What is `dep`? Would be nice to list it as a dependency somewhere in README with a reference to installation instructions.
Hash returned by Django's `make_password` looks like this: In [2]: make_password('secret', hasher='bcrypt') Out[2]: u'bcrypt$$2b$12$Szy1bA/F1Iro2jMQHkzbjO61ecWIhKvuzjwWgautfsoEo04b8pvW.' I think that `$2b$` is not handled by `golang.org/x/crypto/bcrypt` because `bcrypt.CompareHashAndPassword()` always returns an error, not even `HashVersionTooNewError`, and `bcrypt.GenerateFromPassword()` generates hashes starting with `$2**a**$`.
lol wrong quote lol cercle jerker
Looks like the standard macOS terminal.app using the systemwide darkmode...
I assume he meant to reply here: https://www.reddit.com/r/golang/comments/7mrcli/go_kubernetes_terminal_gui/drwkec3/
Woops sorry, was on mobile!
Thanks for your feedback! [Dep](https://github.com/golang/dep) is the official tool for dependency management.
I've seen people claim that C++ isn't OO. :) Hahaha... but yeah, there are a lot of people that think an OO language means something very strict about everything being objects, and objects are a mystical concept that they know it when they see it, but the word class is probably involved.
As per, feedback massively welcome :) 
*Actually I made up the term "object-oriented", and I can tell you I did not have C++ in mind.* ~ Alan Kay
My point is more... &gt; I'm sorry that I long ago coined the term "objects" for this topic because it gets many people to focus on the lesser idea. The big idea is "messaging" &gt; Alan Kay
I can assure you nothing will come out of these "experience reports". It's an idea parking.
I would like the flavor found in F# 
I mean you can approximate most OO ideas well enough that you can arguably say it supports OO style programming to some degree, but someone very used to the mechanisms available in Java, C++, or C#, which would be what most (not all!) modern programmers consider to be OOP, would come to Go and not consider it to be the same at all. I am not saying it is a bad thing that Go uses interfaces and struct embedding to approximate OO style, I am just saying it is sufficiently different that a rational person could declare that "go is not considered an OO language" A rational person could also declare the opposite. Such is the flexibility and vagueness of human language. 
and he didn't have Go in mind either! 
Sure, I agree with this. I just don't think that claiming "C++ is not OO" is particularly controversial/funny. The C++ model is quite far from the original concept as well. Now that I think of it, I might have read your first remark wrong the first time, though ;-).
I have read the description of the project (had to click through to the README) but completely failed to grasp its intended purpose. Well, except for that it aims to be a trimmed-down `curl`. If yes, I think we already have non-trimmed-down `curl`, so what are the benefits?
&gt; I mean you can approximate most OO ideas well enough that you can arguably say it supports OO style programming to some degree, but someone very used to the mechanisms available in Java, C++, or C#, which would be what most (not all!) modern programmers consider to be OOP, would come to Go and not consider it to be the same at all. Just because people are used to a single way to do something, it doesn't mean that there's only way to do it. &gt; I am not saying it is a bad thing that Go uses interfaces and struct embedding to approximate OO style Incorrect, the type system of Go as a whole, not just structs embedding and interfaces. &gt; I am just saying it is sufficiently different that a rational person could declare that "go is not considered an OO language" A rational person would do the exact opposite because a rational person would document itself and would be capable of reasoning, which clearly it's not the case. &gt; A rational person could also declare the opposite. Such is the flexibility and vagueness of human language. I'm not sure you understand what a rational person means. There is nothing vague about the human language in this case. Your knowledge of the subject is clearly flawed. OOP is a paradigm defines a set of properties which are met by Go. There's no place for interpretation here. There's no specification on how those properties need to be achieved.
&gt; I can assure you nothing will come out of these "experience reports". It's an idea parking. Based on what evidence?
Very good question; thank you for asking. A primary benefit is one of hindsight. kurly has the luxury of being a couple of decades newer than curl and as such has taken advantage of two core things. 1) It's written in a modern safer language, so hopefully won't exhibit myriad memory safety security issues that curl is plagued with. 2) Doesn't need to support as many legacy features such as FTP, Gopher, etc, that no one uses anymore. This reduces code complexity and of course less complexity is implicitly good. As stated on the README, this is an alternative to, not a replacement for, curl. :-)
Based on the evidence that Ian Lance Taylor already wrote a significant document about generics and nothing came out of this.
[removed]
And because you've deleted your comment to my question, here it is again, for posterity, as I've spent time on replying to it. &gt; Based on the evidence that Ian Lance Taylor already wrote a significant document about generics and nothing came out of this. Ian's efforts help to inform any future option with regards to this feature. Not only it shows they care about that feature in particular, but it shows how proper engineering is done. The fact that there's no specific solution yet and they are looking at their user base to understand how Go is used outside of Google, what features people need and how they will be used, should be something that motivates everyone to help them. Instead it seems you'd rather have something half-baked and that's against what Go's core principles are: being an engineering effort rather than a theoretical or a let's-support-all-the-things one.
&gt; being an engineering effort rather than a theoretical or a let's-support-all-the-things one. propaganda.
I just added `MakePassword`. It's using `pbkdf2_sha256` by default and can be configured though global variable. Unsalted hashers are not implemented.
&gt; propaganda Of what? A stated fact? A reality? &gt; But you know that already, you will never bother to write any, and so shouldn't anybody. What if I'm happy already with the language or what others wrote already? What if my way to contribute to the language doesn't include me writing an experience report because I don't have something to complain about? Have you ever wrote about your Go experience and what stops you from being even more productive with it and the Go Team dismissed or ignored it? 
Don't bother.
when I try this, I get the following error: cannot use &amp;s1 (type **StructType) as type *StructType in argument to anotherFunc 
Use the playground to show your exact problem, and helping you will be a lot easier than trying to guess the source code that produced the given error.
Perhaps I'm basing the funny part on my own experience of having a certification in object-oriented programming specifically with the classes taught all in C++. I think of C++ as being the most common language to teach object-oriented programming. However, it's probably actually Java or C#. Regardless, I meant my original comment more as casual banter than anything especially well calculated. 😊
Thank you.
I'd say that if you consider this whole thread holistically, it demonstrates ddooo's point in a way you can miss if you just consider each point individually. Yes, with the standard library, you _can_do this on two lines and you _can_ do that in four lines and you _can_ do the other thing with just a couple dozen lines of a struct to implement an interface, but the sum of these things gets to be something you might want to stick in a library if you keep doing the same things over and over. I haven't published it because it's nothing special, but I have a wrapper around the standard library too, optimised for interacting with JSON APIs, because even though the functions are just about 20 lines each, it's nice to not have to implement them every time, you know? The standard library is as generic as it is for good reason, and there is nothing wrong with wrapping specific use cases around it.
Hi everyone! Another big release with tons of improvements and fixes is released. Checkout the full changelog here: https://github.com/fatih/vim-go/blob/master/CHANGELOG.md#116---december-29-2017 As always many thanks for all the contributors and you all for using vim-go. Don't hesitate to give feedback and open an issue if you encounter something :)
That's what is called "bite and retreat tactics".
&gt; Don't bother. So what? You are happy to just have baseless statements and detract people from participating but when asked to support your statements with facts you're just leaving the conversation? This is really mature.
[This](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4/) is a summary of all (serious) proposals for generics put before the community maintained by a community member. I'd say that's a must read for anyone who seriously thinks they know for sure what generics are and how they have to be implemented. As an aside, [this](https://medium.com/@sameer_74231/go-experience-report-for-generics-google-metrics-api-b019d597aaa4) is one of those experience reports on the case where the generics are needed.
I'll type it up, back in a bit
thanks
https://play.golang.org/p/JNHQS4yBlfX
Why? Please follow the requested format of an experience report when answering, so that the language designers can decide how to best integrate the required features into Go. Go is not F#, so a priori it won't be possible to just take what they do, as it will be integrated with other parts of the language.
Oh, thanks! I am used to iTerm so I forgot the Terminal.app
Funny to see all the top-level comments downvoted below threshold. I expect mine to be as well, since this seems to be a polarizing article. But whatever, here are my 2 cents: This is a pretty poorly written piece. Most of it focuses on what Go *doesn't have*, and what *not to do*. What is a newcomer supposed to do with sentences like "If you are introducing an interface, only to provide a noop implementation of your concrete type, don’t do it."? I tried to put myself in the mindset I had when I was learning Go, and the sections on nil and interfaces would certainly not have helped me with the most important gotchas like typed nils.
When you use "new" you create a pointer to the struct created. So when you do &amp;thingy you are passing a **Thingy and not a *Thingy. You should pass thingy as is or declare it as: var thingy Thingy 
So by using the new keyword am I creating a new struct object and ALSO a pointer to it at the same time? 
Title is quite misleading and Go for mobile developers? Do you know what go is? 
&gt;OOP is a paradigm defines a set of properties which are met by Go. The official Go Language book asserts that there is no agreed upon definition of what OOP is. Perhaps you disagree, and can direct your obnoxious rhetoric and Donovan and Kernighan instead of me. &gt;There's no specification on how those properties need to be achieved. Given this interpretation, all turing complete languages are OOP languages. It is not so difficult to create object oriented designs even in ANSI C. 
Awesome work! I also get excited when I see a new release :)
why nats over nsq? I've found the majority of event driven programs require delivery guarantees that NATS doesn't provide.
`new` returns a pointer to a zero-valued struct. 
I love your work!! Thank you so much. Happy New year!!!
&gt; Working with interface{} in Go is almost exactly the same as working directly with Object in Java. I'm interested by your use of *almost*, are you hedging, are you talking about `Object` having a bunch of its own methods, or are you hinting at something else?
There are some subtle differences: A interface{} can have type information with a nil value (if a variable of type Object in Java is null, there is no type information). Example`var x error; var y interface{} = x;`. So a golang interface{} is more like a `class Interface&lt;T&gt; { Class&lt;T&gt; type; T value; }` in java. Also, i am not sure how small values like `int32` are represented in go in interfaces - is go using something like tagged pointers for that or is an int32 allocated on the heap and referenced in the interface?
cool. ill check this out.
Thank you :)
Thanks for all your work on vim-go! It makes for a great development experience.
The primary driver here being the ability to perform periodic checks on your dependencies in the _background_ AND expose that information via `http://../status`. A terse example of what this looks like in practice: https://github.com/InVisionApp/go-health/blob/master/examples/simple-http-server/simple-http-server.go Note: If you utilize a DAL/DAO-like pattern, it would be trivial to instrument it to make use of async checks.
The correct answer that would help OP out should be: new() already produces a pointer to the struct. This means, when you're passing '&amp;variable', you're actually creating a pointer to a pointer. To make your example work, you should just remove '&amp;', or declare the original variable with something like `var := Struct{}`. FTFY
&gt; There are some subtle differences: A interface{} can have type information with a nil value (if a variable of type Object in Java is null, there is no type information). That's not true, all instances in Java have a class pointer somewhere, otherwise neither `instanceof` nor `ClassCastException` would make much sense. &gt; Also, i am not sure how small values like int32 are represented in go in interfaces - is go using something like tagged pointers for that or is an int32 allocated on the heap and referenced in the interface? AFAIK Go uses fat pointers rather than tagged pointers, I'm not sure how to dump the (on-stack) representation of an interface local, but IIRC it bundles a type pointer and the value. I'd expect an int32 cast to an `interface{}` would be a pointer to the `int32` type with the immediate value, whereas an `*int32` in the same situation would be a pointer to a different `*int32` type with the pointer as the value.
Which completion plugin do you folks use and which works well with vim-go? Currently I use YouCompleteMe, but I am not sure if I am happy with it. It is fast, but it annoys me that the parameter list disappears as soon as I start typing parameters. 
Yeah, Java and C++ seem to be most common choices for such classes, which I think is hardly the best thing to do. Back when I was studying CS, my OOP classes were a mixture of Java, C#, Python and Smalltalk, meant mostly to show what OOP is and how different languages approach it. If one wanted to pursue any language in particular, there were separate classes for that. *Oh, well* ;-).
I just use the default omnicomplete, which interfaces with `gocode` and works pretty well IMHO. I don't know what the advantage of all these completion plugins are? It adds a lot of complexity (I see a lot of questions about them) without a clear advantage?
tcrypt posted their response before OP gave their code, and so had to guess what they were doing, hence didn't say anything about `new`.
that auth0 article is from 2015
mucomplete
Huh, so you can't modify the strings underlying array even after you casted it to slice using unsafe magic. I wonder how this works - does compiler inserts some sort of checks? Or memory is guarded? 
Would have nice to see a mention of the oddity of typed Nils, and the potential confusion that can result
Thank you for your hard work.
I'm having trouble getting file watching to work. I've defined the pattern and prep command, but it doesn't seem to trigger on file change. Have you had similar problems?
I checked with `gdb` and it looks like the data of the string goes in the data section of memory, which is read-only. So it's a memory protection thing.
Most likely it's because those are string literals (i.e. strings defined in program itself as opposed to strings constructed at runtime) and the compiler puts them in read-only segment of executable. Writing to such memory will generate sigsev. Per Go spec strings are immutable and this makes it safe to de-duplicate strings i.e. if you have "foo" string defined twice in different parts of the program, compiler can detect that and only have a single "foo" string that's pointed by 2 different variables. C++ compilers have similar capabilities. E.g. /GF option for Visual Studio compiler does the same thing (https://docs.microsoft.com/en-us/cpp/build/reference/gf-eliminate-duplicate-strings). 
I personally prefer vim-go more than IntelliJ’s Goland. Thanks!
I only read the main post and your comment, wasn’t aware op added code later on.
FWIW, [unbounded queue using channels](https://play.golang.org/p/Fgsbmj3AtF-).
&gt; The official Go Language book It's one of the books about Go, all of them being official. &gt; Perhaps you disagree, and can direct your obnoxious rhetoric and Donovan and Kernighan instead of me. Why? Neither of them are in this conversation. &gt; Given this interpretation, all turing complete languages are OOP languages. Except not all Turing complete languages are OO capable as well.
Here is a package I'm working on: https://github.com/256dpi/gomqtt. Maybe it serves as an inspiration for some components.
Entirely down to preference really. I just wanted to get the point across that it was easy to switch between any message provider you wish to use. I like NATS, it's fast, it does support guaranteed delivery, sort of: https://nats.io/documentation/faq/#gmd But yeah, you can use NSQ just by changing a couple of lines :) 
A nice simple implementation. However the author mentioned: &gt; shrank when buffer space was not required After a large number of writes, followed by a large number of reads the array backing `q` will not shrink, and will only shrink after append allocates a new backing array on a future write. This is once again an over-optimization ("bring the data"), but something to keep in mind.
"Hyped by Buzzwords - certified to run in any container, as well as PaaS, IaaS, *aaS." YMMD :)
Thank you a lot!!!
hey man, i've been busy these past few weeks. I've made the change for the idiomatic pop, thank you very much i've learned a lot from you :)
I personally always prefer not paying money to paying money.
You can apply for a license to all of their products with an open-source project you contribute to majorly
Starting at about 5:22, she brings up criticisms against Go and talks about how Go largely ignores the last 30 years of language progression. It bothers me that she (or the Go creators rather) can just brush this criticism aside without really defending it. "You just don't understand Go." Look, Go is a technological marvel. I totally get what's going on underneath, and it's impressive. The concurrency model is a big innovation. I don't understand how that then justifies absolutely crippling the syntax. I'm fine with dialing things down; many languages have way too much, but I feel that Go went too far the other direction. It's a _bad_ form of simplicity.
I'm sure Google will figure it out either way. They're pretty smart.
Any of them would be better than the status quo though.
What are the “crippling” issues with Go’s syntax? From a language point of view Go has one obvious flaw: no generics. That can be broadened to say Go should be like Rust and Swift and have Optionals, Result-types, etc. That’s about it. You can maybe also say operator overloading is nice to have but that’s pretty clearly a subjective trade off. Complaints about having to use one brace style versus another strike me as silly. Complaints about using capitalization for exporting vs private are also silly. So one real problem with Go that they’re thinking about for Go 2. How is that “crippled”?
"typed nil" is a misnomer. Either no nil is typed (the identifier "nil" has no type), or all nils are typed (every nil-value has a specific type). The opposite of a "typed nil" would also be an "untyped nil", which is already a term in use (for when the compiler can not infer the type arising from the usage of a nil-identifier) but has nothing to do with what you are talking about. Use "dynamic nil", maybe. Using confusing and plainly wrong terms won't actually resolve any confusion.
Ironically, all these features that people say are "OOP" have nothing to do with Objects. They are about polymorphism and subtyping and you don't need any objects for that. Indeed, from that definition of OOP, Haskell is an Object Oriented language. Object orientation means, that you have objects that contain some data and some associated code, named methods. Go does qualify.
Or you just put os.Exit inside the defer block
Just to highlight a few things... http://yager.io/programming/go.html I am also deeply saddened at how `defer` works. I hope and pray that they add a scope-level compile-time alternative (behavior closer to that of `finally`). &gt; Complaints about having to use one brace style versus another strike me as silly. Complaints about using capitalization for exporting vs private are also silly. The problem is they settled on the wrong brace style. https://vimeo.com/97329157 And using capitalization to mark exportation _is_ a terrible idea. You may think it's silly, but it's just not to many people.
not sure if you read the article.. because that is what they did
It's definitely not a crippling feature it's missing. But one really nice to have for me would be addition of non nillable pointers. Dereferencing a nil pointer is by far my most common cause of production panics. I think I will actually write an experience report on this in the near future. 
&gt; If you feel that Go lost absolutely no power compared to other languages, I'd love to hear it. You keep saying 'X is bad' everywhere you actually mean 'I prefer Y instead of X', so there's little to discuss.
&gt; I'd love to hear it. TBQH, it… doesn't seem that way? Honestly, this thread looks pretty ridiculous to me. It has three people who each bring their own, completely fringe pet peeves as evidence of "if only Go would do this one little thing, it wouldn't be so crippled". Without realizing the dissonance or what that actually means. You say &gt; I'm fine with dialing things down; many languages have way too much, but I feel that Go went too far the other direction. But don't seem to realize that "dialing it down" *implies* (like, in the logical sense) that at least some people will feel like this: &gt; The problem is they settled on the wrong brace style. Like… You seem to be saying a) it is the correct choice to go against some people's taste in the choices made but b) those people *sure as hell* shouldn't be you. It's just… exhausting reading threads like this. It's full of petty, inconsequential complaints which are used to justify the overarching "Go is too crippled" POV. Look, I can make a list of things that I think definitely should be changed in Go 2 (and I think *will* be changed). defer would be on there, sure. The overload of the identifier "nil" too. The scoping of loop variables. Maybe a dozen other things. But they are tiny, inconsequential things that don't actually matter when it comes to evaluating the language. So yes. It means not only am I aware that it doesn't actually matter what they'll do to that. It also means I have trouble taking this kind of criticism actually seriously. Because if you are in a camp, who thinks its a valid argument what "brace-style" Go chose, *there is no progress possible* in the discussion - because satisfying you would mean pissing off just as many people who have the opposite opinion and will be just as petty about it. Threads like this are just… not constructive.
[removed]
The example Go function for returning a new python dictionary leaks the two Cstrings. They get converted into python Unicode but the C strings never get freed. 
Yup exactly. One less reason to use the wrong language name.
First of all, I would like to apologize for the all downvoting you get. People who don't like Go tend to dismiss people and projects who are using Go. Or resort to trolling. Which, unsurprisingly, left a mark on the community, which in turn became a little extreme on defensiveness. Now, setting this aside - the article you linked basically wants Rust version of Go. That's not how things work... Generics is a very handy feature, and many professional Go developers are waiting for it. The problem is - it's hard to fit them into Go "fast compile" model. People were already upset when compile times went up when Go 1.4 (or was it 1.5) released. The generics introduce a lot of work for compiler and linker, so the compilation time will go up. The question is - how to minimize them without losing runtime efficiency. We would also like for generics not to "box" implicitly (like Java do) or lose type information. Again - generics are one of the targets for Go 2. I agree that having some sort of immutability would be nice. I disagree that immutability should be a default choice for Go. Without significantly changing syntax (making it more terse?) and introducing a lot of fundamental methods like map/for_each and so on, into the core language standard library, it would simply look foreign. ADT (and by extend, pattern matching) is a cool thing, but they, unlike generics, is a core of type system. I'm not sure that introducing ADT atm will not make code look inconsistent in future. And unlike mutability and generics, where you can gradually upgrade your code base, the ADT requires a change to thinking. Still, the ability to restrict method argument to the set of types would be a nice and IIRC it was proposed. Nil - that's a hard topic. The thing is - nil is not your Java/C++ null. It's a perfectly valid state, on which methods can operate and produce results. Slices work that way. Channels have some nice features tied to nil(if you are using select) . Map is somewhat inconsistent about it. So I'm not convinced that nil is a bad idea. It's definitely not the best, but it does has some nice properties. Operator overloading is a very dangerous feature. It's handy. It's useful. But it can lead to absolutely unmanageable code. To the language that values simplicity its simply a no go. Defer is not a RAII alternative. Brace style is entirely subjective topic. I think the only thing that matters is consistency. Same goes for capitalization. People also tend to forget that Go limited focus on syntax, has allowed authors and core developers to focus on runtime, standard library, GC and overall language ecosystem. People like to compare Go with Rust, except Rust is built on top of LLVM (or more recently transpiling to C++) and Jemalloc. It done a lot of work for them. Go didn't have that, because LLVM memory model was unsuitable for goroutines back then. It also doesn't have coroutines atm, and the proposed generators are vastly different from goroutines in their principles (read about red and blue functions) and their implementation (M:N threading vs state machine, runtime scheduler). Overall I think that the general principle "pick the tool which fits the task" is a good principle. If Go fits the problem you solve, pick Go. If Haskell fits better - pick Haskell. If Rust fits better - take Rust. There is no reason to limit yourself to one language. 
Can update it - do the C strings need to be assigned first in order to be disposed?
[removed]
Is c-shared working now on windows ? 
The Go brace style -- opening brace for a function on same line -- is a consequence of the rules that allow the omission of semicolons. Putting the opening brace on the next line leads to an insertion of a semicolon after the ) of the function signature, which leads to an compiler error. But honestly this isn't a problem. An argument I never hear about generic programming is that it would lead to a wide set of container libraries that would make it harder to understand Go code. The fact that there are only two containers used in Go code, slices and maps, contributes a lot to the good readability of Go code.
I'm not aware of anyone working on it, and I'm sure when someone starts it will take a few cycles as it's orders of magnitude more complex than Linux and Mac.
I usually just use: ioutil.ReadFile(filename)
Should probably stop reading at "I'm not handling errors", if not there then for sure when you hit "handleFn".
I was responding to someone else who brought up the brace style. It's not one of my primary concerns with Go. &gt; Threads like this are just… not constructive. And I see that you've suffered through this discussion before. So, let me see if I can reframe it at all: I want to like Go. I really do. However, whenever I ask about a particular language feature that exists in a dozen other places, I'm not met with clear answers along the lines of "it causes problems X, Y, and Z". I'm told, "The Go creators are full of wisdom, and frankly you just shouldn't question the decisions they've made." So, the entire discussion is just people talking past each other. I mean, is Microsoft stupid for adding LINQ to C#? Is Java stupid for adding Streams? Lots of languages are adding pattern matching. I'm not saying Go has to add everything under the sun to earn my respect... but why are these kinds of questions met with "heh yeah lots of people say that"?
&gt; First of all, I would like to apologize for the all downvoting you get. People who don't like Go tend to dismiss people and projects who are using Go. Or resort to trolling. Which, unsurprisingly, left a mark on the community, which in turn became a little extreme on defensiveness. Thanx. Apparently, I struck a nerve. I didn't mean to open up old wounds. &gt; Operator overloading is a very dangerous feature. It's handy. It's useful. But it can lead to absolutely unmanageable code. To the language that values simplicity its simply a no go. I hear this said a lot across many communities. I'm sure the abuse happens, but I'm struggling to believe that it happens as much as everyone suggests. It feels like people say it because his/her mentor said it. (I don't mean to discount your personal experience here, if any.) Is operator overloading really even _used_ that much when it's available? I'm not a fan of the logic used against it because it applies equally so to other features. Right now, I'm dealing with a function (in legacy code) called `GetWidget` that does a mountain of _setting_ in the method; is this evidence against allowing programmers to create or name their own functions? That's just my 2 cents on it. &gt; Defer is not a RAII alternative. Then what _is_ it? I'd like to know why the creators thought that function-level unwinding (with added data costs) made sense over scope level guarantees. This basically means I cannot have a for-loop that opens files/sockets that relies on defer. &gt; Brace style is entirely subjective topic. I think the only thing that matters is consistency. Same goes for capitalization. As I mentioned above, I was only responding to it being brought up by someone else. I'm sad that it's sticking to me now. It really isn't my primary concern even if I do strongly disagree with it.
&gt;I'm sad [Here's a picture/gif of a cat,](http://random.cat/i/0oKOv.jpg) hopefully it'll cheer you up :). ___ I am a bot. use !unsubscribetosadcat for me to ignore you.
I prefer having access/control over the hashing function used in Go's map instead of it being locked away in a black box. Do you prefer otherwise? And if so, why?
It would be a nice feature, but I don't think the benefits outweigh the costs to readability, at least as far as I can imagine it being implemented. If you had a proposal for how you would implement it, I could say more.
A function call called GetWidget isn't comparable to operator overloading, where operators have an expected result on the types they work with but overloading would allow for surprising things to happen instead. GetWidget is a function whose operation is chimed in its documentation, which you can look up via its name. Operator overloading requires that you can recognize the types being acted upon as not built in, and that you know what syntax is used for that overloading to look it up. Defer is used the way it is to allow for recovering from panics, which leave their function, for one point.
&gt; Defer is used the way it is to allow for recovering from panics, which leave their function, for one point. Why is function-level deferment the only way to solve that? Panics could still hit scope-level defer blocks.
It sounds like you're suggesting defer and panic are now acting like try/catch and throw? Is that what you're going for?
I'll assume that you are going for a try-catch-finally sort of style. The reason that isn't used in Go is because it moves the thing you want to do further away from the place where you want to do it. You get this: f, err := os.Open(file) if err != nil { defer { ... ... ... } f.Close() } Instead of: f, err := os.Open(file) if err != nil { defer f.Close() ... ... ... } And as your middle section gets longer and longer, this separation of concerns which should not be separated gets worse. 
_Kind_ of. I want the functionality of `finally` but not its _position_. for someLoopThatIntroducesScope { f, err := os.Open(fileN) if err != nil continue // or something defer f.Close() // Do other stuff here without fear of the file being left open each iteration. } Because `defer` is function-level, I now have to live with allocations (I assume) and files being left open longer than they need to be.
It depends on the file. If it's super big or it's going over a socket directly,. I'll stream it. If it's small, your method works fine. If it's a config file, I'll probably stream it since it's silly to allocate a buffer if I'm just going to parse it and throw the buffer away, though it really doesn't matter.
In my opinion the lack of error handling and the "cheating" diminishes the usefulness of this resource. Not using `defer` and only closing the file when an error happens is not a very good advise either. It is usually better to demonstrate proper usage of the language especially for people that happen to be new.
[Posted a few hours ago](https://www.reddit.com/r/golang/comments/7n2p2q/the_why_of_go/).
I had to stop reading after looking at handleFn. 
Hmm... Don't know why the duplicate detection didn't catch it.
interface{}
Since I'm on mobile, I'm going to respond without quoting, so sorry if it bothers you. The thing is - no feature work alone. Operator overloading is not dangerous by itself, but it is dangerous in combination with generics. I've seen beautiful open source code which used this feature to actually hide the underlying complexity. A also saw the abuse of overloading both in OO and daily job projects. It was not pretty. There is also a problem of finding the used method. Depending on generics implementation it goes from hard, to somewhat simple. Defer is a way to call your function at the end of surrounding function scope. Yes it's used for resource release. But it also used for logging, conditional logic, and working with named results. BTW defer f.Close() is actually incorrect - you do not check the return error value, which can result in subtle bugs. 
I don't think you can do this without defer itself creating a new scope. Otherwise when you see a defer, you need to trace back to the scope it started from to understand what it's doing. Functions are a very clear to recognize scope, especially due to gofmt forcing them to be written in the same style. 
Yea you need to store them as variables so that you can use C.free(unsafe.Pointer(...)) on them after they are copied into Unicode objects. https://golang.org/cmd/cgo/#hdr-Go_references_to_C
Last commit was July 18. What makes you link to it now?
&gt; ...whenever I ask about a particular language feature ... I'm told, "The Go creators are full of wisdom, and frankly you just shouldn't question the decisions they've made." *[citation needed]* I haven't heard such a manifestation of fanboyism in a long time; maybe you asked the wrong people...
do C have streams?
Python invokes the Go code in the same process, right? By contrast to invoke Java code from pure C-Python couldn't be done without other processes spinning up, and some form or interprocess communication although STDIN and STDOUT can be co-opted for that purpose.
&gt; I want to like Go. I really do. Why, though? Like, this really seem to be the crux of the matter. There are people who *like* Go, who enjoy the tradeoffs it was designed with and who like and agree with the design goals. And who, thus, are much more accepting of responses like "we agree with the benefits of X, but the cost don't seem to justify it", or "we agree with the benefits of X, but if we add everything that has a benefit, we lose what makes Go the language it is". And then there are the people who *don't* like Go. But want to make it, for some reason or another, more like whatever languages they *do* like. And I don't get why. There already *are* languages they like, shouldn't they rather work on improving *those*? Like, the answer then usually comes down to either a) I like the simple design of Go, but my pet feature is missing (which is internally inconsistent) or b) I like Go toolings/ecosystem/… which is better addressed by working on adding that to the languages you like more. &gt; However, whenever I ask about a particular language feature that exists in a dozen other places, I'm not met with clear answers along the lines of "it causes problems X, Y, and Z" We have very different experiences then, I think. Usually, it is trivially easy to name specific problems, or at least illustrate why they are more complicated than people say they are. Obviously I'm coming from a different side and have thus different confirmation biases than you, but to me, it seems that every single time, someone suggests that $thing would be totally easy, you talk to them about why they are not and in the end they just respond "well, I don't know, what you say makes sense, but $thing still seems to be totally easy and I can't imagine them not being able to figure this out". The pet flamewar - generics - is a perfect example. There is *tons* of material put out about why it's not that simple, what the questions are that need to be decided and what the problems with existing proposals are. And what the team needs to decide how to add them. And yet, the discourse doesn't focus on actually providing that, but instead on perpetuating the myth that the Go team doesn't want generics, doesn't understand generics, denies the benefits of generics or that generics are, like, totes easy. But also, in lots of places, the answer literally just is "it doesn't seem really worth it". *Every addition* has a default-cost, which is pretty high and needs to be overcome. That cost needs to be justified. That is not saying "the Go creators are full of wisdom, and frankly you just shouldn't question the decisions they've made", it is saying "we accept and believe the philosophy behind Go, that there is a tradeoff to every feature, that the language should be small and code sufficiently uniform and understandable and so far, the designers behind Go seem to have been doing a good job of making those tradeoffs". &gt; I mean, is Microsoft stupid for adding LINQ to C#? Is Java stupid for adding Streams? Lots of languages are adding pattern matching. Pattern-matching is a really good example for something, that makes zero sense in Go's type system. Like, not "The Go creators are full of wisdom for not adding them", but "I don't know what you've smoked to choose this example, Go has no sum types, no type constructors and no tuples and it doesn't even make sense to *think* about that for Go". It's also, FWIW, something I would consider uniquely un-Go-like, given that Go, in general, tries to make computation explicit. But more importantly: *Why would Go need that*? Like, "lots of other languages do it" is a bad argument because those languages are… different languages. They have different design goals, different tradeoffs, are different right now. Why can't it be okay for some languages to have a feature, while *also* being a bad choice for other languages? Generics, sum types, linear types, refinement types… are all *great* features - for some languages. "Others are doing it" is only a good argument, if you believe every language should be the same. I disagree with that, strongly. (and FTR: "C# and Java are doing it" is a *particularly* bad argument - while I don't know C#, Java definitely has a place in my heart as "that unreadable overly complicated language that does basically everything wrong you can, if you want me to like you as a language") &gt; why are these kinds of questions met with "heh yeah lots of people say that"? *Some* of these questions are met with that, because these things have been generally recognized as problems that require solving - but can't be solved right now. This is what I meant above. The behavior of defer, I believe, has been generally recognized as a problem, but can't be changed without breaking existing code. The way loop-variables are scoped - definitely a problem. Too many ways to create values - yup, problem. The overloading of `nil` and the confusion around dynamic nils, yes, also a problem. Other things have been recognized as a problem and that we want to solve, but we're not sure how to solve it yet. These problems are what experience reports are for - they help figure out what the pain points are *specifically* and where in the design space a good solution might lie. Generics - super-complicated problem, *huge* design space, very difficult tradeoffs. No idea how to solve that yet (No, "just do it like $language does" is not an answer - between Python generics and Idris generics is a lot of space). Error-handling - how do we maintain local error handling, while also reducing the repetitiveness and syntactic overhead? Difficult problem to solve. Exceptions give up locality in favor of syntax. Sum types/Optionsal/Result enforce locality, but *add* syntax. Unless combined with Monads, Macros or something - in that case, they remove locality *and* add more syntax and a more complicated type system. We don't know how to solve that yet. However, when you talk to people about this, they generally refuse to accept that there's a tradeoff, they refuse to accept the complications and they ignore, that *the existing* solutions are made in the context of an existing language, with an existing type system or they just assume that what other languages do is really *good* (FTR, I don't think Monadic error handling is something to strive for, it leads to bad software engineering. Much less exceptions). And that makes it hard to actually talk to them or say anything *but* "yeah, lots of people say that". If we tell people loud and clear what kind of discussion we want to have about $feature and they straight out ignore us and call us names for supposedly ignoring them - well, then what are we supposed to say? Then there is the last class of problem that get a "lots of people say that" answer. It's where rolling your eyes and moving on is the only viable solution. Lots of people seem to be petty about brace-style, or spaces-vs-tabs, or that Go is not functional, or that it's not pure, or that Goroutines have no ID, or… well, whatever. If that makes or breaks a good language for you, then good riddance.
What is the problem you are trying to solve and why isn't using TLS/GPG/nacl/jwt/… a sufficient solution? Usually, if you are using these low-level primitives, you should know if you're using them correctly and at least for the crypto-part, you should probably not ask /r/golang, but some crypto-related subreddit. From a "is this idiomatic Go" perspective: * Your variable names are *long*. IMO too long. * Why does Decrypt take a base64-encoded string, instead of simply a `[]byte`? It seems unnecessarily restrictive. If the goal of the package is to directly work on printable strings, then you shouldn't call it `b64ciphertext`, but just `s` or something. The base64 is implied by the intention of the package and it being ciphertext is implied by the function name. Similarly for `plaintext`, btw, I would just call it `b`. Apart from that, I don't see any readability problems here. But again, to be clear: I don't understand the point of this package and I don't know whether the crypto-stuff you are doing is sound *at all*.
Oh, of course: Your exported functions should have godoc-comments, just as the package as a whole. You should probably run `golint` and `go vet` and address what they are complaining about.
I've sent a PR to change this, thank you for spotting the issue.
Yes, I've forgot to add it, I'll send a PR shortly https://golang.org/cl/69091/
If I read this correctly Hugo can now handle thumbnails for me? That'll make my life so much easier 
Yep, that's correct. You can resize and crop your thumbnails and more. [Here](https://gohugo.io/about/new-in-032/#image-processing) you can find more information about it. Happy New Year btw
&gt; Just to highlight a few things... Wow, do I have thoughts on this. &gt; Generic Programming The post seems to be mixing a couple of different things and kind of misattributes some of the problems here. Go does have polymorphism, both constrained and unconstrained, in the form of interfaces. So, when people claim that Go suggests `interface{}` as a solution to generics, they are simply wrong - Go suggests defining a given, non-empty interface for the task at hand and achieve polymorphism through that. What Go does *not* have is parametric polymorphism, i.e. being able to define a family of types in a single declaration, by adding a type-parameter. Notably, `a -&gt; a` is not a single type (and `id` consequently not a single function), but a whole family of types. If you want parametric polymorphism, you have thus to answer how you instantiate different types/values: Are you doing it at compile time (C++-like templates) or are you doing it at runtime (java-like boxing)? Both have different advantages and disadvantages and it is non-obvious what the correct choice would be. You'd also, on a more semantic level, have to define what *can* be parameterized and how. Go has type-declarations, which come in different flavors (struct and interfaces are the most important one for the discussion), which each could have parameters in different places which would have different implications. For example, a parametric struct-fields would change the size of the struct, meaning different `Foo&lt;T&gt;` could have different sizes. Can the receiver be parameterized? Can function-arguments and returns be parametererized? That last question leads to the interesting next point: Go does have subtyping (again, interfaces), but it's neither Co- nor Contravariant. So, if you write a constrainedly polymorphic function `func Foo&lt;T: I&gt;(f func(T) T)` (making up some syntax for "type parameter `T` has to implement interface `I`) it wouldn't really be clear how that could be implemented -- and *both* `Foo` *and* `f` would need access to the methods they need, which might be dynamic and differ. Right now, that is relatively simple: When you store a value of type `T1` in an interface variable of type `I1`, the compiler knows the methods set of `I1`, generates a jump-table for it and every *user* of `I1` can take that fixed jumptable and call the methods it's interested in. If `T1` is an interface-subtype of `I1`, that doesn't pose a problem - again, the compiler knows the method set of `T1` and of `I1` and can shuffle-around the method table. In a world with constrained polymorphism and subtyping, this becomes more messy: *Both* `Foo` *and` `f` need access to their respectively interesting method sets. So when `Foo(v)` is called, `v` must be packaged both with a table of methods that `Foo` is interested in *and* with a table of methods that `f` is interested in (because `Foo` has to pass that on). For a potentially infinitely nested set of types. So, if you want true subtyping (which you probably want, to make parametric types and constrained polymorphism work well and as expected) you again need to answer this messy implementation-question about how that is going to be represented and it doesn't seem clear what the correct level of packaging would be. Then you need to answer the question of type-inference. If you have to type `math.Max&lt;uint64,uint64&gt;(a, b)` every time you are using this function, you don't really get anything, so you definitely want to build as powerful a type-inference machine into the language as you can, to be able to omit the types wherever possible. Rust and Haskell (and most other languages that have parametric polymorphism) solve this via a heuristic solver for their underlying type-theory, which, as it needs to allow constrained polymorphism, needs to be quite complicated. Go's current type-system allows very easy inference-rules using only local information. i.e. the type of an expression can be easily determined just using the type-declaration of where it's used, in constant time. This isn't just a question of compile-time, either: Go values a simple spec and easy to reason about semantics and "an expression type-checks if the compiler has the right heuristics - otherwise add more type-annotations to convince it" isn't a terribly good thing to put in a Go spec, it doesn't lead to terribly understandable error messages and it doesn't make clear why one expression might work, whereas another, very similar one, doesn't. In the end, it will add a bunch of overhead when *writing* Go code - as you are going to invariable end up in a situation where you have trouble figuring out what exact magic incantation you need to convince the compiler that the expression you wrote down is correct. So… Saying something like "obviously, we want Constrained Based Generics With Parametric Polymorphism" not only totally leaves out the discussion about *why* that is the one correct solution to use. It doesn't even actually *address* any of the interesting questions of how that would interact with the myriads of existing language features and how to implement them. So, this article is kind of indicative of the issue with the discussion here (though it's slightly better than other articles, which only discuss syntax, without ever talking about semantics first). It jumps to a solution, without actually really talking about the problem to be solved. It paints that as being a full, easy to implement solution, without actually talking about the actual *issues* with implementing it or answering the questions that where [asked years ago](https://research.swtch.com/generic). And it doesn't talk about the *problems* that approach would have. "Constrained Based Generics with Parametric Polymorphism" sounds like it would be "the solution", but each corner in the cube of runtime/complexity/ease-of-use cost with each side reaching from zero to horrendous can be occupied with an implementation fitting that description. Experience reports are meant as a frame to talk about these things exactly because they allow us to a) evaluate solutions against the actual problems that are tried to solve, b) give us a frame-of-reference for where in the design space a solution should be in and what features it may be able to omit - significantly reducing the cost and c) what interactions to look out for when actually writing down a proposal. The reason experience reports are requested for the discussion, is because it leaves the actual *design* to the language designers behind Go, but gives them information about the *constraints* that design should happen in. &gt; Language Extensibility It is not clear that this is a *good* thing and the article doesn't explain why it would be. The more extensible a language is, the more people extend it, the less uniform it becomes and the harder it becomes to reason about the semantics of existing code. Python is a perfect example, as probably the most extensible language there is (except maybe Perl). The expression `if x in y` can, in Python, be in *any complexity class* (and very frequently is not constant). The number of times I had to tell people in my algorithms-class (which used Python), that if they use `in` with a List, that is going to add a linear factor to their algorithm and make it useless, is frustrating - or that I had to explain that a list-comprehension-based quicksort is quadratic in python. The way python is taking operator overloading to the extreme makes it essentially impossible to know, what a given piece of code is actually doing. The other side is, how extensions make code non-uniform. Is it insanely cool, that you can write [Pony ORM](https://docs.ponyorm.com/)? Well, yes, it definitely is cool af. But it also means, that every project out there will add their own crazy extensions. In any given week, I may contribute code to four or five different projects that I have never seen before and if I have to first figure out what all the extensions they built into their codebase for "convenience" is, I *will* go mad. Python is so extensible, that people write *different languages on top of it*. It is legitimately arguable, whether "Python" really is a single, monolithic language, given how much it is extended in practice. I'm not saying, that extensibility is really a bad thing, Python is a great language and has its place. But I'm also really glad that there is a language that is *not* extensible and at least for the problems I'm working on, that is a *huge* bonus. &gt; Go's Solution: Nil (and multiple return) That whole section is a diversion. Most of it is simply irrelevant -- `nil` is not representing the value 0, necessarily. Moreover, there is no way to assign 0 to a pointer. The author is talking about C here, not Go. And some of it is factually incorrect -- `nil`-pointers do not allow you to construct values of a type that are not really of that type. The rest is kind of an awkward redefinition of semantics/picking of nits, to make your argument more supportable. For example: &gt; Neither Rust nor Haskell allow null pointers, so we know with 100% certainty that we will never experience a null pointer dereference bug Uhm, no, that is false. Haskell does have exactly the same problem, in the form of `⊥`. E.g. if you have a `Maybe T` and you forget to match the `Nothing` case, you crash. So, this seems to be an arbitrary preference by the author: If we call it a pointer and dereference `nil`, it's bad. If we call it `Maybe` and don't match `Nothing`, it's great. The issue the author has here isn't, that pointers can be `nil` but maybe that the compiler does not have warnings for that (whereas Haskell *does* have warnings for some cases of non-exhaustive matching)? But then again, `nil` is *a perfectly fine value* for a pointer, warning about it would simply be incorrect. --- At this point, I'm running both out of time and out of characters… but that post is pretty low-quality discourse, TBH
Hey, thank you for the suggestion. I implemented some benchmarks and changed `bytes.Equal` to `ConstantTimeCompare`. Differences between correct and incorrect passwords are not that big, but also overhead from constant time compare is quite small.
&gt; Do you prefer otherwise? And if so, why? I don't care whether *I* have that control, as I would never use it. I prefer *other* people not having that control, because I don't want them to use it. I have to read their code. If I have to wonder about the semantics of their hashing implementation, that'll be harder. Go is designed in and for a world, where people work predominately on *other people's* code, not on their own. That design goal means, that adding power to the language always adds a considerable amount of cost (the more different things the language makes easy, the more different things people will do and the more different things you thus have to reason about and understand when working on other people's code). If, on the other hand, you come from the assumption that you'll predominately work on your own code (and you are the main person doing so), then, yes, it would obviously seem weird that people think giving you more choice or more power would be a bad thing.
Does it also handle images from css files?
Hugo doesn't parse CSS files to handle images. They're stored alongside with your content files. This way they can be detected as "resources" and handled by file type. The screenshot in the [page resources section in the docs](https://gohugo.io/about/new-in-032/#page-resources) should give you more information.
Nice. Would it be possible to reuse the ETag handling implemented by https://godoc.org/net/http#ServeContent ? something like replace most of the code after next.ServeHTTP(rw, r) with http.ServeContent(w, r, "", time.Time{}, bytes.NewReader(rw.buf.Bytes())) ... but maybe you don't want to other stuff done by ServeContent?
&gt; I'm sure the abuse happens, but I'm struggling to believe that it happens as much as everyone suggests. Cool. Why does python have `is`, then? And, more specifically, why do people have to use `is None`, instead of `== None`? Don't get me wrong, I understand the *difference* between `==` and `is`. But if people wouldn't abuse `==`, *you wouldn't need to have* `is`: Semantically, `==` should give the one and only and correct interpretation of whether two values are the same. So, if operator overloading isn't abused in practice - why does Python have a whole separate language feature to deal with an instance of operator overloading abuse? &gt; I'm not a fan of the logic used against it because it applies equally so to other features. And you are correct. For each feature, there is a cost (potential of abuse and complication of the language) and a benefit. And this applies pretty generally. So, for each feature, you have to weigh them appropriately and that's the art of language design. &gt; I'd like to know why the creators thought that function-level unwinding (with added data costs) made sense over scope level guarantees. Both make sense in some cases and don't make sense in other cases. For example w := os.Stdout if *outFile != "" { f, err := os.Open(*outFile) if err != nil { log.Fatal(err) } defer f.Close() w = f } wouldn't be possible without a function-level defer. Yes, there are cases where function-level defer is bad, but there are also cases where block-level is bad. It's basically a toss-up and as long as you know which is which, you can work around it, so who cares?
I don't think this is true. I mean, apart from the fact that there really is no such thing as "the current scope", so talking about scope-level is kind of confusing. But it would be trivially easy to have a block-level defer. As every statement is in at least *one* block, you could have a defer execute as soon as the end of the smallest enclosing block is reached. The true issue is, that it's not even clear that a block-level defer would be *better*, really. Because sometimes you want to defer something in a loop or a conditional block and have it execute at the end of the function (see e.g. the example [here](https://www.reddit.com/r/golang/comments/7n2p2q/the_why_of_go/drzxilv/)). It is non-obvious that one is better than the other and you can always work around it. For example, I'd argue that if you *need* defer to keep track of whether a resource gets collected in a loop-body, you should probably refactor that loop-body into its own function, as it's pretty complex. But, really, ¯\\_(ツ)_/¯, it's once more one of these things where I can see the arguments either way, but it's not a terribly important issue, so I just find it hard to sympathize with people citing it as evidence for Go being bad…
Blog.
Yeah, I know, I rant too much ;) FWIW, most of the content of that comment is already planned to be digested into a blog post in the very near future. Reddit-rants help me figure out what I want to say ^^
BTW, there is another great example of operator overload abuse (again from Python): Namely, that `a += b` and `a = a + b` do *different things*. Like, not "if you implement them weirdly", but even in a simple case such as on lists, which is a Python builtin. Again, I understand the reasons for *why* they behave differently; but it's one of these cases, where operator overloading has unintended weird side-effects that make code harder to reason about.
The problem with it just being a block as opposed to a scope is that not every block creates a new scope, or at least should-- specifically `if`
Hugo is so awesome. 
Yes, the block in `if` creates a new scope. [As does every block](https://golang.org/ref/spec#Blocks). There is some subtlety in the interaction when it comes to `switch`/`if`/`for` statements (basically, that they implicitly create a block *around* the statement, in addition to the one you see delimited by braces), but it's not really material to the question - `switch`/`if`/`for` clauses only allow simple statements and `defer` is not one of them. So yes, it is *definitely* the case that every block creates a new scope - but not every scope is created by a block. See, for example, [here](https://play.golang.org/p/MdHv5lummaF) for the scoping-effects of `if`. It is forbidden to declare an identifier [twice in one scope](https://golang.org/ref/spec#Declarations_and_scope), so given that we are declaring three `x`, there have to be three scopes involved here. One is the body of `main`, one is the `if`-statement (above mentioned implicit block) and one is the body of the `if`-statement. You can also see the effect of creating a new scope with a block by just having a [free-standing block](https://play.golang.org/p/p4REzF3Dvkm). FTR, this also gives a mechanical workaround for block-scoped `defer`s: If you want a `defer` statement to apply to a given block, just replace the block `{ StatementList… }` by `{ func() { StatementList… }() }` and you get a defer that is scoped to a block.
&gt; An argument I never hear about generic programming is that it would lead to a wide set of container libraries that would make it harder to understand Go code. The fact that there are only two containers used in Go code, slices and maps, contributes a lot to the good readability of Go code. That's the first time I've ever read such an argument. And I don't see how it can hold up. So you're afraid that you'd have to deal with a larger API surface if that happens? That occurs regardless of whether the language has generics or not. The fact that there's quite a lot of APIs, both in the stdlib and outside, doesn't that make any Go code harder to read for you?
(Ah, and: That last point also shows, that there really is no technical problem implementing block-scoped defer's. All that would be needed, is for the compiler to do the equivalent replacement, if a `defer` is used in a block)
`new()` returns a pointer. using `&amp;` on a pointer yields a pointer to a pointer. https://play.golang.org/p/rfRdYizFB8g https://play.golang.org/p/o0N2dtgevhN
Oh I didn't see that that existed in the stdlib! I will check out using that for sure!
Thank you. Fantastic summation. 
Pinging /u/epiris - you seem to know this stuff) 
&gt; Haskell does have exactly the same problem, in the form of ⊥. Haskell's bottom value is not the same thing as nil. Bottom in Haskell represents a computation that never completes. Every turing-complete language has an equivalent to bottom, Haskell's just unusual for the amount of consideration it gives the problem. It wouldn't make any sense to do this in Haskell because you'd be asking if x terminates and you'll never get an answer if it doesn't: isBottom = x == ⊥ So nil can be used for a variety of things and can be a part of a sensible API, but ⊥ is really only useful as a kind of TODO that satisfies the type checker, but blows up your program if you ever reach it. &amp;nbsp; &gt; if you have a Maybe T and you forget to match the Nothing case, you crash. So, this seems to be an arbitrary preference by the author: If we call it a pointer and dereference nil, it's bad. If we call it Maybe and don't match Nothing, it's great. Whether you want a warning or an error for that kind of incompleteness is a compile-time option. The problem with nil is that it can be anywhere whether or not the API calls for it. Maybe only appears intentionally. Whether this Go code is safe or not depends on the definitions of f and g: var x *int = f(5) g(x) Whereas this Haskell code is obviously missing a case (that the compiler can detect): x = f 5 :: Maybe Int let y = case x of (Just x') -&gt; g x' &amp;nbsp; https://wiki.haskell.org/Bottom
&gt; Whereas this Haskell code is obviously missing a case (that the compiler can detect): It's not equivalent, though. The equivalent Go code would be var x *int = f(5) if x != nil { g(*x) } That's basically my point: `Maybe a` is semantically equivalent to `*T` in Go - and either works fine, if you do the check and neither is fine, if you don't. And yes, you can detect a missing `nil`-check just as much as you can detect a missing `Nothing`-case - it's just much less useful to do so, given how `nil` is a perfectly valid value, which is why it's not really done in practice.
&gt; Maybe a is semantically equivalent to *T in Go Except that there are reasons to use a pointer that have nothing to do with what you'd use a Maybe for. An API in Go might use pointers but document that those pointers will never be nil. So whether the if-statement in your Go code is a critical safeguard or senseless line noise depends on the definition of f (and would depend on the definition of g if g were still taking a pointer). Maybe and pointers aren't semantically equivalent, because the only reason to use Maybe in an API is to allow for Nothing, but a pointer can be used for a host of other reasons.
What is your use case? Without it I can only speculate that this was a learning experience. So at a glance: Show stoppers: - PANIC: You need bounds checks, at a glance Decrypt can panic on a string &lt; 96+blocksize. - Home grown authentication and salt scheme, makes this unusable by default. You should not be using a cipher in block mode for single fixed length message like this, let alone a CTR block mode. If you used any cipher prim (you shouldn't) it should be a cipher in AEAD mode so you don't implement your own authentication. - Is it really desirable to have a single shared key? Do multiple machines produce secrets? Do you need to validate which machine made the secret? As these questions emerge your answer will probably push you towards something public-key based like [nacl/box](https://godoc.org/golang.org/x/crypto/nacl/box). Things that are correct but I consider poor form in a crypto context: - I do not like generateKeys returning 4 arguments as it's easy to mix up 3 very important byte slices and the abstraction doesn't provide any value. I would inline it and then you can create one entropy buffer at function entry and use it for IV and Salts saving a call to rand, allocations and readability. - Generate hmac returns bytes without any indication of it's hashing function. You then write at the call site a fixed 32 bytes (hash.Size of sha256), if you changed the hash function to something with more or less bytes and don't use the bounds given by hmac.New's hash.Hash Size method. You could end up truncating your hash or far worse as off-by-N's propagate in offset math to write a few plain bytes of your secret into a buffer somewhere. - I think you may not have realized that 1&lt;&lt;16 is 65k, which is way way more pbkdf2 rounds than necessary. - My general feedback on hash sizes apply here, there are a lot of integer literals that are making assumptions on bounds based on which is asking for later-on-you to come make a mistake. Crypto primitives always have interfaces that define their bounds, use them diligently. So the summary here is you probably don't want to use AES. Forming stronger invariants will help your bounds be more clear and future proof. Good job overall, happy coding.
https://www.infoq.com/presentations/go-concurrency-gc (previous link) vs https://www.infoq.com/presentations/go-concurrency-gc?utm_campaign=infoq_content&amp;utm_source=infoq&amp;utm_medium=feed&amp;utm_term=Go%2520Language-presentations#downloadPresentationMp3 Maybe the detector doesn't parse / ignore GET parameters
Oops thanks. I thought I stripped those but it's hard to tell on mobile sometimes.
There are quite a few implementations of merkle trees on github. Eg. https://github.com/vbatts/merkle https://github.com/cbergoon/merkletree ...the later seems a lot simpler to use.
&gt;There are ongoing conversations happening on what kind of generics would be a good fit for Go. Given the unique type system, it is not easy to just copy an existing approach and assume it will be useful for the majority and will be orthogonal to the existing language features. Go Experience Reports are waiting for user input to see what kind of use cases could have helped the Go users if Go had generics. This seems like a poor way to design a language. I'm all for thinking (and yes, the new type system must terminate when checking and all that), but saying "when were time you would have used generics but didn't" will likely vastly underestimate their usefulness. People forget, don't notice, or just plain work around it. If generics were critical to their project, they would rewrite it in something else. Generics in Haskell are really great - you can derive JSON parsers/pretty-printers for a type, deriving serialization for a type, etc. It's hard to imagine such a feature *not* being used if it were available. 
Thx, that's cool, I'll check that soon ;)
Thank you for response I was trying to implement aes-ctr with authentication and key derivation in go It's just for fun
Image processing is a huge addition. My blog is very image heavy and I shoot with 24/42mp cameras a lot. I usually export them in smaller sizes and then also compress them if needed. Now I can dispatch this work to Hugo. Thanks a lot!
Uh oh! This is a bad miss from my side :( Thank you for pointing this out. Changed the examples to use `defer`, although I'm not sure if it makes the "error handling" any more non-confusing. I didn't want to use `panic` in the examples because I thought *that* would be bad advise for new comers, and `os.Exit` bypasses the deferred functions. Removed the cheating parts.
Yep, this was why I decided to write the various ways down; list out *when* you might want to use one of those functions. However, now that I think of it, this point isn't really clear :\
I'm gonna push back a little bit here. Just having a generic error handling function isn't bad, but using it everywhere without explanation, IMO, is. I should've probably prefaced this topic by mentioning that I wanted to highlight the reading parts and usecases more than the code itself.
That's another thing off my wish list, cool. I'm looking around for something to replace ikiwiki and nothing has everything I need yet (not even Hugo).
&gt; That's the first time I've ever read such an argument. I find that surprising. I am obviously biased, but personally, I bring this up on an almost daily basis in this subreddit alone. &gt; So you're afraid that you'd have to deal with a larger API surface if that happens? I'm not sure, what you mean by this. The argument is, that in Go, people will either use `map[K]V` or `[]T` - for both of these, I have a very clear understanding of the semantics, common pattern,, performance characteristics… making it easy to reason about Go code using them. For example, I know how `append` reallocates, when slices can and can not be shared, I know that `range` over a map won't have a deterministic key order, I know the patterns of using a `map[T]bool` or a `map[T]struct{}` as a set, I know that index-expressions of a map will return the zero value if not found… When people start using a greater variety of containers, this will become harder - every use of a container will first require understanding *what* is used (and given that we'll invariably end up with abstract data structures, that often won't even be apparent from the source code), why it's used and what the differences in semantics and performance characteristics are, making code harder to understand. People try to make the argument, that without Generics, people will still use other data structures, they're just not going to be generic, leading to more API surface or worse code. But it turns out, in practice, this seems not to be the case. It's pretty rare (compared to Java, for example) for people to use more exotic data structures. And in practice, where it does happen, the reasoning is much clearer (as it was a very conscious and deliberate decision) and it is also much more apparent in the source, what is happening. That, however, is my personal experience from working on both a Java and a Go service for roughly the same time.
ServeContent does not calculate and add ETag headers. It just uses it, if the caller had set that header already. Otherwise there would be no ETag header. I had to implement my middleware too.
&gt; It bothers me that she (or the Go creators rather) can just brush this criticism aside without really defending it. "You just don't understand Go." I think that various go team members several times have given answers to why many potential language features are omitted. In many instance the reasoning is that they don't want overlapping features which leaves a bunch of the type system stuff people want questionable to add. For some features they have said that the use of Go needs to mature before anyone can really start to reason about which additional features would bring the most benefits which I think is a very fair point if the language is to be kept from exploding with features making code harder ro read. You can agree or disagree with arguments like that but I have seldom seen the Go team simply saying "You just don't understand Go." without further duiscussion. It has probably happened but probably mostly if they talk to people that actually hasn't at least a medium experience in writing programs in Go. 
Yes there lot's a good stuff in there, some a bit hidden :) Btw, could rw.Header().Set("ETag", fmt.Sprintf("\"%x\"", rw.h.Sum(nil))) be moved from Write() to after next.ServeHTTP(rw, r)? but i'm not sure how much impact there is to do header Set and Sum for each Write. Also maybe io.MultiWriter can be used? so something like this: https://play.golang.org/p/znL0S3n0QRY
Yes that was my idea, reuse the ETag checks done by ServeContent
Oh...Sorry. You are right. I'm doing the same thing using `http.FileServer` (which calls serve content). https://github.com/dc0d/cache-control
I'm the author... I wrote this for two reasons: to learn Go better (it's my first serious Go project) and because I just needed something like this! I based the crypto design on PasswordSafe3, which is one of the best Password Managers available, but only for Windows (I use Mac and Linux, so no good for me). I have been asking in /r/crypto and /r/security for people to review the database format and no one seems to have found anything wrong with it, so I believe it's safe to use. Please check it out, use it if you think the database format is sound, and let me know what you think!
Congratulations! Question: what other languages have you written in?
TLDR: This paper is very important to the database world. It explains a modification to paxos which allows leaders to dynamically change per-key to be closer to where users are. The go code was written by the author of the paper. A TLA+ spec is provided which means the algorithm is correct. "This allows the protocol to process requests for objects under different leaders concurrently. Each object in the system is maintained in its own commit log, allowing for per-object linearizability." Every server globally will agree on a total order of mutations to keys. "linearizability is ensured per object, and when deployed with multi-object transactions, strict serializability is ensured across objects." Every server globally will agree on some order of multiple-key transactions. Looks like 4.3 explains how this works. Looks like the author punts on the specifics but gives a sense of how that'd work. Perhaps a future paper? :D "WPaxos is able to achieve low latency commits using the zone-local phase-2 acceptors." First round is between regions. Second round can be within the region. Figure 2 in the paper has a really good space-time chart. "Paxi’s networking layer encapsulates a message passing model and exposes basic interfaces for a variety of message exchange patterns, and transparently supports TCP, UDP and simulated connection with Go channels." (relevant to golang reddit) Nit. I think the AWS instance types in the paper are under-specified. They're referred to as "medium" and "large". AWS instance types consist of a family and size. For example, "c4.large" is family "c4" size "large".
Yeah I should just set the etag after, that's left over from when it used the other tags in write. A multiwriter might be easier too! Thanks for all the feedback, will implement.
Quite a few :D In order, something like this: Pascal, C++, Java, JavaScript, Python, Groovy, Ceylon, Kotlin, Haskell, Elm, TypeScript, now Go!
No problem! I've noticed that i find a lot of useful stuff by reading the stdlib code
I don't see the point of GopherJS, working with javascript is much easier and productive than golang and it's straightforward. I don't think there's anyone here that has been using it production.. Assuming that the trade it worth it, what advantages would gopher js bring over js?
Nice though it's definitely not all common gotchas. "50 Shades of Go" includes extra gotchas to keep in mind :) 
I made this because I prefer using psql rather than using Postico or other alternatives and I connect to a lot of Redshift databases. It's a simple CUI that builds on top of the ~/.pgpass password file standard that Postgres has defined and allows you to simply select a connection from a list and then have the application build and run the psql command for you instead of making you search through the ~/.pgpass file (or wherever you store credentials) and manually building your psql commands.
&gt; Defer is function scoped, so the following doesn't work: &gt; yes, the idea is to execute code before the function returns, as cleanup if your `for` would do something like `go func(args, wg) {...}`, then it wouldn't block indefinitely, would it?(assuming your func will `defer wg.Done()`) ;)
Right, it wouldn't. However, sometimes I don't need or want the goroutine. That's just one (relatively contrived) example of where I'd want block scope deferred functions (or alternatively destructors with guaranteed run time semantics). I can do without them, but it's messier (read: more bug prone) code. I don't necessarily want WaitGroup itself, but the feature that this example highlights. I basically want to guarantee that something will run by the end of a block even if there's a panic. My current solution is smaller functions with defer, but sometimes that just confuses the code.
I think I got your point, tho there's only so much you can do to protect one from his own code ;)
Worked on this because I prefer using psql rather than using Postico or other alternatives and I connect to a lot of Redshift databases. It's just a really simple interface that builds on top of Postgres' ~/.pgpass file and lets you select a connection from a table and then runs that connection via psql.
This looks like a poor copy of https://github.com/golang/go/wiki/SliceTricks
&gt; "Go should be as easy as Python" Python ain't easy. It's easy to get a hello-world in Python, but the language has plenty of complexity that _will_ come back to bite you. Other things here include that article that was making the rounds a few months ago, about how making lots of fast de/allocations in a garbage-collected language is a bad idea.
Great tricks. Thank you 
It's not just the versioning stuff - the class system is _[fun](http://dwarffortresswiki.org/index.php/Fun)_ and flexible, but also probably just in itself as complex as learning everything there really is to learn about Go.
1. Use [Cobra](https://github.com/spf13/cobra) /thread
Agreed. Cobra is mentioned as one of the points in the post :-)
Ah, Must have missed that one. Cobra is awesome :)
Yes, but that is out of scope to solve for distrilock, that builds on top of NFS. See the links in my post about research on NFS scalability, I would expect future iterations of NFS to be more scalable and add support for redundancy. Although resuming lock state could be added via use of serialised information on the lock files themselves, I have not planned to add such feature, and I think it wouldn't be an elegant implementation anyway. 
That's completely and totally wrong. Remove the &lt;T&gt; from what you wrote and you will see that your problem is not generics, is that you don't understand data structures. You can totally have a non-generic PriorityQueue in go. Generics have nothing to do with your post.
&gt; Remove the &lt;T&gt; from what you wrote and you will see that your problem is not generics, it is that you don't understand data structures. You don't know me - try to still assume that I know at least as much as you, in the future. That tends to be more productive, insulting people tends to not get you very far when your goal is to convince them. &gt; You can totally have a non-generic PriorityQueue in go. So? Like, I don't see, at all, what that has to do with having to figure out *what kind of* PriorityQueue is used or should be used. PriorityQueue is an abstract data structure with many different implementations (each with their own performance characteristics and semantics). My complaint is about having to choose one of those and that very *definitely* has something to do with generics. The lack of generics encourages people to use concrete data structures, instead of abstract ones. I.e. my complaint isn't about `PriorityQueue&lt;T&gt;` vs. `PriorityQueue&lt;Int&gt;`, it's about `PriorityQueue&lt;T&gt;` vs. `Heap&lt;T&gt;` -- and Go's type system (including the lack of generics) tends to discourage building and using these abstractions.
Seems a little bit more like a collection of favorite libraries rather than actual boilerplate for setting up a microservice. Nevertheless it's a decent list.
Just because I've seen beginners and crazy optimizers pick up crazy ideas from web posts and brutally misapply them, bear in mind manual reference counting in a Go app is a seriously last-ditch solution. An intermediate I've used before in a similar situation is that if there are some code paths where ownership becomes very complicated, I will take things out of the pool and simply never put them back, letting the vetted and tested Go GC handle those cases. In the cases where ownership is simple enough to track correctly I put things back in the pool. If you're getting to the point where you are seriously considering doing this in Go, I'd suggest you're also getting to the point where you may want to seriously consider Rust or something. Go has a really nice bang/buck ratio, but if you need _all_ the performance, it isn't really designed to go that far. An intrinsic part of how it gets to that very nice bang/buck ratio is that it seals away that last level of complexity.
&gt; Just because I've seen beginners and crazy optimizers pick up crazy ideas from web posts and brutally misapply them, bear in mind manual reference counting in a Go app is a seriously last-ditch solution. An intermediate I've used before in a similar situation is that if there are some code paths where ownership becomes very complicated, I will take things out of the pool and simply never put them back, letting the vetted and tested Go GC handle those cases. In the cases where ownership is simple enough to track correctly I put things back in the pool. You are absolutely right about the fact that this is a crazy idea, especially when there is more number of contributors to the code. As I have mentioned on the blog as well, this has to be considered as the last leg of your optimisation if at all required. For the majority of the web-apps, this is not gonna be the case. Secondly, the case where you don't put back is easy to handle. This approach mainly concerned about using the objects in a flow that are already been put back into the pool. That could get tricky, especially in a flow, where you are performing a lot of async tasks. If you decide to create pools and not put them back; best way is not to use pools :-) &gt; If you're getting to the point where you are seriously considering doing this in Go, I'd suggest you're also getting to the point where you may want to seriously consider Rust or something. I think this is a bit of extreme approach. I've covered this part in the next bit of my answer. &gt; Go has a really nice bang/buck ratio, but if you need all the performance, it isn't really designed to go that far. It does allow you to hack into the last leg of the memory management. As you might be knowing, There is a way you can completely disable GC and manage the memory entirely on your own (https://golang.org/pkg/runtime/#hdr-Environment_Variables). That would be extreme, but what I have done is best of both worlds. Where ever I will need pre-allocated objects, I use them and manage their allocations. Among other things, GC plays its part. Again, I don't recommend this method for all of the web-apps around. Most of the web-apps don't need this level of optimizations. 
I don't really like Cobra and I think Kubernetes would have used something else if they started out now. It's a bit too complex for what it does. We mostly use http://github.com/urfave/cli because of its relative simplicity and modularity. 
&gt; var i *int = nil &gt; interface{}(i) != nil &gt; &gt; I really wish that if something can be nil, wrapping it in an interface shouldn't change whether it compares to nil. I'm not sure about this one. I agree that at first it look confusing, but in my opinion if you **have** to know the concrete type of an interface to use it, it doesn't make sense to use an interface What should this code do? var i int = 0 interface{}(i) != nil Should we be able to do this: var i int = 0 interface{}(i) != 0 var i int = 42 interface{}(i) != 42 Why should we be able to check for for nil but not for 0? In go, a nil pointer is no more special than 0 or "". Ihmo, the confusion come from the overloaded use of nil. 
Thanks for writing this! I find myself doing this by hand too often.
Maybe we're not using it in the same way as yourselves because while it's more to manage than "flags" it's certainly not our experience that it's complex or burdensome to add or extend commands. Always good to have some other options in the mix though.
Great read - actually building an internal CLI to spin up our microservices on a local environment and using go as well. One unrelated question. You mention the use of a (go based?) api gateway and I was wondering if you plan on open sourcing it? Also, why did you not go with something like Kong? I ask cause we're using Kong and there are some issues I have with it so I wanted to know your experience.
So basically manage your own object pool. With a fixed-size pool this seems technically possible, but how do you shrink the pools when they are dynamically-sized?
Title: 5 keys to create a killer CLI in Go First recommendation: pick Go So, 4 keys to create a killer CLI in Go, at most.
OpenFaaS is completely open source under MIT license. Our API Gateway is designed to manage functions and containers with built-in metrics and auto-scaling. We sometimes use Kong in combination with our API Gateway to apply rate-limiting and OAuth etc. The two are complementary rather than it being an either/or situation. There are also alternatives to Kong.. what kind of limitations are you running into? Have a look at the Kong/Nginx/Traefik guides in our docs here - https://github.com/openfaas/faas/tree/master/guide
OpenFaaS is completely open source under MIT license. Our API Gateway is designed to manage functions and containers with built-in metrics and auto-scaling. We sometimes use Kong in combination with our API Gateway to apply rate-limiting and OAuth etc. The two are complementary rather than it being an either/or situation. There are also alternatives to Kong.. what kind of limitations are you running into? Have a look at the Kong/Nginx/Traefik guides in our docs here - https://github.com/openfaas/faas/tree/master/guide
Projects like Cobra started back when there were no good CLI libraries for Go and because so many projects are depending on them for additional features they grow into massive behemoths with awkward ways of doing things. Cobra is nice and does just fine, but I think there are some more recent libraries (like urfave/cli) that were built from the ground up with developer experience in mind that work better when starting a new project. 
point 4 "Integrate with package managers" doesn't seem to recommend doing that in linux, unless I'm mis reading that. I don't know how much work it is to get your software into a debian/rpm repo, but I see snaps have started taking off, so that could also be a possibility.
Not so much limitations but more so bugs with routing upstream services. E.g. providing a hosts value for the upstream service breaks functionality, no ability to use wildcard matching. Thanks for the links
[removed]
&gt; there are some more recent libraries (like urfave/cli) The `urfave/cli`was literally the first cli package out there, cobra was created much later. Is this all only your opinion? By the way you have put it I understood some limitations of `cobra` were acknowledged by the k8s community somewhere and you'd just reply me with a link to a discussion. 
I just wanted you to admit there's no way of manually deallocating the objects, thus turning GC is really not an option for real, long-running production applications.
That's my next goal, besides iOS and Android. For the desktop I can just setup a webserver and a frontend making HTTP requests (I like Elm for that kind of thing)... but no idea if Go can run on mobile, I saw there's go-mobile but the project seems to be abandoned?!
100% it's not an option for real. But what I have suggested in the blog is best of both worlds where GC does its work and we try to optimize by trying to manage on our own 🙂
Literally everything I'm saying is opinion, I have no evidence of them having specific issues with it, but having worked in the Kubernetes codebase a lot I'm pretty sure they would start with something else if they were starting over. That entire point is a waste of time though, because they're not starting over and nobody is complaining about Cobra in that project. I wasn't aware that Cobra came after codegangsta/cli. 
&gt; file, _ := os.Open("fangraphs.csv") &gt; data, _ := ioutil.ReadAll(file) Check for errors. &gt; file.Close() Use `defer`. Actually you have done zero error handling in your whole program. Please read: https://blog.golang.org/error-handling-and-go
Besides the error handling (something I need to work on for sure, I wanted to do concurrency first) how's it look?
Welcome to Go. :) 1. Do not ignore errors. Check them and respond appropriately. 2. You are converting the file contents to a string and then again converting the string to a Reader to pass to csv.NewReader. Instead, you can directly pass the file and skip the string conversion. Much more idiomatic and elegant code. 2. You probably don't need goroutines for what you are doing. All of them just iterate the `records` slice and manipulate individual columns. The code might look more readable if you just have a single for loop and you convert the different columns all at once. These are just some of the top level things which came to my mind. Happy coding and have fun with Go ! 
[removed]
Or just [save yourself some code](https://godoc.org/io/ioutil#ReadFile)
[removed]
You can sort of do it by taking manual control of when the garbage collector runs. It's not really the same thing as fully manual memory management, but if your application doesn't generate too much garbage and can somehow predict when it's a good idea to clean up any that is hanging around, it can hypothetically provide some of the same benefits. That said, given that Go's GC is pretty good these days, I seriously doubt that there are many applications out there where manual GC control makes sense over switching to a language that supports true manual memory management or simply adjusting GOGC's value.
Tl;dr: Understand the difference between values and pointers. 
Caddy for sure! I found it very easy to reason about the project structure, made PRs to add new Caddyfile directives, and even wrote a plugin for it. https://github.com/mholt/caddy
https://gobyexample.com is a great place to start
What's the advantage over ngrok.com?
Gopher Js is great what do you use to make your flow faster then?
That's just the thing about a boilerplate... there are services you're going to need for every project, and those services are common enough (logging, monitoring, etc.) that they'll have their own libraries. What you're seeing here is the natural result.
Ideally don't use constructors and try to [make the zero](https://twitter.com/davecheney/status/948058108722536448) [value useful](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=6m25s). If it's not possible then just use constructors as shown in [Effective Go](https://golang.org/doc/effective_go.html#composite_literals). Don't trust the Go code you see in Google's APIs. Most of them are auto generated. 
Type safe? There are similar projects like Kotlin for js, Scala.js, and others, so GopherJS provides another option if you prefer Go over Kotlin/Scala.
The deadlock is because you never close the channels. The range will keep blocking because it is waiting for more values (same with the single pull from the second channel). Once your trees have finished walking, the channel could be closed to indicate no more values. 
I should have been more specific where to add it. It would be best to wrap those top level Walk calls in an anonymous function that calls close on the chan after the Walk returns (in the goroutine) 
Boilerplating in microservices is a big anti pattern. If a "common" library is developed to contain this boilerplate for you, you're gonna have a bad time. (This is not what's actually going on in this post, just an unfortunate title I suppose)... The post does however have a clickbait like feel to it as it mixes up a few buzz words without really saying anything.
I suppose you could use something like gomove: https://github.com/KSubedi/gomove
[removed]
 A better article on the same in my opinion: - http://rodaine.com/2017/05/x-files-time-rate-golang/ Also great peripheral reading if you want more background on how rate limiting algos work: - https://konghq.com/blog/how-to-design-a-scalable-rate-limiting-algorithm/
I'm quite convinced that all a webhook inbox is the right way to implement webhooks in general. Make something ephemeral exist long enough to be inspected: - http://webhookinbox.com/ is one possible off the shelf solution, probably someone could hack one together in Go in about 20 minutes and self-host in a Docker container.
I'm very fond of grpc and then sticking https://github.com/grpc-ecosystem/grpc-gateway in front of it. The proto file used with grpc defines typed messages and your service endpoints, you then annotate your endpoints with the REST info you want. And it can generate openai yml. As for ORM I'm not sure what the current favourite is, I am more in favour of just writing some SQL using the brilliant sqlx. Try perusing https://github.com/avelino/awesome-go/blob/master/README.md to see what suits you
I've been using [go-swagger](https://github.com/go-swagger/go-swagger/) for (2). It flips your intended model on its head, but also imo makes it easier to ensure that you build your API "documentation first" because it asks you to write your API spec, then generates (or updates) all your handlers and validators from that. My workflow is: 1. Update my OpenAPI spec to add/update a route. 1. Use go-swagger to regenerate all the validation, routing, models, etc. 1. Write/update business logic in the handler for the endpoint.
Freelancing this year for a multi-national retail concern on a "AWS/GAE-like corporate in-house cloud platform" in parallel with coaching their devs Go development there as-we-progress, so they can get up to speed and actually *own* their code-base for the years to come. Really enjoying that project and am glad Go is finally slowly arriving in the "freelancer universe" --- for years it was just my hobby horse, while doing run-off-the-mill "enterprise .NET" gigs for the bills. Which was also fun, but Go is of course in countless ways funner. That said, seems that corps will "enterprisify everything" --- be it agile, startup chic, lean-and-mean formerly-indie languages &amp; stacks, you name it, they'll manage to! Like a force of nature. In Go within such a context, one may watch out for one that long-term-employed human developers don't acceptingly turn into code generators but rather grow their powers and skills by writing code generators (and identifiying the ample opportunities for that in "the real world" of interop/protocols/formats/etc), for an illustrative example most-everyone here will be able to relate to ;) Hobby-wise, I'm putting the finishing touches on my custom/alternative VS-Code "Go plugin" (more like potentially-one-day-multi-editor-and-multi-language-IDEish-backend-almost-like-a-language-server-but-custom-and-written-in-Go-with-only-the-thinnest-leanest-nodejs-layer-on-the-vsc-side --- right now serving all my Go-in-VSC needs and in a *subjectively* smoother, less laggy manner --- don't care to back that up or drum this project up all that much for some time though). Next up on the hobbyist front, experimenting with some custom FP language from scratch, just for fun (interpreter, transpiler etc) and to get ever better at understanding ever more intimately the fun-damentals of the paradigm
Changing types typically requires a lot more care as you're aware, than names, **but** do read through the gorename (or was it gofmt?) docs in full detail, one of them (forgot which, I always do this stuff manually as you can click through your compile errors to jump to the locations in most-any modern editor) so one of them *can* definitely do "pattern-based code-rewriting". 
1. open GOPATH dir in any half-capable multi-buffer editor, after all git-pulls 2. global-find-and-replace from "github/foo_org" to "github/foo_dude" 3. file / save all before all git-pushs Did you have anything more laborious in mind?
When I care about documenting an API, I care about it being accurate. For me, the best way for me to ensure an OpenAPI spec is exactly what I mean is for me to write it myself. In the past, I've used spec generators, and they always seem to miss some aspect of my logic - enough that I am always worried that the generated spec is wrong in some way. When I write the spec first, I know it's what I want it to be, and if it's not what I want, I discover it when writing the code or sanity checking my endpoints. That's just why I prefer spec first :)
Good point :)
You might want to have different rate limits per user, and per user tier (high-paying customers get more reqs/second). Additional business rules are much easier to write in the same language as the app backend.
Thanks, I'm having a look to this too, although I've never used grpc before :)
Thanks :)
For your example, I recommend using `%#v` as the format operator to add clarity: https://play.golang.org/p/XmCrNtuH1An It's also more a problem with go's `fmt` lib which _always_ unpacks interfaces, and never prints anything about the interface that was being used. &gt; Regardless of the verb, if an operand is an interface value, the internal concrete value is used, not the interface itself. I think in other languages, it'd be the equivalent of having a non-null wrapper object/struct/thing that wraps a nulled value. The wrapper is not null, even if it's holding a nulled thing. It also means that there's a solid difference between "I have not yet assigned anything to the `interface{}`" and "I've assigned something to the interface that happens to be `nil`". &gt; I've had several occasions where I'd pass in something as nil (nil struct pointer usually) and it wouldn't hit a branch checking for nil. Edit: Wanted to point out this statement too. Functions on pointer objects _can_ guard against nil. For example, the os.File close functions check for nil to avoid panics and instead return errors: https://golang.org/src/os/file_unix.go#L196 I think the "go way" is supposed to be along those lines if you're ever working with a pointer object that might be nil.
This.
[removed]
[removed]
[Code-first vs design-first](https://swaggerhub.com/blog/api-design/design-first-or-code-first-api-development/) is the general name for these two development workflows. It's mostly a matter of preference, but IMO the tools for design-first workflows tend to be much saner in the long run. It's much easier to generate idiomatic code from an API spec written in a very limited DSL than it is to generate a sane API spec from arbitrary code in a Turing complete general-purpose language. These kinds of tools often require you to learn a whole meta language of decorators (or struct tags or cli parameters or something) so that they can figure out which parts of your code are meant to be exposed. My other beef with code first approaches is that it makes it very easy to accidentally change a public API and break compatibility with existing callers. With design-first workflows, it's always obvious when you are changing the public API.
Yes, there's a difference, but I don't think that difference is valuable in practice. I could be wrong, but honestly I prefer the way traits in Rust work since they're zero cost and thus there's no runtime check. But whatever, that's how things are, I just think it's an unfortunate gotcha.
I agree completely. This post is completely superficial.
yes, if they are all reading, and only the producer is writing, you're fine.
Yes, as long as the producers and consumers are communicating via a channel. 
I got a coworker that writes Prometheus plugins for funsies.
I do exactly this. However, grpc can be a little bit of a pain. It's definitely not as easy as some of the other frameworks like gin or echo. With grpc, generally you need to know what your data will look like and dealing with arbitrary json is a pain. If you're doing microservices though it's probably the way to go.
If I understand your question correctly you could open it as an *os.File object and use WriteAt. I mean you would have to record the byte position though
1) either approach will work, but goroutine-per-request is either unbounded in memory use, or you’ll need to write limiter code, which would be harder to understand than the job queue approach. 2) I don’t know the answer precisely, but [this article](https://awmanoj.github.io/tech/2016/12/16/keep-alive-http-requests-in-golang/) seems to indicate that it’s ideal to reuse the same client as much as possible.
look for something in between - not a big and not a small one, try to work on projects which you would use yourself on a regular basis (dogfooding) and search with the help of github tags - https://github.com/topics/golang
You have a shared, mutable state. Therefore, your program is prone to race conditions without the use of mutex, etc.
Oh okay, yeah, I read it wrong then. The only thing I can think of right now is you could keep track of how many bytes you are reading with Reader.Read. But other than that I can’t think of anything off the top of my head with scanner, but I also don’t claim to be a golang guru. Sorry I can’t be more help than that.
[removed]
https://github.com/blazingorb/ntreego "ntreego Golang N-ary Tree Implementation. Roughly ported from glib's GNode with idiomatic go" 
This guy just started streaming a series of Developing Games with Go so I'm sharing for those who might want to watch it! From what I gather he's starting with simple text based games then move to 2D grapics with SDL2. Then he said he's going 3D with OpenGL. edit: Seems like his first chapter just ended. Next chapter said to be on Thursday. edit2: Here's the video of the first chapter: https://www.twitch.tv/videos/214870877 edit3: Just found he's also publishing to youtube: https://www.youtube.com/channel/UCnHvMT-7FjTRPUGLVj9mgaA
This obviously won't run in go playground and nor is it production anything but it helps me template out a quick design. It's not pretty nor safe but it's me trying to muddle through something to just get it to work without a framework. There's a ton wrong with it but I think it'll help you if you never touched it before. At least in some ways... I think when you get the ball rolling, you'll realize really quickly gorm and other frameworks just cause a giant headache. Cause not only does it really limit you but looking for documentation is a nightmare with them. Sure you can compare to Enterprise software with them because making tables inside tables inside tables is way easier but when it comes time for customizing, refactoring, benchmarking, errors, ect.. you'll run right back to vanilla. Believe me :) https://play.golang.org/p/-GQ-YWw5fu- I go off these resources I compiled learning. https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk
NATS-Streaming provides delivery guarantee. Nats also provides a lot of out of the box support for dealing with connection issues.
Thinking about this some more, I agree: `pkg` seems superfluous.
&gt; I'm trying to go through a file through a Scanner or a Reader line by line, then check if each line matches a certain pattern. &gt; &gt; Once this is done, I'd like to record the position of the line to edit it It might be helpful to tell us why you want to do this. Manipulating files has never been the easiest of tasks. Depending on what you are trying to achieve there might be a better way.
&gt; I have a github organization and the project is under the organization and later if i transfer it to my personal github For the future, if you want to freely move your project around without affecting the import paths then you can use [canonical import paths](https://texlution.com/post/golang-canonical-import-paths/).
You should be able to set the GOOS environment variable to "windows" prepending the build command. From your Linux machine terminal, run: $ GOOS=windows buffalo build (unsure if it's "buffalo build" or not, but replace that with whatever the correct command is) You'll see a "filename.exe" executable in your current project directory if all went well. The GOOS environment variable tells the Go complier which operating system type your build is targeting. All of "linux", "darwin" (for macOS), and "windows" are commonly used. See the Go documentation for more compiler information. Since the Buffalo command delegates the building/compiling work to the Go toolchain, it benefits from these same features. This particular feature is called "cross-compiling". 
&gt; You potentially need some kind memory fence to ensure you see updates, assuming you have multiple cores. One way to ensure you read the "lastest" value is to use the atomic package to write and read the values. Thanks. I knew I was missing something. Glad I asked!
This is not correct. If a reader tries to read in the middle of a write, there is a data race.
so what you are saying is i need to set up a server which will convert my path to proper paths ? isn't it too much just to use imports ? 
something more dynamic like local imports I still dont understand why everyone is against local imports while it seems to be fiximng lots of problems 
If you plan to change where you host your project in the future and you want to keep the same imports then yes. Most people don't need that feature but it is useful for bigger projects.
still lots of extra work. I dont understand why noone likes local imports while they solve lots of issues. Are there any issues are you aware of that local imports introduce ?
The import path is an arbitrary string and not specified by the language. By convention is it the path that the code lives in under GOPATH. You don't need to use `github.com` or anything like that if you don't wish to. The tooling will happily find your code under any path in your file system.
I'd recommend an atomic.Value if you don't want to lock
You can simply [count the bytes](https://play.golang.org/p/71SU2zAw1oe) you get from the Scanner. This still has a caveat, though, if you have non-unix line endings. A way around that is to supply [your own SplitFunc](https://play.golang.org/p/pc27YHolgfv) and have that take track -- but I found the SplitFunc API to be somewhat hard to use and it includes a bunch of subtleties. Be aware, that the code I linked isn't actually well-tested, so it might be totally wrong. Also, as others have pointed out, keep in mind that editing files is non-trivial, unless your replacements are 1:1 in number of bytes. Like, if you want to delete (or shorten) a line, you'd have to move all bytes *after* that line forward and truncate the file. If you want to insert text, you have to actually take care of buffering the overwritten contents. Like, in a sense, files behave like `[]byte`: You can `append`, you can `copy`, but you can't delete or insert (and the [common tricks](https://github.com/golang/go/wiki/SliceTricks#insert) for slices use the fact that the language will hide a bunch of the book-keeping and buffering for you, which you'll have to do manually). Of course, if you'd change the length of a file, you'd also invalidate all the other line-offsets *after* it. So, unless you always want to do 1:1 replacement, it's *far* easier, more sensible and probably just as performant, to write a new file line-by-line and rename it over the old one.
I found this article that gives some idea of what is generally understood by "distribute lock", especially fault tolerance. Maybe you would be interested. https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html
Use internal, it will hide your project specific code from other code, which is very handy for not polluting your GOPATH. It's mainly useful for projects, but libraries may benefit too. I'm on mobile but will try find a link later to the docs for it.
I agree, the zero value should be useful if possible. The constructor however is there to possibly take some options, like in [this article from Dave Cheney](https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis). He also goes on to eliminate a lot of specific constructors in favor of one more general one. There are many examples of something like Googles APIs in the wild, notably the use of `New()` in self contained packages, vs. having them scoped on structs where they usually become `NewStructName()`. The difference here is that if you'd split your structs into packages, you wouldn't worry about function name collisions, and you could have `New()` in each package. Of course, if you don't want to split them... I guess having a more explicit binding to the struct object sounds good to me, but perhaps not to everyone :) p.s. yeah, I understood that you'd have to be superhuman to produce 900kb of Go code just in one file for the youtube api. I mean, *I did hear stories about Googlers*,...
There's nothing wrong with having a package level function called `New()` especially if good package naming makes the intention clear. Using `StructName{}.New()` feels clunky and very Java-esque to me but I don't think it has any practical disadvantages. I would argue it's less readable but on this case I think it's subjective.
Maybe I missed something but couldn't you use [sync.WaitGroup](https://golang.org/pkg/sync/#WaitGroup)?
That's another approach to handle this issue of passing pooled objects to goroutines. In this case, you have to keep on passing the wait groups across all the functions where you are passing the pooled objects. If that seems feasible, it's definitely another solution for the problem. To the core, you have to do a manual reference counting by one or the other way to avoid putting back the objects into the pool before all the routines are done using it.
&gt; It would also be a bad idea if your manager / lead has asked for RPMs to go back to them with "the internet says no". Yeah, this is important, I had to hold myself back from being that guy.
`sed`
Try using a RWMutex. An RWMutex is a reader/writer mutual exclusion lock. The lock can be held by an arbitrary number of readers or a single writer. http://golang.org/pkg/sync/#RWMutex
What is the goal? You said that your approach isn't very accurate with lots of concurrent requests, but say you want to split every N requests, you receive N-1 sequential ones and then 2 requests concurrently - which one should be considered the "Nth"? FWIW, the word "concurrently" is, in a way, CS-lingo for "incomparable in a partial order derived from time". I.e. by definition, you can't say that one concurrent request arrived "before" the other. And given, that there is only a partial order on events, things like "after N requests" doesn't make inherent sense. So, the tl;dr is: Depending on what specifically you mean by "splitting", "after X requests" and what the actual underlying goal is (sampling? load balancing?) your approach is probably fine. You could use, for example, [sync/atomic](https://godoc.org/sync/atomic#AddUint64) as a counter and see whether `new % X == 0`. That would provide you with a total order of requests, so "every X requests" would be well-defined and that definition is probably as good as any other you could come up with. (now, a different question would be, what happens if you have more than one process, as they won't be able to have a single atomic counter. To design that, the actual use case would be required though) Hope that helps somewhat :)
His website is [here](http://gameswithgo.org/). The topics he is going cover are on it aswell
I don't have experience structuring Go applications in Lambda, but I do for Java applications and I will say that much depends on your use case. Are you using this to set up a JSON endpoint or webpage? If so, why use lambda. It is a long running process and should probably just be set up in an EC2 instance (maybe with Containers). If you just like the convenience of Lambda, you could put the entire thing in a single Lambda instance and not worry so much about architecture. I think Lambda is most useful for event based data pipelines. e.g. a push notification system, converting a file to a PDF when it is uploaded to S3, chron job triggers, etc. Otherwise, the package system in Go should be good enough to handle the modularity you need to decouple various components. 
&gt;For instance, if the writing goroutine is low on registers, it might spill some unrelated data into the storage for that variable, and then restore from it later. Can this even be true? What you're saying is that I should replace obj.var += 1 with obj.varMtx.Lock() defer obj.var.Mtx.Unlock() obj.var += 1 but nowhere do I declare that my variable `obj.var` is volatile. I simply happen to write to it after locking a Mutex. So either the Go language checks for write ops after `Lock` under the hood (which would surprise me), or more likely the `Unlock` call syncs registers with variables, or what you say is incorrect and no variable space is treated as dumping storage.
I must say, that this is an interesting approach, although I wonder why would you choose probability filter instead of some sort of neural network? There were some libraries for natural language processing IIRC. 
It's much easier to open a second file and write the results there, once you are done you just rename it.
I've heard this discussion before but I'm unconvinced. I am quite fond of recognising how a project works from its structure. I can quickly know what to read to find its purpose. Knowing its purpose at a glance isn't quite as helpful to me if I have to dig and dig to find out how it works.
fair enough :)
I should probably go this way. For my project you already have to use a Makefile, so I could patch up any path issues there.
I assume you meant this https://golang.org/cmd/go/#hdr-Internal_Directories 
thank you for linking clockwerk &lt;3 I am the developer of it. I'd happily help if you need any issues/questions.
Hello, just wanted to mention a couple small security nits, first you should at the minimum use filepath.Join for path concatenation all over your project instead of [string + operator](https://github.com/carlostrub/sisyphus/blob/cb1d9243338076f905a3678519f1d32187f378ff/mail.go#L40). Much better than this since Maildir is a simple string perhaps make it a struct with a "root" path that is a http.Dir so you can properly jail file os.Open calls, you may need to _carefully_ mimic it's Open implementation to create the paths for other file operations. [This](https://github.com/carlostrub/sisyphus/blob/cb1d9243338076f905a3678519f1d32187f378ff/classify.go#L176) makes me a bit nervous, but is only a security issue if any portion of Key derives from untrusted input like a mime header. I assume since I see maildir type file operations everywhere there is a good chance it's just the already existing file name of the existing message. If that's the case make sure to load / refer to set key with filepath.Base.
Does a RWMutex ensure that the variable I write to between `Lock` and `Unlock` is "volatile" and will be visible to other cores?
Indeed! That's the one.
Oh thank you very much that's exactly what I was looking for!
I don't think it's meant as a replacement for bash, more like a shell inside a program to run consecutive commands. Think psql or gdisk.
this for sure. I'd add that depending on the complexity of the code you may find only building with -race insufficient. You may need to write a test that specifically exercises this code as intended and run the tests with -race as well to truly verify there are no races. go vet can help you avoid mistakes there as well. Like using/composing mutex incorrectly.
Nice. Will have to take a look. In the past I've rolled my own solution that hooks into Cobra to get command definitions. 
Hoping to see an option to automatically integrate with existing cobra apps.
Split requests how, and for what purpose? If they are being split, presumably they are sharing some sort of resource, like a connection. If you attach the counter to that, it won't be "concurrent" because relative to that resource it'll be serialized. It's hard to be too specific without more information. (Though TheMerovius certainly took a good crack at it.)
&gt; allowing Sisyphus to store roughly 100000 word counters from 50000 unique mails in 10MB. I don't understand this at all. Completely naively storing 100,000 counters using ASCII text, giving an average of ten characters per word and another 20 characters for a naive integer encoding (both _very_ generous estimates) of the good count and bad count yields a mere 3-ish megabytes. Assuming that I'm misunderstanding something, what am I missing?
Question: what's the security issue doing "mypath/"+"anotherpath" instead of filepath.Join("mypath","anotherpath") ?
Thanks a lot for the answer. Use-Case would be A/B-Testing for websites. So if i want f.e. 20% traffic to use a different website template, i'd need to make sure every 5th request gets routed correctly. It's working and everything, i just wasn't sure it's a solid approach, because it looks way too simple.
* [Vendoring](https://golang.org/cmd/go/#hdr-Vendor_Directories) * [dep](https://github.com/golang/dep)
Don't underestimate the power of the Bayes' updater. It is really fast and quite accurate. One reason why I chose this approach was its elegance. All I need to do is to parse the mail and add the (unique) mail name to the hyperloglog counter of each word contained. That's it. Using a neural network would involve an additional training step which Bayes' doesn't need.
Looks cool, I've been using a similar library go-prompt (https://github.com/c-bata/go-prompt) based on python's python-prompt-toolkit.
Thanks! Had just started that was hoping to see more like it.
Yeah your project has to be in your gopath. How is that a big annoyance or liability for developers?
Using a counter would be fine i think as long as you are also using a mutex.
hm..no, i'm not. i will read up on it to get a clue why i should use a mutex. thanks for the hint.
Otherwise since requests come in concurrently you will run into a data race, it will "serialize" the requests as they increment the counter.
Yeah, that was my initial thought as well and why i got sceptical about my approach. I guess i could also just do [this](https://gobyexample.com/atomic-counters)
Yeah using atomic would work too.
You've removed the closest thing there is to a list of the installed packages. Just `go get` new packages as needed. 
Currently I would NOT recommend fighting GOPATH. I tried it, by setting up some scripts in my IDE to copy files back and forth from GOPATH, but that was clunky. There is some talk of GOPATH changes coming in the next version of go (June 2018 I think?) but no guarantees. If you really DO want to fight GOPATH, try out [VG](https://github.com/GetStream/vg) and [dep](https://github.com/golang/dep), which combine to provide something very similar to python's virtualenv, if you are familiar with that. 
That's essentially load-balancing then. Counting is fine. You could also just do `rand.Intn(5) == 0`, which would also do fine.
If your file is line-based text, you usually don't edit in-place since line lengths generally change (as /u/albatr0s points out)... So for a generic "framework/scaffolding" for this problem, I'd use the scanner and output the result to a new temporary file, and when you hit the thing you want to change, you output that instead while discarding the input. Then rename the temp file to the old file. Remove the temp file on error (use a `defer` and just ignore the error). Oh, and I have no idea why you were downvoted. Maybe because the question is about a trivial problem and better suited for StackOverflow or such. But the downvoting feels like it breaks the first subreddit rule.
Wrote this as an exercise in learning the http module. Thought maybe someone here would find it useful.
Well, lookie, a `goto` --- haven't seen one in ages! Gimme a `break` =)
Sounds like your IDE were unduly limited if it couldn't open/store projects *anywhere you want* (including your `$GOPATH`)? Surely that isn't the case!
protobuf frames it for you, no need to add redundant information.
Would you like feedback on your code?
Interesting, thanks!
This was my fear. It's a bit disappointing.
Isn't dep for managing dependencies of a single package and not managing all packages in $GOPATH/src?
There is no inherent security issue in those two forms when used correctly, but the first form leaves more room for incorrect usage and is not portable. You can see how the implementations vary across OS, [unix](https://golang.org/src/path/filepath/path_unix.go) and [windows](https://golang.org/src/path/filepath/path_windows.go). I also have several posts in my history disclosing directory traversal attacks on other projects if you want to see some real world examples.
What exactly are you concerned with? I've started with an empty GOPATH countless times. If you never notice that you're missing a package you once had, are you really missing it? 
Yes, I'm definitely open to that. I'd really like to make Golang my go-to language (pardon the pun), so any feedback or advice will be greatly appreciated.
Thanks a lot. Would you consider this solution even if the file must accessed to relatively frequently? 
It's the only sane option in a POSIX environment, so yes. Depends on the file size, I guess. But if you care about performance, you should probably not be using a text format anyway. More importantly, it's the only atomic way of modifying a file, which solves concurrency correctness. Just use a buffered writer, or you might pay a penalty for writing the small `Scanner` fragments.
Using Intellij idea with goland plugin. It tries to install it for me but it never goes through.
If a teammember just wants to build the Go service and run it without ever developing on it?
The upspin folks started off using gRPC for file transfer but abandoned it for reasons I suspect are related to what you have described. https://upspin.io/ https://groups.google.com/forum/#!msg/upspin/-AN_h_zxqEM/cxi0F8a4AwAJ
You're not stuck with old packages, because you don't have them any more. Even the very rare binary-only packages require a source file. Anything you build will require fetching the source, which will get you the same thing as `go get -u`. Dependencies should be managed carefully, not just with blanket updates. In 5 years of writing Go professionally, I've never once used `go get -u all`. 
If they never want to develop on it then they do not need to build from source. Build binaries, distribute Docker / Docker-compose file or even a makefile can build and run a Go binary with no problem. If they want to build from source they need to play by the sources rules, as they do for any other language.
Thanks a lot. 
I'm trying to keep a record of ip adresses of a few devices. I write them in a file with this format: device1 address1 device2 address2 etc. So, every time this address changes, I (try to) update this information in the file
It's not really, but the server should probably be continuously running so there is no latency.
[removed]
[removed]
[removed]
[removed]
&gt; I'm trying to keep a record of ip adresses of a few devices. I write them in a file with this format: &gt; device1 address1 &gt; device2 address2 &gt; etc. &gt; So, every time this address changes, I (try to) update this information in the file Based on what you said, I can't see any good reason to save the information in a file. You're only making your life harder. Save yourself from all the trouble and use an embedded database like [Bolt](https://github.com/boltdb/bolt).
Well, the best way to learn Gorgonia at the current state is to help with documentation. In particular this repo: github.com/gorgonia/gorgonia.github.io - there's a hugo directory there. It'd be very helpful to pluck a concept from Gorgonia and write a post on it. The most documented is the tensor data structure - a lot of the [rationale for the design of the tensor package](https://blog.chewxy.com/2017/09/11/tensor-refactor/) was written in my blog. It'd be nice to transfer some of that knowledge and design (see DESIGN.md in https://github.com/gorgonia/tensor) to a proper documentation format. 
To quote the spec. Within a single goroutine, reads and writes must behave as if they executed in the order specified by the program. That is, compilers and processors may reorder the reads and writes executed within a single goroutine only when the reordering does not change the behavior within that goroutine as defined by the language specification... Within a single goroutine, there is no concurrency, so the two definitions are equivalent: a read r observes the value written by the most recent write w to v. When multiple goroutines access a shared variable v, they must use synchronization events to establish happens-before conditions that ensure reads observe the desired writes. In https://golang.org/ref/mem
https://github.com/bkilshaw/macvendors/blob/master/macvendors.go#L209 regexp compilation is expensive. since the pattern is the same each time, you can compile the regexp once at startup and re-use it. BenchmarkRegexpCompileAlways-4 200000 6139 ns/op BenchmarkRegexpCompileOnce-4 1000000 1345 ns/op func BenchmarkRegexpCompileAlways(b *testing.B) { macAddress := "dc:a9:04:82:85:4a" for i:=0;i&lt;b.N;i++ { reg, _ := regexp.Compile("[^A-Za-z0-9]+") strings.ToLower(strings.TrimSpace(reg.ReplaceAllString(macAddress, ""))) } } func BenchmarkRegexpCompileOnce(b *testing.B) { macAddress := "dc:a9:04:82:85:4a" reg, _ := regexp.Compile("[^A-Za-z0-9]+") for i:=0;i&lt;b.N;i++ { strings.ToLower(strings.TrimSpace(reg.ReplaceAllString(macAddress, ""))) } }
Thanks for this!! The printf thing was actually something I wanted to solve but just hadn't gotten around to yet.
Really? How was it changed?
There is a way to generate spec from code. I too had issues making it, therefore wrote a blog post with a tutorial. Will be publishing it before Monday.
The problem is that it's a hassle compared to doing a git pull to a Java project and build everything automatically with Maven/Gradle. I like Go but this is the only quirk I've disliked so far. Plenty of people seem to agree on the PR's on github. 
Reliably run via `cron` or `launchd` without dying in flames. PEP 540 will hopefully fix that when it lands in 3.7. Was that trawl through my post history really worth the effort?
What motivated the shift to Elixir? 
Wrote something similar with go-micro based on another library called gotransfer. https://github.com/micro/go-file
Right. I'm sorry. I figured you were a Py3 fanboy going through my post history looking to pick a fight because I criticised Py3 yesterday. To give you a bit more detail, Py3 automatically decodes IO to Unicode using the encoding specified by your locale. If the environment is empty, as `cron`'s is, Py3 defaults to ASCII, which often causes it to die. PEP 540 should see Py3.7 default to UTF-8 instead in that situation.
Thanks, I will look into both. Actually I don't have problems with manually changing the types. I was just wondering if there's a good tool for it.
just myapp/model/user.go myapp/model/post.go myapp/model/comment.go myapp/service/user.go myapp/service/post.go myapp/service/comment.go I don't think your model and services are big enough to separate with different package
I'm fairly unexperienced in Go, coming from PHP. What I've learned is that unlike PHP's namespace, that is based both on folders and files, GO's is only folder based. I'd just have a models folder and a service one, no subdirs. 
it was fixed https://github.com/grpc/grpc-go/pull/1310
I've read that recently, but in my case the models are generated, and having to manually add them to each service package would be wasted time. If I was hand-coding the models, like in other projects, it's very easy to follow the convention. I'm wondering how others deal with generated code and package naming/structuring.
In my case they have to be in separated packages because my columns are generated as types. So different tables would have types with the same names as other tables. table user ( id uuid name varchar(255) // etc ) table resource ( id uuid name varchar(255) // etc ) Those two tables would both generate: type TableName struct { ID ID Name Name } type ID uuid.UUID type Name string 
I don't know your exact context, so there may be something unique to your situation that overrides this instinct of mine. With that said: I think you are over-valuing the time it takes to type things initially, and under-valuing the time wasted in the future trying to derive meaning from generated `model` and/or `service` packages.
In PHP, namespaces are only a label. They are bound to file/folder location because of autoloading conventions, i.e. composer's autoloader. Whether Go or PHP, I usually subdivide my directory structure in a way that tells me something about the architecture and provides a separation of concerns regarding the domain, (infrastructural) implementation details and orchestration code.
 &gt; My models are generated from the database, so it'd be cumbersome to add each model to the their corresponding service package. Either tweak your generator to produce "idiomatic" packages (aka no more model, service etc.) or do it manually. &gt; I'm looking for ideas. I think a better way is to keep all your "models" under a package named after your app (or at the root of the repo) as shown in [Standard Package Layout](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1) and [Upspin](https://github.com/upspin/upspin). * myapp/myapp This makes the naming better e.g. `myapp.User`, avoids stuttering, import circles and keeps things simple.
Great catch!
Well, there API usage has grown substantially over the years. When I rewrote it in Go we were handling out 30 million requests a month. 18 months later and traffic has almost tripled. There are a number of features I wanted to implement, but I don’t have the skills necessary in Go, nor the time to learn, to build them out. A friend is a huge elixir advocate and volunteered to build out the new features if he could use elixir. Nothing to do with Go itself. The original endpoint will stay the same but get rate limited to help mitigate the abuse we receive. We’ve been generous about having no limits on req/s and don’t enforce the 10k per day, but that’s led to people taking advantage of it. We have users sending over 10x that. Also lots of broken scripts that send the same request over and over again. New version will have better logging, rate limiting, multiple return types (CSV, JSON), additional data and paid plans for high usage.
A good model generator allows the user to specify the package
Generally speaking, having those two tables share the same types when possible would strike most of us as a feature, not a bug. What generator are you using? Perhaps it needs to be made smarter to examine the environment for whether a type already exists rather than blindly generating it.
While stuttering is bad, there isn't really a way to avoid `user.User{}`, without the probably-worse problem of importing `user` with `.` so you can just say `User{}`. I think avoiding stuttering is more about compound phases like `getuser.GetUserFromDB()`, where (ignoring the problematic module name) you want `getuser.FromDB()`. Though if I were in your position, I would consider whether I am getting any benefit from this division. I'm probably on the crazier end of the Go community where I advocate (and implement) a lot more packages and heavier use of package separation than most other programmers, but if you're going to pay the price for the separation you need to be getting some benefit, too. If these things are being autogenerated, are there any private members or methods on any of these objects? If not, if they are all just public, I would consider just piling them all into a single package `datamodel` or something, so you get `datamodel.User`. (Would shy away from "data" or "model" alone as the name just on the general principle that it's overloaded and easy to get naming collisions.)
I once read all projects have at least 2 people: you, and six days/weeks/months/years you. Wich makes sense, and MVC helped me a lot in my projects.
Well, those types implement a `Column` interface, with column specific validation and table data for easier custom SQL generation. The column interface is something like: type Column interface { Name() string PrimaryKey() (PK, bool) ForeignKey() []FK Table() Table Constraints() []Constraint } And a validator interface as well: type Validator interface { Validate() error } The generator is one of my own, I'm still trying to sort things out.
Keep in mind that you can easily split and rearrange code within a package between files, i.e. generated code goes into user_gen.go while hand-written code goes into user.go in the same package.
Probably one of Docker, Kubernetes or go itself.
 myapp/user myapp/post myapp/comment
Does this conflict with the clean architecture? How about define the User entity in the user package, and in the service package, you can embed or assemble the User entity to the UserResponse type, and return that to the api response?
Found the guy that hasn't looked at the Linux kernel.
I can't agree more with this. As an architectural consideration, if your model is "auto generated" and you're not adding functionality to it then you have an anemic domain model [Fowler]. IOW you don't have a model at all, just a pile of data types surrounded by cruft. If these structures are sealed up in their own package and no hand-written code can go in there, then you have to Publicly export all your symbols for other packages to do the real work. You're doing zero encapsulation, so why split it up into separate packages anyway? The problem with treating packages like folders for you to organize your code with is that you are prematurely drawing boundaries in your system for no good reason. Packages are tools of encapsulation first, and should be named according to their function. They provide a barrier of abstraction. If you organize them with a preconceived hygienic hierarchy instead of actually how your code works, you're going to be working cross purpose. OP's question is about namespaces. Packages are more than just namespaces.
Room capacity is 148. That is chairs I guess, so 20-30 more can stand in the back or so ? I think this is the same as previous years ? Two years ago I was not able to get into the room at the few times that I tried.
The Go room has been full every single year. The only way is to get there very early and never leave :/
I was actually planning to do that this year (1st time at FOSDEM also). Have you ever tried this? Is it doable?
I did it the first year. I was glad I brought my lunch. Was nice to spend the entire day chatting with the people around me.
Oh wow, so strings aren't even consistent across locales? Yay for Go "runes". 
Go repositories on GitHub sorted by most stars: https://github.com/topics/go?o=desc&amp;s=stars
This is a larger room that in previous years ... but it will be probably completely crowded again as basically all rooms at FOSDEM :)
You can't compare it directly to Go. Go strings are basically immutable sequences of bytes, like Python 2 strings. Python 3 strings aren't bytes, they're Unicode. An immutable sequence of `rune`s, if you will. With Go or Py2, there's no guarantee that a string is actually valid in any encoding. You can create the mother of all mojibake, and neither Go nor Python 2 will complain (unless you try to convert the string to Unicode). Python 3 tries to ensure strings are always valid by automatically decoding from &amp; encoding to bytes at IO boundaries, giving you, for example, the contents of ARGV or environment variables as decoded Unicode, not a sequence of bytes that you can perform string operations on, as Python 2 and Go do. Unfortunately, we don't live in a world of valid-strings-of-known-encoding, and when Py3 can't decode something, it silently gives you *unmarked*, fucked-up Unicode objects (containing so-called surrogate escapes that only Python understands), which will explode if you try to encode them for printing or writing to a file. Beyond the broken assumption that all text can be decoded, the fundamental problem of Py3 is that it doesn't give you the tools or information you need to (easily) fix the fucked-up Unicode objects it gives you.
According to this it seems to be moby. Good idea, thanks!
&gt; read many threads here where people asked how can they implement it &gt; write a lengthy blog post, describing step-to-step Having never used it personally, Swagger is notorious to me by now because I only ever here people talk about it against the backdrop of lost hours and pulled hairs, and hours spent writing internal docs on how to use it for.. docs. =) Looking forward to the day I'll get-to-have-to look into it for some reason or other --- there must be something truly compelling nesting in any thing that "takes off" while all I ever hear are complaints! ;)
I'm in the same boat. Whenever I look at it I see problem, problem, problem that I wouldn't have to deal with if I build API's simply and cleanly. I really like the idea, which is why I looked into it, but getting rolling in a productive way seems like a lot of initial overhead.
We use it so we can generate our client &amp; server side code pretty quickly. Definitely has a learning curve and we have created some tooling to keep things sane but other than that it has been good. I do agree that the code output from go-swagger is difficult at times. Someone decided to be clever and it complicated a lot.
Cool script! I'm not sure if you're looking for comments/improvements, but [I tweaked the script here](https://gist.github.com/anonymous/22a76c1d02c3785b0d3989c9d38f0351). Some of the changes I made: * **Reformatted comments** - Go comments are traditionally on their own lines, complete sentences, and end with a period. * **Replaced inttoStr with a slice** - Since we don't use the int index in the map, and it was sequentially indexed, we can use a slice directly and `range` over that. * **Error-handling changes** - In Go, one generally handles errors and returns early. Instead of having an indented `else` block, the code continues at the outermost level. This is easy to read, and we handle errors as they come up. * **Removed struct tag** - The `encoding/json` library will do a case-insensitive match of exported struct fields, so we don't need to add the struct tag in this case. * **Added rate limiting** - It's generally considered good practice to not hammer public APIs. They hopefully have their own throttling, but we can use `time.Tick` as a simple rate limiter. * **Stream GitLab API response** - We don't need to `ioutil.ReadAll` of the GitLab body, we can simply pass our `*http.Response.Body` to `json.NewDecoder`. This would likely save us memory for large responses, and removes a step from the process. * **Changed concurrency mode** - Each GitLab API call still happens in it's own goroutine, but instead of waiting at the end, we use a `sync.WaitGroup` to wait for all 1296 routines to finish. We also have a separate goroutine to listen for available names, so that only one goroutine is trying to write to our output file at a time. When I ran the script, I got `Total: 1296 Available: 209`, though the GitLab API threw an error or two, so your count might be slightly different :) Side note: I can't edit the gist, but line 49 should use `log.Printf` instead of `log.Println`
Wow, that is really good work! By the way, I never expect to see so many available username on Gitlab.:)
This is more or less how I got a 2 letter .io domain name too a few years back. Scripting is fun.
I’m interested in this layout. Any public repos you can point me to that use it?
You can try to write a github version
I like the idea of swagger but not the way it tries to generate everything rather than the protobuf style of just generating messages and client/server interfaces. So instead what we've started doing is just defining everything with pb, mapping it to http with the grpc http gateway then generating the swagger json from that. This means grpc and http APIs are defined bin the same way but in cases where the API is exposed over http we also get the swagger docs and possibility for client generation. The only downside is some stuff is a bit tricky with pb like file downloads or some response formats. Overall it feels better though.
&gt; It would not slow down the compile time to a noticeable degree nor would it bloat the binary size Cool! Then please provide a reference spec and reference implementation. Shouldn't be that hard, or? You seem to know how to do it and how generics will interplay with pointers, methods, channels, interfaces, methods on functions, etc. pp.
could you explain how this works? Does it compile go to lua?
&gt; if you have trouble choosing between the two Yes, choosing the right data structure is dead simple! I always consult my never failing oracle about the distribution and amount of operations the application and thus the data structure will have to support. From this it is dead simple to choose the right one. But maybe some bad programmers which do not understand data structures and their performance characteristics do not have a never failing oracle like we professionals...
Can’t wait :)
&gt; But maybe some bad programmers which do not understand data structures and their performance characteristics do not have a never failing oracle like we professionals... ... and that's why go only gives them arrays and maps I guess? Seriously though. This sub feels like a flat earth forum for programming.
Yes, that's right. gi compiles one Go expression at a time to a Lua expression. Each expression/statement/declaration is then evaluated on LuaJIT as it is entered. 
Yes, last year I got there some 30min or so before the start and had plenty of choices. Got better during the day, though … 
Good idea to bring your own lunch and drinks. Because the lines during lunchtime are too long anyway. So get in early and prepare to stay there.
I used https://github.com/goadesign/goa for a project. Goa is a design first framework for API's. Its generated output includes a swagger.json - really useful ! 
I believe most important is maintainability in the long term. I bet on Go for this (instead of Python for me) and currently rewrite lot of little dynamic websites. Bonus at short term is speed, i could rent smaller server. The best is to just try...
imho go is good for certain things, and those things are not dynamic websites. PHP is the right tool for this job. Learn to use Docker to control more the environments of your apps. PHP is damn easy to use and gets the job done when talking about a website, it's made for that. Go on the other hand will refuse to compile most of the time because the type of the variable is wrong or something similar. Don't lose your time, stick to PHP for websites. Go is just too low level.
I'm not sure why the hate? This isn't titled &gt; Every single problem you'll ever encounter in go". I Suppose it's just Reddit being Reddit. Did feel like the loop was the same in most languages, although I'd probably make a `map` utility function for what I wanted to iterate over. Most programmers will know what that means, and you'd be able to change the way it works in one place. Looking to improve the code I split it into parts and removed effects. https://pastebin.com/DXLsaC9M &gt; There is a note from the people over at `\#go-nuts` because the style I wanted to apply seemed to have spotty support from golang I'm not Amazing at Golang, so happy for critique. (I know all the animal stuff should be in a separate source file, maybe two)
Just curious, is the talent level of the team more or less comparable or a broad mix?
[removed]
&gt;Some ORM-ish lib (not everyone on the team is that SQL savvy) Take a look at https://github.com/markbates/pop Not an ORM (and to tell you the truth everything else is not at the same level as ORM you can find in RoR or Django) exactly, but a nice tooling to work with db, migrations etc. GIves you some boost, but at the same time encourages you to learn SQL (you'll need it one day anyway)
I mean... That's pretty much what you expect with a statically typed language, don't you? Go is actually a very very high level language, you should read up something about it. The thing with the Compiler telling you your types are wrong is that you can rely on you passing the right arguments. It will not just fail on execution like PHP, JavaScript or any other dynamically typed language. While I won't suggest that static typing is *better* than dynamic typing, your comment is just plain and simple wrong.
I would not define a systems programming language as "very very high level" language like you do. For me low level is C, rust and go. And trying to make a dynamic website with those tools is just a PITA compared to PHP. That was what I wanted to express in my comment.
Have you considered just using VueJS, Angular or React for the front-end, and writing APIs to power it? If so, you could use Go very effectively (as well as PHP if you really wanted to, but I tend to rewrite PHP to Go as soon as something is on a critical path...). In terms of "cheap", VPS servers that can run Go can be less than $100/year. If your driving motivator is cost, you can always find a cheaper option (at the expense of reliability, etc.). I mean this is true for PHP as well. Take DigitalOcean, Scaleway, or some other service like Linode, there are thousands of them. You may very well use the stdlib html/template code in Go, but consider for a moment where you want to evolve with your project in the coming years. Will you need help with development? If yes, I'd direct you back to the beginning of this comment. Choosing an established front-end framework will enable you to find people that are able to work with it. When thinking about Go, you should think about things like high load, concurrency, latency - these are the areas where Go shines, and these are the areas where people that want to work with Go gravitate towards. If you want to work with front-end code, Go is probably not even in your top 5. I'd say that PHP is somewhere halfway between Go and VueJS, in the sense that it enables you to perform complex back-end logic and drive the front-end interface at the same time. It sounds good on paper, but you have to realize that PHP doesn't excel at being excellent in either of those two fields. It excels as being *easy*.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/webdev] [Go for dynamic websites: worth it?](https://www.reddit.com/r/webdev/comments/7ob7h6/go_for_dynamic_websites_worth_it/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
C, C++, and Rust fall into the same camp in my opinion, but Go does not. I don't think it's quite as black and white as high/low level though too. Go to me sits sort of in the middle, because you get some of the benefits from both worlds.
No, that was not my argument. You argued that every "good" programmer should be able to pick the right data structure with ease. I argued that this neglects a major uncertainty of real life applications and that you should not call someone stupid because he admits that it is damn hard to choose "the right" data structure. BTW. Lots of large projects live on HashMap and ArrayList alone because basically all the heavy lifting is done in lower level tools like RDBMs, search engines, etc. And before you start shouting "performance!!!" watch what Stroustrup has to say for linked lists. It's a matter of fact that current day hardware works damn well for arrays and much less well for anything else. Everybody sane wants more typesafe data structures in Go. But they should integrate well with the rest of the language. Up to now lot's of proposal for a syntax for generics have been brought up and all have weird problems on edge case and most people do not want a C++ style 2000 page spec with 800+ special cases for Go.
Thanks for the pointer. I've started looking at the examples. I'm having some trouble getting them to run, so I'll play around with them and start exploring the package as I trouble shoot the errors. By that time, I should have a better understanding of what is going on, and I'll start documenting.
Erb is itself an abbreviation of "Embedded RuBy", so in the general case, I woudn't expect an erb template to be executable in anything but Ruby. You've basically got three choices: 1. If the templates are _really_ stereotypical, you might be able to either write or modify an existing template solution to run _your_ erb templates. I emphasize "your" because it is not a solution for running "erb templates", but just your very specific ones. (Note Go does have [a number of template libraries](https://godoc.org/?q=template); there's a lot of false positives in there because this is hard to search for, but there's a Mustache renderer, some Go-only template solutions, etc.) 2. You could rewrite the templates. 3. You could run a Ruby server that just renders the templates. Unless you're looking at a _super_ high performance website, this is probably fine. There's also a hybrid solution where you start with #3 to get going quickly, but rewrite the important ones incrementally. I'd also observe this is not "Go's" fault per se; it is a generalized problem with using language-specific templating libraries. As much as I like a lot of the design decisions of Go's html/template in a lot of ways, there's a strong case to be made that you should almost always prefer to use something like Mustache templates that are widely cross-platform. In fact, you'd even be able to convert your templates into Mustache, make various modifications to them, and then decide you're going to stick to Ruby, or switch to some other language, and you wouldn't lose your work. And html/template and text/template are definitely Go-specific, with some very Go-oriented behaviors in them.
Yeah, I would definitely suggest the generator needs to be able to use pre-existing types that it doesn't insist on generating itself. You'll want that for other reasons. I would also suggest that you read up on what it means to be a [hygienic macro](https://en.wikipedia.org/wiki/Hygienic_macro). It may not be immediately obvious to you why I suggest this, since it will be discussed in terms of languages other than Go, but it is a generalized problem that code generators face. It will help you understand the landscape you are working in. (You face the additional problem that you want your identifiers to be human-readable and useful, which adds its own additional annoying issues.)
I don't expect you to read this and stop, but maybe just squirrel it away for later reference. The problem with this sort of approach is that it initially looks like it is working well and is very promising, but eventually you start hitting problems with the differences between the semantics of the two languages as you start throwing more code at it. But the first few times you encounter them, you are able to pound through them, albeit with some somewhat weird and funky code. Then you hit the next layer of problems, and you can still pound through them, but it's starting to get hard; some of the weird hacks interacted with some of the other weird hacks, but then you put some thought into it and managed to find a single weird hack to integrate them both. Maybe you get to the point that you feel pretty good about it, and you release it and are feeling pretty confident. Unfortunately, the first 5 people who tried it _all_ immediately threw some Go code at it that you weren't expected and they all experienced various failures. You analyze the problem, and it's hard, but you think you can fix it. It takes you five times longer than you thought, but you finally get about 90% of what they were trying to do squared away, and release it again. Then in the next 50 users, 10 of them experience even more problems, and when you first read them, you despair of ever fixing them. But maybe you decide to try, and you pour months of effort into it, every day convinced you are just a week away from finishing, but, well, actually, now that you look at this it requires you to rewrite your entire approach... but once you do _that_ it'll all be done and squared away, for sure. You finish 95% of the rewrite and are getting down to the last few bugs in the regression suite, when the third-to-last-one, one you've just sort of been putting off because you're pretty sure it will be easy, ends up convincing you after two days of examination and a week of agony that your entire rewrite was flawed, and actually you need _another_ rewrite. Or for bonus agony, that you were better off with the first design. _That_ one hurts. At some point around here you realize that you're never going to get past 98% accurate, which is, unfortunately, essentially unusable for any non-trivial task, and also somewhere around here you realize you'd actually have been farther along if you'd simply written a Go interpreter from the get go. You also realize than even in its current state, the only person in the world who can understand the code even in theory is you (and you're not always too sure about that), and it's going to get even worse before you're done. As I said at the beginning, my intention is not that you read this message and immediately quit. I know _way_ better than to expect that. My intention here, as someone who has been down very similar roads before, is to hope that when you start to realize that this is what your road looks like, that you get off the road months or even potentially _years_ before you would have if I hadn't written this message. The good news is that if you get off soon enough, you can very justifiably chalk it up as an extremely educational experience, you have a _stellar_ demo to show any future employer (and the better employers will also be impressed if you explain to them some of what I said above to them), and hopefully you also had a lot of fun. Or maybe I'm just totally wrong, and maybe I'm being a discouraging asshole whom nobody should ever dream of listening to and should probably have my Reddit account revoked for being such an asshole, and also my breath stinks and I really should run a comb through my hair sometime. I will say that if I am going to be wrong, paragraph 4 is the real cutoff in my story here; if I'm going to be wrong, you'll never get there. If you do get to that point, though, I'd encourage you to give some serious thought way back a year, year and a half ago when you read this post. I put the effort I did into this post precisely because I respect both you, and future you, respect you enough to try to help you avoid a trap I fell into myself a couple of times, not because I'm trying to score pointless internet points.
For example, a non extensible CMS where i hard code stuff that comes out with a template engine, querying from a DB. Nothing fancy.
Well, sometimes i miss static typing, i tend to cast a lot of stuff in PHP to ensure that i push/pull exactly what i want.
.Tthanks for your answer. I don't care a lot about fancy front end programming, most of the time a simple form is more than enough for my purposes. My question is about the tradeoff hosting solutions/content managing/time worth spending on using Golang instead of PHP.
That's exactly what i do. I switched from PHP to Go. I love Go. I've built up a core system with some code generation that allows me to quickly develop the backend. Including simple HTTP cache and even a system that allows me to a/b test. I'm by far not a good coder and i bet if i'd open source my code people would shit all over it. But it works for me and i try to improve it whenever i can/learn something new. I don't see a reason to ever switch back to PHP tbh.
This is an (unauthorized?) copy of https://www.youtube.com/watch?v=_YK0viplIl4 The talk was held by Sameer Ajmani at dotGo 2017 in Paris. please support the team of dotconferences and watch the talks [there](https://www.youtube.com/channel/UCSRhwaM00ay0fasnsw6EXKA) 
You may want to look at: https://github.com/d4l3k/go-pry ... if you haven't seen it.
Much thanks. Feel free to hit me up on chewxy [at] gmail.com if you need help. Or twitter
btw, the project has been updated to support io.EOF too: https://github.com/machinebox/progress 
Are you github.com/thejerf ? If so: 1. Suture is awesome. I use it all the time. Thanks! 2. What's the word on reign? If not: 1. I wish you a jolly good day In either case: 1. Great comment, upvoted.
Ponzu sounds cool! It would be even greater for me if i could bind the content to a template, bypassing the /content api :D
in that case, go's templates are going to be very limited compared to php
PHP’s supposed hosting advantage is moot nowadays. Get a $5/mo VPS and your Go app can easily beat some shared hosted PHP for ease of deployment. 
Had the same idea but with DNS server.
Agree fully. To this end I think it's really nice that we will have `json.Decoder.DisallowUnknownFields()` in `go 1.10`. I personally plan to go from furious to mad with that upcoming change.
Can you give a bit of context what data you are representing? In general I think of it as a smell for the precision reason whenever I end up with a float as a key
I really wanted to make an auto updating status tool, so I decided to make one to monitor Cryptocurrencies! I'm not sure how "correct" my code is, but it does work. I've only been making stuff in Go for about 2-3 weeks, so if you have any advice or tips on how to make this better, please let me know!
This. What is the exact nature of the problem you're trying to solve? You've described *how* you want to solve it, but not *what* the problem really is. What does the float canonically represent? Why is the float the primary identifier for an "Element"? What *is* an Element?
&gt; Do you need nginx/apache in front of it, or is there a more simple approach? Either you're not asking the right questions here because you haven't done your homework... or you're hiding some aspect of your design that would help us arrive at the right answer for you. I fear you'll have larger problems than figuring out how to deploy your service: namely, securing your cloud instance. In researching what it takes to securely deploy a service, I guarantee you, you'll find the answers to the rest of your questions. The simplest deployment is to push the executable to your node and register it with systemd or whatever. Even better, use `runit` to ensure it never stays down should it panic. Pop a hole in your firewall for the service and you're done... until someone discovers the hole. 
I'm well aware of the security implications, this is simply to prototype a react-native app for a few minutes at a time. I don't care if anyone else gets the data in that period, it isn't secret(it's publicly available elsewhere anyhow)
My question is how you in practice "expose" a Go endpoint in a docker container, inside a google cloud instance to the static IP attached to this instance. I know how to expose the port from the docker container to the host instance(so it will be localhost:8081/stocks on there, too) - but how would you tie that to the IP that can then be accessed from anywhere? I've been coding for like 16 hours in a row and my brain is about to explode. Sorry for extremely shitty explaination :D
Spinning up an Ubuntu instance, running Docker on it hosting your single REST API endpoint Go app in Google Cloud Platform is a little bit overkill on a few levels. Save yourself pain and suffering and just use [Go on App Engine](https://cloud.google.com/appengine/docs/go/) where you pretty much only need to worry about your Go code and little else.
Well yes, this is one bit of functionality to learn if you so desire and it scales really well for cheap :) If you're doing docker you might as well let the platform handle it for you with Kubernetes. Yes, the App Engine requires you to download and install an SDK, but I wouldn't say 'all sorts of stuff'. The [Quickstart for Go](https://cloud.google.com/appengine/docs/flexible/go/quickstart) will take you all of 5 minutes to run through including setup and the [Helloworld Go App](https://github.com/GoogleCloudPlatform/golang-samples/tree/master/appengine_flexible/helloworld) as part of that is almost too easy.
Cheers. I'm a bit stubborn and I have to make this first thing when. Obviously App Engine appears smarter(I realize that now), and I will use that later on. After I make this shit work. And catch some sleep.. Thanks :P 
This seems to be a very docker specific problem/question you are trying to solve. If its a POC, I would suggest you spin up a micro instance, just drop the binary and follow [hell_0n_wheel]'s advice to keep it running always (even after panics). To make it a little more secure so that you dont have to expose the static IP, use cloudfront and https the cloud front endpoint (under an existing domain if you have ready access of its DNS setting). Using a docker instance for a POC might seem like an overkill.
How about a GraphQL server? https://github.com/neelance/graphql-go
Note sure what your data is, but you could change it to be: [ { “key”: 1.23, “value”: “test” } ] I do this whenever working with collections of things that seem like k/v pairs in an API, since it’s much easier to add metadata to each item if needed.
Hmmmm... Manage to deploy it alright, and it listens on :8080.. But going to the URL(https://project.appspot.com), I just get an nginx 502 bad gateway. Any idea what it could be? My app is very minimal in that regard: func stocksHandler(w http.ResponseWriter, r *http.Request) { // Set content type: w.Header().Set("Content-Type", "application/json") enc := json.NewEncoder(w) err := enc.Encode(MarketDataMap) fmt.Println("request made") if err != nil { http.Error(w, err.Error(), http.StatusInternalServerError) return } } func StockMarketDataController() { http.HandleFunc("/", stocksHandler) log.Fatal(http.ListenAndServe(":8080", nil)) } Shouldn't this work? It works fine locally, as least for producing the json on this port. 
This is cool, but does require that we have the expected size of whatever we're reading beforehand.
There are also downsides to strictness, though: You are giving up backwards- and/or forwards compatibility. There's a reason, for example, proto3 got rid of `required` fields: It turns out, that more often than not, you reconsider at some point and change it back optional (or vice versa). But now, you are having a problem: There might still be code, which will fail a parse, if the field is not provided; and even if not, you might have to rollback a change and thus re-introduce code that then can't handle the changed data-format persisted to disk. Similarly for `enum`: proto3 changed the semantics to always having a default value for that and to require implementations to cope with out-of-bounds/unknown enum values. The reason, again: You will, in general, at some point decide to evolve your API and given that you can't upgrade multiple services atomically, the comfort that all your services will be able to deal with the new values/absence of old fields gracefully will be *really valuable*. And all of these decisions are born out of large-scale production experience and many real outages; so no, they are not made up or artificially constructed. I find it a bit surprising, that the authors apparently use gRPC, but don't seem to mention that this kind of compatibility is a) a direct design goal of protocol buffers and b) in more or less direct contradiction to their argument. I'd also argue that their example isn't well-chosen. It would seem to me, that if you have a line of code like this args[“num”] = args[“num”][:2] (even ignoring that the slice is the wrong way around) should simply give you pause. This code is *obviously* not robust against evolution of your API and there is an obvious fix here: Just sum over all the values from the beginning. Yes, the example is artificial and it won't always be so obvious of what the correct thing to do is, but that just confirms the example is bad. In practice, yes, it is a *hard problem* how to evolve your APIs, but the correct solution is to *always* make sure, that the evolution you make is backwards- and forwards compatible. If you assume that every service will gracefully ignore unknown arguments, then you can build migration strategies based on that assumption.
Thanks for your (and the others) feedback, knowing how to ask questions is an acquired skill I am working on. I edited the question with more explanation what the data is. Ideally "1.23" would be a key, as the timestamp.
After reading the edited question, here's my suggestion: don't use a map at all. It sounds like you're trying to describe a linear series of events, by timestamp. Why not use a *list* to the tune of [this](https://gist.github.com/therealfakemoot/586bc5dfcfcd36d04b67dd130e0584de). The events are ordered, so they should be in a sequential data structure.
Use -p 80:8081 to expose the container service on the host http port. Then you will need to allow traffic to port 80 using google cloud network settings. Open the instance then click edit and then under firewall check allow http traffic. 
Thanks nevyn. I had seen it. The difference between the two projects has to do with both the front end and the back end. To have a true, incremental, state-maintaining interpreter, one needs to modify the front end parsing libraries. That is what I've done here. `gi` uses modified versions of the go/types, go/ast, and go/parser libraries to achieve this. On the back end, LuaJIT maintains state between each run of the front end on each new command. Ultimately the aim of `gi` is to enable interactive data exploration, and so we must maintain the data (state) in memory between statement execution. Avoiding the re-compile after every new statement is essential. While go-pry can let you view the fixed code path one is on, it doesn't let one change that path without a full restart. Hope that makes sense.
That's okay. You CAN store the values post-processing and *before* JSON output in a Golang map using floats as keys, if you want. Then you can sort the intermediate values into chrono order and dump them into JSON after the video is done being processed.
Thanks for replying. We should avoid using language-specific template engine in the future.
To be clear, this was always computed at compile time, not runtime, but now it’s also more efficient when the compilation happens. I was reading the code for the Unicode runenames x module the other day, it suffered from slow compilation because of this issue. 
[Buffalo](https://gobuffalo.io/), with Plush, looks like some of the Rails code I’ve written. `form_for`, in Buffalo, looks very familiar. You may want to consider using Buffalo to make it easier for your team to move from Ruby to Go. 
The top level JSON value would be a list, not a map. The top level list will contain objects/maps which would have a timestamp attribute among others. You've got a bunch of goroutines all processing stuff and identifying things and when they appear, right? While you're processing them, store them all in a map. Once all processing is done, take that map and iterate over the keys, sort them, and then use the sorted list of keys to create a slice/array ( I'm still fuzzy on the formal terminology tbh ), and then serialize that slice/array to JSON. Re-read my gist. There is no float key anywhere in the JSON marshalling structs.
The standard library templates, at least. Nothing says you have to [stick to the standard library](https://github.com/benbjohnson/ego).
I'm glad you like it! Another thing to note, you can use App Engine Flex and there's no need for a special SDK. Have fun!
People might want to see just two or three coins, and it's much easier to setup Go to channel them all to N workers to solve that problem.
I'd like to see the algorithm that usefully estimates the amount of time remaining in a transfer of unknown size...? (I actually played around a bit with the idea. It isn't necessarily completely hopeless. But I can't come up with anything in fine minutes that doesn't have behaviors the average user would completely balk at. So, time: I'm actually serious, not sarcastic. I'd be interested in seeing an algorithm.)
But API versioning is a thing, so your argument is really invalid.
Judging by your current requirements I also think that App Engine is a good fit for this project. The problem with App Engine is that as soon as you need slightly more complex stuff (say data persistence) you need to start using their internal datastore service. So you end up with a lot of code that only runs on App Engine.
In case you didn't know, you can provide custom functions in the Go templates: https://golang.org/pkg/text/template/#example_Template_func
Go templates may look limited at first glance but if you provide [custom functions](https://golang.org/pkg/text/template/#example_Template_func) then you can extend them greatly.
It's not. For the same reasoning, versioning doesn't solve the problem of API breakages, thus we came up with the model of [gradual repair](https://talks.golang.org/2016/refactor.article) ([see also](https://www.youtube.com/watch?v=tISy7EJQPzI)). If you release your service 5 times a week but your clients one time a month, if at all (remember, for example, that there are still devices out there using Android Froyo), you get *enormous* version skew. Gradual repair and robust, backwards and forwards compatible APIs can actually solve the version-skew problem, instead of pretending that it doesn't exist.
Easy! Remaining = duration so far + 5 minutes :) Accuracy within about 5 minutes, every time!
”arr.each” and ”a.present?” are Ruby, embedded into the template. You’ll need to do something as suggested by /u/jerf
Or you could just store the data in a language agnostic format in the database and then use language specific templates to present it.
Personally I'm happier I discovered grpc and grpc-web, once you get through the initial setup the convenance and knowing everywhere everything breaks at compile time including in typescript for any API change is a god send. 
go/constant isn't used by the compiler, but by static analysis tools such as go vet or staticcheck.
I mean if you prefer the flexibility of ERB templating, there are projects like https://github.com/SlinSo/egon that give you that flexibility. Basically it's code generation, but that requires a recompile and redeploy every time you change the template, even a little bit. Brings the "php way" a bit closer to Go, while keeping type safety. Needless to say, I follow my own advice from above here and use golang+vuejs, even if there are alternatives :).
Nice enhancements - I'd add a couple more very minor adjustments: - Save a few LOC by using range over availChan - Error on line 66 could also include the username we were trying to test - Given that we don't "do anything" when a name is not available, the else case on line 74 might be better suited to an early return, keeping the golden happy path code aligned.
What would that algorithm do? Just keep increasing the time if it goes above a certain limit? Something like adding 50% to the time when you get 75% of the way through? I just don't think it can be done generically. If you know the average size of your transfers (e.g. you can store information longer term) or do some metadata scraping (e.g. see if it's a PNG, mp3, HTML doc, etc), I could see you making a reasonable algorithm, but if you're trying to make something generic that doesn't learn, then it's not going to work out.
that's cool it sounds a lot like [seq](https://rain-1.github.io/scheme-1) that I blogged about here (in scheme, different language) 
Beware though: then you don't get the free tier. App Engine's "standard environment" is usually entirely free if you don't get a lot of traffic.
Absolutely nothing to do with Go.
Ah dang that’s the one I always manage to forget when using http. So if I get the body, I need to close the body. If I get the header, do I have to close the header? —- I definitely agree, I don’t really know what i was thinking wrapping together. — What’s the best way to do this? Log fatal, fmt println err, etc? —- Yeah, that’s true. My plan was to break it up into more specialized functions. Should I do that, or just move it to main? —- Shit! I even use go-vim and I forgot that was a thing! I’ll make sure to use this in the future. Thanks!
I want to license it -- do I have to license under GPLv2 as I ported most of the code from Git? Or can I use MIT/Apache2?
Nope, only have to close the response body. Update `getCoinData` to return a string and error Check the error and display however it makes sense. I'd probably stay away from log. fmt.Println is probably fine. You can move it to more specialized functions, but I'd still put them in main instead of doing a call to another function that calls all the others. No problem!
Sort of. The meat of the operation is handled by calls out to [wmutils](https://github.com/wmutils) (a collection of brilliant little window management utilities written in C), but the shell scripts that I was using previously to do this stuff were getting pretty unweildly...
*Go doesn't do &lt;insert feature&gt; like &lt;insert favorite language&gt;: it sucks !*
Damn, I didn't know about so many of those. I'm 100% agreed about [relative imports](https://github.com/golang/go/issues/15478) tho. Coming up on 2 years now.
Needs to be GPLv2 if you ported it. If you had written new code that just conformed to the gitconfig format, you could have used whatever license you wanted. 
More like *golang is pretty inconsistent in what it does, so it sucks*. 
Thanks! This is definitely something I'd like to do. It's using wmutils initially just because I was already using it, so it made a gradual transition much easier. But now that everything is basically working it would be nice to replace the wmutils calls.
That -1 / 2 example made me laugh.
Why do you need to store timestamp as a `float64`? If you don't need sub-second precision, just use `int64` with standard unix timestamp (`time.Time.Unix()`) If you need sub-second precision but do not need sub-millisecond precision, use what Java uses (`Unix() * 1000 + UnixNano() / 1000000`) If you really really need sub-millisecond precision (really?), store it as two `int64`s, which is essentially `time.Time`.
There are only two kinds of languages: the ones people complain about and the ones nobody uses. Bjarne Stroustrup
When I worked at an address verification company years ago, I wrote their first address autocomplete in Go. It was also my first Go project. The main problem was that pointers on 64-bit systems are 8 bytes, but the data on each node of the prefix tree was only one or two or three bytes. This made the structure horribly memory-inefficient for a then-experimental service on a small cloud instance. This inefficiency is true of most/any prefix trees. We found that simply using a 32-bit system nearly halved the size of the data structure because pointers were only 4 bytes, solving the problem. At least, until 32-bit cloud instances become hard to find. So I devised a data structure specially designed for address autocompletion. We split the address strings into components, and the possible values of each component were stored in arrays, without duplicate values. Then a master list kept as an array would key indices instead of values. We were careful to align struct fields and choose the smallest possible int types for optimal memory use. Lookups involved one more list, a prefix table, mapping the prefix of an address to a start index in the master list. Traversing that list for _n_ items returned the results. In the end, we got the address autocomplete database to fit in less than 2 GB of RAM. Lookups completed in about 700 microseconds, or up to 30ms if there were other constraints such as city/state, etc. With some other enhancements, we were able to account for typos, missing or added components (like directionals), variations on abbreviations, etc. Go's concurrency made this thing blazing fast (considering it was a linear search) and pretty easy. Thanks, Go.
No, memory barriers don't invalidate cache. They serialize execution, forcing instructions to complete before they occur, which costs a few cycles but isn't too bad. 
Heh, even then, the optimization you mention might happen. These are a good read: https://github.com/golang/go/issues/19182#issuecomment-281076863 https://github.com/golang/go/issues/5045
&gt; Have you considered just using VueJS, Angular or React for the front-end I see this type of response a lot in Go community. The answer for me is: well, I don't want to get into the javascript clusterfuck. Most of my apps only need server side rendering. I wish here something like Django or Rails for Go in the idomatic and community accepted way.
It always annoyed me that I have to protect access to bool read/write or the bloody race detector would not shut up about it.
Worth reading https://software.intel.com/en-us/blogs/2013/01/06/benign-data-races-what-could-possibly-go-wrong
The thing I didn't get about this or the first part was why this approach was taken. Yes, loading the full 181MB image into RAM each request would be slow. But you're using go, so you only have to load it once upon startup and keep it around, then you could directly pull the desired subimage from the single master copy in RAM each request instead of having to process multiple chunks from (potentially) disk and merge them each time. I suppose if you were deploying it somewhere where you didn't have a long running process, then the taken approach makes more sense.
Flat is duration spent on given a function and cum is cumulative of current function plus calls above it.
If a() call b() call ( c() and d() ) , c() takes 1s to execute and d() takes 2s so "cum" of b() is 1+2=3s? But how to calculate flat of b() 🤔
Go is not a systems programming language.
Correct, cumulative of b would be c + d. Flat would be c + d + anything else b does. It's possible that flat and cumulative are the same.
Fact #18 is not really correct: &gt; if you change your github username, you break every package that depended on one of your packages That's exactly what I was trying to do and unfortunately it didn't work. Github automatically sets up a redirect (`old_username/repo_name` -&gt; `new_username/repo_name`) for every of your repos. And even if someone registers that old username, the redirect still works until repos with identical names are created (after they are deleted, redirect starts working again). I.e. it's not enough to change your username. You must create repos with your package names under your old username.
TIL. Hadn't considered the multi-processor, non-shared caches possibility, which makes even aligned write not "intrinsically atomic".
Thank you very much TheMerovius. I realise now, many I/O calls are taking time and writing buffered also helps instead of writing to console. This helps.
Using: bufio.NewWriter(os.Stdout) did help, I replaced fmt.Println with fmt.Fprintln and I saw like 300ms improvement. Also I am not sure but I might be able to improve further if I read lines instead of words, split the spaces and filter out upper case words at this point itself instead of using bufio.ScanWords. Will try this. Thank you.