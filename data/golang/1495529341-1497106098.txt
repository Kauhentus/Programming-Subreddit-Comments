I'm way late to the party, but there's a good example of how a project I've worked on did things- https://github.com/euphoria-io/heim/blob/master/proto/packet.go#L789-L804 This is the method on Packet that gets the "payload" (the part of the packet that varies in structure from type to type) into the right struct and returns it as an interface{}. Based on the Packet.Type field you can immediately assert the correct type from there. payloadMap uses reflect and is defined here- https://github.com/euphoria-io/heim/blob/master/proto/packet.go#L135
Looks like DataDog to me.
from what I gathered so far, it's quite easy, yes. Here is the relevant page : https://msdn.microsoft.com/en-us/library/hh378426(v=office.14).aspx 
Written in Go, TiDB is a distributed NewSQL database.
Thank you. I was using the plugin for Newrelic (not the official one because $$). Wanted to see alternatives Thanks _/\_
If still is subject of interest I forked [SurgeMQ](https://github.com/troian/surgemq) and currently in active stage of development. Lots important features has been implemented (e.g. persistence). Take a look and welcome to contribute
Good idea! Do you use consistent etcd reads when using TiKV? What happens if I use another engine? 
Scary read
I might have got it wrong, but why would anyone want to convert the c code to go code??
this looks extremely helpful, especially for someone who has been using netstat constantly to monitor connections in go. Sometimes it's hard to tell why some connections won't close/etc and this seems like a great tool to help diagnose these types of issues.
Where I work we go back and forth and have settled on anything with go lives in the gopath (even if most of the code isn't go). It just makes things much simpler (and means that every dev has the same layout of code so we can write scripts that execute stuff relative to the gopath)
I might do the same :) Thanks!
That's great, but isn't MySQL capable of handle 1500 writes per second? (i am not talking by "default", but after tuning) -- But still it looks awesome!
C function call overhead.
If it's better than Galera then it has plenty to offer vs MySQL.
There are a few use cases I can think off. The main one in my mind is to convert custom, existing tools (binaries and libraries) that are not worth the time and effort to convert to Go unless you can use c2go to do the vast majority of the work for you.
True. I never thought about that. If there were small but high performance libraries that you wanted to use with new Go front ends.
we also have problem with 100 milliions of rows in our db and we decided to use elasticsearch. aggregation is fast but slow writes and no joins are making us code ton of workarounds. If this is as good as it goes it might be worth to take a spin. Anyone knows some drawbacks or using this in production? 
&gt; Just because you say it is, doesn't make it so... god you really just want to argue about things There really isn't anywhere else this conversation can go. And conversations are two sided, you can stop replying anytime, but you don't either. Tell you what, I'm just gonna go ahead an block you. That'll end it.
This release adds support for using multiple scripting languages (python, javascript, ruby, bash) + adding custom languages in the config. Custom color profiles have been implemented and can be configured in the config. The new YAML script header is lot easier to read and simplifies the parsing logic &amp; header extension. Two new builtins have been added: edit builtin, for quickly editing files on the commandline generate builtin, for generating standalone versions of the build scripts The globals have been refactored, to support a multi language setup. This version intruduces a new directory structure: all files that belong to zeus have moved into the zeus directory all scripts moved into the zeus/scripts directory The tests were improved, as well as the README, preview gif and overview graphic. Addionally lot of code cleanup &amp; renaming took place, come have a look! 
Nice, thanks! 
I wanted to use Gogland as my main IDE, I really did. But the "features" feel bloated and takes forever to index my projects, while VSCode starts up in seconds and lets me get to work. I have a feeling with time it will get better and I'll move to using it, but right now with Gogland I still feel like im fighting the IDE to do simple tasks.
When you say "doesn't have access" do you literally mean the call fails in code? Or do you just mean you no longer have the same env variables as your original shell env? If it's the later, the sudo command can be run with the -E flag to preserve the calling users environment https://linux.die.net/man/8/sudo
This is an environment problem rather than a Go specific problem. You must reconfigure your sudo environment to handle that. This question does smell like a [XY problem](http://xyproblem.info/). Perhaps we Gophers could be more helpful if you provide us with more context. I am sure we'll be glad to help you. EDIT: typo
`sudo` will clear the environment for security purposes. You can ask it via `-E` to preserve the environment. See [man sudo](https://linux.die.net/man/8/sudo). But if you are running your app as a privileged process only for the purpose of binding to a privileged port (&lt;1024) then you should consider giving the program the `CAP_NET_BIND_SERVICE` capability to allow it to run unprivileged but still be able to bind to ports below 1024. See [this answer](https://stackoverflow.com/questions/413807/is-there-a-way-for-non-root-processes-to-bind-to-privileged-ports-on-linux#414258) on StackOverflow.
It's a log of actions that cause changes to the data. The data doesn't change much once it is written, so the log doesn't grow much more than the underlying data. And we can just kill it and rebuild from our main data store if necessary.
Honestly, this may be out of scope for me. I had taken a stab at a few things, but ultimately after a few hours need a fresh perspective. Really hoping that someone who has experience with this can solve my problem!
It's a reinforcement learning method that evolves neural networks instead of training them with large set of data! If you define the evaluation function as a function that takes a neural network, makes it play a game, for example, and returns the neural network's score, NEAT will evolve a population of neural networks accordingly. There are several implementations on this already, but I thought Go would be a great language to support this method, since it has a great support in concurrency / parallel processing :)
Yep, sorry, the article is just a fun story about what happens when you use a lot of memory, and an interesting way around the problems. I deliberately don't go into detail about our exact use-case, motivations or constraints. I don't think a "normal" database will ever perform well enough for the question we're currently asking of this code. I have some hopes for dgraph, particularly if we change the question to something more sensible! 
Hi, I'm the creator of the Pixel library (https://godoc.org/github.com/faiface/pixel), in which I was recently implementing the text support, so I've gained some experience with this. First of all, I suggest not using the freetype/truetype package so directly. Instead, I suggest using the truetype.NewFace(...) (https://godoc.org/github.com/golang/freetype/truetype#NewFace) function, which generates a font.Face (https://godoc.org/golang.org/x/image/font#Face) value, which is much easier to use. Then, you need to learn how typing works. To type a string, you need to place a rune, advance by the proper advance distance, apply kerning between two following runes. Methods in font.Face will allow you to take the bounds of each rune (without actually placing it). By taking the union of all of the bounds of all runes, you get the bounds of the whole string. So, all you have to do is to loop through the runes of the string, apply advance and kerning properly and accumulate the bounding rectangle. Perhaps a code from Pixel could help too: https://github.com/faiface/pixel/blob/master/text/text.go#L172 . It uses some extra abstractions, but should be quite clear what it does. EDIT: I'm not exactly sure I answered your question. If not, please clarify.
vim is what I use for a lot of things like C, C++, etc. , but I need a reliable debugger for the application. Gdb does not do that great.
No, that's how GC for "unmanaged" languages like C work, because the GC can't make any assumptions about what is in random bits of memory ... but Java, python, etc. can just track which things are objects/pointers and look at those. I'd assume Go would be able to do the same.
This is ridiculous. First item listed in the "Security" tab claims a vulnerability in linux-libc-dev-3.16.43-2, following the link to the CVE https://security-tracker.debian.org/tracker/CVE-2014-9940 says it's a use-after-free in Linux kernel GPIO API.
Great post name. 
Have you checked out CockroachDB?
&gt; I have to use sudo because I'm implementing https on :443 No, you don't. a) Run the app on port 8443 and use something like iptables -t nat -A PREROUTING -p tcp -m multiport --dports 443 -m comment --comment "300 redirect port 443 to port 8443" -j REDIRECT --to-ports 8443 b) sudo setcap cap_net_bind_service=+ep your-app-binary c) any one of the other solutions you can read about on https://www.google.com/search?q=linux+user+bind+443
Thanks, all of the comments helped me in using cap_net_bind_service, but thanks for the port routing information - I had thought about using that as well. 
You don't need a repo to not build on deployment. You build the images locally and copy them to your staging/live servers. You can google for this yourself, but here is a quick find reference I found to get you started... https://stackoverflow.com/questions/23935141/how-to-copy-docker-images-from-one-host-to-another-without-via-repository
I wrote a very similar application, first was in python, then rewrote it in go. Performance was night and day better in the go version.
The guru tool can answer the "implements" question: http://golang.org/s/using-guru
What about print?
Are you using it? What i like about elasticsearch is that even if search and aggregate sucks it is instant. I.e. I can query top n entries in few ms on single node. Id sacrifice few of those ms for joins. 
In any case I don't think it is possible to derive that information without traversing through all packages, retrieve all interface types and checking against each of them. This is sort of what [guru](https://github.com/golang/tools/blob/bf4b54dc687c73b6ef63de8b8abf0ad3951e3edc/cmd/guru/implements.go#L108-L163) does.
guess you did not like the mascot peterbourgon?
Right, do the following: use the freetype library, specifically use `NewFace` in https://godoc.org/github.com/golang/freetype/truetype, using this `Face` you can setup https://godoc.org/golang.org/x/image/font#Drawer and fill out the `Dst`, `Src` and `Dot`. Now you can use `MeasureX` and `DrawX` separately. This is easier than using `Face` directly. So, before you setup `Context`, you setup instead a `Face` and pass this to `Drawer`. `Src` is your foreground color, `Dot` the position to start drawing.
Will do :) thanks
Looks like TiDB is your good fit. The write can be very fast, tens of thousands write per second, depending on your cluster, and it supports join. You may want to get [TiDB](https://github.com/pingcap/tidb) and test it in your scenario. 
Nice post. Side note: on big screens (2560 pixels wide for me) the font really gets HUGE on your site. It scales nicely for small screens, but perhaps specify a maximum font size for large screens?
Just for personal use so far but they're ready for production, they're also working on distributed joins :D "When CockroachDB distributes a join, it loads the data from both table operands simultaneously and in parallel on multiple nodes, performing multiple parts of the join on different nodes of the cluster, before merging the results towards the node where the query was received from the client. This way, the join can be theoretically sped up by a factor linear in the size of the cluster (in the ideal case)." https://www.cockroachlabs.com/blog/better-sql-joins-in-cockroachdb/
I was reading their issues and it looks like tidb is still in beta a bit. Things like queries can run only once scare me a bit. But its worth a try 
No: https://github.com/golang/crypto/blob/master/ssh/keys.go#L776 That's a bummer. Someone should hack on Go issue 18692. -jeff
Thanks, I was not able to find that information. I guess I can try to detect/check that error and then use ssh-keygen -p, prompt for password, change/blank it and then use that key. Or something like that :)
Maybe decrypt it using https://golang.org/pkg/crypto/x509/#DecryptPEMBlock first.
This is correct. You can strip the password, create an in memory key and use that.
Great, so I can Decode key with encoding/pem , check if key is encrypted with IsEncryptedPEMBlock , prompt for password with use ssh/terminal.ReadPassword, then DecryptPEMBlock and use that. Thanks a lot, will try that.
This is pure gold and describes reason why I switched to Go: "They were going to tell us what was coming in C++0x, as it was called at the time. (It's now known as C++11)... ...In the span of an hour at that talk we heard about something like 35 new features that were being planned.... .... At this point I asked myself a question: Did the C++ committee really believe that was wrong with C++ was that it didn't have enough features?"
Whenever people start a language they get afraid they have to learn the genetics but it's funny when they complain about the lack there of then. It's always been about simplicity in everything. If you are looking for generics then yeah c++ would be your pick.
This is what MySQL Enterprise Monitor does pretty much. Very cool stuff, you could integrate master/slave management, monitoring data, read/write partitioning on your proxy and other neat stuff and have a fairly enterprise style tool here. 
It's still going to be needed to be trained, it's just using genetic algorithms to create the network topology and optimize the weights. It's mostly just an alternative approach to using backpropagation and will avoid the vanishing gradient problem. It still is going to need some unknown number of iterations of training (and the amount of time it takes to "converge" to anything useful isn't known, it's a stochastic gradient descent algorithm), and yeah you might not necessarily need a labeled training set, you're still going to need a way for it to evaluate how well it did or if it was correct/incorrect. So, for classification problems, yeah, you still need a labeled training set. For other things, it needs to be able to try to maximize a fitness function.
[mattermost](https://github.com/mattermost/platform) has a really nice code base. It uses Go and reactjs
that's why I said reinforcement learning. the method you're describing is supervised learning.
No problem. Build it and let me know when I can buy it :)
This is pretty cool, does it work across secure connections?
when I run the XOR example this I get these failures about 10% of the time: -------------------------------------------------------------------------------- Gen. 45 | Num. Species: 29 | Best Fitness: 0.0000 | Avg. Fitness: 1.2033 -------------------------------------------------------------------------------- -------------------------------------------------------------------------------- Gen. 46 | Num. Species: 33 | Best Fitness: 0.0000 | Avg. Fitness: 1.2041 -------------------------------------------------------------------------------- 2017/05/23 20:51:53 Invalid number of inputs: 2 != 3 exit status 1 -------------------------------------------------------------------------------- Gen. 37 | Num. Species: 28 | Best Fitness: 0.0000 | Avg. Fitness: 1.1684 -------------------------------------------------------------------------------- -------------------------------------------------------------------------------- Gen. 38 | Num. Species: 26 | Best Fitness: 0.0000 | Avg. Fitness: 1.1915 -------------------------------------------------------------------------------- 2017/05/23 20:51:05 Invalid number of inputs: 4 != 3 exit status 1 was going to open an issue, but I didn't know enough about the project to be sure it was a bug (like maybe NEAT fails to converge sometimes or something!??!)
Thanks, I will try it out.
Struct is a type, int is a type, string is a type. There are many types, but a struct is just a struct.
https://www.howtogeek.com/190897/how-can-you-open-and-edit-windows-.lnk-shortcut-files/ https://msdn.microsoft.com/en-us/library/dd871305.aspx
Unfortunately I can only think of the paper that I read.. :( Here's the link: http://nn.cs.utexas.edu/downloads/papers/stanley.ec02.pdf I hope that helps!
Here's a tutorial on how to do a for loop: https://tour.golang.org/flowcontrol/1
Minor releases are for bugfixes, not features. But anyway, ECDH is there, there isn't much else than ScalarBaseMult and ScalarMult in an ECDH exchange.
Ian Lance Taylor himself regretted that the plug-in feature was released in that state as he though it was "a mistake". The go team made a terrible mistake with the way plug-in works. edited.
the Go team needs to seriously consider rethinking GOPATH/vendoring/plugins and every other aspect of the build tooling....it just gets worse and worse...and no, `dep` is not a suitable bandaid Go isnt much better at this point than the "antiquated" tools it was supposed to replace
the work the `dep` team is doing is commendable...but `go get` will continue to exist and be broken by design...the Go team must either retire/redesign `go get` and invalidate all extant docs, tutorials, books etc...or allow `dep` to coexist with `go get` and constantly field questions resulting from the confusion on top of all of this, the foundation upon which `dep` builds, the `vendor` dir, is broken by design
I'm sure someone will respond far more eloquently than I can. However, I'll give my thoughts. Go is very much about just getting things done. Your limitations are worded in a way that is very... uh... academic. That said, I will address your points best I can. * There is no form of parametric polymorphization like generics, there is a pseudo top-type called interface{} to achieve the same which is apparently basically a void pointer. This has never been a problem in code that I write but I don't write libraries or containers. I write end-user type stuff. Implicit interfaces have, so far, worked out great for everything where the concrete type isn't set in stone. * Functions communicate exceptional state by return value rather than unwinding the entire stack (good) but Go opted for the bizarre strategy of using a product type rather than a sum type for this so in the normal case the second element of the product contains a null pointer and in the exceptional case the first element of the product just contains "garbage" This was really hard for me to parse. The language you use is not one I'm used to. I don't know what "product type" or "sum type" means but I can infer it from your usage. Returning multiple values turns out to be useful for far more cases than just returning an error and it is very possible to write a function where the first element returns something useful even when there is also a value in the error element. * There in fact are no sum types at all I don't even know what this means so I can't be very helpful there. * Everything can be a null pointer You can have a pointer to anything and pointers can be nil. I don't understand what the problem is. * Essentially there are a couple of "magic types" that receive special support like maps and strings that do implement parametric polymorphization and also work with some iteration syntax which user-defined types can never do. It is true that iterating with "range" only supports certain types. I think that's a good thing. It is significantly clearer that ranging over a struct or interface. It is also true that Go does lack a lot of syntactic sugar and, depending on your use case, may not be the correct choice. However, that lack of syntactic sugar isn't because it is backwards, but because it prioritizes clarity over brevity. 
Do a tutorial or two and see what you think, that's the only real way to get a feeling for it. It really doesn't take long, Go is a very simple language to pick up. It was created that way intentionally. If you're trying to write Java or C# or &lt;whatever&gt; code in Go, you'll have a bad time. The paradigm shift can take a while for some people, and others don't want to have to do so, because they like doing what they do how they do it. In that case, stick with what you like. But if you're willing to write Go code the Go way, then it seems to work out pretty well for a lot of people. Would I like to see generics in Go? Sure. Probably a couple times a month I'll say to myself "Hmm, generics would come in handy here." Then I just do it without generics and it works out fine. I've seen some good arguments against - and proposals for improving - Go's error handling. I really don't mind it as is, and even somewhat enjoy it. It does add a lot of boilerplate, but it's simple to read and reason about and gets you in the habit of handling errors where and when they happen. Why do I use Go? Because it's a really enjoyable language for the most part. Usually I'm doing something I'd otherwise use Python for. Static typing + good performance + excellent support for concurrency/parallelism + awesome standard library + single binary deployment make it fun, productive, and easy to use. If there's a question about a library that the documentation doesn't resolve, then it's really easy to just jump into the source and quickly understand what is going on, largely because the language is so simple. Composition/embedding and auto implementation of interfaces has been a pleasure to work with. I guess for the most part it's a case of "Nahh, don't need that" for a lot of things I previously would have thought I would need.
&gt; This was really hard for me to parse. The language you use is not one I'm used to. I don't know what "product type" or "sum type" means but I can infer it from your usage. Returning multiple values turns out to be useful for far more cases than just returning an error and it is very possible to write a function where the first element returns something useful even when there is also a value in the error element. A product type of multiple type is a type that is inhabited by ordered sequences of an element of all types. Essentially is a carthesian product of set theory. A tuple like `(Int, Float)` is the product of `Int` and `Float`. A struct like `{ int : Int, float : Float }` is the same as far as type theory goes in a different syntax. A sum type, typically written as `Int | Float` is a type that contains _either_ a member of one or the other type and not both at the same time. ML, Haskell and Rust, and other languages use sum types for errors so `ActualValue | Error` because obviously if there is an error there is no ActualValue and if it succeeded then there is no error. Multiple return values are an example of just returning a product type in practice. &gt; You can have a pointer to anything and pointers can be nil. I don't understand what the problem is. Making pointers nullable is famously termed the "[billion dollar mistake](https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions)". It is considered wrong because nil is not a valid member of that type so the type checker is essentially worth nothing. Any reference to anything can fail at runtime because of this with the type checker providing no guarantees.
&gt; Yes, there are no generics. interface{} is a "psuedo top-type" only because it's the empty interface, and everything implements nothing. "Basically a void pointer" isn't strictly true, because an interface value stores both the type and the actual value, but I see what you mean. So if the interface provides information about the type and essentially contains a tag which I didn't know? Aren't interfaces basically sum types then? I'm not sure how to extract the tag but it seems to me that a particular interface as a type then becomes a sum type for all members that implement it with the only weird quirk being that you can add types to this sum later. &gt; If you see an error, you don't use the other values. If you don't see an error, then you're fine. Without pattern matching, I don't think this is any more annoying than sum types. You're going to have to check for the error regardless. The difference is that it becomes part of the type system with sum types with or without pattern matching the type system provides guarantees about what you are dealing with. The type system doesn't stop you from accidentally using the garbage returned in the "unexceptional" slot. With sum types and pattern matching it ensures that you cannot even reach that value if it's not there. &gt; Not every language has sum types. Why is that an obvious flaw? Pretty much every language started in the last 15 years does because they are close to indispensible for creating certain data structures. If you rely purely on product types to create complex data structures you invariably just end up throwing the type system away and using void pointers with no sense of type safety. Like representing an AST without sum types is basically saying goodbye to type safety. 
&gt; Aren't interfaces basically sum types then? I'm not sure how to extract the tag Interface values are a "fat pointer", which contain a pointer off to the type information, and a value, which can be the data itself if it's small enough, or a pointer off to the data. The only way to access this information is through type assertions/switches (`.(type)`), or reflection. See: https://research.swtch.com/interfaces &gt; The type system doesn't stop you from accidentally using the garbage returned in the "unexceptional" slot. With sum types and pattern matching it ensures that you cannot even reach that value if it's not there. I agree that sum types are good in that way. But for Go, there are many tools that detect those types of errors. errcheck can tell you if you forget to check errors, and there are other such linters. &gt; Pretty much every language started in the last 15 years does because they are close to indispensible for creating certain data structures. I disagree. Adding sum types and pattern matching adds complexity to a language. Go is a very small language, which means that when you write something, its meaning is clear. I think that's valuable. If you're representing a large, complicated system purely in type information, then Go's not the right language. &gt; If you rely purely on product types to create complex data structures you invariably just end up throwing the type system away and using void pointers with no sense of type safety. I have no idea what you mean by "product types to create complex data structures". Before, I assumed you were referring to multiple return values. You can't just create data structures like that unless you consider structs to be "product types". And again, I don't understand why you're bringing up void pointers, and to say that ASTs without sum types is saying goodbye to type safety is wrong. Go is strongly typed. You can write code without doing anything nasty with interfaces, and the fact that it's annoying to bypass that system guides you away from bad practices. Java doesn't have sum types, but I would never say it's not type safe (even if I think the language itself is bad). It really appears as though you've already developed an opinion of Go before you came here or actually written anything. Again, you should really just try things out, then form an opinion. Go is not some toy language that nobody uses. It's very widely used by some very big names, and the fact that it's small and doesn't hide things from the developer means that it's easy to pick up and reason about.
&gt; It is considered wrong because nil is not a valid member of that type so the type checker is essentially worth nothing. Any reference to anything can fail at runtime because of this with the type checker providing no guarantees. I think that's really a negative conclusion. Just because a compiler doesn't detect null pointers doesn't mean that static typing isn't worth anything at all. Try writing Python or Javascript where you don't know anything until you run it, or some IDE goes through things to tell you where you may or may not have gone wrong. Largely, this is handled in Go through the errors themselves. You should never use a nil pointer haphazardly if you're properly returning errors and checking them. Go does not promote sentinel values, where you need to check for a bad result, because multiple returns with errors is just more convenient and clear.
It's awful really. That why it probably hasn't picked up yet and there's no major project to look at and say: it's done with Go. We literally write just quick throw-away 2 liners with it and then use a real language to get stuff done. Stay away from Go, it's not worth it. 
can someone define a new type that is not struct ? looks like macros in c++, i wonder if it works the same way
S3 and the instance storage are two very different things. At 8gb storage for the instance you are better off upgrading the storage of the instance before launching it or attaching an EBS volume to it. As for where you can write it, /dev/null is a good place to securely store anything.
&gt; In my C++ project, the guideline was to minimize use of exceptions to really exceptional cases. You are the stuck with the single return value, a problem you don't have with Go. &gt; not really a big deal in C++, you can return a struct with the result + the error if needed, just like C. multiple return values is just sugar. The problem with C++ is more how classes are implemented. But it's a good language, personally Go made me appreciate C++ even more.
[Less is exponentially more](https://commandcenter.blogspot.gr/2012/06/less-is-exponentially-more.html)
Awesome, thank you, nice work!:)
lol
Fantastic for REST application development.
&gt; If you see an error, you don't use the other values. If you don't see an error, then you're fine. Without pattern matching, I don't think this is any more annoying than sum types. You're going to have to check for the error regardless. Unfortunately, that's not 100% true. Sometimes a call might return both a valid value, and an error. E.g. returning what was read up until eol, and the EOL error. I find that odd and confusing. 
First let me start by saying that I respect your desire to stimulate discussion, and providing specific points for that discussion... But that being said, I find it a bit tedious to constantly read requests from newcomers to the effect of "I haven't done anything in Go yet. Please convince me to use it, and that the good points outweigh the bad posts". Why not actually just use it for a bit and form your own opinions as to whether these points actually are true? There are always going to be critics of every language, and there is obviously a community of active Go developers using Go on a regular basis. Something must be useful there. I came from 10+ years of Python, and I also develop in C++. Regardless of the criticisms, from a practical standpoint I find Go to be the most enjoyable of the languages I use in production. I can't say I have sat there "blocked" on the absence of generics, or issues with null pointers, or the absence of sum types. I take it these are things others really sink their teeth into and either legitimately can't work the way they want without their favorite features, or they have written a little bit of code and then wrote a blog post about "the facts". 
Probably
Isn't To() systematically leaking a goroutine ? https://github.com/jochasinga/go-promise/blob/master/promise.go#L65 
Why was this released so soon after 1.8.2, and with more fixes/changes? Could they not have been rolled in together?
Wow, what a tiny lib! Even the readme is longer than actual source code!
I use this almost always with go-resources, but it really doesn't belong in that repo, so I finally made it in a repo. It is tiny, but it does the job, and also serves more of a documentation tool than actually code. Consider it more of a blog post and reference, as per the readme warning. :)
My site, https://pocketgophers.com, is deployed on a single VPS and gracefully updates with git push. I described my setup at https://forum.golangbridge.org/t/best-go-dev-deployment-environment/4978/2
Security fix sure, but the comments on the issue about it don't seem overly concerned https://github.com/golang/go/issues/20040
Yes, but Python and Javascript are dynamically typed languages with all the benefits thereof. You pay the price of this runtime failure for numerous benefits like automatic polymorphism as you see fit. With nullable types you just get the worst of both. The runtime failures combined with the inflexibility especially because Go doesn't have a lot of polymorphism. Kotlin addresses this issue in a novel way by differentiating between `Type` and `Type?` where the latter is a nullable variant that can contain null and that case must be checked for in the type system. For instance `foo.bar()` when `foo : Type?` is illegal because you did not check or the null. You must actually use `if foo != null { foo.bar() }` or `foo?.bar()` for short for it to type check.
Hi, Thanks for sharing your code. Here are a few improvements that can be made: - make the code `go get`table. When I tried `go get github.com/ediston/gogameserver` I got: ``` package gogameserver/httpreqhandler: unrecognized import path "gogameserver/httpreqhandler" (import path does not begin with hostname) ``` - add a license - write documentation Finally, please understand that it's really hard to give feedback when we don't know what the code is intended to do. In this case you dropped 1300 lines of undocumented code. To do any more than I did requires reading and understanding what the code does in order to guess what you intended the code to do. If the guess is wrong, then whatever feedback is given probably won't be helpful. If you meant to have the feedback focused on your `redisclient` package, then you should have linked to it instead of the entire repository. Hope this feedback helps :)
&gt; Ah. Ok. I've always seen those called variants and I am pleased that Go doesn't have them. I think that a variable should have one type. It saves cognitive load. _Q:_ Go doesn't have feature XY, why? _A:_ Something something too much cognitive load. -- pretty much any argument rearding missing features in Go. Ok, snarky comments aside, let me also provide an actual answer: &gt; It saves cognitive load. A variable being able to be one thing or another is too reminiscent of PHP or javascript and, frankly, no thanks. The trouble with dynamic types is that one one thing can **unexpectedly** be something completely else and might be interpreted incorrectly. This problem doesn't occur with sum types, because 1) the range of available options is limitied and well-defined in one place, and, most importantly, 2) it's impossible to accidentaly misinterpret a sum type variable as something else. That just won't happen. The "less cognitive load" argument is bogus, because... well because "cognitive load" is in this context a meaningless buzzword, but apart from that also because the lack of sum types doesn't actually reduce "cognitive load" as it leads to _multiple_ variables representing one thing / one value. That is, in Go, you have _two_ variables for _one_ result of a function (which is either a value or an error, but typically can never be both). 
&gt; I have no idea what you mean by "everything can be a null pointer". He probably meant that there are no pointers that are guaranteed not to be null. Some languages have pointers/references that are guaranteed not to be null by their type. For example, in Kotlin `foo: Foo` is a reference to an instance of `Foo` that can never ever be null (guaranteed by the type system) and if you want it to be nullable, you use `foo: Foo?` In Go, Java and obviously C (and others), all pointers/references are by default nullable and there's no way to get non-nullable ones. (C++ has references that also are never null, but they can become dangling.) 
Ah yeah, forgot about channels! (I just checked and the codebase I'm working on only has 4 places it uses channels. They are handy but not something I find myself reaching for that often.)
&gt; Regarding errors, after a year of Go programming, I think that exceptions is an anti pettern. I think I've had experience with all the common styles of error handling and my takeaway is that they are _all_ terrible. I don't think it's possible to pick a "good" error handling style as all of them suck one way or another. Just pick your poison and hope for the best... 
In that case returning a product type is the right way though. Or I guess a sum of `CorrectValue | (PartialValue, Error)` would be even better.
Checked exceptions are fine in my opinion where what exceptions something can throw is part of the type of a function. The major arguments people have against exceptions is that they essentially circumvent the type system as the type of a function does not indicate what exceptions it can throw.
I use runtone.Caller in a similar way too but with a focus on [frames](https://github.com/cstockton/pkg/tree/master/frameof). It doesn't do much but 4 return arguments are unpleasant looking enough to justify both our packages I think :-)
To add to this. A dynamic can just be used as that type. Like say `print_line` accepts a dynamic string. If we give it a float instead it will fail at runt time but at compile it won't complain. If `print_line` accepts a string statically, giving it a `Float | String` sum type will not work statically. We must some_how first downgrade that type to a pure String and the type system often forces us to consider the case that it is not a string.
FWIW I always assumed that plugins would be able to travel. The end user shouldn't need a development environment to use a plugin from a third party. MS Office plugins work this way, for example.
On Ubuntu I've been using [GVM](https://github.com/moovweb/gvm) to switch between versions when needed.
We do something similar. We build the executable using Jenkins, and push that to ElasticBeanstalk, which is running the golang instance. This allows us to use golang 1.8, rather than the old version on AWS.
&gt; No need to be this passive-aggressive. You may not realize it but your opening post and many of your comments read passive-aggressive as well. You receive what you give.
I should say that what I meant was that after reading about the tech specs of how they work, I didn't expect them to travel at all. I am not speaking to the _desirability_ of that feature, just that I didn't see the sorts of things I'd expect to need to see for traveling plugins. It's a surprisingly hard problem when you get down to the nitty-gritty for non-dynamic languages, and surprisingly easy I think to specify a set of features that are simply impossible to work together.
The two part release enables companies to choose "security only" update or "security + bug fix" update. If there is a requirement to review all changes to code along with paperwork and such, the "security only" update will be a much easier update path. It is one sign that Go is a mature project. 
If you scream loudly about everything, people will pay more attention, right? ;)
So, just to go through this (not quite line by line) - There's a type called IPAddr, which is an array of 4 bytes. You implement a String() string method on (i IPAddr) receiver, which makes it satisfy the Stringer interface. the hosts map is a map of [string] to IPAddr, and uses shorthand to create the elements (just avoids repeating IPAddr on each value). You iterate through each one, and print out the key (string) and the value (IPAddr) using %v formatting. This formatting in fmt will look and see if the type satisfies Stringer, and will use that if present.
&gt; How would that syntax even work? It's really quite simple: branch function_that_may_return_a_partial_error() { case 0: correct_value { // do something with correct result }; case 1: (partial_value, error) { // do something with partial result and error }; } It is just a case statement that branches on the correct variants of the sum which in this case is an anonymous sum where the variants are purely determined by order. Inside of the blocks `correct_value` and `partial_value` and `error` are obviously bound to their respective values. &gt; And you want that? I mean, hey, to each their own but I like the clarity that comes with a variable having a single type. They are already returning two types, a product type is two types as well. With a product you just get something like: value, error := function_that_may_return_a_partial_error(); if error != nil { // do something with error and partial result } else { // do something with correct result } The difference is that you can accidentally call the methods of Error on the nil and then you get a runtime error which the type system can't protect you against. In the case of the case statement which statically only takes the branch of the correct type you can even access the wrong one if it's not there.
[What is REST (in simple English)](https://softwareengineering.stackexchange.com/questions/23891/what-is-rest-in-simple-english)
There's a huge difference between "sharding is the application's responsibility" vs "a distributed service provides an illusion of unified space, with automatic management and balancing".
I have a go binary running on an ec2 instance as a service. To push new code, I have a very simple shell script called deploy.sh. It does three things: (1) ssh's into our server to stop the service; (2) uses scp to copy the new binary to the server; (3) ssh's back into the server and restart the service. ssh -i ~/.ssh/[my key file].pem [username]@[server-ip-address] &lt;&lt;'ENDSSH' #commands to run on remote host sudo service [my service name] stop ENDSSH scp -i ~/.ssh/[my key file].pem ./.bin/linux-amd64/[my-service-name] [username]@[server-ip-address]:/home/ubuntu/bin/[my-service-name]/.bin ssh -i ~/.ssh/[my key file].pem [username]@[server-ip-address] &lt;&lt;'ENDSSH' #commands to run on remote host sudo service [my-service-name] start ENDSSH
Thanks!
Thanks!
Editing time would be great.
Interesting. What language is that? Also, it's worth noting that calling a method on a nil value isn't an error and doesn't cause an error. It is *normally* bad because methods with receivers normally use the receiver, but if it doesn't. No harm, no foul. Example: https://play.golang.org/p/YKPp749QPA 
Easy :) Gogland, https://www.jetbrains.com/go/ , can allow you to see which interfaces are implemented by a type (any type). It's a bit awkwardly named "Super Method" now but you can use it via Navigate | Super Method or via right click on the type you want | Go To | Super Method. Also guru should be able to do that but I've not used it :) Hope it helps :)
It's the entirely unpredictable and un-obvious path through the code that I find the worst. Dealing with that, you suddenly need everything to use scopeguard, Python's context managers and or RAII and you can still leave state in an almost unpredictably bad state.
The only thing I don't like about what's said in /u/TrueFurby's link is this: &gt; RESTs for exposing a public API over the internet to handle CRUD &gt; operations on data" REST apps work just as well on a local machine as they do across the internet, and they ABSOLUTELY DO NOT handle CRUD operations. REST apps should ABSOLUTELY be written in the HTTP verb set (PUT, GET, DELETE, POST) rather than the SQL verb set (CRUD). There is no direct mapping between CRUD and HTTP verbs, and the differences in what they mean make all the difference in creating applications. At the end of the day, REST applications are *really* just [HTTP](https://http2.github.io/http2-spec/) applications. Until a few years ago I understood to be a wire protocol. I was shocked when I learned that back in the 90's I apparently managed to miss the first paragraph of the HTTP spec: &gt; The Hypertext Transfer Protocol (HTTP) is an *application-level* &gt; protocol for distributed, collaborative, hypermedia information &gt; systems HTTP is an application protocol, not a wire protocol. Once you understand that, you'll find yourself thinking about application development in an entirely new light.
&gt; TCE I'm just going to admit that I have no idea what that stands for, and google isn't helping.
Tail call elimination. Sometimes incorrectly called "tail call optimization" or even more incorrectly called "tail recursion" which is probably where Guido got his idea from that it only matters or recursive function. But basically it's a thing you can use with some calling conventions where if you `return f(x,y,z);` as in call another function as the last thing and immediately return its value that the new function call does not get a new stack frame but re-uses the old stack-frame meaning that your stack does not grow if that's all you do. Hence the "recursion" part because a function can actually indefinitely keep calling itself that way and it will just compile to a loop with no stack overflow.
One more thing is cross compilation. Pure Go libs are dirt simple to compile for all os/archs. There are C cross compilers but not for all combos supported by Go, so cross compilation with CGO isn't possible in all cases.
I'm sorry, none of what you just said is true. I don't know what to tell you, man. I will say this: I can't say that reinforcement learning is NEVER supervised or unsupervised, as some set of data, either labelled (supervised) or not (unsupervised), can be 'involved' during the process of training. If the concept of neuroevolution intrigues you in any way, you should look into it, it won't fail you. It seems that there's a weird rumor/assumption these days that gradient-based methods are always better than evolutionary approaches, but it's not. I can promise you that.
I use it primarily as a backend for web apps (React client talks to Ponzu http API, or from a PHP/Node/Ruby/Go front-end). I released a Go client which is mostly ready for use if you want to use Ponzu with other Go apps: https://github.com/ponzu-cms/go-client Ideally there will be more turn-key client libs like the Go client for other languages in the near future. PRs welcome :) Other good use cases are: 1. HTTP backend for mobile apps - JSON response times are super fast and HTTP2 support with Server Push makes for a snappy UX. 2. Web form response collector - use the api.Createable interface from the system/api package and allow outside clients to send you structured data. (All the interfaces in api and item packages are super useful to extend the content types functionally - check those out in the docs) 3. CSV builder. This is a little bit of a stretch, but I recently had a client ask me to build an app that let them input data through a UI and download it as CSV. Ponzu has a CSVFormattable interface in the management/format package which enables all your public content per type to be exported as CSV through the CMS. Feel free to jump in to the #ponzu channel on Gophers slack (link in docs and on repo) if you'd like to discuss your use case or have any issues. 
Same here, automated via Travis CI. Works great.
lol, okay, I only took the class with the author of NEAT. Also, it is a gradient approach, the algorithm is a form of stochastic gradient descent... 
Honestly, if you did, I'm really jealous. I did see on Dr. Stanley website that he taught neural nets class and I always wanted to take it. But, really, I'm sorry, it's not a gradient approach. NEAT doesn't involve any computation of gradient of loss function (unless you decide to). I really don't wanna sound like bragging, but this field is what I research in. I will probably have to email Dr. Stanley soon. Just to be sure, I'll ask him about this discussion, then. I promise to let you know if I'm wrong. I'm pretty confident though. Good talk! Again, I really am jealous about the class. Damn.
Damn, nice to see the creator contributing in this Reddit \^.^ I was wondering: I saw that Ponzu bills itself as being great for rapid development and prototyping because it's a JSON API and an easy to use CMS. There's not clear upgrade path for apps that want to use Ponzu as a lightweight backend before migrating to a relational database once production loads start to grow. Would it be reasonable or possible to develop a plugin for Ponzu that acts as a middleware, echoing incoming requests to a relational DB to mirror the incoming data?
Gradient descent (or ascent, depending on whether you're minimizing or maximizing) is taking steps in the direction of the gradient (direction of greatest increase or decrease, depending again on whether your maximizing or minimizing). With each generation in NEAT, you're taking the top performers to move in that direction. It's stochastic because of mutations/crossing over that add randomness and variation (and hopefully this can get you out of local minimums/maximums), but you're still trying to converge in the direction of the gradient. So, what I'm saying that the NEAT approach is ultimately accomplishing stochastic gradient descent (or ascent) to minimize an error function or maximize some kind of scoring function. What I assume you're trying to distinguish is NEAT from what is involved in traditional backprop, where between training iterations, you compute the gradient of the error, and propagate it back down the network to adjust your weights. You're right, you're not doing that, but the process of training a neural network, regardless of what approach you use, is doing gradient descent (ascent) to converge to a network that solves your problem.
Why are you using a redis backend?
Yup. Insane hack that lets you write infinite amounts of data to your system
Take a look at Terraform, it's amazing.
I think you need to see this repo https://github.com/avelino/awesome-go that lists all Golang libraries and frameworks. Just go to the GUI section https://github.com/avelino/awesome-go#gui there is a lot of GUI libraries and frameworks.
&gt; So how is a product of two types not two types in the same way a sum is? &gt; We construct complex types from simple types all the time. With its product error mechanism Go is sort of trying to emulate sum types by just saying "You should not touch the first element of this type if the second contains a non-nill, you can, but really, you shouldn't" &gt; A sum type enforces this. You cannot touch the first one if the second one is there. The first one is unreachable in the type system itself You're missing the frequent situation where you want to return a partial result when an error is encountered. With sum types you would have to do `Result | (Result, Error)` which is less useful than `(Result, Error)` and quite frankly ugly... What more, it's rarely "meaningless garbage", usually the zero value is returned (`nil` for maps,slices,pointers, `""` for strings, etc.). I don't see how that is actually dangerous to return that when combined with a non-`nil` error.
gui is the big area where Go doesn't really do "cross platform" right now. There are several projects that tie to various toolkits via cgo or other mechanisms, but at this point I think the best way to handle to GUI is to expose your application via html and a browser.
This isn't a graceful deploy. For one, you're taking your service offline altogether to do the deploy. Even worse, if your deploy bombs at some point, your service is stuck offline.
I second that. Go as a backend localhost server and Electron wrapper that just opens localhost URL and gives an out-of-browser "native" app experience. Regarding HTML/JS/CSS there are plenty of options to explore from vanilla server-side templates to React to GopherJS+Vecty.
Also check out Augeas 
I'm not familiar with the AWS-specific stuff you're talking about, as I make my deploy process as vendor-agnostic as possible. As a result, I've really not much choice but to use an orchestration tool like Ansible or Chef. If ever you want to migrate away from EC2 (to save cost, to have presence in more DCs, better reliability, whatever) you might start looking at those tools now. If ever your stack gets more complicated you'll be happy you did your orchestration work now, when the stack's simpler... just sayin'.
True, we have a small base of users who use the platform during a predictable time period. For that reason, I usually run updates late at night and watch the process. It suites our needs but you're exactly right.
We use packer to create and AMI containing our binaries &amp; use terraform to deploy the said AMI to [ASG](https://aws.amazon.com/autoscaling/) which handles graceful rollout of new code. Biggest advantage of terraform is that it lets us sync AWS infrastructure (Lambdas, S3 buckets, SQS queues, RDS instances, etc) with our code. And it greatly simplifies AWS policy management as you can review all policies in one place in source code. If you prefer to roll out AWS infrastructure yourself, ASG + packer is easiest to set up robustly IMO.
Unless you want to have some fun and learn Go I wouldn't recommend this language for desktop GUI. 
save yourself some time and go straight to: github.com/therecipe/qt
Ah that's easy enough. Thank you.
Again without a full example to backup your difficulties and pointing to exactly which lines are causing the issues, it's hard to nudge you in the right direction. Your position about everything has to be created with async is an opinion, but it doesn't have to be the only opinion and it certainly isn't enough to decide to use another language instead. Did you look into reflect.SelectCase usage? Send data on an array of channels? Reuse channels when they are closed? That's a lot like multiplexing without explicit epoll imho.
I have been waiting for this for ages! Now going to re-write kssh in Go https://pypi.python.org/pypi/kssh/
Kubernetes! Quick install via terraform on AWS: https://coreos.com/tectonic
If you want something lightweight, I've heard good things about https://github.com/andlabs/ui If you are already comfortable with qt, go bindings exist for that.
http://github.com/golang-ui/nuklear And this one as well. 0 deps except platform (GLFW / GL ES / SDL)
Why? Go is more suitable for desktop GUI than even C++. If you look how Qt's internal event handling is organised, it's actually channels and everything is reactive. So Go's ideology perfectly fits there. If you meant that there is a little amount of Go packages, then I'd point that except Qt there is no serious cross platform GUI frameworks in other languages as well.
I've been playing with https://github.com/therecipe/qt recently and have really liked it. It's familiar if you've used qt before, and has great cross platform support. It also does a great job of putting all the platform qt dependencies in the build output for the target platform. 
&gt; it will fail at runt time We have all been there op. Being a runt is hard.
The runtime api makes prefect sense for runtime uses but it is not the best for _general use_. I think using this kind of small packages can help make code more self documenting.
...or don't, since we're already being flooded by apps that 1. have a hard time integrating into any OS, looking ever so slightly out of place *everywhere*, and 2. gobble up tons of RAM and CPU ticks to keep the whole thing running. Mind you, the HTML front end isn't *too* bad an idea (although alternatives were listed in other threads), but for the love of Pete don't cram an entire Chromium in there as well. Electron is the Flash of our age, IMO.
Check out this example: https://github.com/awslabs/golang-deployment-pipeline
How? Qt5 is LGPL.
\&gt; in a professional context. \&gt; posting on reddit. I guess reading reddit at work is a professional context, which would mean his comment is NSFW. 
It is just sum types...
Someone on the Gopher slack was asking about a lib to do this, so I threw this together fairly quickly to try to help them out. The original problem was basically, "How do I parse URL query params like `a[b][c]=2` into types in Go?" Rather than solving this directly, I first convert these types or URL query params into JSON and then use that JSON to to unmarshal into Go types. This allows me to leverage the JSON package a bit rather than trying to decode values myself. You can sort've think of this as the opposite of &lt;https://github.com/google/go-querystring&gt; I haven't used this in any production environments yet and I'm sure there are some optimizations that could be made, but it should be far enough along to get feedback and (if any exist) find out if there are better libs out there.
` &gt; 5GB Memory space` LoL
Hey u/its_boom_Oclock In the time you've spent replying to everyone's posts you could have read the entire language specification twice and realize there is nothing more to go than you see on the surface. It lacks the features you've listed and if that's makes the language awful in your book than so be it. 80 / 20. But it gets stuff done, quickly, effectively, with low memory footprint and is easy to reason about. You're wasting your time. Go is what it is. Simple, no nonsense.
s/all/alot/
But that's only once, for building the package IIRC
@SatumsVoid https://github.com/kataras/go-websocket is a nice library for your situation, it's syntax is familiar and very easy to use, especially if you have used socket.io before. P.S: I'm the author of this library and is being used on https://github.com/kataras/iris web framework too.
I agree, and I wouldn't suggest Electrum. Just regular "open your browser to localhost:12345" would be my suggestion 
Shiny is the semi official experiment into providing a cross-platform GUI library. https://github.com/golang/exp/tree/master/shiny An example: https://github.com/golang/exp/blob/master/shiny/example/textedit/main.go
It looks very complicated for what it does. Here's mine: https://github.com/nomad-software/bfg/blob/master/bfg.go
Everyone is having high hopes for shiny. Unfortunately the development is unbearably slow and the fact that it doesn't have its own repo makes things even worse as it makes it harder to track down progress or even know about the project's existence. 
I wasn't being passive aggressive. I stated facts. If you can't tell the difference that only further proves my point
centrifugo
No, you in no way engaged in the topic and just made it about the person. Regardless of what you called it you did _nothing_ to answer anything asked in the topic and really just made it about the person posting it.
I just looked at a programming test where someone used a non-boolean "or" return value :( It's not exactly the only example... * The issues with pip and easy install doing compilation persisted for years and wheels are only just picking up. * Concurrency and a humane pattern for async io have been issues that could have been addressed partially back in ~2003 with Stackless, but instead ended up with gevent, greenlets, tornado and generally a whole load of solutions that didn't entirely work together. I'm not personally a fan of TCE. I've seen a lot of people mess it up without realizing, which can then easily be the difference between working and blowing up if you're using recursion instead of a loop construct - but maybe that's just my memory of doing Scheme, which I think is terrible for readability. 
(thumbsup) 
&gt; So what exactly is the goal here? Seeing what kind of extra performance can be squeezed out of golang in this particular scenario. This isn't obviously for any real world application, but just a fun way to compare languages and contrast "effort" expended vs performance improvements achieved. Also, thanks for the profiling go programs link.
&gt; My guess is that Java is optimizing some elements of the function call away Right. People should keep in mind that just because Go is compiled to native code and Java isn't (initially!) doesn't mean Go will always be faster. Java has a very advanced Just-in-Time (JIT) compiler that compiles hot spots into native code on the fly. Since it's doing this as needed instead of ahead of time, it has access to additional context that can help it produce optimizations that Go simply can't.
&gt; I just looked at a programming test where someone used a non-boolean "or" return value :( Well in a lot of languages this is idiomatic and by design. In Lisp `(or exp exp exp exp exp)` for "return the first value that is truthful" is very standard practice. It's to get the value not just to test some logic. But lisp's have a saner system in this. 0, "", empty list,empty vector and what not aren't falsy. There is only _one_ false value `#f`, all other values are truthy. so `#f` is often used to communicate error of some kind. Like in converting a string to a number when the number doesn't parse. This is completely sane as the number `0` is not falsy. &gt; I'm not personally a fan of TCE. I've seen a lot of people mess it up without realizing, which can then easily be the difference between working and blowing up if you're using recursion instead of a loop construct - but maybe that's just my memory of doing Scheme, which I think is terrible for readability. Well, some languages have "explicit TCE" to ensure you don't fuck up. As in you must use some other construct than `return` like `jump` or `become` when you want the tail call to be eliminated. You communicate intent and if it's not in a position where the compiler will eliminate it it won't compile to solve the problem that sometimes people aren't entirely sure what is and what isn't a tail call.
Would you use Java over Golang if you want your program to be optimized on performance?
You haven't given us any details about the p2p application or your database schema. Generally speaking, Go should be a suitable choice for a p2p application. As far as the database goes, if you are thinking about a general purpose db, my advice is to stick with Postgres. It is usually better to think of mongodb as a cache and not as a general purpose database. You need to have a [very specific schema/requirements](http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/) to make use of Mongodb.
A small micro benchmark in one scenario is far from sufficient to make too sweeping assumptions. Java may allocate new objects with TLABs faster than c/c++ code, but that doesn't mean that java is faster than C. Just that in some situations certain things may be. Theres centuries of time put into optimizations of the JVM so its not something to dismiss performance wise because of some 90s FUD, but there are downsides to how it works that golang doesnt suffer as much from. Id be wary of worrying about micro benchmarks. Especially in java. While your application is small like that and in essentially a loop the JIT will compile that part and speed it up significantly. However if you have a full application running on other threads it may not. If your mostly concerned with just the optimal performance of small methods you should write your application in ASM.
Thanks for the link, it's a good read! But although the title is "Why You Should Never Use MongoDB" the author does explain in which cases mongodb makes sense. I guess that's why I like Postgres, it has SQL for the relational stuff and one can still use JSON for the unstructured data.
Go is basically what I imagined in the 1980s could be done to make C even better. Sometimes I don't want just a better C, but when I do want a better C, Go is it.
You'd use C or C++.
&gt; Making pointers nullable is famously termed the "billion dollar mistake". Ah, but: &gt;In computing, a null pointer has a value reserved for indicating that the pointer does not refer to a valid object. Programs routinely use null pointers to represent conditions such as the end of a list of unknown length or the failure to perform some action; this use of null pointers can be compared to nullable types and to the Nothing value in an option type. That's not how `nil` is used in Go, where `nil` is simply the zero value of a pointer. You don't indicate invalid pointers or error conditions by returning `nil`. Instead you have a separate error value, which you have to explicitly ignore to be unsafe. So in practice it's not the problem it is in C, Objective-C or C++, where an unsafe return of a maybe-null pointer is indistinguishable from a safe return of a guaranteed-valid pointer. If you're checking Go pointers to see if they're `nil`, you're generally doing something wrong. &gt; but Go opted for the bizarre strategy of using a product type rather than a sum type I'm familiar with `Optional` in Java, and I honestly don't see how wrapping the return type and the error return into a containing object makes anything better. You have to extract the error return and check it, and extract the value. How is that better? To me it looks like an ugly workaround for not being able to return multiple values.
I know a performance comparison of bigger applications might be more realistic and could have a different result, but its much harder to do that and for now it's just speculation.
For myself? No. In real code they tend to go back and forth depending on the nature of the inner loop; for instance, as I mentioned, Go already has value types. It's rare for a 2x general performance difference to matter because generally many other concerns dominate. Contrast this with the difference between Python and C; 40x differences in performance _can_ matter in the real world.
&gt; why don't just compile golang to JVM byte code Then it wouldn't be golang but gojava lol😆
I don't see why it matters if golang compiles to assembly or a bytecode if not for performance reasons (and fewer dependencies)
The JVM can pose memory footprint and GC tweaking issues; a well profiled go binary will simply be more streamlined. (I wouldn't presume dockerizing apps is suitable for all purposes.) If you want to use the JVM, why not just use JDK8/9 and some of the nicer modern libraries/frameworks? The language has become a lot more fun since the 1.6 days, even if it doesn't quite get to the goroutine and channel level of ease. 
[removed]
There are some things that go does to efficiently handle goroutines (fibers) that can't easily be done in the jvm without runtime bytecode manipulation. The jvm flatly doesn't have the right opcodes to make that efficient afaik.
&gt; So in practice it's not the problem it is in C, Objective-C or C++, where an unsafe return of a maybe-null pointer is indistinguishable from a safe return of a guaranteed-valid pointer. No, C and C++ guarantee that you can test for a null pointer with `if (ptr)`, a null pointer is guaranteed to be the only pointer where this test is false. A null pointer is the only invalid memory address you can in fact test for. But the type system doesn't stop you. `foo.method()` where `foo` is a null pointer isn't caught by the type system and errors out at runtime; that's the problem. In a lot of languages they guarantee that references can never be null so it always works and often have special nullable references that may be null as well and often the type system if you use a type that is nullable requires you to first extract the proper type with some check. &gt; I'm familiar with Optional in Java, and I honestly don't see how wrapping the return type and the error return into a containing object makes anything better. You have to extract the error return and check it, and extract the value. How is that better? To me it looks like an ugly workaround for not being able to return multiple values. Because Java doesn't have proper sum types and just hacked it in in a poor way where the type system doesn't protect you. Optional in Java is absolutely not a sum type as far as the type system is concerned. It is a dynamic sum type rather than a static one. Sumtypes go like so: branch open_file() { case Ok: file_handle { // do something with file handle } case Err: error { // do somthing with the error } } Note how the code braches depending on which of both it is so if it's the Error value you can never reach the slot of the Ok value because it's not even there. It's unreachable; that's what a sum type does, the slot does not exist as far as the type system is concerned. Only one of them can exist at the same time, never both. Apart from that every language has multiple return values including Java and C. You just return a struct or tuple or whatever.
Hey if he's on some porny reddit or /r/jokes or whatever who cares. But a programming reddit? Do we really need more of this juvenile bro bullshit here?
Java has threads with a fixed stack depth, while goroutines have a dynamic one that can be both expanded and shrunk. This is why deep recursive calls are usually slower in Go than in languages with fixed stack depth. This is also why goroutines are cheap to create but can get really big(aka have relly deep callgraph). Your example is actually falling into "tail recursion optimization" which is long overdue for both Java and Go. But alas...
No it isnt from my experience trying to port a Go binary to Alpine Linux which uses musl rather than glibc. But you can enforce static linking at compile time
Go has a policy of not implementing tail call optimizations https://github.com/golang/go/issues/15304 
&gt; That's like saying that C supports functional programming. No, because returning a tuple or a struct or "multiple return values" is fundamentally type theoretically identical. "multiple return values" is type theoretically the same as returning a product type. &gt; Again, I don't see how your sumtypes are in any way more convenient than They aren't, it's the same code is my point. The code doesn't get more or less verbose, the _type system_ now protects you. You can dynically simulate sum types with product types by just observing a gentleman's agreement to not touch the wrong value; with actual sum types the type system ensures that the wrong value is not reachable. You can just use the `fh` in your code in theory even if an `err` is non-nill and the type system won't stop you at all. With sum types that the `fh` is unreachable if there is an err so the code won't even run and you have that static guarantee.
The most important difference between JIT and AOT optimisation is that JIT optimisation can optimise to the *current situation*. If you, for example, have a function that can handle 10 different situations, but only 1 ever occurs, then a JIT will optimise the function to ignore all the other 9 situations entirely, with a guard at the top to check if the assumption holds. If the assumption ever fails, it'll reconsider its optimisation (or make a different version, switching between specialised variants). In the AOT case, the optimiser will generally just try to make your function as fast as possible while still handling all 10 scenarios.
Delivering applications as docker images isn't useful. It works for a small group of tasks, but most applications can't be shipped in docker images. The simplest issue being that docker is a linux-based container solution, while Go targets various BSD's, OS X, and Windows.
Reminds me of one of those logical CS questions where you should write a program that displays the first 10 numbers of the Fibonacci sequence and a guy in my class literally did: printf("1 1 2 3 5 8 13 21 34 55") and got full credit for that answer. I guess the Java compiler deserves some points as well.
Todd Mcleod's Udemy course is great. $15. 
If the Java compiler was this smart it would deserve a medal.
One day, the JVM will get *really* smart and figure out that my program can just be replaced by "throw new NullPointerException();"... Also, your teacher needs a thumbs up for recognising it as a correct answer.
This isn't really correct. Go doesn't optimise as well primarily because the compiler is very immature in comparison, with the entire compiler backend having been finally rewritten to a modern structure last year. Compiling fast is a goal, but while that blacklists *some* optimisation, it is not why the output is currently slow. Some features in the language also make it more difficult to reason about for the compiler compared to, say, C.
I know the benchmark might be unfair towards Java. But seriously. I made this post, because I'm wondering why the execution of the Golang program is so slow. Warming up the JIT could only make the Golang execution time look slower than it is now.
That's not really true. Compiling quickly is a goal of the Go compiler, and that results in very expensive optimisations not being considered, but the primary reason that the Go compiler outputs slow code is that it is immature. The compiler backend got reworked into a modern architecture as of 1.7 that should allow easier optimisation work, but that was just last year.
I actually wanted to benchmark Javas and Golangs performance on function calls (not necessarily on recursive functions). By reducing the function calls to one this benchmark becomes uninteresting to me. The best explanation I got is that the JIT compiler optimizes the code after 12 seconds and removes further function calls. If this is the case I would like to write another benchmark where the JIT compiler is not capable of removing the function calls after a while.
Web components &lt;3
how about trying https://github.com/chrislusf/gleam ?
Are there any params nested further than that? Or could you share the most complicated params you have to handle?
The thing about the long lived slices itches my brain. I wonder if the GC is classifying them in a different way than short lived slices, simply because they survive enough cycles to be heuristically "same lifetime as the application in general".
Sweet! I'm actually going to give it a go this weekend (never used it before) but regarding: &gt;I’d love to see folks post issues to the dep queue with their questions about how dep should be used to fulfill existing use cases and workflows. I'd like to know how dep will cohabit with git submodules, if there's any behavior to expect/not to expect. I'm also wondering if I can specify a specific commit from a git repo. For instance, I have a dependency that is being developed on a daily basis and only important releases are tagged. However, I often want to pull a specific version because it either add a feature that I want now or a bug fix that I need. I'm sure those questions will answer themselves once I try dep but I wanted to throw them out there for people to comment on.
[@joncalhoun's latest tweet](http://i.imgur.com/5SxlXJo.jpg) [@joncalhoun on Twitter](https://twitter.com/joncalhoun) - ^i ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
On the DB side, you really need to evaluate if you need a relational database. If you need relational and the amount of data will not go off the roof, stick to SQL (Postgres in this case). If the data is not really relational and/or you are talking about massive amounts of data consider NoSQL (MongoDB in your case). Just to give you a reference, I use SQL and NoSQL (MySQL and MongoDB) simultaneously even in the same projects for different use cases. In one project, MySQL stores about 2.5k brands, 150k products and 801k inventory items for those products and some other information. As you can imagine, these are all linked to each other (one brand has multiple products, each product has multiple inventory items, each inventor belongs to a different merchant etc). In the very same project I use MongoDB to store about 1.5 billion documents for geospatial entries which are mostly standalone. I use it to store location information continuously coming from GPS sensors on vehicles that are on the move.
That is so awesome, maybe you would become an engineer regardless but I wonder how many kids went on to I.T. thanks for a strong positive influence like that. Super cool, thanks for sharing :-)
With a friend we had to write a website for a literature conference very quickly, two weeks. https://2017.lhistoireavenir.eu We started at three, him at the template (he didn't know Go template before !), a third person for the text (markdown) and pictures and me at the code from scratch. What i liked a lot with Go is to can serve the docs, pictures, assets directly. Then i can translate the name of the doc to the ID of the page transparently. I didn't need to configure nginx more than redirect everything to the Go app. Finally we did it in the time and it was very fun. The result is simple, efficient, nothing more. It would be slower and a lot of pain to adapt a cms. It's an annual conference, we will have to do it again next year, i'm very confident to read and improve the code in one year. A lot less pain than with an heavy cms !
Perhaps [Forestry](https://forestry.io/remote)? It's a CMS for both Hugo &amp; Jekyll, although I haven't used it myself (yet) I've seen promising demo's of it.
I use just that though some Go DOM bindings to webkit would be awesome so that we can ditch JS.
Oh man this is great I will switch our repos right after the weekend. Glide is usable but it has so many annoying bugs, especially updating all dependencies in the lock file when you add a new one. This was the dep announcement I was waiting for. 
Have you completed the tour yet? It does an excellent job of teaching golang. https://tour.golang.org/welcome/1
hmm not exactly. I kinda know enough to do the backend and front-end stuff individually. However, I have no idea how to design, structure, and bring all these pieces together. I'll definitely check out the database stuff as well, thanks!
Why do you want those numbers? And what kind of function call? The worst possible contender is the *virtual* function call (not what you wrote, but something often seen in Java), which is extremely slow. A normal function call is going to end up simply being a statistical error in most code, and if it isn't, then neither Go nor Java is the right tool for the job. For a standard function call on x86_64, Go will just output CALL instructions, using a cdecl-based calling convention (arguments on stack, return value on rax). You're basically trying to benchmark a few single CPU instructions here. If that's your goal, you're going to have to do it in assembler. The JVM should do the same (unless it's a virtual function call), but you'll need to use `-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly`—which requires you to install hsdis—to figure it out. Trying to benchmark a function call through an optimising compiler is going to be tricky if not impossible to do. If you write a function small enough that time is primarily spent on function call overhead, any decent compiler will just inline the function, removing the overhead entirely. Recursion mostly avoids that, but in Go, you're going to end up accidentally benchmarking the dynamic goroutine split stack allocator as the call stack grows deep, which will break the test by prolonging it. In other languages (not Java, though), you'll trip tail call optimisation, which will break the test by making it *too short*, as it'll skip the stack allocation that happens for standard function calls.
Seems like it's you, not Go.
There is literally no single error that should *ever* wake me up at night (only if they reach a certain number, we can talk about that). At the same time, when I *do* get woken up, because we are serving too many errors, I definitely want to be able to look at the logs and see, where the actual "things that shouldn't happen" are. Warning is a pretty useless log-level, but all of Error/Info/Debug, in my opinion, perfectly describe what they are doing already.
It's an interesting observation about package managers. I found out a go1.8.2 was pushed this Tuesday via "pacman -Syuu". Then Tuesday night I went to my odroid-c2 to do the very same update via sources because there are no aarch64 binaries released yet. I git cloned golang sources and did a "git tag -l" to confirm the golang compile from sources was correct and it was telling me go1.8.3 was released and I compiled it on the odroid-c2 with bootstrap aarch64 I previously built for 1.8.2 on an intel box. Knowing this, the next day(Wednesday) I went back to my intel arch linux box and ran "pacman -Syuu" again, and go1.8.3 was already packaged for arch. I had no chance to download nor compile from sources there. Archlinux rocks! Funny observation: newer linux kernels however, I usually see the packages surface on Manjaro, then a couple of weeks, they surface on Archlinux, then a couple of weeks later, they surface on Debian.
"Fatal" could also be a good alternative name to "Error" - it sounds more severe so people would refrain from logging non-fatal problems at "Fatal" level too often. But still you could decide if a fatal error is worth waking you up at night. Maybe it is even better to only have two log levels: Fatal and Debug. When I worked in tech support, customers usually ran their systems with minimal log levels, and when they filed a ticket about some issue (a crash or something), we usually asked them to reproduce the issue with all log levels set to 5. So basically, logging was set to either "fatal errors only" or "as much as possible" but rarely to something in-between. Rather than differentiating between various log levels (although the system had five of them), we carefully chose which functional modules to include for generating a level-5 log. So if, for example, the scripting engine crashed, we could safely exclude all modules from logging that were not capable of running scripts. What I learned from this: Having many different log levels is less useful than having an option for each functional module of an app to switch log output between "fatal only" and "debug mode".
Originally I tried to figure out why Golang performs so poorly on this binary-trees benchmark: https://benchmarksgame.alioth.debian.org/u64q/binarytrees.html My guess was it has something to do with slow heap allocation and/or slow (recursive) function calls.
I have had some success with these GTK bindings: https://mattn.github.io/go-gtk/ The PyGTK docs are also a good source of information when things start getting more complicated.
The following code runs in 1.7s. The code is quite ugly :) package main import ( "bufio" "bytes" "fmt" "os" "strconv" "unsafe" ) func main() { var sumByKey = make(map[string]int) file, _ := os.Open(os.Args[1]) keyField, _ := strconv.Atoi(os.Args[2]) valueField, _ := strconv.Atoi(os.Args[3]) maxField := keyField if valueField &gt; maxField { maxField = valueField } defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() { line := scanner.Bytes() key, val := getKeyVal(line, keyField, valueField, maxField) sumByKey[string(key)] += val } var k string v := -1 for key, val := range sumByKey { if val &gt; v { k = key v = val } } fmt.Printf("max_key: %s sum: %d", k, v) } func getKeyVal(line []byte, keyField, valueField, maxField int) (key []byte, val int) { var i int var v []byte for i &lt;= maxField &amp;&amp; len(line) &gt; 0 { n := bytes.IndexByte(line, '\t') var b []byte if n &lt; 0 { b = line line = nil } else { b = line[:n] line = line[n+1:] } switch i { case keyField: key = b case valueField: v = b } i++ } val, _ = strconv.Atoi(unsafeBytesToString(v)) return key, val } func unsafeBytesToString(b []byte) string { return *(*string)(unsafe.Pointer(&amp;b)) }
Thanks for sharing, this is really neat. Can you explain why you cast the key to string, but use your function unsafeBytesToString to convert the val to a string instead? I'm guessing it's performance related?
I wonder if it could be possible to see the date of the revision in the lock file or dep status ? (i cannot find an issue about this) 
Cool example, thank you for posting. I ran it through the profiler as well and it seems the `Atoi` was being slow, so I found one on [SO](https://stackoverflow.com/a/27217267) which runs much faster by taking advantage of some of the properties of the integers in question: var atoiError = errors.New("invalid number") func atoi(s string) (x int, err error) { i := 0 for ; i &lt; len(s); i++ { c := s[i] if c &lt; '0' || c &gt; '9' { err = atoiError return } x = x*10 + int(c) - '0' } return } That cuts the time down to 0.37s for `getKeyVal()`, and the rest of the 1.52s is all `runtime.` stuff.
great way to get it started, thank you! &gt; I'd like to know how dep will cohabit with git submodules, if there's any behavior to expect/not to expect. Mostly what people mean by this is, "I have git submodules in `vendor`" - and that's not supported by dep (with one, narrow exception - https://github.com/golang/dep/issues/460). The reasons for this will probably become clear as you poke at dep, but basically, it adds very little (if anything) to the model, while creating a level-busting coupling to git. That said, dep does handle it correctly if your _dependencies_ use submodules. The parent, and any submodules (of arbitrary depth) will be correctly written out into your `vendor` directory. &gt; I'm also wondering if I can specify a specific commit from a git repo. Yep - when you first `dep init`, you'll get a `Gopkg.toml` with a bunch of examples in it that'll demonstrate how. This isn't the preferred mode of operation for any project which has its own dependers, because it tends to create brittle constraints. But... &gt; For instance, I have a dependency that is being developed on a daily basis and only important releases are tagged. However, I often want to pull a specific version because it either add a feature that I want now or a bug fix that I need. Yeah, you can specify a rev for this case. You'll end up with a fair bit of churn in your `Gopkg.toml`, especially if you're switching back and forth between the rev dependency and released versions. If what's happening is that these new commits are coming out along a single branch (I'd assume so?) then you can simply depend on the branch; a commit SHA1 will be recorded in your `Gopkg.lock`. When you want to grab the latest, you `dep ensure -update &lt;dep import root&gt;` (actually, this syntax [isn't quite ready yet](https://github.com/golang/dep/issues/277), but it's our next major roadmap item - for now, you'll have to just `dep ensure -update` and all your deps will move :( ), and `Gopkg.lock` will move along to the latest commit in that branch.
For those interested , below is the combined solution that /u/valyala and /u/adrake contributed towards. The code is pretty much identical, I've mostly just renamed some variables to make it a bit clearer what's going on. The average I am getting now running this is about 1.65 seconds compared to ~3.84 previously, so it's more than double the speed! package main import ( "bufio" "bytes" "errors" "fmt" "os" "unsafe" ) func main() { var sumByKey = make(map[string]int) file, _ := os.Open(os.Args[1]) keyField, _ := atoi(os.Args[2]) valueField, _ := atoi(os.Args[3]) maxField := keyField if valueField &gt; maxField { maxField = valueField } defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() { line := scanner.Bytes() key, val := getKeyVal(line, keyField, valueField, maxField) sumByKey[key] += val } var k string v := -1 for key, val := range sumByKey { if val &gt; v { k = key v = val } } fmt.Printf("max_key: %s sum: %d", k, v) } func getKeyVal(line []byte, keyField, valueField, maxField int) (key string, val int) { var i int var tabIndex int var k []byte var v []byte var field []byte for i &lt;= maxField &amp;&amp; len(line) &gt; 0 { tabIndex = bytes.IndexByte(line, '\t') // returns -1 if not found if tabIndex &lt; 0 { field = line line = nil } else { field = line[:tabIndex] line = line[tabIndex+1:] } switch i { case keyField: k = field case valueField: v = field } i++ } val, _ = atoi(unsafeBytesToString(v)) return string(k), val } func unsafeBytesToString(b []byte) string { return *(*string)(unsafe.Pointer(&amp;b)) } var errAtoi = errors.New("invalid number") func atoi(input string) (val int, err error) { for i := 0; i &lt; len(input); i++ { char := input[i] if char &lt; '0' || char &gt; '9' { err = errAtoi return } val = val*10 + int(char) - '0' } return } 
Good job building a thing, but you don't have to repost it every week. 
https://github.com/golang/dep/issues/663 Playing with Gopkg and status i also submitted an issue where dep status is empty. About the date, we also don't know the date where the lock file was generated, or better the last upgrade of each package. But maybe we need to use our own scm for this ? Please, don't forget to take a rest on the weekend !
lnav is a great CLI log viewer...
I generally think that any logs waking me up in the middle is an anti-pattern. If it's something that important, it's not a log, it's an event, which should be handled entirely differently. Beside that, the system should recover from most events, and it's the lack of recovery from the state, the backed up work or the persistent responses that would wake me up (all generally metrics, not logs).
&gt; Error means, that something is broken, but we can gracefully handle it (e.g. a missing file, unavailable backend…). Ok, here is where our definitions clearly differ. To me, Error means that the system cannot recover from a problem on its own. Recoverable problems would file under Warning. And if our definitions differ, then our conclusions must differ as well. :-) I see your point, and given your definitions of Error vs Warning, your conclusions are absolutely correct. &gt; In a CLI, having to verbose a log is usually counter productive Agreed. A CLI tool that produces log output should at least have a switch to control the amount of output. &gt; the log system should just support good filtering and searching. Again, agreed. I analyzed tons of log files up to gigabyte size with Vim and grep-like tools only, and this worked because the message format was both human-readable and also kind of "structured" (i.e, each line had a fixed-format prefix for easy filtering by module, sub-module, time etc.)
Thank you for you comment. I just tried out dep and the migration was pretty straightforward but mostly because I don't have any complex dependency need. I was unsure how to pin a specific revision. I found some examples with `dep ensure --examples`. However, it didn't have an example to pin a specific revision. I felt a bit dumb when I realized that I only had to write the SHA-1 after the @. Out of pride, I'm not going to mention the different syntax that I tried, the correct syntax was too obvious. dep ensure github.com/foo/@[SHA-1] However, and this is probably a known bug, Gopkg.toml wasn't updated which I noticed because `dep status` complained about missing packages (would be great that it would tell you which one in the future). To clarify the situation, the first `dep init` fetched the latest tagged version of the `foo` dependency (`v1`). I then used `dep ensure` to get the revision that I was using. Dep ensure correctly modified the lock file but the toml was still using the `branch = "v1"` constraint and not `revision = "aa"`. I just manually modified Gopkg.toml, deleted vendor and reran dep ensure to make sure I got the right version.
Hard to say. I believe Oracle's JVM implementation uses a thread-local bump allocator, which makes heap allocations very cheap. The GC is also more mature. It also uses a fixed pool of threads with large stacks allocated up front, where the Go version allocates a stack for each goroutine, each of which must grow to fit the recursion depth. A worker pool pattern (fixed group of goroutines eating functions off a list). For me, the Java test takes 4.5s, and the Go one takes 12s out of the box. Turning off the GC (`GOGC=off`) makes that 7.5s, and replacing the allocator with sbrk (`GODEBUG="sbrk=1"`) reduces it to 6.5s. The last part is probably the goroutine vs. worker pool overhead.
You can, for example count error-log lines and alert on that. If it makes sense. But yes, in general I agree.
ok, my conclusion is not to choose Golang over Java because of performance reasons. There might bei cases where Golang is faster than Java and cases where Golang is slower. To choose Golang over Java one should have other reasons. (e.g., fewer dependencies or easier concurrency)
Right, so, this is part of the awkward transition we're caught in right now - the examples and CLI UI are still oriented towards a model where your primary lever of control is via CLI commands. We've chosen to move away from that, to where you instead edit `Gopkg.toml` directly. Which is to say: &gt; &gt; However, and this is probably a known bug, Gopkg.toml wasn't updated isn't a known bug - it's by design. Problem is, the CLI docs haven't caught up, because we're trying to change it all and there's just been too many plates spinning. ...but, just pulling out the misleading docs that are there, so that it's at least not totally _wrong_, is something we can probably do in the interim :D I'll see if I can push something this afternoon. The examples you really want to be looking at are actually _generated in_ `Gopkg.toml` - they were added by `dep init` (unless you passed `-no-examples`). &gt; I just tried out dep and the migration was pretty straightforward but mostly because I don't have any complex dependency need. OK yeah this is a good note, we really need guides specifically for migrations.
Probably wouldn't use channels for what you're describing. Sounds like maybe you could just use a slice?
I wonder if there's a time frame (or go version) for when this is going to be done.
Agreed. Channels are for communicating data, not really holding it beyond the time needed for a goroutine to get around to picking it up. You can think of channels are FIFOs. A slice is the correct data type to use for this time of thing.
I am using go routines, that's why I was thinking about using channels...dunno if I can manage go routines without channel. I am still new to Go :/
Think of channels like a Ethernet cable, not a hard disk. You can use them to transfer data for a hard disk but you wouldn't store that data by sending it over and over across a network until you needed it.
Aye, it hurts my eyes as well and so did the godep tool. I'm also not crazy about the word 'ensure' when updating etc. But that is just semantics. If one writes Dep ensure -update Why not just make that 'dep update'.
I will take a deeper look later when I'm not on my mobile. So far, the comments look pretty nice. I'm interested in checking this out more, thanks for sharing.
Provided that you know how to program already.
As a user, I would always prefer small memory footprint, no 1 Gig runtime, lesser dependencies, and good performance, which is exactly what go provides. The fact that you can give the user just a single executable is very cool. 
I heard llvm will likely be the avenue go uses to get onto wasm, is this progress still looking good for wasm?
Compare these recent reddit posts: https://www.reddit.com/r/golang/comments/69qoio/goog_gui_library_built_on_top_of_opengl/ https://www.reddit.com/r/golang/comments/5zx4xb/suggest_me_your_favourite_terminal_gui_libs/ to this one only 2 years ago: https://www.reddit.com/r/golang/comments/2km3uv/whats_the_state_of_a_gobased_gui_solution/ It's really amazing how much members of this community have given in so short a time! Amazing work guys! Thank you!
tldr; runs in 0.487s (487ms) Looked into this again, and took advantage of some things. We always want the bytes between the first and second separator, and second and third separator, for example. We also know that both the values will be positive integers. I also found during profiling that the map lookup and increment was costing around 890ms of time. We know the max value of the keys, so I replaced the map with an array. Now the map key is the index in the array, and the value is the sum as before. I also changed the `atoi()` implementation to operate on `[]byte` instead of `string`, so no casting there, and took out the error checking since they were being ignored (we're already assuming correct input... #yolo). This is probably way beyond something usable/maintainable in production as the code is brittle, but it does the job. package main import ( "bufio" "bytes" "fmt" "log" "os" ) func atoi(s []byte) int { i := 0 x := 0 for ; i &lt; len(s); i++ { c := s[i] x = x*10 + int(c) - '0' } return x } func main() { file, err := os.Open(os.Args[1]) defer file.Close() if err != nil { log.Fatal(err) } processFile(file) } func processFile(file *os.File) { var sumByKey [2009]int scanner := bufio.NewScanner(file) var key int var val int for scanner.Scan() { line := scanner.Bytes() firstTab := bytes.IndexByte(line, '\t') secondTab := bytes.IndexByte(line[firstTab+1:], '\t') + firstTab + 1 thirdTab := bytes.IndexByte(line[secondTab+1:], '\t') + secondTab + 1 key = atoi(line[firstTab+1 : secondTab]) val = atoi(line[secondTab+1 : thirdTab]) sumByKey[key] += val } var k int var v int for i, val := range sumByKey { if val &gt; v { k = i v = val } } fmt.Printf("max_key: %d sum: %d\n", k, v) }
Very impressive, thanks once again for sharing your code. I was thinking that map was costing us a bit but didn't realise it was such a significant amount of time. All in all, clever solution for this problem.
Read https://commandcenter.blogspot.gr/2012/06/less-is-exponentially-more.html
I don't have the link ready but there's a meta issue on the Go GitHub tracker with many people involved in the gc toolchain that are interested in targeting wasm from that toolchain. I am also interested in writing an interpreter for Go, ingesting wasm bytecode: github.com/go-interpreter/wagon (for which a GSoC project was accepted) So... While I agree that LLVM is an interesting avenue to target the wasm ecosystem, it's not the only one :) (there are or will be pure-Go alternatives)
Latin pronunciation.
This actually looks really nice!
What is the primary use case for canoe?
Sheer unadulterated crap. Speed I couldn't care less about, which is true of many modern day programmers. If Go's safety was so good how come it needs a built in panic? That says a huge amount about wasting time with crappy old static typing. As for productivity you're in cloud cuckoo land, Python pisses all over Go. If it didn't Go would maybe have Python's slot right close to the top of the most used languages list. If Go is so good how come it hasn't taken the programming world by storm? The simple answer is Go isn't up to the job for the majority of programmers.
Your original post has -6 points which means that it comes across as pure nonsense. If you had to "spend hours fighting the compiler" then something's really wrong with you. Never mind, just keep using Python for your toy projects, who cares...
Zero-downtime deployments work by having a proxy in front of your application that can, at runtime, be told to proxy to a new instance of your app. Spin up a new instance, tell the proxy to swap, and close the old one. There's existing "routers" out there that can do this for you, but in the simplest form, this should be 200 lines of code, tops. Containers have nothing to do with this (they encapsulate installations, but do not enable this reconfiguration).
http://dokku.viewdocs.io/dokku/
Because Go allocates memory and copies byte slice contents to the allocated memory on `[]byte -&gt; string` conversion in most cases. There are exceptions, but currently Go compiler isn't smart enough in many cases, so unsafeBytesToString comes to rescue :) See https://github.com/golang/go/wiki/CompilerOptimizations .
I hear ya, it rubs me a bit the wrong way, too. The discussion around why we made that choice is here: https://github.com/golang/dep/issues/168. /u/medimacs on target - our basic motivation was sort order (for standard locales).
&gt; I'm also not crazy about the word 'ensure' when updating etc. But that is just semantics. If one writes &gt; Dep ensure -update &gt; Why not just make that 'dep update'. [Ooh, we have an FAQ item for this one!](https://github.com/golang/dep/blob/master/FAQ.md#why-is-it-dep-ensure-instead-of-dep-install) :D
&lt;3 &lt;3 &lt;3
this is the issue I was alluding to: https://github.com/golang/go/issues/18892
Not quite since specific platform support still needs to be added to Go in order for it to work on those platforms (see the case of so many different platforms already supported).
Let's think about what errors you can from you db get. Those are based on your database schema - constraint checks. For instance you probably want your username field to be unique, your password hash field to be not null, etc. Those are errors you can expect. Everything else is unexpected failure of your application (or database machine). It's a good practice to validate fields before you execute the query - at least some of them. In this way you're saving db request time and it's better then parsing error message from database. The best practice would be to validate those you can (and want to) visualise to the user before the query is executed and leave everything else to "Server error" Status 500. Make sure you log those somewhere.
I deploy my Go apps (4 currently) to Digital Ocean running CoreOS (most of them run on cheapest $5/month). I wrote a detailed guide of my setup: https://blog.kowalczyk.info/article/5/Blueprint-for-deploying-web-apps-on-CoreOS.html In the past I used to deploy on Ubuntu using Fabric or Ansible but I like CoreOS way better. CoreOS is a minimal Linux-based OS that comes with docker. The big picture of the setup is: * package the Go app as a Docker container (using Alpine as base, for very small containers) * configure CoreOS to run a service under systemd * deploying is as simple as building Docker container locally, uploading it to the server and running `systemctl restart &lt;my_service&gt;` All this can be done with a few shell scripts that use ssh to run some commands remotely. Details in the above article. I don't aim for zero-downtime. Restarting a service is just few seconds (and CoreOS has auto-updates that reboots the server anyway). Building zero-downtime restart is possible but very complicated and it's just not worth the effort. 
&gt; It's a good practice to validate fields before you execute the query - at least some of them. In this way you're saving db request time and it's better then parsing error message from database. I think that is the part I overlooked, you're right, it'd be better to check things before bothering the db at all. Can't believe I had to make a whole thread for this lmao Now I see why DBA's get paid so much.
I think it should be without trailing backslash.
Oh no, I've been downvoted by experts on reddit, they must be right, I'm wrong. Interestingly which major companies and/or organisations use Go when compared to Python? Why are people moving to Rust rather than Go?
Looks like the push promise can include additional headers. Send down the content encoding as gzip, and send the actual file compressed when ready. That would work. Posting from my phone or I'd prototype it for you.
Having written C for quite a long time, I think the existence of the book "C Traps and Pitfalls" is the best reason for trying go. Try the tour of go https://tour.golang.org/welcome/1 
Thanks for the heads up! And thanks for the project. I use it quite a bit for programming some fun toys for my Alliance (space guild) Slack in EVE Online!
I would love being able to program genetics. All that DNA stuff. 
My bad
Absolutely!
Thanks for the suggestion
I have completely replaced Wordpress with [Ponzu](https://ponzu-cms.org). I also wrote it, so I have some bias. If you're building things on Wordpress that you'd usually bring in a plugin like Advanced Custom Fields, I think you'll like Ponzu. Note that there is no notion of "Themes" - bring any HTTP front-end. Ponzu is a headless CMS with an admin dashboard, a flexible JSON API and code generators to create your content types.
I wasn't aware of Wagtail and will take a look at it. Thanks for sharing! 
&gt; In order to ease out the pain, I've also tagged a release Should tag all releases :/ - weird that this is the first tag since 2015? Is this a common thing (not tagging releases) in the go community? 
Version controlling dependencies is something that isn't well handled in general by the Go community in my experience. It's getting better with vendoring and such, but there's still quite a ways to go.
I have a very heavy nvim setup and this failed to start :( Looks pretty sweet though!
Guess I'll be the one to ask: Why? Specifically, why another chat platform for Gophers, what's wrong with the existing ones, what is gained by using this one instead, and is it worth splitting one's attention among even more chat rooms for the same topic?
Isn't Discord primarily used with voice + games? I feel that Slack is more appropriate as it is more chat oriented. (Correct me if I am wrong as I am not too familiar with Discord.)
Thanks for the insightful comment. I have been playing with CAS lately and hadn't considered this.
How easy is it to go back and check previous conversations in Discord? Does it keep the whole history like Slack?
&gt; Interestingly which major companies and/or organisations use Go https://github.com/golang/go/wiki/GoUsers &gt; Why are people moving to Rust rather than Go? Citation needed.
I miss the token check step fron this example!
I think in general, slack/discord operate in different areas to Reddit. They are both convenient for getting quick questions answered. I personally believe Discord is a better service, and its role support as well as the wealth of useful and convenient to add bots makes it better than slack.
Goroutines are scheduled nondeterministically (and on all the available cores unless explicitly specified).
Reverting to name-calling suggests you are defensive and therefore you find my opinion valid. 
Multi-threading is the least of a C programmer problems.
Since nobody has linked it yet, here is the already existing and very active Gopher Slack link - https://invite.slack.golangbridge.org
The IRC channel is official.
Hello, I saw you are importing some library I haven't seen before to generate your key pair. I haven't implemented or read papers on VAPID but a quick glance at the [RFC](https://tools.ietf.org/html/draft-thomson-webpush-vapid-02#section-4) says it uses ECDSA with a NIST P256 curve. I think you should use the standard libraries **crypto/ecdsa/ecdsa** with **P256() -&gt; crypto/elliptic.Curve** instead
"Segmentation fault: core dump" is one of the most scary things to me.
I don't know about the least, but depending on where a c programmer is in their ability it could be pretty far from being a primary concern. The gotchas surrounding malloc/free, buffer overruns, deprecated unsafe functions that may still compile, pointer arithmetic, type casting, and portability things like endianness and type sizes are all things you should already understand before threads. Or, you can bypass all of those things and learn go.
update-golang provides pretty much the same behavior. It's just a little bit more customizable. 
Since you're ignoring the potential error in your example, does that mean your package can't fail? Under which circumstances will it return an error?
&gt; However, when the database is created there are no foreign keys created Gorm doesn't create foreign keys automatically. You need to manually call `db.Model(&amp;YourModel{}).AddForeignKey(...)` to create it. Remember that in both sides of the relationship you need to inform the columns as tags: type User struct{ ID int64 ... Todos []*Todo `gorm:"ForeignKey:ID;AssociationForeignKey:UserID"` } type Todo struct{ ID int64 UserID int64 ... User *User `gorm:"ForeignKey:UserID;AssociationForeignKey:ID"` } Also, you should tell which associations you want with `Preload`: var todo Todo err := db. Preload("User"). First(&amp;todo). Error 
Laughable, presumably someone who is jealous of my own professional standing. Never mind, when you can tell me all about capability violations I'll think you might know something about programming. Keep ducking. Actually that is what Go needs to be succesful, none of this crap static typing which simply wastes time and money, duck typing rules. When are you all moving back to Python, or going forward to Rust, as there's no point sticking with your useless language?
I'm not so sure about that. When I was still programming with C++ (okay, it's not C), my greatest worries were some inexplicable crashes that I eventually traced to SSL libraries (in particular OpenSSL and GnuTLS) requiring special initialization when using libcurl and pthreads. Essentially impossible to debug, only found by pure chance, and an error class that I absolutely don't have to worry about anymore with Go.
You are a troll and should be banned like here: https://mail.python.org/pipermail/python-committers/2014-October/003172.html
Check this video out of Rob Pike explaining the difference between concurrency and parallelism. https://www.youtube.com/watch?v=cN_DpYBzKso
Random numbers are not very random on playground as well: https://play.golang.org/p/vcaT8LlsL0 
True, when I still coded in C, the build system was in many cases actually the biggest headache. This was for embedded stuff and 10 to 15 years ago, but these days I'm mostly in an ops role in a software company where they mainly use C++ - and the build system is still a large part of the complexity. In Go you just type "go build" and be done with it. The "coding" gotcha's is something you master. Yes you can still make mistakes, but when you do things cleanly, you shouldn't violate the basic things. The biggest disadvantage there is all the boiler-plate code and limited stdlib. This is a lot better in C++, where you have stuff like Boost, but is still nowhere near Go's level of convenience.
Yes, I have a strong understanding of the crypto primitives in use here and that your package aims to generate keys. I saw ecdsa in the rfc, ecdsa signs messages using an eliptic curve. The spec specifies the eliptic curve as P-256. So I linked you to the package that can provide you with the **elipitic.Curve** needed to generate a key pair for signing.
Still does not mention param placeholders!
Not advised, just use Sqlite and use a local database next to the executable - that's the whole point of Sqlite!
Go is a multi-paradigm programming language that has built-in facilities for creating concurrent applications. Design patterns allow developers to efficiently address common problems faced during developing applications. Go Design Patterns will provide viewers with a reference point for software design patterns and help to build applications in a more idiomatic, robust, and convenient way in Go. The course will take you to an advanced level of knowledge about classic design patterns but, as you will see, the design patterns covered here are quite different, partly because of the lack of inheritance in Go, but also because we have different and more optimal ways to solve the same problems. With all this, the course will enable you to understand and apply design patterns in an idiomatic way that will produce concise, readable, and maintainable software.
Doesn't sound like a very good idea. (Too much trouble for little benefit). If the project is indeed small and the database schema is suitable I'd say give [Boltdb](https://github.com/boltdb/bolt) a try especially if you want a pure Go solution.
It's mentioned : "How do we avoid this in Go? By using the database/sql package along with argument placeholders"
I think rust is in a different league than Go is. Both are ofcourse new kids on the block with their advantages but Rust feels more like a C++ replacer.
I would say that if you'r problem with C is that it doesn't offer enough abstractions porting to C++ will give you most of those abstractions (e.g. corutines) while not compromising on speed. If you're system did not require speed to being with, it should have been ported to languages like Scala or Rust or Haskell or even Java if you needed Safety and ease of integrating new parts via interfaces or to language like Ruby, Python, Javascript... etc if you needed speed in development and a wide pool of developers that are easy to train to work on it. The only reason that a C programmer might migrate to Golang instead of something else its because its familiar on the surface... or, again, because he waited way to long to port his work, because honestly Golang wasn't a viable alternative until maybe 5-6 years ago. ...Also, C++ is way easier than C, I should argue that with the addition atomic shared pointers C++ can be as easy as Java or Python or any other language which relies on atomic pointer swapping and garbage collection to make the mental model of the program simpler.
I didn't have time to look at these thorougly but from a quick look: &gt; https://github.com/BTBurke/caddy-jwt I didn't see any logout functionality. Maybe I missed it. &gt; https://github.com/tarent/loginsrv It seems that it just deletes the cookie containing the token and doesn't address any of the real issues that JWT has with logout. For example, if the token is stolen and is not expired, even if you delete it, a malicious user can still use it.
I think you can just feed pprof data into Prometheus and you're done. NewRelic was never exactly the most verbose product when you're tracking some very fringe issue, not great for drilling down. These articles might give you some insight: - https://www.robustperception.io/optimising-go-allocations-using-pprof/ - http://blog.alexellis.io/prometheus-monitoring/ - http://the-hobbes.github.io/update/prometheus/metrics/instrumentation/monitoring/2016/03/27/instrumenting-with-prometheus.html Of course, depending on your APP, you might want to add additional instrumentation that sends more data to prometheus, things like query response times, etc. - I'm pretty sure you'll have to do this with NewRelic as well. I've seen a reddit thread a few days/weeks ago which wraps sql.DB so it will time individual queries. Lucky for you it was so recent, that the link still didn't fall of the face of the earth: https://github.com/mwitkow/go-conntrack And in regards to NewRelic specifically - any insight into your application is better than no insight into your application. If you're doing a server, at least consider adding a pprof endpoint. If I remember correctly, I have a section written on this in the [API foundations with Go](https://leanpub.com/api-foundations) ebook (shameless self promo), also making use of [uber/go-torch](https://github.com/uber/go-torch). The readme of that project should be enough to get you started with monitoring your app.
Yeah there is no way to securely logout with a JWT, otherwise you are just reinventing sessions. You either maintain a blacklist or you use the `kid` field and have a per session secret. But then you're hitting a DB or cache on every request, so you might as well use a session cookie. You can also issue very short lived tokens and refresh them on every request using a nonce to prevent replay attacks. It works great for some use cases, but if you need fine-grained control over logouts then it's not the thing to use.
You might have some luck with a read-only database, but definitely not postgres/mysql, but something closer to a .tar archive, most likely. Tar file support is in the stdlib, and can provide some level of key/value storage. Think closer to etcd/filesystem, than an actual SQL database. While sqlite can deal with a read-only database IIRC, you'd still have to modify the sqlite package, to provide your own io.Reader interface. It's not something pluggable, I think. At least I haven't seen a use case for it. If you want to update the database, as you're saying, you'll have to store this data outside of the executable, or you'll have to provide this data over a public hosted API. If your app is not on the network, that might be a deal breaker. Docker might be another option for what you want, but the way you're describing your project, this would be a mutable container, which is a recipe for data loss. If your data is important, please use the added respective data storage services or public-endpoints to service your application and provide stability/backups/integrity...
Guessing here: is it because Inc() uses a pointer to reference Counter, while Show() doesn't?
Take this with a grain of salt since I work there: Datadog does APM https://www.datadoghq.com/apm/. We use Go and gRPC so it was one of the first things we supported. Also there's backtrace.io which can do some really deep stuff with Go, though I haven't really delved into it too far.
I think Rust will replace C++ in most contexts where using C++ was a good idea. I don't think most C++ in the wild is like that; I think a lot of huge corporations adopted it and their high turnover workforce of primarily inexperienced/new-grad engineers building binaries with dependency trees a hundred targets deep is precisely what Go was designed to address.
Sync.map
Could you provide a link? I'm very curious!
is it the mid-stack inlining ?
Nice! Thanks for sharing.
Unix like systems don't search the current directory. To do so, write ./myproject 
https://pocketgophers.com/go-release-timeline/#go1.9 has links to the planning thread and all the milestones.
The ability to define a custom DNS resolver: https://github.com/golang/go/issues/12503 Fingers crossed
that makes sense, but if it isn't using the current directory for the executable where is it getting `myproject` in my first call? my go bin is set to export GOBIN=/Users/my_name/golang/bin is bash cacheing the executable somewhere else? edit: ok, I found out that the other executable is in `/usr/local/bin/` , but I am not sure why does it cache it there, since I have explicit `gobin` path.
And yet App Engine is _still_ stuck on 1.6
Here's a [link](https://docs.google.com/presentation/d/1Wcblp3jpfeKwA0Y4FOmj63PW52M_qmNqlQkNaLj0P5o/edit#slide=id.p). Really cool stuff.
My most anticipated change is that there is not so much change !
 A repo to automate changelog generation **without a changelog** You gotta be kidding me 😂
yeah I have gopath set up too `export GOPATH=/Users/my_name/golang`
I am not sure if you are saying you have your GOPATH set "too" like also- or if you are confusing GOPATH with PATH? Try to echo $PATH var, it should contain the GOPATH/bin dir. If it doesn't you need to make sure you are sourcing it properly. Try typing: . ~/.bash_profile env|grep PATH # again to see path is updated Regardless if you get it working or not you should do what I pasted and stop trying to make GOBIN install to /usr/local/bin, for multiple reasons. 1) The /usr/local/bin directory on any Linux distro is going to be owned by root and probably won't allow your user to install binaries there. In that event Go may or may not fall back to GOPATH. 2) If you use sudo or can install binaries to usr local.. if you `go get` a repo with shitty command naming (common) you can override a known binary with it. Worst would be a malicious one. 3) It's not working. 
You likely did something like "sudo go install" .. when it wasn't working.. to command it to work. Which had permissions to write to usr local bin. Usr local bin has higher precedence as it is the first in your path list, so typing "prog" loaded the stale, previously built version. Typing "go install" without sudo (or due to your environment being setup wrong) was installing to your GOPATH while the older binary maintained its precedence.
I'm sure you already knew this, I'm just noting for anyone else who comes along to read, but you can declare a Counter var without an expression safely here too. Also to the op.. [inverted defers](https://play.golang.org/p/Ec24qvxMEW), FTFY!
Context. And mind your language.
Impossible or just a *big* PITA ?
Just be happy you're not using java, they haven't got their upgrade since 2013 https://issuetracker.google.com/issues/35895687.
&gt; and an error class that I absolutely don't have to worry about anymore with Go. Go channels don't magically make Go programs race free though.
Hm?
Why can't they fix the source of the issues causing the need for type aliasing?
Can you elaborate on that?
&gt; Can you elaborate on that? given 2 interfaces A and B : type A interface { Method() A } type B interface { Method() B } these 2 interfaces are not the same. "Off course, So what's the problem?" The problem is that types that rely on the old context package can't use the standard context package. type aliasing solves that issue ( it still doesn't make interface covariant but type B can be moved to type A ).
Yep I didn't have the time to setup it
They could version their SDK (make a v2), couldn't they?
By the way, Any reason your defers are ordered that way? i.e. defer unlock() and then lock()? 
Thanks for the clarification. It's funny how the subtyping relation induced on interface types by implicit implementation almost seems like an accident, given that the rest of Go's type type system is strictly invariant. What I mean is: type A interface{ F() } type B interface{ A G() } In this case, anything that implements B ("is a B") also implements A ("is an A"), making B this kind of "accidental" subtype of A, even though both are supposed to be invariant at the core :)
Race is not in value you want display but in lock itself. Passing struct by value you are reading / copying lock which is beeing written - locked in other thread.
https://github.com/golang/go/issues
"or worse, and more likely, crash just often enough to be a problem, but not often enough to be easily reproducible" Could you please give me a common example or where this would happen as a result of anything but oblivious code ? If you really want to make a mutli-threaded program crash its easy to do so, if you are actively trying (e.g. having a mutable shared state that doesn't have a mutex which controls access to it... which is still very much possible to do in go, it doesn't stop you from being a moron if you want to be moron). Disregarding oblivious code, programs which do multi-threading using posix threads will probably crash during testing or even better, they might not even compile or generate compiler warnings.
Ah context package. I see. Wonder why they don't let you specify in app.yaml the go runtime to use?
Actually, I have such CMS that can partly fit your needs. This CMS will be better for your customers and it called [MotoCMS](http://www.motocms.com/?utm_source=reddit&amp;utm_campaign=answers&amp;utm_medium=pavidlo). I made a lot of projects for my clients with this CMS and all of them are satisfied, as it have all basic things for CMS: * As you request, it has WYSIWYG editor with simple drag&amp;drop widgets, so you clients won't find a problem to use this editor; * you can add pages, sub-pages, edit all content on the page with this editor; * templates have a mofern design and the main thing, that they are responsive; * they provide support 24/7 in ticket system and can provide with general answers in chat. You can try to add your own code with embed widgets or with iFrame, as they have such possibility, and try to add your own widgets. I found also a high rates regarding this CMS on [Trustpilot](https://www.trustpilot.com/review/motocms.com) and [Sitejabber](https://www.sitejabber.com/reviews/www.motocms.com). So you can check them and also register a FREE demo of template that you like and test all features. Quite good CMS for small projects )
&gt; What comes next? We have an official answer for this: * [Slides](https://docs.google.com/presentation/d/1JsCKdK_AvDdn8EkummMNvpo7ntqteWQfynq9hFTCkhQ/view?slide=id.p#slide=id.g118cf9b85c_0_347) * [Talk](https://www.youtube.com/watch?v=4Dr8FXs9aJM)
It doesn't sound like dep is ready to be mainlined yet. It is not good to force it too early, because putting in too early a version combined with the Go compatibility guarantee results in design issues being enshrined for a long time. In the meantime, feel free to use it anyhow.
The software world as a whole has mostly moved to using the dot as a separator, rather than a decimal point. Very few people are confused anymore by 9.9.9 being followed by 9.9.10, then perhaps 9.10.0, then 10.0.0. Also note how the .0 is not confusing despite being redundant as a decimal point, nor the existence of multiple decimal points, nor the fact that 1.10 read as a normal number would in fact be the same as 1.1 and actually quite a bit less than 1.9.
&gt; Disregarding oblivious code, programs which do multi-threading using posix threads will probably crash during testing or even better, they might not even compile or generate compiler warnings. You have to be diligent with mutexes and other constructs. Their behavior is subtle, easy to get wrong and hard to spot when you do. If you mutate state from multiple threads it sets up a race condition. Sometimes that mutation happens rarely - maybe you're only updating a cache occasionally - and when its rare, it means the chances of the two threads happening simultaneously is small. Unfortunately once you run it in production, the chance is still low, but the opportunity is much higher, because the code gets hit a whole lot more often. Data races end up in bizarre and unpredictable behavior, and it get take a very long time to get to the bottom of what's happening. Other common problems: deadlocks due to failing to release a lock, thread starvation, this pattern: if this.x == null { lock (this) { this.x = something expensive } } return this.x (https://en.wikipedia.org/wiki/Double-checked_locking) Problems related to multithreading are some of the most common bugs when working on software written for servers. I'm surprised you haven't run into them. &gt; it doesn't stop you from being a moron if you want to be moron Just speaking from experience: I make mistakes when I write code. Like with pointer arithmetic, it's really easy to shoot yourself in the foot with multithreaded code, so I'm extra cautious with it. You're correct that Go doesn't prevent you from making the same mistakes, but if you stick to channels and avoid sharing state, you can be much more confident that your code is correct. Its just a whole lot easier to reason about.
All of `sync.Mutex` and `sync.WaitGroup`'s methods are defined on **pointer receivers**. I encourage you to use and pass them as such as it will avoid obscure race conditions like this one.
Thanks. I wasn't sure because the issues seemed to be only language-related, not installer-related.
Great read
And shows them like so: `file.go:19: Show passes lock by value: main.Counter`
You mean ticks? Look at [this](https://golang.org/pkg/encoding/json/#Marshal).
[`man which`](https://linux.die.net/man/1/which)
Thanks, fixed ;)
I've tried a few different command line backup utilities and restic is by far the most promising solution, moreso than duplicity, etc. I'm using restic almost exclusively now. It's not quite perfect but that's okay: backups and restores work in my experience, and I'm really looking forward to the Backblaze B2 backend getting finished so I can back up remotely to there. The developer is really responsive to issues so that's good too.
Except for the dialog windows and standard cursors, yes, I think so :)
The text implementation bothers me. It only supports strings? What if I want to print a user's score in the game, and I want it to go up by increasing a number without recreating the text object? The use of the Atlas with runes also stands out to me as something I wouldn't consider intuitive-- it makes user-input text impossible to make bug-free, as they might put in a character you didn't think they'd put in. I'm biased because I am writing a game engine, but the interface we use for this is that each text object takes in a `fmt.Stringer` instead of taking in raw strings, enabling remotely mutable text objects. The way you handle colors / sizes for strings is also something we did, and it ended up causing a lot of problems so we had to swap it out down the line. Right now to build multiple strings with some set of font/size/color settings you need to initialize those settings and then write that string, right? Then if the next string is different you just change that one setting and make that next string? That's fine if you want strictly static text, but for mutable text it'd be really great if I could remotely change a text's settings so a whole lot of text could all change at once-- like a filter the text goes through before it gets drawn. 
Ah, this reminds of [when I was young and naive](https://github.com/golang/go/issues/16472)... I'm just kidding. I still think it's a useful pattern. I do agree, however, that it would have been a bit overkill to put it in the standard library.
I've never used App Engine but just looked at it. Do you know what the difference is between what google is trying to do with App Engine and what Amazon already does with AWS?
We didn't identify TCP as a source of a significant latency. As soon as we switched to protobuf we were satisfied with the network performance. I'm aware however that we can do better there and at some point websockets over TCP might become an issue, but we just didn't have a need to go that deep.
Did you load test it? How many players can you get on one core? Also you might want to strip that out :) https://github.com/u2i/superstellar/blob/master/Jenkinsfile#L4
In general, report bugs to the first semi-related reporting system you find. Sometimes there isn't a better place for the bug, sometimes there is. You won't know until you post.
Probably to not have the defer registration happen during the critical section. I'm not sure if the effect is measurable, but that's most likely the idea.
24% for Fprintf, 17% for gob and json encoding and time format :-)
We did a load test with 200 clients. With that number of connections the server was just fine with only few % of CPU used on t2.micro AWS instance. However with that number of spaceships the client web app had some serious problems with rendering all objects, so we didn't go further. And because the game was never supposed to be a commercial product we didn't feel it was necessary to actually spend time on advanced profiling and tuning. And thanks for pointing out that file. The "credentials" are only a reference to the item in our Jenkins wallet and the other values are also not critical. We might however store them somewhere else ;)
Of course. In this particular case he can rewrite it to use a stack-allocated `var` — I was just speaking generally, in that if `c` needs to be a pointer, a literal is required to initialize it.
I had been looking at [Ebiten](https://github.com/hajimehoshi/ebiten) because both of you seem to be promising 2d libraries with support for most of the same features. Are you familiar enough with Ebiten to compare / contrast your approach? From what I can tell, you've completed a lot more text support (they don't mention anything like your Atlas, and robust text seems quite important). Other differences seem unimportant (audio support and html5 aren't super important to me at the moment). I appreciate the platformer and typewriter examples! I'll hopefully get to look at more in a few hours. :)
AppEngine is a managed "platform as a service" - you write your code and deploy it to AppEngine and it will handle running your website for you, including scaling your server capacity up and down on-demand. The idea is you as a developer just need to concentrate on writing your code, and leave the server security/patches/management/provisioning/scaling/traffic-splitting etc to Google - all the development team does is deploy the code to the server. It is part of a wider cloud offering from Google (called Google Cloud Platform) that includes equivalent services as AWS: virtual machines, SQL/NoSQL/NewSQL managed databases, blob-storage etc etc etc. Not sure what AWS has that is equivalent to AppEngine. Personally I find the Google stuff easier to use than AWS due to a cleaner web interface and neat command-line tools.
Not 100% following you, we may be aiming to say the same thing .. it mostly depends on how you qualify "it needs to be a pointer". But I'll clarify for anyone who comes along from google etc. You don't have to initialize a value with a literal if you want to its address. All three of the examples below should generate identical behavior (when the value escapes). The first two will have identical machine code, both will result in a call to runtime.newobject, the third may have another move to put the stack allocated Counter into the heap address but the compiler may actually be smart enough these days to generate identical machine code for all 3, not sure. return &amp;Counter{} return new(Counter) var c Counter; return &amp;c I only mention this because there can be really good performance benefits if you remain cognizant of these details. Escape analysis is pretty good now, so you can often get away with a lot of work with zero-allocations. Like a parser for example that is written as: var ( p Parser info Info ) p.Reset(&amp;info) p.Parse(&amp;info, `some string`) // info has its state configured based on parse result of // some string but did not have to escape. // If instead it was written like: p, info := NewParser(), NewInfo() // You allocate at least twice for something you end up throwing away
 go bug
Static (compile-time) type conversion is done like String(somevar), while dynamic (run-time, might fail) casting is done likevar.(Type) Pointer dereferencing is just like in C, prefix the pointer with a * 
I feel like they want to deprecate standard environment but can't and by not supporting later versions they force people to use flexible environment. \**Takes off tinfoil hat*\*
Hi! Ebiten is a great library, I like it a lot. Very well designed and works good. The reason why I don't use it a created Pixel instead is that Ebiten is quite limited in features and is mainly aimed at simple sprite based games. Pixel is built around a set of more general and powerful abstractions, which allow for a much wider range of features and graphics-wise, Pixel already has more features than Ebiten, for example, primitive graphics, full text support, batch.
Ok, passing such pointers could be useful, I admit, but I just didn't want to complicate the API, the current API is very simple, but capable of doing everything that you're describing. Yes, if you want to change a part of the text, you have to clear the existing text (you don't have to create a new Text object) and replace it with a new one. That's how you do it. However, performance-wise, this is not a problem. You can build your own abstractions around this any time you want and if I was creating a GUI library based on top of this (which I might), I would certainly make it possible to do these things. EDIT: You can use more Text objects and change each of them independently of the other ones. And the thing about the Atlas. I don't include the full unicode in an Atlas automatically, because it'd take a long time to create that Atlas. For example, creating an Atlas which contains the whole Han set (Chinese, Japanese, Korean) takes about 20 seconds. That's not what you for a default. However, once the Atlas is created, drawing arbitrary text using that Atlas is very fast.
I must apologize God, or does he sit on your right hand shoulder?
Not saying it needs an alternative. I was just asking why you are using a Redis backend? You use something like Redis when you want to scale your app, as in running it concurrently on multiple servers, and they need to be aware of each other for synchronization purposes. Does your game server actually need this? Does it scale horizontally? Or are you using Redis simply because that's what everybody is doing?
Sorry, I can't answer specifics like that :)
Ha! No worries, figured as much. Good luck with your project!
The point of JWT is to be stateless. They're never remembered to begin with. They're just payloads signed by the issuer with claims to authorizations in them. They can not be revoked without creating a centralized revocation list. JWTs should have tight expirations and be renewed periodically.
Consider using an asymmetric signing algorithm so you can keep the signing key more tightly controlled. You can have one service for issuing tokens that knows the private key and all other services could use the public key to verify.
You can use multi-stage Dockerfiles to easily exclude Alpine from your production image. Depending on how big your binaries are it could be a large savings, or miniscule.
This type of for ... select loop--one in which all paths block waiting for an event--is perfectly fine. It is not the type of infinite loop that causes problems because it is not a *busy* loop. A busy loop is one in which there is a path that never blocks, so it spends all of its time hogging a CPU core and not yielding it to other goroutines.
Thank you, I really should have read the documentation before posting. I deciphered this as well. I responded in the previous comment. :-)
Repo: https://github.com/knq/chromedp
One method of figuring this out is explained in https://hackernoon.com/a-story-of-a-fat-go-binary-20edc6549b97
A classic installer (or an install script, Makefile, etc) might be what you are looking for. Out of curiosity, why do you need *specific versions* of the counterfeiter tool (rather than always using the latest and greatest version)?
Thanks, that seems to work
At the moment we're using a Makefile that cds into a package directory in vendor an executes `go install .`. This works decently, but I'm working on a better solution at the moment that does this and more and integrates directly with dep. Keep you're eye on the golang reddit the next two weeks, because I'll soon release it into the open. 
How bad is the cgo function call overhead? As far as I understand things in Vulcan you need vastly many more function calls to accomplish the same things as in for example OpenGL which shouldn't be a problem in C or C++, but my gut feeling says will be disastrous for performance in Go (since cgo function calls are almost two magnitudes slower than Go function calls).
Actually there are two types of bots in the game. One of them is the bots sitting in `superstellar_utils`. They are plain stupid and blind as they only make purely random moves with no awareness of the game state. We used them to generate artificial traffic and test the server performance. We were able to run 200 of them with no problem for the server (few % of CPU), but with big problems for the front end app (it couldn't render all objects quick enough). The other bots sit in `backend/ai` package. They are a bit less stupid as are able to move, avoid obstacles, aim and shoot other spaceships. We haven't stress tested them, but since they are still quite simple and they run inside the server's process (thus no need for web socket communication) I assume we can run thousands of them. Given big enough world of course ;)
Great, thanks for sharing the code as well!
Hi! I was considering how bad the overhead would be, and it seems that Vulkan API is designed to avoid the problem as well. Yes, CGO is slower, but x2 and even x5 shouldn't matter there, because problems arise on tight loops, for example this is sensible in Go production with millions ops and CGO being used in hot paths. Most "extra" code in Vulkan isn't hot, it's a boilerplate to initialize the pipeline and resources, and buffers and stuff like that, then you just orchestrate it and feeding the buffers with new vertex / shader memory and making draw calls. In the end you work with data transfer to GPU and invoking drawing calls, the same as OpenGL. Btw, some vendors are implementing more efficient methods for the hotpaths, for example VK_NVX_device_generated_commands https://developer.nvidia.com/device-generated-commands-vulkan to avoid latency from CPU in some places. And another solution would be to rewrite more code in C actually, it'd still be better than write everything in C. And finally, I consider this library to be a cool way to learn Vulkan API, rather than use it in 3D graphics "production", because not the CGO overhead but the difference in tooling will prevent you from using that seriously.
Fair enough, I haven't peeked at Vulcan too much yet. If the hot paths only require a handful of function calls, it shouldn't be too horrible. I did the math for something I was doing in OpenGL and the cgo overhead was adding something on the order of 1% extra CPU time, so it was reasonable (it was around 200ns per function call into C back then, in 1.8 this overhead is down to 70ns, so things are getting better).
I'm using [Peru](https://github.com/buildinspace/peru) across my projects for keeping track of binaries needed in development and/or testing. I have a simple setup: a `peru.yml` is commited in VCS and Peru itself is installed by `make setup`.
You could write a batcher (like [so](https://github.com/chewxy/cu/blob/chad/batch.go) (not actually vulkan, but CUDA), or provide predefined batched functions like /u/xlab_is mentioned ([here](https://github.com/chewxy/cu/blob/chad/batchedPatterns.go) is my CUDA example) p/s /u/xlab_is, thanks for the vulkan lib, gave me a lot of inspiration when developing the updated version of the CUDA lib
[github.com/twitchtv/retool](https://github.com/twitchtv/retool) exists for this very purpose. I haven't tried it yet, but seems stable. Theres [an issue](https://github.com/golang/dep/issues/221) about supporting it on [dep](https://github.com/golang/dep), too.
I tried the strip command and got interesting result. I don't know how far it can get to reduce code size. I expected it could remove dead code
&gt; The design of the batch calls is very much inspired, and later, copied directly from the golang.org/x/mobile/gl package Yep, I've read that one. I'm not a huge fan because the overhead of a chan isn't that much better than cgo. I guess everyone is dealing with the same issues. N.B. The mobile/gl package doesn't actually need the batching on Windows where the OpenGL calls have no cgo overhead.
probably the same answer as yesterday, your using a pointer and a nonpointer, `C Counter and C *counter`, try using two pointers? *just guessing tbh*
yes, it is the preferred fix, but it is not a direct fix. [edit] two lines in Show method are commented. So your fix is invalid now.
Presumably in the scheduling of the goroutines themselves.
ok my second guess is this https://golang.org/doc/effective_go.html#channels search "the loop variable is reused for each iteration" in the channels section basically done `done` and `i` vars are shared between go routines, causing a race. so youd have to do something like go func(c Counter, done chan) { c.inc() close(done) }(c, done) //&lt;-- for your innermost gofunc, *but im noob not sure* 
I don't see anything abnormal. What output do you get and how do you run your code ? How do you see a race ?
When you run this code with multiple threads, you must be aware that the execution order of inc() and show() may be randomized. When using goroutines, don't assume that execution order will follow the one visible in the code. This is asynchronous code. So all the show() could for instance be executed before all the inc(). There is no race in this code. It's just a wrong assumption that the execution of inc() will always precede the associated show().
My only complaint is that this overlooks the interfaces in `image/draw` that are made to accommodate this kind of functionality. You can implement `draw.Quantizer` for your palette generation algorithm, use it to create a palette of however many colors you want to use, do `image.NewPaletted` with the generated palette and implement a `draw.Drawer` that uses your desired dithering algorithm and palette when drawing.
Hey, feel free to DM me any feedback or comments. I'm always happy to give a hand to people who want to learn :)
This sounds like almost exactly my experience too. Coming from PHP I've liked a _lot_ of things about Go, especially the very consistent and high quality standard library. Against Java, I prefer having more concise code to do the same thing. For example, assembling an email in Java is an ordeal... Same with frameworks. Coming from PHP you'd be pretty daft not to use a framework, but I love the approach in Go that really lets you choose how to build your system. Often it leads to simpler code because you're not writing things to interface with the framework you've chosen. Symfony for example is _excellent_, but there's been countless times since I started writing Go where I've thought "all of these choices and options, and I only care about one specific set of features... this would be way more straightforward in Go".
Nice! (Yay Beer!) Here is another example (mine) https://github.com/kpurdon/slappd. I do wish I could send a slack message and have a beer appear at my desk.
It is really racy.
i is not shared. And as @chmikes said, done is an inter local variable.
No - it is. You are making copy of the Counter struct while another goroutine is trying to change the value inside. Your lock do not help either because you take it inside Show() and Inc() methods but copy operation occurs outside. Honestly, all of those questions can be answered with race detector. Don't do things that compiler or tooling can do for you. Also - don't mix pointer and value receivers.
Do you mean a data race, as in concurrent writes or concurrent read/write, or do you mean a race condition, as in things are happening in a non-deterministic order and so break code that relies on a specific order?
If you know C and C++, I'd start with the following: * https://github.com/golang/go/wiki/GoForCPPProgrammers * https://golang.org/doc/effective_go.html * https://golang.org/ref/spec 
[Link to the video actually regarding chromedp](https://www.youtube.com/watch?v=_7pWCg94sKw&amp;list=PLq2Nv-Sh8EbZEjZdPLaQt1qh_ohZFMDj8&amp;index=14) instead of the whole playlist, though there's other interesting stuff in there too.
Yes it is. Context allows you to cascade task cancelation which can be really helpful when you application contains multiple logic levels. 
As you are not new I think: https://gobyexample.com/ Just to learn fast. https://golang.org/doc/effective_go.html Learn deeper But then if you can do a search in youtube for "Rob Pike" and "Robert Griesemer" talks about Go. There you can find the Why's of the language and I think that is important. 
Introduction to Go is pretty good. https://www.golang-book.com/books/intro
`go vet` should detect it: https://medium.com/golangspec/detect-locks-passed-by-value-in-go-efb4ac9a3f2b
Just in case you haven't already (apologies if you have), I'd highly recommend taking the [official Go Tour](https://tour.golang.org/welcome/1) before anything else. Answers a lot of questions you might have, by giving you some practical experience writing your own little example scripts.
Thanks man will do :) 
That post has a shell script to run that will tell you the size of each dependency. ``` eval `go build -work -a 2&gt;&amp;1` &amp;&amp; find $WORK -type f -name "*.a" | xargs -I{} du -hxs "{}" | gsort -rh | sed -e s:${WORK}/::g ``` Might help.
you could try to hijack the http request (assuming you aren't dealing with a raw tcp connection) and read from it's underlying tcp connection.. https://golang.org/pkg/net/http/#Hijacker though I have not tested, the result should be the raw http request as it was sent from a client, which would preserve order and case.
Yeah! See a slightly longer comment below about annotations/frameworks, I think we're on the same page here. I basically opt out of most things, and import only very usable packages with composer (lusitanian/oauth, predis, shuber/curl, mpdf, silex/slim?), which is I guess very analogous what we're doing with Go. And I want to cry every time I install something with npm and end up with a 100MB+ node_modules folder with specific packages like "is array" (why fucking bundle a type check into a package? oh yeah, I forgot, this is javascript - an import is better than a little bit of code).
That answer template is a bit long and battery is running low... I haven't built any "secure" APIs in Java, but I have built many in .NET for banks and healthcare that have passed audits with A+s. I switched to Go back in early 2014. You can read the detailed reasons why here: http://blog.jonathanoliver.com/why-i-left-dot-net/ (and comments) For me it comes down to one word: Tooling. Microsoft's (and JetBrains) tooling is superb. You spend years upon mastering the keystrokes with muscle memory. You get excited about the next cool feature or nuget package that is available, that **takes care of that for you** kind of stuff. But that's a lot of time that could spent on developing features. And there inlies the problem. You get locked into these ecosystems. With Go, the tooling is simply the "go X" commands. Short, simple and done. Any editor or IDE you use is simply an extension of those command line utils with lipstick. What I am getting at is with Go, I simply focused on my feature or product and got it out the door. With .NET, you follow best practices and assume that nuget package or framework object is secure (and so do the auditors). You put a lot of blind faith in those packages, patterns and packages. You must setup complex tool chains and pipelines that comply to the standards as well as C.I. tooling to enforce checks and balances in code, so no one goes rogue in a checkin. You must enforce specific versions for auditors. You must implement a huge checklist of encrypted config files and TLS database connections. (Java is very similar) With Go, you only go down to the level of detail you need. Don't need config files? Don't use them. Done, nothing to encrypt. Move onto next feature. 
Minor note: Hopefully by now you're using vendoring so there's some additional tooling: gvt, glide or godep, most likely. At least until there's an official vendoring tool.
This is what gets me with Go. I hate adding dependencies, and the code is so simple, especially when you strip out all the junk people add to turn something into a generic, one size fits all library. I'll read the library, glean the details, then roll my own implementation in a hundred lines and call it a day. The only things I end up importing are things like database drivers and the AWS SDK, where it's well isolated in usage and writing it myself would be burdensome.
This was my question as well. I don't care what versions of developer tools developers use as long as the developers get their work done. I don't even care if they use the same tools, as long as they're compatible with the consensus workflow.
This might be okay for hello world but not for a real application. This is a good way to create a thundering herd, honestly it's so little code to properly implement exponential backoff with jitter in Go there's no reason not to.
[backoff](https://github.com/jpillora/backoff)
If you want to know the position relative to headers of different names and want case sensitive header names (both of these are kind of weird things to want -- header values are already cased however they came in, though), I think you'd need to parse the request the yourself. I don't believe there is anything in the stdlib that would cover a case like this -- could be wrong, but it doesn't seem like something that would've made it in.
This can only be done in bs because js is the only language that runs in the browser. edit: i was assuming you meant in the browser window.
Why create a channel with the sole purpose of closing it? Why not just use a variable?
yes, it is poorly contrived. And good explanation. :)
the idea is abstract it or dont just do it all inline. //you can make a reader helper ReadYesOrNo(config, 'somedefault') //you can make a config helper SetConfig(config, 'myflag', ReadYesOrNo()) //you can make a printer helper func PrintDashesAndText() //you can make an if helper func IfAny(a []bool...) bool // ex IfAny(A(), B()) { dosomething() } //ending with something like PrintHelper('add foo', YesNo_val) config = SetConfig('foo', config, ReadYesOrNo(config, 'defaultval')) ifAny(ReadYesOrNo('a'), ReadYesOrNo('b')) { config = setconfig() } //or not and do it inline - could do it with callbacks too; but i dont like to - the other way is to just move it into `config_crap_logic.go` and call it as a single func in main, `init_crap()` - i kind of like abstracting it because you can just do a few flags in your abstractions and reuse them, for example the PrintHelper(...,true) could print `YES/NO` and false could print 'enter an integer`. the other way is write a config function, that takes a huge struct or json, with all options, so a big json tree thats linked to questions, answers, and config 'string' names, and then have a parser func to set everything, example (psuedocode): var options = { q1: { key: 'someflag', question: 'blah blah yes/no:', default: "yes" } q2: { key: 'someflag', question: 'blah blah yes/no:', default: "yes" } ... } func Print(){ ... } func HandleAnswer() { if key == 'someflag' { ... } if key == 'secondflag' {... } } the problem is none of them work for every app, every app is different. basically just inline it and put it in `config_logic.go` 
epiris, thanks for the comment! I want to make sure I am understanding your point correctly: If we take a client using this retry policy to contact a server as an example: the problem would be if multiple clients were to use this retry policy and start their loop at roughly the same time, they would have the same exponential backoff schedules, and since there is currently no backoff randomization they would then hit the server at roughly the same time for each subsequent retry up to the max attempts? You are pointing out that a jitter factor would help with such a case?
You could just add the [ismap attribute](https://www.w3schools.com/tags/att_img_ismap.asp) to the img tag.
I don't believe that gives you access to prior data already parsed by the http package though. 
Shameless plug :). I have started writing golang tutorials at https://golangbot.com/. Please have a look.
Hi, you're understanding correctly. I think the term you would want to google would be something like "cascading failure", "thundering herd" "stampede" etc for better material on this problem space since it's well covered I won't regurgitate here. I do have some copy pasta [playground](https://play.golang.org/p/X6jvh3zjY7) though to give a visualization, I copy derivatives of something like this because it's so simple / short and plays well with context.Context. I use it for both indefinite retrying like restarting a service that fails as well as every single outbound network request I make to any service HAS to use exponential backoff or some similar mechanism. Happy coding.
The open/closed state of a channel is a good way to pass a boolean value safely to another goroutine. Channel is open: `&lt;-closed` blocks, and the `select` moves on to the next case. Channel is closed: `&lt;-closed` starts reading the zero value of the channel, and so the case... case &lt;-t.closed: return ...now applies, and the function exits. Using a variable instead, you would need to protect it with a mutex, which doesn't make it any easier compared to checking a channel's state.
Would it work for https if you used TCP with SSL?
This a nice example to illustrate the principle. It also shows how to handle a Ctrl-C. But this pattern requires that we add a closed selector to every select of the program. This is not always possible. Where could I find an example of graceful program termination using a context ? 
The version 0 looks more idiomatic because it is simpler to read and understand. What is weird is the closing pattern you use. Since you didn't specify your goal it is not possible to know if this is a design error or a feature of your future code. An idiomatic way to close would be the following: https://play.golang.org/p/en8qrgzYj2 It is idiomatic in the sense that it is more readable. By more readable we mean that what it is easier to understand what the code does. The simpler (less instructions and variables), the more readable it is, because the reader has less text items to interpret and keep track of while reading. Note also that you can drop the select in the main. The channel read performed on the channel returned by time.After will block until the wait time is completed and the timer writes the current time in the channel. If you want the code to react on other types of events, then you need the select. 
Thanks for advise &gt; What is weird is the closing pattern you use. Since you didn't specify your goal it is not possible to know if this is a design error or a feature of your future code. If you mean this part of code: ch := make(chan interface{}) this.hubClose &lt;- ch &lt;-ch This is because if Hub.Close uses some kind of goroutine to finish its workers, it can pass channel to that goroutine, so that when it finishes it will inform caller about close &gt; Note also that you can drop the select in the main Yes, right Can you please also tell about performance implications of version 0, if I add some long running task into its main event loop (by main event loop I mean for { select {} }) , then it may slow down all other clients who wants to call Hub.Add *UPD1*: Close pattern used in Hub.Close() guarantees that function exits from it only if Hub.Run() finished
FYI, I wrote an article about Tensorflow + Go. If you want, you can read it here: https://pgaleone.eu/tensorflow/go/2017/05/29/understanding-tensorflow-using-go/
It is, but you'd need a backoff delay as well, to increase the window in which connections are being made. Jitter spreads out the connections over this window, for example, and should also increase with time. For example: a * 2 backoff starting with a 3 second retry would mean: 3, 6, 12, 24, 48 seconds. With a jitter of 25% of the value, a client may connect in the following intervals: 3 seconds +- 0.75 (1.5 sec window), 6 seconds +- 1.5 (3 sec window), etc. 48 seconds += 12 (24 sec window) Depending on the number of connections that were interrupted this would mean that the reconnections are spread out over this connection window, possibly preventing a [thundering herd problem](https://en.wikipedia.org/wiki/Thundering_herd_problem). Without jitter, pretty much all of them would reconnect in the same disconnection + backoff window. If this is a real problem and you're talking about 10 thousands or 100k connections or more, you'd likely want to have a minimal jitter in line with your high (90%+) percentile of API response times. Let's say that 10ms per request is likely, your connection window should be 100 seconds for something like 10k requests. Let's say you have 10 nodes with that response time, your window just got reduced to 10 seconds. This is where scaling and low-latency APIs have a tremendous effect. estimated needed connection window = longest time of api request (90/95/99th percentile or more) * number of connections / number of servers
Thanks, maybe my comment is not that clear. My question refers to /u/nstogner's question &gt; You are pointing out that a jitter factor would help with such a case? as my understanding of jitter is that it does exactly what you explained: Adding some randomness to the backoff schedule.
Yes, exactly, within the parameters/characteristics of your (or concretely OPs) API/service. It shouldn't be completely random because it's intent is to spread out the reconnections over a *defined interval* (vs. purely random).
Regarding performance implications: You could use a long running func in a goroutine, but you'd most likely come back to using mutexes when you're reading/writing to the map to resolve a posible race. You could extract this into a struct, like somebody did here: https://play.golang.org/p/8pJ7gTuuJR That way you'd keep the mutex part exactly on the structures that you operate on, using the Get/Set/Remove interface as you want. The example [0] should stay idiomatic even with additions of mutexes in this way.
&gt; An idiomatic way to close would be the following: This isn't as good. When Close returns, you know that the hubClose chan has been closed, but you have no guarantees that the Run goroutine has seen it yet.
I will add a jittery version to the post, noting the thundering herd problem: jitter := time.Duration(rand.Int63n(int64(sleep))) sleep = 2*sleep + jitter/2 
It would work if you took the time to setup an SSL interception system. Unless you can get one off the shelf and configure it _very_ quickly, you will find that will take much more time than my original suggestion. It is not out of the question that getting this set up will take you multiple days, if you are not already _very_ familiar with SSL. My original suggestion is probably on the order of half-an-hour to implement for a skilled programmer, so there isn't a lot of wiggle room to be fooling around with figuring out how to make an SSL proxy (which includes configuration on the requesting client as well, don't forget) before you've run over how long my suggestion will take. Trying to hack around this from the outside is really coming at it from the wrong abstraction layer. You need to be on the inside. This isn't anywhere near as big a deal as people think.
You are right. My goal was to show how the channel close is used to notify goroutines to stop. It doesn't show how to ensure all goroutines are terminated. A WaitGroup is used for that. The Wait() may be called inside the Close() or at the end of main(). I suppose we should use context instead to handle cascaded Close. An example would be welcome. 
This pleases me.
&gt; 29 Oct 2015
Right. I think the difference between your Pixel and Ebiten is levels of abstraction.
Cool, lgtm. Only thing I would change is not use a sentinel error for communicating a stop condition. Could simply return nil and just use the enclosing scope for error reporting, I.e: **var err error** above the func or make the return value named.
For libraries, I actually like the LoggerFunc approach too. Read about it not so long ago. But for apps, I think it is fine to have a logger tied to structs.
why not both?
That may be fair but it's hard to give up small, native binaries. I know .Net Core is working on it but when I evaluated a few months ago, it seemed a lot was still required for a "Hello World" HTTP app. Horses for courses.
October 2015... Around that time I was asking my employer's AWS rep about Go support. At the time it was not on the roadmap and their "official" response was to use one of the third party wrappers that shell out to your Go app from Node or Python or some other nonsense.
Woo, this is awesome! I have a similar project that I started because I couldn't find anything like this. What are your thoughts on billing integration (thinking stripe primarily), would that fit or do you want to keep things simple?
Like most things promised to me by AWS TAMs... "It should have been released last quarter..."
Thx, and yes: I want to keep things simple. I also thought about a module for billing integrations, but this should be a separate slef contained module/service.
Bad. 
What about execution time comparison?
I'll believe it when I see it. If there's one thing that I've learned from AWS account managers, it's that every. single. roadmap. is complete bullshit. 
It can be done. TBH I did pay much attention to it, because the idea stays the same.
Cannot agree more. I started learning to program with C# and most big projects seemed too complex. Layers upon layers of abstractions just for the sake of it. Then I found Go. Everything is KISS and easy to understand while still being as extensible. I think Go's lack of inheritance (favouring composition) is a big advantage. Many newer languages like rust are also following this paradigm. 
Gotta prioritize.
Your point about the lack of inheritance and favoring composition is a great one. C# architects will tell you to favor composition over inheritance too, but without the language and community boundaries we've seen what happens. I'll say this again, C# is a great language and I love it's powerful constructs, but I favor the type of code that is written by Go developers. For a number of reasons, the people who are attracted to Go and stick with it are the type of developers I found to produce code that is easy to work on later. There is language theory at one end of the spectrum and code craftsmanship at the other it seems, a language high on theory makes craftsmanship a little more difficult, maybe, just maybe too difficult.
TAMSpeak 6-12 Months = We might decide to build this at somepoint. less than 3 months = We are building it but don't hold your breath
&gt; a language high on theory makes craftsmanship a little more difficult, maybe, just maybe too difficult And this is the reason why languages coming from academia are usually bad for productivity.
Yep, it's a loaded poll. They're going to announce support for both.
There is also this: https://github.com/apex/go-apex
verbose is good for young devs like me. Thanks
I'm hoping for Docker instead. Run any arbitrary container instead of locking in a language. But I'd take Go. :)
&gt; Don't want these either. I love that I now write code that handles absolutely every possible situation gracefully. How can anybody describe Go error handling as "graceful"? There are numerous blogs telling you all the Go tricks of the trade, whereas try/except is blatantly obvious to anybody.
No need for shell wrappers, you can [use a python extension shim](https://github.com/eawsy/aws-lambda-go-shim) to build a native shared library that's loaded by AWS Python runtime.
&gt; There must be something in the network based string that is causing it Are you at any point logging what filename you are about to create? fmt.Printf("creating: %q", name)
I was, but using %s, rather than %q. Probably a C holdover, I didn't even think of. I now know where the error is, but I'm still unsure how to get rid of it. I'm getting a heap of Nil characters after the file name. creating: "/home/user/.data/DESKTOP-U3AH6M9\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00-eXY\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00" 5 Error Opening new file to write key toopen /home/user/.data/DESKTOP-U3AH6M9-eXY: invalid argument
I didn't say the code was graceful, I said: &gt; I love that I now write code that handles absolutely every possible situation gracefully The problem is try/except is knowing where to use it. Go forces you to check every single situation. It's tedious at first, but the result is code you can rely upon.
&gt; Go has basically had it, as sales and marketing budgets don't count so much in this day and age as programmers who actually use a language https://www.tiobe.com/tiobe-index/ &gt; There are simply too many better competitors than Go Prove it. :-) Have you written any Go? Really used it? Perhaps to write something that you'd like to make asynchronous and actually put the massive number of computing cores per box that are on the horizon? The thing I *love* about go is that it scales from tiny IoT postage-stamp sized systems to as much RAM and as many cores as you can afford...
It does no client side work. The server runs the program in nacl for isolation.
I'd love to write code in it, but the straight jacket that you can't get out of makes it impossible, at least in a productive sense. You can certainly forget the strongly, statically typed drivel as you step into the world of interface{} and the reflect package, as you still have to go through the oh so painful steps of compilation. At last you think to yourself, it's finally compiled, and the first tests you run panic. Back to square one fighting the compiler. Heck 35 years ago I mastered the "capability violation" thrown by a [S250](https://en.wikipedia.org/wiki/Plessey_System_250) when using the CORAL 250 compiler. I've used all kinds of assemblers, but never have I had the problems I've had with Go. Unless Go sorts out these problems it's had it. Nobody gives a crap about most of the technical problems these days, it's programmer productivity that counts. Why do you think Python has been so succesful? It's certainly not run time speed, it's programmer time and that's money, pure and simple.
Ah. So, at some point they may want to change their sandbox environment to something that isn't a dead project or take on the nacl code internally if they want to stick with it.
Maybe I'm not understanding something, but can't you do that with ECS?
But C# has too many features and become too complex(So does C++/Scala/Rust/D/Swift).I prefer C/Java/Python/Go. IMO,Go's philosophy(less is more) is contrary to C#(more is more).I wish Go would have generics one day but do not wish it become another C# or Rust. On the other hand,I really like Go's lightweight runtime(contrary to the JVM/CLR beast),powerful but simple standard library and tool chains.
go makes more sense with fast startup time and low memory consumption and speed. it will be a lot cheaper for us i think!
Nice work. I have been using Cony and mainly because of the automatic reconnection logic. Have you thought about adding something like that at all?
Please don't feed the troll. This one keeps getting banned from Python forums, I wonder why no one moderates this thread.
i am developing a web form library with html5 support, binding, mapping your interface, request binding, validations, filters, file upload... maybe you can try https://github.com/semihs/goform
Right after that third AZ in Frankfurt, which is available in ~~Q1~~ ~~Q2~~ **Q3**!
FYI: You don't need `strip` for go programms Extend your `go build` with `-ldflags="-w -s"` e.g. `go build -ldflags="-w -s" -o myStrippedBinary myAwesomeProject`
Lambda is not ECS. ECS still requires u to manage a cluster.
Hi, without hijacking the thread ;-) How can I find your project?
https://gitlab.com/faststack/billstack But I haven't actually released anything yet, this is part of a SaaS. It has a json api that provides: * /signup to create a new user along with a stripe cc token * /login to create a new JWT token * /subscribe to subscribe to a stripe plan * /webhook to react to stripe events (only partially implemented and not tested at all) There's still a few things to do (transactional emails for example) and I'm sure there are still lots of bugs, use with caution. One nice thing it does is extend the JWT claims with plan metadata, which makes it quite easy to implement user limits in other services. This is something you cannot really do if you move billing to a separate service. What are you thoughts on that, /u/smancke? Maybe the new plugin support in Go could come in handy here...
@kataras I guess? How does it compare with iris? http://i.imgur.com/dppVYux.png
a last screen shot for fun http://i.imgur.com/T3TR5UU.png
Is there a text version?
Correct. Further, the idea behind Lambda is that Amazon owns/manages/runs some heavy hitting machines and they drop up to 1000 concurrent (by default) instances of those Lambda functions depending on load. This means you have access to a huge fleet of machines to execute code that you're not paying for until you use it. Yes, it is more expensive to do this than run your own cluster if you're running the functions 24 hours per day. But we need a lot of horsepower for a few minutes a few times per day, not 24 hours a day. Lambda is *perfect* for this. Being able to launch 1000 docker containers on a whim to process a job for an hour or two would be spectacular. Why not use auto-scale groups? Because machine startup time is at least a few minutes per machine. Our code currently running in Lambda is finished processing before the next few EC2 instances would have booted up to start processing the job. Then, once they're up, I have to pay for a full hour even if I shut them down. Lambda allows me to consume resources on a huge cluster at a granular per-second interval. Honestly, this is like the old mainframe days where you paid for a time slice on the mainframe. That model works well for some business cases. ECS is a great tool in the belt, but Lambda Docker would be very well received. Or Go. I'm good with that too. :)
Christ almighty. Does that guy know no shame?
You mean a transcript or the slide deck?
Go compilation is the least painful thing in programming imho. I'm just judging from the quote "I'd love code in it", it makes me think you have looked into it, formed opinions but never actually wrote something. In writing dozens of micro-services, a mobile shared library and some pretty complex dev ops tasks in Go, I've never once reached for the reflect package or used interface{} outside of serialization/marshaling. Take this for what it is worth (which isn't much), but it seems like you fight against the grain rather than embracing the go way of doing things. Once you do that, and I do mean really do it by writing SLOC in Go, you might come to the conclusion that you've learned something. I've been programming 20 years, and I have done C, C++, Java, C#, Javascript, Obj-C, and others for many years each, and I found Go to be a game changer for me in the way code should be crafted. 
I don't agree with this, there are many examples of useful libraries in Go, and most of them don't have to dive into reflection and interface{}. 
I'd like to read it as reddit post. I'm not English speaking really.
You can enable CC in the top right bottom of the video.
Ha! Beat me to it ;)
By the way, how do you make direct calls to windows DLL in Go ? for instance, i want to record sound in go on Windows, how would I do that?
Hmm, I guess i have too. Just was hoping to keep in pure Go... I know there has too be a way.
So this is basically [`github.com/pkg/errors`](https://godoc.org/github.com/pkg/errors)?
I think the way to approach this in Go is to simply drop the immutable part. Go is not a functional language, immutability is good, but not always worth it.
There's a minor typo in the readme: &gt; **Bacakend** is used for mail storage access
I find it curious that his main complaint is lack of immutability, yet his proposed solution is generics.
And here's the slide deck: https://speakerdeck.com/campoy/understanding-the-interface
I am curious while the methods and construction of your object seems generic instead of being tailored to your application. I get your requirements, but seems like you have the opportunity to think outside of generic programming and instead write the AnimalMap object to actually match how it will be used in the flow of your program instead of generic methods like Order(). 
&gt; Yet in Go, every time I need one I have to write 30 lines of code. I feel like I had to fight to Go every step of the way here. I feel sad. So nobody appreciates how explicit yet simple the solution looks in Go? This is a proof of how expressive Go can be. Less is more indeed. Instead the author dreams of a "magical" language construct that would allow him to do all this with little to no code. A feature that every time you have to write anything in the language you have to think if you should use it or not. Then the person that comes to maintain your code 6 months later (which might be the author) has to scratch their head and think why the feature was used in the first place. Oh you think this requires just 30 lines of code in Go? That's funny. You forgot to add the 30 lines of comments explaining *why* you are doing all this.
Yep, `syscall` is what you use. One might also use https://godoc.org/unsafe and `go` assembler to do low-level programming.
Sorry, this is crap. Any project of significant scope has more going on than can reasonably be kept in context. Immutability as a language construct would make it SO much easier to write correct programs. For example, we have had more than a few bugs in kunernetes that came down to someone mutating a cached object. If we had const-pointers that the compiler could track and enforce, we would be WAY better off. I understand exactly how complicated this is, and I still think it is worthwhile.
I realize I was being a little bit silly. I'm just saying that it is possible to ensure behavior without a language construct. In your case, is it possible to use a RWMutex to control access to your cache? 
You mean something long and complicated like the kotlin solution: class AnimalMap(order: List&lt;String&gt;, animals: Map&lt;String, Animal&gt;) { val order = order.map { name -&gt; animals[name] } val animals = animals.toMap() } 
It's not about mutexing. We have many modules accessing cache. They call functions which call other function, and at some point it's not exactly clear if it is ok to modify an object. If one of those functions errantly changes the object, everyone else is impacted. A const pointer would help. A generic "cached&lt;T&gt;" type would help. Go just has no such mechanism. Yes, perhaps we could have been more careful in code, but we have over 1500 people hacking on this. It is one of the largest go project in the world. We are approximately the most active project t on GitHub. IMO, Go should be aiming for our use case, even if we are at the extreme edge.
fundamentally disagree with his supposition that something like `func WriteTo(f *os.File)` is somehow "inferior" to those that take `io` interfaces... if all you want is to write to a file, the first one is fine and easy to understand...and almost always there are other concerns you need to take care of that are implementation specific (in this case, some sanity or error checking you may want to do on that file) and if he insists the interface approach is superior, I would ask why the Go standard lib spends very little effort defining or exploiting the value of interfaces other than what you see in `io` Frankly the rest of the slides just seem to dance around missing generics
For some reason, this [image](https://m.imgur.com/r/ProgrammerHumor/INBvStO) always comes to my mind whenever I see WebAssembly.
That's a great talk.
This echoes my own experience with Go and SQL - same approach to using libraries, verbatim queries, constants, and partitioning repositories. There is no perfect solution but this get you pretty close. One more thing that I do is enclose table and column names in queries in "quotes" appropriate for the SQL back-end: back-ticks for MySQL, square brackets for MS SQL, double quotes for PostreSQL. That simplifies finding all occurrences of a column anywhere in a file.
Low-level mechanism is syscall, but there are projects that already wrote a lot of Go wrappers around Win32 api, for example https://github.com/lxn/win (and https://github.com/lxn/walk for GUI library built on top of win).
Go, and other "high-convenience" languages are generally not appropriate for *breaking* systems in. Using C for this would make your life easier—no bindings needed, and most tutorials and prior art is based in C. Anything else, and you end up with more work trying to make the shoe fit. However, as long as the technique is okay with each syscall running on its own thread (the Go runtime will generally do this), then it *should* work in Go. The lack of thread control is your primary enemy here. Also, I never really understood why the hell CreateRemoteThread seemed like a necessary thing to have...
the alternative is clumsy defensive copies to protect variables, or wrapping everything in getter methods like all things Go...the language actually offers the feature (immutability) but selectively in the cases the designers wanted...for example, strings
But why do you even need to 'protect' variables? Can't you just not export them if you want to prevent people who can't read documentation from changing them? Also, constants are useful not because they're immutable but because they're kept in static memory. They're basically typed C macros without parameters.
But why?
The thing with immutability is that (unless you're doing Rust style deep immutability), immutability gives a false sense of security. For example, take the following Kotlin code (which would be the same problem with Java or c++ consts): fun main(args: Array&lt;String&gt;) { val a = MyType("a") a.changeString("b") println(a.str) } class MyType(var str: String){ fun changeString(arg: String){ str = arg } } You'd expect that since `a` is a `val`, it should be immutable and `changeString` shouldn't compile. But it does. Why? Because a is a pointer. The *variable* `a` cannot change, but the value `a` points to can. And it could be more dangerous. fun main(args: Array&lt;String&gt;) { val a = MyType("a") doSomething(a) println(a.str) } fun doSomething(a:MyType){ a.changeString("b") } Does doSomething modify `a`? It's a `val`, it's immutable. But it changes because `a` is a pointer.
Sorry I cannot understand what you mean.
Hey man, nice seeing you here. I am writing a code to do that, started earlier this week, as soon as i have something you check it out :)
Good writeup, I love the use of prepared statements. It would be interesting to see how they are prepared actually. Slightly funny to think that exposing data from Postgres via API is shocking :D Interesting how the author (or you as a reader) would feel about code generation in this case? You could create a simple JSON that holds all your queries. Out of those queries, some could be auto-generated into exactly the example of GetByID on episodeRepo struct, and all could be declared as const's in a go file. 1. Write the structs by hand (whatever.go), 2. Create a JSON describing the DAO &amp; listing all queries, 3. Generate go files with all the queries (whatever_queries.go,...), 4. Implement more complex queries by hand (relationships, multi-query functions) in whatever.go. - request parameter to turn on/off things like fetching authors for each episode. Automation is an attractive approach to deal with verbosity. Of course at some point when the API is frozen, you can just remove the generator and the files could live there, just as if somebody wrote them by hand. &amp;&amp; writing tests is never boilerplate! :)
Maps aren't really O(1). They have O(k) [k = length of key] lookup time since you have to hash your key to lookup a value. Also, their runtime is 'amortized', not worst-case. Tries are O(k) in the worst case, and can take advantage of arrays being in consecutive chunks of memory to speed up traversal over more expensive random accesses in maps. https://en.wikipedia.org/wiki/Trie#As_a_replacement_for_other_data_structures
I started a project a while back for a zero allocations strongly typed httprouter that works by compiling routes, ahead of time. I haven't finished polishing it up yet but I've tested a few different compilation strategies for pattern matches so can comment. I wrote a little about it here: [play](https://play.golang.org/p/yJmz6qPx_N) why I think runtime is worst time to create http routes. For your question, It would be fine for static routes, but routes with segments that have no constraints like "/path/:foo/bar" would be close to impossible to satisfy with a map based lookup. You would need one of two things, a tree structure of maps or a scheme for selecting composite keys at runtime. The issue comes with not getting so bogged down with parsing incoming request segments into a proper composite key without losing the benefit of map performance. For example you could create a lookup key that would cause no allocations and be fairly fast to lookup: struct{string, string, anySegment, string} But how do you lookup every single variation of routes users have? Massive switch statements? You will end up missing some cases and spilling into a slice which will cause allocations. It will be messy while hard to justify against a trie that performs nearly as well, if not better at that point. That said this isn't an issue at all if you hand rolled your routes ahead of time and is pretty simple to do. Edit: I wouldn't have made comments if I didn't benchmark it at some point, here's a snippet that probably runs when I first poc'd out my router: https://play.golang.org/p/ZLdfDQ588q BenchmarkHTTPRouter-24 3000000 514 ns/op 96 B/op 1 allocs/op BenchmarkHandyRouter-24 20000000 57.0 ns/op 0 B/op 0 allocs/op It's contrived and not really fair, it's also poorly written and not resilient to shitty requests etc. But those could all be resolved while remaining around as fast with the benefit of a much nicer API with strongly typed params. I also use regexp.Syntax to parse a simple rune class to narrow matching and it doesn't cost anything extra in terms of performance because I assert it's a linear (onepass) and the instructions are easy to generate code for. The main point I'm making here is I could reply replace the naive FSM approach and accumulate segments instead and use a hash for my look ups. It would be simpler to write by hand than a trie and still faster. Don't forget that HTTP router uses a map for method selection every single request rather than appending that string to the head of the route segments, it's because maps are fast. Though a lookup table for http methods would be much faster. Maps are okay even if inferior to a FSM, they just aren't as well suited for a unknown data set for this purpose. Not sure if you deleted your comment or that was a pm? Regardless, happy coding.
&gt; ​​​​What is actually unusual about these Repos in the year 2017 is that we don’t have an ORM or any other database library generating SQL for us. We’re writing all our SQL by hand. https://github.com/vattle/sqlboiler
Well yes indeed I talked about expressiveness but in the context of simplicity and readability. I am obviously biased because I do not know Kotlin but I usually find it much easier to open any Go code even on advanced projects and read it from top to bottom more so than any other language. It is the same with that 30-line-solution. It is very easy to read while at the same time it is very explicit and does not hide complexity. Meanwhile many expressive languages have tons of magic and hide complexity for example by hiding loops into a single call which makes it even worse if you can chain it together (See accidentally quadratic). The point is not have as few lines as possible. Sure, it makes a language expressive but also hurts readability and most importantly maintenability. I also argued that those 30 lines of Go code are "incomplete" since they lack comments explaining why we need those 30 lines. Meanwhile, if the language provided this magical construct that allowed for a very short solution, would anyone even bother commenting and explaining why is it being used in the context of the project? I doubt it. 
I had a look at restic, and I realize that it's 0.6 but version numbers mean different things to different people and there's significant friction between the marketing and actual usage. It might be better not to go full PR (we are the best) and leave a bad taste to anyone who tries it. Some things to think about: * "Done right" and your "fast, efficient, secure" ... these are general thing all software would say they want. Instead maybe say how is restic different from borg/duplicity/bacula. * https://github.com/restic/restic/issues/982 ... I think this only affects partial restores using include? It certainly worries me a lot as a user. * Easy to use is your first point, but to use it I have to create a script which calls "restic --repo /backups --password-file bar" ... and why can't I have no password? If I then take a bunch of backups "$restic snapshots" is just a giant mess (slightly better than borg, but meh). * The percentage stats. output is ok, but drop some of the numbers and add a progress bar.
also available here: https://www.liveedu.tv/kensodev/lmn7V-github-git-jira-integration/
As a workaround, I think we could have something akin to runtime.LockOSThread() that also stops all goroutine scheduling (and spawning of goroutines would block), so you can do whatever you need to do, and "unlock" the scheduler. Since it's usually just calling a single system call to do something, performance should be negligible. Another alternative is having some call that tells that the current goroutine should exclusively run on this thread, and no other goroutine should run on this thread either, 1:1.
So if you use Xeon, you get a copy of a copy?
/u/dgryski, so are you really preparing your statements? Preparing the query grabs and binds one connection from the pool, so if it goes down - you won't reconnect as you normally would do with simple sql.Select.
agreed, visitor is a good pattern for this kind of problem
Ugh.
Very interesting read. Thank you. It seam the problem is to find the right balance between the simplest API and the most helpful logs. The benefits of the simplest API are obvious: minimize the required knowledge and programming choices to be made. Simplicity is the strenght of Go and the API should be aligned with that. The std log is a simple API, but people don't seam satisfied with it. It has no direct support of log level or structured logging. I like the OP's choice of their three methods for logging. This yields optimal code documention in that there are only three major classes of logging information. However, programs doing complex tasks may need to provide finer grained tagging of logging information. That is the reason why logging systems usually add Fatal, Warnings and different level of debugging info like trace and such. The user should be able to define the level of info verbosity, and the developper the level of debugging info. 
Well, if you serve static routes from a map, then it is certainly faster. But the reason why all trie based routers do not use maps for static routes specifically, is that it is fast enough. Your router performance is the least of your problems in 99% of the cases. What is more important in my opinion is flexibility, for example https://github.com/DATA-DOG/fastroute takes completely different approach to all available routers and it allows to serve static routes from a map, you can compare the performance: Gin_GPlusStatic 20000000 75.4 ns/op 0 B/op 0 allocs/op GorillaMux_GPlusStatic 1000000 1978 ns/op 736 B/op 10 allocs/op HttpRouter_GPlusStatic 50000000 30.3 ns/op 0 B/op 0 allocs/op FastRoute_GPlusStatic 100000000 23.9 ns/op 0 B/op 0 allocs/op So you see that httprouter performance for static routes is also very good compared to map. But since you are using routers, most likely not all of your routes are static and there comes the cost of complexity for path parameters. The radix tree routers will always be the fastest when N is big, but in most cases it is not the case, though they have limitations and in general their githubAPI benchmarks are not true, because they cannot manage full github API due to limitations they have for path matching `/users/new` and `/users/:id` cannot be handled by radix tree routers.
Thanks for taking the time to write down your feedback!
It's actually a bit more involved. The linux kernel implements network namespaces that have their own full network stack, each with their own interfaces, routes, etc. You have to "enter" a certain namespace to see those individual interfaces and such. The issue here is that the golang VM might spin up a new thread, which inherits the network namespace from the parent process, and your specific call to enter the namespace might be on the other thread, so you could end up being unable to find the interface (in this case a bridge). So it's more of a race condition about inheriting the netns from the parent process in a race while you call the function to enter the namespace.
AFAICT from the article, the simple solution would be to pass CLONE_NEWNET when spawning new threads. If this affects the entire runtime, it would maybe be a suitable workaround to make a runtime function ala `runtime.LockNamespace` that prevents threads from being created in another namespace if possible.
Seems I may have been mistaken. Had an issue, googling and found a support issue requesting support for stored procedures. https://github.com/go-sql-driver/mysql/issues/569 I believe there is a difference in how mysql deals with stored procedures and queries, and at one point caused problems. https://github.com/go-sql-driver/mysql/issues/66 
We're using a similar approach at work, but the go code only ever does SELECT queries that call pl/pgsql functions, so managing SQL strings in go is not a big issue for us -- the function call just gets inlined then and there. There are some other difficulties with this approach, though. At first we had each go service "ingest" all function definitions on startup, which was great, because the go code and the SQL functions a piece of go code would use where collected together and atomically deployed. But at some point we wanted each go service to only have permission to execute those particular functions in the database, and nothing else, to improve security. At that point we had to switch to ingesting the SQL code from a separate, higher-privilege process (and they would be stored in a different place in the repo all together, rather than in each services directory) that would then grant the low-privilege go users access to the functions it ingested, so a whole database schema upgrading process had to be put into place, which involved quite some pain. Now we don't have a single .sql file anywhere anymore that defines your schema, functions whatever, but a folder of migrations, and if you want to see the entire picture of what the sql schema, functions etc look like, you have to create an empty database, apply all the migrations in order (flyway) and then dump the database schema. Comments in SQL code/DDLs get lost in this way unfortunately... Also, we really ended up doing way too much stuff in the database (triggers, ...) that should've been done on the go side, which resulted in some problems, but that's a different issue. All-in-all I think the approach is good, though. We use all the modern postgresql features to great effect; json parsing, jsonbs, hash indices, arrays, etc etc.
a gist would be fine. Also, code posted to playground is branded with a BSD license unless otherwise stated. Without copyright headers and branding a specific license that sample code is now BSD compatible per the UELA of the playground. Google has also tried some shady stuff with golang CLA. It is best to steer clear of using these services unless your employer has the legal resources to make sense of the legalese. who throws copyright headers and license info into sample code?
&gt; The best I can come up with What's wrong with something simple like this: https://play.golang.org/p/xdbJsTqvWp
Has anyone used a yesql clone in Go, e.g. https://github.com/nleof/goyesql or https://github.com/gchaincl/dotsql ? They store SQL in separate .sql files that you load instead of having SQL in your Go source. It seems like a good idea to me, but I haven't tried it in real life. 
&gt; What About Immutability? The way I usually achieve immutability is by making it a part of the API: // Caller must not modify the map. Same goes for expressing something is unsafe or safe for concurrent use, etc. It's 95% as good and only 10% as complex. Which is a great tradeoff IMO. Just wanted to share a thought.
There's no need for all those custom types and reflection in my opinion. Keep your structs simple with normal types and in your code that fetches from the database, scan the values into the appropriate sql.NullX type instead. If it passes the ok check, then fill your struct with the value.
Go is a language designed to write tooling and [server software at scale](https://talks.golang.org/2012/splash.article) so that trend is unsurprising.
Ha, I knew I was risking wasting my time attempting to have an argument with the most unnuanced comment in the batch here. It is always fascinating to me that self-proclaimed experts rely predominantly on ad-hominem arguments to make their points. Frankly. 
Is this a learning experience you want feedback on or a public package you will support in the future? If the latter what use cases do you think will make it a better option than [google/uuid](https://github.com/google/uuid)? 
Cool! We definitely need more go streamers on there 👍💪
Cool but it is shit sample code, so that doesn't matter.
It seems like such a small and insignificant thing, what encoding format a feed uses, but it's crazy how much more of a positive attitude I have towards reading the JSON Feed specification. It just seems so simple and clean compared to whatever I was exposed to for RSS/Atom.
&gt; if all you want is to write to a file That implies you want to write to a *file*. If however you only want to write to a *stream* and you don't care about where that stream comes from (which is the point made in the talk) then io.Writer is the way to go. Furthermore the behaviour around writing to the stream is probably different to the behaviour around opening and maintaining a file handle. So most of the time they should be separated. 
Your basic argument is that variable reassignment and object mutation are orthogonal. This is well known; it's why people use immutable or persistent data structures. E.g. for Java: http://www.vavr.io/vavr-docs/#_immutable_data_structures (Scala and Clojure come with immutable data structures as part of their standard libraries).
You didn't waste your time, karma is not the only one to read and you explained it (again) very well, thanks !
Thanks!
That line of code even made my dick bigger. 
I don't know how you handled your possible null values from database rows in Golang. Why are you even asking? You should know!
ViM, Emacs or LiteIDE FTW
Haha! I wonder why! ;)
First to ad hominem = lost the discussion
Thanks for the insight for the production mode I will change it. Though I do not totally agree with you about the dev mode. For me it is really important to have the compilation on file change. I do not want to have to compile it each time a file is modified.
I guess it's different on workflow, but I rarely change a single file in an app while developing. Or if I do, either I'll save it too often or the IDE will handle the saving for me. Personally I don't see when a compile on change is useful but I definitely might be wrong. Is it because of the error checking from the compiler? Is it something else that I'm missing?
War is peace Freedom is slavery Ignorance is strength Errors are values
I use to develop a lot in python with Django. I really like the fact that it reload each time I modify a file. Of course I know that python is an interpreted language as opposed to Go. Maybe I have to think differently because Go is compiled. Though the compilation time is relatively quick in Go. I will see in the future if I will change my mind on this point.
From my outsider perspective, projects like Kubernetes and Cloud Foundry (both multi-million line Golang systems) are using Go mostly for the runtime properties, particularly cheap/easy goroutines and fast launch. Plus considerations of ecosystem size and momentum. At the time Cloud Foundry began writing almost all new components in Go, and rewriting core components in Go (maybe 5 years ago? I'm not exactly sure), there were languages better suited to programming in the large. But none with the sweet spot of cheap concurrency, launch and ecosystem.
Yeah, like that work... Even if programmers don't ignore this, the will probably pass the result forward, and that function may not have this warning.
Thank you for your comment. I just modify the production part to use the multi-stage dockerfile. Now the size of the production image with the hello world example is 5MB.
Okay, cool, but you can't control the scope where that map will be used, regardless of docs. The snippet you quoted is not related to this problem in any way. And no, you should relay on documentation, because that may go out of date, or flat our contain false information. Only code, that is validated by the compiler is guaranteed to be correct. 
Sure. Lots of tradeoffs in choice of language. 
That's fine with me - let's agree to disagree.
&gt; I don't like Go What are you doing here then? *"There are only two kinds of languages: the ones people complain about and the ones nobody uses"* I am continuously amazed how true this quote is for Go.
&gt; What are you doing here then? I overheard the kerfuffle. &gt; I am continuously amazed how true this quote is for Go. I am continuously amazed that this notorious thunderbolt of multi-gigawatt arrogance is used to support anything.
So the many people who use Go are arrogant? Or they use arrogance to defend why they use Go? Seriously? 
What a useless comment. 
Well I've written production Go myself, so I guess at least one arrogant person uses Go. I was looking forward to it before I started, and then I started. In any case, I'm saying that the quote, made about C++ by Stroustrup, was an act of remarkable arrogance when he said it. Picking at random from wikiquote, I think this one would have covered this conversation pretty well: &gt; Anybody who comes to you and says he has a perfect language is either naïve or a salesman. I work for a company responsible for a multi-megaSLOC Golang codebase. If you asked me today what language to use for the current ways we use it, I'd say "Go". None of the alternatives have the sweet spot of runtime properties and ecosystem size suitable to the problem domain. I accept that Go is good at what Go is good at. But that doesn't mean that it is *uniformly good*.
You can have one without the other, which is the crux of the argument against this verbose pattern. 
Maybe it would pay to think about Go in Go. Go is quite different from Python. Whenever I use a given language/runtime/etc I try to think in terms of said environment and not just try to map things over from one to the other: to me it seems like translating human languages word-by-word directly, which provides terrible results.
Why is that better? You're still shipping around an alpine environment that's not necessary. 
The difference is that you don't need to create the image with the development environment anymore. For Go i think you could even use a more barebones image like busybox or scratch.
Alpine is great because it makes it easy on you if you have any requirements outside your binary; any C libraries, CA certificates, an init process, etc. At &lt;4MB it makes a good default.
Yeah, actually now that I look at it closer, I like building in a self contained env and then shipping the binary on top of the scratch image. 
I work in a Java shop so it's much more difficult to use something like scratch and we have had really good luck building on top of alpine as a base image. The rest of it seems counter intuitive when creating go based images though. It seems like one should explicitly include all that is necessary for the application instead of treating the container as a VM. - libraries can be "vendored" or versioned explicitly with the application - ssl certs can be mounted in the container either from the host or an orchestration tool like Kubernetes - with a static binary, shipped as a single concern, an init process usually isn't necessary Obviously, there are exceptions to everything so I know that's not always possible.
Oh if it helps, i am redirecting HTTP traffic to the HTTPS port
The [effective go](https://golang.org/doc/effective_go.html) doc , provides a good implementation and structure of Go code. For learning the fundamentals from [A tour of go](https://tour.golang.org/list) is a good place to start. Other useful link: [LearnGo](https://www.miek.nl/go/#idxref:75-0), [GoByExample](https://gobyexample.com/),[Wiki of material for go](https://github.com/golang/go/wiki/Learn) and the subreddits [resources for new go Programmer](https://dave.cheney.net/resources-for-new-go-programmers) 
Definitely looks like probes for older, weaker cipher suites that could be exploited. Shouldn't be any cause for concern though. Unfortunately stuff like that has become part of the Internet "background radiation"
This [Idiomatic Go](https://dmitri.shuralyov.com/idiomatic-go) guide contains lots of examples of idiomatic/good go code vs bad code.
Wait, you dont understand spoken English?
I taught a class like this. The outline is here: http://is.gd/gobootcamp. There are many example problems in there. Links to source code and videos are here: http://www.golang-book.com/guides/bootcamp. App engine or heroku will be the easiest way to get started. A Twitter clone is a fun app that you can teach basic CRUD with.
You might also find this useful: https://peter.bourgon.org/go-best-practices-2016/
Are you doing a http redirect, or a port forwarding?
https://en.wikipedia.org/wiki/Result_type
it's so minimal it doesn't even have generics 
Ok, solved the "some don't get executed issue". I wasn't using blocking receives to wait for the goroutines to finish, so the `main` was just happy to finish up/exit the program lol. Solution is.. quite sloppy though. Is there a better/idiomatic way to rewrite this `for` at the bottom of the loop? Also, still haven't figured out why they're not in order, and even more puzzling, why they're always in the _same_ incorrect order. Any hints would be appreciated! package main import "fmt" func main() { msgs := make(chan string) go func (){ msgs &lt;- "pls" msgs &lt;- "be" msgs &lt;- "in" msgs &lt;- "order" close(msgs) }() done := make(chan bool) for i := range msgs { go func(i interface{}) { //func closure on i - so each goroutine gets its own copy of i fmt.Println(i) done &lt;- true }(i) } for i := 0; i &lt; 4; i++ { &lt;- done } }
By putting the actual printing of the value in a goroutine, you lose the guarantee that the prints happen in order. You lose the guarantee because goroutines will perform at non-deterministic times. If you remove go from your print, you'll observe that the channel actually does send items in order.
I understand while it's something like "I would like a cup of coffee". But not the given case :)
I responded with why the order is wrong, here's an example using your constraints: https://play.golang.org/p/cPKs7V0FJh and here is what I think you want to actually do: https://play.golang.org/p/9Uq2EU7ip7 - You were close just had one too many for loops. Essentially you want to communicate from one place to another while waiting for the communication elsewhere. So make to places (goroutines), send from one to the other and let the destination signal when the conversation is over. Goroutines leave an easy trap early on because the little buggers are so fun, but things get much more complicated quickly as things get more concurrent.
You'll need to [add some things if you go with scratch](https://sebest.github.io/post/create-a-small-docker-image-for-a-golang-binary/), notably SSL CA certificates, perhaps timezone/zoneinfo, etc. By hand.
Note: I wouldn't advise to mount the SSL CA certs for security reasons. Most likely you'd mount a central/host location, meaning that if one of the containers would be compromised, you would extend that issue to all containers because of the shared location. Filesystem isolation in such a case is a good thing, rebuild your container and include the SSL CA certs in the image. Or, definitely, use alpine.
1. Cleared my code on syntax error. 2. Not following indentation is annoying.
Thanks for the PR. It is merged.
Oh. Thats new to me. 
My keyboard doesn't have a [whatever this thing is](http://i.imgur.com/BiVo6YX.png)
i did something similar to this here https://github.com/lacion/cookiecutter-golang, im using a build container and then a final container, i'm waiting for multistage to be more widespread before moving to it.
Google also has a UUID package (https://github.com/google/uuid).
Comment is gold
With respect, I think hegbork here may have accidentally stated that more harshly than was perhaps intended, but it is correct in its essence. There _is_ no "correct order" of goroutine execution. If you have a "correct order" in mind, you must use some sort of synchronization construct to tell the runtime about your constraints, and even then bear in mind that you only get the guarantee for only and exactly what you put in those constraints. Assumptions about goroutine execution order are something you need to consciously stamp out. This is not unique to Go; this is a characteristic of concurrency in general. Even programming in single-threaded code won't save you from the fundamental non-determinism of network ordering, for instance. As you saw in the original code snippet, once you type `go` you're not even guaranteed that that goroutine will execute _at all_, unless you somehow ensure that the main goroutine will synchronize on it before it exits. Now, it's a common thing in servers for the main goroutine to somehow lock on something and let the runtime do a best-effort execution of the rest of the goroutines, and in practice that works just fine. But it's not because it's guaranteed.
I'd definitely like a way to set the tab width. I can't deal with 8 character indentation.
But that's the official go style tho, so I think it makes sense 
Official Go style is using tabs instead of spaces. This is using tabs, but the tabs are quite long. Many programs allow you to change the width of a tab.
What's stored in the file doesn't have to match what you see on the screen.
Agreed, I'm just pointing out that following (or in this case, not), the official Go style seems like a sensible default :) 
Link seems to be broken...
Java has had immutable collections since the collections API was introduced in version 2 in 1998.
This was chrome.
Same 
Awesome. Will fix.
Good discussion on the matter here: https://peter.bourgon.org/go-best-practices-2016/#repository-structure
NaCL isn't dead. It will still be used internal to Chrome (to sandbox code) and as far as I know NaCL is still a viable go compiler backend output. Nothing has changed. What has changed is chrome has decided to stop shipping the web user PNaCL (the NaCL was already removed) environment. That is all.
Found a bug: it shows the mac pretzel key even if you are not on mac.
sorry fixed now
Yes I messed up somehow. It is fixed now
this is a premature optimization if profiling reveals memory issues stemming from bool vs struct{} then it's worth looking into
Returning nil is always preferred.
cannot use _ as a value
&gt; If returning nil is better, is it OK for me to occasionally return new(myStruct)? If you find yourself wanting to do this, my guess is there's something odd elsewhere in your code. That being said, it's probably fine to do so internally, but you should generally avoid doing so in anything that crosses API boundaries, and, even if the use is internal, I highly recommend trying to restructure the code that needs it to do so that it doesn't need to do so. Also, it *is* alright to return a valid value alongside an error in some cases. For example, [`io.Reader` allows implementations to return an error alongside the number of bytes read](https://godoc.org/io#Reader) if an error is encountered while reading data.
Thanks for the detailed explanation. I opted to returning nil, fmt.Errorf() and my code works fine!
My guess: Speed = errors.New() More Functionality = fmt.Errorf()
Fixed (make sure to reload the page for it to pick up the new JS).
[They are completely identical](https://golang.org/src/fmt/print.go#L204). The only difference is that Errorf allows one to format their error message. Unless you mean, which one to use from code style point of view. If so, then I'd propose to always use custom errors types :)
[This blog post](https://pocketgophers.com/idiomatic-go/) is a link collection around the question of what "idiomatic" exactly means in Go.
Custom error types that fall under the error interface you mean?
If you want a truly empty struct to be a valid value, then you're probably better off returning a nil but making the methods on that nil be "valid", for whatever the appropriate definition of "valid" is. Contrary to widely-supposed opinion, [you can call methods on nil perfectly fine](https://play.golang.org/p/pG4y2ijOh4). Unlike C or C++ where a NULL pointer is missing its type information, a nil pointer in Go is actually (PointerType, Value), where the Value is the nil. Go can still reach the method even on a nil pointer value just fine.
`errors.New(fmt.Sprintf())` is reasonable if you are okay with importing both fmt and errors.
oh, so you want to be able to output level=error caller=example_test.go:18 err="bad data" it could be done easily (go-kit does this)
Specifically, he was referencing a proposal that had been made to allow `_` as a value when the type is known as a zero-value equivalent of `nil`, essentially. 
Always check errors and return nil imo, deviating away from this sets you up for traps down the road and it doesn't really save you anything not to.
easiest workaround is to name your returns: func foo() (res myStruct, err error) { return res, fmt.Errorf("an error occurred") } 
*facepalm* I am well aware of what it is. I was being facetious in that OP designed his UI only to cater to Macs.
The shortcuts are supposed work on any platform (with Ctrl or Cmd). The fact that I use a hardcoded clover symbol is just plain laziness. Wanted to make sure the app works correctly first, then do this kind of polishing. Didn't want to offend anyone.
Thats what fmt.Errorf is...
glog does it too, but it has to be handled explicitly to be wrapped, and that means any wrapped log API has to support it.
I for one like syntax highlighting. Some people are really picky about colors, so don't expect to please everybody ^^,
I'm SO TRIGGERED!! :P
Uh... your factual error about Java and C++ aside, I'm pretty sure that Cobol still outweighs all THREE of these languages. That means, by your argument to popularity, that we should be looking to Cobol for our design tips.
That's not unexpected at all. And following the [golang faq](https://golang.org/doc/faq#methods_on_values_or_pointers) on this would prevent a panic there. &gt;If some of the methods of the type must have pointer receivers, the rest should too, so the method set is consistent regardless of how the type is used.
It's called SQLite?
It didn't actually do sleep when I wrote time.Sleep, while the go playground does (actually there was a talk on OSCON '2014 on how they built go playground, and time.Sleep is one of the challenges).
It's not complicated, but it's quite limiting. I mean, how often do you need protection within a single scope?
Is he talking about putting project packages in a pkg subdir, like in https://github.com/camlistore/camlistore/tree/master/pkg ?
yes, as it's an empty package that isn't importable by convention
I think it's a nice way to organize my packages. Will need something nicer to use in its place.. which I don't see here. Does he suggest an alternative?
That's pretty cool!
Naming is very confusing. I thought it had something to do with [actual sqlite](https://www.sqlite.org/). Also, fyi, the name sqlite is [trademarked](https://trademarks.justia.com/771/04/sqlite-77104711.html) in the US.
I wrote a bit about this here in case you are interested in reading more - https://www.calhoun.io/why-are-slices-sometimes-altered-when-passed-by-value-in-go/ Doesn't exactly answer your question but helps explain what is going on behind the scenes a bit. 
no vim mode? :( but it's really nice tho! must say the keyboard shortcuts makes it feel more natural to use than the official playground, nice work!
Cool idea!
[Relevant XKCD](https://xkcd.com/927/)
No offense, but it smells like Java. I understand the need to represent things using models and -- since they're restricted by the language design -- a package per directory, but this seems very "namespacey." I came from a similar headspace when I started writing Go. For instance, writing a simple SDL program, I broke it into: /main.go /state /ui There's nothing wrong with this and it lets me duplicate names in each package (or alias imports) if I really wanted to do so, but these days I'd probably do something like: /src/main/main.go /sdl_thingy **Flattening all the things** What I've discovered over the past 18,000 (or so) lines of Go is: * If you've got something that really is a separate domain, it may belong in a different repository (to use the Git term). * If you've got something that's looking at all generic, plan to extract it. * Keep your packages relatively flat and focused. So much of what we're seeing other developers recommend is appropriate for { Python | Ruby | C# | Java | C++ | Rust } but isn't for Go. When I started writing my big SSO project for work, I tried to emulate the model we had for Java: Web Service Authentication Application Account Management Application But even that doesn't work well because we don't "plug" parts in with Go (well, unless you're using [Plugins](https://golang.org/pkg/plugin/), but that's more like dynamic libraries). Instead, I had to look at it again, and now I have a module or repository structure that looks like: go-accounts (common account data structures, LDAP and RADIUS functions, SAML documents) go-couchbase (key-value store implementation; in-memory KVS cache) go-keyvaluestore (key-value store interface, utilities; also implemented in DynamoDB, Hazelcast, and others) go-pool (connection pooling) auth (authentication handlers, functions) reset (account management handler, functions) server (web service; templates, static content, JS, CSS, configuration) utils (utility functions specific to the app; context, properties, MySQL wrapper) And each module usually contains only one package (except utils) and packages aren't more than one layer deep. go-accounts accounts/ account.go (types, methods) ldap.go (wrappers, logic around LDAP authentication) radius.go (wrappers, logic around RADIUS authentication) saml_artifacts.go (SAML ID and token functions, token cache) saml_messages.go (SAML message type, marshaling/unmarshaling) (plus unit tests) **Concrete advice** I'd recommend you get a nice IDE or editor that lets you hop to definitions, and break your sample application's domain model into multiple modules. You'll keep them focused, decoupled, and reusable. customer/ catalog/ order/ And now your application can glue these together along with your web application implementation, database library, etc. It took me an embarrassingly long time to refactor my own code this way but the benefits from moving away from a Java-style model to something more idiomatic for Go have been tremendous, improving testability, reuse, and bug fixes/enhancements.
You can make pure of DLLs, but they would expose a c API.
Tab width setting has been implemented. Check it out!
I've explored the depths of Golang (as far as I know), and I understand the fundamentals of interfaces, but the only two things I've never used in my code: My own interfaces because I'm too scared of when to use them and I don't ever see a need for them (although I may be wrong). And, custom errors.
Awesome! Never heard of it before. One wish, a link at the top of the github page to the godocs is always nice. https://godoc.org/github.com/json-iterator/go
You may need to remove the question mark soon.
VIM mode would be amazing.
Thanks for the reply and reading the article. At this point I have written more Go than Java :) ~2yrs. I think the clear separation of things like web and database from your business logic is the key here and is language agnostic. If your app was relatively small then you may decide that you really only have one domain. If this is the case, then you may not need any sub packages and it would flatten it out. If your app grew larger and you realised there was a clear new domain, you could then refactor.
Nice! Next step: copy&amp;paste images :) Tip: Don't put the binaries into the source tree. GitHub lets you publish binaries as "releases", separated from the source code.
Actually I think the theme is a variation of Spacemacs Themes. :) Check it out here-&gt; https://github.com/syl20bnr/spacemacs/tree/master/layers/%2Bthemes/themes-megapack
[I collected Go plugin mechanisms](https://appliedgo.net/plugins) a while ago. (Yes, this was before Go's native plugin mechanism existed.) However, if "RPC" includes any kind of out-of-process plugins, then I guess there is no alternative to that besides the plugin package or source-level (i.e., pre-compilation) "plugins". Or perhaps script interpreters - but these are not an option if you want to write the plugins in Go.
I would need clear measurements showing me why I should prefer this to the stdlib before I looked closer at it. I see that there are some benchmarks in the *_test.go files, but they are not comparing stdlib to itself. 
https://twitter.com/davecheney/status/871861032603443200
Do you feel the structure I have laid out is encouraging empty pkg? Every pkg has something in it here
Yes, the pkg package in your layout is empty. In my opinion, which is also shared by a number of gophers over github / twitter, this is an anti-pattern.
Looks cool! It would also be nice to have a borderless mode with transparent background.
Not only is this awesome, the author has been wonderfully responsive regarding bug fixes / feature enhancements. /u/iafan it may be worth including a link to the github repo somewhere on the page so people can easily submit feature requests, issues and pull requests, as well as just browsing some great code :-)
There's a link to the repo along with the voting button in the embedded readme (on the right pane of the app). Thought it was prominent enough. :) But just in case: https://github.com/iafan/goplayspace . Of course, bug reports and feature requests are welcome. The most welcomed PR I'm waiting for is some tree-shaking algorithm in GopherJS. I love the library, but I wish the compiled JS would weight less...
yes. currently used by 1000 games with 10 EC2 hosts . that's why i am worried if I have any memory leaks. 
Any chance for subtitles?
&gt; Naming is very confusing. Please explain why. &gt; I thought it had something to do with actual sqlite. It has *everything* to do with actual SQLite. It *is* the actual SQLite with a bundled database/sql driver. The DB [engine](https://raw.githubusercontent.com/cznic/sqlite/master/internal/bin/bin_linux_amd64.go) is compiled from *unmodified* `sqlite3.c` source. &gt; Also, fyi, the name sqlite is trademarked in the US. If you think there's any kind of violation of any trademark rights please elaborate as I want to fix it in such case. But I'm not aware of anything like that.
The only reason I can think that I'd want to return an empty pointer (new(myStruct)) is if I knew it was being encoded to JSON to avoid null as the value. If this helps me, is it reasonable for me to switch to new(myStruct) to avoid my json from returning null, or should I still return nil and find another way around?
Two talks not in mandarin. * [Google: Understanding Go Interfaces](https://www.youtube.com/watch?v=F4wUrj6pmSI) by /u/campoy * [Atlassian: The hidden #pragma's of Go](https://www.youtube.com/watch?v=nmcPwqjPFbw) by Dave Cheney edit: I just realize that presentation is typed with spelling mistakes. At least Dave's one. 
Or golang.org/x/tools for example. It's a single git repo, but things like `go get` won't work with it. Instead, you need to find where the Go files for the specific cmd or whatever reside and use `go get -u` in that directory. It's nice that it's a single git repo because I can just pull the changes, but it's annoying to deal with that just to update a single Go package.
A little off-topic, but, i think `fmt.Errorf` is confusing. People, me included, tend to think that `fmt.Errorf()` prints something. Instead it returns an error. A good [example is a comment on a PR](https://github.com/AdvancedClimateSystems/goldfish/pull/8#discussion_r120100492) I got this weekend. I think `errors.Newf()` is more clear. 
Except I make no effort to meet everyone's needs, only my own.
I disagree with Dave here and agree with [Peter Bourgon](https://twitter.com/peterbourgon/status/872040916751613952). It has a clear use. I also, once again, think that this is an instance of making a broad, overgeneralizing statement, not explaining at all *why* you are holding that opinion and then using "space" or "time" as an excuse for being impolite and abrasive. It still saddens me, that behavior like this is not only tolerated by the go community, but even held in high regards… :-/
In this example: for v, ok := &lt;- c; ok ; v, ok = &lt;- c { // do something with v } What is the purpose of the third statement in the for?
Oh thanks man... Didn't notice.
That's what lets you get new values. The three parts are 'init' which is only run once, 'condition' which is checked each time to keep things going or break out, and 'post' which helps iterate so you aren't stuck looking at the same value. See https://tour.golang.org/flowcontrol/1
&gt; So why isn’t there a version of close() that lets you check if a channel is closed ? Seems to give a non-answer to the question, IMHO. There is a version of receive that lets you check if a channel is closed, that is race-free, but it looks very different from what he proposes: select { case v, ok := &lt;-c: if ok { // do thing with v break; } // c is closed } Now, clearly, it is possible to *implement* a send too, without any races (I mean, just omit the `panic` call in the runtime, really). An argument based on "there is no syntax for this yet", doesn't really explain anything. The reason usual given for why sends on a closed channel panic, is that closing is a writing operation and there should be a clearly distinguished writer to a channel. Whether or not that is a convincing argument depends on your preferences. [edit] urghx, he referred to close, not to send, but same difference.
This package is unique, it's transpiled C code into Go, thus avoiding Cgo, check out the internals https://github.com/cznic/sqlite/tree/master/internal/bin
Oh, of course. I was thinking of an if, not a for.
Right, got it. I was thinking of an if, not a for. Thanks!
Hello Pud11es, Go is General Purpose Language which means it can solve broad variety of problems. Make sure you go through Golang standard library documentation to get to know what Golang is capable of. But basically it can handle everything languages like Java, php, nodejs, C, python,... do. Go application (doesn't matter if it's webapp, cli app or gui app) is compiled to binary. If you want to build webapp, then webserver is included in the app source (unlike php or java, where application server is separated from source code). This approach is similar to nodejs. In practice, you create binary code which listens on some port, then you execute binary which spawns process listening on some port. You don't need to know docker for creating web apps in Go (but it's handy nowdays). Don't forget the Go. It's very promising platform. It's actually pleasure and joy to write in Go. link to udemy course: https://www.udemy.com/go-programming-language
Indeed! They are useful in select statements, to disable a branch. A common case is with contexts: select { case &lt;-ch: /* code */ case &lt;-ctx.Done(): return nil, ctx.Err() } If the context has no expiry, then Done() returns nil so the select will wait on the other channel without extra code. Without this behaviour you would have to have two different selects depending on whether or not it was nil.
go get -u path/cmd/...
Okay so I'm going to attempt to play devil's advocate and ask what are the advantages of Go over Node, bearing in mind that node is also very fast and very popular
Qt is open source if your code is open source. You must buy licence if your code is closed source.
Go is strongly typed compiled language, node (javascript) is interpreted language requiring nodejs runtime. While node being faster than other languages used for webapps, the go is even faster (a lot actually). But keep in mind that you don't need performance of go for every project. For most cases node performance is just fine. This considered, writing in go is much more reliable than writing in javascript. In node you basically create your apps utilizing libraries from npm, where in go you are actually programming utilizing great standard library. Just try to create some small apps in both languages and you'll see what suits you better. Major advantage (also it can very easily be disadvantage) for Node is that it's written in javascript, the language all frontend guys knows. You also got better templating support (search npm for Jade/Pug).
&gt; So no, this isn't a check if a channel is closed, this is a blocking-read operation that will fail when a channel is closed. Whether or not you block is orthogonal to what I was talking about. I talked about the fact that Dave claimed it's not possible to do this race-free. Which it is. If you want race-free and non-blocking, add a default clause to my example. &gt; Dave quite correctly gave an example of a non-blocking check function, and gave the completely valid answer that such a function would be inherently race-y Yes, such a function would inherently racy, but such a function also wouldn't be the obvious design for a race-free way to check if a channel is closed on send. An example of how to fix what you say would be, to augment a send statement with an additional boolean; let's, for sake of argument, say by making it an expression that returns a boolean. A send on a closed channel then immediately proceeds, returning false (instead of panic'ing. This is the "just leave out the panic in the runtime" from above, the check already happens to trigger the panic), while a send on a non-closed channel behaves as it does now and returns true. You could then (assuming `c` is a channel and `v` is a value): // send a value, blockingly, if the channel isn't closed select { case c &lt;- v: } // send a value, non-blockingly, unless the channel is closed: select { case c &lt;- v: default: } // Send a value on the channel, if it's not closed. Panic, if it is select { case ok := (c &lt;- v): if !ok { panic("sent on a closed channel") } } // Same, but not blockingly select { case ok := (c &lt;- v): if !ok { panic("sent on a closed channel") } default: } This allows exactly the proposed use-case ("send a value on the channel, unless it's closed") without any races and easily implemented and understood semantics. If you want to allow racey closes, you could just not panic on double-close and, again, return a boolean, indicating whether the operation succeeded. Notably, it doesn't implement a way to check whether a channel is closed *without* sending on it or closing it, but that is, again, immaterial to the discussion. Because those are the cases in which a race is present, which what this is about. If you *do* believe that doing such a check without any operation was useful, you could still add the function as proposed by Dave; as the raceyness doesn't matter, there wouldn't be a problem with that anymore. Now, you could also do things differently; you could, just as with `,ok` for type-assertions, allow these things to *either* be used as statements with the current semantics, *or* be used as a boolean expression for above semantics. Or you could add a `,ok`-ish form to send-statements. Or you could… This might not be *nice* syntax. But it is not at all difficult to come up with ways on how to implement any sensible use-case in a race-free way, mostly using existing language constructs. So it shows that neither raceyness nor implementation-difficulty is the driving factor behind the decision not to add any of those. Raceyness is just the reason given to people who simply propose to add a `isCheck`-function under the impression it would help them. There are two reasons left here: a) they couldn't come up with a nice syntax, so they decided that the tradeoff of adding this usecase isn't worth it, or b) they *didn't want it*. I am pretty certain, that the latter is the case, because the whole *idea* of allowing sending operations on a closed channel is considered bad. As a bonus argument, by the way: You *can* already do sending operations on a channel without panics: // None of this is actually tested, but the ideas should be relatively solid. // tries to send v on ch and returns, whether ch was already closed. func trySend(ch chan&lt;- T, v T) (ok bool) { defer func() { recover() }() ch &lt;- v return true } // tries to close ch and returns, whether it was already closed func tryClose(ch chan&lt;- T) (ok bool) { defer func() { recover() }() close(ch) return true } // tries to send v on ch. Returns a channel that exactly one bool can be read from, that tells you whether the send succeeded. func trySendSelectable(ch chan&lt;- T, v T) (&lt;-chan bool) { out := make(chan T) go func() { defer func() { if recover() != nil { out &lt;- false } }() ch &lt;- v out &lt;- true }() return out } You shouldn't see that actually used in any code. Because it's a bad idea to do. But it's not *impossible* to do without races.
I'm open to suggestions, if you've got anything you think would be an improvement!
This helped me a lot. https://dave.cheney.net/paste/gocon-spring-2016.pdf
It's like a way shitter version of [python argparser](https://docs.python.org/2/library/argparse.html)
&gt; python argparser Here I was thinking it was more like adding a simple env vars extension to the the built in Go flag package :D
Video linked by /u/goboy123: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [Go Tooling in Action](https://youtu.be/uBjoTxosSys)|JustForFunc|2016-06-02|0:41:51|843+ (99%)|31,223 &gt; In this video I cover some of the dev tools that I use in... --- [^Info](http://www.reddit.com/r/youtubot/wiki/index) ^| [^/u/goboy123 ^can ^delete](http://www.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dijdvtm\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v1.1.0b
This is not checked by the compiler. 
Any sources for that? Reflect package uses interfaces to extract type information (i.e. reflect.TypeOf takes an interface{} so when ur assigning the pointer, the compiler inserts type information to interfaces type pointer)
And the way that works, and the way interfaces work, is by tracking the type. I don't know exactly the breakdown between what is done at run time and what is done at compile time, but that's subject to change without notice anyhow because that's an implementation detail. What matters at the Go layer is that, yes, the types are always tracked and pointers always have their type attached to them in a way that C pointers do not. Or, to put it another way, the source for that is exactly the observation you just made. Go couldn't do that if it weren't tracking types.
Unless go gets inheritance(it never will), there is no need to make every pointer type contain additional information. I don't think its an implementation detail because go "laws of reflection" article clearly states only way to do reflection is through interfaces because only they store type information. I dont have time to look at go spec right now. Im not familiar with C pointer but IIRC you can cast any pointer to any other pointer and break the type system. Go also offers this using unsafe package. But as interfaces store type, trying to break type system will panic. 
How about some constructive critique?
First off: Thanks for taking the time to explain further! It's a great example of already edge-case channel/receiver implementation that isn't racy. I'd read this again if it was in blog format, just saying :) There's some other things to factor in, with thoughts to reliability, when doing the above - a send to a channel with select/default will fail in other cases, which don't necessarily mean that a channel is closed, it may just be full. Or, no receivers may be ready to process the send (which could happen in a high concurrency environment very easily). The first example because of this is incomplete as there's no way to differentiate between these outcomes. As Dave Cheney writes, a blocking send to a closed channel will panic. Something like the `try*` functions you came up with handle this specific case with recover quite well! The obvious issue is that it's not a true check if the channel is open (for reading as well, as the channel is bidirectional), but it's a reasonable attempt. But for something closer to best practices, the [referenced article should provide better guidance](https://blog.golang.org/pipelines). Thanks for the very good attempt!
This is an old but still relevant article by rsc about how interfaces are implemented https://research.swtch.com/interfaces. Might be even easier to read the source now since its in go https://github.com/golang/go/blob/master/src/runtime/runtime2.go#L148 https://github.com/golang/go/blob/master/src/runtime/iface.go. Type assertions are also done at runtime by tracking the concrete type
https://github.com/fatih/vim-go It would be nice if changelogs could have a description for the unknowing.
Why should I have to click more than once to find out what vim-go actually is/does?
Very cool, any chance you could point me to the gopherjs code that does that in github?
I've posted this to the Golang subreddit and a lot of people know what vim-go is. If you're unknown to what `vim-go` is, I think clicking on the homepage is a fair compromise, if that is what you mean :) 
&gt; a little bit heavyweight on the dependencies, I think :/ I definitely can see how it might look heavy from the outside, but that's mostly our standard stack so for us the architecture is pretty logical. &gt; Did you find a secure way to run docker build without passing the host docker socket to furan ... Furan respects `DOCKER_HOST`, `DOCKER_API_VERSION` etc the same as the docker CLI binary (we leverage the Docker Engine API, we don't shell out). In practice, this usually means exposing the docker socket to the Furan container, as you mention. Given that this is an internal microservice we aren't too concerned with the security ramifications. 
&gt; they are not comparing stdlib to itself What does that mean? At any rate, detailed benchmark results can be found here: http://jsoniter.com/benchmark.html Discussion of other reasons why you might want to use it: http://jsoniter.com/ It's a *much* faster, mature, well-tested, fully compatible drop-in replacement for the stdlib implementation — what else do you need to know exactly?
Test with *BOTH* the environment variable and the matching command line argument. The former should never override the later.
Further, ideally the environment variable should just change the command line argument's default value (IMO) but this makes it indistinguishable from an actually present command flag. I.e. in the example, with `MYAPP_PORT` set to any non-empty value the behaviour of things like `flag.Vist` and `flag.NFlag` are changed the same way the presence of `-port` would. That should at least be documented.
Oops! Thanks for the heads up. This should be fixed now.
I've switched to just using `pkg/errors` everywhere, since it provides both, as well as wrapping errors properly. It annoys me (irrationally) when I have to import both `errors` and `fmt` to do error handling.
Which function? In any case, no, not really, unless you want to switch the semantic meaning of the return and I'd consider `ok` to be idiomatic for something like this. The default value of the named return would be "false". So you either need to add a `ok = true` in the beginning and a `ok = false` in the defered function, which seems strictly worse to me. Or you swap the semantics of the return (e.g. naming it `closed`), so that the defered function can flip that from false to true. Which would destroy the analogy to `,ok`. The way it is, the value is flipped to okay on return and stays false, if the return isn't reached. Works elegantly, IMHO. [edit] I just realized, my comments are the wrong way around. I.e. the comments refer to the `closed` semantic, but I implemented the `ok` semantic… d'oh! :)
I'd assume that the generator for ch would also use the context to stop producing items and close ch. That would then raise the question of if you want to just make sure you empty ch, or risk a goroutine leak where ch is blocking on write and the reader is no longer emptying it. Although it's dangerous to generalize, it's probably safer to use ctx.Done() to to abort writers than readers.
My feedback: thank you, vim-go is a large part of why I love Go, you're awesome.
Super helpful input! I hacked this over lunch at some point and totally didn't catch any of these.
&gt; New :GoKeyify command that turns unkeyed struct literals into keyed struct literals. Fuck yeah. 
They're useful for passing values between goroutines, something that might need mutexes in other languages to do safely. Here's a useful talk by Rob Pike about concurrency in go, he covers channels as well: [Go Concurrency Patterns](https://youtu.be/f6kdp27TYZs). He talks about channels around [10:17](https://youtu.be/f6kdp27TYZs?t=617).
It's not compatible. Why jsoniter is faster is that jsoniter doesn't check many things strictly. https://play.golang.org/p/h1oEbEfM7L 
Channels are primarily valuable synchronization primitives. See https://golang.org/doc/effective_go.html#channels and https://tour.golang.org/concurrency/2 (in other words, they coordinate work and timing of goroutines)
vim-go doesn't change anything regarding autocomplete, in fact it doesn't have any kind of autocompletion feature. That is provided by other plugins. if c-x c-o works, that means vim-go also works. I assume one of your other plugins may cause problems. 
Depending on the circumstances, that may be fine, or you may also want to make sure that other goroutine uses the same context so that it aborts, or this may be a worker goroutine that is spawned off of the goroutine on the other end, and so it's not responsible for cleaning up. It really depends on the situation.
This bugs the heck out of me too. I hacked together a pretty print function using Antlr4 just so I could make my templates sane after parsing.
Took a moment to slap in those referenced changes. Thanks again for noting these - I actually built this for some of my own apps that essentially never take CLI assignments, so I never considered the combination caveats or side-effects (also now doc'd) - which is sort of bad since I did make this open for public consumption :d 
You can use hypen to trim space before and after templates [like this](https://github.com/cstockton/go-conv/blob/927c0d2da3e0a9499ac27d1f078a82437dca2dce/testdata/numeric.go.tpl) to have proper indentation. It's a bit tedious at first but once it clicks it's no big deal.
&gt; People, me included, tend to think that fmt.Errorf() prints something. You are probably one of the few. Even if you know nothing about the language, if you try to read `fmt.Errorf()`, it reads like "format error", which is exactly what it does.
They're awesome for coordinating concurrency, like this: https://play.golang.org/p/TFxkEK6PG_
Literally I put "Go" not Go or golang or anything else
It doesn't work against the design of the language or impede productivity. I haven't seen a single argument against it, folders are used to organize files. Having a directory with your packages so you don't have crap like cmd, makefiles, readmes, docs dist bin and on and on mixed and matched with your application makes perfect sense.
After a good night's sleep, I realized that the most likely use case is for a HTTP client which already supports deadlines/timeouts. Obviously not the only one, just the one on the surface :)
Doesn't help in this case
And fixed :)
Shit, this example is fucked up. Most likely I'd just go fmt the output because shit, it's taxing enough to write in a meta-language to generate code source, without having to pay attention to indentation as well.
Calculating fibonacci numbers is not complex, why would you need all those goroutines? Also, you should probably use math/big because fibonacci numbers increase exponentially. func Fibonacci() &lt;-chan *big.Int { c := make(chan *big.Int, 1) go func() { a, b := big.NewInt(0), big.NewInt(1) for { a.Add(a, b) a, b = b, a c &lt;- a } close(c) }() return c } 
The program reads from stdin, so you need to provide some input with duplicate lines, for example: $ cat test something else duplicate and another duplicate $ cat test | go run main.go 2 duplicate 
There program reads from standard in, so you have to pipe a file to it, eg: cat file.txt | ./dup or ./dup &lt; file.txt Also, the program prints nothing if the input contains no duplicate lines.
I assume you're talking about `dup1` here. The program will read from `os.Stdin`until it reaches `EOF` (End of File), which for stdin only happens if you (as the other commenters suggest) pipe a file into the program, or if you hit Ctrl+D (at least on mac and linux, windows might be different) Only after it finished reading the complete input file it'll print the statistics.
Yup, thanks!Ctrl+D turns out to be the magic combination.I had tried everything else unsuccessfully.It is weird that the book has no mention of this at all.
Thanks!
Like for Java or Ruby: I write them as Javalang and Rubylang. It's Go.
Containers are a big one. Getting away from 18 different config file methods/formats (yaml, json, something else made up) and unifying on a list of env vars is a nice simplification; knowing that across a fleet of varying services in multiple languages, there's exactly one, simple look to the config. Etc.
18 different config methods were annoying, so we created a config method to unify them all. Now there are 19 different config methods. 
Remember there's two main "products" described on golang.org: * the specification for the language syntax / semantics and standard library API * the gc toolchain implementation of that language When *The official Go Language specification* says "The existing implementations use a traditional compile/link model to generate executable binaries," it must be talking about the gc and gccgo implementations only, and not the independent (and I believe not quite completed) gopherjs implementation. *Go 1 and the Future of Go Programs* says: &gt; Go 1 defines two things: first, the specification of the language; and second, the specification of a set of core APIs, the "standard packages" of the Go library. The Go 1 release includes their implementation in the form of two compiler suites (gc and gccgo), and the core libraries themselves. Although the wording used there doesn't make clear the name distinction between the two "products" on golang.org, I tend to think of **Golang** as being the language and standard library specification, and **Go** as being the gc implementation of that language. 
It's a bikeshed problem. It's so easy to imagine a configuration format that sucks a bit less than whatever you're using today that everyone thinks they can make one. And it's true. They can. It happens to perfectly match whatever they need at that particular moment, but it's not trivially generalisable which just keeps the cycle going. I've done it myself many, many times. 
why test(`"\"`) // [Why not error!] ? It is just a string, should not fail
This is incorrect, it is all Go. Golang is not the name of the language and should only be used if you're having search engine trouble or adding an extra hashtag to a blog post for SEO.
clang as well.
Example includes solutions, mix usage of hyphen and Params. Pass something called indent or spacer through pipeline inc or dec it as you enter or exit new pipelines. Have a helper func to dec() and inc(). There's a hundred ways to do it.
"Don't communicate by sharing memory, share memory by communicating." Channels let you control when two or more pieces of code run in relation to each other. For example in an unbuffered channel the sender is blocked until a receiver picks up the message, and a receiver is blocked until a sender sends a message.
Buffering means that in scenarios where the consumer is sometimes much slower than the producer in the short term, the producer needn't wait for the consumer to accept the value to continue. Instead, it continues queuing the data in the buffer, and the consumer gets to it when whatever condition is slowing it down disappears. You can of course implement this using mutexes and some sort of queue/buffer, but the point is that channels already solve that (very common) problem, and that the solution is less trivial than "syntax sugar"
I generally agree with this (if you go on a wheel reinvention rant, I'm pretty conservative about doing so or making things for the sake of it). A huge reason is still point #1: containers make heavy use of env vars. [edit] Also, we've both missed making the point that env vars are hardly new. In fact, you could consider this one of the oldest methods of applying config.
If you're going to post your resume online and improve the chances of someone searching for Go programmers finds it, you need both. The word "go" is too generic... appears on a ton of resumes for people who don't write Go, and as a 2-letter word won't even be indexed on some systems' search engines. I personally think Go (golang) is a fine way to express the fact that you know what the language is called while also getting the keyword on there. If you've searched for "Go jobs" in your area you've probably already come across this problem in reverse. 
"It depends". Is this HTML, despite what you're showing us? Then really the best thing is just to stop caring. Is it text? Is it _really_ text? If it's some actual format you may be better off writing something that creates an AST for the format (or using one that already exists), and rendering it at the end. What sounds initially like more work very often pays off as less work total in the end. But failing all that, yeah, the indent solution seems pretty good.
This is turning into a sprawling argument that could go forever: I haven't advocated a particular way to use env vars, or what it means, or what the pros/cons are. I could counter everything you've said as well, but it's irrelevant. Facts: - This is literally a simple lib to easily add the option to go flags, facilitating a pre-existing user behavior. - There's an endless debate elsewhere about the merit of flags/config, and I'm not interested in a new one.
I second this. Since resumes are read by machines and not just people, it's important to have keywords that can be read by both. Anyone seeing this who's familiar with Go won't have a problem with the term 'golang' in the resume.
&gt; true is unecessary here, for { } is valid Go
Thanks for the great reply pointing out that limitation! This is what I love about the Go community. I will be sure to update the post noting what you mentioned.
&gt; where the producer can produce without knowing anything about the state of the consumer But it's a full stop-the-world for the producer if the buffer is full, unfortunately there does not exist a flexible buffer for channels.
Text() has the same problems as Format it only outputs stuff that look like this 'e' -d.dddde±dd, decimal exponent, at least two (possibly 0) exponent digits 'E' -d.ddddE±dd, decimal exponent, at least two (possibly 0) exponent digits 'f' -ddddd.dddd, no exponent 'g' like 'e' for large exponents, like 'f' otherwise 'G' like 'E' for large exponents, like 'f' otherwise 'b' -ddddddp±dd, binary exponent 'p' -0x.dddp±dd, binary exponent, hexadecimal mantissa So the inevitable `5e+18` will still be there. Possible solution: It seems that If all my operations are in the `big.Int` realm, when I transform back to `%s` the numbers aren't "truncated"
Oh, you're original post implies you're using big.Int, but that docstring is from _big.Float_. I would assume that a big.Float representation is almost certainly always going to be truncated in some way, since Floats can't be represented precisely (e.g. they often result in infinitely repeating decimals.
There are a few potential improvements. 1. You can use goroutines to calculate fibonacci if you want, but you don't need to send the inputs through channels. 2. You're using extra lines to initialize variables you don't need to-- if you write a number in Go, Go will infer its type based on its context. 3. You're calculating fib(45) and fib(49) twice, when you could just use the same result twice 4. fib(45) is part of the result of fib(49), so by calculating both separately you're using a lot of extra time for duplicate work. 5. As otherwise mentioned, using big ints will be needed at some point. This code incorporates the first three of the mentioned improvements: package main import ( "fmt" ) func fib(a int64) int64 { if a &lt; 2 { return a } return fib(a-1) + fib(a-2) } func main() { s1 := make(chan int64) s3 := make(chan int64) go func() { s1 &lt;- fib(49) }() go func() { s3 &lt;- fib(45) }() fmt.Println("Total fib sum ", 2*(&lt;-s1+&lt;-s3)) } For the fourth improvement, a common strategy is to use memoization when you know you're going to be calculating the same expensive operations many times: var ( fibMemo = map[int64]int64{ 0: 0, 1: 1, } ) func fib(a int64) int64 { if _, ok := fibMemo[a]; !ok { fibMemo[a] = fib(a-1) + fib(a-2) } return fibMemo[a] } ... but you'll want to use a sync.Map or a slice with defined bounds and null values if you are going to be doing this concurrently, not that that matters anymore, as once you've calculated fib(49) you'll know fib(45). If we [benchmark](https://play.golang.org/p/1AhInet-B9) these two approaches, memoization turns the problem from completely impractical to very quick: BenchmarkFib1-8 1 53478058800 ns/op BenchmarkFib2-8 50000 27901 ns/op
You may be better off then post-processing with an xml prettifier, then. Be as gross as you want during output and let the prettifier fix it all in one shot. Depending on how many templates you have this may be both easier and ultimately more effective. Prettifiers often also come with tunable parameters, which are much easier to tune at that level than to modify every template. I also suggest looking at encoding/xml. I absolutely, positively do NOT guarantee it will meet your use cases, because it is a library that chooses some ease-of-use over total flexibility. But if it so happens it can meet your needs, it may be able to completely eliminate manipulating XML templates _at all_, in favor of using [MarshalIndent](http://127.0.0.1:9000/pkg/encoding/xml/#MarshalIndent). Basically, in the case of XML, not only does the AST exist but there's a translation layer between Go structs and that AST in the standard library. I offer these in the spirit of giving helpful suggestions to think about in the hopes that one of them may help, rather than "encouraging" you to choose any of them.
 func fanIn(inputs ...&lt;-chan string) &lt;-chan string { c := make(chan string) for _, in := range inputs { // this line gives me error go func(ch &lt;-chan string) { for { c &lt;-ch } }(in) } } You were missing the range keyword :). I'd also like to point out that you don't have any way of signaling when a channel is done sending.
Inputs is a slice, so cinput ends up being the index in the slice, and not the channel. You are also missing the range keyword and a return value. So for _, cinput := range inputs
Yeah, haha - I was in the middle of editing it and lost internet connection. Thanks for paying attention though!
I was goofing around with this some more and ended up with a slightly different API so I [put it up on bitbucket](https://bitbucket.org/dchapes/envflag). Feel free to borrow any bits from that you find useful.
Just a heads up that channels in an API appear very infrequently in the Stdlib.
It seems like you are mistaking interfaces for pointers. Pointers are like C pointers where you get one by using &amp; and dereference using *. You get interfaces by declaring an interface type and you get type information by assigning a type to it and using type assertions or runtime package. I cant believe I had to explain this far. If you still believe go pointers are like java references, then I am sorry. 
Take a look at the output here -- is this more what you are looking for? https://pastebin.com/Ti8fj7uY
I'm aware what an interface is. But thanks for your explanation. I haven't once mentioned java. Go pointers are very different from C pointers. If you still believe go pointers are equivalent to C pointers, then I am sorry
Your thought is fundamentally flawed. Go is not python. Pointer types are known at compile time. There is 0 need to store type in memory. The links you posted are about interfaces. I'm having a hard time understanding if ur trolling or not. 
:thumbsup: 
Go is also not Haskell. The links I posted are about the go runtime. as jerf mentioned, it sounds like you're talking about some potential compiler optimizations which are irrelevant to go as a language
did you just try to link your local copy of the documentation
I put one "Golang" in as a bait for resume keyword scanner. And the rest is just Go.
It's just easier to verbalize in my head the two products on golang.org as "golang" and "go", rather than "the Go spec" and "G-C". *added:* I type "go" to run the gc implementation, and my brain wants to refer to the spec as something different. People who came to the Go language for the gc implementation rather than the features of the specified language might not think of them as different. 
Haha, maybe one day!
Good write up! I also found blog.golang.org/slices to be a a thorough read, if anyone else has the same issue visualizing what's happening.
I have added a check for runtime errors. See how http.Unmarshal does it in the standard library.
I use code generation for this. I wrote a simple tool that generates unmarshalling code from a SQL query. My generate lines end up looking like: //go:generate sql-gen -pkg sql -func SelectFoos -struct FooRow -sql select_foos.sql -file select_foos.go which generates a function **SelectFoos** in the package **sql** that returns an array of **FooRow** structs (array will be empty if there are no rows) and an error value. Now accessing the database looks like: foos, err := db.SelectFoos(sql.Named("ID", id)) if err != nil { // handle error } 
Very neat! I hadn't heard of the package. Handy for statistics/dashboard nerds.
I don't feel like you demonstrated much, other than being more comfortable in C++, which is fine. As a controversial idea, it's worth considering if this experience says less about the languages, and more about how you write code?
Is func calculateUptime() int64 { return time.Since(start) * time.Second } valid go? I get an error that it can't be use as int64.
You make an inflammatory blog post about how you dislike go enough to rewrite 7k LoC in C++ and then you post it in the go subreddit? You must really love downvotes. 
For something that revolves entirely around security, I'm having trouble computing where your win is here. You traded memory safety with near zero chances of the most damaging (and common) types of attack vectors .. because of subjective things like "in your face" error handling and generics? You really think a **if err := ..** block is less readable [than this](https://github.com/andreas-gone-wild/snackis/blob/master/src/snackis/db/basic_table.cpp#L11).. which hope table name can never be suggested remotely. Since your [filesystem operations](https://github.com/andreas-gone-wild/snackis/blob/master/src/snackis/db/ctx.cpp#L14) are nothing more than filesystem::path concatinations (rather than a properly jailed abstraction) you are susceptible to directory traversals. So for all I the boiler plate cpp like a [naive fmt](https://github.com/andreas-gone-wild/snackis/blob/master/src/snackis/core/fmt.hpp#L39) and [trim](https://github.com/andreas-gone-wild/snackis/blob/master/src/snackis/core/str.cpp#L9) .. and on and on where you increase your chances of a ob1 or some other mistake having devastating consequences.. you gained genetics? Since you implemented [defer](https://github.com/andreas-gone-wild/snackis/blob/master/src/snackis/core/defer.cpp#L4) you technically are at a 1 for 1 language feature wise. So how worth generics was it for tons of additional surface area, implementing basic string operations everywhere that are part of the std lib? Apparently the only real usage I saw was for your own custom [type system](https://github.com/andreas-gone-wild/snackis/blob/master/src/snackis/core/int64_type.cpp#L6) for writing to your own hand rolled [database](https://github.com/andreas-gone-wild/snackis/blob/master/src/snackis/db/table.hpp#L190), which mixes your schema and type system marshaling inline with [crypto operations](https://github.com/andreas-gone-wild/snackis/blob/master/src/snackis/db/table.hpp#L201). I'm sorry but I don't see any benefits here at all. 
If that's what you see, you're not looking for answers. I apologize for the stepped on toes and wish you a pleasant day.
After a quick skim, I would say that there are lots of places to improve the Go code. It seems that you haven't bothered to learn the language, ecosystem and idioms properly. For example, these things feel very wrong: * https://github.com/andreas-gone-wild/snackis-golang/blob/master/core/bset.go#L21 * https://github.com/andreas-gone-wild/snackis-golang/blob/master/core/types/int32.go#L22 * https://github.com/andreas-gone-wild/snackis-golang/blob/master/smtp/goproc.go#L60 * https://github.com/andreas-gone-wild/snackis-golang/tree/master/tests * self everywhere * In many places you seem to be trying to emulate inheritance. I was unable to find the corresponding code for https://github.com/andreas-gone-wild/snackis-golang/blob/master/smtp/pyproc.go#L13... so, I'm not really suprised to see LOC go down, if you remove features.
Do you know something with an AST so it could parse the structs from existing go code?
Why do you call Go "Golang"?
Unfortunately no. I only deploy on Linux platforms and I use`/proc/&lt;pid&gt;/fd` to get amount of open file descriptors.
&gt; The best explanation I can come up with is that most Golang-software doesn't use C-extensions. AFAIK all of Google's internal production go software uses cgo. I don't know if that already qualifies as "a majority of go software", but it certainly means that a *huge* chunk of non-trivial go software uses cgo. Maybe the best explanation is, that you where holding it wrong? Or that the specific C libraries that you where using where very picky about what kind of software they can be used with (by using thread-local storage or singletons or other kinds of bad practices from the 90s).
Copying from an example I did for a quickstart session: func copyData(in, out chan string) { for { // infinite loop out &lt;- &lt;-in // read from in, write to out } } func fanIn(channels ...chan string) chan string { out := make(chan string) for _, ch := range channels { // iterate all params go copyData(ch, out) } return out }
No I didn't try the Prometheus client, but I'll try it some times if I'm in the need for more complex metrics, like histograms. 
Thanks for mentioning netstat! I didn't knew the project, but it seems very promising.
Surely this will memory leak, as the go routine inside... for _, in := range inputs { // this line gives me error go func(ch &lt;-chan string) { for { c &lt;-ch } }(in) } will never stop? There's a really good example of fan-in here. https://blog.golang.org/pipelines
Thank you.
Note to self: always test code samples. Even those with only 3 lines. 
Am I a bad person for looking down on people who call themselves professional programmers but don't even know how to use pointers?
Thank you for all the great insights. I should maybe mention that I'm not the author of the blog post. Just wanted to hear your opinions about the approach described.
This is quite interesting. I think I need to look more into code generation in go. So far I've only used it for generating Stringers. Are you using https://github.com/drone/sqlgen ? Cause your generate line looks very similar to the examples. 
I'd expect a professional to have fairly wide-ranging knowledge of their field; pointers and indirection are central concepts in computing. If all someone has ever done is bang together Python scripts, I'm not sure they're a *professional*. A programmer, sure, but definitely just starting out. Not that that's a bad thing: everybody was a beginner at some point
You can spend a whole career without ever touching C/C++ or any other language that has pointers – a fullstack dev with 10 years experience in Java, Ruby on Rails, Javascript, PHP and Python can easily be an expert in their fields while never having done anything involving pointers. 
Awesome. Thanks for the explanation.
"Build multiplatform apps! (Apple only)" ¯\\\_(ツ)\_/¯
I never used [Chi](https://github.com/pressly/chi) but from what I actually see: * [gowww/router](https://github.com/gowww/router) has about the same performance as [julienschmidt/httprouter](https://github.com/julienschmidt/httprouter) which, according to their own bench, is faster. But I will push comparing benchs some day. * 92.6% ([Chi](https://github.com/pressly/chi)) vs. 100% ([gowww/router](https://github.com/gowww/router)) test coverage. * [gowww/router](https://github.com/gowww/router) is more pure and generic: no middlewares chaining, much less exported methods, no sub-packages full of middlewares. [Chi](https://github.com/pressly/chi) could almost be a micro-framework. * [Chi](https://github.com/pressly/chi) is more error-prone: make 2 routes with the same path, the first is silently overwritten. * [Chi](https://github.com/pressly/chi) is older (born in Oct 15, 2015) so it had time to be used by big names (CloudFlare, Heroku…), and is maybe more "proven".
Where can we see the performance numbers ? Have you compared with [fastroute](https://github.com/DATA-DOG/fastroute) ?
The place I work does a lot of microservices with rabbitmq and we developed a library to let us bootstrap pub/sub really quickly. It works out well for us but obviously YMMV https://godoc.org/github.com/mergermarket/run-amqp See an example use here: https://godoc.org/github.com/mergermarket/run-amqp#example-Consumer We made a big emphasis on making it easy to test consumers https://godoc.org/github.com/mergermarket/run-amqp#example-StubMessage 
Optimizing single functions can be critical, or not important at all. If a function that is called once per several minutes is allocation heavy it doesn't much matter. But a function in a critical region of code that exists on every call path CAN become a problem. Here is a [real world](https://github.com/osrg/gobgp/pull/1334) example where I reduced allocations from 220,000 per 4K records to 8,000. For the most part I just benchmark, look at the profiles and see where the big gains are. Sometimes in a really tight loop [a bit of ugly](https://gist.github.com/cstockton/78a1371c1c388dfb88c35d1bea8fc211) may be worth, going to those measures in every function would quickly turn your app into a nightmare. Point is staying cognizant of where you are in your application is probably more than enough most the time. If your in a few levels of nested loops take some extra care otherwise probably not a big deal. 
I guess that's shame on me for not having a local doc server up constantly.
Thanks, I really appreciate the feedback. I'm planning on spending some time on this project over the next few days so I'll incorporate your suggestions.
If I'm not mistaken you're not using an array as far as I can tell, because you didn't specify the array length. So that is actually a slice.
Too many people are claiming to be engineers when they are actually technicians. There's nothing wrong with being a technician.
I don't have any specific experience with the frameworks you're using - but I do know that the 4000 character limit is enforced by the Slack API (ie. You can't get around it by simply changing libraries). So, I'm curious how your client gets around this.
Return the error, not a nil pointer. Idiomatic go code returns an error as the last return value from all functions that can fail. It makes it obvious that the function can fail and easy to see when it does. Never return nil pointers from functions, unless they are accompanied by an error value. It's confusing, and it forces users of your code to check all pointers returned by functions, not just the errors.
Education and experience. As for technician vs engineer: "Off the cuff" thought on the subject being that an engineer does the top level design, requirements, planning and project management. The technician builds from that design.
too many people proud themselves with titles instead of accomplishments and real contribution to the world.
My apologies for the confusion. You are right, it is enforced by the Slack API, which is why we wanted to upload the results as a file/snippet instead. Because the upload file feature was not available as part of Micro's Slack Integration, we had to truncate. https://github.com/nlopes/slack supports all (as far as I know) of Slack's features (including uploading files). The framework I put together is built on top of its Real Time Messaging features but it also gives you full access to the API should you choose to want to upload a file for example.
I once spent an hour on == with Java
I don't think there are too many people who don't know how to *use* generics.
Common misconception is that there are no pointers in Java. In fact, whenever you use `new`, you're using pointers. The difference between Java and C/C++ is that: 1. Java actually *forces* you to use pointers . You can't declare objects (except int, double, float, etc.) on the stack, so the syntax was simplified and the * operator was removed. 2. Memory management is automatic. 3. No pointer arithmetic. But they're there and you have to take them into account: http://ideone.com/wzJ4uJ
But there are some people who don't *implement* generics because they're afraid of complexity in the typing system
go newbie here as well. this post is cause for a question of my own. since he didn't explicitly declare an array or if you don't, would the underlying array elements that he describes as trimming be GC'd sooner - in other words is it advantageous to not declare the array. 
So, do you know about pointers?
https://beepboophq.com provides a go option, the service is free to try for 7 days and relatively inexpensive with the paid option. Follow the steps and it will create a repo for you with a go starter project.
That's what the blog is about, my experience of learning more about pointers and more specifically pointers in Go.
"The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming." - Donald Knuth Benchmark, load test, analyze, but *wait to optimize until there's indication that it will offer a meaningful benefit*.
It finally clicked when I realized that I can mentally stick a `*` after MyObject and it will work like in C (minus the arithmetic). Everything was absolutely clear after that.
Any plans for sub-routers like [this](https://godoc.org/goji.io#SubMux)?
Step 3.3 in the go tutorial: "Run your Node.js app from the terminal." Oops - QA fail!
with streaming video of TDD practice in Golang
No, the tool I'm using I developed myself. It looks like https://github.com/drone/sqlgen uses structs in your golang code to generate the SQL and (un)marshalling code, where mine takes the SQL queries and generates structs and unmarshalling code.
. imports are an anti-pattern.
really? What's the good practice, would love to know.
This is documented in effective go: https://golang.org/doc/effective_go.html#channels
I can only see that as an "ok" pattern when you want many different types of worker queues all to share some central semaphore. But a better pattern for that like here would be to create a set of N workers up front as well and share a common task interface to execute or simply give them all their own reasonable capacity (best option). The one you implemented here actually has the opposite affect of the patterns intent. Since each new item you receive in your worker loop spawns a goroutine without first acquiring a sema. You now have an unbound number of goroutines all using resources while waiting. Edit: I just realized you actually want to do this purposely to avoid back pressure, so my mistake for pointing it out. Though I think you need eventual back pressure to protect against bugs or adversaries.
There is no difference between x := make([]int, 10) and var y [10]int x := y[0:10] Except that in the latter case the array has a name (y). GC of the array happens when there are no more references to it. Those references can be slices which slice the array, or pointers to the array, or pointers to elements of the array.
A agree. For quick &amp; dirty ring buffers slicing off the head and append()ing the tail is easy to read and is reasonably efficient [1]. Do remember when slicing off the head to zero the head value if it contains references, so the referenced values can be gc'ed. Otherwise they can't be gc'ed until append() reached the slice's capacity and reallocates a new array. [1] every N = `capacity of slice` items you allocate a new array, copy the live items, and throw the old array away to the gc'ed. If it isn't a tight loop and the number of live items (len(slice)) isn't large, the overhead is noise.
To be fair, it is a work in progress.
While I see what you mean, isn't it fine to have lots of goroutines not doing anything since they're so light? Would [this](https://pastebin.com/BjqEiZrG) be better? It should wait to dispatch the actual goroutines instead of having them all dispatched and waiting.
Yes absolutely it's fine to have lots, the problem lies in not defining lots. Lots to you today may be a thousand, lots to the jerk who finds out he starts one of these if he stops a http request after failing a login may be millions! So your adjustment shifts it to simply being the same as if there was a limit on your "in" chan. So your pattern could be adjusted to fall perfectly within my counter argument many ways, but the simplest would be to give your idea of "large" as the queue size to "in". This swaps the roles of your semaphore to act more like a queue to limit your concurrenct jobs running at once, and your in chan acts as a high upper boundary to limit back pressure during "bursts" of work. The caveat to the simple route being your large size on a typed chan instead of an empty struct. There are a lot of ways to do it, but one better route would be to acquire the semaphore at your send to "in". Then you can start a fixed number of workers to pull from it. (In general for preventing back pressure during bursts it's easier to reason with rate limiting at the send than the receive.)
I see, that makes sense, I'm used to using this pattern for smaller things but you're right, my definition of "small" is very different than another persons. Thanks for the insightful feedback as always! Dealing with back pressure and rate limiting in Go with channels is a very cool topic.
Ahh, that's a helpful snippet. Don't only limit the amount of work that can be done at once, limit how much work can be sent at a time. Happy coding to you as well 😄
&gt; In the real world the trimming will happen concurrently with the appending. No. Use locking. You can't modify a slice concurrently.
For the sake of being pedantic, they're refrences, not pointers.
Yes, and the GP clearly outlines the difference between the two. Aside from these differences, they're the same thing -- indirection by dealing with addresses as values. It's a very fundamental concept, although I don't necessarily agree with the top level post.
From my perspective I traded a buggy, naive language for a mature pragmatic one; which seemed like the right thing to do in this situation. There doesn't have to be any memory errors in C++ user-code these days. Generics rock, their implementation in C++ even more so. You either have no experience or you're living in denial. I would prefer to not write a database; I would prefer to not write a lot of things, but no one is solving my problems.
If you'd literally have to spend a month optimizing code, you might be better off buying/rent an additional server. You really have to work at a huge scale, where investing time would pay off more than allocating some resources for hardware. Let's say, if you're working with a $5K/month+ hosting bill, then dropping a month into optimization at that point will most likely give you a net benefit over the yearly scope. If you're doing much more than that, [it can pay off big time](https://segment.com/blog/the-million-dollar-eng-problem/). Less than that, you're not going even to cover the cost of better hardware at that point, so don't waste developer cycles (unless you consider it an investment, which sure, by all means - investment/education is important!)
&gt; Jekyll to generate the whole site? Where did you see that? I probably missed it.
Go is about types. What I would do: type ConcurrentList struct { m *sync.Mutex Data int[] } func (l ConcurrentList) Trim(len int) { l.m.Lock() defer l.m.Unlock() // do some trimming } func (l ConcurrentList) Append(el int) { l.m.Lock() defer l.m.Unlock() // do some appending } Your implementations could be what you have in the playground, it's up to you. While it doesn't directly answer your question I hope it helps.
There are exceptions to everything, though.
There are no EXPLICIT pointers and it's not a misconception. You can't get value of a reference in Java, just as you can't do anything with this value. Saying there are pointers in Java is like saying there are trees in javascript. Yes, v8 does use trees, but so what?
The desire to reduce nesting isn't specific to Go, though: https://en.wikibooks.org/wiki/Computer_Programming/Coding_Style/Minimize_nesting
Sure. I still think Go's school of programming has influenced how they program at Google though and maybe outside as well.
No, I want to keep it simple. And this solution (with 2 methods: NewMux and SubMux) seems overcomplicated when you can simply put an http.Handler into another. It's like Lego. **Solution #1 — http.StripPrefix** rt := router.New() rtUsers := router.New() rt.Get("/users/", http.StripPrefix("/users", rtUsers)) rtUsers.Get("/:id", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { id := router.Parameter(r, "id") fmt.Fprintf(w, "User #%s", id) })) http.ListenAndServe(":8080", rt) Like that, you loose the prefix in r.URL.Path but you can retrieve the full path inside r.RequestURI. **Solution #2 — Group struct** You make a group structure that keeps the router and the path prefix. You pass the prefix+subpath to the router each time you call "handle": type routerGroup struct { router *router.Router prefix string } func group(rt *router.Router, prefix string) *routerGroup { return &amp;routerGroup{rt, prefix} } func (rg *routerGroup) handle(method, subpath string, handler http.Handler) { if subpath == "/" { subpath = "" } rg.router.Handle(method, rg.prefix+ subpath, handler) } Use it like: rt := router.New() rtUsers := group(rt, "/users") { rtUsers.handle("GET", "/:id", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { id := router.Parameter(r, "id") fmt.Fprintf(w, "User #%s", id) })) } http.ListenAndServe(":8080", rt) That's what I've done in [gowww/app/group.go](https://github.com/gowww/app/blob/master/group.go) (this project is at an early stage though).
&gt; I propose the following guidelines: &gt; &gt; - No package level variables &gt; &gt; - No func init &gt; &gt; **There are exceptions, of course.**
I like the article (and TBH, find the proposed advice as obviously a good idea), but there's one thing that bugs me, I'll comment on it here. The article suggests a hypothetical function: func NewObject(n int) (*Object, error) And proceeds to try to guess what it does based on the signature. I think that's a really bad idea, one that hopefully never happens in practice. Instead, what should happen is that NewObject is an exported symbol and should be documented (or made unexported, as golint would tell you). (I personally would almost never use a package that doesn't document its exported symbols.) Perhaps it would say this: // NewObject invokes a package global database/sql.Conn, to // make a query against &lt;some specified&gt; database; using the // standard log package logger; and a package global pool set by // previous call to SetPool, to request an Object number n. func NewObject(n int) (*Object, error) Of course, a function that does all that shouldn't be called NewXxx, and shouldn't have a signature that takes so few arguments if breaking API changes are possible. Let me be clear, it's my belief that all exported symbols should be documented to say exactly what they do. If they do anything other than what's documented, it's a bug in the implementation. When you're forced to document all behavior explicitly like that, these problems surface, and the advice given by the article becomes a natural outcome.
So you found a bug in a reasonably complex 7-kloc code-base that was written by one man in three months, and that's your proof that none of my conclusions are correct. What do you want me to say here? You don't look very smart from the outside right now. It should return an informative error. In a way, you're serving my argument; since the most probable reason for forgetting was having to write all that stupid error-forwarding code in the first place. I posted here because I thought someone might be interested in learning from whatever mistakes I did, including choosing Go from the start. But instead of discussion and countering of actual arguments, all I get is crap like this. Forced, opaque N*M-threading will always be a bad idea; and it has always been a bad idea, as many have discovered along the way. It's especially bad for a language that wants to be pragmatic enough for system programming; you know, writing actual code that does anything beyond shuffling data in the clouds. This was my way of discovering the same old truth, I have no idea what it will take for Rob &amp; co. Or the two-minutes-of-hate crowd that gathered for this feast. This information was shared openly as a way for others to learn. It represents my authentic experience and the conclusions I came to, and has a right to exist just like all other information. Disagreeing is one thing, shooting messengers and participating in hate-mobs another.
And that somehow invalidates my conclusions? I have spent plenty of time in Go over the last three years, but this was my first project to get this complex. Nothing suggested here would have solved my main problem; which depends on fundamental choices made by Go's designers, and will be a problem for anyone attempting to write similar software in the language. Calling into C from different threads behind the users back is never going to be a good idea, period. 
database/sql is the cause of more use of this sort of stuff any thing else I've seen, sadly. It was a poor design choice, it seems to have infected basically all database implementations. 
Note that it may be faster to copy the data to the front of the buffer even-though it is counter intuitive that it's faster. arr = arr[:copy(arr, arr[2:])] This is simpler and allows to resort the data after new data appending. Sorting data in a circular buffer requires special care. Explanation of the above code. arr[2:] drops the first two elements of the array. copy() copies the elements from the subslice arr[2:] to the array arr and returns the number of elements copied. It is len(arr) - 2. We then set arr to be arr[:len(arr)-2] witch is the subslice with the last two elements dropped. This copy the len(arr)-2 elements at the end of arr to the front of the array arr and drops the last two elements. 
meh, this is just a caveman version of FP...with all of the downsides, namely functions that end up riddled with dummy placeholder values FP actually routed around most of this with point-free style and functional composition. This is possible here if you take the parameter lists themselves and turn those into structs or interfaces...i.e. instead of `func Foo(a int, b int, c int)` you replace that with `func Foo(i *OurReusedParamSet)` which lets you just check the nullness of the param set you are reusing....which is still a caveman approach but it at least makes you think about the signatures you are about to impose on the world, and the potential need to move these reused patterns into the type system and possibly exposed as functions themselves (still no point-free style though) Go does not have good abstractions and these "pattern" type posts just lead you down a "Javascript: The Good Parts" rabbit hole where everyone pitches a fit in code reviews because you aren't adopting Their Particular Good Parts
It has little to do with FP, it's just dependency injection
Global variables are the mechanism 95% of Go libs use to expose their error classes for easy pattern matching...these could easily be replaced with only-once-initialized `let` style vars as in other modern languages, but the Go core team has repeatedly rejected this simple change if you say "no globals", then we are back to reading `.Error()` strings to match errors
yea - I was keeping it simple in the playground 
var ErrNotFound = errors.New(...) is probably the primary acceptable exception to the "no globals" rule. I think it generalizes to "globals that are treated as const declarations are OK".
True that. Edited. It looked fine on my phone! Thanks :)
"There are exceptions, of course. But from these rules, the other practices follow naturally." This saved the article for me. Opportunistically using "pure functions" is a known-good in some circles. http://www.gamasutra.com/view/news/169296/Indepth_Functional_programming_in_C.php Good article by John Carmack (who seems to know how to program pretty well ;). He has a good rule of thumb, "No matter what language you work in, programming in a functional style provides benefits. You should do it whenever it is convenient, and you should think hard about the decision when it isn't convenient."
To me it looks like it was designed to resemble JDBC, because that's what people are used to.
There doesn't have to be any memory errors, although a compelling argument (not really) .. is difficult to measure. Everything you said after that was just an emotional response. You call Go buggy (no concrete reasons why) and naive (subjective). You say generics rock (I never said they weren't useful) then attack my experience or assume mental deficiency. Finally my entire point isn't giving up Go you were then forced to solve .. solved problems in Go, I linked concrete examples of this. I linked technical reasoning to my opinion to give you the opportunity to provide counter arguments which if I found them valid could lead to conceding. Instead you ignored them all and made (another) personal rant. That said, I don't get engineers attacking personal experience when they are met with an opposing technical position, rather than attacking the position. But if you think providing something to measure our experience here strengthens your arguments then I'll oblige. Post your resume github (your main github, since the one you linked has only two repos) old mailing list threads of having meaning technical discussions, open source contributions and anything else to show your experience is superior to mine feel free. I'm rather comfortable with others being more experienced while being understanding of those who are not. Happy coding.
I don't know what that means. "Keeping it simple" in the playground is one thing, but you also said, that you intend to do the modification concurrently "in the real world". That is not possible (I mean, it's possible, it just will lead likely to crashes and unsafe behavior). Do not modify slices concurrently. Use locking. If you *do* use locking, any mention of concurrency is a red herring (as it's equivalent to just doing the modifications sequentially).
I'm a beginner in terms of "Go" and have watched a couple of Peter's go-kit talks, which I liked. What he said about global variables is a good practice and I have not seen too many global variables even in some legacy C++ code that I've worked with. So, that practice is probably not too prevalent anyway. But what he said about the signature - probably I am not following, what he means to say. To me, an API provides functionality which as a client I don't want to know about. As a client, I only want the result - and let the API do its magic (using whatever magic sauce). For instance, consider this: func Enhance(ioImg *XImage) (*XImage, error) { // 1. find a matching image in a image repository/database // 2. get suitable enhancement settings from some other table // 3. apply settings to ioImg // 4. apply some other algorithm return ioImg, nil } Why should I have to pass the database connection or resources that are specific to func Enhance? That's adding a dependency for the client for no reason.
Generics are a mediocre way to expand a type system. A better thing would be to add algebraic types.
Presumably, you had to configure the database connection anyhow. Rather than creating it, sticking it in a global, and throwing it away, create it and pass it to an ImageManipulator class instead. It only costs you a little extra bit of code, but in return, you or your consumers can easily swap in a different database connection for testing. Better yet, take an interface `RetrieveImage` that has a method to retrieve the image, and for which you provide an implementation that uses the database, but makes it even _easier_ for someone to swap in a different implementation. If you're still having trouble with the ideas here, it's probably because you are mentally hard-coding yourself to be both the producer and the consumer of the functionality in question. You probably aren't, because even if you are, you can easily end up separated from your own self by _time_ and forget all the global state you have set up, where it is, what it does, how it affects everything, and it gets harder as the program scales up, too. I've come back to Go code I wrote even just a month ago and only been saved from that sort of issue precisely because I write my code this way. Also, as you get better at doing this, it turns out Go makes it easy. Particularly have a look at how [object composition can make it so you're not passing around anywhere near as much as you think you are](http://www.jerf.org/iri/post/2929). I don't deny that just slapping something in a global variable is easier. However, you may find that once you are fluent in Go it is not anywhere near as _much_ easier as you think, and costs a lot more than you think.
There's a package for that. github.com/pkg/errors Best of both worlds -- you can have your sentinel errors and you can add context to them too. The downside is that you now have to use the library in all of your error handling logic. 
&gt; I never said there wasn't. My problem wasn't code quality at this point, it was platform stability. It's hard to comment on the stability issues, because there are no details. There might have been a race condition somewhere. Or you were accessing goncurses from different threads (not sure whether ncurses supports it). Or that there was a bug in goncurses. Sure there might have been a bug in Go as well. &gt; I'm not emulating inheritance, I'm using the most effective means possible to safely reuse the functionality I need. That's what I always do, regardless of language. Show me a better way and I will be the first to jump on that train. At this point in the project, unfortunately, proposing alternatives would require significant effort and discussion to analyse and understand the architecture and structures. _Sure there are easy cases of renaming self and using `smtp.SendMail` with custom auth._ But starting thoughts: 1. make db based on []byte. This would get rid of lots of interface code in there. Adding type-layer on top of that could remove the "types" package completely. You could see it as a minimal versions of github.com/boltdb/bolt and github.com/asdine/storm -- obviously adjusted to your specific needs. The types could be generated if necessary. 2. adding a concept of record to form (instead of "augmenting" form... see https://github.com/egonelbre/exp/blob/master/dos/main.go#L18 for similar idea) But, my best guess, why these problems exist, are because db/form packages were (probably) designed before having the main logic written. Or alternatively were based on some other design from another project. I.e. the libraries/dependencies forced the structure of domain logic instead of the other way around. So going the other way -- writing the domain logic and making sure it's as clear as possible, would probably lead to a completely different structures. &gt; I get a feeling that you're mostly trying to find things to pick on to divert attention from information that threaten to rock your boat, which is not very constructive from my experience. Not really. I'm pretty familiar with Go and it's shortcomings. It's not the most concise language. Lisps/C++/D etc. are much better in that regard. _I would have commented on C++ code as well, but it's not one of my strengths. Although, the previous suggestions might make code nicer to work with there as well._ My point was that Go code quality could be improved, which might be the reason you were having a bad experience with it.
It only needs to be said over and over because it isn't particularly true.
Fixed it. One of the driver committers recommended using Named values, and I used it in all other functions except for this one. 
You can also submit code fixes if you'd like! *it's all about dat open source*
Just to clarify... I'm not saying that C++ isn't more stable, powerful and performant etc... or whether C++ makes a better language to write this project in. _I've suggested using C instead of Go multiple times on forums and chats._ The point was, when you have "non-idiomatic" (whatever that exactly means) Go code you will have bad experience with Go.
The fixes should reflect on the website in a matter of minutes (if not seconds)
Yeah, these are occasionally useful.
Very nice product indeed! And I'm ready to pay for a good golang IDE. Just make it fast and stable. Currently it's too slow.
I like that. It's the same # of items copied as letting append() do the copy, but doesn't create any garbage. I guess the only downside is you have to keep track of the original slice, so you can pass it into copy(). With the append()-and-let-it-realloc technique you only need the slice of live items.
Better: ``` s, something, somethingLonger := a(), a(), a() ```
Ah, interesting way of doing it indeed.
&gt; So you found a bug in a reasonably complex 7-kloc code-base that was written by one man in three months, and that's your proof that none of my conclusions are correct. I'm pointing out that if you don't take care handling errors it's pretty inevitable that you'll end up with mysterious failures. This is true in any language. &gt; It should return an informative error. In a way, you're serving my argument; since the most probable reason for forgetting was having to write all that stupid error-forwarding code in the first place. Just the return would have accomplished the correct purpose, as well as being what you would have done in C. &gt; Forced, opaque N*M-threading will always be a bad idea; and it has always been a bad idea, as many have discovered along the way. You haven't demonstrated that this is relevant in any way to your project or its failures. Seems like buzzword bingo to me. &gt; you know, writing actual code that does anything beyond shuffling data in the clouds. I work on a 400kloc codebase that's deployed to multiple million end-users. I think I have a fairly good grasp on Go's strengths and limitations in the doing actual stuff department.
I'm contracting as a Go developer. I found it on some shit website.
Or exposing "IsXError" functions
Relevant xkcd: https://xkcd.com/541/
Use a var block. 
Favorite one so far! Have always wanted to learn how to use cgo but never had the need (so far) or the motivation. Thank you! Really like the style of the videos.
Why do people still used contrived examples? No one has a data structure representing animals.
Same here. It's too slow ... depending on how many projects you have in your GOPATH ...
Then replaced animals with uber drivers. 
Why do people feel the need to nitpick pet peeves and ignore the central issue being discussed? It distracts from the issue at hand. When I use "foo" and "bar" in my examples, I get the same complaint. When I use something real in my examples, people nitpick about whether I've really described a real world problem.
[Example](https://play.golang.org/p/Y6NDFpGmHY)
The upcoming cost will be around £7 / month and it's going to be included in the Toolbox subscription if you have it already (at least based on the information here https://www.jetbrains.com/help/go/faq.html#d3e11). Given that you are going to use this tool in order to work for profit then I don't see why it should be a problem. Also keep in mind JetBrains offers free licenses for their other IDEs for students or open-source projects. Even if you are not going to pay JetBrains for the IDE, please consider donating to your editor / go plugin of choice because there's a lot of work going on in making it as useful as it is and the authors totally deserve your support to enable them to move forward.
Speed is a significant argument of your package. I suggest you do a merge regest for your package in l3pp4rd/go-http-routing-benchmark on github. You will then be able to add benchmark results to your Readme. The most beautiful part is the API. Your package deserve more visibility. 
I have about 20GB of files and projects in GOPATH. The only problem I have is currently with the Unused exported function inspection, otherwise the IDE is blazing fast if I disable it. As I've mentioned previously, please report any performance issues you have as otherwise it's impossible to fix them. Thank you. 
Either delve or the application you are trying to debug segfaulted (aka had a panic). Do you have more in the logs? What happens if you execute the same steps as your editor to debug the application? Can you reproduce the problem like that? 
&gt; Given that you are going to use this tool in order either to work for profit then I don't see why it should be a problem. Don't forget that there always going to be startups where minimizing the costs especially at the start is very important.
Ok, my bad. There will always be an exception or set of exceptions for every case / situation. But just saying: I'm going to use this other thing because it's free... Well that's not so nice for the person that has to put hours and hours of their life into that "free" product, is it? And what if those hours are outside or their regular work hours because their job is not to contribute to the OSS community for that project but who knows what else?
Well, your make needs to be `make(chan bool)` I believe, for one. Here's how I'd do it, though, unless I specifically needed the non-blocking behaviour: // tries to send v on ch. Returns whether the send succeeded. func trySendSelectable(ch chan&lt;- T, v T) (ok bool) { ok = true defer func() { if recover() != nil { ok = false } }() ch &lt;- v return } I believe the `ok = true` could be placed anywhere in the top level function, but that looks like the cleanest and most explicit way.
I couldn't get into Gogland, gave it a try... it just had a lot of the stuff missing from VSCode Go that I love and rely on. Also.. it feels a bit sluggish and the UI is a bit convoluted and unintuitive at times. Definitely has some nice features unique to it on its own, and is a bit nice to not have to manage keeping the tools up-to-date behind making VSCode Go's features work (the various linters and so forth). As well, the symbol rename actually works well in Gogland, where I've yet to once have it work properly in VSCode Go. Though I'd say my choice is definitely going to be to stick with VSCode Go for the foreseeable future.
That is actually way less than I thought I saw, and I definitely get how its worth it for tooling that helps you do your job. I should probably have mentioned open source as an additional factor however, I use entirely open source tooling and open source is my day job. I also adore vim, so I enjoye both pieces of software. Gogland made me start looking at my vim workflow to see if I can replicate what Gogland did out of the box for me. I ended up falling back in love with vim and discovering a whole lot I didn't know. However Gogland with vim mode was a close contender and something I'm still using on occasion. Not sure I'll ever purchase but it's possible. 
Could you please describe what features you've missed or what parts of the UI could be improved? Thank you.
Yeah I mention this in my other reply to you, but open source has been a huge part of my life. It helped me become a much better engineer, I now write it professionally, and continue to contribute personally, and use it whenever possible. I don't take any issue with development or use of proprietary software, I just prefer open whenever possible. It was a mistake on my part to mention it as purely a cost issue in original comment, it's more so the open source aspect.
I really should have said closed source rather than criticizing the cost. In any case for me vim-go vs gogland was a really close call, I love em both. In that situation when one is free and open source, and the other is closed source and costs, it's an easy call.
Exactly. I'm not sure gogland is out for me even, particularly on the rare occasions when I need I depth debugging. But for normal work it helped me refine and rediscover vim. Are you in some way involved with gogland?
&gt; Are you in some way involved with gogland? It's... complicated. I like to try and help people get on board with it / maximize their productivity with it. I also used to contribute to the OSS plugin before Gogland appeared. I'm not an employee of JetBrains.
I think Peter's opinion here is as strong as it is consistent for a very long time now. I actually had a run in with Peter on this subreddit in regards to the exactly same conversation - [should one be able to reason what a function does based on the functions signature](https://www.reddit.com/r/golang/comments/67eujw/passing_around_objects_in_go_a_subjective/dgqej0l/?context=3). IMHO it's just true when you're coming very close to the edge/leafs of the execution trees, and false the closer you're coming to main(). And there are many (I'd reasonably say - a majority of all) examples that just don't pass the smell test without looking at the documentation around the function, or actual implementation itself.
Yeah, sorry. Read that as "space". I blame it on it was late and I was tired. :)
Systemd socket activation is basically magic, and Go binaries start up so fast (moreso when they inherit a socket, vs having to ask for one) that I think a move away from long lived listen servers may be feasible. I've been working on something similar, and it works beautifully also with GRPC.
I would study error handling in great detail. Cause every language you need to check your errors like as if you wouldnt even trust Jesus with your inputs. https://dave.cheney.net/2016/06/12/stack-traces-and-the-errors-package Also, study the heck out of interfaces and multiple types cause that's where go shines. Go is more about coding philosophy then shiny new features. https://youtu.be/7YcLIbG1ekM https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk Just don't code like you learned in school for the most part. Because you'll be turning go into something it is not. It is a simple solution. It's sorta what people turn to when they get burned out memorizing the new generics of c++/c#/js
Thank you! This is already a great start! Also, I have seen A Tour of Go, is this a good place to start, too? 
Because it gets the point across without adding unnecessary detail. And yes, he has a point.
I've used systemd before with go. Works very well. 
I also have implementations in https://github.com/dgryski/go-onlinestats
Marketing guy here. I'd avoid Golang. The documentation is written for people who already know other languages, making it very difficult as a first language. (I love when the documentation says "as you might expect" or "the same as C" or whatever. ) There is much less golang code out there on github to borrow from. Much of the very cool stuff about golang about concurrency etc is not anything a beginner or marketer would need. Why not do JavaScript. That's what I wish I had done. 
Your's look way prettier. My was a fast writeup from some slides from school. Had to use it in a project but couldn't find a good implementation on the internet. Thanks for the link!
What about Gogland or vim-go steered you back, aside from cost?