Nginx is really powerful, but can certainly be a pain to set up. I've migrated all of my personal servers to [caddy](https://caddyserver.com) and couldn't be happier. Its all in go, and has a ton of cool bells and whistles (automatic https via let's encrypt is built in for example).
I want to write a class for db connection ,just like a mysql connection ,user call connect method at start .But if user don't call close method explicitly before GC ,I want the connection will be close too. 
I want to write a class for db connection ,just like a mysql connection ,user call connect method at start .But if user don't call close method explicitly before GC ,I want the connection will be close too. 
I'm not well-versed with Go, either, but why store that much data in memory? Usually people just iterate over the rows when they need to accomplish something. That makes it require less memory since you're just going over one row of data at a time.
i am the owner of said repo. This is not a promotion of my program. I doubt anyone actually uses this. However it does offer a great learning experience. Especially for those new to open source. Come learn to contribute!
You can use FileServer from the http package: http.Handle("/", http.FileServer(http.Dir("/app"))) This should be enough for simple cases. But for production I would recommend to use separate reverse proxy like nginx. 
&gt; If you down vote this post, please explain at least why. Thank you! I stopped caring about downvoters. (Of course, only after re-reading my post to see if there is indeed something wrong with it.) They may or may not have had a reason for downvoting. They might not like what you wrote, or they might just not understand what you wrote, or they might just be mad at their neighbour who mows the lawn at 7am while they try reading /r/gloang. 
Thanks for the advice, I noticed that down voting for no apparent reason is a thing on this subreddit...
[Language A] gurus slamming [language B] - are they correct? - No, almost certainly not. I have seen language wars since the 90's, and in the end they are mostly about opinions, emotions, and personal preferences. And about the fear of not gathering the larger community behind their favourite language.
ESBs are coming back!
Try to avoid using `append` when possible. When your slice is full, append will allocate a new array roughly two times bigger than the old one (I gathered more details on the subject for this SO answer: https://stackoverflow.com/a/32996582/1685538). So in a worst-case scenario you could end up using 2 times more memory than needed. Mini-optimization: can't for _, value := range strings.Split(line[23:], ";") { row.Values = append(row.Values, value) } be replaced by `row.Values = strings.Split(line[23:], ";")` ?
https://github.com/thewhitetulip/web-dev-golang-anti-textbook https://github.com/thewhitetulip/Tasks I wrote a Tasks application in Go while learning how to write webapp, then I wrote a introductory book :-D
I know the size of the file I use for my test,so I tried to set manually the capacity of each array, but with no big result ... guess in my case the append is not the problem. For the optimization : https://play.golang.org/p/DBmOFOkZdx use around 1G9 so 200m won just with that !
Why you need nginx at all? Golang has great HTTP stack, it even serves static files great. Single reason to use nginx is configuration flexibility. But if your application doesn't need that flexibility, I'd rather not use nginx.
I used pprof and the windows task manager. Probleme is that i need quick acces to specific row but also acces to many rows at the same time ( sort, filter ... ) 
caddy just need to reach 1.0. I mean for stable api 
beanstalkd. Really easy to run configure 
I've started working in the vim-8.0 tree https://github.com/fatih/vim-go/tree/vim-8.0, it's still not there but a beginning :)
Checkout my vimrc, I'm using also deoplete with ultisnips, you need to configure it for your needs though: https://github.com/fatih/dotfiles/blob/master/init.vim
Is there any reason for not using a proper project management tool like [gb](https://getgb.io/) while working on this project? It seems to need some packages and structure. You should also consider a mux for requests like [gorilla/mux](http://www.gorillatoolkit.org/pkg/mux) I might contribute to this :)
[Hi again](https://github.com/minus5/gofreetds)
This started as a way for me to learn golng. Then when someone added a random pull request i decided why not bring this simple toy to a community looking to learn. thanks for the input, ill be reading up on gb and mux today
While this is a great utility, the way licensing is described, this shouts DANGER ZONE.
Now I'm happy about all the bike shedding over vendoring tools. If there's no convergence on version metadata for packages with source code, there's no way in hell there will be agreement on how to integrate binary-only packages.
Go is not licensed under Apache, but it's own BSD-style license. The README says this library is under Apache 2, but the source mentions the Go license and a LICENSE file which is nowhere to be found. I'm also uneasy that the test has no copyright/license notice. I'm not certain it has to, but with these things one can't be too careful.
Sorry, no. Not that I'm aware of. I'm sure you could cook something up using reflection and unsafe pixie dust. That wasn't really the point though. The point was that as long as you know the number of items, you can put them in a generic array and get pretty efficient comparisons in one op.
first of all, happy cake day! 2nd you must run it from the source directory as the templates and html pages are there. that's the issue you are having rn. had it when i tried to do the same thing EDIT: added an issue as i do think this is something that needs to be worked out. workarounds are only temporary.
The confusion was probably caused by you getting it from [this file](https://github.com/cockroachdb/cockroach/blob/master/util/leaktest/leaktest.go) from CockroachDB and the only LICENSE file to be found is the Apache license that pertains to the rest of CockroachDB, which is obviously not the file spoken of in the header. Easy mistake to make. The code originates from a [net/http test](https://golang.org/src/net/http/main_test.go)
An equality function isn't that complicated (you're already adding a helper function anyway to avoid the ugly `[...]interface{}{1, 2}` syntax). I would just compare slices so you're not limited by static length at compile time. You can use your own type if you don't want to write `[]interface{}`: https://play.golang.org/p/x5cMPsSPM9 Or you could remove the helper function, and use a literal type of the correct length: https://play.golang.org/p/chluOtp-4y
So, who's responsible for gometalinter? Seems this would be a valuable addition.
I could just make a PR, but I guess it should be disabled by default? Or maybe not report if all dependencies are unvendored?
Good luck using slices as map keys, kind of ruins the whole idea. Agree about the literal types though, definitely cleaner.
Sometimes, depends on how general purpose the functionality is. I can see cases where one struct per key type just isn't possible. Part of the point is the generalisation this allows without writing lots and lots of boilerplate.
Ah, well, the point is to get the equality taken care of by the compiler, without crossing the line to user code per value. That is what enables using them as map keys. I am aware that it's generally a bad idea to use fixed sizes; but for some things, like index keys, it makes total sense.
That's kinda what I was thinking, won't I need load balancing eventually?
yes, but you don't need nginx for that. There is also DNS load balancing and many other solutions depending on your environment. I actually use haproxy instead of nginx for LB. But it is more a LB specific question and does not have anything to do with golang. Maybe this helps: https://www.digitalocean.com/community/tutorials/how-to-configure-dns-round-robin-load-balancing-for-high-availability
Does this warn you when vendoring in packages other than main? Because that's generally a mistake right? Isn't the consensus that only main package should have vendored dependencies? Anyway, this looks great.
Fix the type declaration for `def`. You have a slice of anonymous structs, but you want to end up with a slice of `def` structs: type def struct { You create a slice with `make`, not `new` (but you don't need to make it since you're gong to let the json package do that for you) var json []def w.Get(&amp;json) Then don't ever use pointer to an interface, so decode with err = json.NewDecoder(resp.Body).Decode(payload)
pro-tip: the conversion of a `[]byte` to `string` in an index operation is optimized away by the compiler.
I see you took out the helper functions in https://github.com/fncodr/godbase/commit/648c17c971fe26ad2c9bf0f8ab73e86e2d4dc860 -- that makes the two cases a lot closer to each other.
lol @ being downvoted for saying what is very obviously true (I've proven it in production).
Why does it show my text as [removed] if I log out?
Assignment and condition in if. This new style of coding in Golang sometimes really make code not easy to read and ugly (long line). I prefer one line-one condition or statement, except for `for` command.
Thank you for sharing your preference.
Why doesn't func Definition just return []def instead of interface{}?
Someone shared the good idea, I think I tried at one point but didn't get the extra parens right and just moved on. I agree, learning to use the very expressive literals instead of insisting on encapsulating everything is a step in the right direction.
App reads an environment variable for assets dir and reads file relative to it. This provides flexibility across our test, staging and production environments. ASSETS_DIR=/opt/public ourapp We simply tar all assets and use scp. That is all automated with ansible.
&gt; If the dependency I'm importing isn't in vendor/ then I'm likely using some random version lying around in my GOPATH. That sounds like a potentially big problem. No, I don't believe that's true. At the very worst you are using a stale version of that package (a situation you will end up more often with vendoring, because upstreams are notoriously bad at updating vendored stuff, hence my comment about security and the prohibition of vendoring in debian) or your program won't compile; true, your program will, on average, refuse to compile more often without vendoring than with. This is a the fundamental problem, I just don't think vendoring is the correct solution. &gt; Now, TheMerovius states their opinion about vendoring for libraries very strongly. I'll assume they mean what I do + commiting the dependencies source code into your VCS along your projects source code. No, I don't. The "checking it into your VCS" is actually the only advantage vendoring has at all (because it at least ensures that stuff can't just drop off the internet). &gt; TheMerovius makes it sound as if the go compiler could do an rm -rf / if I did this. Yes, I think something like this is a very real possibility. Probably less `rm -rf /` and more a "silent corruption of your database because you use two mutually incompatible versions of a package that assume different schemas" or "…mutually incompatible versions of a package that assume a different layout of files on disk" or something like this, but same difference. My production machines won't contain much of value except the on-disk state of the programs I'm running anyway - installing a new OS takes less than 5 minutes - so corrupting that is just as good as an `rm -rf /`. Think about it this way: For years, people have *strongly* objected to the idea of having one GOPATH per project - indeed, the very *concept* of GOPATH is diametrically opposite of that, because why would I check out my sources into one central path, if project's GOPATH's are self-contained? The go tool could just use "the root of the current repo" instead. But that's *exactly* what the current vendoring hype does (in the open source world. As I said, if you work for a company that has a monolithic source tree for *everything*, that's different. I work at such a company and vendoring works very well there). Every repo will probably come with a structure like this: cmd/foo cmd/bar cmd/vendor/... // vendoring the dependencies of my main-packages, yay! pkgs/… // no vendoring for library-packages now, how is this any different from setting GOPATH to the root of the repo and moving the contents of vendor to the top-level? I find the idea of vendoring harmful and very much un-go. I am stating my opinions strongly, because I am bitter that this is the way that was adopted by the community.
Great, thank you very much!
&gt; more a "silent corruption of your database because you use two mutually incompatible versions of a package that assume different schemas" or "…mutually incompatible versions of a package that assume a different layout of files on disk" or something like this Last time I checked if A vendored B which vendored C, A didn't compile until it vendored C itself, and the vendored B used the C vendored by A. The C vendored by B (under `A/vendor/B/vendor/C`) wasn't used and all code in A and vendored by A compiled against the same version of C (in `A/vendor/C`). It's possible some setup of `vendor` directories could lead to the effect you describe. `A/baz` imports `A/foo/subfoo` and `A/bar/subbar` which in turn import `B` respectively from `A/foo/vendor/B` and `A/bar/vendor/B`? Then a linter to warn about it would be helpful. Yes, it would be nice if something like this wasn't possible in the first place, but AFAIR some people wanted to be able to do this when two versions of a package could coexist without these extreme consequences. I'm convinced most of the time this is not what you want, but I don't feel like I can tell people (some of which have much more experience than me) that they will certainly never need to be able to. &gt; Think about it this way: For years, people have strongly objected to the idea of having one GOPATH per project - indeed, the very concept of GOPATH is diametrically opposite of that, because why would I check out my sources into one central path, if project's GOPATH's are self-contained? The go tool could just use "the root of the current repo" instead. &gt; &gt; But that's exactly what the current vendoring hype does [...] Per-project GOPATHs were error prone. You either had to use weird-shell-magic or set them per shell session. That's the main issue I recall people having with it.
No, you can use it to proxy too: https://caddyserver.com/docs/proxy
Interesting. I was seeing the same problem on OSX, but thought it might be garbage collection. Let's assume for the time being that the profiling bug is fixed, and that instead it's a problem with the code. The code I mentioned above also had Dgemm as an inner loop. It could be that there's a scheduling issue on Darwin, and possibly the way gonum is coded is triggering that. Do you have access to OpenBLAS? I don't have access to a linux box at the moment. I'm curious if the gap between OpenBLAS and gonum/blas/native is the same on both systems, or if it's much larger on OSX. I can also try and take another pass at the Dgemm code. It's been a while since I tried optimizing it, and the Go compiler has gotten much better. On the bright side, the upcoming SSA compiler has some substantial speedups. On the down side, I the gap between dgemm and OpenBLAS mat mul is still much larger than I'd like for large matrices. If you happen to be an expert in mat-mul algorithms when the scheduler is roughly FIFO...
This looks very interesting. I am moving over to go mostly from bash and perl I worked in devops with some monitoring tools, but I am looking to build some small stuff from scratch to get away from some of the more complicated big box solutions and make it a bit more simple and manage those configurations through tools like puppet. Edit: Also like the website how did you build that if you don't mind me asking. 
Thanks for the data point!
I was wondering if perhaps the matrix ops were being internally parallelized, and due to some scheduling issue (poor goroutine management, or maybe unlucky distribution of matrix work?) one was finishing early, blocking on the semaphore, while the others chugged away.) I've no *evidence* of that, just a guess. I don't know why it would behave differently on Linux though. &gt; Do you have access to OpenBLAS Not sure what you mean. Are you saying there's a C binding for Go for OpenBLAS, and I should try that? If you're interested in source, my project is here: https://github.com/armhold/rnn. It's a recurrent neural net that I translated to Go from Python. I was surprised that it seemed to be about 10x slower than the original. I researched a bit, and a comment by /u/jerf [1] explains that gonum isn't able to use SSE, while Numpy is. That explains the general disparity in performance. Still, I wanted to see where it was bottlenecking, hence my profiling. It's quite possible that I'm doing something less than optimal. I've wondered if maybe keeping the matrices around and zeroing them out between uses would be better, but haven't tried that yet. &gt; If you happen to be an expert in mat-mul algorithms when the scheduler is roughly FIFO... Hah, sorry, I'm not at all an expert. I had to reach back 20+ years to my distant linear algebra classes just to get this simple translation working. But if you have suggestions I'd be happy to try them. I don't want to waste your time though, as this is just a for-fun project and nothing critical. [1] https://www.reddit.com/r/golang/comments/2f6053/matrix_operations_in_go_inspired_by_numpy/
Also, FWIW, all of my code is single-threaded (go-routined? not sure what the term is here in Go-land). If there's any go-routines happening besides main, it's coming from gonum. 
Yea, matrix multiplication is coded concurrently. If you set GOMAXPROCS to 1, I think the runtime sem stuff will go away. 
govendor list +unused
For a second I thought you'd rigged Alexa to work while riding on the drone (why have Alexa be stationary, amirite?) Regardless, pretty awesome—gotta love mashup demos with cool tech :)
I see only ~~one~~two snippets. Am I missing more?
Nice! Two small comments: * No need for `go get`ting the resize package. `go get github.com/stdupp/goasciiart` does this automatically. * Also no need to build after get, as `go get` automatically runs `go install`. And it seems the algorithm assumes a font whose characters are exactly square, otherwise the result looks stretched in one direction.
That's pretty cool. I never knew that arrays had particular advantages over slices, in this way. Are there any others (beyond performance and fixedlengthiness)?
I think what you want is defer, like so: func main() { db, err := sql.Open(driver, dataSourceName) if err != nil { // handle err return } ... defer func() { err := db.Close() if err != nil { // handle err } }() }
Between several servers? Then you already ought to know how use nginx to load balance for several upstream http servers. Do you know how to? If you do, then why you ask the question?
Also, Golang has utility function to make proxy requests, so you can easely build your own load balancer.
I wrote my own using a combination of [GeoDNS](https://github.com/abh/geodns) and [Oxy](https://github.com/vulcand/oxy)
I'm using [vulcand](http://vulcand.github.io/) but it relies on etcd so might not work out for you.
&gt; oxy Oxy looks really good 
Not the same thing ,think that I write a library let's say it named Test,then I provider the lib to others.People use the lib,but I don't know how they use ,if someone just call open method ,then don't call close method explicitly ,I want the Connection always closed when GC destroy it.
thanks for your reply, i set a default scale 1:1.6 (width:height) to avoid that,if you open the result in a browser will much better :)
:)
What about _you_ being patient and wait to have some content before posting your link here?
You can check on https://github.com/akhenakh/statgo (author here) it has the advantage of being multi platform, BSDs ... But the disadvantage of relying on cgo to access libstatgrab. 
No, you cannot simply import json.
Just use nginx. Has been around for a while, its easy to use, its robust and mature. 
That's interesting. I never thought of simply jumping to the symbol. I guess I never really paid too much attention to how other (stdlib) packages used certain runtime functions. Nice post!
You can also use Caddy and its `proxy` directive, where you can set multiple backends, health checks, routing policy,and more. e.g.: proxy / web1.local:80 web2.local:90 web3.local:100 { policy round_robin health_check /health proxy_header Host {host} proxy_header X-Real-IP {remote} proxy_header X-Forwarded-Proto {scheme} } https://caddyserver.com/docs/proxy
The reference time thing got me when I first started using Go. Didn't understand that it *had* to be that specific time for it to work and kept wondering why my times were off. Much easier to use than in other languages once you get this. As for the actual value of the reference time, what's the significance?
Interesting. I haven't seen those backticks before. What do they do in the context of defining members of a struct?
Here's a really minimal approach: https://play.golang.org/p/ZM-X1UuyPy This exploits the json's package of automatically parsing lowercase json data into upper-case exported struct fields, but is fragile because the variable names must match. Here's a slightly more verbose but more typical approach: https://play.golang.org/p/zy05NDhYm3 This allows control over naming the fields to make more sense when used in the code.
That is funny I was just at a golang talk by two employees of hashicorp. I ended up talking to one briefly about console. 
oh, thanks, that really helped me a lot.
&gt; The only exception is if you're multiplying a skinny matrix by a tall matrix. Yeah, I'm doing that unfortunately. The origin Python RNN code does lots of 100x100 * 100x1 math. &gt; blas64.Use(cgo.Implementation{}) Cool, got it working. It's about 3x faster now. Thanks!
They also let you specify the type, for example: type Foo struct { Bar uint64 `json:"bar,string"` } When marshalling between JSON and Go, the type will convert.
A little extra explanation: Backticks just define a string. Unlike double quotes, though, a backtick-delimited string isn't parsed for escape sequences and can span multiple lines. It's usually used for struct tags because of the double quoted strings that are used inside of them, but it's just convention.
What a classy reaction, bravo!
I mean, if a coworker did this in their code I'd throw my stuffed gophers at them, but it's still neat. 
I think its `(*MyData, error)` instead of `(&amp;MyData, error)`.
I really have no idea what is faster but i strongly suppose that when you use the [golang asm](https://golang.org/doc/asm) library that you will outperform java. But i dont know if its within your constrains.
I don't know how anybody could possibly answer this question for you. There are so many unknowns and unknowables that the only realistic way is for you to answer the question yourself: build a prototype and see what works best. Also, keep in mind, given that you claim to be building a "game engine", it's quite possible that the answer will be "neither." Experiment, then analyze, then build.
Good point, it seems completely arbitrary on an entirely different level.
Under "update", there may be an "announce" and/or "withdraw" section. &gt; "message": { &gt; "update": { &gt; "attribute": { &gt; "origin": "igp", &gt; "local-preference": 100, &gt; "extended-community": [842122844570372] &gt; }, &gt; "announce": { &gt; "ipv4 mpls-vpn": { &gt; "101.1.101.1": { &gt; "2.6.0.0/16": { &gt; "label": [1001], &gt; "route-distinguisher": "65000:1" &gt; } &gt; } &gt; } &gt; }, &gt; "withdraw": { &gt; "ipv4 mpls-vpn": { &gt; "1.2.3.0/25": { &gt; "label": [1001], &gt; "route-distinguisher": "65000:1" &gt; } &gt; } &gt; } &gt; In this section, the IP address, "101.1.101.1" is the key, but it is also data. It identifies a gateway. There could be multiple gateways in the message, each keyed by their IP address. The same goes for the "2.6.0.0/16" subnet address underneath. &gt; "101.1.101.1": { &gt; "2.6.0.0/16": { &gt; "label": [1001], &gt; "route-distinguisher": "65000:1" &gt; } 
Backplane is entirely go based. It runs as a service which will save you some big headaches trying to figure out how to distribute your services as you scale. It uses a reverse tunnel to connect your backends to the load balancer so you don't have to worry about firewall configuration. You can run backends on anything that has an internet connection. The open source client used for connection and configuration currently supports linux and OS X. It even supports lossless switchovers (blue/green deploys).
its the same deal with python, you'll be making use of some kind of binding. I don't know what your goal is exactly but either should work. If your looking for a quick one off you can customize in Go, there's this example from my repo: https://github.com/dskinner/snd/blob/master/example/oscil/main.go That plays a 440hz tone and for a cheap metronome effect you could just change these lines osc := snd.NewOscil(sine, 440, nil) // oscillator al.AddSource(osc) to this instead osc := snd.NewOscil(sine, 440, nil) // oscillator dmp := snd.NewDamp(snd.BPM(80).Dur(), osc) al.AddSource(dmp) 
I'm specifically looking for user feedback, bug reports, etc. 
Add it to your path
Actually, I recommend everyone to read this article as it points out some real possible problem, but, yes, the poor choice of title is killing the whole article.
Good suggestion I will see what I can do there.
First of all, I think what you are looking for is a load balancer; there is no need (ordinarily, anyway) to otherwise stick a web server in front of a go service; the http library should be fine. Secondly, you should not use fastcgi. You will want to use a simple reverse proxy. Nginx and haproxy (which I kind of prefer for this purpose) will work just fine for this. There are other options as well, but I'm mainly familiar with these two (and ELB on aws). Finally, you will want more than one load balancer, balanced using round-robin dns with the lowest ttl you can afford to pay for given your traffic. I kind of get the feeling, though, that you may be putting the cart before the horse.
you need to add `$GOPATH/bin` to your path, not `$GOPATH`
I'd really like to see this reworked in the future but I doubt it'll happen.
Clickbaity titles considered harmful.
tl;dr: the article is wrong. After reading the article, it seems as bogus as its title. - Yes, do use json.Decode for a single object. A single object can still be large(tm) and it'd be stupid to read it all into a large buffer. - No, json.Decoder does not "silently ignore invalid syntax". It deals with correct syntax. Also it looks like a made up example. - json.Decoder does not drain HTTP connections properly – fair enough, but you already had to drain it manually because of trailing whitespace, anyway. And the fix he links to has nothing to do with JSON in the first place. It's related to GZIP and would occur with any reader on a compressed connection.
Assuming I've understood the problem, and that the keys are unknown but the depths are fixed, I think the piece you are missing is that json.Unmarshal works just fine with map[string]struct{...}. I reworked your prototype with straight Unmarshal, using maps of strings to structs where appropriate: https://play.golang.org/p/8dAanVHxvO If entries in the object keyed by "ipv4 mpls-vpn" can be arbitrarily deep, things get more complicated, but you might still be able to set up e.g. recursive structs to unwind it. That all said, this is kind of a weird JSON blob, so if changing it is in scope, I'd change it to use arrays of structured objects where it's currently using maps from arbitrary keys to structured objects.
So, a map inside a map? type Update struct { Announce map[string]map[string]Announcement } type Announcement struct { Label []uint32 RouteDistinguisher string }
Ignoring the stdlib bug, let's talk about the semantic of wanting to notice that the sender sent multiple objects, and giving an error. That calls for a func Decode(r io.Reader, v interface{}) error that ensures the singular object being decoded is followed by optional whitespace and an `io.EOF`; otherwise, return error.
Got me too, because it's very, very weird. Like, weird enough that I read the docs a bunch and still was incredibly confused.
Basically, your project should be a library. Whatever code you can move into vendor, should be that library.
Relevant to this: https://github.com/golang/go/issues/6705
Nevermind, found it https://github.com/meshbird/meshbird. No need to upvote :)
Stdlib usually does stuff like `urlStr` instead of `url` Kinda sucks but shadowing can get annoying and then you'll have to go back and rename variables, which even with an IDE isn't fun. 
Lib or create some sort of generator. 
In my experience it doesn't come up much. Thinking about it the most problematic is net/url, and then I just use u or something.
Sounds like you should check out gorename if you think renaming variables is a pain.
It was this post, and this post alone, that convinced me that maybe there's something to be said for Go's way of error handling. But I still like unchecked exceptions.
I've found this tool to be really useful for this kind of thing https://mholt.github.io/json-to-go/
Just FYI, your first point is a common misconception. json.Decode actually does store the entire json object (not to be misinterpretted with the stream) in memory, and in fact, calls json.Unmarshal on it. The "json.Decoder" actually uses *more* resources to read a **single** json object, as it creates and allocates additional stream handling objects, and performs additional work to scan the input. It's purpose is exactly what is stated for: to read *multiple* json objects in from an input stream. When it comes to reading just one, it's more efficient to read into a []byte and unmarshal it. PS: Don't believe me, just look at the [go source code](https://golang.org/src/encoding/json/stream.go). Also, regarding your second point - the author is actually correct, at least in regards to using json.Decoder for a single json object. Once again, the Decoder is meant to process *multiple* json objects in a stream, so it'll allow multiple "root-level" json objects in the input, whereas a truly valid json input would only contain one root json element.
[**@GolangUKconf**](https://twitter.com/GolangUKconf): &gt;[2016-04-29 07:30:12 UTC](https://twitter.com/GolangUKconf/status/725950296724148225) &gt;🔔 Last 48 hours in our Call for Papers! We welcome papers from all people &amp;amp; are in need of lots more topics [*golanguk.com*](http://golanguk.com/speakers/) [#golang](https://twitter.com/search?q=%23golang) ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/4gyk4w%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/joealcorn/TweetPoster) [^[Issues]](https://github.com/joealcorn/TweetPoster/issues) 
[Here](http://docs.traefik.io/benchmarks) :) 
Yes, you are right! Now, prompt and --master are supported too, --master only used to test(same goes for adding passwords). See source code: [main.go:42](https://github.com/mkideal/onepw/blob/master/main.go#L42) Master string `pw:"master" usage:"master password" dft:"$PASSWORD_MASTER" prompt:"type the master password"`
This. Oh gads, yes - thank you! Because all I really want is a native strftime to deal with time stuff. ...and yeah, there's https://github.com/jehiah/go-strftime - but really? Pulling in a 3rd party library for something so ubiquitous as strftime()? Thanks for the link - I suspect that may ease my way up the golang time learning curve... and it will definitely save me some head scratching along the way. :-)
"Look at this book I wrote. It's written in reverse and in Spanish, but trust me there is some great stuff in there" 
I thought this was a good article. At least I wasn't aware of the nuance between Decoder and Unmarshal. Not sure why it's getting all the downvotes...
Much better than websites with banners that drop down over the text you're trying to read whenever you scroll. e.g.: http://qz.com/672463/belgium-will-give-iodine-pills-to-its-entire-population-in-case-of-a-nuclear-disaster/
errors.Wrap looks interesting, but I'd argue that if I get an error from a function defined in package foo, then any IsTemporary or other such function that I'd call for context would come from foo as well. I'm not going to call os.IsNotExist on errors from any old function.
I don't know about upstart, but systemd by default captures stdout &amp; stderr and stores them in journald. So you don't need to do anything special in your program.
How this relates to this other one? https://www.tinc-vpn.org/ Just curious
I have, but I needed three things that oauth2_proxy didn't have: * Routing based on subdomain * WebSockets * Let's Encrypt support I also didn't need much of what the bitly project has. Add a dash of not-invented-here and you have an implementation from scratch*. \* If you look at the code it's mostly a fancy config file parser. The heavy lifting is done by packages like net/http/httputil, https://github.com/yhat/wsutil, https://github.com/xenolf/lego, and https://github.com/dkumor/acmewrapper
Regarding the first point: Yes, this is https://github.com/golang/go/issues/11046. It's not a fundamental property of the decoder and will hopefully change in due time. Regarding the second point: Fair enough. However, it's still largely a made up issue, and if it's real, points towards an issue with the encoding, not the decoding. The article makes a lot of noise about problems that aren't really problems in real code, and discourages the use of something that makes for nicer code and proper composition of readers.
I'm still pretty new to Go. Is there some documentation on this behavior? te, ok := errors.Cause(err).(temporary) Specifically the .(temprorary) part. I understand the double assignment. I don't understand the .(thing) notation.
I'll check this out later, starred and followed. Assuming there's an async mailbox/queue between the actors, I'd love to implement a pluggable system to allow for message brokers in between...
How about passing an error handler function for each error type that can occur?
Yes there is, actors can be configured using Props (much like Akka). https://github.com/rogeralsing/gam/blob/dev/actor/props.go#L40 pid := actor.Spawn(Props(NewMyActor).WithMailbox(MyMailboxProducer)) So it should be fairly easy to create a persistent mailbox
Nice!
Go probably allocates more memory than it uses, so I'm guessing pprof is the accurate way. What breakdown does pprof give for memory usage? It sounds like you might have a time-memory tradeoff then. If you want to use the minimum amount of memory you can just store the bytes and parse it on demand. You could even store your own byte format, say &lt;length of row&gt;&lt;length of field1&gt;field1&lt;length of field2&gt;field2. Another idea would be to load the entire file into a []byte and reference the values in there with byte slices (loading the entire file into a string and using strings may work, but I'm less certain how Go strings work internally). So you would have type Row struct { Key []byte Values [][]byte } And then don't use NewScanner. I think you can use bytes.Split() since it should just use slices of the []byte data that you give it. Of course, that could use more memory since the byte header seems to be larger than the string header. If you want to use the minimum amount of CPU, then converting it all into structs is probably a better idea.
It doesn't reinvent anything. Errors in Go are simple values for exactly this reason.
For those that do not already know, Discord is a new chat service that is growing in popularity. Having checking though the search and other places it doesn't seem that there is another Discord chat channel dedicated to Go already so I am offering this as an candidate for that job :) &amp;nbsp; Also, if you are a mod/admin here and decide to join, send a message to to me with your Discord name and I will also give you moderator privileges on the server. &amp;nbsp; Sub-Channels are available for Go Package developers where you can have a room dedicated to your specific package. &amp;nbsp; I am very open to constructive criticism to help make this a useful tool for both expert and new Go programmers. 
One thing you might want to take into account is how much memory management you want to do-- gc pause times will probably be a big concern for keeping frame rate up in your engine. I'd recommend measuring or researching pause time comparisons between Java and Go.
Also, for arbitrary precision: https://github.com/EricLagergren/decimal The 'testing' branch holds the new API which will hopefully be released this weekend. There's also a wrapper around the bcd C library that GCC uses for its decimals floating around somewhere. I cannot remember what it's called, though.
No, it's Go written with SOLID principles -- which apply to essentially every language.
while not in the spirit of csp this looks like a pretty interesting project and uses go idioms well.
Very interesting. Thanks for sharing.
I wrote this as part of testing [the C API](https://github.com/rust-lang-nursery/regex/tree/master/regex-capi). Rust's regex engine in particular is heavily influenced by both Go's `regexp` package and RE2 (uses finite automata, linear time matching, etc.).
&gt; Not sure why it's getting all the downvotes... I'm confused by this as well, ok maybe the title was a little alarmist but the content is valid and easy to read. I've noticed this sub-reddit has a lot of downvoted content that is actually decent or good, just elitist reddit gophers I guess.
I do feel like the community was generally more positive a year or two ago. I hope we can get back to that place.
how's the performance? in particular, i wonder if go-&gt;rust can be made faster than the cgo overhead by exploring some of the properties and guarantees of rust (i'm not that familiar with it, so sorry if the question is naive). i would love to get rid of most of the 150-170ns overhead of a cgo call and get better safety guarantees...
Im a big fan of web 1.0 form post back and as little js as possible when I can help it ha. Saves you from having to-do things like validation twice in two diff languages. 
Um, what's the difference between this and big.Rat?
Somewhat off topic, but does anyone still prefer the proto2 way of doing things? Lack of default values in v3 is my one big complaint, but I miss the required/optional distinction as well.
What if to get past the overhead of calling C, you took the assembly from Rust and turned it into assembly for Go?…
Huh, does Rust's regex engine support negative look ahead? I find its absence quite painful in Go.
As far as I know Discord is more along the lines of programs such as Mumble, Teamspeak and Ventrilo. That means although it allows rich chat messages like Slack it's mostly made with voice in mind.
There are pcre bindings for Go.
I've added a chat server/client example that shows how to connect multiple clients to a shared server. https://github.com/rogeralsing/gam/tree/dev/examples/chat 
&gt; Ironically, I can now write Go date format strings now after building this site. LMAO
Very simple and easy, thanks!
Thats the point I was trying to make, you can (using this strategy) pass an object to the header and the "body" template is only concerned with the "body" model
This is the best post I have read in a long time! It highlights internal struggles that have every-time I make all the decisions. I too love the simplicity of server-side templates, I love loading a model from the DB, overlaying properties with form post values and providing that to the template as the model, so I have have buttons that can post back to the serverside and manipulate the model, and only on an postback where action=save do I persist back to the DB... If that made any sense... My main stigma with the JS frameworks is of all the ones I've used I like AngularJS the best, and It irks me that Angular2 (which has alot of features and ideas I really like) Is pushing TypeScript or some other trans-piled language so hard. I hate the idea of compiling from one interpreted language to another, And I really dislike the idea of running any node software on my development machine...
While I haven't used slack, I've been told discord has a fairly similar interface. There is this post where Reactiflux explain why they migrated from Slack to Discord in a very detailed post https://facebook.github.io/react/blog/2015/10/19/reactiflux-is-moving-to-discord.html. Vs IRC, Discord has a much more modern interface but beyond that there's not much you can do to improve upon a text chat interface. Like shovelpost mentions, Discord also has full voice capabilities similar to mumble or teamspeak. Discord has some gamer specific features like a game overlay. There's also a pretty good API for writing custom clients or bots and that's actually how I got into this to begin with... Personally, I think it wraps up all the stuff I need from a few different tools into one and has a great interface.
Made it very fast in a few hours, I know there are some bugs and a method which doesnt work how it supposed to be. But it was a little sketchup. I'm planning to make a rosetta plugin for VSCODE and ATOM
You just gotta accept `if err != nil ...`. That's how things are here. If you write Go in Java/Python/SomeoneElse style, you're gonna have a hard time. You're right though, a huge chunk of code is error checks. &gt; and you end up in deeply nested if blocks Go should be pretty flat. If you're deeply nested, then you're doing something wrong.
&gt; Having built-in language support It's not a language change. It's a tool change. And don't worry: "go get" will not support binary-only packages. The packages have to already be on your filesystem in just the right place already. This is just preventing even uglier hacks that people are already doing. 
This is the double-edged sword that I both welcome and loathe about software. On one hand, OSS is inspectable, fixable, and maintainable. On the other hand, you can't really capitalize on IP if you wanted to. I don't think this will hurt the Go community as a whole. What I do think it will do is tip the scale for corporate fence-sitters in favor of Go over J2EE or .NET stacks, if the open nature of Go and how Go is distributed were a gating factor. I really don't see things like a "Go Marketplace" becoming a reality. I might be overly optimistic, though.
Okay going back to Node.js
So it's good for things like currencies right?
time and money, anything that you accumulate and want to control rounding errors in really...
Why? "Alright team, they made one change I don't agree with. Scrap everything. We are out of here"
author here. Would love to answer any questions anyone might have. This was a fun airplane project to work on and I plan on improving it even more from where it's at now. The thing that prompted this project was I was really tired nobody writing password managers were using AEADs and I also don't GPG, so all the crypto is very modern.
I now adopted [functional options](http://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis), which is way cleaner and I think more elegant than taking option structs and variadic interfaces. You should check the [updated doc](https://github.com/jochasinga/requests).
Thank you! Actually after feedback from the community, I adopted the cleaner, more idiomatic [functional options](https://github.com/jochasinga/requests#functional-options), which means you can tweak and customize anything usually done in `http.Request` and `http.Client` in one place. Apparently, taking `...interface{}` was brittle and unidiomatic. You can still use [PostJSON()](https://github.com/jochasinga/requests#post-requests) as a shortcut to marshal data to JSON though.
Thanks for your feedback. It now [does](https://github.com/jochasinga/requests#handling-async-errors). 
Thank you for every feedback. They're all really great improvement advices. Just a heads up that due to your feedback (and others more), the following changes were made: *Functional options instead of `...interface{}` (clean and simple) *Custom `Request` and `Response` types so you can do: opts := func(r *requests.Request) { r.Timeout = 0 r.CheckRedirect = someRedirPolicyFunc r.Jar = nil } res, _ := requests.Get(url, options) if res.ContentType() == "text/html" { fmt.Println(res.String()) } *`Error` field in `Response` to carry the connection error in `GetAsync` to the main routine. rc, _ := requests.GetAsync(url) res := &lt;-rc if res.Error != nil { // handle error }
Awesome work... I really like the changes you've made! These are the kinds of packages that I think are really great. Simple wrappers that reduce boilerplate code for common operations.
Check this out. https://github.com/mongolar/mongolar
Does this bring us a step closer to facilitating debianization (and similar packaging) of Go apps &amp; libraries, en masse? I feel like it does. My woolly understanding is, that Go's existing dependency model doesn't line up neatly with Debian policies, mainly due to the lack of independently-built dependencies. I asked Andrew G about it last year, and I think he said words vaguely to that effect.
So this is basically wanting to use a screwdriver to chop a piece of meat and complaining that the screwdriver cannot be used for that purpose. Actually, I can relate to this situation. I've faced a similar problem some months ago when I wanted to do something strange with my csv file and I was expecting `enconding/csv` to be configurable enough to let me do it. But the catch is, my change made my file to be a non-valid csv. The `enconding/csv` package is designed for valid csv and nothing else. If you want do decode something that _looks_ or _is similar_ to csv but _is not_ csv then do not use `enconding/csv`. You are using the wrong tool. Simple as that. &gt; This needed to be a simple class, and I will write my own version of it, but I am disappointed by the stdlib. The Go standard library provides the basic tools to be able to read any file. All you need is a for loop and some programming. So it's not stdlib you should be disappointed with.
&gt; Support for black boxes is supporting an opaque and brittle ecosystem. 1) It already supported these *black boxes*, how else is package caching supposed to work? 2) That is all.
&gt; The thing that prompted this project was I was really tired nobody writing password managers were using AEADs and I also don't GPG, so all the crypto is very modern. Just using regular GPG is a major selling point of `pass` for me because it makes the passwords easy to manage. How do you manage multiple directories of passwords encrypted with different keys for different people?
You do the same thing with the .h in c++
Have an upvote, you're not the only one a little frustrated with the csv package. Being new to go, I'd suggest not taking your experience with package csv too hard, the std lib is generally high quality and a great read for learning go as well. I'd also recommend getting familiar with accessing the docs if you haven't already, for example: https://golang.org/pkg/encoding/csv/#Reader "If LazyQuotes is true, a quote may appear in an unquoted field and a non-doubled quote may appear in a quoted field." As someone else mentioned, setting LazyQuotes to true should take care of your case without you having to alter your data. Also, for accessing third-party documentation: https://godoc.org/
&gt; The modification I made was a change to the delimiter, that is all. That hardly would be a massive customization. So this is no longer a CSV file yet you want to use `encoding/csv`? &gt; Why does the CSV class need to deal with quotable strings? Because of the CSV spec.
Your input data is tab delimited not csv. So don't use encoding/csv. All you need is string.Split. https://golang.org/pkg/strings/#Split 
The title should have been: "Do I over do it sometimes?"
So You Want To Write Your Own CSV code? http://tburette.github.io/blog/2014/05/25/so-you-want-to-write-your-own-CSV-code/ Even for PHP, don't write it yourself but use this http://php.net/manual/en/function.fgetcsv.php and this http://php.net/manual/en/function.fputcsv.php
Assembly. Those stupid programming language devs have anyway no idea what they are doing /s
Distributed channels example https://github.com/rogeralsing/gam/tree/dev/examples/distributedchannels
Man up and don't suffix /s
I mean it's very fast when you're used to doing c++ haha I've never once thought it was too slow.
&gt; Your input data is tab delimited not csv. The `delimiter` is irrelevant. &gt; All you need is string.Split. https://golang.org/pkg/strings/#Split If you actually have a csv file, this is absolutely the wrong thing to do.
No solution, but it does have a restriction. If Go 1.7 and 1.8 are explicitly incompatible, library authors are forced to deal with it instead of making something for 1.6–1.9 that breaks in 1.10. That discourages binary distribution and thereby discourages lock in. 
If you for real want to ditch Go to dive back into Javascript callback hell then godspeed.
"Directories" is all imaginary in passgo. It works like we have real directories but all the passwords just go in to one big file. Not sure what you mean "for different people". Here's how the crypto works. You have a master password that goes in to Scrypt to generate a master symmetric key. Also a master public private key are generated. The master private key is encrypted with your master symmetric key. Next, when a new password is added to the vault, I really didn't want to prompt you for your master password, so a new public private keypair is generated. The site private key and your master public key are used to agree on a symmetric key, which is used to encrypt the site. The site public key is saved with the encrypted password in plaintext. Lastly, to display the site's password we need to prompt for your master password. We regenerate your master asymmetric key from the password, and then decrypt the master private key. Using the master private key and the each site's public key we can regenerate each sites symmetric key. 
Thank you. After looking into other "interpretations", I tried to balance between what's idiomatic in Go (simple but sometime repetitive) and what can be wrapped without introducing too much complexity that needs more learning. If you like the idea, why not fork it to see if you can help?
&gt; Not sure what you mean "for different people". With `pass` you can have different keys for different directories or even multiple keys per directory. This means you could share the password database with your co-workers and everyone could just open the passwords meant for them.
Ahh. Passgo does not do that yet. I've thought about how to add sharing and it's something I want to do, but I haven't quite figured out the right way yet.
Can you give a sample of the TSV file (which includes a line that `encoding/csv` doesn't parse correctly)?
The error 'invalid memory address or nil pointer dereference' refers to you trying to dereference a pointer that is nil. For instance, say you issued an http.Get response. resp, err := http.Get("http://example.com") if err != nil { fmt.Println(err) } Now, if there was an error and you tried to dereference and use a variable in resp, you would receive this error as resp is a nil pointer (http.Get returns nil for *http.Response, and an error) and as such has no members or variables (trying to read resp.StatusCode for instance will produce this error). What it could be is you're trying to use the `doc` variable after checking for a possible error. If there was an error creating a NewDocument with goquery, `doc` will be nil and calling `doc.Find()` or anything else on `doc` will result in the error. Check the lines the output shows too: /Users/Kaly/code/src/github.com/misamisa23/decode/decode.go - line 138 /Users/Kaly/code/src/github.com/misamisa23/decode/decode.go - line 186
A friend and me are writing an smtp server(https://github.com/gopistolet/gopistolet), it's far from complete but we have been running it on a server for a couple of months now. You can register a handler that will be called when a mail is received, just like a http handler.
Also, looks like the URL you are trying to issue a GET request on is incorrect - it's trying to GET on the entire &lt;img&gt; element instead of just the URL.
Hi, sorry it took awhile. out is a variable of type channel. Channels are used to send data from 1 goroutine to another. mutex stands for mutual context, is used to avoid data racing. Data racing happends when when many goroutine try to modify the same data. We use mutex to lock the data from being changed, after done processing data, we unlock it. But it is not important. The channel is what you should pay attention to. Wish you luck :D
If you just want to exploit Kahoot from your phone, this would be the easiest method: 1. Get a shell at Digitalocean (or wherever). 2. Install an SSH client on your phone. 3. Run the code on the remote VPS. 4. Ruin somebody's day.
Now for less hacky daemonization...
What's over doing it by using stdlib to something?
Yes it's not CSV it's a TSV, not drastically different. But CSV spec varies wildly, this is gos selection of CSV spec. 
Despite their similar names TSV is not CSV-with-tabs.
just guessing but that url may have an error theres a space (or `+`) `%20` and then `style= ""` so maybe the url is not 100%; maybe its doing "GET /&lt;img src=foo.png style=blah" (invalid http)
I would love that, the file I am parsing are huge.
why do people not check if their pointer receiver is nil? https://play.golang.org/p/2gs7JLoU0r my rule is...any pointer in Go passed to a public function can be nil and has to be checked...even receivers
If only there was a way to solve this problem. If only we had a program that could do static analysis of our code. Maybe something that checks that types are correct... 
Right, IF you have a csv file and he DOES NOT have a csv file. He has a tab delimited file. I know that because he said he has a tab delimited file. I'm not really sure why you think he has a csv file. With csv files and code to deal with them typically quotes have meaning so if you try to use csv code on non-csv data you wind up with EXACTLY the problem he desccribes.
Only due to unfortunate design choices
but then why check any pointers? why not just panic on every kind of nil pointer? screw unit tests, we'll do it live! and what do you mean "allocate something on the spot"? that makes no sense in this case my point is...the receiver pointer is not special....it's just another pointer....not sure why it gets a pass on being checked but other arg pointers should be checked? a nil receiver is an error like any other. not sure about you, but when I write a public api, I think it is my duty to be "paranoid" not sure why I am getting downvotes, I am only showing you a consequence of Go's reflection capabilities (type affinity is sticky)
Like I said "The `delimiter` is irrelevant.". In this case none of the values are quoted, because they don't need to be; the quotes are part of the value.
There is no such thing as a specification. There exist various conflicting specifications for CSV by various companies and vendors, but that's about it. Given that mess, `encoding/csv` does a pretty good job. Sorry it doesn't quite match your requirements.
The way I see it is that you should check pointers where something could be nil. If it shouldn't be nil but is, it's a bug, not an error, and it might as well panic. Tests can help you detect these scenarios, and you can just as easily detect if something panics in a test. As a result, you should document where nil is allowed and probably make a note that it's not allowed unless stated otherwise. And no, the receiver isn't special, but I'd argue there are situations where checking if it's nil will only tell you one thing: your program is hosed and you should panic. A nil receiver is an error, but that error might just be the program panicking because you did something it can't handle. When it comes to public APIs, I don't think it's my duty to do anything other than what the documentation says or provides as acceptable use. If I don't say nil is a valid receiver, then I feel the implication is that nil isn't a valid receiver. When you do something outside those bounds, it's on you if it fails somehow. As for downvotes, I didn't downvote your comments (or anyone else's), but I would guess it's partly that your tone — I know, it's text — comes across as pretty negative and condescending (i.e., "why do people not…" can feel like "I assume you do this, you're wrong, and I'm right"), and partly that your stance on this probably isn't popular (hence why I've disagreed with it). I'm sure someone else who actually downvoted you can comment on why, if they want to.
By refresh you mean the "Refresh now" link at the bottom?
If you are going to take a quote, then also make sure you include the actual point of that quote which was *if it shouldn't be nil but is, it's a bug*. 
I don't understand the logging bit. Perhaps the author can chime in? What exactly is so wrong with using log.Printf()...? Why make a Logger object a field of foo? Wouldn't that just make your foo struct unnecessarily huge, and is rather reminiscent of java style programming?
From my experience: sometime I want to log different module into different files. Pass in logger instance can easily achieve that. Also in case you want to do test and don't care logging, you can pass in logger which direct to /dev/null.
Better yet, why doesn't Go allow me to declare a pointer type that can't be nil?
that's an idea I hadn't considered (logging different packages into different files...). In fact I'm gonna adopt that.. that's simply a fantastic idea.
That's actually pretty clever ...
No. They're a bad practice, as explained well by others in this thread.
you probably forgot to upload some files. ./main.go:51: undefined: setLanguagePreference
Right, none of the values are quoted. Because it is a tab delimited file and not a tsv file. Therefore strings.Split is NOT absolutely the wrong thing to do. That is why I suggested it. 
wow. You literally rewrote all my code XD. Clearly have a lot more to learn. Thanks for the tips. I did end up seeing/solving the deckOne problem were it resets it. Wow, thanks man
any uninitialized or wrongly initialized variable is a bug...what is the difference between the pointer receiver and a parameter? indeed, the pointer receiver *is* a parameter, just one with a different syntax....in any other language it would be "this" or "self" etc
no, the other coders looked at my original sample and were genuinely surprised that a nil pointer could reference methods, so everyone is downvoting because their ninja rockstar status was temporarily threatened
What do you mean four types for each suit? Do you want four of each card? The loop in this code will get you one of each number for each suit. And, while it's possible your shuffle might shuffle a card into the same space it was in before, that also happens when you shuffle a deck in real life.
No. // Perform the following block for each of "Spades", "Hearts", etc. for _, suit := range []string{"Spades", "Hearts", "Diamons", "Cloves"} { // Perform the following block for each of "Two", "Three", etc. for idx, name := range []string{"Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King", "Ace"} { // Will loop through in this order: // "Spades" - "Two", "Spades" - "Three" . . . "Hearts" - "Two", "Hearts" - "Three" etc. deck = append(deck, Card{name, suit, idx + 2}) } } also it's not my code If you need further convincing, go to the play link that the code-writer gave you and run that. It prints out the deck for you, and you can check it isn't missing any cards.
The two suggestions above are good. If you can't change the JSON, there's one more way: unpack twice. The first time you unpack into a struct type that just has one field, Command, and then switch on that and unpack again. This works because the json.Unmarshal ignores fields which aren't present in both the JSON and the target type. 
I think the next couple of releases should bring improvements to compiler speed.
are you stupid? do you honestly think that's a good argument?
you're getting downvoted because you're ~~dumb~~ wrong. edit: wording
rms would not approve.
Don't tools like Supervisord or Systemd or Upstart or Runit, etc. provide everything needed? Seriously asking, I feel like I'm missing something.
They do and can. It just feels like it goes against the Go way. Let's introduce a Python dependency for Supervisord to run our Go binary. That's just my two cents. 
&gt; // dbud: only set seed once. What does "dbud" mean here?
See the article: https://blog.golang.org/profiling-go-programs and instead of profiling main, profile what you need. Also you could write benchmarks and run them only for that function.
https://golang.org/pkg/runtime/pprof/#StartCPUProfile &gt; StartCPUProfile enables CPU profiling for the current process. As I understand it, no matter where you start it you will still get CPU profiling from other running goroutines. Edit: also this is for live profiling, so sadly the benchmark approach does not fit my case.
With the default settings, 105,049 domains are currently blocked (same lists as pi-hole). The biggest difference from pi-hole is easy deployment anywhere, concurrent queries allowing for very fast question handling time, and much lower hardware requirements (under 15mb of ram is needed for 105,049 domains).
Neat. I'll give it a spin once I get home...
&gt; If it is nil but you don't dereference it, you are fine. To me that sounds like a reasonable argument *for* the explicit check. First, why even have it as a member function if you aren't using it. It might fit a situation where you might possibly dereference it but don't that time depending on the parameters. Or if it's an interface and on this particular implementation tge receiver isn't used. In that case it would probably be good to have the explicit check since the code is in a state it shouldn't be, calling a method on a nil object. I can't think of a reason why your code should blindly continue since something has gone horribly wrong.
That sounds impressive! What was the message (payload size) for that? And do you have comparable numbers for the Akka and Akka.NET implementations? I guess the implementation currently uses a single gRPC stream (and thereby a single HTTP/2 stream and a single TCP stream) - is that correct? I guess that could be really fast, but probably depends a little bit on when gRPC writes/flushes everything into the HTTP/2 stream (once for every message (stream object) that you write or waiting for multiple objects before flushing). I guess that would make quite some difference for latency and throughput. Another thing that comes to my mind is whether this protocol should be scoped to the Go implementation only or if it can be interoperable with the other implementations. I personally like protocols that can be used from any programming language because it doesn't tie the whole system to one. But I guess for the presented use-case there are also already a lot of other messaging protocols if someone wants interoperability.
Code review: 1. Should have run gofmt on it first. 2. Also, it should be Go, not a rap video. Otherwise, LGTM. -jeff
Libraries using log.Printf are incredibly tough to work with in a production environment if you want anything more interesting than looking at stderr. Libraries that let you provide a logger API at time of construction are better than log.Printf, but they still fail at letting you include contextual information inside method calls. We inject a logging interface into all our methods that take a context.Context object [1]. This allows us to push contextual information onto the stack of context objects, and then when we log we can do it at the point of failure and have access to an immense amount of useful information. Check the attached gist to see an example of how this works in practice [2]. Given that the context library originated out of Google and is now part of the stdlib in 1.7, I would love to see other libraries embrace it instead of relying on much less flexible solutions. [1] https://godoc.org/golang.org/x/net/context [2] https://gist.github.com/justonia/f81eead323d2b23eca1c485ed8e5db5d
Interfaces are implemented as methods on a type. Sometimes the method receiver just doesn't matter. Besides that, the fact that methods can be called on nil values is documented and (ostensibly) intentional in the language. You are free to defend against it (and pollute your API with otherwise-unneeded errors), but it might be surprising to users who are actually versed in the language.
As the other person replied, it is usually immediate. Relax, I'm not complaining, I was looking for help when I posted this.
Go's CSV package isn't a general-purpose delimited data reader; it's specifically a CSV reader. If you have a tab-delimited file with no tab characters in the data, you can just use `strings.Split`to get the individual fields. If the values have quotes, you might find that `strconv.Unquote` solves that problem.
I've updated the README - https://github.com/dolftax/summer/blob/master/README.md . Hope that helps! 
Don't use binary-only packages? It's really that simple. The new changes in the go tool aren't really meant for wide consumption anyway. They only exist to prevent a particular kind of less-clueful companies from committing much worse abominations in their quest for protecting the world from their source code.
Post includes a discussion on how Server Push is implemented, as well as application considerations and implementation API considerations.
I used gocui https://github.com/jroimartin/gocui/ for a little porject : https://github.com/gophersiesta/gophersiesta/blob/master/gui/root.go Very easy to work with
In theory, [runtime/trace](https://golang.org/pkg/runtime/trace/) *might* help you, though you probably have to force it a bit to give you useful information. This might get you an execution trace, which is pretty much as useful as a profile. Or it might not, I haven't looked at what *exactly* they log. Apart from that you could manually instrument your code to do request-scoped tracing. It's not very hard to do in principle, it's somewhat harder to do in practice (though totally doable) and you will incur a performance-impact even if you don't trace. A profile, as in pprof, you can't request-scope, unless you could somehow force the runtime to only execute the code belonging to this particular request and stop everything else. I don't think that's realistic.
In my experience, it's more likely I will find the libraries I want don't exist and I need to write them myself, or use bindings to C. 
Go CUI is a wrapper around https://godoc.org/github.com/nsf/termbox-go. Depending on the project it may also be suitable for this todo app by itself.
This is pretty cool. Hoping that /x/net/http2 gets this functionality flushed out a bit more. I have plans that could definitely use it.
This works on multiple platforms (Linux, Windows, OSX): https://github.com/peterh/liner 
Same here. I've been using it for dead simple networking/concurrent projects that aren't too complex, but I've been using other languages for other tools.
This is true. One can use the `trait` and `interface` keywords almost interchangably; explicit traits are there to prevent accidental interfaces (and for programmer preference).
How do you know which Java libraries are "production ready", how do you tell for Ruby or JavaScript packages? How do you mitigate the mentioned risks in C/C++, Java, Lua, Node, Ruby, Clojure, Haskell, Cobol or FORTRAN?
Because the push promise needs to provide a synthesized request to the client, shouldn't you be accepting a *http.Request in an API so that you can push the following? GET /assets/style-b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c.css If-None-Match: b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c 304 Not Modified ETag: b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c
Nice idea, but I think that this could be used in a wrong way due to lack of knowledge and/or laziness; so with that in mind, allow me to make a few remarks: - Per default I think it would be better to listen only on localhost. - At least show a big scary warning if it is started as root. - Show a warning if "root" option is set outside of user home directory. As a "nice to have", you could enforce some sort of auth flow in any of these cases and (_optionally_) skip auth process if the application is running: only on localhost, not under root user and the `root` option is set inside user's home directory. Also, under "nice to have", you could implement a white list, where each user can define what files should be accessible.
Sorry, can you clarify? So instead of pushing just a URL via the Link header, providing an API to push a *http.Request? To provide more control over the headers being pushed? EDIT: If so, then yes but perhaps not a *http.Request but instead a simper struct such as: type Promise struct { Path string Header http.Header } 
Yeah, because with the current API pushing a 304 is impossible. I think you should use an interface with type assertions, and implement methods on the ResponseWriter. if pusher, ok := w.(http2.Pusher); ok { pusher.Push("/style/foo.css") headers := ... pusher.PushWithHeaders("/whatever", headers) } edit: and make it clear that you accept the special :status etc http2 headers 
Great article, loved it especially the gopher cheering squad! Initially, I played around with Go, but I couldn't get used to it and its package quirks. So I left it. Recently, I came back to Go for a second look, and now I'm really enjoying coding with Golang.
As of version 1.0.2, grimd supports easy integration with external services such as criticalstack.
LGTM. I will add these to the issues. You may file any feature requests and nice to have's https://github.com/dolftax/summer 
Because it's Go and not kids hacking around on npm in their spare time. You can characterize Go code as ruthlessly efficient and explicit. Read the source code of the libraries you're interested in, there's literally no better way. 
Not to mention there's nothing in the definition of GC that would require compaction. Did anyone ever have problems due to Go's GC being non-compacting?
Thanks for the advice and kind words. I took some beginner/intermediate Java in Junior College, as well as a beginner C++ course. They were not very rigorous...so I feel like I did not learn a lot from the course (Although I know programming is a lot about devoting free-time and not just for school assignments, which is why I say I have little to no experience). Would you suggest taking the C, C++, or Java route? Apparently Go is C based? From what I read, at least. I hear either three are all good starters but it's a mixed opinion, just would like to hear yours.
C is a great language for developing an understanding of what the machine is actually doing, without all the conveniences of a more "modern" language. I don't believe you can truly appreciate or understand higher-level languages until you know the things they are trying to hide from you.
The angle brackets are just a piece of syntax (familiar to C# / Java / ... users), I didn't want to invent new syntax for go. As functions take parameters, generic types take "type parameters". So this just means"Type Array parameterized by type int" (and in context of array, it should be quite obvious what the type parameter means; of course, type of the items). So we once define an array that is parameterized by the type that it will contain, that type is known [and fixed] at compile-time, and efficient code can be generated - for example Array&lt;int&gt; will contain unboxed integers. And then we can say we want an Array&lt;ofWhateverType&gt;, and we get a fast &amp; type-safe array (type-safe in that - without some dangerous casts - the compiler won't allow us to stick other type in, or let us try to pull some other type out ...) Edit/Addition: if the parameterized type also defines some [type-parameterized] methods, they'll have correct signatures. If implementation details allow it, the compiler can generate just a method per "size of the parameter" &amp; one for reference types, so we don't even need to pay full price in code size. I like generics because they allow to clearly express intent to create or use a generic abstraction. Go already has generic arrays, maps &amp; channels (enumerators / observables), so the most painful points are covered, but still, sometimes, they would come handy. Check out generics in Eiffel, Haskell or Scala for examples of how great they are when well integrated.
Also, check the documentation. I find that documentation quality is a good indicator of code quality.
I think Go as a first language is definitely possible if your a cs major. I decided to teach myself Go by building a side project, and it just came down to practicing the syntax. I wrote a short post [learning golang](http://www.tysonmaly.com/programming/go/learning-golang/) on the resources I found most useful for those getting started in Go. 
its a golang subreddit, I figured everyone uses godoc.
Cxx definitely makes learning Go easier, but Go's syntax/# of keywords is easy to get into your memory, it has a great community, it's type-safe, and it has a standard library you can do a lot with, so I think Go would be a great first language to learn
Go is not C-based, but the look of Go is very similar to C, so people sometimes say that Go is a "modernized" C, although technically speaking they are not related. My opinion is to start with Go out of those languages. The modernizations in Go are nice: no mandatory semicolons, easier to understand error messages, syntax is less weird and has fewer traps (like mandatory semicolons and braceless if statements). Learning Go will make it possible for you to learn the other languages more quickly when you get around to it. "Oh, `class` is just like `struct` but for Java and blah blah blah…" etc.
Reworked the whole project, it is fully functional now. Added travis, tests and other good stuff Check it out! Alot of examples in the Readme
Dave Cheney has a blog post from about a month ago: http://dave.cheney.net/2016/04/02/go-1-7-toolchain-improvements I haven't tested, but I believe performance improvements (of compiled binaries) are even greater than that chart shows - that data was from the beginning of March, and I've been seeing commits &amp; issues to fix some outlying performance regressions since then.
I wrote an article about that: http://eagain.net/articles/go-dynamic-json/ Also likely useful: https://whispering-gophers.appspot.com/
This doesn't seem to provide the security properties of html/template. Just calling https://golang.org/pkg/html/template/#HTMLEscape is not good enough.
Insecure, allows access to the whole file system: https://github.com/dolftax/summer/blob/a6074d81de39c6e4a1ba00db4a5d27ab9fcbf3e7/utils.go#L11 (well, that might depend on how net/http cleans the url path, but that's scary to rely on)
See also, N. Wirth's Compiler Construction, version for Oberon, which is a next gen of pascal-like language. According to the fact that Go is similar to Oberon in some way :) this book should give you much more profit https://www.inf.ethz.ch/personal/wirth/CompilerConstruction/index.html
Those changes are in tip, so http.Request is likely to make it in unless it gets reverted out for a release (not sure why it would). Don't think http.Response has a context associated with it, I don't imagine it needs one.
I don't think we are on the same page here, but that is Ok. Let me clarify, a client package can not understand when/how my application ends, so can not *handle* it for me. Can you please elaborate which ones you mean by "a lot of them"? Because the ones i use daily does not. For example, Redis Client has https://godoc.org/github.com/garyburd/redigo/redis#Pool.Close Cassandra Driver has https://godoc.org/github.com/gocql/gocql#Conn.Close RabbitMQ Driver has https://godoc.org/github.com/streadway/amqp#Connection.Close They have them for you to call them when you dont need a connection to the remote resource(s). And if you don't free these by closing long running connection resources, they are leaked.
Ah I guess I used the word incorrectly, was more thinking along the lines of similar to C. Okay, so far it looks like diving straight into Go or C seems the most popular
Cool. Yeah general consensus I'm getting is that it's a good first language but knowing C, so to understand the machine, would be a lot better.
I thought the article was interesting and well-written; it's cool that Go's programming model is already influencing the JVM world. 
Heh yeah I am indeed full of analogies. I think I was Doctor McCoy in a past life. 
I have never seen Star Trek but I am going to assume he was a man full of analogies? haha
I am new into programming world, i have basic awareness of html css and i am learning javascript. So should i go with go programming after javascript along with php ?
Unless you run the executable as superuser (Which you do only when you are sure what you are doing), the executable will inherit the current user's permissions. IMO, It is always better to restrict access in system level over application level.
Can't say I've needed this in the 2 years I used Go but I feel like today the best solution would be to use go generate to automatically build your data structures.
You can still use input/output pairs and iteration, the fact that you use a library to assert isn't going to change that. Different types of assertions can take different amounts of code and setup to handle, the library (testify in this case) just provides them pre-made (kind'a the point of a lib right?).
ditto, but I'm ok with toolkits, *if* the value is there. This one seems to provide some routing tools and contextual state handling for requests, as well as static file handling and mongodb shortcuts... Whether that's enough for someone to use it over the std lib... well, that's up to them I guess. To me this is a very narrow target base (especially with the assumed inclusion of mongodb code).
&gt; I guess the implementation currently uses a single gRPC stream (and thereby a single HTTP/2 stream and a single TCP stream) - is that correct? I guess that could be really fast, but probably depends a little bit on when gRPC writes/flushes everything into the HTTP/2 stream (once for every message (stream object) that you write or waiting for multiple objects before flushing). I guess that would make quite some difference for latency and throughput. &gt; Another thing that comes to my mind is whether this protocol should be scoped to the Go implementation only or if it can be interoperable with the other implementations. I personally like protocols that can be used from any programming language because it doesn't tie the whole system to one. But I guess for the presented use-case there are also already a lot of other messaging protocols if someone wants interoperability. That is actually spot on why I started fiddling with this. There is nothing Go specific in this implementation. I do plan to port all this to .NET Core, I blogged about some lessons learned when making Akka.NET https://rogeralsing.com/2016/03/13/random-things-learned-building-akka-net-part-1/ So by using gRPC and Protobuf, this could be built on a number of different platforms, and everything would be interopable. Regarding latency and throughput, the example I'm using for benchmarking right now does favor throughput over latency, and batches messages in stacks up to 1000 messages at a time (less if the endpoint writer actor starts to run before the batch is full) I'm currently researching what the best default would be, in terms of throughput vs latency.
Nah, it recently got updated to: http://invite.slack.golangbridge.org
This is the most anticipated thing for me as a web developer..
I'm really looking forward to the next installment. 
Thanks for pointing that out! I definitely missed that, damn. It's fixed in the next release!
I find it a difficult theoretical exercise to include some third party code, I started out with Django and I was flabbergasted at their few month new version release cycle. when I have my startup I had promised myself that I'll write my own framework or write from a language and not use a framework.. that is when I had come across Go, and it was a life saver, no need to constrain yourself to the framework, write code in language directly without any framework
Nice write up, thanks!
This is some nice work - but I kind of wish the yahoo finance stuff was split out from the representation of the financial data.
PHP and JS are nice entry points into programming because they give you quick feedback. Be aware though that they have bad reputations with professional programmers because they tend to be conducive to bad habits. As long as you move beyond them someday, they're great to get your feet wet. 
That's a pretty cool idea.
Do you might explaining why/how you could determine that? trying to learn coming from languages with higher level of abstraction (python, JS, etc). 
I did a quick read at what FITS is, and as a hobbyist astronomer I was wondering what was available to shoot images like that and the practicality of it. I found a bit on "Amateur Astronomical Spectrographs" which perked my interest, but curious if you have any quick insights, again, for a hobbyist :)
I've been using https://github.com/gdamore/tcell. Seems nice. It's still in development though. ... Looking at the termbox-go code made me feel a little icky...
Defense in depth is better. For example, safely adding TLS support gets tricky; the app needs to read the private key.
FITS (https://en.wikipedia.org/wiki/FITS) is a standard data file format for storing data in astrophysics, astronomy and cosmology. I actually don't know whether there are telescopes targeted at hobbyist astronomers which can readily produce images in that format. As FITS is the de facto standard in astro/cosmo, there are many s/w stacks and tools that deal with it: this allows for readily available tools to massage and post-process these images. (I suppose the main s/w stacks are IRAF and astropy.) I am sorry I can't be of more help than that, not being myself a hobbyist astronomer :)
and now, you can directly do: $ go get github.com/astrogo/fitsio/cmd/view-fits $ view-fits http://data.astropy.org/tutorials/FITS-images/HorseHead.fits enjoy :)
&gt; go get github.com/astrogo/fitsio/cmd/view-fits you should vendor shiny (because I'm lazy) ;P mpl@yggdrasil:~$ go get github.com/astrogo/fitsio/cmd/view-fits # golang.org/x/exp/shiny/driver/x11driver src/golang.org/x/exp/shiny/driver/x11driver/screen.go:356: cannot use int32(width) (type int32) as type uint16 in argument to xproto.CreateWindow src/golang.org/x/exp/shiny/driver/x11driver/screen.go:356: cannot use int32(height) (type int32) as type uint16 in argument to xproto.CreateWindow 
Context please :D
He means Java is the language used on the Enterprise. I'm sure every Star Wars fan would agree.
yeah, you have an out dated version of shiny (like 6 months-ish). I think i may have even been the one to submit the CL to fix that. Vendoring for an app is good too though.
You might want to check out Google's context package as a good reference design for this sort of thing. Also in your fix, you should wrap all your unlocks in defer and immediately after the lock as a general good practice. Cool work though man glad to see you having fun with it. 
I froze my GoSublime a few weeks back. An update was pushed that broke intellisense and the import window. So I reverted to a previous commit and froze it. 
Yup, I switched to Atom (https://atom.io/) with go-plus (https://atom.io/packages/go-plus). Been very happy with it so far. 
For game engnes, Rust could be the better option than Go and Scala. It's compiled to native machine code and equipped with granular control of memory and as powerful type system as Scala.
One of the common problems I encounter when testing web applications, after learning about the utility of interfaces, is that many popular frameworks and setups don't implement their own interfaces - instead they write giant structs with many pointer receiver methods. This is very nice for the actual implementation, but makes testing harder. A common solution to this is to inject your own interfaces to your methods/functions, and compose them of existing interfaces when necessary. For example, the Gin-gonic/gin library has handlers that expect a pointer to a Context, which is a struct rather than an interface. Instead of writing your handlers to accept a Context, make them accept an interface, one containing the methods of the context that you'll be using. For the real server, the context will implement the interface, and for your tests, you'd create a mock context that implements that interface. If you use the data on the context, and not just the methods, you simply add that data to the mock. This is just one example, but I find that it embodies the general pattern: make your methods accept interfaces, and it makes them easier to test. For integration tests, take a look at http test.RespinseRecorder, and the other parts of that package. Good luck!
I would recommend to switch to atom or even liteide 
Huge recommend for vscode. I switched from _years_ of using GoSublime. Sublime was a bit more snappy, but the tooling in vscode is _so_much_better_. 
i organize handlers in controllers. controllers are structs which accept dependencies (like db Database). handlers are methods on controller receivers i recommend this article which explains different approaches to organizing db access, if you haven't came across. http://www.alexedwards.net/blog/organising-database-access
maps are not thread safe. But now, he fixed it with a mutex.
I put this small library together as I couldn't really find anything available that had what I wanted. Any feedback is most welcome!
Are there optimizations here that can be pushed into the std lib? That would be gnarly.
+1 here. net/context is really good thing. Unfortunately, http.Request is struct :-( If it were interface, it will be easier to add context to.
Hahahaha dam sorry to hear. I can't say I know how you feel...just...good luck? haha. I never worked without an IDE and yeah javadoc is a pain to have to do(although I do understand documentation is important). Thanks for sharing your experience, I really appreciate it
Interesting, that makes a lot of sense. Never heard of this theory but yeah can see it definitely applying to programming. Thanks for replying. This sub has been really helpful/vocal haha
Twitter
golang-nuts
Go Newsletter http://golangweekly.com/
[Go Newsletter](http://golangweekly.com)
[GitHub issues](https://github.com/golang/go/issues)
What I usually do is, to a) have a context for request-scoped data (e.g. session and transaction) and don't care about compile-time type-safety. It's usually not a huge problem and very simple to test, so who really cares, in practice? And b) make a struct that contains all the state the server needs to hold and then use that to mock out logger and databases in tests. As long as you don't actually use any global variables, that's very simple to test because you get whatever level of isolation you wish in your tests. So I would use the closure-pattern for request-scoped data (but pass a context around where the state is actually exposed) and the struct-pattern for all state that needs to survive requests (and try to minimize that. Stateless HTTP-Servers are much better in any regard).
http://golangshow.com/ - russian podcast
This is probably the way that would make the most sense to me, it sounds similar to the "env struct" pattern I've seen a few places, including in other comments here. I think you could probably take this a bit further and make it a bit more modular by treating the structs you assign dependencies to as if they were controllers. Cheers!
Yes, I don't count "connections to other services" as real state. You *could* reconnect on every request or when your process/server/harddisk/whatever dies, so it's merely a performance-optimization to have one connection overall, it has no effect on correctness. So my habbit is to put a long-living connection into the struct and have a per-request transaction which I save in the context.
You're right, every context leaks, but it's fixed now. I don't know what happened maybe I was overexcited so I forgot how to program xD. I thought about breaking compatibility by introducing my own ResponseWriter interface and Request wrapping the ones of the standard library, but I was unsure about that. I could easily eliminate the global context map with a custom Request. Also a custom ResponseWriter would allow me to add the global functions right to it, e.g w.WriteJSON(...).
Go uses so called a goroutines (coroutine), which allow you to program concurrent applications, which - depending on your CPU - may run things in parallel. While parallel read access to shared memory is no problem, parallel read and write access is. Go's net/http package creates a new goroutine for each incoming request, that means while handlers of other request access their RequestContext from the global map a new request may also create a new RequestContext in parallel, hence parallel read/write access to the global map. The thing that could happen is, that the map's internal structure is modified while others still try to read it. This could then crash the program. To prevent such things you must synchronise the access to the global map using a mutex. https://en.wikipedia.org/wiki/Lock_(computer_science)
Cool, that makes a lot of sense. Thanks again!
Reddit and golangweekly for blog posts, gloang-nuts for community questions, golang-dev for dev cycle updates, and gerrit to see what's new/pending for tip :)
Reddit
Thanks!! I had read that maps were not thread safe, but your explanation helped clear up a lot about why you were using a map and cleared up more about the context map that I had never fully understood. Very much appreciated!!
Subscribing to new CL notifications in areas of interest at https://go-review.googlesource.com
Reddit
I know about the Go channel on Freenode IRC, but what Slack server/channels are you using?
Use gofmt.
Some ideas here: https://gist.github.com/Redundancy/89a5f490062fec3c84a0a4d0b1f9b05f I removed the file manipulation from the main function to help make it testable, removed the multiple passes through the source file to reduce the length and complexity, brought in some buffers and TeeReader to make appending he original content easier (just a copy) and rely much more on io.WriterTo. The boolean variable is gone, replaced by just checking for an empty title, and that logic is moved into the title type, reducing the complexity of the main function. Some redundant assignments are gone. I've changed the order to put the most important functions at the top and tried to make writeToc as readable as possible. Some of the functionality has probably changed slightly, but it's hopefully fairly close to the original.
Reddit
Go generate is explicitly for library authors, and you can't generate code for types you don't know ahead of time.
from the default settings' comments, it looks like you'd need to quote-and-comma separate each arg; something more like `["reset", "&amp;&amp;", "go", "run", "$_fn"]`: // what 9o command to run when (super or )ctrl+dot,ctrl+b us pressed // e.g. ["go", "build"] // the 9o command ^1 recalls the last command you ran manually // see 9o help(ctrl+9 "help") for more details about what commands are supported "build_command": ["^1"], 9o.md doesn't list anything about supporting `&amp;&amp;` or `reset` though, so not sure if even that'll work. You might need to make your own build system, eg. mine is: { "cmd": "go run $file", "file_regex": "^[ ]*File \"(...*?)\", line ([0-9]*)", "selector": "source.go", "shell": "true", "variants": [ {"name": "Go Test", "cmd": "go test $file"}, {"name": "Go Build", "cmd": "go build $file"} ] } the cmd arguments there should support anything your OS' default shell does.
Some people refer to any form of autocompletion that way.
https://forum.golangbridge.org/
Pretty cool! I messed around with rumprun a few times. I didn't try running any kind of substantial service, but I did encounter two problems: 1) Building everything was a pain, I think that Docker is probably a good idea here if it reduces how annoying that is. What I wanted was a version you could run on your Mac desktop that required no building whatsoever. You could just download some program like UniK, already compiled and ready to go (maybe a homebrew "bottle"?), and instantly compile your Go apps into unikernels. Ideally that means no make, no docker, no go, just unik. 2) I wanted to run it on GCE, I got a f1-micro instance to work with a DHCP hack, but there seemed to be some issue with my mac build tools, so a version compiled on the mac never quite seemed to work correctly (might have been the hacked together grub + xorriso I was using to build the image instead of grub-mkrescue). Here are a couple of hacks to get rumprun to work on GCE and compile on mac: https://github.com/goroutines/rumprun/commit/94c587dba9eff3d823a9694f7583003459b7b055 My reasoning for trying to get #1 and #2 working was that if unikernels could offer a really nice development experience, there might be a more tangible reason to use them instead of the old fashioned SSH into a Linux computer method.
https://golangnews.com/
The title is the link...
This is great. I've already used this 3 times in the last hour or so!
Thanks for explaining 
Discord also does audio which can be useful while you're busy typing out code. Optimise :D
Reddit
I'm new to Go. I'm curious about this gob thing, can you tell me more about it? Perhaps you happen to know of some links that introduce the usage of gob?
yeah... I suppose vendoring an x/exp(erimental) package is the right option, but I am lazy too :) (and as shiny is more or less the only external dependency of view-fits that I don't control, I prefer to have my code to always compile with a quick "go get -u" incantation)
I wish someone made a firefox extension. There was talk about doing so in 2014 but nothing since then. https://github.com/sourcegraph/sourcegraph.com/issues/168
It has linear regression via Solve, but that's it. I agree it should have more detailed fitting algorithms. mathext can still be in flux, the discussion was that it should be broken up. Feel free to comment if you have good reasoning. https://groups.google.com/forum/#!topic/gonum-dev/Peu9M-j0O7w I'm not sure I agree on the matrix functions. Of course it would be nice if they didn't allocate. In my opinion it's really nice that input matrices aren't modified rather than needing to memorize which functions modify and which don't. Frequently this requires an allocation and a copy, which I think has less cost than the potential errors otherwise. We try to mitigate this with an allocation pool, and the user can frequently mitigate this by having independent receivers. Of course, if there are unnecessary allocations you see then file a bug/PR. Spline code would be appreciated, just make sure you open a discussion on gonum-dev first. We haven't figured out how all of the fitting stuff should work yet.
I also like autocompletion better 
One tip: instead of doing // Queue is Empty. func (err *EmptyQueueError) Error() string { return "Queue is Empty" } you can use the `errors` package, e.g. var ErrorEmptyQueue = errors.New("goqueue: queue is empty")
I learned C a long time ago. I have to say its still one of the fastest languages out there without counting hand coded assembly. But Go has a nice standard library that give you a lot more higher level abstractions, so your productivity is higher as a developer. 
Aahh, it all makes sense now. So I guess when you do a byte() on a uint64 it just takes the most right 8 bits from the whole number,is that correct?
From this post it looks like Heka is no longer developed or supported. Unless some person/org jumps in to fix code, the project is abandoned due to longstanding performance issues. Channels seems to be main culprit for this situation.
Annnndddd Atom just broke...on to the next one!
Almost certainly https://github.com/golang/proposal/blob/master/design/12416-cgo-pointers.md
Does that link throw a 404 for anyone else?
No; but knowing Google Groups it wouldn't surprise me. Here's the non-mobile version: https://groups.google.com/forum/#!topic/golang-dev/n-D2RYU4nIs
Yes this. 
Between Australia and US you can't be faster than the speed of light...
Looking at RFC4642 (https://tools.ietf.org/html/rfc4642) it says: &gt; 2.2. STARTTLS Command &gt; &gt; 2.2.1. Usage &gt; &gt; This command MUST NOT be pipelined. &gt; &gt; Syntax &gt; STARTTLS &gt; &gt; Responses &gt; &gt; 382 Continue with TLS negotiation &gt; 502 Command unavailable [1] &gt; 580 Can not initiate TLS negotiation &gt; &gt; [1] If a TLS layer is already active, or if authentication has &gt; occurred, STARTTLS is not a valid command (see Section 2.2.2). ... &gt; A server MUST NOT return the STARTTLS &gt; capability label in response to a CAPABILITIES command received after &gt; a TLS handshake has completed, and a server MUST respond with a 502 &gt; response code if a STARTTLS command is received while a TLS session &gt; is already active. It seems like you are trying to handshake on TLS connection that has already been established. Make sure that you check the server's capabilities response before you call STARTTLS. 
Why would I use this over https://github.com/codegangsta/cli, https://github.com/spf13/cobra, or https://github.com/mitchellh/cli?
Oh, if there's already been an extended discussion on the pros and con, I'm sure my views have already been brought up. They're not particularly deep. I've looked at the newer call signatures. These are much better than the ones I was used to using. There are still some internal allocations (which are mostly necessary given the call signatures), but it's a vast improvement. Spent some time this afternoon updating a bunch of gross computational geometry code to use the new versions. (And in doing so found out that my cluster was still running Go 1.3 when it crashed while compiling gonum/internal). (Although, to clarify, my problem with the allocations is not performance, it's heap fragmentation.) Yes, some thought definitely needs to be put into these types of interfaces. The spline stuff in particular is currently written with functional options, so it very much needs to changed to be consistent with the way the rest of gonum is written.
Oh, I hadn't realized there was no FFT. At least there are a couple of unaffiliated libraries which provide support for that.
Thanks! I think that's it - an implicit read call invoked a handshake and it's already occurred. Thanks again for the insights!!
up
Hitting an in-process cache I'd guess. :-)
The Heka author is saying that wrong decision was to use Go channels as unbuffered they're slowing down scheduling too much, buffered can lose values. He's also saying that instead of queueing stuff in memory, it's faster to queue them on disk. How come? Can anyone explain?
This is awesome!
I agree that PUT and DELETE are better off easily accessible like GET and POST are. However, these are most within clients for REST services, where it's often needed to initialize an http.Request anyway.
Regarding eigenvalues ... Is there no QR iteration implementation for calculating eigenvalues? This algorithm is the best for this job. It is also used as most robust for finding roots of polynomials - simple compute eigenvalues of companion matrix.
Good point; using stubs for client tests makes sense. I'm not so sure on where to start in generalizing the connection though. Any good doc/examples you know of?
There is an implementation there now, but it is not the fastest or most robust algorithm. As you mention, iterated QR is a good algorithm -- the one lapack uses. Here is the call graph for the algorithm http://www.netlib.org/lapack/explore-html/d9/d8e/group__double_g_eeigen_ga8ec1625302675b981eb34ed024b27a47_cgraph_org.svg As you can see, it is hours and hours of work to implement such an algorithm, especially with tests along the way to ensure correctness.
Is this really a problem? One can just use client.Do() and supply a request with any verb you need. https://godoc.org/net/http#Client.Do 
http://imgur.com/odWr9Qo
&gt; e.GET("/fruits"). Expect(). Status(http.StatusOK).JSON().Array().Empty() Sorry, but this is gross. I think tests should be data-driven, especially http ones - you write table test, you have input / outputs nicely listed and test driver in one place.
You can tell that this is not the right answer, as the behavior of select is defined, whereas the iteration order in a map is undefined. It's an implementation detail of gc, that the iteration order is randomized, other implementations don't need to follow that (they could even choose to iterate over a map in sort-order if they wanted to). Select, on the other hand, must always be random, to prevent starvation.
&gt; the iteration order in a map is undefined. It's deliberately defined to be unpredictable. From Go 1 release notes: "In Go 1, the order in which elements are visited when iterating over a map using a for range statement is defined to be unpredictable, even if the same loop is run multiple times with the same map. Code should not assume that the elements are visited in any particular order." &gt; It's an implementation detail of gc, that the iteration order is randomized It's not an implementation detail of gc. It's a deliberately added randomization. [See line 648 and forward](https://golang.org/src/runtime/hashmap.go) Don't call someone out on "not the right answer" when you don't know yourself.
&gt; False. It's deliberately defined to be unpredictable. Let's look at the [spec](https://golang.org/ref/spec#For_statements), authoritative source for the language definition of go: &gt; The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next. The segment you quoted is specific to the implementations provided by the go team. It's not part of the language spec. [edit: I even think that sentence just means it's defined to be unspecified - unpredictable doesn't mean randomized] &gt; It's not an implementation detail of gc. It's a deliberately added randomization. The two aren't mutually exclusive. &gt; Don't call someone out on "not the right answer" when you don't know what you're talking about. a) I do, and b) the answer is wrong *regardless* of the specification of the iteration order of maps. [edit] To prove my point: [The iteration order of maps in GopherJS is deterministic](http://www.gopherjs.org/playground/#/hBSLA0oGWN). Other implementations can choose any iteration order they like (that's pretty much the benefit of having it undefined)
This is exactly it. It has another benefit - programmers can't rely on the order being top-most-first, which allows for optimizations compiler-side (and other things). This is the same reason why map keys are returned in random order. I should also say this - the most "sensible" approach would be FIFO... Whichever channel had an element "earliest" should be returned first, which would be a deterministic way of preventing starvation. It has the benefit that each channel would be consumed in the order the elements were put in, which would lower worst-case wait time. This solution isn't practical in reality, of course, because tracking that information would slow down channel operations.
Yeah, this is classical "DSL vs config" debate. If your code becomes complicated, you can replace it either with DSL or with config + engine. Config approach is cleaner, while DSL approach provides more power. httpexpect implements a kind of DSL. BTW, I would use something like [pyresttest](https://github.com/svanoort/pyresttest) for data-driven tests for HTTP API. And "JSON().Array().Empty()" is maybe not the best syntax, any suggestions are appreciated :)
&gt; This solution isn't practical in reality, of course, because tracking that information would slow down channel operations. Yes, that was my conclusion also. It's also much more complicated to put into the spec. :)
I agree the syntax feels too much like RSpec from Ruby or something doing BDD tests, however, I think this library is very well done and useful. Perhaps the author can tweak the API a bit to make it more Go-like and show a table-test example too, because these kinds of assertions are very common for JSON apis, and offers good ideas for productivity. We've written something similar internally and its made a world of difference for writing more concise http tests.
@miko5054 got an example? :)
this way more or lees ... :) [MongoDB](https://medium.com/@matryer/production-ready-mongodb-in-go-for-beginners-ef6717a77219#.8rwj3u6ho)
I wrote github.com/anacrolix/sqlrpc that lets you do SQLite over the network
If you're strictly concerned with your main package, then it doesn't matter very much whether all your setup is in an init function or at the beginning of main. For every other package though, it's guaranteed setup that is executed exactly once for the package before any other code in the package is executed. So any package that needs some plumbing hooked up before any calls are made to its public functions should put that plumbing in init.
I filed an [issue](https://github.com/bcicen/go-haproxy/issues/4) on Github to capture the idea and continue the discussion in a place that can be better attributed to the code. 
I do it in this repo https://github.com/go-playground/universal-translator/blob/master/resources/locales/en/main.go it allows a locale to be registered once and only once.
&gt; To prove my point: The iteration order of maps in GopherJS is deterministic. Other implementations can choose any iteration order they like (that's pretty much the benefit of having it undefined) You're attempting to prove your point about go's runtime by showing javascript's runtime?
Should you not put a config.json in your Dockerfile? 
SQL drivers use `init` to register themselves: https://github.com/go-sql-driver/mysql/blob/66312f7fe2678aa0f5ec770f96702f4c4ec5aa8e/driver.go#L165-L167
Am I wrong? But I was under the impression that the init would get executed only once whereas the main would happen everytime ? In the case of a web server, init would make sure that you have the env setup and the main start the execution ?
Instead of using config files, I'd pull config from the environment using a library like [github.com/vrischmann/envconfig](https://github.com/vrischmann/envconfig). You get a couple benefits from doing this: - You don't have to build a new Docker image to change some config - Easier to manage multiple environments - Less likely to accidentally commit sensitive credentials to the repo - Plus [a bunch of other benefits](http://12factor.net/config) It can be a bit annoying to manage a large number of environment variables (and my projects tend to end up with _a lot_), so I use [github.com/joho/godotenv](https://github.com/joho/godotenv) to set environment variables from a file. To make it easier for others to get up and running, I provide a `dev.env` in the repo with some sane defaults (or empty values in cases where you can't give a useful default, like AWS credentials).
If you know HTML/CSS/Javascript well you'll be much happier if you split the application into front-end static files that use Javascript to make requests against a backend API written in Go. Sessions are abominations created to easy the of the transition from pre-HTTP application design to post-HTTP application design. I apologize in advance if it sounds like I'm talking down to you, but please understand that I'm throwing you a role to pull you to a better and more productive development environment.
I'm sorry but clearly you have not bumped into people using init() the wrong way, like this for example: https://play.golang.org/p/XZmc9lNhlz ? Now, I'm happy to improve my Go skills so I look forward on how you'd test sort of situations (without Windows btw). And before you jump up and say but you can split up into OS differentiated files... Yes I know I could do that but that's a stupid example of something. What if in the init() I would have called an API? Or initialized the connection to the database? Or this would be a package that you'd want to use how do you inject your on values for those variables? Yes, there are examples in the standard library and (almost?) all SQL drivers use **init()** to register themselves but those are clear situations where one **knows** what he/she is doing. Which is what I've said in my comment, don't advise to use init() unless you **really** know what you are doing.
init() as well as main() are executed once and only once (caveat for init which can have multiple definitions in the same package in which case each definition will be executed only once). main() is the entrypoint in your app, it gets called in order to start the execution of whatever you want to do, be it a simple CLI app or a more complex server / UI app. Once main exits your program will stop execution. In a webserver, the handlers get executed multiple times, but main will always be executed once (and continue to be executed, else the server will stop). You can read about main and init here: https://golang.org/ref/spec#Package_initialization I hope this clears up the confusion. 
Check out [prometheus.io](https://prometheus.io/).
I have been using https://github.com/apexskier/httpauth for a project and found it to work great. It ties into a http.Handler so works with the standard library and any packages using this interface.
Just a couple of days ago there was announcement from Heka authors that using channels for data pipelines was a mistake: https://www.reddit.com/r/golang/comments/4i6f14/state_and_future_of_heka/ Green threads (no matter how cheap they are) are not substitute for proper system design.
Good job on the app!
I love papertrail. Use it to grab all logs and then you can customize alerts. I use slack to get them.
thank you!
For the writes, why not just append the new slice?
Good idea, will do...
That benchmark pretty much benchmarks the effectiveness of GC under heavy allocations. Fastest implementations use a "non-standard allocator" or alternatively they tweak the GC for this particular purpose. Using go tip makes it 1.5x faster, setting GOGC=800 makes it 1.5x faster. Combining both gives ~2.3x improvement. *Note: measurements on a windows machine.* Using some non-standard allocator could make it even faster.
Go 1.5 binary tree benchmark was somewhat slower than java but became 4x slower than Java in 1.6. Maybe it's a regression.
I haven't looked at goa nor go-swagger but, how do they generate meaningful tests from a swagger spec? 
Note there is a slight difference between a "custom allocator" and a "non-standard allocator". That benchmark disallows "custom", as in specifically designed for that benchmark, allocator. However it is fine to use a non-standard allocator that can be used in other places.
AWS CloudWatch is pretty good.
Totally agreed, I don't get snarklords on Reddit/HN, I just don't see how it's helpful or productive in any way. 
Thanks!! Got it :) 
Yeah, adding `debug.SetGCPercent(800)` at the top of the main gives a speed boost. In fact, I always do that for gc-heavy applications where the total memory usage is not a concern. I think somebody might want to submit it as an improved version.
I think also it might be because the Go GC is geared towards low latency moreso than high throughput.
There are very few places where you need init. By definition, since it has no input or output, it's usefulness is fairly limited. Also, writing tests for it is somewhere between difficult and impossible. And yes, many people misuse init. I don't think you should never use it, but consider it very carefully. It is, by definition, all about global state, which is bad. Main is probably the one place you never need it though, since func main works exactly like init, so why have two?
I totally agree. With docker you can pass the config file with `-v` (or ENV vars with `-e`), and use command line arguments as a way to pass environment configuration. When 12factor.net writes that config should come from the environment, they are not talking about linux environment specifically, just that whatever configuration bundled with the app would not require rebuilding the app on change... Personally I'd go with `namsral/flag` as it provides the `flag` package interface, which imho is simple and powerful enough to be usable. In the long-term, simple worked best for me, if something is broken for some reason - it's easier to replace a simple interface than a complex one.
I stopped using HN because of such people, you won't believe how short sighted these supposedly "smart" people are. They just won't believe in what others are saying, no open mindedness at all. Always being insulting to others who don't think in the same way as they do.
Yes, I am planning to do that today in a few hours, It was a "breakthrough" moment for me to be able to implement sessions in my app :D Any more suggestions? code refactoring? best practices?
go-swagger doesn't at this point, but nothing is stopping you from adding it. The reason it doesn't is that I wanted to make the model generation support all of the swagger first before I got into doing more features. I felt that stability was more important than features. That being said it has pretty much stabilized now, so it could be added by a motivated party.
Okay. I was curious because I'm facing that very question :)
Read the blog post "Error handling and Go" and especially the part "Simplifying repetitive error handling". https://blog.golang.org/error-handling-and-go
it is now https://www.reddit.com/r/golang/comments/4ik37z/goguru_guru_tool_formerly_oracle_plugin_for/
I use init whenever I can for initialization. The problem with init is there is no guarantee on when it will be executed against another packages init.
Good job. Cool project though we are still stuck with SQLite.
Thank you, I have modified the parts you suggested and refactored the code to have some saner error handling. I'll read the link you gave and refactor the code more :)
*"As a practical matter, the [myriad ways](http://benchmarksgame.alioth.debian.org/u64q/binarytrees-description.html#binarytrees) to tune GC will be ignored."* There are one or two ways to tune JVM GC also ;-)
What version of haproxy is expected here? Are you aware of differences in the commands and responses in the haproxy control socket? 
Oh I understand. Then I reckon that the benchmark is not fair and gives an unfair advantage to C and C++.
*iirc* there were a couple of Go binarytrees programs that allocated all the memory at once -- eventually someone noticed and those Go programs were rejected.
where do i go to request an invite?
In that case, tests in the same directory as the code, please!
sorry, no can do; I have a database to write and not enough arms to go around ;)
Your statement is 100% false and completely misses the point of HTTP. I know, because I thought las you did once...and now realize just how wrong I was.
1 minute seems a bit long. Have you checked cpu and mem profile? I'd also look into something like flatbuffers or some of the other serialization formats that I can't remember off the top of my head.
What would you suggest instead?
We use https://getsentry.com at work and like it. 
Looks interesting! I've [added a PR to add Windows support](https://github.com/pinterest/knox/pull/4) to the client and wouldn't mind a code review if anyone feels like having a look. File locking is based on [some code in the go build tool](https://github.com/golang/build/blob/master/cmd/builder/filemutex_windows.go) but may be inadequate or incorrect for this use case. Comments / criticism welcome!
My old work had a node app (from before I was around there) and I had to dig into the memory leak too, iirc it was a few different things: 1) Older version of node had a memory leak with how it handled SSL certs. I think it kept adding redundant ones to the pool. I think the 0.12.X series was the worst 2) Various libs had fairly significant leaks, NewRelic was our #1 culprit. 3) Bad JS, people not knowing scoping and closures had some stuff that was never GC'd
We seem to have some interests, Go and QuadTiles. :-) https://github.com/tmornini/quad-tile-go I'm curious how many GPS coordinates to QuadTiles conversions you can you do per second?
It looks a lot like there is some kind of memory leak in the loop that fetches the user counts from the Slack API. That is the only thing that is continuously running, and since the site had no traffic after we switched, it's likely in there. I'm going to investigate some more when I have time and post a update. PS: If anyone had trouble visiting the past half hour, I accidentally broke something trying to get better logging, and then had to do a restart, which meant some 404s and me frantically trying to fix it for a bit.. Turns out having a test environment is a good idea!
You can now try this live in your browser. http://www.gopherjs.org/playground/#/5NfiqqGZCs (Wait a few seconds for it to load, then press Run.)
Unfortunately as I am writing this under an NDA (what I have said is semi public knowledge) I cannot release source code. No matter how much I would love to do so :P
reminds me of a question at SO back when I started: https://stackoverflow.com/questions/29138591/hiding-nil-values-understanding-why-golang-fails-here
See also: https://npf.io/2014/05/intro-to-go-interfaces/
I don't have a lot of insight, but something like https://github.com/hashicorp/yamux might do it if all your requests are to the same server.
You should propose this to the Go team. The second method is very intuitive.
Quickly stripped from an internal program using forking https://play.golang.org/p/p4dUlOV5ml ... (may need some fixes for the imports and may have made a mistake while extracting the relevant pieces.) There are some bindings https://godoc.org/?q=svn, but not clue how well they work.
it is becoming problematic that this subreddit makes useful discussions disappear, and it is happening more and more when messages don't seem to confirm some community zeitgeist you weren't insulting anyone, you weren't promoting misleading factual assertions...people felt your comment was enough of a conversation starter to repond, so why hide the discussion? when we hide the discussion, we hide the responses, and some of them here have real value
Thank you for the detailed comment :-) I'll make sure this goes into my book! https://github.com/thewhitetulip/web-dev-golang-anti-textbook Now my question comes regarding context, do I really need to use context for finding out which user is the currently logged in one, or shall I, as you said, map the sessionID-&gt; username? 
Haha awesome, I didn't realize OSM had it's own tile scheme. It looks like it's that same as the Quadkeys but with 'ABCD' instead of '0123'. Good call on the benchmarking. I added a few simple benchmarks to the repo and caught some low hanging fruit bottlenecks (removing strconv.Itoa, etc). I add the full results to the bottom of the README in the repo. It looks like it's converting ~4 million/sec all the way to Quadkeys or ~6 m/s if just going to the tile XYZ for a single location at level 18 on a 2.3 GHz core i7 MBP for the microbenchmarking.
Thanks! fixed!
A good workaround is here: export GORACE=history_size=7 https://github.com/golang/go/issues/10661 
Playing devils advocate here... It seems it would be a million times safer just to grab a hash when you freeze it and spin up a goroutine that checks every several seconds if the hash changed. Is this pointer-level granularity worth it?
Yes, that's literally in my first sentence.
great :)
Have your type implement the json.Marshaller interface. The json package will automatically use it. https://golang.org/pkg/encoding/json/#Marshaler
&gt; Shying away from tools because "it can be abused" is a very sad attitude to have. This is precisely the reason I use Go. It foregoes a lot of frequently-abused features (inheritance, exceptions, etc). I favor general tools over specialized tools all else equal, and in the init() case it does seem like all else is equal (though perhaps I'm missing something?).
It's pretty simple. Functional programming:2010s::Object oriented programming:1990s Making things immutable for no reason:2010s::Making all functions into class methods:1990s
I agree with you, but I think your bigger beef is with global state. init() is to global state what constructors are to object state. Testing global state is always a pain in the ass, and init() is no exception.
This kind of thing is typically used when you want to expose internal fields, but don't want callers to be able to modify them. Think final in Java.
I don't think that would be more safe. If some logic relies on the value in a "frozen" variable to remain constant, but it changes in between these checks you propose, this could lead to concurrency issues that are really hard to debug.
But this is only to help the developer, right? Eventually the change will be caught during testing/unit testing. Edit: That wasn't well worded. What I mean is, freezing something is to make sure the user knows not to modify the value, right? So if you poll every few milliseconds (backing off to seconds over time for performance), they'd almost definitely be notified within one of their tests.
Oh good lord, please don't. Randomly panicking in production because deep in some corner case of your code some dev did the Wrong Thing is horrible. It's neat as a proof of concept, but I hope no one ever ever uses this.
Psyched about this, btw. Three kids + hour commute to city = nate doesn't get to a lot of meetups.
If you make a member private and don't expose any setters, it would be a compile error for it to be modified externally.
Agreed. Not even a panic, a hard unrecoverable crash.
Sorry, the README should be more clear on the use case. I absolutely do not recommend using this in production code (it only works on Unix anyway). It's more for testing/debugging.
&gt; Even if you hide your vars in a struct, they are still technically accessible via unsafe.Pointer If clients are willing to use unsafe.Pointer to get around the compiler, then these clients can now just call mprotect to get around this package.
They're calling immutability the current fad in a way that I read as being derogatory.
Thanks for the help. I too couldn't tell if they were being facetious.
Getters are a pain. For example, what if I want to (efficiently) pass around an object like this: type Books []struct { Name string Pages []struct { Number int Words []string } } If I pass the bare slice object, anyone can modify the slice and screw up other reads. If I encapsulate it in an object that exposes a `Book(name string)` getter, that's a slight improvement, but callers can still modify the internal `Pages` slice. So now `Book` has to return a new object with its own `Page(int)` getter. And ditto for `Words`. It's a contrived example, but it's not too far from reality. Alternatively, you could always return a new copy of the object. You'd need to write code to correctly descend into the object, though, and the result could be inefficient depending on your use-case. Of course, I don't recommend that anyone use this package in production (I should have made that more clear in the README). Even though getters are annoying, they provide static guarantees, and they're far saner than mmap'ing a new page for every object. This is more of a proof-of-concept. It was a lot of fun delving into the `reflect` and `runtime` packages and discovering that this hack was actually possible.
fair point. No sane person should be worrying about `unsafe.Pointer` abuse anyway. If the user has access to the program's memory, there's not much you can do to stop them.
I was wrong to suggest that the final keyword in Java ensures immutability ([link](https://en.wikipedia.org/wiki/Final_(Java)). Sorry about that. However, what you suggest does not guarantee immutability either. Take the following class: public class Example { int x = 0; public int getX() { return x; } public void incrementX() { x++; } } Now say we have an object o which has a private copy of an Example object. If we provide an accessor for this Example object, callers of the accessor method can then call increment() on the returned Example object which *does* modify o's private instance (it's the same place in memory). The freeze package in this post is to guarantee immutability on non-exposed variables with public accessors. 
Oh yeah you're right; the OP clarified in a comment that this is only intended for use in unit tests and the like. In that case I do like your suggestion better.
I generally pass by copy by default (passing pointers out of concern for efficiency seems like premature optimization), and I don't usually make things private/read-only unless there is a compelling reason to do so. I also rarely need the sort of nested getters you describe (perhaps this is just a difference in how we model problems?). As such, the "pain" of getters is very minor and very rare for me.
Memory allocated by `mmap` is not tracked by the garbage collector. That's why I need to set a runtime finalizer to unmap it when it can no longer be referenced. This is the same trick used by the [mmm](https://github.com/teh-cmc/mmm) package, and the same caveats apply.
Yes, but with future versions of the runtime, objects may be moved by the garbage collector. Pointers in your untracked chunk of memory won't be updated and might crash on dereference.
For anyone interested, there's also branch with a small server that aggregates data into tiles. It's not in master currently, but is pretty interesting if you bind to leaflet's tile requests (there's an event for it) and can only get the data returned that's currently in view. Endpoints look like the following: GET / - lists indexes POST /index "index={string}&amp;lat={float}&amp;lon={float}&amp;value={string}"- Adds a value to the index at lat and lon GET /index?index={string}&amp;x={int}&amp;y={int}&amp;z={int} - Aggregates data and returns an array for all data under tile at x/y/z GET /tile?lat={float}&amp;lon={float}&amp;z={int} - Returns the tile x/y/z as json, also accepts POST data w/ those params
&gt; If we provide an accessor for this Example object, callers of the accessor method can then call increment() on the returned Example object which does modify o's private instance (it's the same place in memory). `object.getExample()` should return `Example`, not `*Example`. Problem solved *at compile time*. There are other static solutions as well, but this is the most straightforward.
Thank you for the reply and information, it certainly helps clear some of this up. My team and I will be looking into this a bit deeper over the next day or two so if anything comes to light, I'll make sure to respond here and in any associated tickets.
Yes, you are correct! Sorry, I did not realize that we could have call-by-value evaluation in this manner. Clearly I still have a lot to learn about Go. If anyone else is interested, [this blog post](http://openmymind.net/Things-I-Wish-Someone-Had-Told-Me-About-Go/) touches on the subject. To be clear though, the argument I made above about Java still holds (I just tried it out to confirm).
Javascript knowledge was the 3rd skill I qualified on the first line of my first response. &gt; If you know HTML/CSS/Javascript 
you will now :) 
Because if you have 30 thousand lines of code written in Go, it takes more than 5 minutes to convert all of that to Node.js. It's all good if you've only just started out, but for most serious users they can't just switch like that.
Hmm. I'm not sure I understand the runtime well enough to comment on this. But it's worth noting that `Object` freezes pointers recursively, such that pointers in a frozen object will only point to memory allocated by `mmap`.
It's derogatory. This is a useless use of immutability. Immutability is fine as a choice when the compiler enforces it and the runtime takes advantage of it. It's completely pointless without that. If your problem is that you find things mutating behind your back, you will be even less happy to have things crashing unexpectedly. The reason that this package exists is that immutability is a popular hammer now, so everyone is busy looking for nails even where they don't exist. This happens often in the software industry, and for the most part, we make progress through the turning of the [hype cycle](https://en.wikipedia.org/wiki/Hype_cycle), but it's still worth keeping your wits about you and resisting the peak of inflated expectations when it's taken to ridiculous extremes.
Or just [`git freeze`](https://github.com/nicerobot/git-freeze)
I'll have to work something up. :)
Yes that would work. The final keyword just means that the variable always points to the same object; it can't be re-assigned, but the state of the object can change. I was, like you, under the impression that it also guaranteed immutability, but apparently that is not correct. Anyway, thanks for helping to educate me about Go! That's why I'm on this subreddit in the first place.
&gt; That time isn't here yet, as the language still hasn't settled. As someone else already said: that time passed **4** years ago https://blog.golang.org/go-version-1-is-released . Also, correct me if I'm wrong, but I think `reflect.ValueOf(...).IsNil()` solves part of the problem, so although not ideal, I don't think this problem is anywhere nearly as bad as it sounds; Certainly not enough to raise any priority for a `Go2` release.
If memory serves me right, up until I think 1.5, the method value for an incoming http.Request always showed POST for all methods except GET, and HEAD. This maybe wasn't a problem for making requests but it made writing handlers a bit more tedious. 
My major gripe with Go is your last point, namely that I need to write a lot of things myself whereas in PHP, they just exist and work.
No, you're right. In fact, I was involved in a project that heavily involved reflection and potential nil pointers (we were sending arbitrary structures over a network with no shared type information) a few months ago, and we never had issues with this sort of thing. It can easily be avoided, and even when it can't, there are tools to work around it. 
This first thing I would do is convert the subversion repo to git via a tool like svn2git to keep the history... then I'd use git :)
Thanks! That was useful.
Of course. Yet they are helpful. In your opinion, what would be the best way to measure project quality?
Agree with you. But this question is about concrete benchmark which relies on GC.
i disagree, null pointers in C are a landmine, but since C doesn't have the concept of interfaces as Go defines them, the conceptual overloading isn't there.
It's not the same kind of overloading as in Go, obviously. However, NULL in C is overloaded to mean all kinds of things in C, from "end of string" to "out of memory error".
Benchmark indicates about 20-25% faster on larger recMap using a "just right" bufCapacity. To be honest, its hard to get the size right, so I might remove this parameter and implement the Marshaler interface.
Test coverage IMHO is one of the strongest indicators of quality. However, the inverse isn't always true. I.E. You don't often find well tested code that is poorly written however there is a lot of good code with no tests.
To throw another datapoint into the ring... I'm converting to barycentric coordinates from cartesian. When I turned on the cgo implementation the performance dropped about 420%.
&gt; Quadtiles use 2-bit tile interleaved addresses thus: &gt; xyxyxyxy xyxyxyxy xyxyxyxy xyxyxyxy So, morton encoding? I've done XY and XYZ versions of this, both either embedding, or not, level into a uint (setting the right-most bits so sorts work correctly). For example: https://github.com/dskinner/octree/blob/master/octree.go Also related: https://github.com/dskinner/quadtree/blob/master/quadtree.go 
Hey man, the elephant in the room is that making a rather trivial 10 functions wrapper over BSD/MIT foundations (all of the libraries you use, plus golang itself) and pulling AGPL3 on that isn't really fair, nice, nor friendly. ;)
This is on my todo. Hopefully, it will be a reality soon.
Exactly what I was going to say. Though at least this is people putting their money where their mouth is. Using a package takes a lot more effort than just clicking the star.
Test coverage tells you how much of the code is definitely NOT tested*. That's it. So, something with 70% coverage is definitely not testing 30% of the code. Now, sure, if someone was a really bad tester or just wanted to game the stats, they could easily write tests and/or code to make it look like they have 99% coverage... but in practice, higher coverage % usually means more and better tests. *Actually... in Go even this is not for sure. go test -cover only understands tests in the current package. If you have a separate package that tests this package, its tests won't get counted. 
[Go Report Card](https://goreportcard.com/) is another good tool. It measures how well the code conforms to `go` standards and the "complexity" of the code defined similarly to how Code Complete specifies it. 
tc is the worst cli ever created ( after megacli ofc )
Thanks so much for the info!
thanks for the share. It seems wellington uses libsass under the hood
I would suggest using protocol buffers or cap'n proto or something, *especially* when persisting them. gob doesn't have a good story for backwards or forwards compatibility, protobufs have both. You *will* change your schema and when you do, you don't want to be dependent on maintaining backwards compatibility in code. Plus, safety: The encoding layer takes care that your data is well-structured. Speed-wise, protobufs should be same-ish to gob (gob's wire encoding is actually based on protobufs). I don't really see a lot of valuable uses of gob, tbh. You will always, whether when communicating over a network or over persistent storage, will have to read values that where written by a newer or older version of your program. If you *do* use gob, you generally don't want to encode discrete values. Every Encoder will first write a type representation for all types used, so if you encode every value to a separate `[]byte`, for example, you'll have a lot of overhead and computational cost to pay.
Gob has a huge value in streaming protocols where you don't want to have to have a pre-shared schema and where JSON doesn't have the right performance profile for the problem at hand. you are right in that it's a sub-awesome protocol for one off object stores since the schema has to be re-defined for every discrete stored item. I suppose if you are only storing maps/slices/strings/numbers, (ie: json style), then there's no extra overhead there as those are predefined types in gob. 
It can handle that too. It keys by name and the encoding is not order-dependent. Fields that don't match both sides are silently ignored. If your code can handle the two versions, gob will not make the problem harder.
How is this "with Go"? It's perl &amp; make, nothing to do with /r/golang
https://github.com/alecthomas/go_serialization_benchmarks
This could apply to any programming language, but it a slimmer process than using gulp or grunt. I prefer this just as I prefer to use the Go standard library. I like to keep things minimal.
Unrecoverable panic? Unrecoverable? That's bad.
Hi gdey, thanks for the response! I actually meant that I wanted to create something like the Gorilla toolkit in respect of websockets to try and reach myself go. I don't need it for a project as such, just a learning exercise.
I agree, but occasionally it's useful to see examples of people using Famous Ruby Things without Ruby. Similarly for Angular without Node as the backend, or [capybara without Rails](https://gist.github.com/thbar/7843643).
You don't break things into modules just for reusability, more often it's about readability. Yes, with a big enough screen and a small enough font-size, even 400 lines long is not a big deal, but is it easier to keep in mind than a smaller well organized struct? I don't think so.
I haven't compared the two, yet, since I'm on mobile. Is the site just a dump of that repo? If so, that's kinda cheesy. I love avelino's repo, and I don't see an attribution to awesome-go anywhere, nor can I find any indication it are run by the same person. 
I think this tool is cool and I use it works well for my few simple project. Any one has any issue for this?
I also publish a Line Bot for animal adoption platform for Taiwan Taipei in https://github.com/kkdai/LineBotPetNeedMe
If there is some other benefit to grouping fields into another sub-struct, like maybe you can define some of your methods on that sub-struct instead of the parent, then it may start making sense. But modularization just to keep definitions smaller is probably premature abstraction. 
&gt; I think we can think about this in the same way we think about object oriented design. Hugely overrated and killing productivity and understandability? :) (sorry for the snark. You happened to mention OOP while I am in a phase where I need to write lots of Java and am frustrated by it's culture of throwing wrenches into programmers intentions)
&gt; You don't break things into modules just for reusability, more often it's about readability. No! Spreading stuff all over the place doesn't make it clearer.
Yep, looks like this site is a shiny front end to the github repo. Their 'about' page clears things up... https://go.libhunt.com/site/about Thanks for pointing out the new site! (Well, new to me, at any rate. :)
Ah, I must have glossed over it when I checked the about page. Glad he's giving credit where it's due, avelino works very hard on that list.
Why is this the case? You don't really care about which fields are about states or meta every time you scan through the definition of the main struct. And we don't just split the fields and throw them away, we can organize them into structs with meaningful names. What's more, when reading the code, the editor can help us find the definition of the contained struct if we are indeed interested.
the other case here not asked in the question are anonymous structs in place of say, camelCasing or short names. I did this recently to see how it felt where (for opengl) i have a series of attributes, uniforms, and buffers. Each series member relates to a distinct thing, such as vertices. It becomes a case of either typing something like `x.attribVertex` vs `x.attribs.vertex`. I'm still undecided with how it feels but I'm likely to revert to the former or swap the words for better coherency, e.g. `x.vertex.attrib`. Still, it's a question I started asking myself recently.
You don't need to use channels to communicate between goroutines, but it's a good idea up until the point that your server is too slow *and* CPU profiling shows that channel communication is a significant bottleneck. Channels might not be the best solution to the "everyone broadcasts to everyone" setup you're envisioning, but the overhead isn't as much as you'd think.
Channels are just used for communications. Goroutines are used for concurrency. By default (with go 1.5 and up), these will be multiplexed over as many os threads as you have cores. This number can be adjusted up or down depending on the setting of GOMAXPROCS. 
I wrote a useful tip on finding [go projects](http://www.tysonmaly.com/programming/go/go-projects/) that lets you use keywords. I use it all the time to find cool projects in Go
I generally only break structures out like this when the embedded part would stand alone somewhere, or might be composed into something else. So for example, I might have a structure that represents a request to do something, but need that data in another structure that actually manages the performing of the request. So like: type JobRequest struct { } type Job struct { JobRequest } Otherwise, I don't find that multiple structures are more readable than a single larger structure (its actually the opposite for me). Obviously, though, this depends on whether the proposed substructure stands on its own. If it does, then I'll break it out
&gt; Channels might not be the best solution to the "everyone broadcasts to everyone" When a player logs in, I usually send a message to all their friends on their friend list (that are online). I'm just not sure if I need to pass this through a goroutine. I got channels and goroutines mixed up in my title I think. 
Awesome go list à dozen of image server, i think imaginary is pretty mature. https://github.com/avelino/awesome-go/blob/master/README.md
presumably you'll have 6 goroutines for each of the players' connections, so you'd probably want some channels or other way of distributing the movement signal to each of the other goroutines.
Yeah okay, I get that part. As I said I've always thought that keeping the API and the UI as separate "applications" is a very good technique as you can get advantage of both different environments especially if you have a good team, aka back-end devs only having to deal with Go and the front-end devs working their Javascript magic. This also gives the advantage of not mixing HTML and other web tech with Go (like when using templates) which although is a very useful method it can get messy quickly. But still what I do not understand is how can you replace sessions with Javascript. Can you explain that part please?
I'd say this is a pretty good place to start looking: http://go-database-sql.org/ 
With some projects the reason may simply be that this is how the structures grew over time. A structure may start out small, and grow as the code has to handle more and more complexity. As I said in a separate comment, I think that writing a large struct with well commented groupings is very readable. Of course, if a structure has grown into a large and ugly mess, then it may be time to refactor the code.
Why is this marked NSFW?... 
Could you tell me where you heard about my project ? I've received more than 150 stars ( https://github.com/trending/go ) and I don't know why ! :D
"We're seeing even better performance with tip." Hype! Great work by the go team, looking forward to 1.7!
Think of goroutines as threads. Channels are just queues. That's all they are underneath and that's exactly how they behave: thread safe first in first out queues. 
Indeed. Fixed. 
From what I gathered about your use case, using go routines isn't the solution, since scalability will be a problem. What would happen when you have 100, 1000, 10000 players logged in? I think you should consider some of the pub-sub solutions that are out there.
Sounds like a review of your design might be needed.
This is very nice. Thanks!
Care to elaborate, i.e. why it is bad to have all "needed almost everywhere" data in a central struct? Also all the "attached" functions need data from the struct, so I kinda have to give it to them as receiver (I think, don't I?) The struct is basically what a class would have been if I'd have done this in a language that supports OOP.
They are good in case you want to create something that needs heavy computational power like Fast Fourier Transformations, signal processing, electrical engineering, etc. It all depends where do you want to apply. Fractal is another field where you can apply it, and it's quite recommended to use it. I didn't.
HTTP was designed as, has always been, and continues to be a [stateless protocol](https://en.m.wikipedia.org/wiki/Stateless_protocol). Server side sessions are a vestige of the days when the only way to save state in the browser was as a cookie. HTTP cookies were [implemented by Netscape](https://www.ietf.org/rfc/rfc2109.txt). A similar mechanism was previously used by the X-11 which used the term cookie as well. From Cookies sprange sessions of all sorts. They were useful because without them there was NO WAY to tie a series of HTTP requests together -- which was necessary to make even the simplest of web applications. They allowed the application to know what had already happened and from that it could figure out what to do next, and wether to allow it. But today browers are a full-blown development environment! If you understand how you'd build a mobile application action, then you already know the answer to your question... The user starts an app. It challenges the user to authenticate. The user types their username and password in and they are securely sent to an HTTP endpoint that identifies the user and issues a response with an HTTP header that includes an authentication token which the applications stores for future use as it must be included with future requests. Was than an Android, iOS or web app? What's the difference? On iOS, the app is written in Objective-C or Swift. On Android, Java. On the web, HTML/CSS/Javascript. The API is written in Go, of course. :-) Does that make sense?
First I create a repo interface which specifies the actions I want to take on my persistence layer: type TodoRepository interface { ListTodos() []ID GetTodo(ID) Todo SaveTodo(ID, Todo) // etc... } then I implement a simple in-memory debug-implementation and get on with my day. i wait until most of the application is done before i make a database-backed implementation of my Repository, using the sqlx package.
That makes sense yes but I still cannot understand how that replaces sessions. Let's say we have a web app and we want to store some stuff (in the session) like some user specific options or an e-shop cart. How can you avoid sessions in this case?
How stable is this, given that Wren is presumably still in design flux?
Just a note - you don't need to create the src directory under GOPATH. The first time you go get something, it'll be created (and given that most editors will want you to go get linters etc, that will probably happen before you write any code of your own).
Assuming you're using some kind of autocomplete in your editor, `x.attribs.vertex` would be accessible by typing `x.a&lt;tab&gt;.v&lt;tab&gt;` while the other form would require `x.attribv&lt;tab&gt;`.
This is just a small detail about Go if you're using Windows: If you can compile go programs but when you run them, they just get stuck before anything in you code is run, make sure you're putting your gopath on your antivirus exception list. It happened to me recently, and it was oh so frustrating, since the antivirus(avast in my case) silently blocked them.
I made one some time ago as well: https://github.com/maciekmm/messenger-platform-go-sdk - supports templates, but event system needs a rework.
Its tradeoffs - after spending much time on files with 1k+ or 10k+ rows there is definitely incentive to spread out. But then when there are tons of one-off files or a type definition that points to twenty different other type-defining files that is also not great. Given enough experience, things like verbose commenting or extreme abstraction tend to get in the way of just getting it done. But so does repeatedly writing out behavior or data that could be abstracted. This is the art of software engineering and is not a golang-specific issue. You should try spreading out and see where you end up.
I don't see the point of this article. The examples both use other peoples libraries to parse, with different functionality to do something trivial. The only conclusion is that Go is faster than Ruby. Well of course it is and I don't even need to list the reason why because they are all obvious. This has been a waste of my time I even regret typing this comment.
Another issue with abstraction is the potential for debugging nightmares. Stack traces with many layers of abstraction can be a slower unroll, or sometimes even impossible to see important info (which HTML5Host was in place at that time?). Careful logging and debugging strategies are hard won, and complex type systems can get in the way, hence a reason to make a huge struct to just dump with +v once.
This is kinda an aside: I'm working on a v2 of my rdb (relational db interface) package. This release will include support for context. Every query will have a context associated with it. Once that context is done (which should be when the request is done) that query/db conn will be finished and returned to the pool. Thus so long as your request have a context with a deadline associated with it that get's canceled when the request is done, database connections won't leak. I know that doesn't help you now... but...
&gt; Win/win eh ¯\\_(ツ)_/¯ I would call it a loose/neutral. Readability suffers in my eyes and it doesn't bring any benefit. Which is to say (just to make it explicit): All of this is simply subjective. Whether you find struct{}'s littered everywhere readable or not, whether you think 40 lines is too long and where you draw the line… all is subjective. Though I guess, what OP found is, that a lot of people agree with my notions (as he complains that struct definitions with my notions are "very common").
Try this: At the beginning of your test call `db.MaxIdleConns(0)`. Before your test exits verify that `db.Stats().OpenConnections == 0`.
10 fields is indeed more reasonable than 40 fields, but it's still the upper bound for SRP-respecting code in my experience.
I am an idiot :'( ... wrong suspect. https://bugs.chromium.org/p/chromium/issues/detail?id=110649 Go had nothing to do with this, its a self signed certificate. You mentioning chrome://cache is what helped me, so thanks for that. 
Even the Go documentation says gdb doesn't play nice with Go programs. Use Delve instead. 
Yes, that makes sense to me. &gt; Now what we disagree? Whether 40+ lines a struct is too long. There is no magic number of lines, beyond which a struct is definitely too big. 40 lines may be fine for some piece of code. 200 lines may be fine. Probably 1000 lines is too many ;)
Sounds like you need a pubsub system for the notifications. Channels are great, but you can also use a mutex to ensure your data is race-free
If you want to see an example, https://github.com/goadesign/goa is a generated framework that leverages gofmt via goimports.
What's your lib's name?
&gt; But I don't know why it became trending in the first place... There usually is one reason - people found it useful!
The first return value from a range is the index of each item into the range specified. The range you specified is list[1:], so you're getting i values of 0,1,2 that correspond to that range ["b","c","d"], but what you're printing are items indexed into the original list instead. The simplest way to fix this is just to use the version of the range operator which returns the actual item as well as the index, since that's what you seem to care about: for _, v := range list[1:] { fmt.Print(v) }
Very true.
Yeah, it's very subjective.
Hmm, I have no problem using a go server with a self signed cert. Cache-Control, Last-Modified, 304:s etc. work as expected. Try making the self signed cert for `localhost` domain and use `https://localhost[:PORT]` not the IP address to access your site. I created the cert with the cmd line tool that go ships with. Its hidden somewhere in the crypto package, its just not built when go ships, but you can build it in the dir manually. **Edit:** Its this one https://golang.org/src/crypto/tls/generate_cert.go cd into the dir and run `go build generate_cert.go` and follow the instructions in `-h`.
well, you built a module / package / library, so you can't really run it. In go the "main" function is called "main" in a package "main". So at the minimum you need another go file that looks like the following: package main func main() { test(42) } but this still will not work since test is not in the main package. What package did the "swig" step generate ? Check the first line of example.go and import that package in your main file. 
Note that you don't have to spread out the structs in different files. You mentioned verbose commenting, that's what happens when you put too many fields in a struct, you start to add comments explaining "the following block of fields is about the status".
You should download the RSS file have the programs read it from disk, instead of downloading it, to get rid of network latency and download time as a factor.
Exits*
Gob is only go specific in that there aren't other implementations of it. Same can be said about many serialization formats. I've attempted a java port a while back, but I stopped when the docs/spec didn't match the implementation, so my java codec couldn't decode everything. Figured I would pick up back up some day as I haven't found a better self-describing protocol for streaming. Not a fan of IDL based protocols in a complex software environment, too much work to distribute / coordinate. Also not a fan of map/list style protocols (json) as there is so much redundant info for objects (ie: sending the fields names with every obj) that the overhead becomes an issue in some applications. 
The Go spec has never promised the x86 memory model. Changes made in one goroutine may *never* become visible without a happens-before relationship. The code here looks like the "busy wait" example of incorrect logic in https://golang.org/ref/mem
&gt; added MatchWithWriters functionality, which is used in the HTTP/2 &gt; matcher in order to send an early response (e.g. an HTTP/2 settings &gt; frame) to a client No, you misunderstood that part of code. As long as you use `cmux.Match` (https://godoc.org/github.com/soheilhy/cmux#CMux) cmux does not write any data back to the client. `cmux.HTTP2` and `cmux.HTTP2HeaderField` are truly read-only. Yeah, there is a write there, but that's discarded when you use a Matcher. :-) cmux spoofs a SETTINGs frame if you use `cmux.MatchWriter` and pass in a `cmux.HTTP2MatchHeaderFieldSendSettings`. This is to fix a broken java client and I have warned in many places that you shouldn't use that unless you absolutely need to spoof SETTINGs.
I also worked on something similar: https://github.com/paked/messenger.
Is... is that a minion?
The installation location for Linux is the same as Mac. sudo tar -C /usr/local -xzf go1.6.2.linux-amd64.tar.gz
I think they're easy to spot if you have telemetry data graphed out e.g. with Prometheus. Even just logging go routines would show leaks clearly on a graph since I think an open db cursor creates a gorourine. Another package like pprof would give you more info to actually fix the issue. A test would be better but having the graphs is a good catchall for this kind of thing. 
Sorry I thought you were the author. Happens all the time here, ppl are sharing their work and get feedback here :)
Store it on the client side in your Javascript application, or keep it entirely stateless on the server side, indexed by the user ID which is typically available on the back end via the authentication system. Trust me, it can be done, and it's not particularly difficult once you "get it." :-)
I understood it correctly, and my opinion stays that the use of `cmux.MatchWriter` (and not `cmux.Match`) can break things for the given reasons: You will certainly break something if you have more than one MatchWriter if they don't match completly orthogonal byte streams. And you might even break something if you have only one. E.g. take a look at the Go HTTP2 server implementation here: https://github.com/golang/net/blob/master/http2/server.go#L1197-L1206 : The server will close the connection if it receives an unexpected ACK. By sending a Settings frame from cmujx (unknown the server) the remote side will answer with an ACK that is not known to the server and you will run into this situation. Some HTTP/2 implementations might behave that way, others might ignore that ACK (e.g. the Go HTTP/2 client implementation does not seem to care about it), but the general outcome is that it might brake otherwise perfectly compliant HTTP/2 implementations. I would not risk that just in order to get some other implementations running in combination with cmux.
With synchronized hand-offs as long as they're un buffered. :-)
Do you know any opensource go project that follows that method? I'd like to see some code to understand it better.
Maybe try to use intellij idea + delve. Works like a charm for me.
why does that page have black borders? i'm not reading this on a tv.
This seems like it would be well served with an explanation of the different purposes of TCP and UDP, as well as handy things such as deadlines, timeouts, and keepalives.
It's the default WordPress theme.
I don't think I misunderstood anything: Toggle network a few times to see notifications: 2016/05/14 08:33:27 bing.com is DOWN 2016/05/14 08:33:27 google.com is DOWN Toggle network a few times to see live updates: google.com REACHABLE ================== WARNING: DATA RACE Read by main goroutine: main.main() /home/tv/z/src/github.com/pbnjay/reachable/example/main.go:63 +0x632 Previous write by goroutine 62: github.com/pbnjay/reachable.Start.func1() /home/tv/z/src/github.com/pbnjay/reachable/reachable.go:101 +0x30 github.com/pbnjay/reachable.(*Checker).run() /home/tv/z/src/github.com/pbnjay/reachable/reachable.go:162 +0x245 Goroutine 62 (running) created at: github.com/pbnjay/reachable.(*Checker).Start() /home/tv/z/src/github.com/pbnjay/reachable/reachable.go:87 +0x99 github.com/pbnjay/reachable.Start() /home/tv/z/src/github.com/pbnjay/reachable/reachable.go:103 +0x116 main.main() /home/tv/z/src/github.com/pbnjay/reachable/example/main.go:57 +0x5e3 ================== google.com NOT REACHABLEFound 1 data race(s) 
I'm curious; but seeing the "Inspired from SQLAlchemy" has me trembling. After fighting SA for the last several weeks, I have absolutely no doubt that hand-rolling SQL for each target database type is easier/safer than using SA. :/ Hopefully qb addresses these pain points.
No examples of joins. Are those easy enough to do?
Very cool! Thanks for adding the cross-platform functionality as well. Would love to get this information added to the Prometheus node exporter. 
This isn't about Go, this is about [HTTP](https://tools.ietf.org/html/rfc7540) and [ECMAScript](http://www.ecma-international.org/publications/standards/Ecma-262.htm).
https://github.com/assembla/svn2go
How can you hate minions!?!
1. set the CC-variable to a corresponding C crosscompiler and explicitly enable CGO (CGO_ENABLED=1) in addition to the GOOS and GOARCH and it should work: https://gist.github.com/steeve/6905542 (the crosscompile script is not necessary any more since the compiler went 100% Go) 2. Go can even be compiled without any dependency on libc, although it CAN be used, and indeed must be used if compiling with cgo. 3. Docker is very good for isolating different versions of anything, but runs on your OS kernel, so it won't solve crosscompiling issues.
I haven't used it before, but I've seen this library recommended elsewhere: https://godoc.org/github.com/mingqing/godocx
It's linked to in the intro: http://stackoverflow.com/a/1099734
It's pretty straightforward to fix this race. Either make the global bool private, expose it with a func and protect it with a RWMutex, or if it must be a bool then change with a sync/atomic swap. I don't get the defense of a known buggy implementation.
A good open source project then?
Update: things are not great for me right now. I'll be looking forward to chatting about this stuff with you guys when things get better for me (maybe in a month or so).
Can anyone pls comment? rather than upvoting and later downvoting? downvoting doesn't help unless you give feedback!
Highly recommend go semi official:"https://godoc.org/github.com/golang/time/rate". Very good library, with beautiful API, IMO. It should be very easy to integrate, if each request is comparatively small % of total bandwidth. Otherwise you may have to break down each download into multiple "token requests". 
go tool knows how to run swig, if you have a .swig file. See https://github.com/golang/go/issues/6696. Search for "slimsag commented on Apr 2, 2015" - this comment has very useful step by step instructions
Looks like it does have support for most common joins if you look at the godoc. I like this library because it's not trying to do too much. I use sqlx in most of my projects and this will add a little syntactic sugar to make building queries a bit easier. 
Please share your amazing ASCII art!
Did some clean-up and decoupled httprouter sources to make it easier to use with existing work. Cheers
nothing you write in go matters, no type safety, not legitimate... ... However, what you write in Haskell is logically a formal proof for all time... I'm just sick of all the waste.
Ah.. Purists are fantastic. 
Usually when I see a thread like this and cannot decide whether it is trolling or for real I just move on. But this time you really amused me, so you deserve a comment ! Do you have ever seen production code? It usually is a mess.. the language doesn't matter at all. Everything needs to go fast, be prototyped and especially shall not cost much money (-&gt; time). If you think choosing 'a functional language' could change that you still need some real life work experience. Go at least offers you tools to make the code reading easier (fmt, lint, ..). Oh and btw you would never define a linked list type with interface as shown in your little rant. Just use a slice instead but I guess you don't care because you already know what's best in any scenario. Happy haskelling :)
Since Go has a sane backward compatibility I haven't felt the need to have multiple versions so far, it looks like a good way to do it, thanks. Your example cross-compile script is I think for pure go applications. For cgo applications, things get a little bit complicated. I guess it is best to stick to only pure go libraries when cross-compile is in question. 
You have the "Every body is retarded" syndrome. Good luck.
What a success for Go to be compared to the rolls of the languages by the master of the developer ! It's too much honor ! Lol !
Maybe. That would require engineering a way to scan stacks while the corresponding Go routines are running, which is a little difficult.
IIUC you are asking about the current implementation of the GC and in that case the answer is no. You might be able to get the latency very low, but not zero, as the algorithm still depends on a STW phase. This *might* change in the future, but AFAIK this isn't currently planned. go is an engineering project and as such it makes a tradeoff between latency and throughput and likely will get to a "good enough" for both and not really further. I also don't really understand why you'd need zero latency for an audio/video transcoder. Surely a bounded latency together with good overall throughput of the transcoder is enough?
They is an saying like "If you meet one asshole during the day, you met an asshole. If you meet only assholes during the day then you are an asshole."
Based on https://twitter.com/realtalkintech I'd say it's not serious
Video codecs usually allocate ahead of time and don't generate much garbage. They usually know how large the buffers they need to process given an input resolution and settings. They re-use buffers allocated for first frame to process following frames.
I am sure it is a joke.
I get that testing package will hold a mine of information, but I was actually asking the techniques of testing a web app and not testing in general :-)
I am not very familiar with the appengine library, but the log functions take a standard `golang.org/x/net/context.Context` object. So you can just use the `Background()` [function](https://godoc.org/golang.org/x/net/context#Background) to get one. If you look at the [source](https://github.com/golang/appengine/blob/master/appengine.go#L28) of the `NewContext(req)` function this is exactly what it does. Digging into the appengine's log implementation, it appears that there are some context-bound settings that you would have to apply if you wanted to override the log function. [\[1\]](https://github.com/golang/appengine/blob/master/internal/api_common.go#L75) Although I would first try to get it working without digging into those details.
Preallocation and reuse are the ways to not generate garbage. What bet are you hedging by not generating garbage to begin with?
It's been a while since I've used app engine, but as I recall an instance is sent a special request at startup time. You should do your setup in a request handler for a special URL instead of doing it in an init function. App engine is set up so that you must always have a Context object to do anything. See this page for an overview; the special request will be an empty GET request to /_ah/start https://cloud.google.com/appengine/docs/go/an-overview-of-app-engine
One other note: if I remember right, your instance will not be given any normal requests until the /_ah/start handler returns, so you don't need to worry about race conditions between startup and normal handling within a single instance. However, multiple instances could be spinning up at the same time, so you should take care for race conditions between instances in your initialization code.
Awesome, this is what i was looking for. I can move almost everything out of init and into the handler for /_ah/start.
I think giving some constructive criticism would be a lot more helpful than a comment like this; let's keep this community friendly shall we?
Where do I keep the current state of things ? In memory in structs ? When do I discard the info ? after i save it immediately in DB ?
You can pass the function from main to your package (probably). It sounds like a really odd thing to need to do but it does sound like you want a function argument.
for 1) you could use [gvm](https://github.com/moovweb/gvm)
I used to think that too: What if every built in data structure has an Interface? But then, they all going to have methods like this: AddInt, AddInt64, AppendString, AppendByteSlice, etc. Not exactly elegant...
This kind of thing; the community surrounding functional programming, is exactly why I stopped. I started getting the same kind of vibe from the Scala community. People who think they're god's gift to the world of programming. It's interesting though, genuinely; I've never seen a piece of Haskell code in production. I've never heard of companies using it in production. In fact, the only time I've heard about it is in rants like this, or where people have compared it to other languages. In one of those comparisons I did see people saying things like "the most complex thing I've seen written in Haskell, is the Haskell compiler", and "in 5 years more useful code that runs in production has been written in Go, than has been written in Haskell in the last 20 years". Go may not be the most "feature complete" language, but it doesn't need to be, nor does it intend to be. It doesn't try to woo you with fancy unnecessary stuff, it's a tool that helps you get shit done; it's pragmatic. It's got one of the most welcoming, and disciplined communities I've seen before, and I'm glad to be a part of it. Look at all the companies switching to Go, reporting much greater productivity, easier development, faster ramp-up times for new developers, great performance, stability, ease of deployment, so on. This post on the other hand is only going to alienate potential Haskell users even more; and like I've said, I've seen tons of FP nuts who are like this. I have no idea why, but a lot of them just seem like arrogant pricks.
I wonder if this is the reasoning behind Python's subprocess module deesign.
The code receives commands from the outside and my main package has a function RegisterCommand() where I can register a command from any other place in the code so when a registered command is received it'll be executed. Now I have an extension package, that acts a bit like plugins, where I want to put codefiles in that can cal RegisterComman() so that when it's command it received the code from that package will be executed. (RegisterCommand() takes a function pointer that's called when the given command is received).
&gt; A use case is a audio/video transcoding program which needs predictable performance(zero latency) Predictable performance != zero latency. How many fps do you need to encode, how many can you practically encode? What's the GC's guarantee in terms of latency? Can you fit in your encoding time plus the GC latency in your encoding timeframe? That's the kind of questions you need to ask. FWIW, I'm using Go for a soft realtime application at work, and it's totally usable if you know your requirements and time constraints.
You can't do it. You can only pass function from *main* to function from your library. Anyway you have to define a signature of the function in your library. Check a middleware conception. There are some example. It's just conception. [example](https://play.golang.org/p/CbDtluiPt5) 
All his posts are done anonymously it's clear he's just immature and lonely. Since we know his motivation is simply to get attention, ban him and move on.
Link me your github, I'm curious whom employs you and has the privilege of your Haskel code in production? I would love to see some amazing waste free code.
You move your whole command registration to its own library as well. 
YOU are doing this right? This is your project. Just start writing something. Little less planning. Little more coding. Let the pieces fall in place. Try things. Make mistakes. A partially working prototype is a far better place to start than a "plan". You can plan all year and still not have a single clue what you are doing. Let me help. package main
Or have the library provide a setup function that your main can call into, to allow it to register functions. Or have your library provide a `Commands()` function that your main can call to get a list of commands to register. Basically anything besides having your library attempt to call functions directly in main
I disagree with the statement that Go is not a good beginner language. I actually think it is. I think the things that make it a good large team language, also, make a good beginner language. Also, the number of concepts one has to learn to start is very small. Unlike c++ or Java, much like C. (Perl, Python, Ruby, the amount is just one line which is nice.). With Go: You can start with this simple program (https://play.golang.org/p/y5XX4RDTW5) package main func main(){ printf("Hello World\n") } I would not start there, but you could. This is better then Java, because you don't have to teach them what is a class, or what imports are etc… But they can get immediate feedback. And the fact that there are only 25 keywords make's the language grokkable in a weekend.
Exactly - if you're transcoding at 60FPS, that's ~17ms per frame. Given that go's GC pause time is often around 3-5ms, there's still plenty of room in which to do your work without jitters. Even if that tiny bump puts you outside of your frame-time requirements, you can always make up for it by just putting the tiniest buffer in front of the output - and in reality, video de/encoding is heavily variable in time-per-frame, so you're gonna want a bit of a buffer anyways. Unless you've got more than enough headroom, in which case GC isn't going to be relevant anyways.
Really interesting read. Thanks for that!
I've considered using one just to simplify commands, subcommands, and more complete help text.
Cool, very helpful, thanks!
&gt; This is better then Java, because you don't have to teach them what is a class, or what imports are etc You know, that argument really isn't valid. You don't have to learn about a class in Go, but you do have to learn about a struct. And of course you have to learn about imports in Go, or you can't get anything done. The package complexity thing hits you square in the face as soon as you want to do anything more complex than should be contained in one file. I don't think Go is a good beginning language at all. For that matter, I have my reservations as to Go's viability for most general computing. I will agree that Java isn't the best "first language", but neither is Go.
So Go is not a good language because it's too easy to use? Programming must be painful?
I never said its not a good language. I use it everyday in production. But you will eventually run in some c++ code or other programming language (a bit more complex) , so why not have a bit of experience in manual memory management or other similar topics.
That reasoning is solid, but it should not make you choose a different language for core projects. Maybe encourage your developers to do hobby projects in other languages or perhaps do some less important things in other languages for practice (although that really hurts maintainability).
Doesn't it Look like a work around - you have to have a new domain name to make your package works. Having this meta data in html pages is still annoying.
@MasterScrat - I have another. Not-yet-public project that should collects this metrics and feeds them into [InfluxDB](https://influxdata.com/). Then I try to visualise everything with Grafana. Here is little demo - in Slovenian - about the thing. [Check it out.](https://www.youtube.com/watch?v=87I7tKwQGn4&amp;t=2358) You can contact me if you want to collaborate on this,... socol was designed to be used as a command-line-tool. Or as a web (micro) service... You can also use it with something like [ProxyMesh](https://proxymesh.com/).
I am sorry, I have no idea how to do so, can you give me some pointers?
Not a silly question. You need to have a remote server and upload your program to that server (FTP, rsync, scp, etc). You'll also need some way to connect port 80 to whatever port your application is listening on (you can even make your app listen on 80, though you'll likely need to run it as a privileged user). Finally, you'll need your Ubuntu server to have a static IP address and you'll need to purchase a the domain name to register your IP address to (this last point is a bit complex, and I don't know what you already know about DNS, so feel free to ask further questions).
First just transfer your Go app to the remote server. You can do that either by uploading the binary and any static files via `ssh`, particularly with the `scp` command or alternatively: * install Go to the remote server * `go get` your app * deploy with`go install`. The remote server has an IP say `104.1.2.3` so after you deploy the Go app to the remote server you can access it by visiting `http://104.1.2.3:8080/index`. Of course it's more human friendly to use domain names that lead to IPs. So if in your DNS you have that `example-site.com -&gt; 104.1.2.3` then you can access the app via `http://example-site.com/index`. You need to check the settings of your DNS provider for that. Another thing you need to be aware of is port forwarding which practically means that you need to have port 8080 open in the firewall. It's more common for security reasons to have 8080 disabled and access every app from port 80. If the only thing you need to run is your Go app then just configure it to listen on 80 and you are done. The flag package is ideal for that so that when you start your app in the remote server you can do something like `goapp -http=localhost:80`. That gives you the flexibility to change the ports that your apps are using without recompiling. If you want to run more than one apps then you need to configure another server to act as a reverse proxy like `nginx` or `apache2`. That way you could for example have `http://example-site.com/index` served from Go app1 and `http://example-site.com/service`served from Go app2. In this case, you need to configure the reverse proxy in such a way so that `/index` goes to `0.0.0.0:8080` (Go app 1) and `/service` goes to `0.0.0.0:8081` (Go app2). Now after you are done with your tests, you can turn your Go app into a service so that it automatically starts when the Ubuntu server starts. That can be done with Upstart or Systemd depending on your version. Check out a sample Upstart configuration file: # goapp upstart conf script description "goapp upstart conf script" start on (net-device-up and local-filesystems and runlevel [2345]) stop on runlevel [!2345] respawn respawn limit 10 5 console log # avoid running goapp as root setuid &lt;username&gt; setgid &lt;groupname&gt; exec /home/yourname/go/bin/goapp -http="localhost:8080" Modify and write to a file `/etc/init/goapp.conf` and then start the service by `sudo service goapp start`. Lastly, if you log stuff in your application like with the standard log package `log.Println("An important event occurred!")` then you can find those messages under `/var/log/upstart/goapp.log`. Happy hacking! Edit: Modified the script based on /u/NeedsMoreTests 's comment.
Please do not encourage people to run things as root. You could do `setcap 'cap_net_bind_service=+ep' /path/to/program` to give it the `CAP_NET_BIND_SERVICE` capability to be able to bind to ports under 1024 without root. But the recommended way is to use nginx/apache/Caddy https://caddyserver.com/docs/proxy to proxy requests to the backend.
Yeah, another user corrected me as well. Evidently you shouldn't run your application as root, but instead use a reverse proxy.
Evidently you should use nginx or caddy; my advice about running your application as root and listening on 80 is insecure. In the past I've used rsync to deploy my payload to DO from my build server; this worked pretty well. You'll also want to configure your server to use upstart or whatever Ubuntu is using these days; this will make sure your app runs on server reboot and it will restart it if it crashes, etc.
Careful with that article, the author doesn't know about racy code yet, and if you plan to learn from him/her you won't learn about racy code either, until you do the hard way. :) -jeff
open /etc/nginx/sites-available/default and add this to server block location / { proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $host; proxy_pass http://127.0.0.1:8080; } The most importnt line is the last one where you specify that all requests from `/` are proxied to `http://127.0.0.1:8080` For making sure Go app is always running, I'd use supervisord ([how-to](https://www.digitalocean.com/community/tutorials/how-to-install-and-manage-supervisor-on-ubuntu-and-debian-vps)) which I find easier to use than upstart or systemd.
Nginx and caddy have the same restrictions as to privileged ports.
Testing your specific HTTP implementation would be start the server, send it HTTP requests (perhaps a table of request sequence and expected results?), and verify the response and sequencing is what you expect.
How does the bootstrap toolchain work?
Couple of comments: * The upstart file here runs the application as *root* * You don't need and shouldn't have go on the remote system. Just cross-compile the binary: GOOS=linux go build .
v1 (without context) is at https://godoc.org/bitbucket.org/kardianos/rdb v2 (with context but incomplete) is at https://godoc.org/github.com/kardianos/rdb v2 will operate on the basis of injectable connection pool driver, so I should be able to wrap database/sql drivers, the stand alone pgx pool driver, and have a default pool implementation as well. 
I ended up going with caddy. I don't have my domain name yet, but setting up caddy was super easy and I would have never known about it without this thread. Setting up a basic reverse proxy with 4 lines was very satisfying. Question though, wouldn't a person be able to access my `localhost:8080` routing if they connected directly to my site rather than the proxy that listens on `localhost:2000`?
You can definitely get anonymous functions / closures from libraries. https://play.golang.org/p/sp4GiYATZZ Just gotta return a func. This isn't two packages, but does show the closure functionality on a call.
That's another side of it, given unlimited time you should do both (client to server, server to database, these are independent in some ways). I'd personally be mostly worried about getting my query language right, so I'd want to test every query I've written. That would be running them through an actual database - I'd setup a db with test data and have a set of passing/failing cases for each query, with the Go app/database interaction handled by the Go test code. 100% test coverage would also be testing the code that interprets the return of the query. So there are three separate testing tasks in what you describe so far.
`proxy / localhost:8000` would be correct. Caddy listens on 0.0.0.0 by default. If you then only allow port 2000 in the firewall, people will be able to visit. A connection would be like this Client -&gt; port 80 -&gt; Caddy -&gt; port 8000 -&gt; Go
I have to admit that I find it very silly that we still have the concept of privileged ports hanging around, but yes, it is indeed the best workaround.
Well, it builds the compiler and its dependencies into what they call the bootstrap toolchain, then it uses this to build the compiler again, including all tools. It basically just builds the toolchain twice to ensure that you have a fast compiler as well.
I just wish there could be a permanent setcap for a given binary path or some other permanent way of allowing it without port rewriting. Every time I update the binary I have to re-setcap which is unfortunate.
You can compile it out of the kernel, but otherwise there are update script that setcap as part of the update, setcapped proxy (haproxy or similar) or port rewriting are the "convenient" ways to deal with that.
Right, since it's 1. compile src with go 1.4 2. compile src with compiler built in previous step
Are you near a border town? There may be a company offering US shipping addresses there where it's usually a lot cheaper (albeit with a trip to the border with it's associated wait times) . There's one in Sumas WA, Oroville WA (across from Osoyoos BC), Blaine WA even one in Point Roberts WA. Not sure of the rest of the country but I am guessing they're everywhere. 
And no shipping to europe. 
Is this still the America only thing? Might be worth noting in the title.
There are quite a few third party libs that build on top of image/draw. Even I have [one](https://github.com/urandom/drawgl), though it's still in development
I really like https://github.com/disintegration/gift and used it in production.
I'm not sure why some people perpetuate this myth. With Go there is very little reason[1] to proxy with something like nginx. The Go standard library net/http is as solid and production-ready as it gets (including the TLS stack). 1. One of the possible exceptions would be for load balancing among several different servers, or for server multiplexing (by hostname, path prefix, etc).
Recommended by whom? In most instances a separate proxy process is totally unnecessary. This is exactly what setcap is for, and you avoid an entire extra layer of complexity and configuration.
This seems like the typical "Go isn't like my favorite language so Go must suck" type posts. Go get is just one way to fetch packages. You could absolutely set something up to have a very flat name space of packages and have "pretty" imports and still use the Go tool, but in practice it's just some hierarchy, the actually package name is the last part. 
Behold, Google's monetization strategy for Go. :p
Until you want to virtual hosts, or ssl, or... lots of reasons to use a reverse proxy in front of webapps. Even apps written in Go. net/http is great, but we do not have to recreate every other functionality in Go just because we can. There are already lots of projects that do what we need.
Props for implementing a protocol. That's great practice and a super important skill to have!
http://www.postgresql.org/docs/current/static/external-pl.html I am not seeing a PL/go for postgresql there or anywhere else on the interwebs. 
I see. Personally while I also come from a Java background I have very a different opinion for the majority of those points but if we start discussing we will never finish. Thank you for elaborating and satisfying my curiosity. I respect your and your group's opinions.
&gt; I am still learning. How can you avoid running the application as root with upstart? http://upstart.ubuntu.com/cookbook/#setuid http://upstart.ubuntu.com/cookbook/#setgid 
CGo can be used to build shared libraries. You could use that to have a .so that exports the symbols expected by PostgreSQL.
Yes, https://github.com/thewhitetulip/Tasks
Thank you!! The code is at https://github.com/thewhitetulip/Tasks if you want to see it :)
Yes, I didn't actually mean random values, I am going to have a database filled with values, that won't be a problem in Go. If I got it right, I have to basically write bots correct? I mean I'll have the GET /, the login logout, invalid login attempt. invalid URL, invalid method, valid GET /Tasks/7 and for each attempt I should check what output I get from the server and check it with what I'd have gotten from the database. 
This seems to work https://github.com/urturn/go-phantomjs 
Profiles or gtfo
As some people explained, Don't make your Go server available directly on the internet. Use Nginx or any http proxy that will forward client requests to your app, It may remove some problems. Some research on google would have been useful for you https://www.digitalocean.com/community/tutorials/how-to-use-martini-to-serve-go-applications-behind-an-nginx-server-on-ubuntu
I am so sorry everybody you did not get your gopher. However, I really hope some of you could actually get it. Purple the most cutest one for me ;)
Sounds more like a confusion of GOPATH and GOROOT.
Had the same idea: https://github.com/hectorj/godm I don't maintain my project much though...
If this is a question, then yes -- they're pretty much equivalent. *make(map[string]int, n)* gives you the option for specifying initial allocation size while *map[string]int{}* will use the default.
Just use master.
Hi. Author here. I know about racy code. I even mentioned that in more complex apps, mutexes should be used to guard the config variable. "go build -race" didn't detect anything. Could you please tell me how can a race condition happen in this code? Thank you.
Is this common practice with Go to not have versions? What if they update their code and in one build my code works and in the next one it doesn't. 
See https://blog.golang.org/slices for a simple and thorough explanation of slices and append. In general, note that growing an array almost always require for the array to be relocated. Something like a C++ std::vector just doesn't tell you that it relocated things.
It's impossible. Unless you have a friend in the USA who'll send it to you.
I'm just happy that this made me read the Wikipedia page about manuls: Siberia's grumpiest wildcats.
https://github.com/mgutz/dat has caching // cache result for 30 seconds key := "user:" + strconv.Itoa(user.id) err := DB. Select("id, user_name"). From("users"). Where("id = $1", user.id). Cache(key, 30 * time.Second, false). QueryStruct(&amp;user)
Not at build time, go intentionally doesn't support build-time processing. But [go generate](https://blog.golang.org/generate) is usually used for this kind of stuff. Just write it into an sql file and then write a short go program (hedged by a `build +ignore` or something) that generates a .go file from then. Then add a `go:generate` comment somewhere that `go run`s that program and run `go generate` before/at each commit. I don't know if there are ready-made solutions to this. Another way would be to use a pre-existing solution for statically compile in files from source and then write code to read from disk/that statically compiled in FS at runtime to find the queries.
You could use go generate to embed the contents of some sql files into your program before compiling. There was post about them here: https://mattjibson.com/blog/2014/11/19/esc-embedding-static-assets/ I also wrote a *very* simple version here: https://github.com/tscholl2/embd Most of these won't deal with multiple queries in the same file, but you may be able to figure something our for that.
wow, awesome! gonna work on that stuff!
Hi synaix, thanks for the snippet of code and your explanation for why typed const are important (and yes, I agree) :)
Thanks :)
You could try `go generate` with something like this: https://github.com/jteeuwen/go-bindata (bonus is that debug mode accesses files directly)
Ok, maybe video decoding was not a good example but there are plenty of applications that require real time / predictable performance. 
It would have been nice to mention that query params (`?` in the video) are database specific; it's one of the biggest points of confusion I've seen for people who are new to `database/sql`; they see a tutorial using sqlite or mysql and think that postgres will be the same (or vice versa) and it isn't. Also, I think it's understood at this point that while the database/sql docs are good they don't get people to the point where they understand it well. It'd be good point people to more comprehensive documents that are maintained by the communty like http://go-database-sql.org/ or (shameless plug) http://jmoiron.github.io/sqlx/
That answers the question. I think best of both worlds would be set the compiler with a specific latency/throughput ratio so that you can get either more throughput and higher latency or the other way around based on your requirements.
i use this often and it works flawlessly.
Hmm. Seems like a slightly less featured [CaddyServer](https://caddyserver.com/). Why should someone choose this project over that one? Not asking to be a dick, but seriously wondering what benefit there is here.
That's what I thought as well, but maybe it's just me that can't figure it out. Starting *$ caddy* plain, it serves the local directory and even notifies back: "Activating privacy features... done.", however if I go to "*https://localhost:2015/*" Chrome throws an ERR_SSL_PROTOCOL_ERROR and there's nothing.
The bit about docs not having many examples resonates with me. Some of the official docs don't have many examples, which is a bit of a concern.
I don't know. IIRC if you're connecting via ODBC then `?` should work. Postgres requires `$1, $2, ..$N`, oracle uses `:named` style params.
Shorter: ``` $ caddy gzip ``` Then load localhost:2015.
I plan on doing that at some stage, real life has a huge stranglehold on me at the moment. 
I'm guessing you were running in an environment with a $HOME different than you thought it was. (That's the usual case for that.)
That's what I had in mind, I will dig in that direction
I was wondering if gzip was an acceptable CLI argument, but it wasn't listed on that page.
Get off Reddit. :-p
You first! 
How can I? 
Thanks for the info. Next time report the error please. ;) Will be happy to look into it.
It actually does. A lot of effort has been put into making nginx safe, and making it safe to run as root. Effort that probably hasn't and shouldn't have gone into your Go binary. Unless you implement the privilege-dropping in a Go binary yourself, running nginx as root *is* safer than running that Go binary as root. I'm not sure why you're disagreeing on this, it seems obvious. Even if you're running them both setcapped, nginx is probably safer. It boils down to whether you trust yourself to implement security better than the people behind nginx. I don't. You might.
You're welcome!
AFAIK mgo is a driver, nothing more nothing less. Guess you're responsible yourself for implementing stuff as soft-deletes etc.
What I meant was you don't need to start of by explaining what a class is, or gloss over it. When people start out they start out they cargo cult. The more boilerplate they have to deal with to get simple apps running the more things the teacher has to go over. In the sample I gave they are already a lot of concepts you have to start with, what is a function, what is a package, how are functions called, what is string, why is main special. With Java you have to add to this the burden of classes, which brings in all of the conceptual baggage of OOP. That's a lot to gloss over. At the same time you are teaching people what a programming language is, what is an interpreter, a compiler, a terminal, about text, text editors, and why programers still use text. It is a lot to take in at first, and the fewer and simpler concepts you have to introduce in the beginning the better. That's why Go is better in this regard. Less is brought in to start, you still have to explain OOP, and structures but those things can be push to later; instead of it having to be all front loaded. This is, also, why Javascript/Perl/Python/Ruby are easy to start with. You only have to start with the interpreter, functions calls and strings. But, I believe static types are actually better for beginners because they forces them to think about those types of things; and the compiler will help them out, instead of the runtime. Who's errors with stack traces are not as good. (Elm, and Perl6 do this part better then Go, and error reporting always could use improvement.) This is the reason I think Go is actually a good first language. The compiler will help you, with function calls. (Knowing why something works and how, types provide some docs towards this.) Go tools make coding consistent and easy, especially Go fmt, and Go run. Fewer keywords and standardized ways of doing things make it easer to keep everything in your head. Modern general languages (any language from the 1970's onward ) tend to be big, and have very powerful abstractions. These things are great for productivity, but can hinder understanding and readability; which is harder for beginners. Take modern Perl 5 for example, it's got one of the most sophisticated OO systems (MOOSE, or Perl6's object system) to date. This sophistication leads to abstractions that can be hard to fully grok. This allows, small amounts of code to do a lot, but at the same time for someone new can be daunting and a challenge to understand why something happens. Go by eschewing this, and insisting on be very explicate aid's in understanding, and beginner comprehension. 
(shameless plug) You can use the Go plugin for IntelliJ and have it highlight (and even autocomplete if you connect the IDE to a supported database) your sql queries written in strings, see this example: http://imgur.com/a/YwPYV More over, IntelliJ can basically inject (as it's called) any supported language there (with various support for features such as writing Go inside a Go string).
Very nice! 
Ironically I don't find myself writing all that much heavily concurrent Go, my favorite stuff are things like its flavor of interfaces. This is awesome though; a good reminder of how Go provides you what you need while staying out of the way.
I'm pretty new to Go....Why use sync.WaitGroup{}? EDIT: Nevermind. It wasn't clear to me in the article but this answers the question of how to have only n workers work at a time (rather than launch all 15 goroutines at the same time we launch 5 at a time). The code was also confusing. Put time.Sleep() at the end of doWork() made things clearer. Here's the cleaned up code: https://play.golang.org/p/542brhlfYP
Caught. http://imgur.com/L3KbkZ7
Thanks all for your time and suggestions!! I really appreciate it :))
 I disagree because it is incorrect. 1. nginx is not by design safer than any other HTTP server when running as root. 2. nginx is not by design safer than any other HTTP server when running with privilege dropping. 3. nginx is not by design safer than any other HTTP server when running as a regular user. I know that you mean "nginx *with privilege dropping*" whenever you say "running nginx as root", but as it isn't what you're writing, I'd like to underline it thoroughly: Running nginx as root in a regular environment, without privilege dropping, *is not safe and never will be*. Period. On to the important parts. I do indeed agree that nginx is a *very* tested piece of software (that is, a HTTP server), but we all know that this by itself does not provide guarantees when it comes to security (openssl, I am looking at you). Not only that, nginx is in active development, so there are constantly added features, bugs, and possible security issues. Nginx has no magic sauce when it comes to this, and is "just" a good quality piece of software. It is not implicitly safer than any other non-terrible piece of software, and especially not your run of the mill Go HTTP Application for a few reasons that I'll explain if you feel like a bit of reading. Nginx is a complicated HTTP server that can perform a lot of tasks, usually ending out in either static files being served or application logic being called (through HTTP, CGI or others). People don't really write HTTP servers in Go (except for very few cases), nor generally write the application for the sole purpose of serving static resources (which http.Dir implements for you if you want to go there). They write application logic in the form of request handlers for net/http, with all platform, network and protocol details abstracted far, far away from them. This HTTP server, together with the runtime and stdlibs, is shared by everyone using Go and is used in production by big companies (Google included for some things, if not mistaken). It's also very simple (much simpler than nginx, which like Apache is getting to a point where it can do everything from caching your files to clipping your toenails), and assuming the Go compiler, runtime and stdlibs don't break (which of course is also an assumption that nginx holds), bugs can basically just result in resource exhaustion (cpu, memory, fds) and cause the application to crash. This is an availability concern, not a security concern. Now, the request handlers can of course do *very* stupid things (read and write to arbitrary files, perhaps? direct code execution? who knows), but unless they tried to make a static asset server that could be replaced entirely by nginx (which is also bundled with net/http: http.Dir), this application logic would still be present if you put nginx in front and proxied the requests either with HTTP, CGI, uWSGI or whatever communication mechanism you can think of. The security implication by this application logic therefore does not change by the introduction of nginx. I believe that this would be the most common reason to even consider dealing with a HTTP server in Go in the first place. You should also remember that Go is a memory safe language, C is not. While I, unlike what appears to be the popular opinion, have *no* issue with C (seriously, I like C), and indeed believe that safe C is both possible and an accomplishable goal, I also acknowledge there is a whole class of bugs that can occur in C that should not be possible to trigger by a user of Go (or Java, or ...). Bugs ranging from nearly impossible to debug crashes to remote code execution exploits. Even considering that they can occur in very obscure conditions (compiler bugs, runtime bugs, or code doing bad things with unsafe or cgo), the chance of inducing this class of bugs is much much smaller. Believing that nginx is a safer HTTP server than net/http is an incredibly silly statement. Even if you rolled your own HTTP server entirely, doing so in a "safe" environment means that the security issues are mostly pushed into the step where you handle the requests. If you manage to perform a stack smash, abuse a use after free or anything like that, and you didn't do it yourself with unsafe/cgo, then it's Go itself that is broken, and the problem is shared with everyone, not just HTTP servers. I'd even go as far as believe that net/http is safer than nginx even if you ignore the memory safety, due to Go's TLS handling and HTTP implementation is much smaller and simpler than nginx + openssl. The fact that openssl is avoided is a security feature in its own right, for reasons that I doubt I need to mention here. To recap: 1. Running any binary as root (that means no privilege dropping) is security wise an awful, awful idea, unless the environment is designed specifically for that purpose. nginx is no exception. 2. Running any binary as an unprivileged user, using privilege dropping from is security wise acceptable as long as the time as root is minimized and only simple tasks are performed, but it is a terrible hack around archaic and broken "security features". Your run-off-the-mill C application won't do this, and your run-off-the-mill Go application won't do this. "Production-grade" stuff does it. It's not (much?) more difficult to do in Go. In the worst case, you can use cgo for this. 3. Running any binary as a (very) unprivileged user is acceptable (that is, still technically a huge security concern, but the best we can do). Use setcap or port rewriting to make this possible on Linux. 4. Always design your systems so that exploiting an application will have minimal damage. Also expect people to have a privilege escalation bug at hand, so ensure that systems are separated. 5. Assuming that A is safer than B is ignorant, unless you have found or know of security issues or concerns in B (e.g. poor track record or poor design, both which apply to OpenSSL, terrible file path sanitation if you just serving files, which can easily happen for a home-rolled server, etc).
&gt; I know that you mean "nginx with privilege dropping" whenever you say "running nginx as root", but as it isn't what you're writing, I'd like to underline it thoroughly: Running nginx as root in a regular environment, without privilege dropping, is not safe and never will be. Period. Well good. I'm glad you acknowledged that you knew what I meant before you posted a huge wall of text arguing against… what you know I didn't mean? Did you realise you initially misunderstood me and then still wanted a reason to spout all of this at no-one in particular? I'm so confused right now.
I have a similar issue, it does not seem any basic UI framework that works with gomobile exist to help with these issues.
You can do the same thing with channels, but it's going to be more code and not necessarily as obvious what you're doing.
What's this for? Googling suggests that 9p is a Plan9 networking protocol, but it's not apparent to me what the use cases for this are. I'm guessing most Gophers are (at best) only nominally familiar with Plan 9, so more detail would be great.
I have been using [gin](https://github.com/gin-gonic/gin) lately and really like the routing/middleware system that it provides. Using JWT is a good idea because you don't have to store the session state on the server.
Good points all around, although I've used '?' successfully against a postgres database, using the https://godoc.org/github.com/lib/pq driver. I think that using sqlx would be a very good topic for a screencast. Mind filing an issue at https://github.com/arschles/go-in-5-minutes/issues for that topic? Finally, I've added a mention of go-database-sql.org on the episode 13 page (https://github.com/arschles/go-in-5-minutes/pull/69). That should make it onto the site shortly.
It was released as part of Docker's wider code drop relating to their ongoing efforts to bring OS X and Windows up to speed with a native Docker capability. https://blog.docker.com/2016/05/docker-unikernels-open-source/ More specifically this library was part of their `DataKit` component. The example given on the github project page is for exposing and interacting with a github repo using a filesystem API via the aforementioned 9P protocol library. https://github.com/docker/datakit 
JWT's are nice because they provide: * built-in expiration time * custom data in payload that can't be changed (if somebody modifies the payload it invalidates token) * is standardized and has good packages in many languages
Just for the sake of it, an author of some popular Go package should move the code to another, offensively named github account, like `LongJohn`, `shittypanda` or somethng similar (we already have BurnSushis, codegangstas, vipers, ant0ines and so on). I'd very much like to see the faces of all proponents of remote imports when they update their code with `import "github.com/LongJohn/cli"`.
This implies that 1) the code that needs to wait knows the amount of work that needs to be done, and that 2) this value will not change while it's waiting, which isn't necessarily the case.
I have a Go process with 252 days of up-time, it has several long running go routines, no problems.
The issue you might be referring to is leaking goroutines, i.e. goroutines that are blocked on a communication that can never succeed (for example they try to write to a channel whose reading end fell out of scope). And yes, if that happens, it's an issue. The issue is basically what a memory leak is in the C/Java/Python world. It's the one thing that makes writing concurrent software in go tricky-ish. Though it's still far less likely than just a memory leak.
In what world is reflect "performant"?
No, for AAA titles Go is not a good idea, because first it has GC and second point is that in AAA titles you program in a way that you need to control everything, even how cache lines are getting filled included. To answer your questions: 1. Depends on which workloads, for AAA games i don't think it will. 2. Depends on your data, game design, reuse of objects etc. But for 2016 AAA game i don't think so. 3. Memory safety thanks to automatic memory management, a lot less complex language than C++ so easier to learn and reason about.
There's a "perfect storm" mix that can create issues: - Multiple long-running goroutines - Without any blocking calls (I/O, channel, syscalls, function calls in general) - Running on a small number of cores - Generating lots of garbage Combined, this will mess with the runtime (scheduler and GC) to cause rough performance. These situations are rare and usually are a result of terrible design and no refactoring. It's, more-or-less, a subset of the "bad code is bad and you should feel bad" lemma.
Hey there. Other newb here. Built something for the gopher gala earlier this year. It is by no means good or production ready but it may give you an idea or a direction to follow. It connects to postgres, uses JWT, password hashing, and has some basic sql queries. I am actually gonna start working on it again now so it will get better I hope. :) But feel free to take a look: [https://github.com/jebrial/learnlink](https://github.com/jebrial/learnlink) edit: I forgot to mention I am using GIN right now but I may look into rolling my own with fasthttp. edit2: I like GIN and I would only be doing the roll my own for learning purposes although I hear fasthttp is mad fast.
&gt; I heard that many times Consider anyplace that says that a "poor source" for Go knowledge. &gt; is it true Not even a little bit. 
thank you!
Now, editor is supported. Similar to `git commit`. See example [21](https://github.com/mkideal/cli/blob/master/_examples/021-editor/main.go) and [22](https://github.com/mkideal/cli/blob/master/_examples/022-custom-editor/main.go).
Go Indie and use Go.
"This is not a bug in Go, by the way. It's intended behavior that can be used to do some pretty advanced stuff. See the "function closures" links at the end."
1. no, 2. yes, 3. the same as for every kind of software: Readability, Maintainability, Memory Safety,…
Yes. A couple of go people have acknowledged that, if they'd do it again, they'd do it differently. But it's too late now, so it's a caveat you must get used to (but on the other hand, you can get used to it, trust me :) )
IIRC Andrew Gerrand mentions it in this chat with the Go team, here: https://www.youtube.com/watch?v=p9VUCp98ay4 Can't remember when though.. Also, I guess he was not one of the original designers (?) 
I cant stress enough how good [this](https://www.amazon.co.uk/Web-Development-Go-Building-Scalable/dp/1484210530/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1463652928&amp;sr=1-1) book is. It teaches from first principles rather than just saying "lets implement X framework". The book does assume a certain knowledge about Go already and only has a small section on the basics.
What a fantastic blogpost :) O.P. here, all feedback appreciated. 
Even I wrote a book! https://github.com/thewhitetulip/web-dev-golang-anti-textbook/ Stresses on principles and real examples ;-) I read amazon reviews and found them to be somewhat fake, almost all reviews focus on chapter 9 alone. Apparently the book doesn't have anything other than chapter 9 i.e. the RESTful API chapter
It's behaves similar in other languages, e.g. in C# and Javascript (in case of var loop variables), which also capture variables by reference into closures (instead of by value) and don't create a fresh variable for each loop iteration. I agree that it's error prone and should probably behave different, but once you made the mistake in one language (or read about it) you know that you should check how loops and closures interact before you use them.
hahahaha. My book doesn't contain anything related to REST, but this sunday I'll make sure to learn and write it using a real example Much of the book is based on my learnings I got while building https://github.com/thewhitetulip/Tasks There aren't many open source books which teach the concepts using a real example, much of them are either too high level overview or give too simple example and then expect the user to suddenly understand everything on their own without giving a proper code example
I have just wrote this one using github.com/gin-gonic/gin but you can easily modify it to use net/http. https://gist.github.com/tuxlinuxien/29aa0ddaaa33c506c6220266bbb632a1
This will probably be usefull too: http://justinfx.com/2016/05/14/cpp-bindings-for-go/ 
I remember when I learned this the hard way in JavaScript. Thanks for reminding me how easy is to mess things up as I'm starting to look seriously at Go!
Since November, I've been using Go to build my first web API that authenticates against a RDBMS, returns a JWT, and then allows for 'stateless' interaction for several hours. Some stuff that I see others do wrong that you should look out for if you use them: Add an expiration time to your tokens. Otherwise, you'll have to change your pub/priv signing key in order to invalidate tokens. There are apps on the Google Play Store right now that use a single token for 'login-free' authentication. Anyone can reverse engineer these apps and then use this whenever they would like, for as long as they would like, and appear to come from their app with very little spoofing. The big one to avoid is that the JWT spec has a vulnerability, but it's easy to avoid: https://github.com/dgrijalva/jwt-go/issues/59#issuecomment-88567525
Thanks! =)
No problem!
I simply suggest that it have some sort of expiration time that suits your use case in order to prevent 'master key' access tokens from existing. It's simply an opinion of mine after being baffled by how easy it is to find these types of access tokens in decompiled mobile apps. Mine expire after 6 hours for 'trusted' users, and 1 hour for free mobile app users, though the latter policy might be excessive for most cases. &gt; Also it is beyond me how people can create login-free applications, It's easy. Most developers of login-free, data-driven apps, just assume that the majority of users will never try to find this built-in key. The app just uses one key for login-free access that is ether shipped unobscured in the source code to the app stores (most likely), or is obscured (less likely). EDIT: I think from your other post that you get this, but for others who see this: If it travels over a network to the device, it's now compromised. So design around that, use HTTPS with HSTS, and don't ship keys that you can help to not keep in the open.
Thank you for the detailed comment! Few months back at work I had taken part in building an app using third party API via Java, we used to send a request for a token by sending a username/password and get the token which we used for future requests. If we had done this, then we won't have people being able to generate tokens at whim, correct? If I have my keys in the app source code, then yes, certain people can and will get through to pick up the key and screw up everything.. What approach do you suggest to generate auth tokens? sending username/password to the server in exchange a token or some other way to generate token?
I don't understand why mainstream languages don't pick up on the Haskell style of typing. So much better than anything i've ever seen.
9p is the Plan 9 equivalent of a FUSE userspace filesystem, but being Plan 9, it's designed to be used in a networked environment (which means you can, for instance, mount 9p resources from remote machines, and they don't necessarily have to be NFS..)
ah, I see that vet actually catches when you capture a variable with for loop and "range", which neither of these are. Just regular C-style for loops. However, https://gist.github.com/dgryski/2d2b428f4452f452bb95d390034e9ce5 
I think theyre using Gophercon for that (Denver, July 11-13)
I'm the author of log15, one of the loggers they compare against. This looks like a great approach for folks who need extremely high performance structured logging. The use of a struct with specialized fields for the most commonly logged primitive types is clever. The actual per-op performance numbers are unlikely to matter nearly as much as their focus on removing allocations. Less work for the garbage collector means fewer and shorter GC pauses. A few things though: - I've never seen anyone log more that 5 fields in practice, so the first benchmarks seem a bit overstated - As usual with most performance-focused code: it probably doesn't matter for the 90% use case - There is no Handler interface for customizing log handling. log15 and go-kit's Handler interface is what makes them so powerful and flexible and there's not really an equivalent here. If/when I get back to working on log15, I'll probably end up pulling a lot of ideas from zap. nice work!
&gt; we used to send a request for a token by sending a username/password and get the token &gt; If we had done this, then we won't have people being able to generate tokens at whim, correct? If I understand you correctly, you worked on an app that sends a username and password and then receives an access token of some form in response. With JWT, as you probably know, the app on the server generates the token using its own private and public key, typically during login. I think my last EDIT is a bit confusing about this: I say compromised as in the end-user can view and replicate it. As in, do not make an app without a built-in login-free token that downloads one from a server, thinking you've outsmarted people. Sending a login/pass + some form of captcha if absolutely needed and receiving a ~~one-time-use~~ access token is best practice. EDIT: To be even more clear, I mean one-time-use as in the time from when it's issued to when it's considered expired and invalid.
404s...
GitHub tells me: &gt; One of our mostly harmless robots seems to think you are not a human. &gt; Because of that, it’s hidden your profile from the public. If you really are human, please contact support to have your profile reinstated. We promise we won’t require DNA proof of your humanity. I use GitHub since 2008 and pay for it since 2010 – and that's what I get. Crazy, just crazy. I hope it will be resolved soon, but announcement is really messed up.
Found this: https://github.com/powersurge360/androidSizes
Do you understand the meaning of "If you downvote, please advise me on what's wrong in the comment. Just downvoting doesn't help at all" Does it say that "Hey don't downvote me?" If you have nothing +ve to contribute then sit in the shadows rather than being a sadist and hindering someone else's learning experience.
Thank you! For the API I'll make sure I use the correct method :)
Exactly. ;)
Built (and ran) fine for me, perhaps you have some old versions of some of the dependencies ?
It looks like you have an old version of some dependencies. In particular, your golang.org/x/image/math/fixed that doesn't have the Ceil function, and your golang.org/x/image/font doesn't have the Metrics function. You can try running `go get -u ./...` and then recompiling.
Effortless compilation of a project is a great achievement of GO language. The fact that I just grabbed code and got it running without asking "what platform your code is for and how do you build it" is awesome. I am not even talking about cross-compilation that is easiest I've seen.
Cool thanks. I tried with `go get -u github.com/driusan/de` and it works. I am very happy to see some GUI projects written in Go. I think it's probably the area that Go is lacking the most right now. 
I am assuming that the amount of code you wrote wasn't that much otherwise the project would already be on version control. It's quite likely that the amount of time you need to rewrite it will take much less than finding how to recover the code. That said, losing work always sucks big or small. Also, which operating system are you using? Maybe there is a way to recover the contents of the folder that way.
Really interesting seeing someone doing a real project using shiny given that it's still in heavy development, great as a reference !
Do you use an IDE that supports local history? Unlikely, since I don't know of one that has *good* golang support, but if you're using IntelliJ or something, you can recover deleted code that way.
I'm on Windows. And yes it wasn't _that_ much code. I tried the 'previous versions' feature but found out Windows removed the folder from the list of backed up paths (I'm pretty sure I explicitly added it at one point). You are probably right that rewriting it won't be that big of a deal but since it's annoying to write the same thing again I figured I'd try recovering it first.
Eclipse. While it does have local history, you can't restore deleted projects.
&gt; by game development, I mean mostly AAA titles Let's be realistic here. Who would ever go and develop a AAA title without going through the standard route of using a battle-tested engine and C++? Nevertheless, the indie scene is big nowadays and those games are written in all kinds of languages and platforms. Minecraft is written in Java which has a garbage collector. There are even games in Python and Ruby which are slower than Go. There's absolutely no reason Go is less suitable than Python, Ruby or Java for game development as a language. In fact, as a language I could argue that it could be more suitable for certain tasks due to easier concurrency (like calculating AI paths in parallel). That said, the ecosystem and libraries of Go are not nearly there yet, especially compared to other languages (e.g. Python has pygame). Go has a few experimental 3rd party [engines](https://azul3d.org/) but I am pretty sure that you will have to write lots of code yourself. Of course, what's undeniably a great candidate for Go for any game, even AAA titles is the backend/network systems. &gt; the first one (performance) is specially a curious one, why we cant optimize such bare and simple language to the level of c++ This is all about the Go GC and nothing else. It depends on your requirements and the game type aka how CPU intensive it is. P.S. This is written in Go and gopherjs: [https://awakeman.com/27/](https://awakeman.com/27/) 
For those who are looking for screenshots: [File listing](https://i.imgur.com/SEp5rKs.png) [Editor](https://i.imgur.com/eyIFFQe.png) 
what makes it more idiomatic or the others unidiomatic?
Nice, I notice you also seem to be working on a web browser as well. I personally have a PoC platforming engine built on shiny and mobile that I haven't put on github yet. I also have been trying to make a basic terminal emulator with shiny as well.
I guess to really answer the question you'd just have to look at a body of code and see which behavior is more commonly desired. Personally I'm pretty sure I almost always want a new variable when I'm capturing it in a closure inside a loop. In the rare cases where for some reason you'd want to capture the changing value of the loop variable (honestly, it's hard for me to imagine a case where you'd ever want this -- can you think of one?), it would be easy enough to declare the variable before the loop: var x int for x = range foo The other language I use most often is Objective-C, which gives you a new variable each time. E.g., this will print 1-10 (in random order), which to me is both more intuitive and more useful than the Go behavior: for(NSNumber *x in @[@1,@2,@3,@4,@5,@6,@7,@8,@9,@10]) { dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSLog(@"hello x is %@", x); }); } 
Yeah I've only been bitten once, &amp; now I know to look out for it, but it's still too bad -- (so far) it's never the actual behavior I want! Can you think of *any* instances where you want the Go behavior? I can't. Anyway, I still love Go, of course -- almost all of it's design decisions are amazingly prescient and well thought out. Almost. ;)
I realize it's not an implementation bug, but if we could go back in time, would it not be better to spec it as creating a new variable each time through the loop? If you really want the same variable throughout the loop, that's easy to do: var x int for x = range foo In my experience, this is by far the less common case. It also has the advantage that the behavior is very obvious.
Thanks very much for pointing out these issues!
Thanks very much for your comments!
That's a good idea. I'll try and add some tomorrow. (Maybe I can start with a screenshot in the README of the README..)
&gt; I've come to the conclusion that the W3C's goals are to make the CSS spec so unwieldy that it's impossible for anyone other than the large corporations that make up the W3C to implement them. With how complex web standards are, I find it baffling that everyone thinks that web apps are the future. I often wish that a new simpler standard will come along at some point. ^(It doesn't help that I personally don't like any of HTML, CSS or Javascript) [EDIT] I've been working on my terminal and *some* shells don't seem to return any output. I tried making a small go test app and it works perfectly fine there. bash works fine with my terminal, but oh (the shell written in go) doesn't.
&gt; Doing so with 9P is just a lot simpler, [...] *on Plan 9*. On Linux, choosing to use 9P means choosing to not implement everything possible; on Plan 9, 9P *was* everything possible. &gt; [...] and didn't concern itself with things like block caching [...] And this is why FUSE can pretty handily outperform 9P ;) &gt; Using the FUSE device directly to read and write FUSE messages on the other hand is generally frowned upon, suggesting that one should only interact with the FUSE kernel driver through the library due to compatibility concerns. [citation needed] &gt; FUSE is certainly also not designed with mounting remote filesystems in mind - it's of course possible, but the kernel driver might not be too happy about very high latencies. [citation needed]
Here are some, unordered. You'll want to read more about each of them rather than taking my quick summary of them as the entire concept: * Use as few type conversions as possible. * Operations are typically faster when performed on a []byte vs a string. * Use a bytes.Buffer for string concatenation. It's the fastest way that I know of, though not if you need to clear the buffer to reuse it. * []byte("") is actually a type conversion of a string to a byte slice and does the opposite of what you might would think in terms of performance. EDIT: Unless your specific function takes []byte as an argument, you're unnecessarily allocating the string AND the byte slice. * Preallocate where possible. Dynamic resizing takes time and creates garbage. * Worker Pool(s) * Use the ffjson package if your API is returning large JSON objects. It can be around 2x faster than the standard library package. * Return your for loop values from conditional statements as soon as possible. Don't necessarily wait for the loop to reach the end of the range before returning values. * Don't make a generalization if you're unsure about what could happen and then over-optimize your codebase. It will cause problems. I promise. Whether or not you use this key-value store, this slideshow has some helpful tips and some examples of some of what I've mentioned: http://www.slideshare.net/cstivers78/gotham-go-nov-2014 EDIT 2: Just noticed that you said "or other aspects." * Research to find the appropriate standard format for your data. Ex. RFC3339 timestamps, GeoJSON for geographical data that would've otherwise been returned in custom JSON fields. This just makes things easier for those who must implement a client for your API. * Use proper HTTP status codes/HTTP methods. Ex. GET requests should never modify information on your server/app cluster, only return it. * Think about how someone might abuse your API and then try to break it yourself. Creatively testing security, in my opinion at least, is more important than performance. * Most importantly: Keep it as simple as possible.
Don't forget rate limiting!
You are awesome man, thank you! If you have time, can you contribute to http://github.com/thewhitetulip/web-dev-golang-anti-textbook. my book hit 100 stars today
To be fair, this one uses code generation, that does set it apart
I'll definitely submit a PR if I see something that could be added or improved. I briefly read part of it earlier today and liked what I saw.
I can't really see a use-case for capturing not the current value and I guess that other default would probably be better for all users. I can only guess it is the way it is in Go and other languages for some optimization and implementation reasons: The compiler must either use new memory for each loop iteration or it would need to perform some escape analysis that tells him that the current iterations value escapes the iteration and needs to be copied.
I don't do fuzzy testing on this kind of stuff. Just make sure that every code path is tested. You should write out all of the possibilities, and test each one. At the very least, you'll have. * Valid email, valid password * Invalid email * Valid email, invalid password * Valid email, no password * No email Then, depending on your system, you could have more outcomes. What about lockout after n attempts? Does the lockout have to be reset by an admin, or is it on a timer? Are attempts throttled in any way? (e.g. Users must wait at least n seconds between attempts.)
This is really cool! I had been wondering when I'd start seeing some x/exp/shiny stuff, and I hope to eventually see something like this exit experimental.
https://github.com/pankona/gomo-simra
https://github.com/pankona/gomo-simra
Is there any way to excecute a comman on a whole file, like gofmt or goimoprts?
That's a good question! Currently, no (other than writing by writing plugin), but it would definitely make sense to hook up the selected text (or whole file if nothing is selected) to the stdin of the program exec'd with middle click/enter to enable that style of workflow without writing a plugin and should be a pretty small change [here](https://github.com/driusan/de/blob/master/actions/execute.go#L104). I'll create a ticket so I don't forget..
Impressive. :) One issue I've noticed: If I keep `j` down for a moment, it will keep scrolling long after I've let go.
Just curious, but why are you trying to recreate the services? [SQS WSDL](http://queue.amazonaws.com/doc/2012-11-05/QueueService.wsdl). [SNS WSDL](http://sns.us-east-1.amazonaws.com/doc/2010-03-31/SimpleNotificationService.wsdl). Keep in mind these WSDLs may be out of date, they're several years old. You'll also want to refer to the services developer guides and the AWS General Reference. [General Reference](http://docs.aws.amazon.com/general/latest/gr/Welcome.html) [SNS Developer Guide](http://docs.aws.amazon.com/sns/latest/dg/welcome.html) [SQS Developer Guide](http://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/Welcome.html)
Thanks for the suggestions
Does it eventually stop? It might just be a backlog of key events that need to be processed before the rendering catches up.
To critique your points, or rather provide a counter-argument: &gt; Requires state on the server to revoke the token on-demand The simplest way is to implement a blacklist, but in my case where every user has a different secret to sign their token, I only have change their secret in the db. I believe this point is true for the alternative as well. &gt; Disallow 'permanent' sessions (related to bullet point #1) You could just set a really long expiration time on the token. &gt; Require some sort of front-end manipulation to shove them into the request This isn't difficult at all, just a matter of setting a header on your xhr requests to protected routes. &gt; Custom cookie payloads can be authenticated and encrypted JWT has a protocol called JWE for encrypted tokens, but its generally best practice to not send sensitive information in auth tokens in the first place. To your last two points there appears to be some confusion. JWT's and cookies are not mutually exclusive, as JWT's are commonly stored in cookies. 
You have a valid point with the blacklist, however in my situation I only have to change the signing secret for the user that I need to invalidate. I know about the security issue that is brought up, although thankfully it has been taken care of in the popular libraries. 
yes, that's very helpful. thanks!
I want to be able to test SNS/SQS messaging without having to use AWS itself. I tried YOPA but it apparently is not compatible with Python/BOTO as I keep getting 400 errors when I call any SQS service s using the celery event processor. So I thought I would re-write a developer setup in golang as a learning exercise as well.
1. Very unlikely to be at the same speed as C++, however it's very likely that at some point it doesn't matter that much. 2. Remember that now AAA means targeting VR, i.e. 120Hz for both eyes, i.e. which roughly leaves 8ms per frame. For something to be negligible it should be below 0.5% i.e 40 microseconds. 3. There likely isn't much. The reasons Go is nice for servers doesn't necessarily make it nice for games. Manually managing memory in games isn't difficult. Goroutines really don't help that much. And finally, you would lose a lot of prior art by switching to Go. But the language itself is much simpler and more fun to use. And there is fast compilation. Language, like Jai, would have more benefit. Now this is only about AAA. When you go to AA and lower, the language safety becomes more important since the skill of the developers (probably) decreases. Similarly there's less pushing of the boundaries, hence more room for inefficiencies.
Just curious, would sleeping the goroutine for a random amount of milliseconds before returning an authorisation response prevent timing attacks in case there was a timing attack bug somewhere else?
Yes it does. Still, it renders the editor unresponsive for a while, and I thought you might consider that a problem.
Yes, it's quite surprising that many large projects don't have exhaustive test suites for authentication. Thanks for the tips!
The oddest part of this (disabling HTTP/2) is due to the HTTP/2 cipher suite black list. https://tools.ietf.org/html/rfc7540#section-9.2.2 &gt; The black list includes the cipher suite that TLS 1.2 makes mandatory, which means that TLS 1.2 deployments could have non-intersecting sets of permitted cipher suites. To avoid this problem causing TLS handshake failures, **deployments of HTTP/2 that use TLS 1.2 MUST support TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 [TLS-ECDHE] with the P-256 elliptic curve [FIPS186]**. From the TLS 1.2 spec we see the problem: &gt;[**9. Mandatory Cipher Suites**](https://tools.ietf.org/html/rfc5246#section-9) &gt;In the absence of an application profile standard specifying otherwise, a TLS-compliant application MUST implement the cipher suite **TLS_RSA_WITH_AES_128_CBC_SHA** (see Appendix A.5 for the definition).
Oh, I do, I just meant that, technically, the reason it's still scrolling is because, technically, you pressed the button that many times. At any rate, for an unrelated reason I just committed a fix that makes the rendering use much less memory, which has the side effect of making it much faster, so now, so you shouldn't have this problem if you update.
Can confirm, not a problem anymore.
This sounds really interesting. The readme mentions Kafka. Does Kafka run well with this project in its current state? Or does Kafka leverage some of the features that aren't yet supported?
I haven't had a chance to try it myself, but this [issue](https://github.com/glerchundi/parkeeper/issues/3) points to some potential problems with kafka. It would be interesting to see if the problem still persists with kafka 0.9.x.
pretty awesome talk, thanks for sharing
1000x speedup! I switched to Go from Python, and it seems odd to me that the default linear search in the language is so unoptimized.
Okay, now there is for anything that reads from stdin and writes to stdout (like gofmt or sed. I don't know about goimports, I've never used it.) de will pipe the selected text (or the whole file if nothing's selected) to the command's stdin. See USAGE.md for details (it's a little different than acme if that's what you're used to), but the short version is: You can just add "|gofmt" (or any other command) to the tagline and execute it from there to replace the selection with the output of piping the command to gofmt. (Technically could could also do it from a comment inside the file, but I doubt you want to pollute your source code like that.)
Wow. I really thought I knew the std lib backwards and forwards, but that package escaped my notice. So weird! Thanks! -jeff
Thanks, it's a great talk. Heard many good words about this talk before and it's finally available for everyone. 
Linear search is not the default algorithm for doing substring lookups in Go. `strings.Index()` uses [Rabin-Karp](http://courses.csail.mit.edu/6.006/spring11/rec/rec06.pdf) for strings larger than 31 characters.
Nice. I've tried it out but with no luck. How it's suppose to work? I tried: ":|gofmt&lt;Return&gt;" and nothing happened.
That should work exactly like that, it's definitely a bug. You can comment on GitHub issue #2 if yo u have any insight, but otherwise fixing this is probably my highest priority for de since without it I can't do things like find/replace with sed. (It's weird, I could have sworn that it was working perfectly when I committed it, and now it's not working for me either..)
Zookeeper without java!!! I'm going to be excited once you have ephemeral nodes and watches
The readme is very short. You could explain why you did it, where it goes, what the current state is.
Second vote for more/better docs. If you want people to use your project appeal to their intrinsic laziness. 
It's been there since pre-1.0 days. It was there for godoc and we could've removed it and probably should have, but oh well. There's a dozen packages in the stdlib I'd kick out if we did it again.
What tools are you using it with?
Should work now if you update. There were a couple issues, I think I had committed something that wasn't as ready as I thought prematurely (making executing things from the tagline work really unreliably, and | not always do the right thing when working on the whole file, and on top of that there was a bug where the last command in the tagline couldn't be executed.) It should all be fixed now and work as documented now, if not you can open a ticket.
In my project I've set memory scanning for passwords as the rigorous test idea, to be sure passwords aren't left in memory and (hopefully) are encrypted.
In my applications I have a few constructs that start goroutines that live for the entire lifetime of the application instance. These use very little time and memory though, doing things like copying or routing a message on request and/or listening for a timeout signal. For persistent applications (like a web server) the time, processor, and memory use of the goroutines define the limits of traffic the application can support. So, assuming you are writing bug free code, what kind of performance are you looking for?
Extended documentation that includeds current status and examples of use using awscli tools. hope this helps. https://github.com/p4tin/GoAws 
the main reason is that you can't have two replicates, (one private repo, one public repo) The private one is used for internal development. by the design of "go get", you can only choose one replicate to use.
&gt; the actually package name is the last part. This is correct in simple cases. let's say you have package foo/bar/worker and foo/bar/utils. And your foo/worker requires function under foo/utils. You will have to define "github.com/foo/bar/utils" instead of just "foo/bar/utils" or "../utils" and this is annoying
This is an incredible talk by Prashant that I really want every gopher to see. It's simply a collection of best practices and steps one can/should follow when profiling/optimizing some Go code. It's also incredibly useful as a quick reference for some of the harder to remember command names and flags to get some relevant tasks done. It's also inspiring to see how well he can present something so coherently and well explained while doing live coding in front of a large audience (I guess you don't see this part since it's a screen recording).
Or: How *I* organise
tks Done
Ouch. As soon as my project gets more than a few lines, I `git init`. I learned the hard way to also push that up every time something gets stable(ish). I was working in sublime and every now and then the auto-complete would stop working and the best fix was `rm -rf $GOPATH/pkg`. I accidentally did `rm -rf $GOPATH/src`. Oh, that sinking feeling. I changed that command to an alias, started pushing up branches more frequently, and now am on vscode. All three are solid improvements.
&gt; assert.Equal(validate("foo bar ! 1 2[]()&gt;&lt;"), "foobar12", "should be equal") No, thank you.
What about leap-seconds and other TZ nightmares? ;) AFAIK it's a main reason stdlib is settled on hours as a top value.
&gt; clone of the AWS SQS/SNS systems You might want to state that way, way, up front. Like, in the project name. AWS is a huge ecosystem.
https://github.com/p4tin/GoAws/blob/master/gosqs/gosqs.go#L43 You're accessing a global map without any concurrency protection. That's racy.
Sooooo.... "golang-lib-[pkg]" is still good?
What is your plan for SQS API/behavior coverage outside the very basic path like long-polling, delayed messages, batch send/receive, message attributes, dead letter queues, etc? 
Once the basic SQS and SNS APIs are covered, I will work on the features that people want to see. If you want something special I encourage you to open an issue on github. Thanks for you interest in the project.
I have created a PR for this issue #11 since I am not a concurrency expert in golang can you review it before I merge it please? https://github.com/p4tin/GoAws/pull/12
False. Google recruiter told me the only languages they allow are java, javascript,C and pythom .. but not golang. 
Not all recruiters and not all interviewers are the same. Experience may vary, even between the recruiter and the interview.
Don't name it httpd either, that's Apache. 
&gt; 1) use interfaces Interfaces are slower than using direct type. Why would you introduce a performance penalty just to make testing easier? 
@allhatenocattle my bad. I also curate http://importpython.com using the same backend and curated it to the wrong issue. Sorry about this and thanks for finding it.
The algorithm seems to be happy with any port number between 1 and 65535. I wouldn't like to start a new service only to find out that its port is blocked by an ssh connection. Also, if the algorithm generates a port # that is already in use, the user has to wait for 30 seconds before another connection attempt can be made. Apart from that, I really like the idea. A while ago, I spawned a virtual server on Vultr, and only a couple of days later, someone tried to brute-force into the system by connecting to port 22 every 3 seconds (which caused unusual CPU load on this tiny VM instance, which was how I noticed this attack in the first place). With this ssh fluxer in place, the attacker would have run into a closed port 22 and might have just moved on to the next machine.
Why not? What's stopping you? Just to be clear, I'm not trolling. I work at a very large company with 4000 employees and we have ssh key policies all over the place.
This is even worse than projects that use packages "common", "util", "models" etc.
How do you enforce those policies? I don't know of any way to enforce the age of a key. And since you can't enforce key aging, that I'm aware of, you can't ensure that a leaked key is only usable for x period if time like you can with a leaked password.
What's the point behind this? Why would it ever be useful?
As luck would have it, recent OpenSSH allows you to require several `AuthenticationMethods`. E.g. AuthenticationMethods publickey,password publickey,keyboard-interactive
Well, there is no loss of type safety as long as I am not using type assertion and even if it is used it is perfectly go-idiomatic to use "comma check" notation or type switch.
I considered this, but haven't benchmarked. In my experience, loading and de-serealizing such a data structure from disk usually takes way longer than building it in memory. It would be interesting to see how it plays out here
looks awesome! subscribed :) Looking forward to the next issue!
github electron + go-rest-api + optional gopherjs-middleware
In addition to jump hash ( https://github.com/dgryski/go-jump ), I've also implemented two other consistent hashing functions from Google: Multi-probe consistent hashing: https://github.com/dgryski/go-mpchash Maglev hashing: https://github.com/dgryski/go-maglev
Now returns cleanly on success, and panics on failure. fail := func() { go func() { _ = []struct{}{}[1] }() var c chan interface{} &lt;-c } n := 37 for i := 2; i &lt; n; i++ { if n%i == 0 { fail() } }
While it is more a matter of style thing, instead of doing: if r.Method == "POST" { // all your code here } I prefer to return early: if r.Method != "POST" { return } Same goes for !db.Valid instead of db.Valid check, this way you don't get all these nested control blocks.
There seems to be another active attempt at wxGo though it's not fully ready yet. Maybe help out there? https://github.com/dontpanic92/wxGo
I've had luck with go-qml https://github.com/go-qml/qml
we have just came up with a [client and server implementation](https://github.com/envimate/nrpe) for NRPE, that supports SSL as well I have some examples for the client in this [blog post](https://goo.gl/bGKRMd) golang is so awesome to work with, things are getting done fast! :)
when a user has their publickey installed on some server, what's keeping the corresponding private key on the corporate asset? put another way, if you're just using ssh keys, how do you know that the user 'john' who just logged in with an ssh-rsa key is actually john and that he's coming from his work laptop, rather than malory who compromised john's computer and stole his private key (it's living on disk after-all and john hates typing a passphrase so he used an empty one despite the policy saying that he can't do that). the point is, there's nothing in the ssh-key spec that allows for key expiration ala ValidBefore/ValidAfter. I can imagine a bailing wire and duct-tape setup where you have publickeys stored in ldap with validity periods and your config management system constantly updating the list of authorized_keys, but that's super brittle and will likely end up failing in ways that leave you exposed. if you want keys that actually enforce time-based restrictions, then you need to look at ssh user certificates. you'll need to manage a CA, but it's definitely worth it if you've got thousands of employees. ssh certificates also come in the host key flavor, which allows you to completely get rid of the "never seen this host-key before" or "hostkey changed" error messages.
If you're interested in these types of structures, you may also want to read about linear trees where given any point in the tree you can determine its exact position, children, and parent, without having access to any other structure containing such information. It's "linear" since you typically store each point in an array instead of a recursive structure. For example: https://github.com/dskinner/quadtree
Since you're the only one who's offered any help, I'm getting closer. Here's what I have now: https://play.golang.org/p/9DLXU2gfMC Despite `main` and the infinite loop goroutine being locked to the two available OS threads, the user can still create a new goroutine and block main to panic within that goroutine.
How does this compare with Google's FarmHash (Go implementation [here](https://github.com/dgryski/go-farm))? I'm building a web crawler and one structure I'm thinking of using involves splitting up domains among various worker machines using hash(domain) mod n, where n is the number of workers. One of the issues just thinking about it is what happens if another machine needs to be added, changing the mod value? Does this hashing algorithm aim to solve that issue? How would it be implemented? Edit: Just posted this and saw your comment @dgryski :) Thanks for coding these in Go! Could you recommend which one you would use for my scenario?
It's just the first issue. Give the guy some time. You don't know if it's automated or manually curated. And you seem to be running a handful of newsletters yourself. You don't have to look down upon a rookie up start. :)
As far as I know it's not possible and I would be happy if this doesn't change. go install compiles and creates the binary in GOPATH/bin but it also compiles and creates packages in GOPATH/pkg no need to add hooks or anything else to a well defined command. If you want to install something, you can use a make file or anything else that's used to achieve this. You can read more about go install here: https://golang.org/cmd/go/#hdr-Compile_and_install_packages_and_dependencies
And there are even TOTP 2fa support with libpam-google-authenticator
&gt; sub claim thank you!
I appreciate I can write a `Makefile`, but then it becomes less idiomatic and more of a custom-deployment. I guess that's the way I need to go though. 
I'm not too clear on a lot of the internals of the runtime, but how about the following: runtime.GOMAXPROCS(1) runtime.LockOSThread()
go install is not meant to deploy anything. It's meant to compile and put the artifact in a directory. It's not about being idiomatic or anything else that could facilities the deployment of a Go application. There's also no idiomatic way of deploying a Go application, it's dependencies or other tools related to the said deployment process.
Sure. I guess I was trying to say that most of the installation-instructions for projects I see are of the form: go get ... $GOPATH/bin/foo -arg1 -arg2 .. -argN Rather than: git clone github.com/user/repo cd repo make &amp;&amp; sudo make install The latter case is obviously trivial for copying a binary, perl script, config-file, etc, etc, into `/usr/local/{etc bin}`. I have the feeling that if I go down that route my project will become just that little bit more annoying to install, but if that's what I have to do then so be it :)
I have been having some strange thought about using go generate to do something similar. But I am afraid of even try it :)
A quite ugly way i guess would be to create small bin wrapper programs in go that execs $GOPATH/src/../../file.pl etc. But yeah... ugly :)
You need sudo for make install only if you copy something where the user doesn't have access to. And if your user can copy paste the first option, it can certainly copy paste the second. Finally, I don't understand the case where you'd need a file, especially a Python one, to run the Go binary. Can you provide the repository you are working on? Or the concrete case for this. Maybe I'm missing something obvious from your need. 
Exactly. In which case it's a good idea to have the password as another authentication factor, so that gaining access to the private key isn't enough. I always hated that you can't require the client to use a keypair that is strongly protected on the client side. This allows the server to place requirements on a password, even if it isn't the passphrase used to protect the private key.
true, but the problem with pubkey + password is that nothing's preventing the user from using that private key from a non corporate asset. I had someone complain about not being able to ssh into prod from their phone once. no, just no, you will not be sshing into prod from your phone.
You're comparing apples to oranges. The analog would be: `assert.Equal(value, "foobar12", "should be equal")`. This seems perfectly readable to me. My biggest grievance with the standard testing mechanism is that I have to constantly repeat the error message. `t.Fatalf("Wanted %v; got %v", wanted, got)`. I write a lot of test cases, and it's pretty tedious. I don't use this assertion library, but I can definitely see the appeal. &gt; I'm really starting to appreciate Go's philosophy of "writing tests in Go are just writing code in Go." Using a testing library is not inconsistent with this statement.
Maybe that should be controlled some other way? VPN? SSH is quite complicated as it is. Often it is better to build security out of simple well-understood layers. Preferably orthogonal so that they don't interact in "interesting" ways.
I've tried that. Somehow the user can break out by blocking the `main` goroutine. https://play.golang.org/p/Gm4QabOFl_
I can see where this becomes a problem when you have a project with many many packages in it. Something that I have seen become more and more prevalent in packages i see on github. I have seen webapps with a db package, a template package, a handler package, etc and it seems that it should all be one package. Look at the "net/http" package inside the standard library. It has client code, it has server code. Having this in the same package is good. If you are running into relative import issues a lot maybe you should try to cut back on the number of packages you need to import. Also remember: " little copying is better than a little dependency"
gotk3 is workable, all the core stuff for building graphical interfaces are there.
Thanks so much for your response. In the original design, I had a main URL priority queue that ran on a machine separate from all of the workers. Each worker would communicate with this main queue server to pull the next URL to crawl as well as save new URLs that had been found. This single database/queue design though was an obvious bottleneck, but I didn't realize how much until I tested it. It turned out to be pretty bad (I'm using MongoDB as the priority queue for now vs something like Redis), and only one worker could run alongside the queue server. The queue requests are taxing, but also keeping every worker polite and preventing two or more workers from crawling the same URL/domain at the same time took up even more resources. I could scale up vertically adding more power to the machine, but to be honest I would much rather spend time trying another design of the crawler structure and improve it through software instead of hardware. So after a reading a few other examples and some papers, I think there's a decent way to go about it with the domain hashing. Could you give an example of how you would structure the set/range/topic portion? My thought process with hashing is each worker will run its own database, containing a queue of domains only assigned to that worker, and it will just pull URLs off the queue that way (batching though). The whole thing is I think keeping everything decentralized will allow it to scale much better on cheaper hardware.
Regarding my comment about assigning each worker a range, imagine that you have 4 workers. Instead of setting n=4, set n=20. This means you have 20 queues that you write URLs to, and then worker1 reads queues 1,2,3,4,5, worker2 reads queues 6,7,8,9,10 etc.. Later when you add worker5, you can migrate queues 5,10,15,20 to it I don't actually recommend you do the above. It's more headache than its worth. If you're planning for a horizontally scalable architecture, work on each piece as an individual service (data source, queue, HTTP workers, DNS, results processor) with a clear/simple API between them. Ideally, your input and output queues are the "cheap" parts of the stack. It's really not that hard to have horizontally scalable queues without resorting to teaching your input system about your worker topology. Why are you running on MongoDB ? What was redis's single box LPUSH/LPOP performance like ? If it wasn't good, you can shard the queues over multiple redis boxes, or you can test a naturally distributed queue like apache kafka. 
Main Features: - Lot more efficient binary client (compared to JSON) via protocol buffer and grpc.io. - Now supports retrieving `first:N` results.
Not sure why you're being downvoted. It's a decent question, especially for someone more familiar with the parent/child paradigm. 
Not sure beyond err as most common trigram
https://go-review.googlesource.com/23381
&gt; and am looking for common bigrams and trigrams for the major programming languages Most used bigrams probably are: \^C \^V 
This. We downloaded all source code from all packages on godoc once. It's not difficult to do, doesn't take that long and doesn't need that much disk space. Afterwards you can just do the counting yourself and get a definitive answer.
it's a design masterpiece
Not sure if you are sarcastic, but I find it excellent myself. It does its job perfectly, and isn't that the goal of a well designed dashboard?
Sure, you can't force users to keep their SSH keys secure. You also can't force them to keep their passwords secure. Those policies are preventing secure login via public key, and [reducing security by forcing password expiry](https://www.cesg.gov.uk/articles/problems-forcing-regular-password-expiry). And users will still be able to share passwords with colleagues or write them on Post-It notes.
Check out github.com/gogo. The code it generates is even faster than the default if you use the options to enable custom marshallers per type. 
Well, you could always use [CA-signed SSH keys](http://www.lorier.net/docs/ssh-ca), or not let users manage their own `authorized_keys` and forcibly expire old entries.
Indeed. So write those helpers yourself. No need to use a framework or a library to provide you with said helpers. Especially when it's one of those libraries that require you to learn a whole new DSL.
Serf is already a golang library — it's an implementation of the gossip protocol used for distributed systems: https://github.com/hashicorp/serf. For a second I thought this was built atop the serf protocol for a second. It *is* a cool looking library!
Hi OP. Wish you would've included numbers for (or at least a reference to) the high-performance github.com/gogo/protobuf/proto package as well.
Looks nice! Thanks! 
Actually, a reference to the benchmark was included via a link. But I've added gogo protobuf to the table. Thanks for the feedback!
This looks pretty cool. Have you run any benchmarks or other performance analysis to compare this package to other popular loggers? Would especially like to see how it fares compared to github.com/Sirupsen/logrus.
Awesome, thank you cube2222!
Har har