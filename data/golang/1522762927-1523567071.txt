Multicast? So technically if routers will route the multicast packets, it works beyond the local network?
I'm not really familiar with c++ so no. I heard it was originally a fork of leveldb, do you consider that as (bad) code aswell? 
If you're just sending some data between two machines, it is completely incomprehensible that you would want to get a block chain involved for any reason
I think this is by and large true, but blockchains have some very legitimate use cases. Most apps don’t benefit from one, but many apps will or do, too.
OK.. so the benefit then is to be able to take chunks of data, blocks.. and use them to feed the next block (as the examples show) then send all that data (one chunk of data that entails 2 or more blocks in it) down the pipe in a multi-cast manner to any number of receivers? Or do the blocks go to multiple locations where they would be stored (in memory/database)? I am confused I guess as to the longevity of the block data.. is it merely a way to group lots of data in smaller chunks making it harder to crack because the entire data set is in multiple smaller chunks? Or is it to transmit multiple different bits of data (e.g. different user accounts of data as individual blocks) so that the data is accessible to anyone with access to it at any one of multiple locations? Or did I totally just screw the pooch in any sort of understanding of it?
"Freedom" in "style" is not a thing in Go. You should use `go fmt`, it exists for a reason. It's the standard and you will find very few people willing to hack on your code or work on Go with you if you don't. At the very least, you will get tremendous PR churn every time someone using an auto-formatting editor touches your code.
tbqh I have yet to see a single compelling use case for one. It's a neat idea, but in real life it pretty much always makes more sense to use a centralized database
The point is for the entire "chain" of blocks to be broadcast to everyone on the network. Whatever chain is the longest is considered to be the canonical one, and the different machines on the network compete to add a block with a valid hash, making a new longest chain. Pretty much its sole utility is letting the network create a canonical, ordered record of messages (almost exclusively transfers of crypto currency in practice) without a central clearing house. If you don't need to do that specific thing, block chain has no meaning for your application
nicely done
well there is more to it than just being decentralized, but that is a key selling point. another facet is that once the data has been added to a block and confirmed on the chain, it is immutable. while a database can have a record edited a blockchain cannot have the block altered once it has been added. this is very powerful. here is a quick read on what IBM is doing for business on the blockchain: https://www.ibm.com/blogs/insights-on-business/government/blockchain-asset-registration/
there are a tremendous number of use cases for blockchains. any time you want data to be immutable like asset tracking or logistics is perfect for blockchain. airline flights, uber receipts, voting systems are a PERFECT example of where blockchains would be superior to transactional databases. 
Thank you. Will read. So the code snippet is that all there is to using blockchain. Seems so small and simple. Or is this a very simple example but it would normally be more complicated?
Native UI toolkits. Gotk3 seems like the best option, but GTK leaves a lot to be desired and the bindings themselves aren't complete. Ideally there would be a native-Go toolkit with an OpenGL backend and extensive styling properties. I'm guessing media transcoding libraries are not a strong point for Go's ecosystem either.
I ask because I have been told that our next area of work is moving data to block chain... which has the smell of "its the new word everyone is using and have no idea what it means.. so we need to say we do it too". I hate that.. but too often that is what happens.
I think the case for a blockchain has a lot less to do with verification and immutability than it has to do with decentralisation. It also has a lot to do with discoverability. If all you need is a means to establish identity cryptographically, you could just as well store hashes in text files and match them against an incoming request. On the other hand, if you need to take power and really distribute it so that no one party has absolute control, well, you can’t do that with a centralised database. Distribution in a blockchain is a function of this objective. I think the point is that information - data - is very valuable in this age. That also means creating monopolies of data and opaque black boxes is quite often not what we want. 
It's just network multicasting for discovery and HTTP on a dir. for data transfer, with a WebUI to make it easy to use. 
So the big advancement is that now instead of one big scary company having my data and I have to trust them to delete it if I want, now *every* big scary company has my data and also I can't ever delete it. Sounds lovely
what immutable databases are you referring to? blockchains don't have to be public, you can have your own private blockchain that stores whatever info on it that you want. here is an example for you, github is built on a merkle-dag, which is basically a branchable blockchain. there is a reason there is a lot of buzz around blockchains. there is some aweful HYPE HYPE HYPE but the underlying geeks understand the power it offers.
Literally any database, just make sure your application doesn't issue updates or deletes. Immutability isn't some hot new concept that just came along with block chain. And if your block chain isn't public, that's even more nonsensical. The point of the whole thing is to verify an ordered sequence of events amount potentially untrustworthy actors. If the system only has one user, that user ought to be able to trust itself
I've never heard of that, it sounds amazing (but rather complicated to implement in git)
&gt; faq is pronounced "fah queue". Not really...?!
My main packages typically end up very small, because I pull all of this out of them. There are some packages that are almost literally func main() { app := myapp.Application() app.Run() } Anything that you find yourself needing somewhere else, pull it out of the "main" package. A common pattern is to have the repo organized as maindir/ cmd/ application/ main.go so that the command is separated, and it doesn't feel too strange that main.go may actually be fairly small. Having the top level of the repo be a main package is not exactly an "anti-pattern", but it's suitable only for projects that will not grow beyond a certain size where the whole thing fits in one package comfortably.
What's the difference between this and Syncthing?
^The linked tweet was tweeted by [@francesc](https://twitter.com/francesc) on Apr 03, 2018 18:31:43 UTC (3 Retweets | 13 Favorites) ------------------------------------------------- If I get 1000 likes on this tweet, next \#justforfunc episode on CORBA! [https://twitter.com/jponge/status/981237191421677569](https://twitter.com/jponge/status/981237191421677569) ------------------------------------------------- ^^• Beep boop I'm a bot • Find out more about me at /r/tweettranscriberbot/ •
Oh, man 😂
Haven't touched leveldb. Used slightly modified zsdt (undo functionality added) and their code was poorly structured, thus this little modification came at higher cost than it would be possible. My colleague is touching rocksdb right now and rate it quite poor in terms of code. I just don't get why to open mediocre pieces of software at all. Although there're some doubts if facebook have good ones at all: I have heard the ugliness of their UIs is just a consequence of their software development culture, which is the a mess there.
FWIW, this is [Cobra](https://github.com/spf13/cobra), not [CORBA](https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture). /shudders
You could tar them at the beginning to produce a single archive file, then untar them at the end. Here is a good breakdown of both: https://medium.com/@skdomino/taring-untaring-files-in-go-6b07cf56bc07?source=linkShare-a7d8ec2f59bb-1522794712
Yes, `gozstd` implements the following subset of zstd 1.3.4: * In-memory block compression / decompression. * Stream compression / decompression. * All the compression levels supported by zstd. * Compression / decompression with dictionaries. * Building dictionaries from user-provided samples. Currently it doesn't implement: * [pzstd](https://github.com/facebook/zstd/tree/dev/contrib/pzstd). * Naked block compression / decompression, aka [block level API](http://facebook.github.io/zstd/zstd_manual.html#Chapter21). Additionally, currently it only works on `go1.10+` and `linux/amd64`. Patches adding support for older go versions and/or platforms are welcome.
Could you provide proofs of security vulnerabilities in `zstd`? It has been open sourced three years ago, so security researches had plenty of time for finding security issues in zstd code. I found only [this one](http://www.openwall.com/lists/oss-security/2015/10/24/3) from 2015.
Great project! I've been makng plans for a small pure Go SQL DB preferably as an SQLite drop-in replacement, at least for the features that I use in my apps. This will help me a lot. Do you have any plans to make SQLite databases writable (even if without SQL)?
The simplest method is use ioutil.ReadFile() to read each file, then append its bytes to a byte slice or bytes.Buffer, finally use ioutil.WriteFile() to write the joined byte slice or buffer to the file you want. This assumes the files you're joining are not very big and can be accommodated in RAM. If the files are large, then we can read small chunks from each file and append to a temp fle. Finally rename the temp file to the desired name.
Some questions: When you're separating the files at the end, you're separating them based on what criteria? What happens after you join the files, before splitting them back? What are you manipulating? Are the files text files?
It's a wishlist, so I can ask the Genie any 3 wishes, right? 1. I want SQLite, but written in Go, and it should have strong encryption. 2. A HTTP client lib, to automate browsing: check your gmail, github, reddit, everything in one go and report what's new. That'll save lots of time, but should be easy to set up for different sites. 3. I won't ask, I've almost writen it already, just wish it'll be ready soon
This is exactly what's going to happen, unfortunately.
https://golang.org/pkg/archive/zip/
I would read the 5 files each in a `ReadSeeker`. Then use `MultiReader` to read them as one file. Then seek the files to `0, io.SeekStart` to use them individually again.
Instead of using `init` it can be better to use `PreRun` or `PersistentPreRun` to initialize common things. only a little better though because things still end up as global, but you do have more control over execution.
Are you intending to do this for production use? I wouldn’t recommend that, but either way you should read this: https://www.sqlite.org/testing.html I can’t imagine the benefits of rolling your own outweigh the pain you’ll feel.
Seems an interesting option. One thing I am not sure after reading the link is, result of the tar is single file (or) something like compressed but 5 different files?
My understanding of zip is compression, not combining them into 1 file. Am I missing something?
tar.NewWriter(io.Writer) writes it’s output to a single file, assuming the writer you pass it is a file (for example, from a call to os.Create()) The example article I provided can be a little confusing on that because they use an io.MultiWriter to output to multiple targets &gt; the purpose for accepting multiple writers is to allow for multiple outputs (for example a file, or md5 hash)
Comparing to the other solutions provided, using this tar approach has two benefits: 1. The use of io.Copy() means there is limited memory used, so large files are not a problem. 2. The tar headers give a clear way to extract individual files back out into their original form.
[removed]
Cool. Thanks for your time! Will try it.
I almost signed up to twitter to like it
Sigh, so is pretty much every other router out there (except a few I've come across that use lots of reflection at runtime like gocraft/web). I don't have anything against Gin but comparing routers for their speed is a bit stupid because most of your performance will be lost in your own code generally, waiting for IO, DB queries etc. The difference in routers is so small it's not even noticeable. Gin does have a very large community and that is a much better reason to choose it than speed, other good reasons to choose a framework could be well designed code base, features it provides, or in the case of Chi the handlers follow the same signature as stdlib which makes it easier to mix with other libraries than Gin for example. http://dayssincelastgohttprouter.com/
You didn't write it in go..you wrote it in opengl...
that’s a pretty impressive testing process 
That's like saying you wrote your server in HTML.
Here’s one written in C, for comparison: https://github.com/fogleman/Craft. My guess is that C would be faster than Go, but a lot faster than Java
Waaaaa, that's so cool!
I didn't realize graphics programming was possible with Go at this time.
I've recently had to heal with [ChromeDP](www.github.com/chromedp/chromedp), a library I didn't even know exists. In short it can launch Chrome and run commands in it written in Go. The project felt pretty fun so I decided to share it with others. If you have any questions please let me know. 
Author here. I didn't know about that one!
Author here. Making it writeable is really a whole new level. It would mean things like balancing the btrees. For now I aim for reliable reading, and then work toward higher level functions.
&gt; I didn't know about that one! How new OSS libs come to life. :)
Yes. Did you read the documentation?
Java has less overhead with C interop than Go which will help, but the lack of value types can cause serious problems unless you are willing to make your code kind of horrible (never use a vector3 class, for instance). You could probably make the Java one as fast or faster than Go with enough effort, BUT go's lower latency GC might mean less noticeable GC pauses even if average framerate is lower. C or C++ is going to be fastest of course. Sean Barret's open block game is in C: https://github.com/nothings/obbg
I show how to set up SDL2 in one of my streams: https://gameswithgo.org/topics.html We will be setting up opengl on thursday. 
Execution-speed I suspect Java to be on-par with Go, the JVM applies some dark JIT magic. Java -&gt; C interop is far from optimal though, JNI has some serious overhead too... Not sure how it compares to the Go -&gt; C bindings though - but would be interesting to see. The Go or C version however, will be quite a bit more memory-friendly. And although both Go and Java are GC'd the GC pauses and latency will probably be better for the Go version. 
Just about anything should be possible. I've been developing a game using the Vulkan API in Go for awhile now. Windows side is pretty easy - the DLLs can be invoked directly from Go and the available Vulkan functions can be loaded up from there. Same with windowing and input and audio. I haven't looked much at what I'll need for Linux yet - may need cgo to use dlopen and friends. But for now can call everything using 100% native Go.
Thanks!
Why not use a vec3 class? Is it because you could use a len 3 array and assume from there?
I did and compression is not what I am really looking for.
If you say so.¯\\\_(ツ)\_/¯
That's a good approach. I'll also give writing to SQLite DBs a try. I don't know when, but when I do I'll let you know what I'm doing.
Is it possible to work remotely?
Not a fan of the short assignment operator?
There was a talk at GopherCon about moss: https://youtu.be/ttebJcN5bgQ
if you look at the bottom of this post's project: &gt; Implementation Details Many implementations is inspired by https://github.com/fogleman/Craft, thanks for Fogleman's good work! a lot of the code is ported
[removed]
https://github.com/golang/go/wiki/WindowsDLLs
interesting, so performance of doing things this way is worse than cgo? better? the same? 
Very true - most of it is experimental to start with, so getting it all working together properly is the first step, and then optimize the crap out of it. :)
gin is basically unmaintained these days. The last release was july 2017. And there's next to 0 commits. I wouldn't choose gin today.
https://github.com/genome/log2file
I do agree with the ease of ability to use standard library signature. Which is one of the reasons I wrote the framework 2 years ago. Back then, I was not able to find a system which gave all routing, middleware etc. but used the std lib signature. And even in my v2 release, I have stuck to it and will always do.
Sounds interesting, unfortunately I'm in Vancouver 😔
If you write up the outline and details publicly, you might get some free suggestions/advice. :)
Yeah, I was trying my best to keep it as simple as possible. There's a lot of FUD and confusion around DI, talk about frameworks, annotations, etc. But really the _principles_ are very simple. &gt; This allows the client to make acquiring dependencies someone else's problem. &gt; The service is made part of the client's state.[1] Passing the service to the client, rather than allowing a client to build or find the service, is the fundamental requirement of the pattern. Now I didn't make a "service" per-se. Most common examples are some struct which takes a dependency in some kind of constructor (`NewFoo(depA DepA)`) and then you have methods that use that dependency. But I like to believe I highligted the _principle_. The "service" did not care about where the dep came from and it could be interchanged to let it do different things for the caller without it knowing the details.
Just started working with [another vulkan wrapper](https://github.com/vulkan-go/vulkan). So far so good on windows at least, do you have any experience it @chompsky? 
[removed]
Not an elegant solution but you can add the `Remaining` field explicitly and then implement `MarshalJSON` method on on `Quota`, in which you would calculate value and populate the field and then call the `json.Marshal` on the structure. This does not turn field into a dynamic property but solves a specific problem. See https://golang.org/pkg/encoding/json/ for an example of custom marshaling. 
Wellington, New Zealand. VISA ONSITE Weta Digital, one of the premiere Visual Effects studios in the world, is hiring for a number of software developer positions. One in particular is within my own department, as a Senior Python Developer. This role also has opportunities to develop in Go, as we have a number of tools and services that are Go-based. https://careers.wetafx.co.nz/jobs/720
I agree. Finalizers that may or may not run are useful only for things that are completely fine when the finalizers do not run. But that's [mostly] equal to not having any finalizers mechanism in the first place.
In C# I'll often use finalizers to track bugs in which an object was GC'd but Close() was never called.
Lol! I have been writing go for a couple of months and I am happy since I understand 85% of this 😋 now
considering this is r/golang, I would expect job postings here to be go-related, not python
Cool, we just started using Segment. Love your app, it does what it says on the can and works great- no surprise it's written in Go ; )
Etherparty - Full-stack / blockchain engineer - Vancouver, BC, Canada - Full-time We are a blockchain company that makes smart contracts and infrastructure around them. Super fun, small close-knit team. Everything on the back-end is Go. We are looking for some engineers to come in hot and hit the ground running. Blockchain experience is, of course, a massive plus, as most of the job revolves around that. Our stack: Golang, Solidity, CockroachDB, React, Docker, Kubernetes, AWS, etc. What working here is like: Fast-paced and fun. Constant learning, a really new emerging industry that takes difficulty to stay abreast of. Best fits would be people passionate for the industry, rather than simply a dedicated Go engineer who would accept a blockchain-related job. Very competitive pay for the right people. We are interested in hiring multiple developers. If you think you're a good fit, send me a PM to get a conversation started. My name is Jeff. Thanks!
I find finalizers a pretty useful to tie C heap allocations to Go object lifecycles, which can come handy when binding.
Yes the job title is looking for a python developer. But I am sharing it because Weta Digital has been slowly doing more tooling and services in Go. The position offers the opportunity to continue this migration.
THANK YOU for MIT! The previous QT/QML libraries I used had GPL limitations which wasn't helpful for a number of projects I was working on.
The website and the youtube talk go into detail. It's completely tuned for that use case, including not providing APIs you'd expect from a general-purpose key-value store.
[removed]
[Uber](https://www.uber.com/careers/list/33677/ ) | San Francisco | Onsite | Visa | Full-Time The Go team at Uber is a small team with a bit impact. We support a huge community of over a thousand developers working on production Golang applications. We're looking for all skill ranges. Whether you obsess over allocs in your benchmarks, or if you're newer to Go and want to grow your skills with mentorship from language experts, we definitely want to talk to you. Representative work: * https://github.com/uber-go/zap * https://github.com/uber/prototool * https://github.com/uber/go-torch * [Profiling and Optimizing Go](https://www.youtube.com/watch?v=N3PWzBeLX2M) [Apply here or PM me directly!](https://www.uber.com/careers/list/33677/)
It's open source, here's the github repo for it :) https://github.com/CoinCulture/point-of-sale
How have you been liking graphql? Are you native or wrapping other services? 
I don't personally use it extensively since I focus on the core pipeline, but we do use it as an API gateway to talk to other backend services.
Using fmt.Scanf package main import ( "fmt" "os" "io" "strings" ) func main() { file, err := os.Create("abc.txt") defer file.Close() if err != nil { fmt.Printf("Error creating file:%s", err.Error()) } else { for { var inputStr string fmt.Scanf("%s",&amp;inputStr) if strings.EqualFold(inputStr,"quit"){ break } io.WriteString(file,inputStr+"\n") } } } 
Not if it's dynamically linked.
[Bitly](https://bitly.is/hiring) | [NYC](https://kwp.io/2q5K573) | [DEN](https://kwp.io/2GVBzBu) | ONSITE | Full-Time Does API Design make you excited? Are you up to the challenge of building scalable, robust, distributed systems? Do you see an opportunity in building tools to help people understand the world around them? Then Bitly might be the right place for you. * Design and build large-scale, distributed, highly available, well-tested, and easily managed services. * Create, manage, and improve web APIs that clearly, accurately, and efficiently provide clients with the data they need. * Work with people throughout the company to understand the goals, needs, and priorities of systems and turn that understanding into a specific plan of attack. * Use a variety of tools and languages including Go, Python, Hadoop, MySQL, and more. 
The technical stuff aside, which I assume is interesting, what's it like working for a company with such a negative public image? Especially since some of the negative press involved engineeers doing very unethical stuff. I've always been curious to hear how all that affects the average working bee at Uber.
Interesting. I didn't even know about this feature. Fortunately, I think this means that finalizers _are_ an antipattern as the author describes. However, I also think it's a bug for a file descriptor object to be GCd without reaping the open file. Yes everyone _should_ understand that it's necessary to clean up OS resources, but in the off chance they don't or it's accidentally forgotten, I prefer the gradual failure instead. I guess an alternative to this is that if a file is still open when it's being GC'd, then the program panics, but that still implies having a finalizer I believe.
We are looking for backend engineer — if your interested in building Health and Fitness. Our stack contains PostgreSQL, Cassandra, Python and Kafka. https://gyrosco.pe/jobs/
Finalizers are used to try to remedy pacakge user mistakes. https://go101.org/article/unofficial-faq.html#finalizers
Which udemy course?
&gt; Common Go idiom is this: &gt; &gt; if err != nil { &gt; return err &gt; } May I kindly disagree. This is not a Go idiom, this is error handling done wrong. Written this way, error handling is nothing but a verbose form of exceptions, passing the error unmodified up and up again, until some error handler writes the error out to a log file, leaving no helpful information for the developer who tries to fix a bug in their code. Instead, always pass new context to the caller to facilitate analyzing the reasons for wrong behavior. And do this only if the error cannot be handled at the current level. if err != nil { d errors.New("Cannot do xyz: " + err.String) // OR fmt.Errorf("Cannot do xyz: %s", err) } where "xyz" describes the attempted action at the actual level. 
Having a name for a concept (or pattern) makes it easier to reason about it, and to talk to others about it.
Your series is awesome.
I think it builds a bit map. Think of as a map[char]bool, where the char index into an array of bits.
By reading another character as long as the current one is whitespace. Seems like a good way of skipping to me.
Why don't we just call it accepting interfaces in your api to build dependenceless libraries? An injection always sounds like something I don't want.
Each runes decimal value is used in a left shift by 1 which is just a power of 2 (i.e 1&lt;&lt;8 == 1&lt;&lt;‘\t’) in order to give each rune a distinct slot within the untyped numeric constant GoWhitespace. This is leveraging the fact that the highest decimal value for ascii white space is 32, this is an important detail because of how it is checked during iteration. The for loop performs the same bit shift to determine the slot of the current rune and checking if the same bits are set within the mask. It is actually relying on allowing the right hand a side to overflow by the 32 bit address space constraint on the rhs. All and all this makes for a less safe API and probably wouldn’t have been used over a map in most code, but this is a rare exception because it’s performing linear text iteration. The bit mask lookups here are a 1ns kind of cheap and allow user configuration without branching / complexity of a safer iota style bitmask or the performance tax of map lookups. 
 const GoWhitespace = 1&lt;&lt;'\t' | 1&lt;&lt;'\n' | 1&lt;&lt;'\r' | 1&lt;&lt;' ' The above line produces the following bit pattern ' ' '\r' '\n' '\t' ^ ^ ^ ^ | | +-----------+ | +------+ || + + ++ 100000000000000000010011000000000 ' ' == 32 so shifting 1 by 32 bits sets 32nd bit as 1 etc. so the code GoWhitespace &amp; (1&lt;&lt;uint(character)) would produce a non `0` value if the `character` is one of those characters in `GoWhitespace` 
Oh I see. This is so brilliant. Thanks for the drawing.
Yes as pointed out, I cannot override the Qt license, so if u want to statically compile and sell your work, you will need a commercial Qt license. However if u dynamically link (as I demo) you can use Qt as is. I understand but cannot confirm, u can statically link, if ur code is open source. 
I just put together the instructions and a working framework for developing apps using Qt and Go. I found alot of libraries out there, but very little documentation to get started quickly and easily to produce production apps. It was important that dev was fast to me so I added the hot loader. I also put the right artifacts in place to get started and everything would work immediately. It's meant to be a start point for anyone wanting to produce a production desktop app cross platform. Yes the demo is large as there is a lot of qml and qml libraries because it demos so many elements. In reality you wouldn't be compiling so much into the app. Yes the calculator didn't get any more attention than proving the go code was handling the business logic. I didn't spend time converting strings to floats to do maths... Hopefully that doesn't upset people too much ;) Hopefully people find it useful, I do. See the YouTube linked in github if u want more info 
You are right. Fixed that, thanks.
`grep -nr '^func main'` is your friend.
Yes, usually you use https://github.com/pkg/errors#errors----- to wrap the error you are returning with more information. I omited that in the example. Also from https://github.com/pkg/errors#errors----- readme: The traditional error handling idiom in Go is roughly akin to if err != nil { return err }
&gt; however QT is not open source. Qt is released under LGPL license, I guess that's open source right?
If I'm honest the Qt license is a complicated one. I think: If ur work is open source then u can use Qt fine. If your work is not open source but u dynamically link to Qt, fine. If u statically compile, but open source your work, fine. If u statically compile and charge for ur work, then u need a commercial license. That's my understanding, don't quote me in court on it, but if u learn something new, please let me know! 
Thanks to comments, I have updated the Readme to mention it is LGPL. I am not sure when you are required to buy the commercial license, perhaps that is documented in LGPL somewhere, but I think its when you statically compile and sell your product. Apart from that, I think this is a nice open solution to developing GUI apps in Go
This doesn't really adhere to 'asking a good question' but to help you out: * to take a value from the user from the console when running the app, look up Golang command line flags * to store the value in a struct is the same as storing the value in a variable. If you know how to use structs, this should be easy, if you don't look up Golang structs. * To store the struct to a file, it needs to be marshal the struct to json, then write the json byte array to a text file. Code snippet: ``` var s struct{} structJson, _ := json.Marshal(s) err = ioutil.WriteFile("output.json", structJson, 0644) fmt.Printf("%+v", structJson) ``` I don't want to give it all away, but that should kick you off. GoByExample is a great site to learn how to do each step. On the other hand I may have misunderstood your question, but that may have something to do with the vagueness of the question ;)
That's how I'm planning on using it. Was curious to see if another gopher was writing their api gateway in go and what their choice of lib was. Thanks! 
This outlines the use of Qt from an opensource perspective. Basically, for most intents and purposes, you are all good: https://stackoverflow.com/questions/8760076/commercial-application-using-qt
No idea if that's similar to what's going to be described in the follow up post advertised on the site, but your idea inspired me to take it further and submit a quick proposal based on it: https://golang.org/issue/24696
AFAIK, VSCode is available on Linux, has a consistent UI and works well.
Not sure how many embedded developers we have here, but this allows you to develop Network Functions in Linux user space with a high speed packet processing engine DPDK from Intel
[BAMTECH Media](bamtechmedia.com). NYC, SF, Research Triangle, NC or Remote. BAMTECH used to be the media arm of MLB.com that has been spun off into it's own company then acquired by Disney. We work on direct to consumer video streaming including MLB.tv, NHL.tv, Fox sports Go, Eurosport, PGA Live, HBO Now, ESPN+, and more. We are looking for Go developers to join or 'Developer Productivity Team'. Working on our custom deployment platform built on top of ECS. https://jobs.disneycareers.com/job/new-york/senior-software-engineer-core-engineering/391/6300467 
Graphql-go is what we use.
It's not always easy to know, depending on how resource ownership works. If you integrate with a scripting language that determines the lifetime while something is also in use, it can get very tricky.
We really enjoy it! No auth sucks though. And we made the mistake of have graph talk to graphql...which we promptly fixed.
I thought there was schema level Auth? Is it not in the go implementation yet? What was the issue with gql to gql communication? 
Lots of things with gql to gql. But mostly enum types! Keys are meant to be camelCase per JSON spec, but when we had 'http' that correlated to value HTTP. we then had to either make the case match and deal with the conversion later. Also we lost a lot of insight into errors. Gql has pretty nice error outputs. But a lot of messages in the second service would get lost in the first. And finally, we tried to share schema which was our bigger problem. We then wrote this whole abstraction layer so each implementor could provide their own resolvers via injection and it proved a pain for even small changes. So instead we went to gql as our gateway which fronted small restful microservices and have had a much much better experience since then. Also, we haven't looked at auth in over a year so if it's a new feature I couldn't tell you. 
Thanks for the great insight. Our plan has been as a gateway or having the business logic for a resolution on service. I hadn't really considered gql to gql. Auth certainly isn't in the spec. I've just seen several talks where the node reference implementation has Auth features. Didn't mean to imply that the spec now includes Auth.
You probably won't want your Gopher to be entangled in "moss" :) I suggest "cookie", because we all know Gophers eat cookies :D
I use finalizers in a similar way in a cgo-based package that has to retain references to C-allocated memory. My API says that you're supposed to call the equivalent of 'close' to dispose of things before you let the Go structure go out of scope and get GC'd, but there's no guarantee that people actually will. Without finalizers, making that usage mistake would create an invisible and hard to trace memory leak, so I attach a finalizer as a backup. I personally think this is a good usage of finalizers, although I understand some people don't like it.
I think you'd need some testing around whether select { case runtime.Leaks &lt;- errors.New(file.name + ": missing Close): default: } will do what you want. If the finalizers all run during a GC, they could be running in fairly quick succession and the channel could end up blocked by the fact the consumer hasn't/couldn't be scheduled yet. I know the GC is no longer "always stop the world" but doesn't it still have some stop-the-world phases? At the very least I'd be worried I'm not saying I _know_ this is problem, because I have never dug in far enough in the runtime to _know_. Just a thought that came up.
Data is never defined, outside the for loop define it with data := make([]string,0) then append with data = append(data, string) You'll also have to address the data you're appending since it must be string. You could make a struct and use and []struct or do sprintf those 2 data points into a string.
Some of the general points are mostly correct, but I am going to disagree with some and give some tips as someone who has done a lot in both langs...: * Golang concurrency is not that much easier. Many developers will have an easier time working with futures, promises (i.e. CompletableFuture), thread pools, and concurrent collections than they will with select+channels. Just make sure they understand blocking/non-blocking selects and channel. Go is not just magically "less buggy", it takes discipline wrt state sharing/movement * I personally find swagger/openapi specs to not be very good for code generation. Good enough for json model gen I guess, but do the HTTP req/resp yourself. Or if it's not a ridiculously sized or volatile API, just work with it directly. * Don't get hung up on annotations vs other ways to specify routes, the difference is negligible. Consistency and difficulty are what matter. * It is pretty company specific that Java is considered to have a clear devops edge because of some closed-source commercial monitoring system. Also, I don't consider dockerizing both to be that straightforward wrt runtime management of a VM and dependencies vs static compilation. When considering devops, ease of upgrade and package management should also be a concern (there are pros/cons for both langs here) * Normal Go using shops shouldn't be leveraging a ton of code generation to work around lack of generics. It will get ugly fast. Just accept the language limits and work within them, especially for microservices. * Don't get hung up on Java libraries. That hibernate is even listed to me screams that this comparison is not on modern Java and approaches. Again, microservices, nothing complicated. Just make the scaffolding and let your devs run w/ it. * The lambda implementation in Java is not "hacky at best" and again, this reeks of a level of misunderstanding that makes me think someone else should put together a comparison doc for your company's sake. Also, whether defining anon functions and their types feels natural in Go compared to Java is subjective at best (I think Go is way wordier and explicit...whether that is good/bad is up to you) * Dependency management in Go has not improved that much in my opinion, it just became more fragmented. * Go does not do code analysis much better. That the lang has built in checks for unused variables is nothing compared to something that tells you that you are going to break at runtime w/ a nullable var (e.g. by using the checker framework in Java). These statements in the post, like many others, seem to be based on what comes with the package and not the ecosystem. * Compiling Java code is not slow. I'm gonna have to see some numbers, especially in a reasonably sized application. Even start time is not really slow, especially for daemons. Meh, I'll stop there...I think the author could use examples of simple Java microservice code and war stories of bad developer use of Go concurrency to even it out a bit. But I don't disagree with the general post or it's overall conclusion. Also, author is doing a disservice excluding Kotlin.
Honestly not sure. I'm hoping to spend some time with this as a side project at work. All our DPDK stuff is C/C++ based. If you look at the example firewall, the pass/reject rule is applied from the Go code, so somehow they are getting the packets into Go. I'm interested in seeing where Intel goes with this.
I've never used them, but logging/debugging seems like an excellent use case.
Oooh! As a crocheter (and knitter), I may just have to make one of these. 
It seems to be using `cgo` for this interface. They have encapsulated this in their [low](https://github.com/intel-go/nff-go/tree/master/low) package. It's not just a 1:1 interface either; they put some initialization and control loops in [low.h](https://github.com/intel-go/nff-go/blob/master/low/low.h). That said, `low` seems to also contain a fair number of Go implementations of low-level functionality, so it looks like they moved what they could into Go, including translating some code from the C implementation.
[removed]
I'm not sure the motivation behind this is a "challenge".
[removed]
Maybe because I am more aware of the problem, but I have noticed more and more issues like this that would be sovled by vgo.
[removed]
[removed]
From https://tour.golang.org/methods/15: "Type assertions A type assertion provides access to an interface value's underlying concrete value. `t := i.(T)` This statement asserts that the interface value i holds the concrete type `T` and assigns the underlying `T` value to the variable `t`. If `i` does not hold a T, the statement will trigger a panic. To *test* whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded. `t, ok := i.(T)` If `i` holds a `T`, then `t` will be the underlying value and `ok` will be true. If not, `ok` will be false and t will be the zero value of type `T`, and no panic occurs. Note the similarity between this syntax and that of reading from a map."
Break it down to the smallest possible component. Focus on those you don't understand. At the end of the day what you don't know can bite you at some point for sure but don't let that stand in the way of being productive. You think everyone using Rails understands all the underlying structures and the ruby that underlies it? If using buffalo gets you going and you feel comfortable with it then knock yourself out. The more you work with a language and its packages the more you will come to understand and learn.
[removed]
Is it your first language? I remember being stuck on a bunch of things when learning my first language (C++). Pretty much gave up on C++ when I reached pointers because I didn't understand why you would ever need those, but then after doing some other languages it just kinda clicked.
[removed]
Perfect thanks!
Soon: Twitch builds a startup
Nice try, person who wants someone to work on a concurrent filesystem for free!
I think this is a perfect use case. Can always through a nasty log in there too, reminding the user to cleanup.
Nope. Python and Javascript before. C\+\+ was the first language I looked at when I was in Middle School learning to program. Pointers is exactly where I stopped also lol. I see what you mean. It just seems like it takes me longer than most people to learn something. 
If you read David's [next blog post](https://crawshaw.io/blog/sharp-edged-finalizers), you'll see that the only thing he recommends using finalizers for is bug detection. They should panic if you forget to close a resource. You can disagree, but you should at least be aware of what he's trying to advocate.
It sounds like you may find it interesting to set up delve or something and debug your way through one of your requests, stepping through it all the way. I find Go source code is pretty transparent; you get quite far down before it goes to magic. Debuggers are great for exploring code bases through the lens of the actual code that executes. You don't get a good sense of the corner cases but you'll get a lot of info about the common ones.
Seems like a pretty arbitrary place to get hung up. I mean ... why stop at 3rd party packages? Are you cheating when you're using the standard library? What about the Go compiler? Your kernels TCP/IP stack? Processor architecture? Just build stuff and don't worry about it.
Or even dep. Or really any other vendoring solution.
If you have to write microservices with a JVM language, skip base Java and use something more modern like Kotlin. Kotlin is wonderful and is what Java should have been.
My recommendation: stop beating yourself up for *your own biased observations* of how long it takes for a concept to be ingrained in your head. Stop and consider the following: * It takes you longer than most people to learn something new? Are you sure about that? And are you considering all the variables? Could it be that you are picking up facets of something other people do NOT pick up, and therefore it might take you “longer” to do something, but in reality, you’re picking up details others defer. -&gt;. And if this is the case, are those details salient? If not, then maybe find a routine that allows you to have a positive self-conversation and make sure you’re focusing on the right details vs. deferring those details that may not matter at the moment. * Learning a programming language is not trivial. While having experience with other languages helps tremendously, give yourself a bit of a break here. Your background is more around scripting languages, which let you focus more on logic and less on low-level concerns (I’m NOT critiquing scripting languages btw). You’re now picking up a language that is 1) compiled and 2) deals with value vs. pointer types, references, and other somewhat low level details. These are all new to you, right? Ease up on yourself. * Stop comparing yourself to others. It’s always a dark rabbit hole: https://www.becomingminimalist.com/compare-less/ Finally - have faith in yourself and your abilities. You cannot love others before you love yourself, so start convincing yourself that you’re awesome and you learn things in your own way. And that way is no better than any other way. And all methods of learning can always adapt and get better over time. -Michael
I blame Spring and Java for the confusion around the need for a “framework” to enable DI. You could make an argument that Java did not need a framework to do simple DI either, though the addition of the Spring ecosystem as a direct response to the JEE complexity did muddle the waters a bit. Afterwards, devs “demanded” DI frameworks, even when not necessary. I felt the write up did a great job at showing the DI pattern in Golang. Another place to show the concepts of DI in Golang is possibly during type creation: type Blah Struct { SomethingDependedOn blah.SomethingElse } func CreateBlah() (Blah, error) { blahDitty := Blah{} if someEnvVar == “mock” { blahDitty.SomethingDependedOn = blah.MockSomethingElse{} } else { blahDitty.SomethingDependedOn = blah.RealSomethingElse{} } return blahDitty, nil } This is a common pattern I use on some of my projects as well. :) -Michael
I think your denouncement of the author's views on Java lambdas is unnecessarily strong. The author doesn't go into enough detail but if you're used to using first class functions in any other language you'll find the Java version feels bolted on. This is mainly due to the lack of proper closures. This is not a criticism of the implementation, the Java team worked within the constraints of backwards compatibility and produced probably the best implementation reasonably possible. That being said, Go's first class function support is objectively superior. 
Waterloo, Ontario. | Zenreach (www.zenreach.com) | Full-time, onsite. Posting here: http://bit.ly/fullstackdevzr. 
Couple things: Please use gofmt before submitting code. It makes it way easier for everyone to read. You are defining the "secret" flag inside the loop. There is no need to define it 2000 times. In the CSVExport function you are checking for errors, but the function still continous if an error occurs.
Kinda figured a reply would contain complaints about generics. They're orthogonal to this discussion. I agree hacky at best is unfair. You can absolutely add methods to Go functions by defining a type - net/http does it. 
no, they are not. 
Define "real closures" from the user's perspective in this case. They are compiled and serialized in code as function objects, they just happen to look like other objects. I'm not sure the distinction has value from the developer's perspective.
I should have been clearer there I agree. What I mean is that Java lambdas cannot close over variables, only values (usually a final variable). Compilation fails if this is attempted. This limits their utility because they can't store state. To be totally fair, there are gotchas with Go closures as well that some people who are used to functional languages might not like, but I think they are better than Java's. To expand further on my previous point, it seems the author has already decided that lack of generics isn't a problem for his use case (I think many find that for basic services), so I don't think considering the benefits generics provide to Java's lambdas is completely pertinent. 
Meh, a value that's a reference to state (e.g. AtomicReference) serves the same purpose. One could argue not being able to mutate a var in a closure has benefits in a concurrent language. Regardless, we are down a rabbit hole here and I concur w/ the author, I would have chosen Go for the use cases (but author did mention code generation as a viable solution which I rarely agree with).
True. I agree that code generation is not a general purpose solution and shouldn't be presented as one. In any case thanks for the discussion.
American Express | Palo Alto | Contract We need folks who are seasoned Go developers with experience writing and deploying Go applications to production. PM me directly for a quick response. Skills required: - Strong Golang experience - Docker - Integrating Consul - Test Driven Development - CI/CD - Usual Software Engineer requirements - Deployed Go applications in production - Excellent attitude and fast learner - Team player and strong communication skills 
language wars suck. its not about what is technically better, never has been. its what the head / loudest developer has used. you will never win technical contest. i seen CEOs choose it, CTOs.. its rarely a technical decision. 
Eh, I'd label it more overly clever than brilliant ... esp. without comments. I can see why the compiler would have some problems generating the same code for a more obvious construction like "for { switch {} }" but even so.
Samsara| Engineering | San Francisco |Full-Time Samsara is hiring for our office in Potrero Hill in SF. We're are hiring for Product Designers, Security, Site Reliability, Product Infrastructure, Front-End, Full-Stack, Mobile, Hardware and Firmware Engineers Samsara was started by the founders of Meraki and has a small, tight-knit engineering team that’s quickly growing. We are looking for people who love building and seeing their code get used by customers. Our backend is powered by golang/graphql/grpc and our frontend applications use react/react native/typescript. https://www.samsara.com/careers https://www.samsara.com/blog/enterprise-iot-leader-samsara-raises-50m-to-invest-in-growth Please apply directly to site if interested. If you have any questions you can reach out to heather.brouwer@samsara.com. 
go-leftpad
I feel you. I added GoConvey to my personal project cuz it was a breeze and did what I needed it to do. Then over time felt shame due to adding a dependency and not sticking with the std-lib. I go back and forth now whenever I see a shiny, new package. I gatekeep myself and argue over whether or not the benefit is worth deviating from the std lib. For this particular article, I feel like I'd just write the helper functions myself instead of adding gunit, but there are def some useful libraries out there I have no shame in using. I think developers need to constantly ask themselves if something is _truly_ worth it, and not automatically add or dismiss third-party libs.
I love to see more low-level stuff getting implemented in Go. I imagine it's much nicer to use than C for this type of stuff, even if just for the wealth of Go libraries.
Yeah, I've been trying to convince our Software Director that it would be worth exploring. Our datapath will always be C, but we do so much at the slow protocol/control plane level that doesn't need low latency response. We have a REST API in Python that most C/C++ developers hate because it is so cryptic. It could also be done with Go. We are starting to containerize things and so many tools are springing out that could help us.
Go is much nicer for writing APIs than Python anyway, especially in larger projects. Typing mismatches and other error cases that Go finds just saves so many little bugs from cropping up. And C devs won't get headaches reading it.
Or a public package repository that people cannot suddenly remove packages from 
spammer begone
[TENZAR](https://www.tenzar.com/) is a startup in San Diego, CA and we're always looking for talent! We use a lot of Go, Django, and Docker.
&gt; $13.99 Original price : $89.99 Discount : 84% off 4 days left at this price! Scam spam.
send me a pm and we can set up a hangouts call or something, web dev on go can be a bit confusing at first but once you get the hang of it - you probably wont want to use anything else :)
There is some discussion about const pointers (and the like) in [this thread](https://groups.google.com/d/msg/golang-nuts/_XiGWtxhmhE/8iWxTYXCfn0J). It's not clear to me, why the absence of the concept would cause null pointer panics?
It's great to get a panic, you know then that you are dereferencing null pointers in your code. In C/C++ you would be lucky to get an segfault. 
Lack of const pointers didn't cause panics in your code, poor code caused panics in your code.
If you set the compression method to zero, it only stores the data without compressing it, essentially doing the same as tar.
Network functions are just "boxes" which perform various network functions like routing, switching, DNS, Firewalls, VPN gateways to name a few. Typically to get high performance out of these, you have to go with ASIC's or a network processor, a specialized CPU devoted to handling networking packets. Intel changed that with the release of the DPDK, which allows standard multicore servers to provide these functions in a Linux environment by bypassing the slower Linux network stack and directly shuttling the packets to user space, eliminating many context switches. It's no big deal now to handle 1 Gbps of bidirectional traffic with a single core of a server. Many of these functions are now virtualized and applications like Openswitch provide switching and routing between Virtualized Network Functions VNF's. But virtual devices are heavier in weight. It would be nice to implement the networks functions as an app that resides in a Docker container. That's what this toolkit allows you to do.
Eric Lippert's blog entry https://ericlippert.com/2015/05/18/when-everything-you-know-is-wrong-part-one/ covers similar ground for C#.
The slides are pretty clear if you're just looking for a quick perusal: https://talks.bjk.fyi/bketelsen/gcru18-best#/
I've looked into it, but rqlite is a networked layer on top of Sqlite. That is, it still needs CGO and SQLite.
Hey, I also made a tool to help people earn virtual money on [Eldarya](http://eldarya.fr/) called [Purraka](https://purraka.com/). One of the great challenges was to parse HTML tags. The biggest challenge was to authorize Eldarya's HTTP images to be shown on my HTTPS website. Browsers *really* hate mixed content these days.
Have a look at GRPC even if your stuck with C/C++. Might remove alot of the cryptic pain points for the API.
motivation is to learn from you guys how to use channels properly :) I'm thinking that the only people who would like to do this challenge are some intermediate Go programmers and possible some masters.
? I'm just wanting to learn some more best practices and how concurrent programs are structured
who's sprint
?what?
as one example, I need to make sure there is no another goroutine reassign the pointer.
You can't call golang burdensome, if you're gonna use it to write bad code. There are simple ways to avoid exactly what you're talking about, without using `const`. You could avoid this whole situation altogether, if you're a little more careful about how you design your code...
They hate non-https in general, marking http as "non-secure".
[removed]
[removed]
What about runtime dependencies and the additional complexity they bring?
I thought about having it a interface, but I could not come up with one method that would make sense. We are using this library in combination with multierror package, where you collect multiple errors and warning is still treated like error, but is passed within multierror to higher level where it is saved into DB - as status for later inspection.
Have a look at vertx.io, it's a nice framework to create (micro-)services.
I see what you mean. But then we also should not call Go's error handling "error handling" because in the end it is just another return value... I think the point is that "dependency injection" is a concept, and "passing an argument" is a technique. A technique can implement a concept, but this does not mean that the concept becomes the technique.
Well yes, that is exactly how one would use this. By wrapping the error with errors.Wrap(err, "context message") you add message and stack at the point of wrapping, which bubbles up. My package is supposed to be used in tandem with this and multierror.
I considered this at some point as well, but came across some discussions where Go core contributors discouraged such usage as well. Unfortunately I don't recall the link/details, but you may want to do some more research before relying on this for something critical.
Want to parse html. Check https://github.com/PuerkitoBio/goquery
Oh wow, give this man a cigar for the least useful comment in the history of programming.
 package ref type Int struct{ *int } func NewInt(p *int) Int { return Int{p} } func (i Int) Int() int { return *i.int } 
Yeah DI is a concept/principle There are different means to that end. 
&gt;why is 'reasoning about things' such a catchphrase these days? "I don't understand this thing, because I've not been willing to put the effort in to understand it" == "This is hard to reason about".
"I find your comment elegant, efficient and easy to reason about" ^(= "I agree.") 
You can not assign the address of a constant to a non-const.
Yes, we use that for some of the new components and has worked well. The hassle is how slow CentOS seems to be incorporating it, so we end up having to build it ourselves.
Still trying to get this to build though. Some issue with go generate. I also have to do some things with huge pages to get DPDK up correctly.
The obvious drawback of doing this is that the C heap allocations won't contribute to the garbage collector's view of memory usage and how often it should do GC, since they're invisible to it. If the C heap allocations are small this probably doesn't matter, but it could if they're relatively large. (Sometimes you don't even know for sure how big the allocations are, if they're hidden inside a C library that just gives you an opaque resource handle and says 'trust me'.) 
&gt; Most my development is in go but it is also good to have intellij for nodejs and java GoLand has the same nodejs support as IntelliJ as both rely on WebStorm for it. So if you get GoLand you'll have the nodejs support available, but not the java one. &gt; How good is intellij go plugin? Is it as good as goland? Which one do you suggest from a mostly Go development perspective? The Go plugin in IDEA Ultimate provides the same functionality as the corresponding version of GoLand. For example, the plugin available in IDEA 2018.1 offers what GoLand 2018.1 does. The difference is that GoLand is focused on Go development and as such it is cleaner, quicker to start, etc.
if this sounds like homework then wouldn't the teacher be a programmer? or atleast fairly versed in what a programmer would do? and furthermore, all programmers today know about GitHub and most of them use it so the teacher can easily figure out if I've conned others into my homework and I will flunk my exam. I want to learn how to use channels and how concurrent programs are usually structured in Go. If you don't like it don't do it. It's completely optional. btw im self taught and home schooled
Also, GoLand usually gets new features/updates first and they appear in Go plugin for IDEA later. I have IDEA Ultimate and do all my Go development in VSCode. Just a matter of preference. Development in Kotlin, however, is completely different matter - IDEA, without question.
Writing an Interpreter in Go is probably the best software development book I've ever read for any language. https://interpreterbook.com/
&gt; Also, GoLand usually gets new features/updates first and they appear in Go plugin for IDEA later. It depends on the release cycle of the various IDEs, this is true.
Got it. Thanks!
Wait, wasn't rqlite[1] doing exactly this? [1] https://github.com/rqlite/rqlite
https://github.com/CanonicalLtd/dqlite#how-does-it-compare-to-rqlite
"Get Programming with Go" it's a good book for learning Go and programming, it's not published yet but you can still buy the MEAP version https://www.manning.com/books/get-programming-with-go
Thanks! Didn't see that point :)
Cmon man, it's common sense - Every single program would be perfect if developers would just write perfect code! /s
I've never used generics and I've never missed them.
Yes it is, I was just pointing out what browsers say explicitly.
Not really, they forgot JavaScript.
Finalizers are run after GC, not during GC, so scheduling is not a problem (the finalizer keeps the object alive for one extra GC cycle). You can still lose something but if you have that many leaks you probably don't need an exhaustive list anyway.
Why?
Idk tbh, I was tired. I don't know why that's meaningful at all. ¯\\\_(ツ)_/¯
&gt;One of the great challenges was to parse HTML tags. Did you use the [`golang.org/x/net/html`](https://godoc.org/golang.org/x/net/html) package for parsing HTML or a different approach?
I'm just giving you a hard time. :P
&gt; ~~GO~~ Go is not a magical tool which give you faster application compared to Python and Node. Don't buy into the hype, build something , test it and see the result for yourself. This is true, but you can also assume for many cases that Go _should be_ faster than both Node and Python. Not always though. Also, Go doesn't protect you from being a bad developer. If you write something that will end up being slow, it'll be slow. Go does provide you with some excellent tools to help both avoid and detect these kinds of things though.
If you put another newline under your first sentence then the bullet points will be formatted correctly.
I agree with you here, I don't think plainly returning an error without context is very useful. Sometimes it's the right thing to do, but not often. There are some pretty huge flaws with using `errors.New` and `fmt.Errorf` though, as you actually lose the original error if you need to compare against it. That's what packages like `pkg/errors` helps with though. Personally, I'm on the fence about packages like `pkg/errors` though, I also don't think that's particularly idiomatic. Generally I think you can probably just make custom errors types, then at each level you should still be able to provide enough context to the caller about what happened without masking it (like `fmt.Errorf`, etc. will do). One example of where this might be a problem is when using SQL in Go. `sql.ErrNoRows` might not really be an error, but there may be another error that the SQL package returns that is far more serious (e.g. maybe a table is missing or something), in that case, one is obviously far more important than the other. If you used `fmt.Errorf` on whatever error the SQL package returned, you wouldn't know how to handle the error properly. Really though, you can just make some custom errors to handle this kind of thing, or maybe even just for the "normal" types of errors you get, making those catastrophic errors just use `fmt.Errorf` because that's all you need for those even.
Wow! Cool to see my blog popup on reddit ;) I hoped you guys enjoyed to read it, feedback is always welcome.
Are you interesting about project status or about for which the library is intended?
Nice, this is the way EVE is meant to be played. I never got into industry much myself. I'm curious, did you buy stuff cheap and move it, or did you build on location?
Static typing is not just for speed. It’s also for correctness and error handling. I don’t worry about speed that much. I worry about clarity. Most of my time is spend maintaining things and the database is my web bottleneck, not the web framework. 
If you have a point to make, you can do so without the tone. You're also encouraged to add to the conversation, as opposed to whatever it is you're doing here.
I bought items in Jita and sold them for ~20% higher price(buy low, sell high). Building items my self took too long, simply moving items was effective enough. Having the data from killmails was very valuable but I think location is even more important, but that comes with game knowledge.
[removed]
I built some stuff for "decompile" hostile "encrypted" php code (often a block of bytes passed to a eval(), which i wrote in go. I spent too much time messing with parsing php and eventually put the project on hold somewhere, but if I were to re-visit it I would definitely use this as a basis! Thank you /u/z7zmey for doing this!
Why is this here?
Beside books: https://tour.golang.org/welcome/1 https://gobyexample.com/
Agreed. I bought this book and created an interpreter for my own fake language called C-- ..... haha... The book's a marvelous practical guide on how to use the Go language after you've grasped Go's "theoretical" side.
I agree with a lot of this, but I just can't get behind a style guide that recommends taking on a bunch of third party dependencies in every project.
Edit to add: There are many healthy practices covered in this styleguide. I did/will not downvote this sort of post simply because I differ on one or a few points. That said... I can't disagree more with the dependency on an assertion library. Using the following code based on [this example](http://goinbigdata.com/testing-go-code-with-testify): func TestAssertSubtract(t *testing.T) { ds := []struct { name string min, sub, diff int }{ {"zeroes", 0, 0, 0}, {"tens", 10, 10, 0}, {"larger min", 10, 1, 9}, {"larger sub", 1, 10, -9}, {"fail", 10, 10, -999}, } calc := NewCalculator(nil) for _, d := range ds { t.Run(d.name, func(t *testing.T) { assert.Equal(t, d.diff, calc.Subtract(d.min, d.sub)) }) } } func TestStandardSubtract(t *testing.T) { ds := []struct { name string min, sub, want int }{ {"zeroes", 0, 0, 0}, {"tens", 10, 10, 0}, {"larger min", 10, 1, 9}, {"larger sub", 1, 10, -9}, {"fail", 10, 10, -999}, } calc := NewCalculator(nil) for _, d := range ds { t.Run(d.name, func(t *testing.T) { got := calc.Subtract(d.min, d.sub) if got != d.want { t.Errorf("got %v, want %v", got, d.want) } }) } } It's output is ugly and needlessly verbose: === RUN TestAssertSubtract === RUN TestAssertSubtract/zeroes === RUN TestAssertSubtract/tens === RUN TestAssertSubtract/larger_min === RUN TestAssertSubtract/larger_sub === RUN TestAssertSubtract/fail --- FAIL: TestAssertSubtract (0.00s) --- PASS: TestAssertSubtract/zeroes (0.00s) --- PASS: TestAssertSubtract/tens (0.00s) --- PASS: TestAssertSubtract/larger_min (0.00s) --- PASS: TestAssertSubtract/larger_sub (0.00s) --- FAIL: TestAssertSubtract/fail (0.00s) calculator_test.go:25: Error Trace: calculator_test.go:25 Error: Not equal: expected: -999 actual : 0 Test: TestAssertSubtract/fail === RUN TestStandardSubtract === RUN TestStandardSubtract/zeroes === RUN TestStandardSubtract/tens === RUN TestStandardSubtract/larger_min === RUN TestStandardSubtract/larger_sub === RUN TestStandardSubtract/fail --- FAIL: TestStandardSubtract (0.00s) --- PASS: TestStandardSubtract/zeroes (0.00s) --- PASS: TestStandardSubtract/tens (0.00s) --- PASS: TestStandardSubtract/larger_min (0.00s) --- PASS: TestStandardSubtract/larger_sub (0.00s) --- FAIL: TestStandardSubtract/fail (0.00s) calculator_test.go:48: got 0, want -999 Dropping the subtest decreases assert's friction with the standard library, but then context is lost. It's usage, to attain it's purpose of dropping a few lines of code, is also ugly and difficult to parse with a glance: assert.Equal(t, d.diff, calc.Subtract(d.min, d.sub)) got := calc.Subtract(d.min, d.sub) if got != d.want { t.Errorf("got %v, want %v", got, d.want) } More so, in my opinion (and if for only this), reducing a handful of lines of code at the cost of having to learn a proprietary set of equivalency rules makes using an assertion library astoundingly unappealing.
For me the problem with assert libraries is they reduce type safety and this has led to confusion with multiple team members on projects before. (this is an obvious use case where generics would be handy)
Yep, absolutely. You can definitely do some crazy things in the name of speed in Go. I've been working on a parser library (for something that I'm not yet ready to release) that will be used as part of an HTTP request, so I've been trying to ensure that's as fast as possible. It does make for some harder to understand code, but in that case it's worth it in my opinion. Funnily enough it's something that already exists in JS, and the implementation of the lexer is twice as fast as the JS one for most input. I'm sure the JS implementation could also be made faster though. In many cases, especially in most applications it's not worth this. In my case, better performance than the existing implementations is one of the main goals. Like you've said, IO is usually a much bigger bottleneck.
Nice, with that book ill hit twice at once. Learning to write a language and learning go.
+1 to getting a good IDE. There are many IDE that support go now, but only few do so while making it feel native. Visual Studio Code is one of them, GoLand is probably good too, last time I used it, it felt a bit cluncky around the edges, but that was a while ago, and since then it probably is much better. 
There's a bit you can remove, such as the fact you can just [+= an empty map entry because you'll start with the 0 value](https://play.golang.org/p/i-EopSpMY0j), but at its core, that's what you're looking at, yes. Go doesn't have the sort of basic functional programming tools that are in most modern languages.
Aye ! Edited, Thank you very much :)
Very cool! Has anyone made a phpfmt using this yet? I was a PHP developer ages ago and worked with a team that refused to consistently format code. I'm so thankful for gofmt.
&gt; Removed. Pretty tolerant moderator decision right there.
Content doesn't even mention Go. Not relevant to this subreddit.
Herp derp, last time I checked we're in /r/golang Are you going to delete this post too? You sure delete a lot of posts..
You want this: https://tour.golang.org/
Hell yeah- thanks
Interesting talk, was only a little bit distracted by the wig :P
mind share how to prevent this without using const? that would benefit every go programmer
Very very nice, and funny! If you like this talk and want to hear him talk more and make jokes you should try gotime.fm. 
You want me to debug your code, even though you're not bothering to share it? That's almost as ridiculous as modifying a shared pointer in a goroutine. 
Yup, I am not asking my team to follow this. Often choosing simplicity already present in the stdlib even though it lacks features is wise. And I actually only agree with some of it. Disagree w/ the opinion on "Unadorned returns", required signal handling, etc.
Then use some access function if you can't live without it ? It will give you the same functionality. Language creators were pretty clear about this - it will not land in Golang. You have panics = you know where YOU made a mistake, fix it and problem solved. 
So are you saying I can omit the entire else {} block?
WTH. "securely", but passes all data through a 3rd party.
[removed]
In addition to what had already been pointed out in other comments, I also don't agree about preemptively splitting code into many packages. I find it annoying when there are tons of tiny namespaces all over the project and there are 5+ imports for packages in the same project. If the file is big and the responsibility is splitting, then sure, split as needed. I would rather start with less packages and less files. 
Ah, thank you very much. I didn't know anonymous fields in structs were a thing
https://golang.org/doc/effective_go.html#embedding
They are mostly the same thing and use the same plugin. Goland just streamlines the interface to assume you are doing Go projects. I don't like having tons of ide windows open so I end up staying in Intellij so that I have full access to not only Go but python and Java projects. Many of the language plugins are offered in either the language specific ide or Intellij ultimate. 
I’m personally a fan of the In Action series by Manning pub. [Go In Action](https://www.manning.com/books/go-in-action)
fellow eve player and go developer here. ive written some eve stuff in go, feel free to hit me up with any questions!
I'm adding to the discussion by ridiculing the fact that you offered some of the oldest developments of PLT as Go reducing the burden on programmers, in response to an individual being burdened by deficiencies elsewhere in the language. 
I have. Waiting now 😂
Would you mind editing your question to include a solution when you get there?
I personally bought Ultimate Edition this year. I was using PyCharm and Goland, and just consolidated to the one license. Now I get access to more products for the same price of two I was already paying.
Looking for any interns from the San Diego area? :)
Golang.org/tour
I agree with a lot of the points in the style guide. Can someone explain the "Avoid using DeepEqual" point? I've been writing some tests recently, and drew inspiration from Google's go-github project where they use DeepEqual to compare API responses with an expected value. I understand that using reflection for comparison is probably slower than comparing the fields yourself, but the structures that I am comparing can be quite large, and I imagine that writing out a function to convert my struct to a string for each of them is going to be very time consuming and tedious.
Nice start! One of the areas of improvement I see open is better error handling. You could work on improving that next. Basically, make sure the application behaves in a friendly and helpful manner when invalid input is entered.
The whole if. Leave just the true branch.
Thanks, that is good to know 
Another helpful tip. Your `app.Action` code is currently highly nested. It makes it harder to read. There's a very effective technique for reducing the indentation. Read about it here: https://golang.org/s/style#indent-error-flow
Thank you !
I think so! You can apply on our [careers page](https://www.tenzar.com/careers). Though I just noticed that it says Python and C++ when it should probably say Python and Go. Or maybe we're assuming nobody knows Go and looking for C++ devs to train in Go. But yeah, apply there nevertheless!
My first reaction was "This is impressive... But ewe, why?"
My main suggestion is to just not do this :). The Hash interface is set up to be simple to use already. This implementation requires more lines than it's likely to save, adds cognitive overhead for programmers who are already familiar with the stdlib, and is less flexible (note that you're passing in nil when in some cases you can be more efficient if you pass in a buffer). The main reason to wrap an interface or stdlib functionality in your own would be to make it satisfy another interface or to introduce a layer for dependency injection, but that isn't clear in this case.
Embedding is one of the killer features of Go. Once you learn to master it, it fits the pieces beautifully. There is a proposal out there to remove embedding from Go. I sincerely hope that does not happen.
Great content, look forward to next stream!
You picked the worst possible example to talk about constants. Java's `final` isn't even a proper constant anyway, it just means that that reference will always point to the same value. You could have talked about C++'s `const`. If a variable is `const`, you can't take a non-`const` pointer to it, so your second example wouldn't work (if you replaced `var` with `auto` and `final` with `const, of course). C++ also gives you `const`methods, so you can reason about which methods you can call on an `const` object (because they won't change it), and which you can't. So no, constants are not hard to reason about. They're the opposite. When they are real constants (not Java's `final`) they give you a strong guarantee: this object will never change. That's it. How could that possibly be harder than mutability?
I don't use beego, but I don't see why you couldn't achieve this with pretty much any of the web frameworks. It consists of you choosing some way to do the front end, which would be served at a given route such as "/". Then your front end would make calls to other end points from that same single page, such as "/api/..." 
Dammit! I was just trying to decide between Clojure and Go!
There are huge threads on golang-nuts about why there are no asserts in the standard testing library. I can't discourage their use more; I read a ton of Go code and assert libraries and gomock are some of the worst parts of it.
Beat recommendation I can give is to find a problem you're trying to solve and use the language to solve it. You'll have a working product and be able to learn the language at once. Outside of that i'd say yes to the your and additionally the effective go site and pick up a book on algorithms. First example stands though. Also, don't Google your problem. Or if you do, ONLY look at sites that are within the docs otherwise you're just a Google programmer. I've seen too many of those in the last few years as resumes float across my desk and what a waste of time they are. (Apologies for the mjni-rant.)
&gt; The embedded elements are pointers to structs and of course must be initialized to point to valid structs before they can be used. How do I do that if they don't have names?
I’d tend to agree. Creating a custom Hash type just for this line of code doesn’t seem worth the cognitive overhead of the additional layer of abstraction. Great point, seeing the bigger picture.
I indeed used `golang.org/x/net/html`!
you use their type name https://play.golang.org/p/OIXrK6iHMTq
Here is an example of initializing with an existing Hash and also modifying it after the fact: https://play.golang.org/p/iRwSSfCfyb1 You access it by the type name. Embedding only supports one of each type as anonymous fields. 
WHY
So the answer is no
QED-it | Full-time | Tel Aviv | Onsite and remote QED-it, a funded Tel Aviv based startup, is looking for experienced software engineers to join its core team. We are tackling the hardest and most interesting problems in the Blockchain space - solving the consensus/privacy paradox, using zero-knowledge-proofs. ZKP is a new technology, that up until recently was solely explored in academia. We are funded by smart money from top tier angels, and have assembled a team of experts in cryptography, computer science, security and distributed systems. We’re at the heart of the private Blockchain industry. The founders built and sold successful businesses in the space, and are focusing on privacy as the key to Blockchain deployment, impacting industries from banking to aerospace. QED-it is building a unique product combining cutting-edge technology, design and implementation of cryptographic protocols and user/developer-facing APIs. We’re looking to expand our team with more great individuals! -About you- * You have a few years of work experience in tech roles * Have a strong sense of long-term/delivery trade-off * Generalist who likes diving deep into challenging subjects * Looking to be a part of a product bridging multiple levels of complexity in its first stages * Enjoys being part of the whole product life-cycle up until the end-user * Entrepreneurial spirit and a maker mentality * Previously worked in a startup and/or in a dynamic environment * Without using Google, you know what Q.E.D. means, possibly even 2 different meanings -Contact- Send an e-mail to jobs@qed-it.com! 
Writing to stdout creates a synchronization bottleneck that is unacceptable for a high throughput application. 12 factor aren’t rules, they’re guidelines and often bad ones especially at scale. 
I really like to have a stable lisp dialect implemented on Go!
Uber's posted [zap](https://github.com/uber-go/zap). 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/uber-go/zap) - Previous text "zap" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Nice! Nearby: https://github.com/johanhaleby/kubetail
The whole idea of the Hash interface is to get to the final checksum, which is an array of bytes. I haven't found it useful to pass around and `String()` half done `hash.Hash`es. When you have hashed what you want hashed, you have bytes. For some reason, the canonical format for displaying is hex encoded, not Base-64. var h hash.Hash /* io.Copy(h, src) */ sum := h.Sum(nil) fmt.Printf("%x", sum) 
&gt; static typing might be a pain. Yup, PHP &amp; JS dev for 9 years and when I switched full-time to Go it was definitely a learning experience. However, when I switch back to JS for front-end stuff or maintain my PHP applications, the fact that I can go `10.54 . 11 . "fred"` and NOT get an error message does not strike me as a good thing.
I use IntelliJ IDEA Ultimate because I maintain PHP applications. Just make sure you use File Watchers, friendo! `go fmt` and `goimports` specifically. It's annoying for my app to not compile because I commented out a logging statement and it still imports the package,
&gt; Then use some access function if you can't live without it ? It will give you the same functionality. No, it won't give you a static guarantee like a non-nullable reference would. &gt; You have panics = you know where YOU made a mistake No, you don't. You _potentially_ know where you made a mistake _sometime later on_ when the program is run, which _may_ be during tests _if you're lucky_ but it also may be days, weeks, months, years later, potentially in production or on someone else's machine, etc. It is called [The billion-dollar mistake](https://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions) for a reason. I prefer to know about my mistake as soon as possible, preferably right now on my machine, preferably before the program even has a chance to run and cause damage. Of course, there's a never-ending debate on how many static guarantees are enough. Type systems can get arbitrarily complex. However, I don't think this applies to non-null pointers much, given how incredibly huge the number of problems with nullable pointers &amp; references has been historically (and not just in C/C++ but in memory-safe languges as well) and because non-nullable references aren't hard to understand or use. Having non-nullable references should be a no-brainer. However, nullable pointers are very deeply rooted in the mainstream culture and heritage of languages like C, Java and others, and so unfortunatelly they feel "natural" to most people even though they are in fact quite silly if you think about it independently of the said heritage. &gt; it will not land in Golang I know, Golang is pretty anti-type-systems. Oh well. 
Will recommend it too. It has got many examples around go concepts . Although the book contains snippets/parts of programs (just what necessary for explaining a concept) for examples, you can get full working programs at https://github.com/adonovan/gopl.io. Chapter on goroutines and concurrency is pretty good. It's difficult as a beginner to design your program to be concurrent - since there're multiple primitives that you can use (mutex, channels, etc). Book will guide you through examples that'll help you design better. &gt; I think you can read it online at gopl.io Just the first chapter. For the rest, you'll have buy it. I'll suggest going through that chapter; it's a brief tutorial of the language.
I'd love to code web applications in Lisp again :) Clojure + Emacs was great when I tried. What about https://github.com/glycerine/zygomys ?
`zygomys` is awesome! But there is only one active contributor (the main author) and I had some difficulties that needed to go deep into the package(s). So I've postponed the whole experience for now. This was a `generic` wish for some lisp!
I think I’m going to print this comment out and frame it. Thank you! I really appreciate it. 
They got the import splitting wrong. Most packages do: import ( "net" "os" "github.com/me/this-project/whatever" "github.com/me/this-project/whatever2" "github.com/thirdparty/blah/whatever3" ) They switched the 2nd and 3rd parts. Example: https://github.com/coreos/etcd/blob/master/clientv3/cluster.go#L17 Example: https://github.com/purpleidea/mgmt/blob/master/lang/interpolate.go#L20 Etc...
Is there a better way to share a code than to use an image? Yes, there is, use text instead!
If your app's purpose is to emit high volumes of logs, something's wrong. 
If your application has high throughput logs, there _will_ have to be a bottleneck _somewhere_. Doesn't matter whether you follow 12 factor rules or not. If you are managing writing logs from within your application, then you need to manage buffering, syncing to files and all that by yourself. Writing to stdout just creates a clean and simple way to allow the logs to be handled by a different process. And something which you can reuse for all your applications. If one app needs to stream to kafka, whereas another needs to write to elastic search, you don't need to write different code for each of your app.
It is quite common for high-throughput applications to emit huge log volumes for analysis. Especially for content and ad serving systems.
"Logging" is the wrong tool for that.
I'm quite new to go but I've heard complaints about go as a programming language being ill suited for opengl because of the garbage collector and I was hoping someone might be able to address this because looking at go I'd love to try opengl out with go. People say the same thing about java or any language really that has a garbage collector but mlm java performs very well under many circumstances. It does present limitations though. And the little I've read describes go specifically as being even more poorly suited than java because its garbage collector stops the whole world. So any opinions on this anybody? In java there are work arounds with the garbage collector such as pools etc. But eventually optimization can get to a point where its probably just easier to manage memory in native c or c++. In c and c++ you get complete control but at the price of having to code it and in my case probably coding it all the memory allocation and deallocation poorly. The idea I've heard most state is just not to allocate too many things that might need to be cleaned up or not cleaned up in one step. But I'd really love to move into real time collision detection pushing the limits of how many objects can be handled at one time and in situations like java that means working with many instances of objects. Anyhow just curious what the thoughts were of those experienced and knowledgeable of go and those who have worked with opengl and go before. I've also heard a large barrier to doing game development in go is the lack of tooling compared to other languages. From what little I've seen of go I like it quite a bit for web development but that is likely just because I really hate javascript. Perhaps functional programming and closures are just too complicated for me but man does javascript annoy me.
Using the `error` interface does not mean you lose type information. In the end, an error is any type that implements the `error` interface (implements `Error() string` method). Using an example from the link: if err := dec.Decode(&amp;val); err != nil { if serr, ok := err.(*json.SyntaxError); ok { line, col := findLine(f, serr.Offset) return fmt.Errorf("%s:%d:%d: %v", f.Name(), line, col, err) } return err } The type assertion in line two allows you to handle errors in a specific way. The same is done in `os` with `*os.PathError`, `net`with `*net.OpError`. I do it the same way for errors that need to carry more information. If there are very specific errors, you can use a package variable to compare against. `database/sql` does this with `sql.ErrNoRows`. Just create the error with `errors.New` to produce a descriptive error. Why not have the error in the function signature? You make it harder for yourself and the caller. For yourself, because you are restricted to that one error type. You can't just pass through an error that is out of your control, e.g. trying to open a file that doesn't exist. You have to shoe-horn every error case into your new error type. You make it harder for the caller as you can't: - reuse your error variable, if the error doesn't implement `error` - easily log the error as it doesn't implement `error` - type assert as the value is not an interface, you lose the actual type of the error and associated info in short: it makes everything harder. The `error` interface is the sane default case, and as it's an interface, you can still access the actual error by type asserting. 
We use Zap extensively in [Nakama](https://github.com/heroiclabs/nakama) - It's truly a joy to use and develop with. Highly highly recommended.
you used implicit field names which will bite you in the butt sooner or later (field order dependent, information hiding)
It just depends. If you wanted to make the next version of Doom, then using a garbage collected language to do it all in would be a poor choice. Plus C/C++ offers other performance opportunities like complete access to SIMD instructions. On the other hand the best selling game of all time, Minecraft, is in Java. It suffers a bit for it but that didn't stop it from making billions of dollars. Go has three advantages over Java - the GC is lower latency, so GC pauses are likely going to be much shorter with otherwise equivalent implementations, or you would not need to bother with pools as much in Go. It compiles to native binaries instead of being jitted, which improves responsiveness of anything that has a UI (functions aren't being jitted the first time you click on a thing, and so on) Maybe more important for most games is Go can do value and reference types, rather than only reference types. (C#, a popular game programming language, also has this) Go has one disadvantage in that the overhead for calling into C libraries is higher than it is with Java or C#. If you made *many* calls to opengl per frame, this could be an issue, though that is not typical. As you said at the end, the largest barrier is a lack of tooling. If you want a robust engine and tons of libraries, that isn't there the way it is with c++ or C#. If you want to do things from scratch anyway, which is not unusual, Go is fine. 
&gt; Calling functions should eventually handle the error - how do I eliminate the tight coupling? In my opinion: You can't. All you may be able to do, is to remove compiler checks verifying that you are coupling correctly, but the coupling itself is intrinsic. Say, for example, you are using a package `foo`, that stores some state in a file. Any errors encountered are passed on to you (potentially wrapped in some way). At some point, that package gets a feature to read the state from the network instead, say by making an HTTP request to etcd. Suddenly, all the possible error classes completely change - previously, you would get e.g. an `*os.PathError`, now you suddenly get a `*something.HTTPError`. When switching to the new feature, your code breaks, because you type-switched on `*os.PathError`, which will no longer be returned, but the compiler was happy (because it got an `error` and `*os.PathError` satisfies the `error` interface). From this POV, errors and their types are inherently API surface. Any concrete type that `foo` returns and that you rely on becomes part of `foo`s API. But the underlying errors (in this example `*os.PathError` and `*something.HTTPError`) that `foo` encounters are *implementation details* and shouldn't have been exposed in the API without careful consideration. As a consequence, if you rely on any feature of an `error` except it's `Error` method, you are either a) binding yourself to implementation details, which are bound to change and won't be compiler checked or b) are relying on documented, stable APIs, in which case *it is fine to couple strongly*. Just as it's fine to couple yourself strongly to the signature of some exported function of a different package. A corollary of this is, that packages should spend just as much time thinking about their error API, as they should spend on all the other APIs. And find the right tradeoff between hiding implementation details and providing the flexibility and useful information to handle the errors they return. Personally, I tend to start with "expose no information but the error interface" and then refine by adding types, once the need to distinguish errors arises.
Use both. They're both wonderful for different problems. Clojure is great for web stuff and Clojurescript makes writing react apps fun and easy. I use go for command line utilities because it's easy, quick, straightforward, and the startup time is worlds better than Clojure. 
Just use logrus + lumberjack. 
You should start with A Tour of Go or The Go Programming Language. If you are more interested in looking at how to use Go in Work related setting, I would recommend [Distributed Computing with Go](https://www.amazon.com/Distributed-Computing-concurrency-parallelism-applications/dp/1787125386). It covers important topics like Containers, Docker, testing etc from ground up. 
Now up on youtube as well: https://www.youtube.com/watch?v=yxAPS2eyKmA
Got to build. I think there is some issue with the ubuntu install and go generate. Once I installed the compiler directly from the tarball, it worked fine.
It wouldn't be C++ if it didn't bundle the very useful tool with a shotgun pointed at your feet. 
I don't remember framework meaning import. A framework is a structure you build around... Its a loose term... 
stdout isn’t the bottleneck, it’s whatever is consuming logs on the other side, which is going to exist in any log pipeline. 12 Factor isn’t a panacea but this rule is pretty inviolable.
Surprised no one brought up vscode 
Logging is simply emitting discrete events.
[removed]
Unfortunately I have to live with an EFK stack which is a PITA; just yesterday I have watched one of your presentationson ok log and find that approach intriguing. But I guess my devs are too much accustomed to the "comfy" kibana ui. Well. I try to teach my developers, that we're not in the business of log output generation. When I hear people saying they'd need "logging" for analysis, my first guess is, they're abusing it for things for which they should use prometheus. Or any other *structured* means. Certainly not bulk text dumps. 
We're hiring for a Senior Go Developer at [Hatchify](https://hatchify.co/). Remote | US | Full-Time The position is fully remote, with a need to travel to the office once a month. We're a fast-growing startup out of Richmond, VA that's empowering sales reps across the country. Our app actually makes their lives better, removing the need for cold calling, getting cussed out, etc. I built the infrastructure from scratch in Go and as the second engineer, you'll have wide control over where the platform goes. You can apply via AngeList [here](https://angel.co/hatchify-1/jobs/350658-senior-backend-golang-postgres-engineer-us-remote). Salary and equity are negotiable. We're not looking for a rockstar, just a solid engineer who's able to communicate well, has some amount of emotional maturity, and wants to create value and be valued. General Reqs: - Fulltime - MUST be in the US, East-Coast based - Remote (monthly travel to Richmond, VA) - Quick response times - Invests in team Communication (very important for remote) - Expert in tools of the trade GoLang/JS/Postgres - Expert in highly performant processes, people, and tech - Expert, and delighted in wearing multiple hats (tech debt, documentation, bugs, features, you think about the whole process) *Able to listen to the people/data/etc and quickly solve problems cohesively - Self Technical Reqs: - Four or more years writing Go in production - Fundamental understanding of SQL databases and PostgreSQL in particular - Fundamental understanding of data structures and when to use one over another - Experience with concurrent programming in Go - Ability to ramp up quickly and own a piece of the codebase Our platform is young and evolving. There's no legacy cruft to sift through. Your voice will help determine the direction of the platform and the company. https://angel.co/hatchify-1/jobs/350658-senior-backend-golang-postgres-engineer-us-remote
As of 2018.1 the IDE is capable of automatically adding/removing imports without having to use ` goimports `. See https://blog.jetbrains.com/go/2018/03/29/go-the-distance-goland-2018-1-is-here/
are you using ide, static analysis tools, formatting tools, transpilers?
Thanks, I see. I will work on that, apreciated the time you spent checking the code. Thank you so much! :) 
This post has parts that are in active disagreement with what the *actual* Go designers have said. bahlo, please label your opinions as your opinions.
[ActiveState Software Inc.](https://www.activestate.com/) | Remote in North America or Vancouver, BC (our HQ) | FT | No visa sponsorship I'm hiring for a new member on my team. We're developing a new system using Go, Docker, DCOS, Mesos, AWS, and other interesting tech. See https://www.activestate.com/careers#op-243215-senior-developer for the full job posting.
I'm currently migrating the codebases at work from logrus to zap, and it's great. The speed improvement per log entry is pretty extreme too.
You can file bugs at https://github.com/golang/go/issues
Using interfaces is fine, because you can test for behaviour instead of specific types. To eliminate the tight coupling, you can present new errors, or at least bubble up errors with some specific behaviour (i.e. not a type) and handle it later by testing the behaviour.
I don’t know. You think he will appreciate that? :-)
Single-page applications are a front-end thing. Unless you literally mean all of your content just goes on one page, and there's no JS. Either way, you can handle the backend with Go, but not something that goes on in the browser. You could use GopherJS to write Go that you can run as JS in the browser though with something like Vecty.
I was not sure that's the right place. Done. Thank you. 
neat!
Thanks!
I see, thank you. I assume I can only have one anonymous field of the same type per struct, correct?
You mean in the first example, right? It should have been hash.Hash: sha256... I am currently learning Go and I'm trying to understand as much as possible.
&gt; No, it won't give you a static guarantee like a non-nullable reference would. You will never get 100% static guarantee in Golang without major language changes and you are talking about references or pointers now? which in most languages that I know both mean different things (while they are the same things under the hood). You can take reference to dereferenced value of pointer which can be null. So if you want const pointers with const values they point to, you would need to recursively prove they are non mutable. But what if you forget to make something const? Lets make all pointers non-mutable by default, right? Where do you stop? When enough is enough ? Golang wouldn't be the same language after those changes. If you want those guarantees just use different language. If this one is not fitting your needs, especially if you know (from language creators) that this change will not happen. I am completely fine with using Golang without const pointers. But there are languages that fit your description. 
Probably why he hasn't made any announcements.
From a cursory glance, this appears to be a library aiming to implement IPFS (https://github.com/ipfs/ipfs) in Go. 
One of the only things I have actually seen get in the way of writing SPA's is that some routers do not allow serving static files from / and then have dynamic routes underneath that. Not all routers support this, some do, or some frameworks even get you to serve static files using a fallback middleware because the router cannot serve static files under / itself with dynamic subroutes present.
I would always choose the type assertion. For one, there's no risk of mistyping the magic string.
The answer is "it depends", really, especially when the compiler will restrict when you can use the second one.
Do you accept pull requests? Wanted to refresh my memory about some algorithms, and you are missing for example quicksort if ive seen correctly
the short answer is that your question lacks sufficient context. neither are really idiomatic go because a problem like this would not be modeled as multiple interface types that don't satisfy the same interface. taking a stab at an approximation of your problem, I'd consider doing something like this: https://play.golang.org/p/s9GPE3UId2N
Maybe merge with: https://github.com/emirpasic/gods which I think is the most referenced version of this kind of thing.
Thanks a lot. 
[removed]
Other redditors have commented, widely on a variety of other things. But something in particular jumped out at me: &gt; particularly in Go, where the programmer is encouraged to return up the stack. In Go, the programmer is encouraged to handle errors. Returning up the stack isn't particularly great for a huge number of usecases.
Are you talking about my example of using embedding? I can't speak for every application, but this example was dealing with the goal of wrapping a type to extend it by one method. Embedding has its uses. 
&gt; Args hold the command-line arguments, starting with the program name. https://golang.org/pkg/os/#pkg-variables https://golang.org/pkg/encoding/
That's a bit vague. By console input do you mean like command-line flags? You could do something like package main import ( "flag" "fmt" ) var foo struct { A int } func main() { flag.IntVar(&amp;foo.A, "a", 3, "set a") flag.Parse() fmt.Println("a is:", foo.A) } Or maybe you'd like to read text on stdin, and write to a file? Json would a handy format to do that. package main import ( "encoding/json" "log" "os" ) var foo struct { A int } func main() { // read json foo on stdin d := json.NewDecoder(os.Stdin) if err := d.Decode(&amp;foo); err != nil { log.Fatal("could not read json on stdin:", err) } // write to "foo.json" w, err := os.Create("foo.json") if err != nil { log.Fatal(err) } defer w.Close() b, err := json.Marshal(&amp;foo) if err != nil { log.Fatal("could not marshal json:", err) } if _, err := w.Write(b); err != nil { log.Fatal(err) } } Sample usage: $ echo '{"A": 8}' | go run test.go $ cat cat foo.json {"A":8}
Your question is both short and very broad. It actually covers a number of concepts, so any answer is likely going to be just as general. Have you tried anything yet? Here are the high level steps for you to Google: Reading input from stdin ([Example](https://tutorialedge.net/golang/reading-console-input-golang/)) Convert a string to [type] ([Example](https://golang.org/pkg/strconv/)) Encoding structs ([Example ](https://gobyexample.com/json)) Writing to a file ([Example ](https://gobyexample.com/writing-files)) 
As mentioned, it's a loose term, and a discussion about terminology is not why I posted this. If u want it, go for it, if u don't, that's also fine. Call it whatever pleases you 
...asking for a friend
If this is the complete spec of the file then it doesn't seem complex enough to warrant a grammar/parser library. Looks like you can just use a Scanner to scan lines. If it's a start section, save the name. Then read lines into a body until you hit the end section. There are only two tokens to look for. 
I think the first example ("Add context to errors") is good, but a very bad example since the `os.Open()` error [already contains the filename](https://golang.org/pkg/os/#pkg-overview): &gt; If the open fails, the error string will be self-explanatory, like &gt; &gt; open file.go: no such file or directory So you'll get: open foo.txt failed: open foo.txt: no such file or directory The "open foo.txt failed" is entirely redundant, it also doesn't describe *what* you were doing, and this message can be hard to trace down to a specific location in the code. Much better would be something like `return errors.Wrap(err, "could not open output file")`, as that describes *what* you were trying to do, rather than just duplicating the error that stdlib returns. Even just putting the function name (`return errors.Wrap(err, "OpenLog")`) is a lot better.
https://play.golang.org/p/BVL62oVOcE_V
These are very clear and easy to understand. You write textbook perfect code :)
This is quite interesting, but re-treading the rendering side of this problem space does seem tremendously wasteful. It would be far more interesting, and powerful, if `glyph` were a translation helper to move from the Github Issues/comments to another, already existing, engines format. For example, it would run, grab all the data from the repo, and turn it into the right structure for a Hugo blog, then call that to render. This would give you all those really nice extras (nice GH UI, user, etc) but would not burden the program with reinventing the entire rendering pipeline (which is no small thing to undertake). Regardless, nice work :)
`~/.bashrc` is bash-specific, whereas `/etc/profile` and `~/.profile` are shell-agnostic. The current recommendations are correct and complete I think.
Very true. I was mostly reacting to what felt to me like the sentiment that op should just blindly follow 12 factor. We don’t know his motivations but just throwing 12 factor in his face is narrow thinking. 
The title of the post is literally "An opinionated styleguide".
Anyone have real-world usage of this package? (github, bitbucket, or gitlab, etc..)
Cool! Will go through this. Go is a very good and plain language to do these things in. 
Can I create a struct filled with functions or closures (yes, I get that a closure can probably create a function, at least in languages I'm used to that's my usual usage for it) at runtime? Since functions are just a type that a variable can hold, yeah? Like, I'm guessing you could tell I've thought about this problem in other languages which often uses reflection so I think I get what you're trying to do, but.... well, I might end up using this more often than I'd like as part of some sort of pickling system as well (or does such a thing already exist for Golang? Like is it possible for me to basically save basically every relevant pointer+type of that pointer then keep the data from being trash collected for the time it takes for me to read off the raw data into a slice I guess it's called where each part of the slice is of variable bytes holding the actual data and then later basicalily dump the data back into memory using the slice to dictionary array to recreate the pointers to the data which would be more or les sunchanged excpet in cases where there's an already existing function to pickle or backup or whatever an object and then recreate it?) I don't even know if that's a logical thing to do or remotely possible, but I THINK I need a way to basically... Okay, basically temporarily create two more or less perfect versions of the data which are both running an outdated version of my program and restart one then load the data back in and restart the other and load the data back in if at all reasonably possible. I know this is a separate question, but.... Well, basically if I'm given a bunch of objects is there a reasonable way to save them then reload them from there saved point if I keep track of what I saved at least as far as the type of what I saved and maybe tag or whatever I saved? I guess type changes are kinda confusing me along with whether I can just save an object as a value and then later resurrect it using just the value's data (seems like I should be able to, but who knows?) as long as I know its type so that I can take the value (which I can keep in only one version being updated at a time and send to the other as a value ) of everything relevant then reboot things with all the values turned back into the right type and working as if not rebooted (assuming the type doesn't get changed). Like I wouldn't do this with all data, just a certain subset, but it would be a hugely helpful to be able to update while 'live' by updating two synched versions (well, one by one the two versions which synch CERTAIN data in full and not other data which I won't reset when I reset anyways).
HOpefully that does get more support including Windows.... but it looks like it does work as I'd hope something would and is one possible fix for me. If it's not too complicated then my group can have someone work out how to make that work in cases it currently doesn't if we don't just use reflection instead. But it sounds like it kinda serves different purposes actually - we'd use reflection for one thing and plugins for the other.
&gt; https://github.com/dearplain/goloader Interesting. We might have a use for that with our plan to use html5 for graphical stuff plus some javascript code mixed in potentially at points (possibly just JSON). Thank you!
Well, it looks like I'm likely to use it as half-APi half-customFFI (the code it may be interfacing with and actually talking to may or may not be Go code, but from the outside it shouldn't matter just like any well written API shouldn't care much about the underlying code).
&gt; Can I create a struct filled with functions or closures (yes, I get that a closure can probably create a function, at least in languages I'm used to that's my usual usage for it) at runtime? I guess you can though I don't see the purpose of this. Just create a struct , then functions that take that struct as a parameter and wrap everything in your own custom object. Struct methods only make sense if you have the need to implement existing interfaces. Anyway, be cautious here, Go might not be the best language for your requirements, even with the "plugin" functionality, the JVM or a scripting language like Python might make more sense.
Whatever performance problems exist in serializing to the stdout FD also exist symmetrically in serializing to any other FD. A highly concurrent application benefits from careful log sync behavior regardless of the output writer.
Drive by comment would be that your method/variable names are a bit long and we don't name things with Get prefixes in Go. user.Name() and user.SetName, not user.GetName.
The plugins will have to be other go binaries. But did you consider just executing the given binaries as subprocesses? You could then communicate over stdin/stdout with the subprocesses. That communication is of course slower than using a plugin but you would be completly language agnostic. 
i've found solution here: https://wiki.debian.org/EnvironmentVariables *"Graphical logins do not read a shell's startup files (/etc/profile and ~/.profile and so on) by default, but you as a user may choose to create a ~/.xsessionrc file which does this."* so i created ~/.xsessionrc and added if [ -f ~/.profile ]; then . ~/.profile fi and it works after logout and login again.
If you run into problems with memory you could change your format slightly by requiring the first lines to be an 'index' of sections available and where they start in the file. Then you dont need to read the whole file to find the last section
I just been collecting stuff to put it all in one place for reference. https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk
I love how he is helping all these serious kids while acting like a woman. Goes to show it doesn't matter who or what you are doing, if you have the answers.
@twain2048 you missed that, this is where the `iris#SPA` method comes into the game: https://github.com/kataras/iris/blob/master/_examples/file-server/single-page-application/basic/main.go#L31 Iris and net/http packages are the only routers that support these type of things (static paths + dynamic and wildcards in the same path prefix). Have fun
There is a bug in your ternary search where you update the bounds. You only throw away either left or right side and never reach the else. Conceptually, instead of throwing away parts that you don't need, you should leave only the needed part. That way you leave 1/3 of the array instead of throwing away only 1/3. So it should be somthing like this: if number &lt; midIndex1 { // number in first third, so move max to it's end maxIndex = midIndex1 - 1 } else if number &gt; midIndex2 { // number in last third, so move min to it's start minIndex = midIndex2 + 1 } else { // number in the middle - drop the sides minIndex = midIndex1 + 1 maxIndex = midIndex2 - 1 }
Cool
It's unclear what problem you are actually trying to solve. You describe how you want to solve it but not what's the issue that leads to it.
i think your question is how to choose and set a field of a struct based on an unknown variable take a look at reflect package another way is to redesign your architecture
Enlighten me: how would promotheus how with the logs issue ? :)
Someone asked something similar a couple months ago, [my answer](https://www.reddit.com/r/golang/comments/7qb74r/can_golang_package_source_with_no_imports_be/) is the same here: arbitrary code execution is never the right solution, ever. Consider that the entire Go tool chain fetches libraries from the internet and compiles them to architecture specific executables for your os, without executing arbitrary code. Ignoring [CVE-2018-6574](https://nvd.nist.gov/vuln/detail/CVE-2018-6574) of course since it was fixed, because arbitrary code execution is a security risk too high to accept. I would be glad to nudge you in a better direction, but so far you have only described the potential solutions so you would need to define your problem.
You need to ask yourself, what you want to know? Do you want to know *if* there was an error or *how many* of them? Use metrics for that. Hoarding metric tons of unstructured text rarely satisfies reasonable research questions. 
Yes, OP has fallen into the xyproblem. http://xyproblem.info/
This is a valid concern and good idea. I honestly didn't think of this before. Probably because I had no prior experience with Hugo or other static site generators. However the rendering pipeline already works and it wasn't that big of a deal thanks to the great libraries I used for markdown to html processing and for templating. In my opinion the greatest benefit would be to have access to more themes. I will however consider to add hugo (or others) export as a feature (low priority).
Yeah, I get that. I meant the GO binaries may end up going outside the boundaries of Go code.... it's going to be an annoying real world necessity for my case.
Unfortunately, arbitrary code execution is actually what I need.... technically I just need arbitrary API's and then I let other programs run their own code and spit back out what I need, but I either need a very complicated thing to restart without problems while loading in new API's or, more realistically, the ability to load in arbitrary code (well not truly arbitrary, but.... a decent amount of freedom in its form) is important. I can't really go into more detail, but it's not intended to be truly arbitrary code execution, at least.
&gt; and you are talking about references or pointers now? which in most languages that I know both mean different things Both of those have different definitions in various languages. Golang has "pointers", but you can't perform arithmetic on it and dereferencing is safeguarded, which in my book makes Golang pointers actually more like references. In any case, I don't really care whats it's called. &gt; Where do you stop? When enough is enough ? There's two things being conflated in this topic: Immutability (aka constness) and nullable pointers. OP seems to ask for immutability, apparently alluding to the fact that using immutability a const non-null pointer cannot be accidentally re-assigned to a null value. However, a similar effect, arguably in a better way, could be achieved with non-nullable pointers/references (like Kotlin has, for example). IMHO support for immutability would be a larger change than non-nullable pointers, non-nullable pointers are IMHO fairly simple to implement. In any case, I was mostly just expressing unhappiness of having "regular" nullable poitners like in C from the start (albeit with safeguards against UB). I don't see any good reason whatsoever to have pointer/reference types that are nullable by default. In case of languages like Java it's more understandable as they are much older than Go and more traditional. With Go, on the other hand, at the time of its inception it was already perfectly clear that nullable-by-default poitners are a bad idea that only causes trouble and has no benefit at all (and that nullability should rather be opt-in). But alas the milk is spilled now and it's not going to be easily fixable, as you pointed out (without language changes). &gt; Golang wouldn't be the same language after those changes. Well, yes. That's kind of the definition of language change. That's the whole point. &gt; If you want those guarantees just use different language. I try to not have a 'favourite' or 'go-to' language, I try to be familiar with multiple languages and choose a language or multiple ones based on project's needs. But yes, if robustness is a strong requirement, then another language should probably be chosen... 
'last' section. Always assume the worst case that could happen. Also you could assume that the first section takes 90% of the file and if you search for any others you need to scan all of these lines from the first section. I know this is probably not really necessary as he said tge files would probably be in the kib range, but thinking about scalability is never wrong ;) 
But again, you are focusing on the solution that you have thought up, and are asking only about how to implement this solution. What we need to know is the *problem* that your stated solution is trying to solve. Knowing that, we would be able to suggest alternative solutions. You speak of "arbitrary data" and "arbitrary API", but this conveys no meaning. Are you building a database that others can manipulate? If so, what does it contain? The solution you are suggesting sounds flat out conceptually *wrong*, and thus we would love to guide you in a better direction.
There are projects that provide an interpreter layer, to which you can expose a subset of what go provides. For example, if you wanted to expose only your APIs, you could do that, without giving access to packages like `os` or whatever else that could cause damage. https://github.com/mattn/anko It obviously has other caveats. The performance will not be great as there's a "virtual machine" running and interpreting this code. The second caveat is that the syntax will not exactly be the same as Go, but from what I see, this project provides at least somewhat compatible syntax overall. There are also projects that give you a javascript VM (a lot more complex than this), and there are other language interpreters available also. I find that this can be a good tradeof between arbitrary code, vs. code that is basically sandboxed to access only the objects that you pass to it. I haven't used the particular GH project in production, because I rarely have so high demands for arbitrary logic injection, to warrant inclusion of a VM.
A few bits and pieces about writing more readable question posts: 1. Focus on first describing the problem you are trying to solve as exact as you can, without any detours. *Then* describe the solution your are attempting, and *then* describe the why you are having trouble with that solution. 2. Avoid ellipsis ("..."). It has no place in a post like this. Period, comma, semicolon or em dash. 3. Use paragraphs whenever the subject changes slightly. That is, two newlines. Example, based roughly on your post: I am building a product that should contain a datastore (explain data!) and some base functionality (explain functionality!), which has the capability to be *extended* with additional functionality (explain example additional functionality!), preferably at runtime. How would one go about doing this in Go? I was imagining something similar to loading plugins with additional functionality. Is this doable, or are there alternative methods more suitable for this task?
Thanks a lot!
Thank you too :)
You seem to be down the right path. The fact that read and parse aren't exported means that awkwardness of doing the close in a separate function is OK because you aren't leaking that to the consumer. You could refactor it 100 times without a consumer knowing. That means you can live with the awkwardness for now and fix it later. In terms of interfaces, just consider them to be dependency injection points. Your module to parse a config depends on something to parse from (aka the ReadCloser). The read function may be better as an "open" more than read since you could get a ReadCloser from the operation and aren't reading until you parse it. My 2 scents. Also, for potential inspiration, maybe some code in github.com/spf13/viper might help?
I think your first step is to define how your network communiction would work. Are the clients communicating among each-other, is there a central server that dispatches to every client. And regarding the communication protocol, I feel like for such a simple use case, anything not hand baked would be overkill. Of course YMMV. :)
Yeah, VS code has some good tooling for Go. Beyong just the main go package.
Another vote for VSCode
VS Code is honestly good enough that I am not sure why anyone would bother paying for an editor. The Go support provided by the Go plugin is top notch.
In case you are willing to invest in a „little bit“ of learning, you can switch to vim + tmux Vim-go Plugin https://github.com/fatih/vim-go Vim IDE https://github.com/farazdagi/vim-go-ide In the beginning it is painful but in the end you are so much faster :)
In order to bring another point of view to this thread: For small projects, I use Vim, with https://vim-bootstrap.com Go configuration And for larger projects (lots of files, directories, etc) I use Atom editor with go-plus plugin.
Is atom any good? 
I'm not sure what you mean by "not real time" ... Do you want to have a connection permanently open between server and client? From what you mention as your use case, I'm not seeing why you'd need that.
Thank you! Your answer and habarman's do sound, um, like sound advice. The tip about keeping game logic and I/O isolated is something I'll keep in mind. 
grpc-websocket-proxy can stream to browser clients. 
not something Go-the-language gives you; you've just got to rely on docs and source code reading. i'm curious what things you would like to handle specially though. (i tend to treat net.Listener errors by printing them and retrying after a delay.)
(though i guess in theory something like guru coukd do this analysis for you, tho i dont think it currently does)
Didn't they remove it because they released an entire Go IDE?
No. And not just for Go.
It is an asshole move. I really want one IDE to rule them all and I use the paid version of IntelliJ, I really don't want to install and run a separate one for Go. I typically work in Java, Python and sometimes Ruby, in addition to Go. Can't believe this, I might just go with Microsoft. VS Code is free and runs on Linux now. . . the times they are a-changin'.
Anyone here running VS Code on Linux? If so, how well does it work? JetBrains people, I hope you're reading this, I am super pissed that I can't use a Go plugin in IntelliJ anymore - I have the full enterprise version too. I used to love Komodo for the very reason I have loved the IntelliJ suite - an IDE I can run cross-platform with many different languages. ActiveState's product quality really went downhill after a while though. I do NOT want to run Goland AND IntelliJ. Also. . . did you drop support for Ruby in IntelliJ too? The last time I tried to install the Ruby plugin, I couldn't get it to work. 
I don't think so. Some hand baked messages encapsulation over HTTP would be enough, at least to get you to start prototyping. If you find it too slow then you can move to passing messages over UDP, which doesn't have all the overhead of waiting for TCP handshake and all that. But my personal opinion is that that's in the realm of FPS games more than what you have in mind.
What are you talking about ? There is still a go plugin for idea. At least I installed one couple of weeks ago. 
Unless you look at the source code, you can't know.
Vim with [vim.go](https://github.com/fatih/vim-go)
Yes, but their standalone Go IDE doesn't have a permanently free version like IntelliJ does.
My work machine was Ubuntu and vscode ran perfectly for Go development, much better than sublime and I've not tried any more. I'd highly recommend vscode to anyone who hops between operating systems frequently. The "synchronise settings" plugin is amazing for that.
I had issues with Atom constantly crashing, removing my changes, etc. I ended up switching to VSCode and haven't had any issues. 
It's $90 / year and they'll give you a free license if you're working on FOSS. https://www.jetbrains.com/go/buy/#edition=discounts Seems pretty reasonable to me.
I disagree. JetBrains make software, mainly IDEs. It wasn't an unexpected move on their part at all. They have to make money to continue making software, and paying their staff who work on specific IDEs. Microsoft can fund something like VS Code easily because they make a LOT of money elsewhere, and it's a great way for them to raise their profile further, and that of Visual Studio in general.
The Go plugin for IntelliJ Ultimate still works fine. I've just loaded up, updated it, and used it to try it out.
I would consider using eventsource or websockets, and I'd do so without a framework but possibly with one of the libraries that implement these if you don't want to have the fun of learning how they work by implementing them yourself. I'd also encourage you to look at AppEngine standard Go runtime for hosting, as it has super easy datastore, authentication, and channels support and has a lot of free quota.
VS Code or Atom with Go plugins installed are more than enough for me. On atom the go plugin is “go plus” or something, I think on VS Code it’s “Go Lint.”
Do you have autocompletion in vim? The standard solution (gocode) seems to be [broken](https://github.com/nsf/gocode/issues/500) since go 1.10.
Atom is great for exactly one thing for me, and that is pair programming. Teletype is legitimately bonkers awesome. Everything else? It's slow and buggy. I switched back to Vim after months of fighting with Atom and I'm much happier.
Autocomplete is quite crap compare to what GoLand had in beta versions, debugger support is really poorly supported and designed, but that's just how VSC does in all languages.
Thanks a lot! 
+1 VSCode with go tooling is fantastic.
Really? I thought autocomplete and the debugger were fairly good. I will have to give goland a try then.
There is Go plugin for IntelliJ (Ultimate), which is equivalent to Goland. 
The Go plugin maintained by the Go community (I'm one of the maintainers) has stopped development about 1.5 years ago, with very few contributors to it. The old plugin can still be installed in older IDEA/other IDEs versions. Jetbrains took it and made it inline with the other languages they support, with a standalone IDE, GoLand, and a plugin, which has feature parity, available for IntelliJ IDEA Ultimate 2017.3+. I'm sorry that you have issues with the plugin on your new machine, please feel free to raise an issue on our support tracker: https://youtrack.jetbrains.com/issues/Go or ping me here, on Twitter, or on Gophers Slack (same nickname as here). Full disclaimer: I'm now working as of this week as a Developer Advocate for JetBrains, previously (when maintaining the open source plugin) I had a different job.
The Go plugin is available for IntelliJ IDEA Ultimate 2017.3+, just like all our other language plugins. I'm sorry that this was not clear enough, if you need any help, please let me know and I'm happy to help you.
Somewhat related; Out of curiosity, why do we still use standard JSON APIs? Would an RPC library be more efficient than REST/etc JSON APIs? I've never tried replacing any of the user facing *(read, browser facing)* JSON APIs I write with RPC, but I'm quite curious if it would be more efficient. Ie, less data transferred, more robust for security, or ... whatever. Thoughts?
If I worked for someone who forced me to write PHP and I didn't want to quite, I would totally write all my tooling in Go! :)
Hi, Fresh JetBrains team member here but I think I have enough insight into this. &gt; JetBrains people, I hope you're reading this, I am super pissed that I can't use a Go plugin in IntelliJ anymore - I have the full enterprise version too. The Go plugin for IntelliJ IDEA Ultimate 2017.3+ has feature parity with GoLand 2017.3+. For example, if you use IntelliJ IDEA Ultimate 2018.1, you can install the Go plugin which will have the same features as GoLand 2018.1. You can see the Go plugin page here: https://plugins.jetbrains.com/plugin/9568-go &gt; I do NOT want to run Goland AND IntelliJ. You don't need to, as I mentioned above. This is inline with out other languages that we support and have a standalone IDE or can be used in IntelliJ IDEA. &gt; Also. . . did you drop support for Ruby in IntelliJ too? The last time I tried to install the Ruby plugin, I couldn't get it to work. Unfortunately, I don't have any experience with this plugin but I'm happy to reach out to the right team if you can provide more details on the issue. As far as I can see, there is a Ruby plugin available, https://plugins.jetbrains.com/plugin/1293-ruby, as it is for Go or Python. My apologies for any confusion, please reach out to me if you need any help. Thank you.
Every debugger and code style supporter from JetBrains is top tier. Nothing is even close to that.
I agree, but I would still like to introduce you to [Delve](https://github.com/derekparker/delve), if you haven't heard of it already. Great tool. It's pretty integrated into my vim setup so I can't speak for how it runs natively but it feels more in tune with the run time than GoLand's does to me. To be fair, I stopped using GoLand when it was Gogland...
I saw goLand recently and loved the feature where the param names are in the function calls. Does vscode have a plugin like that?
vscode can't show me a list of interface implementations
what does that mean?
That's correct. I never upgraded the plugin for 2017.1+ because of lack of time and nobody else contributed to the sources either. However, at this point the open-source plugin has a lot to catch up with. The plugin is still available here https://plugins.jetbrains.com/plugin/5047-go-language-golang-org-support-plugin and the sources are available here https://github.com/go-lang-plugin-org/go-lang-idea-plugin/ (were it always has been published).
Would say they're code style and autocomplete is top notch, but I wouldn't say that there debuggers are top-tier. I suppose they're the top tier cross platform or cross language debuggers though.
websockets
True. You need the ultimate. But the price makes up if you use more languages ( via the plugins )
ahh :D i think we are all one, me you my brother and this whole world, but this is a philosophy in that case you are wrong i would not mind to ask for myself:)
If you have an `.edu` email, you can likely get a license for free. 
Is Go a hard requirement? (I.e. does a hard fought business contract go into breach if you don't use it?) If yes: Add an interpreter for some scripting language to your Go binary. You can use a line like "We built this on the highly robust Go foundation and extended it's capabilities using a highly tuned Lua engine." That's your "arbitrary code" running in an environment where you can control access permissions from Go. Dynamic data structures aren't really a core strength in Go; not impossible, but against the idiomatic grain. Worst case, just transmit, store and manipulate your data structures in JSON, XML or some other serialized format. If no: Go may not be the best tool if you really need eval() to solve your problem. Yes or No: I will be another voice imploring you to take a few steps back. Take a few more steps back. Now tell us the actual business need you're trying to fulfill before you end up with a Rube Goldberg machine.
Is it really? Or is it more of an "asshole move" to be complaining about paying for an IDE that you find (found?) useful while developing... on a *Mac*. 
Something very similar is coming to VSCode soon, [https://code.visualstudio.com/blogs/2017/11/15/live\-share](https://code.visualstudio.com/blogs/2017/11/15/live-share)
Not an answer to OPs question yet but hopefully can be an option in future. I am working on https://github.com/centrifugal/centrifuge library which is an abstraction over several bidirectional streaming transports - GRPC, Websocket, SockJS. So theoretically one can combine transports in a way that is appropriate in certain situation – Websocket in browser, GRPC from mobile device for example. Also it's supposed to work with JSON and binary (Protobuf protocol) payloads, though SockJS obviously does not support binary. It's not ready for production at moment as the work simply not finished but most things already implemented and working. The difficult part is clever public API – still working on it, review and feedback are very valuable at this stage. It can be a bit distinctive in some aspects as its original purpose is to be a core of [Centrifugo](https://github.com/centrifugal/centrifugo) v2. The sad thing is that server requires client for each platform and transport. Personally I can implement browser and Go clients, but can't develop for mobile. I can only believe in open-source in this aspect.
[removed]
A few thoughts: 1. Why do you need `read(filePath string) (r io.ReadCloser, err error)`? What's the difference between this function and, say `os.Open`? 2. Why do you take `io.ReadCloser` instead of `io.Reader` in `parse` function? I don't think you really want to handle the closing in `parse` function (it's not its job). I'd prefer passing in `io.Reader`, and close the closer (if it's really a closer) in the caller. &gt; Is passing interfaces considered the general best solution in Go Yes.
Or just invest in learning Emacs. Tbh, it's got me covered in most of the stuff I do in a variety of languages. And before you, vim-guys ;) , start to complain - it's entirely possible to have Emacs setup in a similar fashion to vim, and you benefit from a large ecosystem of packages too.
Vscode or spacemacs (emacs with vim bindings)
[removed]
[removed]
Thanks a lot for your feedback! I was actually watching a talk with Steve Francia (spf13) to understand passing interfaces better :)
Hey, I just pushed some functionality that enables C-like decoding of `[]byte` buffer into structs, where struct fields can have bit widths smaller than 8 bytes. I use tags (and `fatih/structs`) to document how many bits each field should take, currently only 32 bit size is supported for structs. Anything to add? Write it in the comments ;)
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](http://docs.hylang.org/en/stable/) - Previous text "Hy" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Thanks a lot for your feedback, I like the idea of passing a Buffer instead very much and will do it that way. That is way cleaner! With regards to testing, how would I test that read function? I do not see another way than either actually creating a temporary file and deleting it afterwards or leaving the code untested :/
[removed]
This is a great resource from the Cloudflare Blog, should answer your questions: https://blog.cloudflare.com/exposing-go-on-the-internet/
For Pike's sake it's the third time you're doing this and you're still not giving a better explanation of what you want to do
I'm about to submit a proposal to Google via official channels for funding and I'd rather not talk about stuff too much. In this case 'arbitrary' means 'decided by an arbitrary program as given permission to run by the user' so I feel 'arbitrary' is pretty accurate. I'm considering the possibility of switching to the second language of choice and transferring requests with JSON then switching to JS as needed.... but then I need to know how to wrap it as much as possible in Golang so as to provide the greatest degree of concurrency possible.
IN 2 or so months when implementation starts, I'm going to have as good as I can people working with me to make sure data is never shared in an undesired way so the real danger is going to be from how far we get in the project (there will be one period where our later security via custom VM shenanigans and our earlier security via only having a few known programs running alongside)...... But to a certain extent safety is not a concern here. Or, rather, the safety is going to be as much as myself and a few google engineers can come up with, but in the end the danger is going to be the end-user primarily and not us which is..... something that can never be avoided, but will be done as well as I can, I guess.
https://goreportcard.com/report/github.com/Kilgaloon/Leprechaun and no tests.
Doesn't GoLand use Delve?
We do indeed use Delve, just like every other editor.
&gt; This has the added benefit that A LOT of people will benefit (from VS Code, to Vim, Sublime, what have you.) Paying for an IDE license will also allow A LOT of people to benefit from it since the developers, who are specializing in building those IDEs can keep working on them and delivering value to the users. This is exactly like paying to the tools developers that you mention.
Thanks a lot for your feedback as well! One reason I split the flow up was to help testability. Keeping the code in one single function surely makes it harder to test (classic example of having to create a file for testing vs. passing a type that implements io.Reader for example). I agree that this function would be underwhelmingly short but therefore not easily testable. Would functions like those (with trivial flows) generally go untested? 
Thank you, but if you really want to see then go down to the bottom of the thread where I've started a subconversation where I explain more than I feel safe doing so, but whatever. Random redditors on /r/golang are probably cool people I can mostly trust, yes? I hope so, because, well, my future is running on this problem and I can't afford to have it scooped from under me, but well, you can go to the bottom of the comments to the last reply and my reply to that to see more.
I'm gonna go 100% Richard Stallman on this one. I think these kind of tools should be free and open source so that you can use them in your favourite environment, don't get locked in, vet what's going on under the hood etc. Also think it's very much part of the go ethos to have this kind of tooling be totally free.
I'm using go-kit now, and it forces the separation from protocols reasonably well. So it should be rather easy to change http/json for grpc. Maybe.
1. Why can't your `LoadConfig` function call `os.Open` instead of `read`? I still can't see what benefits wrapping `os.Open` into `read` brings us. 2. No you don't want to read the whole file into `bytes.Buffer`, that's waste of memory. Your `LoadConfig` function could be something like (assuming `parse` takes `io.Reader` instead of `io.ReadCloser`): ``` func LoadConfig(path string) (Config, error) { f, err := os.Open(path) if err != nil { return nil, err } defer f.Close() return parse(f) } ```
Changing `LoadConfig(string) Config` to `LoadConfig(io.ReadCloser) Config` would solve your testing concern. Testing short routines that only compose standard library calls is up to you. Some folks are weird about 100% code coverage. I prefer not to retest the standard library and instead move on to something more productive. 
Yes, thank you very much for this tool ;)
Carpenters everywhere agree with Stallman as well, free hammers for everyone!
You are right, that is actually very much cleaner! Thanks for your help :)
It's funny when this argument gets brought up but nobody in other industries makes it. We get paid to write software, but we don't want to pay for our tools. And to add to the irony, we write our messages from Macs or iPhones... I'm not saying it's right or wrong, just a bit ironic.
&gt; I prefer not to retest the standard library That was exactly my thought as well. Thanks for reassuring me in this. &gt; Changing LoadConfig(string) Config to LoadConfig(io.ReadCloser) Config would solve your testing concern. I talked about this in another thread already (and it's also the reason for my 3rd question). If I did this, I would move responsibility to open the file to the caller, which I think is not the best way to do it as I wanted to separate concerns. Thinking about it now it is maybe actually not so bad. I will give this a try :) Thanks a lot for your help!
We aren't going to be perfectly safe. When allowing arbitrary code to run you simply can't guarantee safety..... think of the simple fact that viruses exist for OS's and this project is basically going to be implementing a lot of similar features but at a higher level while ignoring the low level concerns. Then I hope with our own VM we can fully isolate things so that the only way to cheat out of the sandbox is to go talk to the OS and ask for stuff which we cannot control. We aren't goign to be completely safe though and that was never the intent - the goal is to make it so that we have lots of go bits who are sandboxed and do not share any data they do not want to.... just like in Go itself where you choose what to expose to the public. 
I see a lot of folks in here supporting VSCode. I’m definitely in that camp when it comes to Golang (among other languages)
Killing me here.. locked in to what? I mean, locked in like OSX tools for Mac development? Or for iPhone? Or back in the day with .NET? I mean, come on.. you are paying a very reasonable cost.. probably a couple hours of work for the average developer, for a years worth of updates, support, etc. If you want open source go jump on Eclipse. I used to be eclipse and heavily fought against moving to IntelliJ primarily because years ago, it wasnt as stable/fast as Eclipse was.. but it has greatly surpassed Eclipse and is well worth a couple hours of work to enjoy writing code in. Free? Nobody forced you to use it, and frankly, I think most people looking to use Goland are those already using IDEA for java, C, python and others and want to stick to a familiar IDE. That said, I have tried a few others including VS Code, and nothing touches what Goland offers.. and I get updates/fixes for a year. I mean, if you had a good argument like Goland is $50 a month to use.. even then it would be worth it for those making a living writing code... I dont know.. I dont see your argument here. If you want free, use vim, or something else. If you want continued updated/supported features and a familiar very popular very powerful IDE, you pay a couple hours of work worth and get IDEA. 
I now have 18.1... that is updated with Goland I believe right?
There isn’t a better alternate than GoLand. I have tried all but goland is top notch. When they stopped giving out beta license I got free license for a year with my college email ID. If you have some money do get a license I would get one if I had to. It’s so much better than text editors.
Huh.. asshole move because he chose a superior IDE that costs a couple hours of work to own? An asshole move is to claim someone choose an IDE they are already familiar with is an asshole move. 
Apparently you dont have to work to survive. IntelliJ pays employees who work and get paychecks on features that they give away free. At some point, I think a highly supported/respected/stable product deserves a little payback in the form of people paying for it. Or.. do you work on all free software and never expect to get paid? They also still allow you to use the free version of the plugin.. it is just no longer supported by them for free. Expecting them to pay developers good money to support a plugin that is free is unreasonable. 
It's funny because both "asshole moves" you pointed were not done, either by him or by me.
Where does `lib/pq` come from? Clearly it's not stdlib. If it's from your own repo, you should import `"repo_name/lib/pq"`, not `"lib/pq"`.
Wow. Beautiful, for some reason I didn't come across this in looking for a solution. Thanks a lot!
"for space reasons" - is there a reason that you think that's going to be an important consideration?
Doesn't it do it by default if you let the mouse over the function name for a second?
 go get github.com/cjbassi/gotop # github.com/cjbassi/gotop/vendor/github.com/shirou/gopsutil/host ../../cjbassi/gotop/vendor/github.com/shirou/gopsutil/host/host_darwin_cgo.go:7:11: fatal error: 'include/smc.c' file not found #include "include/smc.c" ^~~~~~~~~~~~~~~ 
If you are a student or working on well known Open Source projects then they will give you a free license. Apart from that the personal license is reasonably priced I feel if you are using it all the time, if you are not using it personally then hit your work up for the cost ... Either that or use VS Code which is my next alternative after Goland and quite capable. 
The thing that infuriates me with Atom is that I've become used to the overwhelming functions of VSCode and now Atom is so bare bones that it becomes a pain to use. I got some hype for Atom IDE, but it's still far behind VSCode.
If you have 2018.1 IDEA Ultimate then yes, the Go plugin has feature parity with GoLand 2018.1.
try to rebuild gocode with 1.10
For sure, different people need/want different capabilities :)
You can explain a problem without having to actually explain the business details behind it. It requires a bit of effort but you should be the one that puts that effort in, as opposed to those that are trying to help you.
You are allowed to use the personal, not educational or oss, license for commercial projects as well as on your personal computer AND on your company computer (as long as your company allows you to do so), all within the terms and conditions.
A lot of these floats are getting communicated over a network at a time, so reducing the space that a single float takes up would help in that regard. 
You'll have 2 different things to handle: - match making (find a table/room to play) by asking a match making service - the game itself, in the room Ideally, you want many room servers (as many as needed) for a few match making service... and the two types of service need to communicate too (so that the match making service knows which tables are available, how many players are already inside, etc) Match making may not require a real time interface (HTTPS REST api) while the room API should probably use real time interface Design that architecture carefully... As for the tech stack, I'd recommend going with Websockets and JSON. Websockets are native to the web, well supported in JS and with Gorilla Websockets. JSON is easy to deal with. Make progress fast, make perfect later.
Wow, I most be getting old and unhip. I still use sublime text for almost everything's I find the auto complete from gosublime really good.
What OS and CPU architecture are you on?
&gt; Basically, we're looking at an... enhanced Desktop Environment.... with special channels to allow programs to directly but safely interact with each other via data exchange and potentially method calls while providing additional.... and some additional stuff. DBus? https://www.freedesktop.org/wiki/Software/dbus/
Also, when going from protobuf (the format underlying gRPC) to javascript, and assuming you are serving your JSON with gzip compression like a responsible adult, you only get a 10ms speedup with a 10kb size saving over JSON ([source](https://auth0.com/blog/beating-json-performance-with-protobuf/)). So it definitely feels like a premature optimization.
Nice. Loving this btw.. took me years to finally buy it, as the java version for free did a ton already.. thank you btw, for your teams work on this IDE. Well worth the price for Ultimate especially with the WebStorm and Goland being part of that package! I use all 3 now daily!
use benchmark framework? some generic tips. - change var list []int to var list = make([]int, 0, limit/2) to avoid unnecessary allocations. 
Use guru's whicherr command. https://docs.google.com/document/d/1_Y9xCEMj5S-7rv2ooHpZNH15JgRT5iM742gJkw5LtmQ/edit
Hey. lmk if I can help you in any way. 
I do have an IPC.... but if someone installs a new program I need a way to handle it. ideally I would load as little as possible so anytime a new program gets started up or loaded up from a frozen state. Basically, the problem is that the goal is to allow people to write fan-made wrappers for program communication and the like so a non-GO+JSON based IPC is..... unlikely to fulfill the requirements of my program.
I would love to see websockets/rest apis/json rpc handle this nicely.. and in slower not-quite-real-time games they may suffice. If you want almost instant communication between say two players (lets say Clash Royale style or other mobile person to person 2 player game that requires almost instant updates), I am not sure any of these will work well enough. If you want near real time, you might take a look at [this](https://api.unrealengine.com/udk/Three/NetworkingOverview.html#Unreal%20networking%20architecture) 
protip - if your entire lib is in float32: import math "github.com/chewxy/math32" 
Unfortunately it's all float64 right now, so I'll still need to find and replace right? 
THis is a relatively new problem and it's tied pretty tightly to my business logic. To be honest I've gotten a lot out of just the first 2 or 3 answers already so I'm pretty good on things for the moment and can always ask again later.
Just updated the repo with a fix, let me know if you're still getting the issue.
I'd say testing it is low priority, as you'd basically be testing Go's ability to read a file (which usually works). However, if you do want to test it, you can just make various pre-made test file(s) you run through it. Not too big a deal.
You shouldn't go from 1 to limit incrementing by one, it's much better to jump the exact number. To be more clear, you should generate the sequence instead of checking if every number is a member of it. Also, you don't need keep the list of all elements, just the last two.
I get your point, I'm just saying it was there for free earlier and since it was good I'm considering buying it too 
Go is the best language to learn on route to learning go. If you've written in anything else before, it shouldn't take you any more than a week to be competent. 
In queue.go, you acquire a Lock : "if LockProcess(r.Name, client) {" However, you RemoveLock inside of the internal for-loop, does not seem to be correct, as if the loop has a second iteration or more, you will RemoveLock again, and again, which is probably not the desired result you would maybe after? Another thought is the queue processing could be done in a go routine, and the loop in main.go would send work, or a signal to the go routine to process the queue ? and then could close the channel to signal the go working routine to exit, probably a bit more of the go way of programming.
I like using emacs to edit go code. I use a setup similar to [this](https://johnsogg.github.io/emacs-golang). The autocomplete plugin is surprisingly good.
IMO, you should not think of goroutimes as long running. You should have one scheduler that launches a goroutine each time you want to fire one of these tasks.
What you're probably looking for is a "message queue" of some sort; a proper message queue will be able to handle acknowledgement/receipt of messages, verify completion of work, and redistribution of messages if a recipient has failed in some way. I haven't worked with message queues at any length but I believe [zeromq](http://zeromq.org) is a generally useful application. So basically, your "producers" will pump messages into zeromq. Your worker goroutines will consume from zeromq. Producers and consumers will submit side-messages saying "I got this message", "I finished working on this message, here's the result", things like that. Hypothetically, you could implement all of this from scratch in your own application but it's not easy to be fault-tolerant across the huge range of possible failures: what if zeromq crashes? what if a zeromq node experiences a disk failure? what if a zeromq node experiences a short term network disconnect? what if zeromq experiences a long term network disconnect? what if a worker fails to acknowledge receipt of a message? what if a worker acknowledges receipt but fails to communicate any further? how long do you wait for it to 'come back'? If your application is strictly single-machine, you could probably just use an extra channel or two to communicate this extra stuff; "goroutineX received workPayload1", "goroutineY received workPayload2", "goroutineX completed work on workPayload1". if you feel up to the challenge, give it a try, it will probably be very illuminating on the full nature of the problem-space.
What do you mean by crash suddenly? Generally all of your failure conditions would be expressed as an error. Go errors do not cause go routines to "crash suddenly". If your go routines do there's probably nothing you're going to be able to do about it (panic due to allocation failure, for example). Or it's code you have written using panic that shouldn't be, in which case you can fix it. I think you should think a bit harder about what you are actually concerned might happen and try to express it more clearly.
Yep, same issue after commit: 009a0204890244b5800c47e824301dbde860f2d9 (HEAD -&gt; master, origin/master, origin/HEAD) Author: Caleb Bassi &lt;calebjbassi@gmail.com&gt; Date: Sun Apr 8 16:56:06 2018 -0700 FWIW there's no smc.c file or include directory under gotop here.
Also you should probably use a Ticker from the stdlib `time` package if you want light weight way to schedule recurring tasks.
https://play.golang.com/p/H_YEHfvA4Co Something like this. Then you don't have to worry about "thread" management. Each time you start thinking of goroutines as weighty and needing their lifetime managed, consider if you might be going against idiomatic go.
You're trying to sell this poor dude a race car just to drive to the grocery store.
You should evaluate the length of list first.
Ooooor I'm presenting multiple options for a very underspecified question. "I have an application that will do work" doesn't include any details about where the work is coming from, what the nature of the work is, or how reliable the system needs to be. Note that at the end of my comment, I did propose a rough sketch of a hand-rolled solution involving local channels instead of an external message delivery service.
Absolutely
Yep! I am just looking to handle a few specific errors on the server side. Thanks a lot for the reply! 
This problem is an excellent opportunity to take advantage of two niceties in Go's syntax: flexible loops and succinct variable swaps. You can actually do most of the work in a single line, like so: for m, n := 0, 1; n &lt;= limit; m, n = n, m+n { // Filtering logic goes here }
Not in terms of style, constructs or most of the actual language but function names align pretty closely to python 
I would argue that Go is a very popular language. Many highly visible tools like Docker and Kubernetes are written in Go. If you are interested in learning systems programming Go is a great language to learn.
that was the initial announcement, I did get an invite to it a few weeks ago so it is definitely coming along. Seems to work fairly well but to be fair I never tried Teletype so can't compare
C and Javascript. https://golang.org/misc/cgo/
This solves a problem I was previously using shell scripts to solve. I will definitely give this a spin.
Why is spacemacs better than vim?
Hmm, not sure what it could be then. Could you try downloading the binary to see if it works precompiled? Cause you're having an issue trying to build it right?
[removed]
goLand keeps it in view permanently and not just on mouse over. Something like this: s2 := strings.Replace(old: s, new: pat, n: times) Though slightly lengthier, it really improved readability of the code and I found it to be productive. vscode should definitely pick this up. 
You'll always get work with javascript, for better or worse.
[removed]
It has a lot of excitement. Or did... and I think most of that has worn off as is kept up only a slow pace and then was overshadowed by VS Code.
I would say python. There are some differences obviously but they are both good tools to have under your belt.
Yeah, I used their student license and now I get my employer to buy a license for me... that bit of marketing worked out for them.
Alright I think I got it working now, realized it was an issue with dep pruning the include directory but it's there now. Let me know if it works this time.
nodejs and python are the most common web development language alternatives. learn a framework like expressjs or django. ruby and ruby on rails are your alternative to python and django. personally i think node is easier because if you build your own frontend it is still just javascript. your tools are more or less the same.
yeah if you want to eat that is a good combo. 
Have you seen https://floobits.com which is available today and works with a lot of editors out of the box? 
Option C: Just go get github.com/foo/yourproject/services/serviceC This makes for lengthy import paths but maybe you can live with it. If not, set up a vanity alias at your domain.
lots of reasons. - automatic relevant plugin install - asynchronous - magit - org mode - mneumonic keybindings - same config works across every OS the last point may not seem relevant, but my vimrc never worked right across windows/osx/linux, where spacemacs (and emacs, more generally) has no problems.
Take a look at Tideland GoTogether (https://github.com/tideland/gotogether/). It contains a package named sentinel for monitoring goroutines and reacting on errors. 
You get locked into goland if you want their tools, and just because the Situation for osx devs is worse doesnt mean we have to move into the same direction. I dont see how you dont see the point of wanting free software. Wouldnt it be nice to have a &gt; very popular very powerful IDE That is open source. There are licences that allow open source projects to make money if the user uses them commercially. The point isnt really that it costs money but that its not free as in freedom not free as in beer.
Is Eclipse considered open source?
Digital ocena has a good writeup of this: https://blog.digitalocean.com/cthulhu-organizing-go-code-in-a-scalable-repo/
One of the cheapest thing that I have done is asking a fresh college graduate for his college email id so that I can use GoLand free for 1 year using the student's discount.
You don't need to symlink, there's a few options: - [goenv](https://github.com/crsmithdev/goenv) - docker, (`docker run -it --rm -v $PWD:/go/src/... golang:alpine go build/run/etc.`) - have the build toolchain in a docker image (using a CI that you can run locally, like [codeship](https://codeship.com) "jet" tool) Generally, at least docker/CI approach doesn't require you to set up a GOPATH structure, and it's possible to set up vanity aliases so you can have whatever import path you like to your app. Not sure your comment about `src/` is relevant. You would only have your project under src, and for whatever dependencies you pull in, you should be using vendoring by now (dep, recently vgo). Generally it's advised to commit the vendor/ folder, but because of licensing restrictions and such, you might have to pull them on demand (vgo supposedly handles something about licenses something something, didn't read it very carefully, but if you care about which packages you include because of their licenses, you should be using vgo aparently, it's the current thing).
But we cannot help without more information. There are basically two ways to interpret what you are asking for: 1. You have some central service that needs to be extendable with libraries/plugins. For this case, a library/plugin is *loaded at startup*, and is only provided by the system administrator. Such setup is static in nature, commonly used, and completely fine. 2. You have some central service that needs to be able to run user-provided code. This is an extremely dangerous game. It doesn't matter what language it is, it's a giant attack vector. If #2 is *absolutely what you need* (which we cannot know at all without more information—for all we know, you could be trying to inflate a tire with a nuclear bomb blast), then you have to note the following: * Consider whether the functionality could be implemented by a well-defined API and code running on the *client* system, making simple requests to a backend. This is by far the safest solution, and assuming that the extended functionality is not super high performance (you mention *javascript*, so it can't be), this will probably also be the *best* solution. * If more elaborate functionality is needed, consider if it is "small" enough that you could simply make a small query language that can do what you need, but *nothing* more. This is a bigger task, but if you do it right, you can limit the damage by limiting memory and cpu resources, either by having hard limits, or by not having any functionality that can abuse it. * If you need a "real" language, remember that *any* user that can execute arbitrary code *own the machine*. Even with sandboxed JavaScript, they can take out your service by eating CPU and memory until the machine is unresponsive, and the OOM killer slaughters things at random (potentially your service). Skilled attackers can also break out of the sandbox and take over the machine that way. * Running user-provided Go or C would be grotesque—this would be equivalent of giving every user SSH access to the server. If you can pass the task over to a javascript instance, which seems to be your current consideration, then it seems like the task is "simple enough" that it could be just a REST API, with the code running on the end-users' machine (potentially in their browser). If you feel safe doing so, you could PM some additional details. It might clear things up a bit.
It is important that you understand that "not complete safe" means "not safe at all". If every individual user has their own dedicated VM, then I guess things are okay, but that suddenly makes your company a VPS rental service rather than a SaaS. If more than one user use a VM, then the isolation is insufficient. A malicious user would be able to attack the other users on the system (stealing private information and credentials, monitoring activity, messing with their data), and would also be able to take out the infrastructure by using multiple users to take out multiple VMs.
A quick look at github shows quite a lot of projects hostet in the eclipse foundations account. One of which is the ide. 
Then you really need to embee a scripting engine in your Go program like others have suggested but even then you'd have to provide some sort or API to the scripting part and once you do that, you already define things clients can do so it won't be like the client can do absolutely anything it wants.
You do know that there are flags you can use to output the line no. of the source code. And also you can include a prefix string. https://golang.org/pkg/log/#New.
The IntelliJ Platform is also open source, see https://github.com/JetBrains/intellij-community/ and there are a lot of plugins/projects under https://github.com/JetBrains/ as well.
Imo 1 is not a big deal, you hit save and the package usually gets autoimported in VSCode - then autocomplete functions as normal. I'd like to add themes for VSCode are nicer - allowing increased visibility - I like to use this theme ([modified version of ColdSnack!] (https://gist.github.com/arehmandev/90e8a43112b612f82d804b3ec06ee323)
[removed]
Yep but the go specific stuff is not which was the original thing. I dont really know where he is going with his eclipse example 
Not sure I understand. Do you suggest sending it over the wire as a string? Sounds potentially wasteful. Bonus point: on many processors and for many instructions lower precision translates into better performance: http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/
well done, nice UI, pretty blinkinlights. 
Yes I was thinking of sending it as a string. Why do you think it's wasteful? Thanks for the link.
A `float32` is 4 bytes — and anything beyond 4 characters in the string representation will be larger than that.
You're in production, and it's too early for production, but [vgo](https://research.swtch.com/vgo) solves this. It lets you put your code anywhere. It's from Russ Cox so has a high chance of acceptance, and I've been using it successfully in lightly shared projects at work; it's still a proposal under development, though, do caveat lector.
magit is so amazing, at least check some youtube/blog posts about it, it blows everything else away
&gt; Qwentic developed our Chatbot solution in record time with zero issues in product developemnt. And now it's time for some spell checking.
Interest as well
I used codeanywhere. It just has basic linting and intellisense. 1. it's online and not platform specific. 2. nice mobile ui that isn't perfect but best out there. 3. when you spin up a container it creates a droplet in digital ocean so what you code is actually hosted. 4. Works perfectly on a Chromebook even though yes crostini is coming out soon https://www.google.com/amp/s/chromeunboxed.com/news/chromebook-containers-virtual-machine-crostini-google-io/amp/ 5. I can get help or share from friends with actual code instead of GitHub stuff no one wants to read. 6. If I'm teaching someone, I have an actual working example to show. 7. No more million project files hidden somewhere in a cloud or on some pc. It's real and live and I'm tired of having all these different focuses with all these libraries and frameworks. 8. For practice I have a live container running. So to push myself to not only practice cause I'm paying for hosting but to focus now on one big project. It wouldn't be work place practical but for having a goal it sure helps.
Create an error channel in your main thread. Pass this into all of your goroutines. You now can monitor this channel for information and call the appropriate code depending on the error type.
Use this - &amp;http.Server{ Addr: addr, Handler: handler, TLSConfig: &amp;tls.Config{ PreferServerCipherSuites: true, CurvePreferences: []tls.CurveID{ tls.CurveP256, tls.X25519, }, MinVersion: tls.VersionTLS12, }, ReadTimeout: httpReadTimeoutSecs * time.Second, WriteTimeout: httpWriteTimeoutSecs * time.Second, IdleTimeout: httpIdleTimeoutSecs * time.Second, }
Thanks for showing an interest in the review, Can you please share your short bio and your working experience with golang at my email aggarwalarpit.89@gmail.com
Thanks for showing an interest in the review, Can you please share your short bio and your working experience with golang at my email aggarwalarpit.89@gmail.com
Thanks for showing an interest in the review, Can you please share your short bio and your working experience with golang at my email aggarwalarpit.89@gmail.com
Right.. so people develop plugins for BOTH IDEs (and some others) that they give away freely. You can use the FREE IDEA IDE AND get these free plugins.. thus remaining completely free. So I am not understanding anyone complaining about them having an ultimate version which itself is closed source and makes them money, but the plugin system is open and anyone can add free/open source plugins to either the free or paid version. Look, IDEs been around a long long time. IntelliJ just puts together a lot of powerful functionality that most of the other IDEs have in some way and some varying degree anyway. I dont see why the core IDE and a few of their plugins MUST be open source (especially if they are free) to be good or used? The only people that should want the source of the IDE are those that plan to work on the IDE itself and commit to it. IntelliJ simply said.. nah.. we got a team of very specific developers to do that.. but you all can add plugins if you like. The benefits of open and close source are well understood. You do gain some community fixes/additions to an open source IDE... but plugins provide most of the feature set anyway, which you can add to IntelliJ. The down side to open source is you often get non-specialized developers trying to get some ad-hoc feature added and of course it is reviewed before accepted... but by who? A select few who "control" the landscape of the open source IDE. So how is that any different than what IntelliJ does.. only their contributors AND reviewers are paid developers that work for the company. It is almost the same thing, except they focus on the IDE day and night as their job, where as the community contributor is using the IDE for other purposes..and feels it is lacking something so wants it added and in many cases feels it would be a good addition for others to enjoy. Sometimes, they just want it for their own use and could care less if others use it. 
Lua, then combine it with Go. Many large games combine Lua and C++. Lua+Go makes it easy to reload Lua code and instantly see the result. Not because of the compile time of Go, but because of the environment launch and setup time, for larger projects. Lua also compliments Go nicely since it is more dynamic and leas strict.
&gt; StructOf currently does not generate wrapper methods for embedded fields. This limitation may be lifted in a future version. Remember this.
Wow thank your for the advice, didn't know Lua before. i'll check it out 
Yes, [RTFM](https://golang.org/pkg/fmt/) about the `%v` and `%#v` formats. For more hardcode stuff, look at [`go-spew`](https://godoc.org/github.com/davecgh/go-spew/spew).
Since `go 1.10` you can set https://golang.org/pkg/encoding/json/#Decoder.DisallowUnknownFields to fail hard on unknown fields. With that said, admittedly, it would be very nice if there was an option to decode the residual fields into a `map[string]interface{}`.
I don't think you should feel like your wire representation has to match the precision you use internally. At the very least, 64bit floats might save you from a few problems if you aren't careful about the precision of your intermediate steps (but not always). With respect to your later point about arithmetic speed, I'd be cautious - for one, AVX2 should be getting more and more common, secondly, I don't think Go currently does much in the way of float math optimization. So... your best bet is to benchmark, but first to ask yourself what sort of performance differential is worth what to you. Is it one vm extra per 100? is it ten minutes faster?
I went ahead and built a [AES-CTR + SHA2 (512bit) HMAC encryption and decryption library for go](https://github.com/Xeoncross/go-aesctr-with-hmac) to test my questions out. It works fine, but seems it might be slower than this optimized [AES-GCM implementation by gocryptfs](https://github.com/rfjakob/gocryptfs/issues/222#issuecomment-379539825) on certain CPUs.
Short answer, No, This isn't an issue.
This seems like a good approach. Is it a common pattern in Golang?
func Try(f func() error) (errRun error) So this function Try takes a function assigning it to f, what is the error right after it? Is this what f is expected to return?
I made this package for dealing with arbitrary JSON. https://github.com/toolateforteddy/arbitrary I think you would probably want to use Hydrate to make it into the class you want, and then on error, use Dig to pull out the error object. 
You can make it much faster by knowing that: - "the sum of the first Fibonacci numbers with odd index up to F(2n−1) is the (2n)th Fibonacci number, and the sum of the first Fibonacci numbers with even index up to F(2n) is the (2n + 1)th Fibonacci number minus 1." [https://en.wikipedia.org/wiki/Fibonacci_number#Combinatorial_identities] - F(n) = round((g^n)/sqrt(5)), where g=(1+sqrt(5))/2 [https://en.wikipedia.org/wiki/Fibonacci_number#Computation_by_rounding] Assuming n is small enough to not cause FP numerical issues, your algorithm becomes O(1) in both space and time. 
I would not recommend zeromq unless you have a good reason. There are plenty of native messaging libs such as gRPC or NATs. Introducing CGO into any project should take careful consideration as the drawbacks are pretty big.
I think based on the response code 200 or 404 you can manage different json decoder strategy
Pretty good article. &gt; there are a lot of different ways to manage dependencies, and it generates a lot of confusion, but I hope at the end we will converge in just one. Agreed. &gt; Probably dep I hope not. There is a new alternative with a better idea that has a way better workflow: https://research.swtch.com/vgo (I also predict that other languages will eventually copy this idea.)
Always a fan of the simplicity of this project. As a fun aside, I wrote [an AOT compiler](https://github.com/cretz/goahead/) from JVM bytecode to Go code but I abandoned it because the Go compiler just [can't handle it](https://github.com/golang/go/issues/18602).
JumpCloud | Engineering | Boulder, Colorado, USA | Full-time | On-Site | www.jumpcloud.com JumpCloud offers a Directory-as-a-Service product in the cloud. Work with technology like Go, Vagrant, Docker, Saltstack, ELK Stack, Redis… -Sr. Software Engineer: (Gophers wanted, or experience with C++, Java, Python or Node is ok too) -Software Engineer in Test (SDET)-(5 yrs Go or Python ideal or exp with multi-lang (C++, Ruby, Perl); SQL; Open to former DevOps/sysadmins with coding exp who want to do more development -Software Engineer (OS Applications): Develop agent technology; Native desktop devs; system-level api work More details here: https://jumpcloud.com/careers#careers
Hi How can I subscribe to get the article when it's out? thanks
Does it have generics?
I have not used debugger with Go. Not even once. Error handling usually tells me all I need to know and racing/timing issues are practically impossible to fix with debugger. So its usefulness is very limited. 
Relevant: https://gafferongames.com/post/why_cant_i_send_udp_packets_from_a_browser/
I've seen that issue. It's related, but it's not the same. I was actually thinking about adding this to that issue if I'm not misreading my code somehow. The weirdness here is that a pointer seems to somehow become initialized by the call to New or (more likely) by a call to my method. I really can't explain it by anything I understand of how things should work, hence the question if I'm on drugs and missed something obvious.
Reminds me of the "Does it have XML?" question frequently asked by clueless hightech investors shortly before the dot com bubble burst.
Thanks a lot for this effort ! A friend of mine is looking to contribute to the ssa backend. But docs are seriously lacking in that department. The information is spread across multiple docs and code comments. Recently, /u/mvdan has been chalking up a few READMEs on that front. But it would be awesome if the compiler can get an exhaustive treatment like these.
AFAIK the JVM actually does not support generics natively like the CLR.
Please be careful with this. If `a()` takes about 1 sec to complete, you'll run the risk of spawning infinite go routines (well, not inifinite, you'll just consume all available resources and might bring your server to a halt :-)). I suggest something like this: func execEvery(interval time.Duration, fun func()) { tick := time.NewTicker(interval) for range tick.C { fun() } } func main() { fmt.Println("Hello, playground") // Just so that you can see the program finish. ender := time.NewTimer(10 * time.Second) go execEvery(time.Second, a) go execEvery(time.Hour, b) go execEvery(24*time.Hour, c) &lt;-ender.C os.Exit(0) } This solves the problem of infinite goroutines. However, if `a()` still takes a second to complete, the `runner(..., a)` call if equivalent to a `for { a() }`. If that's a problem for you, swap `time.NewTicker` for `time.NewTimer` and call `tick.Reset(interval)` at the end of the loop.
Of course, that's why they're there.
This article is mostly good, but it attempts to argue that finalizers are in the spirit of Go because Go takes the philosophical view that resource management is hard, hence the GC. The premise is rock solid (managing resources is hard), but the conclusion is wrong (if I understood it correctly). Finalizers are run when the GC decides the program needs more free memory--it makes no sense to make decisions about freeing file handles or network connections on the basis of memory consumption. Based on the aforementioned philosophical premise, Go should have a GC for every kind of resource--not just memory. Finalizers are absolutely not the right answer.
Hi devs, I was writing tests like a good developer and couldn't find a mock gen for Testify that was good and fast so I created this CLI tool that uses [`go/loader`](https://godoc.org/golang.org/x/tools/go/loader) to inspect the program for interfaces to mock. Any feedback appreciated.
I know I can't stop people from writing comments, but pleease don't reply to my comments with this Iris crap again grr. Every time this happens I feel it's my duty to inform people why you shouldn't use Iris and I'm not really in the mood for that today. Just lookup the history of "Kataras", well known for stealing code and not giving credit where it's due. Squashing commit history to hide other peoples work, constantly rewriting git history so it looks like it's his own work, and it uses FastHTTP which doesn't make it follow the stdlib sorry no matter how "fast" that library is, it's not stdlib. I'm sure other router libraries are capable of this, just not any I can think of the top of my head right now.
Oh definitely, I do give credit.
There is type erasure, but the generics do affect type casts and there is some runtime generic support via reflection. It's a reasonable model if you don't want the overhead of reification though it annoys those from .Net land and other users from the outside looking in that just want to do something like reflectively construct an instance of a generic type.
$120 a year may be small compared to what I could make using it, but it's large compared to how much VS Code and Vim and Eclipse and XCode cost. I know that price framing makes economists unhappy, but that's the reality of the situation. IDEA is probably nicer than the free options, I'm not convinced it's _that_ much nicer.
Too useful. I've been working on depending on as many stdlib interfaces as I can in my code and it's done wonders. Been working on a Go client for the Coinpayments API to take cryptocurrency payments with no external dependencies, and depending on something like an `io.Reader` just makes it so easy to work with, and for other devs to collaborate on. It's a different way of thinking from my primarily PHP/JS experience and took some getting used to but now I love it. Something like: func (cps *Client) HandleIPNDeposit(reader io.Reader) (*IPNDepositResponse, error) { body, err := ioutil.ReadAll(reader) if err != nil { panic(err) } var resp IPNDepositResponse if err := json.Unmarshal(body, &amp;resp); err != nil { return nil, err } return &amp;resp, nil } 
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/wRQ6uz8.jpg** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
I believe you are right and you found a bug in reflect. I took the liberty of [reporting it](https://github.com/golang/go/issues/24782) with a minimum working example and some additional info. It would be great if you could butt in there :) I also reported [this issue](https://github.com/golang/go/issues/24781), which I found while trying to figure out what was going wrong ^^ It seems, reflect with embedded fields is pretty broken, sadly :(
I have used SonarQube for GoLang and you really need more than just GoMetaLinter. I wasn't able to find a complete set of Docs that really helped you through the process of getting GoLang scanning in SonarQube. So. I decided to write it myself. You can find all of the information in my Repo: https://github.com/Talderon/k8s-sonarqube Please feel free to comment/open issues as this is an on-going active project of mine so I should get back to you pretty quickly on issues and questions. Thanks!
found the solution. I was looking at examples pre-Go1.6. The current version has block tag which makes things easier
We use finalizers the exact same way in the Imagick project (ImageMagick bindings). Users can call Destroy() to free the underlying C memory, but a finalizer is also created to clean up at some point as a backup. 
It doesn't seem to work well from the mobile chrome browser on my phone. The original present tool can scroll every slide, but this one cuts off the first slide and only manages to scroll to most of slide 3
I'm Icelandic. Seeing an "X-conf Iceland" that includes no icelandic speakers or organizers is a bit weird. Oh well, it won't be a popular tourist dump forever. This, too, shall pass.
Hi Icelandic, I'm dad!
The only semi-rational explanation I have is that the pointer doesn't get magically allocated. Instead whatever mechanism implements the methods actually treats the struct field as a proper embedded field and not a pointer and what gets allocated is the actual string. Of course, internally in reflect things are still confused and that's why printf and such lie. This hypothesis might sound far-fetched, but memory doesn't just allocate itself spontaneously.
clearly a rhetorical question
It should be "GopherCon Europe" which at the moment happens to be in Iceland.
Sorry I am kind of slow, what are we looking at here?
It's implemented with type erasure and automatic casts. I don't know how clr implements it
Time is money.. if IntelliJ saves me 2 hours of work over other IDEs in the year.. its paid for itself. Truth be told.. it has saved me a lot more than that. I have used VSCode and Eclipse, as well as Atom. But... to each their own. If you are more productive with others, glad to hear it. For me, IDEA has surpassed all others in many ways to make me more productive. Well worth a few hours work in pay to have a tool that is a joy to use and makes me more productive. 
GO is highlighted on the whiteboard
The show isn't super accurate about a lot of things, which I think makes it funny. Unless, we all agree that the ideal maneuver for when you are about to poop your pants in front of people is to crouch down. 
If you deal with basic middleware you need to 'convert' it into a echo.MiddlewareFunc function. e.Use(echo.WrapMiddleware(servertiming.Middleware))
&gt; You have some central service that needs to be able to run user-provided code. This is an extremely dangerous game. It doesn't matter what language it is, it's a giant attack vector. This. Think.... Desktop Environment I guess you could say? Basically, the point is that the user is in control and there's not a lot I can do about this fact given the intended borderline revolutionary final intended form of the product. Now, I want to sanitize as much as possible and avoid issues and I'm considering backing off to a certain extent and simply letting users send messages, but I'm worried about running into a pretty logical use case wehre such a thing is not enough (arguably I already have although I think I can create a standardized way to avoid the issue basically by simply letting programs 'register to sign up for a listener' more or less). 
This is a good point. I'm sure someone on the team being assembled would eventually point this out to me if they didn't just engineer around the problem from the start. In my case though the servers would only save part of the data and general structure and while we would offer the equivalent of a VPS rental service (I'm sure Google is capable of doing so so nbd for my project) the general solution would be to have the 'client' program be backed by a 'server' program but the actual interfacing is done through a program that connects to the 'client' (the 'server' allows for easy restarting from a new client e.g. simply turning off a laptop then reloading similar stuff on their desktop even if the user is actually viewing things using a tablet).
Yeah, that's the plan tentatively now. It will either be a variation of GO or Javascript, but we're hoping that the project takes off in which case a lot of people on /r/golang will be hearing about this project and benefitting from the developments we make for it (including a GO-based version of the CLR/JVM), but, well, I'll just have to figure the scripting limitations out with my team. 
clearly not a question
More like Rust in the wild ^^^^^someday ^^^^^there ^^^^^will ^^^^^be ^^^^^Rust ^^^^^jobs ^^^^^in ^^^^^my ^^^^^area ^^^^^:(
That hand writing is way too legible to be realistic.
Bloomberg LP | New York, NY (On Site) | Full-time | Senior Software Engineers | [Careers](https://www.bloomberg.com/careers/) Bloomberg's developer experience team empowers 5000 engineers globally to reach their maximum productivity. The work we do helps engineers deliver software that underpins the entire financial industry. Bloomberg leverages more tools and open source technologies every year, and our team is expanding to ensure engineers here are well-equipped to take advantage of those tools. We are hiring for our Developer Experience/Deployment Workflow Team. We develop and maintain the deployment system used across Bloomberg and are leading the charge transitioning from a manual deployment model to continuous integration/continuous deployment. The specific job listing can be found [here](https://careers.bloomberg.com/job/detail/65482). Send your resume to jcarberry7@bloomberg.net and mention reddit. As a team we are pioneering Go at Bloomberg and do the majority of our new development in Go. Our stack is: Go, C++, Docker, Kafka, Redis, and Kubernetes (soon). If you have any questions about the position feel free to reach out to eyoung81@bloomberg.net or mculhane2@bloomberg.net (engineers on the team) We're always looking for passionate and energetic problem solvers to join us. While I mostly cover devx and data science, we have full-time software engineering openings across a variety of teams, feel free to send me your resume to jcarberry7@bloomberg.net and I can help you find the right match. :) -jen
Even though I pay for Deezer now instead of Spotify for lossless...So I'm paying more than what most people think I should have to pay for music streaming...I still can't get on board with $90/year (or even $50+ after a few years) for a code editor. Yes, I'll pay $240/yr on music, but feel less than half that rate is unreasonable for a tool to code. A tool which could potentially make you money no less. We all put our own values on things I suppose...But if there was a free lossless streaming alternative, I'd ditch Deezer too. The fact is GoLand's pricing is ballsy given the market rate and available alternatives. I don't think it's reasonable at all. Look at apps like Affinity Photo, Designer, and Sketch for design...Those are one time fees too. Major version upgrades cost more. That's the pricing model I'd expect from a code editor or any productivity tool. Ulysses screwed up too by going "subscription" for a markdown text editor. Wrong model. I won't touch these things on general principle.
Agreed. Go, when self-contained, is the most cross-platform friendly language in existence. It is the perfect tool for system admins.
A very interesting library, thanks! I think I will try this. 
Thanks, this helper library for Gorilla websockets looks like it can make life easier and is very useful. If I use Gorilla websockets then I'll try this.
I graduated 2 years ago and still on the student license, because my university gives indefinite access to your edu email.
ayyyy, we made it bois!
Thanks for the library, exactly what I needed. Also, when streaming decryption to a client over http, you can `panic(http.ErrAbortHandler)` at the end of the handler to close the connection if the HMAC doesn't match.
Yea, I hear that. I do realize we live in an ever evolving world with many companies trying out new billing models (games and microtransactions, Adobe with its subscription model, etc.). Though I don't think they all will do it and I also think it'll be a passing fad. I think it's catching an untrained audience off guard. Like an impulse buy. Gimmick of a strategy really. Sooner or later people will catch on and realize they have 50 different tiny tools they're paying small amounts of money for that really add up. They'll start picking things to get rid of. Anything with a cheaper or free alternative that even provides 80% of the functionality will the first to go. I think JetBrain falls squarely in that category. VS Code, Atom, even Sublime. Heck, vim and emacs are making big comebacks. We'll see though. Maybe subscriptions will be the dominate model in the future. I don't think it was a poor billing model to sell major version and then upgrades. It's worked for years and years and years. Microsoft's done fine by that model. It's only the cloud stuff now that's dictating the change in model...Because there's perpetual resource overhead for them. Look at cool products like TeamSQL (seriously cool SQL editor). That has to be a subscription model because they are hosting servers that hold data and let you share. Granted they could've built the software differently and I do also think they are using the subscription model as a growth hack gimmick...I do think it'll bite them in the rear end one day...But I also think it makes sense and I think it's a great product. Plus the alternatives? Yea, not many or super expensive. Slack? Yup. Makes sense. Trello? Yup. Desktop only software? Ehhh... Maybe. Though a fair question; is the desktop dying?
As u/kostix said, the "fmt" package and %v. I usually use the %+v variant. For visualizing more complex structures I prefer [kr/pretty](https://github.com/kr/pretty) over go-spew. I think the output is easier to read, though go-spew's output is more "complete". Or if appropriate encode to JSON and use that. For large data structures it can make debugging easier because you can inspect the output with for example [jq](https://stedolan.github.io/jq/).
Yeah but the algorithm for the most efficient manner of jerking off a room full of dudes was spot on. 
Thanks for showing an interest in the review, Can you please share your short bio and your working experience with golang at my email aggarwalarpit.89@gmail.com
As a local maybe you can help us reach more local companies and meetups? We'd love to have the local companies engaged in the community and having a good chat with gophers from around the world, and we'd also love to have a collaboration with the local meetup groups, and so far our efforts to make this happen could use help! The best way to get in touch is pinging @dlsniper and/or @natalie on the Gophers slack. Thanks!
Uh! My bad,I only tested this on firefox and chrome on my pc. I will do some digging and see if I missed some mobile related stuff.
This seems misleading regarding when referring to the type *T*. I think statements like this are only true if *T* is allowed to be a pointer: &gt; If type T is a non-interface type, then the a copy of the T value is boxed (or encapsulated) into the result (or destination) I value. The time complexity of the copy is O(n), where n is the size of copied T value. And whether or not *T* is a pointer depends on if the interface has been implemented with pointer or value receivers. But I'm guessing.
I could not agree more. Also seeing the same speakers on each conferences is a little bit tedious. I agree that some of them are Golang advocates, but i consider that inviting other speakers who have an expertise in other fields then infrastructure would benefits a lot of more Go programmers, then to focusing almost entirely to devops, because in the vast majority of cases the topics are centered around infrastructure. There is a single exception in this lineup.
Hi! This code works so because any embedded function gonna be invoke first, and value, which embedded function returns gonna be passed to wrapper.
&gt; implying sysadmins can code their way out of a wet paper bag I'm not bitter
Quote from Go spec: &gt; A value x is assignable to a variable of type T (“x is assignable to T”) in any of these cases: &gt; […] &gt; x’s type V and T have identical underlying types and at least one of V or T is not a named type. Basically, `handleTest` can be assignable to a `JsonHandler` type because they have the same underlying type (`func(*http.Request, Thing) (string, int)`). So it's implicitly typed as such when passed into `RequiresPOSTAuthentication`. Then the returned function is also of the same type. So now that your returned function type is considered `JsonHandler`, the compiler sees the `ServeHTTP` function, which means it implicitly implements the `http.Handler` interface. This means you can pass it to `http.Handle` which will call the `ServeHTTP` function with the returned function. Keep in mind that there is nothing to be constructed for `JsonHandler` – you've just created a type which is used for interface matching and function lookup by receiver. You could use your `handleTest` in other contexts and it would not be considered to implement `http.Handler`.
Thank you very much, really helpful explanation :) 
No problem, let me know if it doesn't make sense. I also edited my post to show an example of `time.Duration`. It will work the same way as your case, where you can turn `int64` into `time.Duration` "magically" but really it's because they're the same underlying type.
I believe they're describing the fundamentals of a decorator, which I think you already know. All the *types* of everything are statically available (that is, the compiler figures it out before the program runs) which is unlike Python, but any return values etc. are only generated and returned upon function calls, as you would expect even in Python.
&gt; however this is not happening. It would be very helpful, if you posted an actually running example and explain how you determine that what you expect isn't happening :) Especially, given that the code you are posting is missing loads of very important code (e.g. how `RequiresPOSTAuthentication` calls `fn`). Now, assuming this: package main import ( "net/http" "log" ) func main() { http.Handle("/", RequiresPOSTAuthentication(handleTest)) http.ListenAndServe(":1234", nil) } type Thing struct{ } type JsonHandler func(r *http.Request, thing Thing) (string, int) func (fn JsonHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { log.Printf("JsonHandler.ServeHTTP") fn(r, Thing{}) } func RequiresPOSTAuthentication(fn JsonHandler) JsonHandler { log.Printf("RequiresPOSTAuthentication") return func (r *http.Request, thing Thing) (string, int){ log.Printf("RequiresPOSTAuthentication return closure") return fn(r, thing) } } func handleTest(r *http.Request, thing Thing) (string, int) { log.Printf("handleTest") return "", 0 } The output I'm getting is &gt; 2018/04/10 10:37:18 RequiresPOSTAuthentication &gt; 2018/04/10 10:37:20 JsonHandler.ServeHTTP &gt; 2018/04/10 10:37:20 RequiresPOSTAuthentication return closure &gt; 2018/04/10 10:37:20 handleTest Which makes sense: 1. `RequiresPOSTAuthentication` is called, when setting up and passed `handleTest`. It returns a closure, let's call it `x`. 2. When a request arrives, `x.ServeHTTP` gets called by the HTTP Server, which is the method declared on `JsonHandler`. 3. `JsonHandler.ServeHTTP` then calls the receiver, which is `x`, the closure returned by `RequiresPOSTAuthentication` earlier. 4. Finally, that function in turn calls the function we passed to `RequiresPOSTAuthentication` (that it closed over), which was `handleTest`. Does that clear things up a bit? :)
I think they just didn't expect the `handleTest` to "magically" turn into `JsonHandler`, but it does so from virtue of them being the same underlying type (there's no instantiation involved because it's not a struct). I would mention that happening in your steps to clarify at what point a simple function attained the "method" (function with receiver) necessary to implement the `http.Handler` interface.
Yep, thanks! I think the main issue was I was using decorators in Python in the right way but I probably never really stopped to think about how they were working. That's why my inner self knew the code I wrote was going to work but when I stopped thinking about it, I couldn't get it. Also, I guess the Goland debugger bugged me even further, because it wasn't stopping on RequiresPOSTAuthentication, so it looked like it was not called at all
Yeah it's both this and what I said in my reply to this answer
Yeah, I knew the fundamentals of decorators and I was writing and using them correctly in Python, but the thing is I never stopped thinking about how they were really working. It's pretty weird, I'd say I had a "practical" knowledge of it, but wasn't grasping the "closure" thing until now Go made me think about it
Thank you really! You've been so kind in explaining all this. I definitely have a better understanding of it now 
Oh and check out this thing I built which may be relevant to your learning about Go patterns: https://github.com/fika-io/httputil I like to call this pattern "middleware" as opposed to "decorators" since it has additional HTTP-aware logic, but it's quite similar to what you were doing.
Will definitely do, thanks again!
If I got your progblem right, I can explain it like this: In basic situation like : fn1(fn2(fn3())); Flow of execution will be 'backwards': fn3 executed and it's value passed to fn2, then fn2 executed, and it's value passed to fn. But with decorators flow goes forward, but decarotor operates not with function result, but with function itself.
I think that if you look at our schedule, you'll be surprised that the vast majority of the talks are actually not focused on infrastructure at all. Take for example the talks from Marian or Hunter. Those talks are on topics that have nothing related to with DevOps or infrastructure, and both are topics in which other languages are frequently used instead of Go. We hope that after seeing those talks, others will start using/considering Go as a language for other tasks than just infrastructure/web development.
Perhaps the simplest way is this (not tested) ``` var m = sync.Mutex func myHandler(w http.ResponderWriter, r *http.Request) { m.Lock() defer m.Unlock() // exec.Command(...) } ``` This will probably not guarantee that your requests will be processed in order, so if that's an important concern, you'll need something a bit fancier.
Hey OP, this is what I see: &gt; gochanges.org is currently unable to handle this request. &gt; HTTP ERROR 502
I once wrote an internal web API that needed to limit concurrent use of an external binary that was doing the heavy lifting. The limit was needed to keep resource consumption sane, so my cap was five instances instead of one, but the idea is the same. I used a buffered channel as a [counting semaphore](http://www.golangpatterns.info/concurrency/semaphores). Since your limit is one a mutex might seem attractive, but if you use a channel then you can [use a select statement to timeout](https://gobyexample.com/timeouts) an API request if it cannot be served within a reasonable time and return a "server busy" response.
looks like some sort of PaaS / container manager architecture on the board there.
Spawn a separate goroutine and send all your "unoconv requests" through a channel to the goroutine. You have a FIFO queue :) But on a side note: if you can run concurrent instances behind a load balancer, in effect you are calling your library concurrently. So why not call it concurrently from your handler itself ?
A FIFO like you said would be a good idea. Do you have a SQL database already?
Honestly not a bad option but a work channel with a single worker reading from it would preserve FIFO ordering.
Pool of workers with queue is a good idea.
You can create wrapper struct around the library you use. E.g. ` type SyncStruct struct { m sync.Mutex obj &lt;your object type&gt; } func (s *SyncStruct) doSmth() { s.m.Lock() defer s.m.Unlock() // do whatever you want with obj } ` By doing this, you will ensure that all methods are being ran synchronously per instance, so all you need to do in the API is create a single instance and use it everywhere. 
Another option would be at the load balancer level, only send off one request to each backend at a time.
Oh wow, that looks amazing. I was recently looking for something like ncurses for go and couldn't find anything. Would you mind explaining how you did the window/UI layout?
The [libzstd.a](https://github.com/valyala/gozstd/blob/master/libzstd.a) file serves the following purposes: * It allows using upstream zstd code without modifications. The upstream code is located in [this folder](https://github.com/valyala/gozstd/blob/master/zstd/). * It allows updating upstream zstd code with a simple Makefile rule - see `update-zstd` rule in the [Makefile](https://github.com/valyala/gozstd/blob/master/Makefile). * It simplifies package build procedure, since go doesn't need to build `libzstd.a` from upstream sources - it only links with the pre-build `libzstd.a`. Additionally, this greatly speeds up package build time. If you don't trust binary `libzstd.a` from source code, just grab the latest upstream zstd code and re-build it with `make clean update-zstd libzstd.a` via the same [Makefile](https://github.com/valyala/gozstd/blob/master/Makefile). The https://github.com/DataDog/zstd lacks the aforementioned benefits, since it mixes upstream zstd code with its own go code in non-trivial ways. https://github.com/valyala/gozstd has easier-to-use performance-oriented API and better dictionary support comparing to https://github.com/DataDog/zstd - compare [gozstd API](https://godoc.org/github.com/valyala/gozstd) and [zstd API](https://godoc.org/github.com/DataDog/zstd).
Soryy, I'm not the author. But [this blog post](https://itchyny.hatenablog.com/entry/2018/04/10/100000#h3) the author wrote explains window layout.
Hmm, I wonder if the mutex not being perfectly fair will matter or not? As long as it's roughly-fair it seems like it should be fine, but it's also probably operating over time-scales that are somewhat larger than mutexes are designed for. If the simple mutex solution didn't work, you could use a channel as a FIFO queue. Then to get back your result, just use another channel. Something like this: https://play.golang.org/p/LYWJMpsVJA0
~~probably~~
Use a message queue to handle this case
Thanks. Fixed now. I'll investigate what caused the server to crash, so it won't happen again.
As far as google translate goes it uses either https://github.com/gdamore/tcell or https://github.com/nsf/termbox-go
Actually the API will be inside a Docker image. So I just want users to download the image without having to worry about a database :)
Have a great day!
The uses cases may vary. We can imagine: - an application calling the API because one of its user wants a PDF from its .docx file (order does matter I guess) - a backend job running at night which converts a list of Office document (order does not matter) So if my API is able to keep requests' order, then it satisfies every uses cases :)
Superb!No need to thank me, friend!
Got it. The FIFO queue should work fine for you then. Just take care of sending quit signals and being able to handle timeouts and backpressure.
Ok I get the idea :) Still, I'm not sure where I should run `handleJobs`. Here are my handlers chain: https://github.com/thecodingmachine/gotenberg/blob/1.0.0/app/handlers.go The handler which convert a file is called `convertHandler`. As you can see, a request normally just pass through all my handlers and then left. That's why I'm a bit lost about where to run `handleJobs`. 
Interesting, not specifying the length of my channel will allow me to receive X requests (until memory leak)? Still, I have the same question as asked to /u/innix :) Where should I put this part? ``` // elsewhere go func() { for request := range uploadRequest { response := doMagic(request) request.done &lt;- response } }() ```
Thank you for your advices! I'll take care of that :)
I copied a link to this question into gophers.slack.com in the #gopherjs channel where Paul Jolly is known to chat.
An SQLite file on a tmpfs would be a database that can handle multiple clients while fitting in a single container. But pure Go channel/mutex solutions will be far nicer.
I'd be really grateful for any feedback on this -- particularly any parts that aren't clear to follow or any terminology that I've not got quite right! 
That goroutine can start anywhere really. But it would probably be best located before you start your http server. You'd also likely want to add a check that ensures all requests in the channel are processed before the API shuts down.
Thanks for the interest - I've responded to your PR over at https://github.com/myitcv/react/pull/117 with a more comprehensive answer.
Have a look at [GoCUI](https://github.com/jroimartin/gocui). I have used this successfully for a project.
I think the best would be if you create or use a service library that enables you to spin up multiple go instances. These instances are all connected to for example Redis and will process one job at the time. Next can you let your API instance feed Redis with the jobs that your instances will process.
Looks good. Makes me kind of glad that I chose Google App Engine over AWS Lambda. https://cloud.google.com/appengine/docs/standard/go/quickstart
Cool, looks neat, reminds me of hecate https://github.com/evanmiller/hecate 
I went through this whole process a few months ago only to learn that the cold start times for lambda functions and additional latency for API gateway and Lambda functions made this a really poor choice for API endpoints. Perhaps some additional testing after setup is in order.
Great! Thank you for your advices, I’ll try to implement your solution :)
You can schedule the lambda to run once every 20 min to keep them warm, that solves the cold start problem.
Couple small corrections, not specifying length gives a length of zero- a receiver must be ready for a recv before a sender will unblock. Also both buffered and unbuffered channels are guaranteed to run in FIFO order, you don’t need a size to preserve order. 
Oh ok I wasn’t aware of that! Thank you!
It would be nice to see comparisons with this method to see how the performance improves. Though it doesn't exactly inspire confidence when I have to use workarounds to get to basic functionality. Makes me wonder what other gotchas exist that I might run into on a larger scale.
Yeah sorry, I should have said 0. Actually it seems that FIFO order is not guaranteed observable for either kind of channel: https://groups.google.com/d/msg/golang-nuts/CPwv8WlqKag/tvArwrZhb5EJ
why wouldn't this preserver order? i've never worked with mutexes on golang yet, but my naive reading gives perfect order.
[See here](https://godoc.org/golang.org/x/crypto/nacl) NaCl has sane defaults and is fairly secure, it's in the /x/ repo but fairly stable in general and shouldn't change really. Just use that.
I wrote an example showing how to use (mostly) just the standard library and get a simple encrypt/decrypt working in Go, Javascript, and Python. You may want to look at this: https://gist.github.com/tscholl2/dc7dc15dc132ea70a98e8542fefffa28 I would also recommend cryptopasta as someone else mentioned.
This is exactly what the NaCl functionality and API was designed for as its core use case. /u/Renorei, where your ideas and NaCl's ideas about the perfect API may diverge, I would extremely strongly suggest taking NaCl's ideas. The API is as easy as it can safely be.
Regardless of Go or not, the question is: do you trust your dependencies will be there when you'll need to do the build or not? Some of the people think that's always the case, some know better and commit the vendor directory (caveat in case you run your own code mirror infrastructure).
[removed]
Excellent! Just what I was looking for.
I'm really sorry, I had dep ensure in my build script and it failed on that line and skipped to the next steps (hence, the dependencies weren't installed). It did, however, install the github.com and golang.org directories inside vendor, so when I ran `ls vendor` I didn't pick up that the dependencies were not installed. I'm terribly sorry to have wasted your time, and thanks for reading the post through anyway.
Great write-up! Only thought is that if you happen to have a resource that dives into performance considerations (keeping warm, pooled connections, etc), that would be useful supplemental information (similar to the solid link to architecture pros/cons).
I’ll be able to answer that better if I know your general use case
You're comparing apples to oranges. Google's equivalent would be Cloud Functions.
I want to make a morse network with a central REST controller. User posts their morse code through a REST call, the controller transmits it to the destination user.
Yeah, I'd love to know more about it. That post basically says "we did it and it was great" but not much about how they achieved that. It's definitely not the same experience out-of-the-box.
Thanks! Your addressing library inspired our implementation of the Zones feature. One of the things I noticed is that your implementation of postcode matching in Zone uses a string, but I felt that it was more idiomatic to use an interface with different concrete implementations. 
No "The go programming language"?
%v doesnt work for me idk why I still prints as a struct if I use %+v it Will show the fields but still prints as a struct 
This is my first program that I've created using Golang and used it as a means of learning it better. I know I could probably clean and optimise it further (which is my intention) and I'd love some feedback and pointers on what I've got.
The api gateway overhead has gotten better, but there's still a latency tax of sorts to pay. But the connivence is amazing. In my experience, Lambda works great for services that mostly sit and occasionally burst. But if they are going to be running all the time, you might find that running standard ec2/containers whatever stuff gets run in these days. 
to; dr: you could use dozens of different options. If it’s truly a simple REST web app, hosting on raw compute is super simple because Go deploys are so easy. Buy a couple $5 DigitalOcean or lightsail servers. There are tons to of ways to get web traffic to a REST endpoint. Using Lambda and API Gateway is one way, but you’re billed on invocations and execution time, but scaling is handled by Amazon. IMO they have a generous free tier on Lambda that might suit your needs. Elastic Beanstalk is an option if you want dedicated instances but this can get complicated and is a little on the pricier side since you’re probably using it for more than one server and ALB. ECS plus ALBs or EC2 with ALBs is another option, but there’s more upfront setup. Maybe Heroku suits your needs if you only want to ship code, but I’m not sure about their Go support. Raw GCE, DigitalOcean, EC2, or many of the other cloud hosts might be just fine, since Go is so easy to deploy. 
Why deleted?
This isn’t basic functionality as far as AWS is concerned, it’s an intentional trade off. Their freeze/thaw cycle can be problematic and I’ve personally migrated a prod app of of Lambda because of atrocious response times. Perhaps our app was a poor Lambda use case, but we saw drastic reductions in response time (90%) by moving from Lambda to Node’s Restify web server running on Elastic Beanstalk. 
It would probably be good to embed the `collection.json` file _inside_ the `collection.go` file (i.e. as a multi-line string literal inside \`\` marks). As it currently stands, any program using this library would need to have the `collection.json` file available in its current working directory, otherwise the `ioutil.ReadFile` wouldn't find it.
Nice write up. I'm working on my first Go/Lambda and am using SAM. So far I'm pretty happy with it. Generated cloudformation templates for deployment + sam-local for testing is very handy. https://github.com/awslabs/serverless-application-model https://github.com/awslabs/aws-sam-local
 package http import ( "context" "net" "time" ) type CustomServer struct { s *Server } func (srv *CustomServer) Serve(l net.Listener) error { defer l.Close() if fn := testHookServerServe; fn != nil { fn(srv.s, l) } var tempDelay time.Duration // how long to sleep on accept failure if err := srv.s.setupHTTP2_Serve(); err != nil { return err } srv.s.trackListener(l, true) defer srv.s.trackListener(l, false) baseCtx := context.Background() // base is always background, per Issue 16220 ctx := context.WithValue(baseCtx, ServerContextKey, srv) for { rw, e := l.Accept() if e != nil { select { case &lt;-srv.s.getDoneChan(): return ErrServerClosed default: } if ne, ok := e.(net.Error); ok &amp;&amp; ne.Temporary() { if tempDelay == 0 { tempDelay = 5 * time.Millisecond } else { tempDelay *= 2 } if max := 1 * time.Second; tempDelay &gt; max { tempDelay = max } srv.s.logf("http: Accept error: %v; retrying in %v", e, tempDelay) time.Sleep(tempDelay) continue } return e } tempDelay = 0 c := srv.s.newConn(rw) c.setState(c.rwc, StateNew) // before Serve can return c.serve(ctx) } }
epiris is a leaking cunt. report that nasty bitch. that tool needs a ban.
I appreciated all the environmental setup information, like setting up the cli and the file structure of the code itself. Many tutorials will leave that kind of information out, and it’s very easy to get lost with “wait, where does the file go?”, so it’s nice to have it explicit.
don't let that douche bag intimidate you. These mods should have done something about him long ago.
Love people sharing!
IMO Cloud Functions is redundant. GAE Standard is comparable to AWS Lambda. Willing to be convinced otherwise though. 
Of course Go is good for CRUD operations, however there are frameworks out there, ie Rails, that will get you up and going much faster than with Go. It just depends on what the scope of the project will be, performance, what languages you already know etc. As for project layout following this https://github.com/golang-standards/project-layout is pretty solid. There is also this you can check out https://talks.golang.org/2014/organizeio.slide#1
I've built several REST style services using Go. Working with Postgres in Go is pretty straight-forward. We also used JWTs and Auth0. As for folder structure, keep it simple. I have a file for routes, files for data access code, and wire them up in main. Really only create more folders if the source root starts to get unwieldy.
If you want to understand why some people advocate for committing dependencies, google the left-pad incident to see what can happen when relying on centralised dependencies. Schools of thought do remain divided though.
Cold starts are only for the initial request. Also take advantage of freeze/thaw to cache data/connections. Finally, consider using regional API GW endpoints that avoid CloudFront. Techniques like these will all reduce request times.
https://github.com/carlmjohnson/whatsit is another one. 
[removed]
I would recommend using higher level tools than just the Go stldlib. My project started off as "just net/http" and "just database/sql" and now we have lots of dumb boilerplate code (riddled with one-off inconsistencies) to list all the columns for writing queries, scan them back into Go, etc. The models used inside the API are too highly coupled to the objects we send over http (thanks to "just use json tags"). It's crude and has caused a ton of technical debt and inappropriate coupling.
It depends what kind of project it is. For libraries I never commit vendor; for runnable projects I usually do. If a dependency disappears for a library then it's usually not a big deal as such, since all the stuff you actually want to run will still run (as it has vendor in git).
If I need to reach for a lock, usually my operation is non-trivial and lives in a function invoked by the route handler(or whatever is doing io). That has the bonus of allowing my logic to be testable without the net/http/httptest boilerplate. For example, using a [database package with connection pooling](https://github.com/jackc/pgx), you might run a sql query to respond to a client. Now, you're likely not going to put the query invocation in the route handler because there's probably a bunch of context around that operation. Instead, you invoke a function with the required parameters taken from the http request. When the function returns, serialize it to return to the caller. Under the covers, your db package will likely need to lock to grab a connection from the pool. This way, all your locks stay in isolated code and your handlers need not worry. tl;dr 'Don't lock around io' but also write testable code.
It's always nice when doing the right thing lines up with writing better, performant code.
That's amazing feedback. Thank you! What would you say about C# .NET Core in this case?
Unfortunately I have no idea -- I've always been on the open source/Linux side of things.
Been using C# with Entity Framework as a ORM for SQL. Tooling is always important in considering an MVP for us BUT the flip side of the coin you have to consider your teams proficiency in the language you choose. In general I can recommend C# .Net Core as a great way to get stuff out quickly. C# remains my favourite goto lang and with .Net Core it cross compiles to Unix platforms if you are looking at Linux docker deployment in a cloud env.
The part that dings me a bit is that all the first impressions point to this being a conference for the Icelandic Go community (if such a thing exists). The name is "GopherCon Iceland" and the website is registered under a .is domain. I absolutely understand that organizing conferences is a huge and tiring job, and having them in a place that you'd like to visit is a nice carrot for you and the participants. That's fine. It's just a bit disappointing to then see that, in fact no, this is a one-off thing parachuted in by the Go regulars. "GopherCon Foo held this year in Iceland" could have managed expectations better. Also, I can unfortunately only provide nitpicking and nagging from a distance, as I've lived abroad for a decade now and don't have much contact with the local community. Seeing things like this makes me think "Oh, there might be some work back home" and then "... no". :(
About learning Go and Web dev at the same time: There is a good book and video course available on this very topic at https://www.usegolang.com/. (I'd love to also recommend my own video course here, but it is only on Go, not on Web dev.) About frameworks vs libaries: A framework gives you a quick start but can limit you in severe ways once your project grows bigger and more complex. A set of libraries makes you stay in control. You decide about your architecture, your data structures, etc. Libraries are here to help but do not get in your way when your project expands. Go comes with a rich standard library from the start, and therefore naturally supports the "stay free, stay in control, use libraries" philosophy. So yes, there is a bias in Go towards libaries. This being said, you are of course free to use a framework if you want, as long as you are aware of the limitations. And the borders between libraries and frameworks can be blurry sometimes -- there can be frameworks that give you quite some freedom, and there can be libraries that put considerable constraints on your own code. Whatever you choose, choose wisely.
well give us compile time type safe synchronized data structures like type safe sync Map and Slices, and no need for locks...
Awesome write-up! Go seems to do really well at these kinds of stream processing/aggregation tasks. And the performance improvements often can significantly reduce computing costs. The team I work on has done this a few times now: replace or augment an existing vendor service or appliance by building a new system using Go. We also build systems to optimize the HTTP responses from other web servers, again saving money and improving performance. Add in a bit of home-made FaaS / edge compute that replaces a bunch of dedicated application VMs with simple Lua/Go plugins and the savings really start to add up! Oh, and if these kind of things sound interesting we have a few developer, operations, and internal services/consulting positions that just opened up 😁 Remote friendly (but usually requires the right to work in USA) and an awesome team working on interesting problems. Hit me up for details! Platform Developer: https://careers.walmart.com/us/jobs/1027875BR-staff-software-engineer-golang-developer-sunnyvale-ca Internal Support/consulting: https://careers.walmart.com/us/jobs/1027871BR-staff-software-engineer-sunnyvale-ca
I used flask for a small CRUD app before. It's easy to get started and doesn't force you to follow any conventions. Most of the work was in the front end of my so so flask made sense since I knew it wouldn't be a huge app, just a few APIs. That being said, don't know how well it scales. 
Thanks for taking the time to write this up and share it!
I just started learning... Deep learning and I love go.. So thanks!!
In a professional environment, you'd be hosting your dependencies in your own proxy, not commit them in a vendor directory like a savage :)
Actually looking to build this out from scratch for https://github.com/micro/go-micro. Feel free to join the Slack and discuss http://slack.micro.mu/.
Did you check out Conductor? \([https://netflix.github.io/conductor/](https://netflix.github.io/conductor/)\)
If you are considering the frameworks/tools route, there is a popular Go alternative for rails: [https://gobuffalo.io](https://gobuffalo.io) 
This is *awesome* =D Good idea!
Only take advice from people you want to become more like, in a specific area.
The C influence shines through, but the code is nicely structured!
Great article, thanks for sharing! I have a question: how do you avoid too much concurrency issues? With the implementation shown, wouldn't a very big and complex filter potentially open too many concurrent connections to SQL? The way I understood it, the filters are traversed and all the queries made concurrently, then waiting for all the queries to finish. Did I get this right?
Go's sql package uses a connection pool so there would only be a certain amount of connections open at any given time.
You might be interested to have a look at http://scipipe.org It supports separate, named ports, concurrently running processes, and can easily be rewired at will by a high level connection syntax. It has taken some inspiration from GoFlow, but does not depend on reflection, but instead uses channels directly between ports underneath, and also has a somewhat more terse syntax. It also helps workflow design by allowing connecting one out-port to many in-ports (thus doing automatic duplication of data packets ... which is fine, since they are mostly immutable in scipipe anyway). It is right now pretty focused on components (processes) running shell commands, but custom components can be written in Go as well, by plugging in an anonymous func() in proc.CustomExecute field, or by writing a completely custom Go component (but they you'll have a bit more work on reading and sending to in- and out-ports in the correct way). Another caveat is that scipipe is right now heavily based on using the local file system as the persistance layer, and coordination point. This is planned to be made more flexible in the future. 1.0 is not (yet) reached, but we use it daily to run workflows locally and on HPC clusters (using the proc.Prepend field to prepend HPC resource manager command to shell commands). Would love to hear your feedback on it.
Did you make this api with tensorflow-go ? I just sent a request to use your api, seem really cool 
As u/GoHomeGrandmaUrHigh mentions, no one can use this without copying your collection file (and distributing it). I've got an [example here](https://github.com/snicol/swearjar-go/blob/master/swearjar.go#L13) of my own project using a string literal to hold the json blob (caution, it's a swearjar so you will see bad words). You could also use resource embedding with the added advantage you can use gzip. See [here](https://github.com/avelino/awesome-go#resource-embedding) for some different libs that do this. I've not used UnnoTed/fileb0x but it seems to have gzip + json support and is maintained unlike go-bindata. There's also no check for ReadFile errors or Unmarshal errors in `collection.go` which worries me. Otherwise, a very handy lib that I wish I had a few months ago! 
If you use `db.SetMaxOpenConns`. Otherwise the number of connections is unlimited. I had that happen for an app that queried a ton of data from another api in many requests. Regularly went over the pg connection limit. Put in a reasonable limit in the api, works a charm.
I was pleasantly surprised that it wasn't just a pitch for your service, but an actual honest to god write up of a useful service that 1) replaced obsolete/unsupported software, 2) was efficient and saved you bunches of money in the long run. So, did you get a $50k bonus for the team working on it? :D
As far as the code goes the author is currently importing and using tcell: https://github.com/itchyny/bed/search?utf8=✓&amp;q=tcell&amp;type=
Does that mean you solved your issue? 
What is the main difference to gopass (https://github.com/justwatchcom/gopass)?
Great suggestions, thanks!
Thanks Actually found scipipe while researching this before asking the question. I still need to play with it, but what was a bit discouraging when I saw it first was the file oriented nature of the processing (it makes sense for the types of problems it was build to handle). Will take a closer look again.
Hard to say without knowing specifically what your steps consist of but https://github.com/Jeffail/benthos is a service for multiplexing different sources and sinks and performing common message streaming tasks. It exposes metrics and logging and performs retries internally. It's configured in either json or yaml and lets you write a list of processing steps for each input/output such as content based multiplexing, filtering messages (as text or json), mutating messages (as text or json), batching, splitting, (de)compressing, (un)archiving, etc. We use it at work as a swiss army knife for building platforms.
This might not be a popular opinion, but I think the first mistake they made is to switch to some obscure small project (InfiniDB) instead of using a mature, battle-tested solution which could handle the load. Then fixing this mistake by using Go to speed up things which InfiniDB caused in the first place. This whole thing could've been avoided by just looking at better tools. My first "checkbox" when looking at new tools, is how big the community is behind it. 
Conductor seems to be a bit on the heavy side for what I am looking for. Will play with it and see if I can make it work.
Indeed. I have lately started to regret making the file-based nature so inherent to the design so early, and is in fact since a few months looking at ways to refactor it out to be more generic. It takes a lot of thinking though, because of Go's characteristics. I recently managed to make other core componnets of the system (processes and tasks) built on a really generic core, using a nice pattern that have crystallized, so I have high hopes to solve it somehow, in the near future.
Thanks a lot! Not it's fixed 
Your name may collide with https://fishshell.com/.
Feeling weird pointing out, but C# .Net Core is open source and runs under Linux.
Going to use this for now as I need to be able to specify the key. Thanks!
Það er gjörsamlega ekki neitt spennandi að gerast heima, kannski flytur maður einhverntímann aftur og þá vonandi með remote vinnu í farangurshólfinu.
Thanks!
This really could have been rephrased as, don't just blindly defer things.
I have no experience of these beyond reading source/posts here... https://github.com/contribsys/faktory https://github.com/fireworq/fireworq
Much appreciated
That's great info, thanks!
Understood. Thanks!
Depends if the professional environment affords that investment or considers other things to be more important. Not sure how savages prioritize things I guess.
I suspect you could save a lot more money every year by purchasing bare metal hardware and maintaining it yourself instead of renting it at this scale. 
Yep, I found this solution, but interoperation within the app itself, especially with Cloud Datastore worries me somewhat. I wonder if Datastore would be able to properly handle []quotedUint64 as a uint64 array on save and get.
Who actually locks around entire HTTP handlers? This would be an instant code review fail.
Ironclad looks to be a minimalist tool that lets you store, edit and show (or paste to clipboard) text based passwords contained in an encrypted json file. Gopass have enough functionality to warrant a series of blog posts.
Definitely second about those DSLs re-inventing programming languages over and over. Perhaps it makes sense in certain cases, but most of the time, but one has to consider that to make developing in a new DSL productive, one will need new syntax highlighting schemes, autocompletion support and code linters and verificators etc, which is already available for existing languages. This is one reason why we went with a pure-Go API as default in SciPipe. The Go tooling is just too great not to use. The Yaml plans we've had, has been thought to generate scipipe Go-code, so that you could continue from there, if you'd have any more complex use cases - like starting to include "ifs" here and there, as you refer to :) Also second about how hard it is to make re-usable components in Go. Lack of generics really shows its consequences here. What we realized helps in this direction, is to do heavy use of struct-embedding, to create poormans-generic base components, that work with string-&gt;struct maps to keep track of things, and then embed those in outer structs when certain accessor methods need to be made more explicit (naturalyl help for things like autocompletion, testing, and documentation). We have documented this to some extent here: http://scipipe.org/howtos/reusable_components/ , with an example here: https://github.com/scipipe/scipipe/blob/master/examples/wrapper_procs/wrap.go but we also figured we could use the same strategy for the inner components in scipipe, so now, the "BaseProcess" is such a poormans "generic" base component (https://github.com/scipipe/scipipe/blob/master/baseprocess.go), which is embedded into the "Process" component, which adds a few more methods which are more specific and concrete (https://github.com/scipipe/scipipe/blob/master/process.go). This seems to work great, and i'm only now scratching my head about how to do the same with the IP ("data packet") components in https://github.com/scipipe/scipipe/blob/master/ip.go . That has turned out to be slightly harder because channels somewhat extra non-generic, which seems to pollute everything that touches them into being locked to a specific type. I have some ideas (collected in https://github.com/scipipe/scipipe/issues/45 ), but any feedback on this is highly appreciated.
Maybe, but personally I don't think trying to protect against "precision limiting" is worth a lot of time. I've never see anyone use something that isn't just `int` and it not be good enough. If this were a worry within the Cloud Datastore ecosystem, I would have expected some special ID type. But who am I say, I really only use UUIDs with postgresql and move on with it... :P
Basically, if you need to use locks, make them as fine-grained as possible, i.e., lock around the tiniest window. This is quite generic to many things. 
EC2 is spectacularly expensive if you don't need it's management infrastructure, and fairly reasonably priced if you do.
&gt; That has turned out to be slightly harder because channels seem somewhat extra non-generic, tending to pollute everything that touches them into being locked to the channel's specific type. In the thing I wrote, I gave up and use reflect to wire up the graph with the specific types, but I did also notice how hard it is to have one thing emitting, say, `[]byte` and something else that wants to receive an `io.Reader`. You'd love to be able to match those up with the obvious byte.Buffer wrapper, but the only way I've come up with being able to do it is to spin up an entire freaking goroutine for the conversion, which at scale is quite expensive, or lose the syntactic select. I stopped mucking around before I got to this point, but I did find myself wondering what the performance penalty of [reflect.Select](http://127.0.0.1:9000/pkg/reflect/#Select) would be. If you could use something like that without too much penalty, then I can imagine how to put the conversion behind the scenes into library code that would use a smidge of reflect behind the scenes. It's possible you could get the general case down to some decent API (_most_ of the time you're going to send and receive defined things along the defined connections, it might be that the common case doesn't look too ugly), while still leaving people the ability to add their own select clauses in a pinch. It's grotty-but-straightforward code on the other side. It isn't compile-time type safe, but it is "will either fail the first time or succeed always", which is still better than nothing. (It's really easy to catch those in unit tests.)
Unfortunately I don't have the link anymore, it was not in go. So I thought I'd see how I can make the same thing in go. I found a cross platform notification library and built it. Will need to add some tests, maybe figure out how to improve usability. What do you guys think?
Thanks a lot for sharing!
Yes
Thinking now ... could either of glow or gleam be something? (It supports distributed mode, but seems simple enought to be worth it even without using that): https://github.com/chrislusf/glow https://github.com/chrislusf/gleam
Thank you for the book recommendation! As for the framework vs library question, would the above book show us how to set up our own customized libraries?
Floats in the interval [-2^53 + 1, 2^53 - 1] should be safe to pass through JSON. If this isn't enough for your application, the Go JSON package can marshall the math/big types automatically. You can find some more details at http://yourbasic.org/golang/json-example/
Whyyyyy?
Haha. Yes, I hope so. I think using an HTTP handler to demonstrate the problem, though, is especially vivid. I hope the example will get readers to be as discerning with their locking strategies.
Its not that a Go Microservice solved their problem. Its the different algorithm they use for querying. That has nothing todo with Go, or Microservices. 
For the glory of Satan, of course.
SIP and DNS servers are two examples which usually listen for both TCP and UDP connections on the same port.
You should clarify whether you need to listen for both TCP and UDP on the same port, or if they are listening on different ports. The latter is much easier than the former.
I am in very similar situation, learning go and Web development. For me very useful about learning go itself is Youtube channel justForFunc. Basic web development is also covered there. More you can learn from some open source projects on github.com or by creating your own app and posting it somewhere (gophers slack #reviews) to review. 
It's supposed to follow RFC 865, so I'm guessing they're going to listen on the same port. My code looks like this at the moment: https://pastebin.com/paT7qYFc
There‘s literally no difference. You are probably referring to the same socket which would require a raw socket.
If you are holding a lock for too long, highly likely it can be split into two, one with lock and the other one with a lock. So, yea just looks closely. We need static analysis tools which detect and flag these issues. 
Twitch | SF, Seattle | Full Time [Twitch](https://www.twitch.tv/) is the world's biggest live broadcasting platform, and is one of the biggest Go users in the world. Nearly all of our backends are written in Go, and we've been heavy users since go1.3-ish. We are deeply involved in the Go community: - Tony Ghita, the primary maintainer of [graphql-go](https://github.com/graph-gophers/graphql-go) and all-around great human being, works at Twitch - Rhys Hiltner has published some great articles [on Go garbage collection](https://blog.twitch.tv/gos-march-to-low-latency-gc-a6fa96f06eb7) and is [constantly involved in work on the Go runtime](https://github.com/golang/go/issues?utf8=%E2%9C%93&amp;q=+is%3Aissue+author%3Arhysh+) (issue [https://github.com/golang/go/issues/17831](#17831) is a personal favorite) - I released [Twirp](https://blog.twitch.tv/twirp-a-sweet-new-rpc-framework-for-go-5f2febbf35f) earlier this year. I work on Twitch's [Video Platform](https://jobs.lever.co/twitch?department=Platform%20%26%20Services&amp;team=Video%20Platform) team. We build large, complex distributed systems in Go and certainly are hiring for those roles, but I'm personally hiring to form a new group to build development tools and infrastructure for our engineers. You could be a part of this team! Go expertise would be useful, but not required - we think Go is easy to learn. REMOTE work is an option if you're experienced and have worked remotely in the past, although we'd probably want to work together in person for at least a few months to build rapport. To apply, go to https://jobs.lever.co/twitch/7bf12720-20d6-4768-85be-228874615a8f (feel free to look at other roles at Twitch too, of course :)). Email me directly too if you apply, or if you have any questions: spencer@twitch.tv
These are good points. Just wanted to add this: in the case of getting a connection from a db-connection pool (or in a generic producer-consumer problem), we can get a connection using the so-called 'lock-free programming' technique. It's essentially a CAS like technique which can directly be translated into assembly code. That drives down contention quite a bit compared to mutexes / locks.
&gt; how big the community is behind it. Yup, in addition: * Frequency of commits * Frequency of releases * Build / test coverage * Number / age of open issues * Prominent users of said tooling * Overlap between team's expertise and tooling On that last one: doesn't matter if it's the most popular tool in the world, if it's written in Ruby and your entire team speaks Java, it's going to be an uphill battle from day one. Needs to be considered what it'll cost to fight that battle. And that could be why this issue came to be.
I think it's always good to keep in mind flaws of a language, but I feel that sometimes people expect every language to be able to do everything well. Go does a _lot_ of things amazingly well, and satisfies many use-cases more than adequately. Scala for example also has many flaws, and I'm sure a post similar to this could be written about that. Probably the same for Rust, and any other language out there. There are indeed gotchas in Go that possibly could be removed, but some of the things that fall under "The Bad" and "The Ugly" here are the things that make me enjoy using Go, or that make it easier to use in my opinion. For example; the lack of generics - I think the solutions I've developed without generics have been much easier to understand because I've thought about it another way. If I would _need_ generics for something, then I could turn to code generation, and while it's not without it's flaws, I prefer the simplicity that it brings to the language in _most_ other code. Interfaces too, 2 of the problems listed are ones that I don't see any _real_ issue with. Editors tell people which types implement an interface. Yes, types may implement interfaces accidentally, but that has never once been an issue for me because you would still have to write code that passed those types around to the wrong places (very unlikely). The only issue I've had with interfaces is when adding methods, you do sort of have to do it backwards - but like you said, you can make and compose smaller interfaces to get around it. If you define interfaces away from their concretions, where they're used, you will find this problem also happens far less frequently too. Dependency management right now is a mess, for sure. That problem should be resolved when the Go tool-chain has versioning support, which is upcoming. &gt; Functional programming? No mention of it. Generics? You don't need them, look at the mess they produced in C++! Even if slice, map and channels are generic types as we'll see below. Not every language needs to be functional. A lot of functional code is harder to grok because things are hidden behind abstractions. I'm not trying to say abstractions are bad by any means, and yes, you can learn those abstractions, and in fact having spent a lot of time with Scala myself, I do understand many of them - but when you are working in a team, or trying to train new developers, or trying to learn the language yourself, or even trying to read other code like the standard library - all of those things are substantially easier if the code is easy to understand. Your code might not be as concise, but I'm yet to come across Go code that I've not been able to grok (that hasn't been written to be intentionally difficult to understand, that is). On top of that, Go _does_ have some functional features, like first-class functions. I appreciate functional programming where it helps maintain a focus on business logic, for example, Spark is a great example of where functional programming is incredibly powerful. This simply ties in to one of my first points; you should be picking the right tool for the job. Not all of these points are wrong though, but no language is perfect. There are other languages that solve many of the problems outlined here, but that also don't have many of the advantages that Go has. 
The hardest part of understanding this is to understand that there is nothing hard to understand. To have a server running two listening ports, you just start one goroutine to listen to one port, and start another to listen to the other. The only slight bit of drama is making sure the main goroutine doesn't fall off the bottom and exit, resulting in the program terminating.
Some other points are really wrong and just show a lack of understanding of Go, for example in "zero values that panic". But I agree with some of other points, especially about mutability and some bastard features in the language such as iota, ":=/var", panic, "generics", etc. I wish the Go creators would communicate a road-map for Go 2.0, because there are real issues in the language. We need something similar to what ANSI C brought to the language compared to K&amp;R.
Mér liggur ekkert á heldur. Það eina sem gerir það eitthvað áhugavert að flytja til baka er að vera meira með fjölskyldunni og að strákurinn minn geti þekkt þau almennilega. Hvar ert þú?
And Perl runs on Windows!
As an embedded scripting language it could be useful. 
Shouldn't other components only access via the REST API? importing seems to go against the principles of a REST API.
I'm personally very excited about this and I'll say its about time! Ruby is a powerful and expressive language, with a terrible concurrency model. Go's runtime as a VM for other languages makes sense to me, making the work to offer strong concurrency for language developers pretty easy. I'm not sure if implementing Ruby as-is is the perfect choice, perhaps a small fork of the language might be necessary to jam in goroutines + channels, but still cool!
They should, if it's saving 50k PER year, the least the company could do is give the team that's going to save them endless amounts of money a nice bonus.
rails is too good
Oh, well, that's great! It's not production code at all, so I guess I'm in the clear. Thanks for the reply!
[MRW](https://giphy.com/gifs/why-ryan-reynolds-1M9fmo1WAFVK0)
huh, TIL. Thanks!
I've been learning GoLang in my spare time, actually put other languages on hold. And have even put it on my applications to WalmartLabs hoping they're be like "Ohh someone learning GoLang" because I'm pretty sure, especially in the case of customer facing apps, GoLang would improve performance a lot but also probably on internal apps. I don't have the necessary formal schooling (Incomplete bachelors at an accredited but for profit school) and nearly ever position asks for it or a professional/documented work history in CS (everything I've done has been personal or private/unpaid *cough underground(legal) cough*) projects, sadly. So I've started working on a portfolio of sorts so I can be like "here, look what I can do" and hope that helps my chance. It's nice to see that WalmartLabs is getting into Go, I didn't see any positions when I looked previously, I was worried that they wouldn't bother. Off-topic, but are there specialized positions that focus on UX? Or is it just up to the programmers to do the UX, because it seems like some of the designs of the apps were made without thinking of the end user. Also, what is Staff Software Engineer? I've only heard the term at Walmart, but I've inferred that it's a position higher than Senior Software Engineer based on pay grade.
The book's approach is to walk you through a Web project, and you learn Go as you build up the Web application. Libraries ("packages" in Go lingo) are created in the course of this project and therefore demonstrate *by example* how to structure packages around an application. There is no generalized "how to" chapter on packages, but then creating a package is really quite easy in Go. 
You could, kinda, re-work Mage to do this: https://magefile.org I have been thinking of this issue as well as I do have some ETL-ish tasks that I need to run to populate a heavily normalized db. 
Does it still have a GIL?
willing to add any suggestions!
Wow, Russ' comment was so clear and detailed it should probably lie in an FAQ somewhere.
It would indeed (thanks for pointing that out). The main caveat now is that it is more of a pattern than a full library (but the pattern works great indeed), but also that the core of scipipe has in fact improved to become superiour in many aspects to flowbase. I'm planning to break out these improvements into an improved version of flowbase, which then scipipe can depend on hopefully, but haven't got to do it yet (so many distractions while pursuing a phd).
lol no generics
I missed this one, thank satan!
I'd be open to helping with that as I am diving headlong into go to potentially replace an ETL-ish system
&gt; finding what types implement a given interface is hard as it relies on function definition matching. I often discover interesting implementations in Java or Scala by searching for classes that implement an interface. Stop using interfaces as if the type system were nominal? Use them [as if they were structural](https://blog.chewxy.com/2018/03/18/golang-interfaces/). &gt; There is no way to define immutable structures in Go: There is [this](https://blog.merovius.de/2018/02/25/persistent_datastructures_with_go.html) &gt; As we saw above there is no way in Go to have immutable data structures. Send structs? &gt; Noisy error management You're a programmer. Program your way out. Write [monads](https://blog.golang.org/errors-are-values) if that makes you feel like that's the cool hip thing to do.
Why would you need an embedded scripting language in go?
yo dawg
My thoughts exactly
I’m currently using one in a personal project for a task manager. I embedded a JavaScript engine and expose some of the Go code through JavaScript functions in the interpreter. It allows you to easily create reports, run bulk updates, etc, without me compiling in specific support for it. Everyone wants to archive tasks differently. I can either build a complex command with a shit ton of flags, or I can just have the user script it themselves to do exactly what they want.
One example would be a facility like Lua scripting in Redis
Make something wonderful with clojure, instead of learning Go. 
My 2 fav languages together, here take my upvote!
Go is a good programming language
The canonical reference on this subject is - https://speakerdeck.com/mitchellh/advanced-testing-with-go - https://www.youtube.com/watch?v=8hQG7QlcLBk
[removed]
The thought that someone on this sub would down vote a comment by someone as well known in the go community as /u/chewxy is amazing to me. 
The CLI is installed to /usr/local/bin/gofish so it does not collide with the Fish Shell in any way on your OS. They only share the same project name, which if you want to argue about name collisions, they all collide with "Fish, the Fish". People Google for things related to Fish shell by using "fish shell" in their keywords, not "fish". If you're a Fish shell user, go ahead and call it GoFish if you want. It's my personal pet project, and I'll continue to call the project Fish. It's just a name, damn it.
Ha, this is what I find myself manually doing for practically every recipe, very cool!
I got excited for a new talk by Rob Pike but I thought it seemed familiar. This is just a repost of a dotGo 2015 talk https://youtu.be/rFejpH_tAHM
Both CPython and Ruby use a GIL. Other Python implementations (PyPy, etc.) don't use use GILs.
Oh, I had no idea that Ruby has one too.
Because it is only slightly easier to change runtime behavior in Go than it is in C, and there are use cases where that is very helpful, like an extensible editor, game scripting engine, etc. That is the one place where a dynamic scripting language really shines.
Using both my favorite quote from somewhere, "functional programmers know the value of everything and the cost of nothing". Use the tools that work for you. As a hammer user, screwdrivers aren't impressive.
Every day we move further from god's light.
They stole [my article title](https://blog.carlmjohnson.net/post/google-go-the-good-the-bad-and-the-meh/). (Actually, mine was better.)
The autocert usage is not right. Since TLS-SNI-01 has been removed from the ACME draft and implementations, you need to spin up a server on :80 to handle the HTTP-01 DCV challenge. ACME servers will not try to validate over HTTPS unless they receive an explicit redirect from port 80.
I agree it’s far from perfect, but I like to give the power to the user. Plus the thought of writing a DSL makes me want to cry more than asking the user to use JavaScript.
Great, thank you!
At least use one of the 5 embedded lisps available in golang or something! JS is just....oof.
I mean, I wouldn't complain about an endless stream of cash...
Most people aren't comfortable with lisp, but JavaScript is easy enough to get something basic working with it.
I’m not familiar with Lisp, and since they don’t have an embeddable Python interpreter, JavaScript it is! 
Lua's a reasonable choice too! I just picked Lisp because I know there's at least a few lisps in Go that are quite pleasant to work with. But JS just sounds awful.
JS is fine, especially with the newer features that have been added in the past few years. It gets a bad rap, but it's actually reasonable to work with. That being said, I like Lua quite a bit better, and I like Go even more. I might have to check out the lisps available in Go though. :)
&gt; I don't understand this argument. The same applies to enums too. It does to C style enums but I don’t know personally many languages using those. Enums implemented like sum types are a first class thing, not just integer constants. I don’t agree with OP that the danger is in inserting a line. It seems like you’d have to be doing something odd like deriving “enum” values with arithmetic to encounter an issue. However I do think there is a problem with enums that are just constant integer values and that’s that there isn’t type safety (technically safe because it’s an integer but effectively unsafe because you are using a subset of integers as a new type). I can’t write a function that takes my enum type (let’s say with 3 enumerations) and know it won’t ever receive the value 55.
Then we can convert it to asm.js and run it in firefox with a rust CSS rendering engine.
&gt; Write monads if that makes you feel like that's the cool hip thing to do. I think it's important to note, that the article does not implement Monad; it implements [Monoid](https://www.stackage.org/haddock/lts-11.4/base-4.10.1.0/Prelude.html#t:Monoid). The crux of Monads is that they allow you to compose computations - i.e. not only does the Either Monad prevent the *effect* from happening after the first error, but also the rest of the *computation*. As the author notes, the pattern in the article does not return early on error and if the values written are more expensive than just slicing (say, template execution) that difference becomes very important. There is a way to get the actual behavior of the Either Monad with panic, but I wouldn't exactly recommend that either :)
You kinda want to import the data model the REST API is exposing :) unless you want to copy-paste that code, but that's wrong for a number of reasons.
Scripting in games, allowing dynamically loaded plugins, exposing internals to external hooks...the same reasons people embed lua or javascript or scheme in programs.
What are the advantages of using charlatan over [https://github.com/golang/mock](https://github.com/golang/mock)?
&gt; I think it's always good to keep in mind flaws of a language, but I feel that sometimes people expect every language to be able to do everything well. Go does a lot of things amazingly well, and satisfies many use-cases more than adequately. &gt; &gt; what about basic stuffs, like final variables? I don't believe one second the current state of the language is acceptable in that regard. what about compile time type safe synchronized maps and arrays? it's baffling that people need to use "untyped" sync.Map to do that in a language that claims easy concurrency. No, go has real obvious issues that have nothing to do with generics and co.
&gt; Personally, I'd probably go with Lua, Yep, I looked around at different options and went with [gopher-lua](https://github.com/yuin/gopher-lua) for a recent project that needed both local scripts or a network API to control the systems. That Lua VM is plenty fast enough even on Raspberry Pi Zero Ws which is what my project made use of.
Simple doesn't mean that's easy...
&gt; Simple doesn't mean that's easy... that's what written on go homepage &gt; Go is an open source programming language that makes it easy to build simple, reliable, and efficient software. Maybe you should submit a pull request.
It's an utter shitlang mate 
Oof, so much of what I like about Go mentioned as bad or ugly. Okay then, it's a matter of taste I guess.
K. JavaScript is not my favorite language, either. But it has its uses, it is ubiquitous, and an absolute requirement if you care about anything web related. But that’s not what this thread is about. This person is being shit on because they chose to embed what is, arguably, the worlds most popular and well known language into a personal project. If you want to reach your average developer, use JavaScript. Look at all of the companies that support writing JavaScript for things - Amazon, Cloudflare, Nginx, Zapier, etc.
A compile time synchronized map can be implemented in a handful of lines with a mutex. It is slow but safe. Why should the language _itself_ provide something like this? Go claims easy and fast concurrency.
Is it still not your everyday language? What is the current situation?
110% biased Python developer answer: because the Python community doesn't really have fanboys, we want Python to be better and we have performance problems to solve. Also I don't know if other languages block that much - e.g. threads are really useless unless you only do I/O waiting.
To have generic and exceptions.
Maybe simplistic, basically a testing function per method in the interface/package. So I’ll have an getTestingDBAndConn func at the top of the test file, which returns a DB connection and in itself will run and test the migrations against the test DB which runs locally. Then for stuff in the model it’s just run the methods and check the DB for results. For controllers I’ll create an http request and pass it to the handler and check the response. It’s very simplistic but it works for our app well. 
Runnable example here: https://github.com/lthibault/quic-mangos/blob/master/example/pair/main.go
Cloud Datastore has a special Key type, but it takes a lot more space than necessary. If you know the Kind and Parent (if any) of the entity referenced, it's pointless to store it all. And better worry about it now than be flooded with post-beta bug reports a year in, due to JS "approximating" certain IDs... :)
MRI uses a GIL, other Ruby implementations like JRuby don't.
Forward compatibility and old distros maybe?
Go is forward compatible as well, you can write code in 1.4 and compile it on 1.10 just fine. As for old distros, you can download and use the Go SDK straight from the website, in less than a minute after downloading.
This tool doesn't seem to address that part of the ecosystem in terms of problems that it solved.
I use both Go and Python a lot. Plus client side JS. 
`strings.Repeat("/", 8)`
Anyway I decided to sidestep the issue and use byte slices. They marshal to and from base64 strings, which is pretty much spot on for my use case. Also I hoped to avoid having separate models for storage, business logic and JSON, but it seems it won't sit well no matter how I spin it. I can probably still use the same model for business and JSON, and another for Datastore schema.
Looks like the major diff is that this creates a mock interface using hooks that you implement in your test file. Golang mock implements a reflective object that you attach expected behaviors to. In terms of testing golang mock would generally be better because you aren’t introducing new code into your test env that itself is untested. However, for really complex behaviors preregistering all input and output expectations maybe redundant or difficult to posit about later. Seems like this tool falls in the category of “enough rope”. Its use should be carefully considered so you don’t hang yourself. But a good tool to keep in your pocket for those times mock becomes cumbersome. 
There's nothing simple about most concurrency models. 
[removed]
One more could also be RxGo: https://github.com/ReactiveX/RxGo 
Last I knew, PyPy still used a GIL but we're working to phase it out...
Last I knew, PyPy still used a GIL but we're working to phase it out...
Last I knew, PyPy still used a GIL but we're working to phase it out...
Full time Python dev here: I think if Python wanted to get better and improve performance, they could start by getting rid of some of the mostly harmful magic that makes Python so hard to optimize. I think that the fierce, patently false arguments people make in favor of the GIL (Python has threading and the GIL doesn't make it slow, or multiprocessing is just as fast as threading in other languages, for example) indicates that Python has quite a few fanboys.
&gt; I can’t write a function that takes my enum type (let’s say with 3 enumerations) and know it won’t ever receive the value 55. Go is the first statically-typed language I've really learnt, and this is something that struck me as seeming to break some of the safety guarantees static typing is supposed to give you. Sum-type enums strike me as a much better idea.
Author here. It's a difference in approach, so IMO the advantage is more concise test fixtures. I feel that the expect style used by the mock tool has a very tedious API that leads to excessive boilerplate in tests. The hook style allows you to express your mock's behavior precisely using normal code without having to map that logic to an abstraction. I hope you find the project useful!
&gt; A guy from Stackoverflow used ffmpeg to achieve this, but his context and problem were different. ffmpeg is still a very good and easy to use way to achieve your goal. Why not use it?
Yea I've had plenty of code break between Go versions. For example, plenty of people had implicit logic depending on order of map keys. Their code was possibly broken, but clearly passing their tests/etc, so it was working in their context. Then they updated a Go version, and it all broke. Go didn't do anything wrong here of course, it's a great feature - but that doesn't change the fact that a Go version caused a code-breaking scenario to appear.
He needed to get the first frame of a static file, which was already encoded, while I have the video in plain [] byte format from a HTTP body.
It's still encoded in mp4, and you can [pipe the byte stream to ffmpeg](https://ffmpeg.org/ffmpeg-protocols.html#pipe).
Thanks a lot, I will look into this.
My hunch is that it would make a difference. Nodejs is great at io but not so good at high cpu calculations. Go will certainly be better. Also, try pynum width python. All of the vector calculations are written in C. You should write all three and measure performance. That’s the best way to be sure. 
Ive noticed if you're using dep, older versions of go ignore the vendor folder.
There are also several Ruby implementations which have no GIL. MRI is the one with a GIL.
My bad, I'm not an expert in not-CPython. I did a quick search and saw something that said it did.
Got ya covered http://feyeleanor.github.io/RubyGoLightly/
If by older versions of Go you mean anything before 1.6, then that's expected as that's when the support for vendoring was activated by default, after being optional in 1.5. However, if you are still using Go 1.5 or earlier then I urge you to upgrade to the latest as you are missing not only important performance updates but a lot of security updates as well. Go does not backport such patches for more than current version-1, eg you can expect 1.9 and 1.10 to be support but 1.8 is end of life as far as the support goes.
This struck me: &gt;Go creators deserve a lot of respect, but it looks like Go's design happened in a parallel universe (or their Plan9 lab?) where most of what happened in compilers and programming language design in the 90's and 2000's never happened. Most of what happened in industry in the 90s and 2000s was C++ and Java, and many of us who use or have used both think that they were ultimately mistakes. If you want "C++ but better", use Rust. Go is for those of us who think C++ was a step in the wrong direction, who remember Modula-2 and its successors, and think that there might be a useful space beyond C that doesn't involve functional programming or the things that made C++ bad. Go goes back to C, ignores everything C++ did, and makes different decisions. I think the fact that Go has largely failed to pick up C++ programmers reflects the fact that it's difficult to get people to try things which are philosophically fundamentally different, even if they look superficially similar. That's a lesson which keeps getting learned over and over again. My favorite example is Dylan, once a statically compiled Scheme: the development team decided to throw away Lisp syntax and have a more C-like (Algol-like) syntax in the hope of winning over C++ programmers. Didn't work.
That's simply not true for any recent Go version. Maps are documented to not be sorted in any order and as of Go 1.1 all iterations are randomized so no two for loops will have the same order for keys in maps. This has been well documented for more than 5 years.
Here at Auth0 we've written a number of good tutorials around REST APIs and such. Here are a few examples to hopefully get you started: - https://auth0.com/blog/developing-restful-apis-with-loopback/ - https://auth0.com/blog/using-python-flask-and-angular-to-build-modern-apps-part-1/ 
This seems like the way to go for me. Do you have any references available that demonstrate how I can do this? Thanks 
Caddy doesn't cover my use case. FRP is essentially an open source ngrok alternative.
[removed]
Fork it to your company’s repo and build it yourself from source.
I stopped reading at `if (err1 != nil) {` - it shows the author has been fighting Go instead of going with its conventions and ways. It is all very subjective anyway. Many of us successfully write software even with all these “ugly” features. 
I want to avoid having to audit the whole code-base. My plan is to be like "hey, these guys are also using it, so it must be ok"
&gt; Again, nothing to to do with any language change. We're not discussing the language though, we're discussing the *go version*. Ie, the binary. If the binary changes from 1.9 to 1.10, and breaks your build - you best believe it matters. I'm not blaming Go, Go did the *correct thing*. That doesn't change the fact that your build changes from one version to the next.
https://gobyexample.com/spawning-processes Call ffmpeg with the parameters you need for thumbnail generation, write your byte stream to ffmpeg's stdin pipe, grab the thumbnail as byte stream from stdout pipe. 
But, if you read the place we started from, difference in flags were brought up. This was not a difference in flags, or a language change, or anything, nor does it address my question on why would the tool help in these cases. 
I wasn't addressing your question, I was replying to someone else, agreeing with them that the Go binary has caused hiccups for me as well between versions. Ie, I can see merit in not just ignoring the version. I was not discussing your argument, nor arguing with you - I wasn't even replying to you.
The [Rosetta Code - Extra credit 1](https://rosettacode.org/wiki/Cartesian_product_of_two_or_more_lists#Go) implementation with Go 1.10.1 vs. yours with Node 9.11.1: ```bash node cartprod.js 16,39s user 0,62s system 102% cpu 16,612 total ./cartprod 2,16s user 0,20s system 118% cpu 1,992 total ``` Go is 7 times faster. If you need to handle arrays/slices of mixed types, the difference will certainly decrease but at the end, it's still a win.
We use https://github.com/3d0c/gmf in production for video processing. It is cgo, so shelling out might be a better option. I have used ffgopeg for an experiment I was doing, https://github.com/colek42/streamingDemo. There is a good script in there for building ffmpeg from source as well.
hehehe
This is a great start, thank you!
Thanks! I'll take a look at NumPy too!
&gt; e2e test provide important validation from the outside e2e tests are fragile and difficult to debug. Even Google stopped using them years ago... https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html &gt; mocking outside services is ~~overrated~~ essential Mocks are an excellent way to test how fragile (or resilient) your program is against its external dependencies: ex. how does the service react when the DB is lagging, or doesn't respond at all? Mocks also make it super easy to get the benefits of e2e testing without the added complexity or difficulty. You can rely on your mock's behavior, instead of having to question it with every test. &gt; test for service failure too So you agree that mocks are essential! Great! There's a lot I can write on just those five words, but I'll simply leave a breadcrumb here. The Art of Software Testing (Glenford Myers) begins by telling us that the purpose of testing is to find failures. Not to document code. Not to verify that code works. (You can't prove the absence of bugs!) But to flush out as many failures as you can. Services fail in many different ways, and Myers provides a great template for planning a comprehensive suite of tests: failure under peak load. Failure under extended volume. Failure by incorrect inputs. Failure from dependent services. etc. etc. Book is free online. It may be old but it's a gold mine of ideas for effective testing.
For Go, one of the things you have the chance to do is optimize farther than even the V8 engine can safely do, because you have some non-trivial control over allocations. See [this example](https://play.golang.org/p/4Myz0fqWhIf), for instance, if you don't need a manifested list of the cartesian product but just need to examine each element in sequence. That is going to be very fast because it should inline (though I didn't check), and does nearly the minimum possible work. (Not quite. But reasonably close.)
if you define your dependencies with ssh instead of http you can also work around this in CI with git config: script: - git config --global url.https://gitlab.mydomain.com/.insteadOf ssh://git@gitlab.mydomain.com/ - [netrc update here] ``` I think this is better because in dev you can use your ssh key. You can of course use ssh in CI but it's much harder than http because you don't get an equivalent of the job token.
You don't need to git to fetch your repository. Your repo is already there. And also if you use "latest" or one of the stretch tags you'll get git. You don't need to build your own image and host it.
Yes I have. https://serifandsemaphore.io/a-cognito-protected-serverless-api-with-golang-in-minutes-a054c9f50cf3 Now this is Serverless which is quite different than your standard go app...but it can highlight just how easy it is to secure a crud api using JWT. To cut to the guts of the matter, there’s two really good Go packages for JWT. https://github.com/dgrijalva/jwt-go https://github.com/lestrrat/go-jwx Then there’s a great sql library I like to use: https://github.com/jmoiron/sqlx You don’t get a lot from Go’s standard library out of the box here, though it does have some great crypto and sql stuff that these packages leverage. Yes. Go is wonderful for what you’re after and SQL -&gt; Go structs -&gt; JSON is a lovely experience.
I second numpy. It's blazing fast and it's based on c&amp;fortran code with a very nice syntax. It would outperform even go.
Thanks for the article. I am in the middle of doing the same thing with my go app and Gitlab CI.
I was literally struggling with this exact thing yesterday. (Go, Gitlab, internal deps)
pic rel https://pbs.twimg.com/media/DalMqfgW4AITDvJ.jpg
I very much specified that you’d use external services as containers, and not mocks. There’s a significant difference in writing tests against mocks or against real services (ie. an actual redis instance or mysql instance). By providing an actual instance of the service you’re testing against, you’ll find real issues, not only issues against a mock implementation of some interface per se. Maybe you’re considering this instance as a mock, but I did quite literally mean a mock implementation of an external service in code. For that, I’d hope, you’d agree that having a mock redis object which isn’t really a redis client doesn’t serve the purpose of actually testing literal connections, commands and behaviour of this service. I think we’re just having a slight misunderstanding as to what constitutes a mock. Hopefully explained better above, and yes, I do agree that there are volumes to be written about possible service failure, and I’ve just added Glenford Myers to my reading list. Thank you for adding more context to what was also my point - external services can be the crux of an implementation (and often are), so it’s very important how one would test this interaction. It shouldn’t be taken lightly.
Haha great name! :)
A question. Are you open to suggestions about interface changes? There's significant verbosity which feels like it's carried through by Java devs writing Go. You would significantly benefit from some changes.
What about Envoy? https://www.envoyproxy.io
What about HAProxy or Nginx?
No reverse tunnelling 