I think we were considering things like sql injection. Or if the server expects specific data from the front end, because the front end app is designed to send it, it should expect that it may receive bogus data because an attacker may modify the data send by the front end. This is why the backend should "sanitize" or at least check the data. 
For quickly sharing a directory over all network interfaces I use a small snippet: [webshare](https://gist.github.com/miku/b5d856ef96a1f78530d8abbeb8f4d13d).
GCP recommends reversing key strings when inserting into datastore/bigtable since it allows for more efficient sharding. Just a real world use case I've seen. 
There is one scenario where you have majority of code in Java (Android application) and already building it with Gradle. You want to add tool in Go or a library in Go. Then it makes sense.
Benchmarks? 
Which is fair, but that's one reference of many. Static type safety is surely nice, but when you can always do checked casts it's not like the lack of static type safety is a general lack of type safety in the same way that you would expect with void pointers in C++.
any comparison between this and bolt - both from performance, as well as, imo just as importantly, general api/stability/ease-of-use?
Thanks! What casual observation, it seems the rpi drivers use non optimal clock calculation. I think it's definitely worth looking at improving the clock selection in the drivers themselves but that's orthogonal to periph.io itself. In the meantime I use an oscilloscope on the signal line and fine tune the speed until I get an appropriate clock rate.
I hope you also want discuss your appreciation of the project. It is licensed under Apache v2.0. It has a pretty good testing story, so contributing does not incur typical guesswork to figure out if anything will break silently. I see a lot of comments about code ownership. Don't worry, nothing obnoxious involved. Every contributors keep their own copyright, and are listed in https://github.com/google/periph/blob/master/AUTHORS Thank for your interest!
&gt; err := someFunc() &gt; if test.err != err { &gt; t.Fatalf("expected err to be %v, but got %v", test.err, err) &gt; } &gt; But even for a basic equality assertion this is unnecessary complex. First of all the author claims that the above code is unnecessarily complex. How can this be? It's an `if` statement and a print message. It's one of the simplest things you can have in programming. Then he goes on to explain why. Let's see what he has to say about it: &gt; * Manually writing the validation error message is tedious. &gt; * 3 lines of code gets verbose quickly if you have many assertions. Apparently, he doesn't like repeating those 3 lines of code and writing the validation messages. Okay. So the first thing he could have done is to write a simple function or a group of functions that abstract the parts that he finds tedious and solve the problem. Let's see what is his proposed solution: &gt; The solution is simple. Start using stretchr/testify! Okay, so the author decided that the best solution is to include a package of almost 10 thousand lines of code to save himself from writing a few functions. I can't possibly imagine what he would have included if he had to write a few structs as well.
Just a little mistake: &gt; I don’t think you can keep a pointer to an element in a slice. You can, otherwise a very nice article :)
Heroku uses the [heroku](https://github.com/heroku/heroku-buildpack-go#example) tag, so add `// +build heroku` to heroku-specific implementation files.
Manually writing the error message _is_ tedious for the common case of checking equality, and `testify/assert` has a lot of nice introspection for things like lists/maps to print a message that identifies exactly what is different. Why would I write my own (likely inferior) helper function, when one already exists in testify? I have better things to do with my time than to write (and debug) unit test helper functions, when an extremely good library already exists for that.
The `if` clause you have would allow `Close()` to be called multiple times if the error returned was `nil`. Depending on the specific code, that may be incorrect. My solution would be to fully wrap the Closer, e.g.: type SafeCloser struct { io.Closer closeErr *error } func (sc *SafeCloser) Close() error { if sc.closeErr != nil { err := sc.Closer.Close() sc.closeErr = &amp;err } return sc.closeErr } By wrapping the Closer, you can then pass it around to other functions outside of your direct control, as well.
The bit about Go's so-called reference types is wrongly interpreted as an idiosyncrasy, but in reality it's consistent with what he should expect as a C++ programmer. If he likes, he could think of a slice as a struct with some header information and a pointer to an array in memory; as such, he should not expect that the *pointee* is copied, but only the *pointer*.
The OP is asking for an in-process persistent queue. ZeroMQ and nanomsg are designed mostly for inter-process communication, and have no persistence mechanism.
I'm joining to this request. At this point they only state that: &gt; High RW Performance Yes Yes No Where "No" is boltDB. Obviously, write performance is not the best when you have a sorted set of keys.
That's the part I wasn't sure of. It's been quite a while since I looked into them, so I wasn't sure.
Are there any benchmarks for the new thread safe map?
Wait, is there a problem with the way I'm currently sharing the static directory ?
Where in the documentation would you like it to be? I work for heroku and can get a doc fix made very quickly.
&gt;I feel like saying interface{} isn't type safe misses the fact that you can always determine the type (it's a bit like RTTI). lol what is a compiler?
Hmm yeah, good point, I guess unlike the example of opening two Closers, I didn't feel like I would ever have that specific need of closing the same Closer twice so I omitted it. But never say never in this biz, eh! Good to know that there's a lightweight way to deal with that situation too. You're quite right though, my solution is not functionally equivalent.
&gt; I will actually consider changing that, however I would say its not security critical, since login is required to write that file anyway. Seriously.. Did you bother reading my post..? I said this for several reasons, first one is because often inexperienced engineers get auth wrong (Which you did, more on that in a moment): &gt; "Finally note ANY file system access, if behind "auth" or not needs to be protected. You should only grant the minimal trust needed to an authenticated user to get them access to the data granted by the app. It's not acceptable to allow a authenticated user to break out of the expected file share." Because I doubt you are okay with giving someone access to your entire server because you want to send them a picture of your cat..? This is a great setup for this little gem: &gt; In the end I trust my chmod the exact same amount I trust the command if it were run on github's servers. You're statement is not true because in this case the "self" is a single individual, verse an entire well funded technology company with a entire team of trained security and systems engineers. Supported by intrusion prevention / detection systems, disciplined patching schedules, auditing mechanisms, resources to fund third party specialists to perform forensics in the event of a compromise, on and on. Do you honestly believe your "chmod" (ugh.. lol) compete with that? These issues you view as minor I view as building blocks to own you. How? Because you disregard my warnings about path traversal due to "auth", and your choice to use your own software and server to distribute the binary I am now able to compose a more sophisticated attack. **First** I know that if I can just get a username and password I can now replace the binary you are distributing by exploiting the path traversal. I can replace the binary with a binary with malicious machine code that will appear much the same. So if you give any friends a user and pass to "test" with, you have to trust not only them- but their security practices, how they manage their credentials, the connection, their machines security, on and on. **What could possibly go wrong, you got auth!**. Speaking of auth- you completely failed. You use this little gem for an [auth token](https://github.com/George3d6/Hermes/blob/master/server/authentication.go#L167) (session id) here via [math/rand](https://github.com/George3d6/Hermes/blob/master/server/authentication.go#L7)'s deterministic psrng. rand.New(rand.NewSource(time.Now().Unix()-time.Now().UnixNano())) Yea. Did you even.. look at it or think about what it does? You are issuing tokens that are sequential moments in time. You later use these session ID's for authentication. Great, now I don't need to even have a valid credential anymore I just need to figure out a time someone you did trust logged in. The precision is nanoseconds- but I have 24 hours based on your token expiration time default. Without any rate limiting bruteforcing will not be a problem. Lets remember since it's only protected by your mighty chmod.. not sophisticated (and expensive) IDS's scrubbing near your edge routers to detect traffic with these characteristics. Anyone between your webserver and a trusted end user will get perfect hints to this, despite https. It can be assumed any of the initial tls negotiations will be a good fuzzy time to start brute forcing the possible moments a session was created. Perhaps with millisecond percision as it's likely the servers time leaks publicly in one way or another. There are countless other ways to narrow the time to guess, from social engineering to.. just digging through your code base to find other issues. Now once I have a session id, game over. I will begin traversing your file system to get my bearing on CWD, begin determining system information, current user, download config files, system patching information, etc. Now your machine is compromised, but the sad thing is it's not just your machine. It's now the system of every single one of your users. But the sucking doesn't stop, because you have no correlation between user sessions for downloads and login handles and emails, threat reaction teams, or even the knowledge that such teams exist.. you will have no way to even notify those users what has happened. You have no way to even try to make it right. The icing on the cake? The second an experienced developer and security engineer took time out of his lunch break to warn you about these issues, it went from ignorance to negligence. Give it five minutes man.
That sounds typical I suppose to most concurrent data structures. I suppose as with most things, I'll have to try it out to get a feel for its performance.
Can you add a comparison using [benchstat](https://godoc.org/golang.org/x/perf/cmd/benchstat)?
you are loved 
What's with the random gilding happening in this thread. All we're taking about is benchmarks. Edit whoa first gilding!
It seems a lot of golds are handing out in other threads too...
&gt; current mutex + map idiom Do you just bundle up a map together with a mutex in a struct, or is there something more to it?
Hi
Came for the gold. But too late. :(
No u
My stance here is that you have to look at security through the prism of the product that you have, if its a friendly file server for acquaintances you can assume they are not malicious. If you have cat pics, books and binaries of fairly unpopular oss on it you can assume someone won't waste hundreds of billions of requests to brute force a session id. And, further more, assuming my linux user schema is ok the only thing malicious users can modify is the files served (intent behavior) and whatever files I considered unimportant enough to give the server's user permission to. The highly unlikely security exploit where you override fs utilities is impossible unless I am running this things as root... ... etc My problem here is not fixing these problem, indeed, now that I am at my computer, I shall get to fixing them right away (as I said in the github thread), but rather, that issues like these will pop up again and again. Few I can think of off the top of my head: -&gt; File are not encrypted on the server -&gt; Server doesn't force https (meaning that security of credential transfer is completely ruined) -&gt; There is no two factor auth (meaning that, if a compromised computer access the server, the info it sends is enough for an attacker to do so) I am quite sure the list can go on and on and on, after all storing and serving files is like an unpainted bikeshed over which you can apply strokes with 10001 colors of security, but at one point I won't be able to implement everything due to paranoia. Security is not a black and white thing and the line at which something is secure is quite subjective.
Probably I don't get the idea of using it and what are pros comparing it to the standard testing package. It's more familiar to ruby devs since it's a clone of rspec. Following this logic there should be golang implementations of testing frameworks for python, java, etc. 
Sort of. Buffered channels (channels that are created with a specified size limit) can be looked at as a queue, however the advantage with using channels is that it gives excellent concurrency and synchronization throughout multiple goroutines. Any write to or read from an unbuffered channel, a write to a full buffered channel, or a read from an empty buffered channel, will block for the calling goroutine until another goroutine is ready on the same channel. In this way, channels can control how and when things happen with multiple goroutines running in parallel. They can also send and receive data between goroutines at critical moments. They can also be used to block routines from continuing before another routine completes. There's probably even a lot more you can do with them that I haven't mentioned here.
Yup - that's exactly it. And Set/Delete/Get methods with mutex locks. 
I saw that you typed a sad face emoticon in your comment, so I just wanted to let you know that I hope you have a wonderful day!
Author here. Every now and then I type "man *somecmd*" only to find that *somecmd* has no man page. This is usually true for Go binaries, especially if installed through `go get`. So I wrote a tool called `goman` that displays an "alternate man page" instead. What `goman` does is: It retrieves the path to the source code from the binary. Then, if the source code includes a README file (and most projects do), `goman` finds this README file (either locally or in the public repository) and displays it on the terminal, with colors. The tool relies heavily on third-party libraries and code, so my kudos goes to those who did all the heavy lifting - from getting a binary to reveal its source code path to rendering Markdown as plain text with ANSI color codes. (See `goman`'s README.md for details.) Talking of ANSI color codes: This might be a problem on Windows that does not support ANSI escape codes before Windows 10 Threashold 2, according to [Wikipedia](https://en.wikipedia.org/wiki/ANSI_escape_code#Windows_and_DOS). Luckily, [this wiki page](https://github.com/rspec/rspec/wiki/Getting-colored-output-working-on-Windows) offers a couple of workarounds. The blog article that the headline links to contains a brief rundown on how `goman` achieves to find and render the readme. The tool itself is available via `go get` [here](https://github.com/christophberger/goman). 
Hi! As I mentioned, I've applied via stack overflow, but still had no reaction eiter negative or positive. Could you please DM me, what's wrong with my appliance? :)
because external dependencies are the source of all evil. Someone will change something in testify and then you'll enter dependency hell. Even if you don't import the changed library on your machine, someone else will when they try to get your project working. And then you'll want something changed to fit with your project. You have a choice at that point: submit a PR to someone else's project and hope it gets accepted, vendor their entire project so you can make the change you need, or rewrite all your tests so they don't depend on someone else's project. By writing your own function you remove dependency. You create exactly the solution you need for your project, you understand exactly how it works and what it depends on, and you can change it whenever you like for whatever reason you need. It's a Go Mantra: lots of repetition is still better than a little dependency
table testing is awesome :) 
Hi, Today we will go over all applicants. Soon you will get a reaction :)
A donation has been made in your name to the Human Fund.
Pardon my ignorance, but what do you mean by checkpointing?
&gt; there's some subtlety missing lol, what is nuance?
&gt; 30000 - 60000 RMB annually good look finding anybody that wants to work for 4.4 - 8.8k USD *annually*. 
Maybe because I'm not from a Ruby background, but what is Rails without Ruby? It's not like we see djangogo. When your web framework starts to spread into other languages, you really know it's virulent.
Playing devils advocate here. Maybe when you see frameworks spread to other languages it is because they are very useful. I think there are lots of Sinatra like frameworks in other languages, even if they aren't called Sinatra.
Code generation is exactly the reason I am not touching RoR with a 10-foot pole. Too much boilerplate. With Django code generation is minimal and completely optional. I always created everything by hand and it was not a chore. `manage` is still useful for running app and migrations but I did not use it to create code. Don't get me wrong, code generation is useful but I do not want it to be a core/main feature without an absolute necessity.
hmmm, when reading the jd in Chinese I thought it 20-40k per month. &gt;中高级全栈开发 20-40K
I wish it could use types natively like a regular map. Since it uses interface{} everywhere you'll need to do type assertions every time you pull something out and want to access it normally (unless you are just passing it to something like the fmt or json packages which due that themselves).
Dunning Kruger in action everyone!
`megacheck` combines `staticcheck`, `gosimple`, and `unused` into one linter that runs faster. It should be mandatory in any Go project. https://github.com/dominikh/go-tools/tree/master/cmd/megacheck
&gt; when you drag and drop a file onto a built go executable does that count as the first parameter as if you were running the program from the commandline? Why don't you write a simple program that prints its arguments, and experiment?
As someone who has just started with Go, what are the advantages of using Gogland compared to for example VSCode?
I tried that when I first started Go just over 6 months ago and it was a pain to get it all setup with the debugger etc.etc. This just works out of the box. In fact it made me buy a JetBrains subscription and I am now using a lot of their other IDEs now too. 
VSCode is much better now, it'll walk you through setting up all of the go tools. All you have to do is click install when it pops up.
After the introduction of `sync.Map` in tip, some use cases in the standard library itself were rewritten to make use of it. Some of this commits have benchmarks: * [reflect: use sync.Map instead of RWMutex for type caches](https://github.com/golang/go/commit/33b92cd6ce) * [encoding/gob: replace RWMutex usage with sync.Map](https://github.com/golang/go/commit/c120e449fb) * [encoding/xml: replace tinfoMap RWMutex with sync.Map](https://github.com/golang/go/commit/eb6adc27d5) * [encoding/json: replace encoderCache RWMutex with a sync.Map](https://github.com/golang/go/commit/d6ce7e4fec) * [net/rpc: use a sync.Map for serviceMap instead of RWMutex](https://github.com/golang/go/commit/ce5263ff8d) * [mime: use sync.Map instead of RWMutex for type lookups](https://github.com/golang/go/commit/e8d7e5d1fa) * [expvar: replace RWMutex usage with sync.Map and atomics](https://github.com/golang/go/commit/fb0fe4277d) * [archive/zip: replace RWMutex with sync.Map](https://github.com/golang/go/commit/34fd5db147) * [expvar: reduce sync.Map overhead for (*Map).Set](https://github.com/golang/go/commit/e9702c0c85) 
As long as you don't need an actual GUI, you can simply drop files onto the executable. The file paths will end up in `os.Args`. The first string is the application itself. You could also use `flag.Parse()` and `flag.Args()` in which case the first string will already be removed. Definitely the better option if you're going to add flags anyway (like *optional* size, output path etc.)
I have never used any JetBrains products, only Visual Studio, VSCode and Sublime Text. What's the sales pitch here? What do I gain?
I think there're really big differences between Ruby and Go as most Gophers know. In general Ruby is flexible and Go is strict. But on the other hand Go is simple designed and Gophers favor a much 'direct' way to make things work. That's just a personal preference. We know Ruby is used more to develop some DSL tools in past years, like Puppet, Chef etc. Ruby is good at making a DSL to do some configuration managing. So I think you can just take Rails as a management tool to develop your Go app. Use it to model your database schema, manage your migrations etc. And with newest Rails 5.1 you even can manage the JavaScript packages you want to import. And GoOnRails is just a Rails generator indeed. It reads the association relations from models and generate mainly CRUD functions on models. It's more helpful and familiar to the Rails developers who want to develop some Go app with the handy Rails tools and Rails-like ORM naming conventions. And you can mix them together, just build some Go APIs in a Rails app for performance, or use the gems like rails_admin and Devise to make a database admin console for a Go API easily and quickly in just several minutes. I'm afraid maybe Go is lack of suck packages as I know. And Go can use JWT token to authenticate with the Rails user system. 
Yes!
Next project: A command named "nasai". - - - Edit: For the records, the deleted comment two levels up said, "Goman nasai".
good keyboard shortcuts (chords are a pain in visual studio) great refactoring amazing plugin support, and a bunch of ethereal qualities, hard to explain developing in it just feels good. I never had that feeling in my c# visual studio days. In fact all the c# developers I know use ReSharper to make VS act like intellij, download the EAP and give it a go, its free right now
You can use IntelliJ Ultimate which probably would allow you to have a single IDE for all of the language you might want (with a small couple of exceptions, depending on needs). I'd be interested to know what would you think can be improved to IntelliJ / Gogland.
Is mid-stack inlining in this release? https://docs.google.com/presentation/d/1Wcblp3jpfeKwA0Y4FOmj63PW52M_qmNqlQkNaLj0P5o/edit
This is a fun project that you could undertake. It's not that complicated and like others said you could utilize some messaging queue system like rabbitmq (or others) for it.
Very promising!
Exactly.
God I hope they change that name.
No, not promises too, please!
And they should be!
Yes, but behind a flag. Explicitly not supported for production use. https://github.com/golang/go/issues/19348
I've always been a fan of IntelliGo, short, familiar, rolls off the tongue. Isn't slang for nuts (and not the kind gophers eat), best of all, it's possible to pronounce it. Really anything would be a better name than Gogland.
Depends who you ask :) https://en.wikipedia.org/wiki/Gogland -&gt; makes an excellent pun on the fact that Kotlin is also created by JetBrains and it's a programming language (and some parts of the IDE are written in Kotlin)... :D
I think you mean [std::promise](http://en.cppreference.com/w/cpp/thread/promise)
Gogland is not a "text editor" it is a full featured IDE based on the powerfull IntelliJ base, vscode people will never understand
This is a collection of resources that I generally recommend to people starting out with programming/webdev/go or whatever else. I usually try to give a shorter version based on what they need, but figured it would be easiest to publish as a big mega-list. I'm happy to add other resources if others can vouch for them. It is sometimes hard to evaluate a beginner-oriented resources when I already know the material being covered.
Magento is its own beast. I'm coming at Go from Laravel (PHP) and Python, and while the newness of Go still feels awesome, I'm in Laravel every day, and it's not that bad at all.
No, it's pronounced gogland (as a single word, not go glad or otherwise).
You really worked hard for that gold m8
.Thank you! :)
Poor guy, the bar was set so low and you didn't make it ;)
No I know what an IDE is. I just feel like I can get a better experience on VSCode for free. No disrespect to IntelliJ though. That's just my opinion 
Yea of all the frameworks I played with Laravel was my favorite (as far as PHP is concerned) but the whole magento using xml to wire in classes thing and give super vague terrible errors when anything is wrong thing is terrible and anytime you print_r something it goes into recursive hell lol oh and all the modules you download are also written like garbage, that doesnt help.... /rant laravel is nice though :P
Why not use bcrypt? import ( "golang.org/x/crypto/bcrypt" ) func HashPass(pass []byte) ([]byte, error) { pass, err := bcrypt.GenerateFromPassword(pass, 10) if err != nil { return nil, err } return pass, nil } func CheckPassHash(hash, pass []byte) error { return bcrypt.CompareHashAndPassword(hash, pass) }
Didn't really look into it to be honest. The cheat sheet more or less lists it as kind of a last resort if the other methods aren't available. pbkdf2 was the first from that list (top to bottom) that was available in go without cgo. Will look into it tomorrow if I can't get pbkdf2 to work until then. I kind of want to know what I'm doing wrong in my current implementation though.
It appears that hashPassword is altering the value of hash on line 42 ensuring that they're always equal. https://play.golang.org/p/jyC_jmkK_P
Just my luck
Nothing much, gold is simply falling from the sky, s'all =b
I have used `bcrypt` in several of my small projects and it works wonderfully, it's very easy to use too. I would suggest that you use functions like these if you're not sure about password hashing etc.
sorry about the mistake😄 
Thank you😄 
What's with all the gold?
I'm not sure why the OWASP recommendation appears to be PBKDF2 but I strongly recommend bcrypt. [This guy](https://security.stackexchange.com/questions/4781/do-any-security-experts-recommend-bcrypt-for-password-storage) says it better than I could. Bcrypt has a number of advantages and has great support in Go. Edit: After looking at your code I would quadruple my recommendation. You should not implement you're own equality code for cryptography. The Bcrypt library handles that for you.
The main reason I prefer the JetBrains IDEs are the amazing refactoring tools. Extractions (method, field, etc depending on the language), moves... VSCode just has rename, and it's not even that great.
One of the motivations is to make code more explicit, readable and narrowly scoped. Without the explicit initializer, the only way to scope a variable to an if block is if the type provides a bool conversion operator *and* that operator provides the semantics you want. The other options are excessive braces, overbroad scopes, or one-off wrappers with the desired bool semantics, none of which are particularly readable. Combined with destructing bind, we get a substantial readability improvement when dealing with `std::map` and other APIs that make extensive use of `std::pair`.
It's actually for simpler reasons. They produce a bad user experience. JetBrains IDEs implement their own linters, parsers, formatters and so on not because the political reasons but because they work in memory whereas everything else needs to work on saved files. That's how the IDE can tell you something's wrong/fixed as soon as you type it rather than have you to save the file every so often. Also in order to provide the quick fixes and all other refactoring options they need to have that implemented in their IDE.
This is a great list of resources. 'The GO Programming Language' book is great. I also used Todd's Udemy course for an introduction into go. But the best resource by far has to be Jon's course 'Web Development with Go'. I am in chapter 7 at the moment. The instruction is clear and the pacing is easy to follow. Jon's practical style of working on a single project through the course has been the best way for me to learn. If you want to get into web development using go then it needs to be at the top of your list. Thank you Jon for all the hard work you have put into it. 
That's embarrassing. The link has been added now.
Thank you!
You're right! 9nut gave a great explanation if you're interested.
Do you have a sample that xan reproduce the issue? What commands does vscode run to get the debugger to work? Which Go version are you using?
Nested packages are not allowed. Packages are one layer. Yes, you can "nest" packages in the file system but that's not "nested packages" (or sub packages in other words)
Yup same here. Go 1.8 and latest vscode-go with the delve which the extension installed for me
I've worked with PHP for over a decade now and I've really fallen back in love with the language in the last three years or so. The ecosystem around the language, especially when it comes to tooling with `composer`, PHPUnit/CodeCeption/Dusk, static analysers, Blackie, etc, is some of the best in class (partly because a lot was learnt from the mistakes of other languages that modernised earlier. The majority of my work now is with Laravel and Symfony, but I still maintain a handful of relatively large Magento sites and it's just woeful by comparison, Magento 2.0 improved the architecture somewhat but brought in a whole host of its own in problems. PHP and Go (with a bit of JS) cover the vast majority of code I need to write and do so with an appropriate level of stability and readability, so I'm sticking with them for the foreseeable future, but will celebrate heavily the day I no longer havr to babysit Magento.
&gt; In most languages, one can write: &gt; assertEqual(expected, obtained) &gt; And that will do the work of the 3 lines above. So compared to that, it can be considered more complex, because it introduces a lot of repetitiveness which leads to strain when reading, as well as mistakes when writing. The question is, is it worth importing 10 thousand lines code to avoid writing 10 lines? Also please read [this](https://golang.org/doc/faq#testing_framework).
Wow, someone gilded this bot?
Yes, it's a good suggestion, however in order to implement the use of real lego palette the core algorithm should be changed a little bit, specifically to map each lego block to a specific color, but at the same time to preserve the recognition of the original image. But because in the first step i reduce the number of colors of the generated image, it can be reduced to the maximum number of colors of the lego palette. But above this another algorithm should be implemented to differentiate the lego sections. So to sum up it's possible, but needs a lot of work.
The author says that java has nested packages too, however. It doesn't based on your definition. I think the author doesn't understand the GOPATH.
delve like most debuggers has *step over* and *step into* commands. next (alias: n) ------------- Step over to next source line. step (alias: s) ------------- Single step through program. I suspect what you are seeing is the *step into* command being called when you want the *step over* command.
I wish the author wouldn't use new(). It's semi-ironic that coming from C++ someone would complain about Go's declarations. Every large C++ project I've worked on has had compile time issues due to headers, either through poor header management, or the built in issue that headers leak information about private implementations unless you use pimpl or some other idiom to fix it. 
Shout out to /u/sbuss for all his hard work!
Since most other problems are solved; do not use bytes.Equal to compare hashes, like ever, as a general rule you should be using a constant time compare to check if you compare hashes in a security context.
We will finally be released from the curse of golang.org/x/net/context.
I generally like https://www.techempower.com/benchmarks/ since the benchmarks are well defined. However, I don't think that this article makes a case for much, other than that there are faster (and potentially operationally more efficient) languages out there, which is a measure that differs in importance depending on what your costs and load are. There's a whole load of stuff that makes me believe that Javascript is a terribly designed language, but it's popular regardless, you can find a whole load developers who know how to use it. It will only "die in a fire" when there's a compelling reason for the people who are perfectly happy and productive with it to move away from it, since there's an inherent adoption curve and cost to any alternative. At least part of that mathematics is when it stops being the only available language for a massive number of programmers who need to create the front end of websites, which I only think might happen when webassembly takes off (Google's Dart seemed faster and better designed, but didn't take off that much).
[removed]
Seems nice, but it's not working on Windows. $ man &lt;executable&gt; &lt;executable&gt;: command not found
I have an article on [cleaning up bash customizations](http://meta.ath0.com/2007/10/23/cleaning-up-bash-customizations/), because the shell's default behavior really isn't useful for modern systems.
Sorry to hear that. Unfortunately I have no Windows around for testing the tool. Are you using a Unix shell on Windows? (The prompt sign `$` indicates that, as well as the fact that you use `man` (a Unix tool).) What happens if you invoke `goman` directly, instead of `man` (which I suppose is the shell script from the README)? Is `&lt;executable&gt;` in your Windows `%PATH%` and/or in your shell's `$PATH`? (Does it run when called directly)? 
Sorry, that was a typo. I was trying to invoke `goman` directly, not `man`. I first tried on Git Bash (this explains the `$`), but just tried in `cmd` with the same result. Yes, the executable are in PATH and work when invoked.
Guess I need to check the `which` library I am using to find the binary. Maybe it wasn't made for Windows. (Although at a first glance, I see no os specific code in it...)
I've been learning Golang as a Node developer and wrote a blog post about how refreshing Go was to use compared to some of the nastiness of Node. However I don't want Node to go away, Node is beautiful depending on the use case. It'd be the first language I'd look to to prototype something, to write a beautiful, dynamic UI or even a simple script. I wouldn't write a performant API using it but Node still has it's uses, just like Go has it's own.
I don't know if that is the problem, but maybe you should take a look if the [`os/exec.LookPath`](https://golang.org/pkg/os/exec/#LookPath) don't already solves this problem.
Repeating what I sent to the mailing list: I was wondering if anybody would notice it on the release notes! Feel free to start using it by setting `api_version: go1.8` in your app.yaml. Note that this won't ship with gcloud until next week, and the official announcement email will be next week or the week after. Normally I'd wait and release everything at the same time, but I *really* wanted to get this in your hands asap. If you're already using gcloud, then I'd advise waiting until the new Go component ships next week. If not, the "original" SDK for Go is still available on our SDK downloads page at https://cloud.google.com/appengine/docs/standard/go/download. Just click "Or, you can download the original App Engine SDK for Go." at the bottom of the page and you can download the new SDK zips. Please start playing around and let me know if you run into problems! Keep in mind that this is a Beta launch that you have to explicitly opt-in to by setting `api_version: go1.8`, so there may very well be problems. Using `api_version: go1` or `api_version: go1.6` will keep you on the older toolchain for now. This was a long slog with a bunch of work from many teams, but I'd like to thank Adam Tanner (adamtanner@google.com), in particular, for all of his hard work before I got here, and for all the help he gave as this project transitioned to me. Happy hacking
Loved your book, will be digging into this chapter very soon! Thank you so much for your work!
Correct, but there have been talks in the past about how changes to the Go run-time could be made to allow for GOMAXPROCs &gt; 1. I was curious if those other changes happened in between Go 1.6 and 1.9.
Hmm, I wasn't aware of this. It would be nice to have it.
&gt; Sure, why not. It's not like it's going to hurt you in any way. It's totally unnecessary to import a 10 thousand lines project when you can get the job done by writing 10 lines. Not only you add an extra dependency, you add extra complexity and could possibly alienate the future readers. But the most important reason is the attitude. Go has excellent build-in mechanisms for testing. Not only you refuse to use them (because why not), you also refuse to construct the things you need aka those few functions (because why not). With this attitude you will keep adding needless dependencies in your project (because why not). You'll keep increasing compile times over time, you'll keep increasing the time the rest of the go tooling needs to do its job, you'll keep making the project more complex and ultimately harder to maintain. Also please read [this](https://golang.org/doc/faq#testing_framework).
Please read: [Go at Google](https://talks.golang.org/2012/splash.article). It has all the answers you seek.
&gt;That's a lot of excitement for a fairly basic thread-safe queue :) All these features have already been available in various programming languages for a while now. How easy do other languages make it to select and execute a send or receive across a handful of queues when the next queue is available for communication? Or being able to "disable" queues by making them null, or detect a closed queue by multiple receivers without having to send enough sentinel values? 
Looks like this is a golden thread. 
&gt; The package name should match the file’s directory name. This is how the import statements find the packages’ files. I don't believe this is correct. Naming the package the same as the directory is more just a good practice. It helps make it obvious when you import a package that the package identifier will be the same as the directory. https://golang.org/doc/effective_go.html#package-names "Another convention is that the package name is the base name of its source directory;" 
If that's your whole code, your problem is probably that there's nothing blocking in the main thread. Goroutines terminate when the main thread does, which it will because it has nothing to do after launching the goroutines.
[This](https://youtu.be/f6kdp27TYZs?t=456) will explain everything. main() does not wait for all goroutines to finish before exiting the program.
This guy doesn't know what he's talking about. He's made huge errors in both part 1 and this part.
Yeah, it's a pity. And /u/Redundancy_'s project looks more comprehensive. Regarding why not to shell out to rsync, here are the reasons: 1. The data transmission is between a non-PC device and a PC (mostly Windows). Rsync is not installed by default on either side. If I resort to rsync + my program, I have to ship at least two binaries, instead of one, on both sides. Let alone setting up a rsync server on Windows is not an option in my use case. 2. The transport layer is not necessary TCP. It can be UART, USB(ACM/CDC), Bluetooth, and so on. AFAIK, rsync doesn't support that. The program I wrote also requires end-to-end file encryption, so vanilla rsync doesn't suffice.
Heh, time for me to shine on Reddit :p My home backup system is like ghetto version of Dropbox, I built it just for fun. I created a Go daemon using [fsnotify](https://github.com/fsnotify/fsnotify). It watches a certain directory, when it sees a new file, perform upload to S3 and delete the local copy after verifying the checksum on S3. So you could do the same thing, watch a certain directory, do some work when new files are dropped to a directory.
That sounds like a fun project to mess around with. Unfortunately I am looking for a way to make it super easy for end users to process files. Does your dropbox do any updated syncing? Could be an interesting next step. 
Despite the project, I typically try and avoid block based methods these days. It's far more efficient to have a working understanding of the individual units of change that go into the files you want to update, and simpler and easier to scale delivering them individually using HTTP 1.0 and a CDN.
Yes, and Go will "scale" (what does that mean?) better than Python+Django, especially when you follow Go idioms. If all you're doing is a simple website that "pulls data from a database" you might not even need an actual database at all. And benchmarks are probably an over-optimization for such a task. Go's standard template package is one of the best I've ever used, frankly. Spend a week and learn how to write a simple app in Go. Totally worth it.
I guess I meant to ask does Go have load balancing for multiple servers or would I have to do that another way (for future projects) I must have misinterpreted the template engine if it's that good xD
Thank you for sharing this! EDIT: Holy crap, Go looks amazing from that case study. Microsecond response time LOL
There are Go load balancer like https://github.com/containous/traefik but I just use NGINX to do load balancing. 
Yup, it's awesome. I have recoded my huge application is much smaller and it's 10x faster. I moved from a $300/m server to a $40/m server.
Yes, Check out this link http://nginx.org/en/docs/http/load_balancing.html. On to of that I use supervisord to run multiple processes with different port
My entire [personal website](https://dmitri.shuralyov.com/) is written in Go, and I absolutely have a blast both [developing and maintaining](https://github.com/shurcooL/home/commits/master) it. &gt; If all you're doing is a simple website that "pulls data from a database" you might not even need an actual database at all. I agree with what /u/mwholt said there. Not having a database goes a long way to reduce complexity and bring joy. Even though I have a bunch of dynamic content on my site (reactions, comments, etc.), they're all stored simply on disk. If I ever need to scale up for performance, all I have to do is implement the same service interfaces with a database-backed implementation.
I was going to suggest a dithering algorithm like Floyd-Steinberg. I thought I'd do a quick google search to see if anyone has already implemented it in go, and I found this nice little [project](https://github.com/esimov/dithergo) which I'm guessing you've already seen since you're the author.
I see, that make alot of sense :) Thanks
Node.JS to Go "convert" here, it took a surprisingly short time (6 days besides full-time job) to get a decent understanding of the language. What really sold me on Go was downloading gitea for mips architecture just to see how it ran on a linux-based Ubiquity router after scp-ing the executable. After node.js eating my little VPS' RAM like a champ, that means something to me. A thing I don't like is that Go source code seems to couple itself to the repository it's hosted at, especially when subfolders' packets are involved. I know, `sed` or `gomove` would do the job, but still, local paths like with node's require would have been great. There's probably a good underlying runtime reason that's not allowed though, even if I don't agree with it. Edit: phrasing
I disagree with everyone here. Go is a great tool for command line apps and network servers, but I don't think it is a strong choice for websites. There is too much boilerplate. You'll spend your time doing things that would not be necessary in a language like Python, Ruby or Elixir and its highly unlikely you'll ever need the speed of Go. I'd rather use Elixir with Phoenix. Its far more maintainable imo and about just as fast. See more discussion on this very topic here https://www.reddit.com/r/golang/comments/53cv73/a_real_world_example_of_a_large_go_web_app_for/d7sf6r3/
It's not a runtime question, it's an actual instance limitation. The largest instance still only has one cpu, making GOMAXPROCS irrelevant. 
dlv 1.0.0-rc1 Go 1.8.3 VS Code 1.13.1 VS Code Go plugin 0.6.62 I am not sure the command VS Code uses. It isn't publicly view-able.
See the book Programming Pearls where Jon Bentley discusses the efficient implementation of moving text in a text editor/word processor. The algorithm uses reverse three times, and is quite efficient: requires zero memory allocation and is linear in time. A quick search turned up this blog illustrating it... https://prakhar.me/articles/the-string-rotation-problem/ in short, if prime or ' denotes reverse: AB =&gt; abc defghi A'B =&gt; cba defghi A'B' =&gt; cba ihgfed (A'B')' =&gt; BA =&gt; defghi abc
Went in skeptical but at a first read looks pretty cool! Will have to try it out sometime. 
From my brief look, I strongly disagree. That code is very very hard for me to read and looks very annoying to maintain. A mistake in templates should be reported because you would be compiling them upon startup. Even then, for me, I don't think the tradeoff here is worth it. But I wouldn't use Go for a web app in the first place.
Go on GAE Standard is very nice when you want to focus mostly on the app/service. Now that Go 1.8 is available I have no excuse not to get my apps back onto GAE again :) Exciting times!
Sorry, I didn't mean your PR. I was talking about the file I linked to. I would use Elixir with Phoenix instead of Go for a web app. I find elixir more expressive and easier to read along with having a much stronger concurrency model (though way more complicated and involved, I've read 3 or 4 books on erlang/elixir and I still feel a bit lost). Unfortunately, the only web apps I have written in Elixir are private and I cannot share the code. Here is a decently involved phoenix project you can look at https://github.com/authentic-pixels/ex-shop The templates are in https://github.com/authentic-pixels/ex-shop/tree/master/web/templates and written in embedded elixir (very, very similar to embedded ruby except with elixir). And here are some docs on templates http://www.phoenixframework.org/docs/templates I have read about people who say templating doesn't matter though, and write a javascript client in react that parses JSON out of the server and renders client side. I've never tried this but Go might be very well suitable but I would still stay with elixir because of ecto, code reloading, better concurrency etc.
Since you asked for specifics though, I find this part extremely hard to read https://github.com/shurcooL/home/blob/51da532f91cf3eeb7c3fcaebbaecb6411b77b7e6/blog/render.go#L55-L177
&gt; or the built in issue that headers leak information about private implementations But if they don't, and hide everything behind faux interfaces, tracing a complex program becomes really difficult. At least, that's how it was 5 years ago. Idk if the IDEs have improved a lot since then.
A little background: the app is heavily optimized, but it's running on embedded hardware (arm, 500MHz, single core). There are about 5-10 goroutines, and two timers (one generator at 250microseconds (4kHz), one consumer at 250ms). The communication between them is over a slice+mutex, with the generator writing to it every 100 samples (25ms, 40 mutex locks per second, something like this): for _ = range r.ticker.C { r.Generate3(sample) buffer = append(buffer, r.EncodeSample1B(sample)) if len(buffer) &gt; 100 { queue.Lock() queue.Items = append(queue.Items, buffer...) buffer = buffer[:0] queue.Unlock() } } The consumer queue similarly, locks the struct and then empties the Items slice every 250ms (4 locks per second). Overall this method was chosen because it gives a performance advantage over sending each sample over a buffered channel. The pprof data for the flame graph was collected over a http endpoint. My logic: since the hardware this is running at is very low-end, the goroutines take a lot of time to do context switching between them. I could improve the overall performance, if I could reduce the number of goroutines that are running at any given time. True/false? Does a "paused" goroutine still take time for the context switch (ie, a goroutine which might contain `&lt;-chan` and is waiting for data? Would you prefer to spin up new goroutines in such a case (4-25 goroutines/second, all short lived), or would you try to keep long running goroutines and communicate with them over channels? How would you approach additional optimisation to increase the rate at which the generator can produce data for the consumer, ie, to lower CPU usage at the current rate? Edit: [here's the actual flame graph svg](https://scene-si.org/images/temp/profile_cpu.torch.svg) Edit 2: This are a few pprof lines from the optimized output: (pprof) top10 1440ms of 1710ms total (84.21%) Showing top 10 nodes out of 76 (cum &gt;= 20ms) flat flat% sum% cum cum% 970ms 56.73% 56.73% 970ms 56.73% runtime.futex 160ms 9.36% 66.08% 160ms 9.36% runtime.usleep And this is a few lines from the older flamegraph: (pprof) top10 14480ms of 16820ms total (86.09%) Dropped 44 nodes (cum &lt;= 84.10ms) Showing top 10 nodes out of 54 (cum &gt;= 8690ms) flat flat% sum% cum cum% 11330ms 67.36% 67.36% 11330ms 67.36% runtime.futex 1190ms 7.07% 74.44% 1190ms 7.07% runtime.usleep So, basically same distribution of top10 calls, but the total time is what differs a lot, really by a factor of 10. The pprof interval for collecting the data was 30 seconds in both cases. TIL: If you're doing Tickers or something that works with time.Sleep, you're going to have a significant CPU impact when you're dealing with really short intervals (like less than 1ms). The flame graph from the optimized version is [here](https://scene-si.org/images/temp/profile_cpu_optimized.torch.svg). No notable differences, aside from the fact that I got rid of the tickers themselves and some associated overhead regarding the ticker.C channel.
Where's loops or modules?
Out of interest do you have a link to the blog post you can share? I'm in two minds at the moment as to whether look into Go or NodeJS, or something else entirely.
It's a great myth that Google is designing Go to fit their needs. It's actually also a myth that Go is a Google product. It's not, Go was created by three guys who just happened to work at Google. Later, a whole open source community joined them. Go is a truly general purpose language. All it lacks is rich libraries for tasks other than servers. However, we need to take into account, that Go is a young language and developing mature libraries takes a lot of time. Languages that posses plenty of libraries for a wide range of different tasks are usually the languages that have been around for a long time. However, there is a lot of effort. Me and other guys are creating graphics/game libraries, such as Pixel, Ebiten or Engo. There's the Shiny GUI project. Other GUI projects will soon or later appear. So, as time progresses, Go will have just as many high quality libraries as any other language, we just need to wait a bit. Or contribute to make it faster ;)
Could you please tell us what the axes labels and units are? (I'm not used to looking at flame-graphs and I'm interested in following along)
Excellent book, thanks! It would be perfect if there was a system for macro expansion this way in Go
@fairface Feel free to share your project links, seems very interesting! ;)
I'd never considered this but this would be an awesome improvement over the manual mutexes
Alright, here they are: * Pixel (my library): https://github.com/faiface/pixel * Ebiten (another nice game library, not mine): https://github.com/hajimehoshi/ebiten * Engo (has most stars, but I don't really like it, not mine): https://github.com/EngoEngine/engo * Shiny: https://godoc.org/golang.org/x/exp/shiny
I looked at the graph and formed the opinion before reading your background. After reading your background, I think I still agree with myself. :) To me that flame graph says that a whole lot of context switching and waiting on locks is going on and not a lot of work is going on. time.Ticker is implemented using channels, so that explains why time.sendTime eventually ends up spending lots of time in futex. Another thing to think about: the raw data for the flame graph is samples taken by the profiler. The goroutine that wakes up and takes the samples will detect the same program counter address each time for one of the other goroutines that is blocked on a system call (futex, for example). So a wide stack of stuff that terminates in a blocking call will appear to be consuming CPU, when actually it is not. What do you observe in terms of CPU time? I would expect if you watched this thing running with top that it would have much less than 100% CPU usage, because it is spending lots and lots of time in futex due to waiting for the next sample time. What is the problem you are trying to solve? If the system appears to be working correctly, but the flame graph is making you nervous, there's an easy fix: don't look at the flame graph. :) -jeff
Well, you're correct on the time.Ticker comment in regards to channels. Unfortunately it also seems that time.Sleep is using futexes (ie, time.Sleep spends something like 80-90% time in futex), and not some underlying channel send/recieve mechanism (or at least not only). I did just remove the Tickers and resort to a loop+time.Sleep anyway to eliminate channel overhead. CPU use unfortunately is about 60-70% (slightly less on amd64, about 40-45% average), and changing this doesn't have any measurable impact... I'm trying to reduce the CPU usage. Flame graphs are a visualisation of where the time is being spent. Sure, it might be a misleading one (sampling), but the generator itself is well benchmarked and can generate samples in the millions. Would you suggest some other approach? (increasing the sample rate, or using tracing instead?). Any suggestions welcome :) Edit: since I have a time based generator, I could modify the loop so I invoke sleep much less. Invoking it once every 250ns was taking the CPU time, so I now do it once about every 4ms (16 samples). My best explanation for this is that time.Sleep is a bit goroutine friendly, but in high frequency causes CPU load. I'll file this under "TIL" :D Edit 2: CPU load dropped from 40% on amd64 to about 8% (which is not bad :)), I still have to test it on arm hardware.
Thanks. That's a pretty large selection. It's pretty much all of the code to render the entire blog page, everything but the header on top. There are some parts that are unnecessarily complex and can be improved over time (like having to parse output of blackfriday into HTML nodes, just to render them again), but that'll be done later on because it's not a high priority.
Thanks for the info.
I haven't tried that. I've only used the templates in Go standard library. From the description, it sounds appealing: &gt; It works by transpiling templates into pure Go and including them at compile time. These templates are light wrappers around the Go language itself. I'll consider it in the future. Thanks.
youtube-dl has support for hundreds of websites. It would be a huge amount of work for no real benefit
I believe Go has applicability well beyond servers. I used it recently for a make project using raspberry pi and arduinos. It was my first move into the make space and I found the language was completely in harmony with getting out of my way allowing me to learn about a completely new technology without creating tooling complexity, integration challenges etc. No other languages i have used allow that style of skills portability. For those that adopt go I am convinced by this experience there will be as large payoff, even for domains outside of the stereotype of backends. Other environments I am familiar with include C++ Java Python C#. I got into the world of Go after getting a role using it, I was also considering jobs using Rust.
Then don't use QEMU as usermode but boot up a linux arm distribution on it and you'll be good to go !
Structurally, you might consider a single goroutine that is publishing clock signals into a timer, and a second goroutine that selects on the channel, either executing generator code or consumer code based on the timer event type. Because only one goroutine can execute the generator and consumer, no locking is required for the buffer. Edit - sample code: const ( GENERATE = iota CONSUME ) func eventSource(ch chan int) { for { // Generate and consume every 250 milliseconds time.Sleep(250 * time.Millisecond) ch &lt;- GENERATE ch &lt;- CONSUME } } func main() { ch := make(chan int) go eventSource(ch) for ev := range ch { switch ev { case GENERATE: // Generate some data into a local variable case CONSUME: // Consume the local variable -- note, no locking of the local variable is required } } close(ch) // Will never get here } 
What is the output of `goman -v goman`?
Nothing in fact. Just that this is not the first attempt to make Qt (or GTK) binding in Go (look at https://github.com/avelino/awesome-go#gui and all tentatives that are today, unmaintained). And this kind of initiatives tends to be unmaintained after the first years for all the other I found… I just have cons against CGo, not against a proper binding of a library written in another language. I'm playing with this binding actually, and I expect it will survive in the coming years. If my skills were more polished, I will gladly try to contribute. But I'm more confident in the serverside programming for now.
Yup, I expect that Go will have a niche in embeded and IoT some day. But even if it's not the same world, it's part of "cli/backend" for me AKA not "user-facing apps".
 $ goman -v goman No source path in D:\Go\bin\goman.exe - goman is perhaps no Go binary Main path not found: invalid magic number in record at byte 0x0
Slices are tricky bitches. a := []string{"a","b","c","d","e","f"} b := a[0:3] b[2] = "x" fmt.Println(a) Will result in `[a b x d e f]` [playground](https://play.golang.org/p/vI-Yj2NwHo). This is what I noticed after realizing that sending a slice over a channel would duplicate the output (less obvious in longer running programs with a fast consumer): [playground](https://play.golang.org/p/qNnngcZo5b) - so it seems that it's very much suggested to pass a freshly allocated slice to a channel. Or if you want to have less allocations/overhead, wrap a mutex around a slice as I ultimately did. Yes, this also happens with two buffers [playground](https://play.golang.org/p/XrbCNSuOBr). And yes, also with explicit pointers [playground](https://play.golang.org/p/GQLVtqurKy). I'm probably just as fucked up about this as you might be :) You're getting some concurrency because goroutines are lightweight and run on the same thread. The issue was somewhere else, and a reasonable guess it's a side effect of goroutines. The syscall for time.Sleep was causing CPU issues, since obviously you don't want sleep to pause the complete thread with all goroutines. At least that's the conclusion that I'm taking from this, I may stand corrected if somebody with a deeper knowledge of goroutines wants to correct me :)
I did go with something (exactly) like this for the consumer, just because it spawns one long running goroutine, instead of something like `&lt;-time.After` (which is a lovely replacement for a ticker you never want to cancel). I can't put the thing into a single threaded select like you did, as the consumer might block the generator, very realistically. As such, by using different goroutines, any blocking on the consumer side shouldn't effect the generator.
Should've called it TensorGlow
Including code from github can be insecure? You don't say? Nothing to do with the language.
when webasm becomes popular I imagine you could use it to write frontend code. It already has some similar features that I love in Javascript such as closures and first class functions.
Is it intentional that the menu entry "Idiomatic Go" is a different size to the others?
Been there, done that, got the scars :-)
Not the language, but it actually has a lot to do with the *tooling*. When people do `go get`, they are pulling `HEAD`, which may or may not represent a stable release for a library. Vendoring doesn't address this issue, it merely freezes the library from the time you first retrieved it. If you retrieved a regrettable commit of a library, vendoring actually just doubles-down on the mistake. This weakness is not a universal condition of library repositories. For example, if you upload a perl library to CPAN, it will be subjected to a series of tests automatically, and can be pulled down in the event of a reported vulnerability. `dep` doesn't address the issue either...the Go community needs to rethink this.
I'm always looking for ways to improve my code. The current version is the easiest to maintain/develop for me, it's much better than previous versions. If I can find a way to make it even better, I'll gladly do that. Or if there's a way to make it more readable for others without sacrificing its good properties, that'd be a great change to make.
Check out https://github.com/rylio/ytdl - not fully featured and YouTube only but not a wrapper either.
A fun project isn't directly translating hundreds of different scripts directly from Python to Golang.
My experience with docker cause my laptop bricked, twice. No one would believe me, until someone post a bug report that UEFI ROM can be overwritten (This was happened about two years ago). From my opinion, docker make something simple become not simple; and that's a big no for my philosophy: simple, small, stable, and secure.
I wrote my own version of aria, the download utility. I didn't get all the features but I had fun doing it. Why not let the author assess the difficulties? Why spread so much pessimism? 
It's not the language, it's how it's written with it.
I had some excitement getting all my metadata converted properly, and then more excitement getting the frontmatter changed from YAML to TOML and unnecessary frontmatter removed.
Hmmm, I didn't really have any issues with metadata. I used the Wordpress to hugo exporter tool thing (from command-line) exported it all to ZIP. Just going through manually touching up the generated markdown to make it consistent with the format I'd intend to author posts going forward, and juggling image URIs around. Also making some small aesthetic changes to the theme I chose to use, with a little helper CSS to center image allowing me to just append #center to the image location like: ![image desc](/img/someimage.png#center) Only thing left to do after that is minify and gzip all of it, rip out wordpress, and configure nginx to do all the fancy gzip and caching and so forth. Worth it in my opinion to remove an avenue of vulnerability (Wordpress/PHP) from my personal website.
I haven't needed a router until recently. I really liked goji and notice the API is similar yet more actively managed. Would anyone care to comment how this stacks? edit: for those of you who are using it in production, could you give some sort of sizing as to what production means? What type of load are you seeing?
&gt; You'll spend your time doing things that would not be necessary in a language like Python, Ruby or Elixir Things like ?
Uhm, you're directly contradicting Rob Pike: &gt; Go is a programming language designed by Google to help solve Google's problems [...] From his [Go at Google: Language Design in the Service of Software Engineering](https://talks.golang.org/2012/splash.article) talk. And further: &gt; The Go programming language was conceived in late 2007 as an answer to some of the problems we were seeing developing software infrastructure at Google. Call it a myth all you want, but Go was designed *explicitly* for Google, by Google, and you can see it in a number of the language's design decisions.
I use chi in production and really like it. I have also used Gin in the past, but chi doesn't try to deviate too much from the standard APIs, whereas I felt Gin was trying to recreate the world so to speak. chi is great for people who feel like the standard lib http APIs are pretty good but could just use a little bit more Until chi disappoints me, I will continue using it.
I think that interacting with telnet through spawning a process is just strange. It's not that I haven't done something similar for other problems, but you'd be far better if you could bring that functionality into Go itself. Maybe something like https://github.com/reiver/go-telnet would help with that. Note that https://gist.github.com/anonymous/417de81094d5fcc81bb6fd6be16a9efd#file-gistfile1-txt-L107 potentially exits without closing the device. You could use defer to prevent that if it isn't intentional. 
Thanks a lot, great article. You've convinced me to have a good look at Go!
There's always HTML/CSS/JS + Go backend, all running locally. :-)
&gt; How does vendroring correlates with getting specific version? it doesn't, re-read my comment. &gt; All decent package managers are perfectly able to use anything from semver to tags to branches and even commit hashes. You get exactly the version you want when you using this. explain how you achieve any of this with `go get` &gt; I fail to see how pulling out anything out of publicly available repository is a good idea do you even program in Go? This is exactly what `go get` does
I wrote my food project [BestFoodNearMe](https://bestfoodnearme.com) in Go. I do use nginx as the termination for https, but the webserver is gin, the email and image processing are custom microservices. I use postgresql for the database. previously I had used redis and a customized boltdb.
Too bad they have a huge performance cost
go get was not designed with pinning in mind. It wouldn't be possible given how imports (more specifically import paths) in Go work. Go get is also completely orthogonal to vendoring and pinning. It was always there just to get the repo. Nothing else. If you want pinned library versions you use glide or dep. They are perfectly able to get you the versions you want. Getting applications with pinned libraries is trickier if author didn't supply vendor files. This remains subject to discussion - pinning to GitHub or bitbucket repos is not reliable either, and vendoring libraries takes additional space. The usual package repositories are also not without issues themselves - forking and fixing to name one. Centralization - do you use npm? Governance of said central repository. The hurdles if setting up the corporate one. Pulling out - removing something from publicly available repository. Sorry if I wasn't clear. 
Eh. I was a very long time C++ dev, with much affection for the language, but once Go was published, I fled to it as fast as I could. (Also as I've been gradually learning more and more about horrors of C++ while diving deeper and deeper into the abyss.) I have a feeling that the series is written generally in good faith, but still with significant leaks of subconscious, hard to shake off prejudice. Also, with not enough practical experience with Go on author's side (yet?). So that I wouldn't sound overgeneralizing and unsound, I will try to counter what annoys me as I go reading. Here comes: *"I don't know how people should specify the API of a Go package without providing the implementation"* — use godoc and/or interfaces, depending on what aspect specifically the author meant here. *"I don't think there is any way to enforce correct initialization like a default constructor in C++ or Java"* — ok, one somewhat valid point (though I can't recall ever being troubled by it in practice); however, conversely, it's worth to know, that it has a nonobvious benefit, that you try hard to make your type to be correct when initialized with default zero values, which is especially helpful as a convention for booleans in your struct, so you don't have to wonder if they're default true or false. *"[For methods,] you have to specify a name for the receiver – there is no built-in “self” or “this” [– it] feels like an unnecessary invitation to inconsistency"* — on the contrary, I found it to make things more readable, making it possible to explicitly name the receiver (versus vanilla "this"), and also making refactoring between a method vs. a regular global func trivial. This also sometimes makes it easier to think if maybe some other argument wouldn't be a better fit as the receiver. And I was never really bothered by inconsistency (but it may well be that we do care about consistency in code reviews; anyway, it's good style to name this stuff consistently). *"acceptable to call your method on a null instance [–] I find that undisciplined"* — well, that something is different than in C++ doesn't mean it's worse (i.e. — prejudice). Calling methods on nil pointers and having them return correct values may well be a nice and powerful primitive if used consciously. *"In C++, you can overload operator =, !=, &lt;, &gt;, etc, [...] making your code look tidy"* — but also often hard to understand ("what could author hide behind this operator? what was he thinking?") and surprising (you never know what horrors can be hidden behind every single plain-looking line of code, because someone wanted to [look](http://www.eelis.net/C++/analogliterals.xhtml) smart). *"Symbols (types, functions, variables) that start with an uppercase letter are available from outside the package [...] I find this a bit strange. I prefer explicit [...] keywords in C++ and Java."* — again, prejudice. Not liking something different than already known. Me, I now find it hard to understand why it's not more popular in other languages, and people are forced to write those long keywords each time, and don't see if a method is public or private after just looking at the call site. etc., etc., got bored already and not feeling sense to discuss more, just wanted to show my view that generally most of the opinions in the series are unfortunately poorly based and often miss some valuable benefits. Also please note — it's not like I don't have some frustrations with Go. But they are not those mentioned in the article, and there are absolutely cartloads less of them than in C++. 
Amazing! Thanks for the kind words, I've been loving Go lately, one you get over some caveats, it's great to work with and is just super refreshing to benchmark it compared to my Node server apps.
Who said that? There actually isn't a performance cost with interfaces. The perf cost comes when you handle empty interfaces and treat them as generic values.
The message "invalid magic number in record at byte 0x0" seems to have been reported almost always in the context of Delve. (Says Google The Search Engine.) And almost always the problem was caused by using a package name other than `main` for the file containing `func main()`. But this is definitely not the case here. Right now I see these possible causes: * An old compiler version produces wrong or no symbols * The linker has stripped the symbol table from the binary * Something else has stripped the symbol table Could any of the above apply to your case? (BTW, just recently I have improved the error messages a bit. In case you do another `go get`, don't be surprised if the error messages look different in the new version.)
Last time I checked type switches had negligible, if any performance hit. 
There is a cost - especially when converting primitive types to interfaces. So much allocation! I miss the Go1.4 days where if your data can fit in the interface, it'd be stuffed in.
There is a cost. Methods must be dynamically looked up rather than being statically known at compile time, and they end up boxing their contents. However, this is hardly a "huge" performance cost. If you consider that a "huge" cost them I don't know what you program in, because almost all languages will do some dynamic lookup of some kind at some point. Even Rust and C++ will run out of things they can do at compile time, though they can get father than Go.
Nice algorithm, but you can't use it on strings, they're immutable - and even if they weren't, you wouldn't want to. That algorightm actually has nothing to do with strings, it's about rotating/moving *data*, and the fact that it reverses arrays of *data* as an intermediate step is just an implementation detail, whereas reversing a *string* is simply a concept that doesn't make any sense. Strings are for final human representation (with a few convenience operations thrown in). For any serious text processing you use byte arrays, i.e. you work directly on the underlying data.
I have a source code scanner that identifies your grandmother as a vulnerability to sourceclear.com. Sourceclear.com should buy my vulnerability scanner. The only difference is my product would instrument the source code to mitigate the vulnerability without harming your grandmother. It's an excellent product, you should buy it...when it comes out...it's not out yet...fill in our form and we can notify you when hell freezes over. The sourceclear.com tool makes no suggested corrections for each vulnerability. This a well-veiled attempt at FUD towards Go. Nothing to read here. Move along. 
I have been using gorilla mux+negroni in my stuff. How does this compare with that ?
This. I've used Gin before too, and it feels great at the beginning but later on when you try to use some middlewares or other components (e.g. go-bindata, go.ricebox) with it, it's kinda unwieldy to use since you'll have to wrap those functions into one of Gin's own to use it. Then I switched to chi (when it was v2) and those are non-issue anymore. It's more like using the standard `http` lib, with some helper functions in the `render` package that makes your life easier. Great stuff!
That isn't the case. They still get skipped. Even if I stop and rebuild breakpoints will very frequently skip as if they never exist. Very frequently the program even get stucks and will not execute anything. When variables are collected, if they are, there's always some missing one. It's just not viable debugging with Gogland atm.
I could be missing something, but perhaps there is to much focus on "what" is happening in the program rather than what it is trying to do. You seem to reiterate two things about your generator 1) produces at a constant rate 2) does not need to yield or be burdened by the work of consumers. This means the generator doesn't need a lock, or to append to any buffer or channel at all. If looping to 100 in a for loop, we wouldn't put the values to a queue first, we don't need to here either. We don't need to synchronize because the generator produces values at a constant, fixed rate. There are a lot of ways to implement the concept I'm talking about, but here is an easy to digest illustration of a [lock-free producer &amp; consumer](https://play.golang.org/p/OsQzMVshLp) using a fixed buffer. The main thing to take away here is we aren't locking or allocating anything, just a single atomic increment for the queue head because it's used by the consumer to catch up to the lower constant rate generator. The tail is not accessed atomically because it's only used by the consumer. Obviously you would reset the queue head &amp; tail when tpsMax is reached and do your bounds checks, and ensure the generator doesn't write past the tail if the consumer can't keep up- though it would be better to provide a larger buffer and panic() if for any consumer tick (head-tail)+tps &gt; tpsMax. Anyways maybe this helps, maybe it doesn't! Have a good one.
&gt; So we will be gradually adopting named return values more and more, both for new code as well as for existing code. :((( Are these optimizations impactful to any relevant metric?
You are right that a performance commit should never be made unless the measurements indicate it is a win. But the author did measure the generated code size, and it was a clear win. You are also implying that you don't think code size matters. I agree that this author did not show the evidence that his/her win in code size is a relevant metric for his/her app. However, instruction cache thrashing is a real worry, and with current architectures it is generally true that between two systems doing the same task that the one with lower locality of reference (code or data) will perform worse. In general, I find it good and right that Go has elevated the conversation about efficiency to include discussions like this. In the last generation of programming, we used to say, "well, the computers are so fast, what matters is saving programmer time", resulting in the kinds of inefficiencies you find in the Ruby runtime, or Java GC's long stop the world pauses (when untuned). With Go compiling to native object code, we can actually consider questions like instruct cache thrashing. -jeff
Your example had a bug where you'd use atomic increment in both the generator and consumer. [FTFY](https://play.golang.org/p/m4EQFKotGd). Thanks for a good example of a lock-free handoff, I got the point. :) If I understood you correctly, the max bounds check would need to be implemented in the generator as well as the consumer. The generator needs to reset 'head' back to 0, and the consumer needs to loop to tpsMax then reset tail back to zero so not to skip any data. I extended the example [on playground](https://play.golang.org/p/bnB6wjDzsz) as an exercise. Thoughts/caveats: obviously, you need a large enough buffer so that the consumer will always catch up to the producer. If you reduce tpsMax to let's say 5, the caveat is that the generator will start overwriting it's own samples, and the consumer will stay stuck with no new data. A non-cyclical slice (which has a capacity and is emptied periodically &amp; doesn't incur additional garbage collection penalties) will guard better against this, as data can't be skipped. To detect this, you'd have to keep track of processed samples in each consumer run, or with a slice to just monitor the len() of the slice. With the slice it's easier to recover, if you can just throw away the data if len() is larger than some value. Of course, there's still the price of the mutex there.
The problem is that named return values and especially naked returns have serious costs to comprehension, which the article ignores or breezes over. Specifically, that named return values clutter function signatures where retvals are few and unambiguous, and can hide state in larger functions: func F() (info objectInfo) { if condition { info.field = 123 } // lots of code if errorCondition { return info // I intend this to be zero-valued, but it's not! } info.final = true return info } Naked returns make the problem even worse: func F() (info objectInfo) { // lots of code if condition { return // what am I returning? what state does it have? // the only way to know: parse the entire function! } } Program efficiency and binary size aren't totally meaningless metrics but (IMO here) in most industrial contexts they're orders of magnitude less important than developer comprehensibility. I'll go a step further and say that binary size in and of itself is completely irrelevant in the niches Go tends to target, i.e. deployed server software. So I get really sad when they're used as justification for changes that makes code harder to read, especially when it's an unqualified recommendation like "We'll be making these changes more and more." If you can justify the (real!) improvements as impactful to your application, then by all means. But please don't take this as good default advice. I think it isn't. edit: similar sentiment on HN here https://news.ycombinator.com/item?id=14668538
FWIW there is a bug open now https://github.com/golang/go/issues/20859
&gt; But the author did measure the generated code size, and it was a clear win. In the example they had four returns and saved 176 bytes; minio has about 1690 functions: [~/src/minio](master)% ag --ignore vendor 'func ' | grep -v _test.go | wc -l 1690 So that's 1690*176 = ~290 kilobytes, saved. Not insignificant, but will anyone notice? I doubt it. Certainly doesn't seem worth the effort to rewrite code *just for this*. Even they manage to optimize a whopping 12 returns per function on average it's still only about 1MB, but the Go binary size for minio on my Linux system is: [~/src]% ls -lh ~/go/bin/minio -rwxr-xr-x 1 martin martin 32M Jun 30 09:24 /home/martin/go/bin/minio* So it'll be 31MB instead of 32MB ... Again, I doubt anyone would notice. ---- Maybe my averages are way off here, but I would be surprised if they manage to shave off more than that. If that would be possible, we'd all know about it by now ;-)
Damn, it's just my luck that 'tracing' is not written yet :)
I like named returns and I like efficiency, nice! An argument against named returns is that things become harder to track in longer functions or functions with a lot of branching, but if you're using gometalinter you'll be warned about both of those things anyway, so I don't see the concern there.
[removed]
I know that feeling. However after having used tensorflow everyday for over a year in python I understood a lot of its structure and thus switching language it's just a change of syntax. I think tensorflow is a masterpiece of software engineering, however. Once I started thinking about tensorflow as a descriptive language (exactly like SQL, but with a graph structure) everything became more clear and easy (and in this way the language in which I describe the graph is completely indifferent, but using Go is always a pleasure)
May be Pi is not the best example to illustrate the argument because Pi is a special constant value. It better has the most accurate value and the user should not be allowed to use a down graded value because it may afect the function output and the whole program behavior. 
I agree that it is not the best example, I should probably have used something closer to reality.
Glad to see you take the example and run with it, it should be about as fast as your going to be able to get. You do have the option of using a linked list to peel off pages of work from consumers using unsafe pkg. You would need unsafe so you could atomicly store pointers but you could have an unbound queue size. However I would recommend against that, you should just pick a side to yield. Either the consumer discards samples or generator stops sampling, either would be much simpler to implement and removes the inevitable potential for oom.
Some people indeed have an obsession with standard `net/http`. While standard library is great, it's not a gospel nor is it perfect. It implements minimal functionality required by `go` tooling. Package `log` is case in point. Just look at what kind of libraries people build most and that will tell you which part of standard library is lacking. For small and/or simple projects the choice of library does not matter. Once you start building many projects, you'd want to build your own set of modules, snippets, libraries, whatever. If one of the 3rd party libraries already has it, why not use it? Most of the 3rd party routers are backwards compatible with `net/http`, i.e. they support standard handlers and middleware, albeit with a wrapper typically, and utilize standard `context`to handle timeoouts. Note that passing additional values in standard context is inefficient (extra allocations) and is not its original purpose. That's why some 3rd party libraries build their own context on top of standard one. In fact, I consider the reduced number of memory allocations per request a great feature and strong adherence to `net/http` a non-feature. YMMV. However, having strict standard library compliant 3rd party router is beneficial as a drop-in replacement if you want to migrate code developed against `mux` in standard library to a ore performant router. The new version of `chi` features some interesting routing capabilities. I am not sure I want the router parse URL path span into parts for me. But I can see potential usefulness of this to others.
Go's interfaces are actually a good example of interfaces done the right way around - an interface should be defined by the consumer, not the implementer. I tend to think it's instructive to read about Uncle Bob's Interface Segregation Principle with Go's interfaces in mind (or watch the video for I in SOLID).
That's some real autism
It's not really about disk size tho; if code savings would allow CPU to keep your inner loop completely in cache that can be a huge win for performance
&gt; return info // I intend this to be zero-valued, but it's not! if you "intend" zero value, return zero value. IMO if you want to use naked return as a method to return empty object without having to define it every time, just name it like func F() (emptyObjectInfo objectInfo) the bigger problem I have with it is that it isn't very good for returning `(s someType, err error)` as you either have to reuse same `err` over whole code or do `return nil, someErr` anyway
On that point, even if you have something that can reasonably be expected to change, you shouldn't make it a global value that all functions depend on. This is just asking for race conditions.
[rest 0.7: adaptive cli web client, added support for lua hooks](https://github.com/zan-xhipe/rest)
It really annoys me that somebody came up with this guidance to work around something that's trivial for a compiler to optimize away down the road. They should have filed a bug report and been done with it. I will always choose readability and maintainability over a constant improvement.
I look at these result functions and all I can think is, "Wow, it must be really delightful when you get a zero record back and what to know why your parser has a bug." I really hope these are didactic in nature and not a representation of industry best practice. Why not just declare a record in scope and return that? Why rely on a sneaky little piece of syntax tucked away in the return value? Aren't gophers supposed to be all about a regular language with few surprises?
Posted 2 days ago and it's even at the bottom of the page, if you bothered to scroll down lol.
&gt; 1) Does Go have a chance out of the serverside/cli world? What world would that be? The only one I can think of is "desktop applications" which, let's be honest, is dead-er than dead can be. Then there's what, mobile? That market seems pretty happy with ObjC/Swift/Java for the boring client-side stuff. I'm personally not dying to draw buttons and check-boxes in Go. But most serious apps have a pretty hefty server-side component as well. And *that* can definitely be Go. So I that leaves us with web apps and games. Web apps are all Javascript client-side (and sometimes server-side) but once you're server-side, Go is a great fit as a REST-ful API server for a client app. Games are weird because few people are creating stuff from scratch - you just piggy-back onto Unity or Unreal or whatever and use whatever they use. &gt; 2) Without counting your answer to 1), do you see Go as a server-language or a true general-purposing language? Definitely "server" language, but what interesting new work is *not* server-side? How many Silicon Valley startups have serious "client-side" job openings? &gt;3) Which programming languages and tools do you use outside of the CLI/serverside world? Javascript, Python, C. 
A good editor plugin for Go would allow you to answer your question: &gt; How is config.Pi defined? very, very quickly.
go fmt + go test + go vet is about all you need. Linters are overkill. 
I see the one for version is very used
The demo is nice. Im still learning go so not up to reading your code sample yet. I am curious how well it scales.
Java veteran here. Yeah, it's a bummer not being able to use the nice library in j.u.c.. The way I think about it, golang is best served for small utilities or small-to-medium sized services. Without templated types, golang will always fit these categorizations well, but never much past that.
The first sentence said "inspired by Rails". I left the scene like malware was staging an attack on my pc. 
You should take a look at Google AppEngine. It will handle all the hosting for you.
Flags are good for integration testing (connecting to a real vs. a mock db), as one example.
Your question is too vague to get a useful answer. What's up with all the questions you're spamming /r/golang with? Why can't you put them all into one post? This way we get some idea of what you're trying to do: what are you building, how are you testing it, how are you deploying it, etc. Once we understand this, you can get a better answer.
How much? 0.1%? 1%? 50%? I can imagine that in some cases the differences can be significant, but most of the time it's going to be a lot closer to the 0.1%. More importantly, I think, is that this is the sort of thing that the compiler can (and should) optimize. It seems more useful to me to work on that, instead of converting all your functions to use named return values.
It definitely wouldn't be something worth compromising your code structure over. But definitely something that would be nice that compiler do.
OT: I always enable travis from shell with https://github.com/mattn/goravis
Oh, I like the project (and wish I had more GPIO/I2C things to play with). I just think misleading Reddit submissions are baad, mmkay? Taking away contributor copyrights would be downright hostile. The Google CLA is one step down from hostile: &gt; Grant of Copyright License. Subject to the terms and conditions of this Agreement, You hereby grant to Google and to recipients of software distributed by Google a perpetual, worldwide, non-exclusive, no-charge, royalty-free, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works. I'm sorry but I only like fair deals. If you give me your code under a license, I'll give you my code under the same license.
Have you tried CircleCI? It works (for Go) even without a configuration file, by auto-detecting things.
I think the library that implements a client for some service/database/... should care on errors with that service and translate them into more abstract view for the caller. Also, it is a good practice to provide a way to log detailed errors: for example some Logger interface as a field of library 's client struct.
I recommend you pull back and consider the incredible usefulness of external configuration via environment variables. Good stuff!
This is the one I've iterated to over the years. https://github.com/shurcooL/githubql/blob/e7e57ebcc99dfeeb1c7c82642b47b569a14a6499/.travis.yml#L1-L16
MaxBytesReader is similar to io.LimitReader but is intended for limiting the size of incoming request bodies. In contrast to io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a non-EOF error for a Read beyond the limit, and closes the underlying reader when its Close method is called. MaxBytesReader prevents clients from accidentally or maliciously sending a large request and wasting server resources. If the request Body's size has not already been limited by MaxBytesReader, the size is capped at 10MB. r.Body = http.MaxBytesReader(w, r.Body, 50 * 1024 * 1024) err := r.ParseMultipartForm(5000) if err != nil { log.Println(err) return } file, _, err := r.FormFile("file") if err != nil { log.Println(err) return } defer file.Close()
Thanks! I think you're basically saying to typify the errors, is that right? So instead of returning errors in their "raw" form, User returns from among a set of known errors within its package, that a consumer could identify by reading through its code/tests/documentation. In this case both the "client" and User are more familiar, since they live within the same app/package (a simple web app or api). So it's not a separate library per se, but I can understand if the suggestion is to write it that way (while thinking of the additional code I have to write to make that happen ;).
Upvoted, because this is an article that takes the time to explain some of the ideas behind a pattern of dependency injection, mocking, and testing in Go that many devs (particularly those new to the language) have questions about, discussed here and elsewhere but summarized in one document, and it doesn't cost anything to read.
Just recently I tried to integrate Caddy with systemd. After a few failed attempts, I gave up and wrote a Dockerfile instead. It was surprisingly easy, and now Caddy serves three web sites while running in a container (and I am planning to add more), and I had no issues so far. (Let alone Docker issues that I wrongly attributed to Caddy.) And this gives me nice features like auto restart, easy rebuild when Caddy is updated, etc. But I agree that Docker does add another layer to any deployment&amp;maintenance scenario that in many cases is not necessary, so if someone is not already using Docker for something else, they would not want to add Docker to a scenario "just to have it."
Yo mama is spamming. I have no idea what I have to do that's why I am asking it to real people. I want suggestions on what I should do with my code. But I don't know it yet so I don't know what to ask.
&gt; your assumption that every docker must be run as root - outdated. That's a relief -- can you point me to where I can learn about why this is no longer the case?
I'm of the opinion (and it's an opinion) that errors should be handled where they can be dealt with. So if the user fat-fingers the password, nothing in the system can deal with that, so it needs to be passed back to the user to resolve. If the database blows up, the user cannot deal with that. Only the system can determine if there's a reason it blew up, if there's anything that can be done about that reason. If it can't resolve it, then the error needs to be passed to the sysadmin and the user needs to be told the system is broken (different from passing the user the error). In your situation, if the User service handles its database storage then it needs to handle database errors, because handing those errors back to its consumer is pointless: the consumer can't do anything about them. It's about separation of responsibilities: the User service is responsible for storing the data. If it can't do that it needs to say it can't do it, but only as a last resort. It should deal with the entire process of storing the data, including handling problems.
Why exactly does this need to happen? Couldn't the compiler statically generate different functions for each of the types that implement `FourLegged`?
Thanks. If User lives within the same app/api as its consumer, does that change anything about this approach? I was calling it "service" as distinguished from its store, which is separate as described above to facilitate testing (the DI pattern discussed in this group and elsewhere). In this case there's another entity "Auth" representing the endpoint, but in most cases the object itself (for example "Project" or "Product") will have its own endpoints and be more self-contained. (And in fact User itself will, but that's more for viewing one's profile, versus the authentication scenario, which has no "Auth" data counterpart.) So in this case user isn't really a "service" in the generic sense, separately deployed and monitored, but merely represents the api endpoint and any HTTP processing required before handing off to the store responsible for db interaction. Does that make sense? I'm wondering if that changes anything. Probably not a big deal, but it's always nice to nail down an approach to these things.
You'll probably need encoders/decoders/players for all the audio types you want to support, and those projects are going to be very scattered/outdated. Off the top of my head you should be able to find flac, mp3, wav, and ogg but each one is probably going to be at least one library to incorporate. (I assume you'll be able to google for these but if you want me to link some projects I can dig for what I've gone through) (disclaimer: I am in the middle of developing a project to unify these libraries, the project is not functional enough / stable enough for use right now) As long as you aren't doing intense particle or 3d graphics effects your UI will perform fine, you shouldn't worry about CPU or memory usage. Those are all the questions I can answer!
You can see the setup I've done here - https://github.com/agnivade/funnel/blob/master/.travis.yml
Go doesn't have classic Object Oriented concept of classes and inheritance. Interfaces in Go provide a way to specify the behavior of an object: do like this and reuse it. In Go programming language Interfaces are types that just defines a set of methods (the method set), but these methods do not contain code. This methods is never implemented by the interface type directly. Also an interface cannot contain variables. Go's interface type provides lot of extensible and composability for your Go applications. Interface types express generalizations or abstractions about the behaviors of other types. [Learn more about Interface](http://www.golangprograms.com/go-language/interface.html)
In the last decade, computer hardware has evolved to having many CPU cores and more power. Nowadays we heavily leverage cloud platforms for building and running applications where servers on the cloud have more power. Although modern computers and virtual machine instances on the cloud have more power and many CPU cores, we still can't leverage the power of modern computers using most of the existing programming languages and tools. Concurrency in Go is the ability for functions to run independent of each other. Its (concurrency) mechanisms make it easy to write programs that get the most out of multi core and networked machines, while its novel type system enables flexible and modular program construction. When a function is created as a (goroutine) , it's treated as an independent unit of work that gets scheduled and then executed on an available logical processor. Goroutines are created by calling the Go statement followed by the function or method that you want to run as an autonomous activity. The Go run-time scheduler is a sophisticated piece of software that manages all the goroutines that are created and need processor time. The scheduler sits on top of the operating system, binding operating system's threads to logical processors which, in turn, execute goroutines. The scheduler controls everything related to which goroutines are running on which logical processors at any given time.[What is GO ?](http://www.golangprograms.com/go-language.html)
[removed]
Define errors you care about in the scope of your application code. The application should not know anything about `sql.ErrNoRows`, but it should define `ErrNotFound` or something, which it does care about. The implementation of `User` shall translate `sql.ErrNoRows` to `ErrNotFound`. The same applies for `NullTime`. Encode the notion of a time which can be null / nil in your application. Have the database layer translate that to whatever the database needs.
Yes, same app is not the reason to couple packages when it is not required. You could return some predefined errors, not necessarily different type – like ErrTimeout or ErrBadRequest or something other. Maybe not all of possible errors, but those which caller could react on.
&gt; just name it like `func F() (emptyObjectInfo objectInfo)` That's a very bad idea for exported functions/methods (like your example) as it will show up in the API documentation godoc produces. That documentation is one of the few clear cases where named returns should definitely be used. (E.g. [`func Polar(x complex128) (r, θ float64)`](https://golang.org/pkg/math/cmplx/#Polar)). 
go build ./cmd/app -o app[.exe] -v -i -ldflags="-s -w -X main.version=V1.0.0" - `-o`: set output file - `-v`: verbose mode - `-i`: installs while building. Important for compiling speed, since this makes cache of packages at $GOPATH/pkg - `-ldflags`: - `-s` and `-w`: makes executable smaller by stripping debug information - `-X variable=value`: useful to say variables, like version. You can see the last Git tag or commit hash, as example.
I think you hit the nail on the head. A challenge that needs concurrency, easy in go, hard and messy in most other languages. Anything multi-threaded.
U got a specific problem you can share?
I recently made "A Go package that can decode and validate an ASP.net FormsAuthentication encrypted and signed cookie": https://github.com/mevdschee/aspnetcookie @Brian: I would be grateful if you would add that (submitting on that site does not work for me).
Any blocking operation with a timeout. Which is go is easily done by "select" ch := make(chan *response) go fetch(url, ch) select { case resp &lt;- ch: handleResponse(resp) case &lt;- time.After(100 * time.Millisecond): fmt.Println("timeout") } 
Is this a different kind of select than C's?
Yes*
I have one, which I'm to this day trying to find if possible to implement equally elegantly in any other language: A scientific workflow management system, which uses a simple model of processes (simply goroutines packaged in structs, with channels for communication stored in struct fields aka 'ports') and channels for the communication, to get a nice "implicit scheduler" for managing things like HPC jobs, using very little code (I counted that it uses 3x less code than a recent python based system in the same category, by a respected bioinfo org). My library is open source and available at http://scipipe.org and we are just starting to use it in production for coordingating our HPC jobs at http://pharmb.io right now.
TCP Proxy func run() error { li, err := net.Listen("tcp", "127.0.0.1:5000") if err != nil { return err } defer li.Close() for { conn, err := li.Accept() if err != nil { return err } go proxy("127.0.0.1:5001", conn) } } func proxy(destaddr string, src net.Conn) error { defer src.Close() dst, err := net.Dial("tcp", destaddr) if err != nil { return err } defer dst.Close() errs := make(chan error, 2) go func() { _, err := io.Copy(dst, src) errs &lt;- err }() go func() { _, err := io.Copy(src, dst) errs &lt;- err }() return &lt;-errs } Example: # start the proxy [1] go run main.go # run sh listening on port 5001 [2] netcat -l -p 5001 -e /bin/sh # connect to port 5000 [3] netcat 127.0.0.1 5000 [4] echo hi =&gt; hi Simple and efficient.
I'm fairly new to Go myself. But I am implementing an interface for dealing with an API from a game server you can see here https://github.com/Gacnt/go-pubg/blob/master/wsconnect.go The nice thing I found so far with Go, is I can easily use channels to block the REST request from responding with a result until the channel receives a response from the websocket Open to any criticisms on how to do anything better! 
Thanks for sharing the source code. I have to implement a scientific pipeline with external programs. I will look into your package. The documentation is very nice. Are the different tasks executing asynchronously ? We would also like to use a database to store progress information and intermediate results for external monitoring. What do you use for monitoring ? 
Thanks for the kind words! Yes, the tasks are executed asynchronously, which is exactly what would be so hard to do without Go-routines. For example in Luigi which we used before, you needed separate full python processes (workers) for each concurrent task. (More details, perhaps too much: Since we used tasks to keep track of HPC jobs live (with a blocking system call to the SLURM HPC resource manager), we quickly ran into a limit of how many processes could reasonably be running on the scheduling node, even if they did not do any actual work (that would be done on other HPC nodes). I think we maxed out on like 64 processes, while we wanted thousands, so that our thousands of tasks could be queued up in the HPC system as fast as possible) Regarding monitoring, that is a good question. We don't really have much in that area yet, except from the audit logging to stdout and manually keeping track of which files are produced, but is something we've been thinking about, and for sure would like to improve upon. Creating web UIs and APIs in Go is easy, so I hope we can come up with something soon.
Create a tool that you can easily distribute to users on multiple OSes, which does a large amount of work in the background while running a local web service that shows live status etc.
You might be interested in [moggio](https://mogg.io/). It's written in Go, it's a full-fledged music player but also the components are highly reusable for your own music player too (I've used pieces of it for other projects).
Wouldn't it be easier to just google "golang select" than wait for a response on Reddit?
This is a nice project but exceptionally easy to do with Erlang and OTP. What you store in structs with "ports" would just be an Erlang process identified by it's Pid or via a named registered process. These Pids can be monitored by a process so they're restarted based on your requirements. It would be interesting to see what the comparable system would have looked like with Erlang.
**Edit:** I agree with the replies, this is actually not a great example. You can in many other languages. ~~I like the Fibonacci example.~~ package main import "fmt" // fib returns a function that returns // successive Fibonacci numbers. func fib() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } func main() { f := fib() fmt.Println(f(), f(), f(), f(), f()) // Output: 1 1 2 3 5 }
Testing concurrency edge cases. Very readable in Go because it's so easy to fire off some coroutines vs dealing with a bunch of thread boilerplate (particularly worse in languages that don't even have lambdas)
There's also [testfixtures](https://github.com/go-testfixtures/testfixtures), that cleans the database, but also allow you to define sample data in fixtures files.
Anything that does work concurrently and waits for results: https://talks.golang.org/2012/concurrency.slide#46 
Wouldn't it be easier to let other people decide if they'd like to answer and not shit on someone for simply asking a question?
meh, all this golang concurrency primitves looks bad when compared to erlang
A more Go-specific solution would probably be the goroutine/channel-based one as presented in the Go tour: https://tour.golang.org/concurrency/5
You can do basically the same thing in plenty of other languages. Even the mutli-assignment of `a, b := 0, 1` isn't Go specific, take this python for example: def fib(): a, b = 0, 1 while True: a, b = b, a+b yield a 
Erlang message passing does not block, which is a problem for the "implicit scheduler via a pipeline network" idea, since it does not give you the implicit back-pressure that you get with Go's channels (because of the fixed size buffers). It is *possible* to implement Go-like channels etc, (which is done in ElixirFBP afaik: https://github.com/pcmarks/ElixirFBP ), but then you need this extra framework, while in Go you can implement it straight in the language itself, reducing the amount of code a lot.
Now, there *are* scientific workflow management systems implemented in Erlang, of which Cuneiform is an impressive one (http://www.cuneiform-lang.org/), but AFAIK, it is a pretty different beast altogether, and AFAIS requires to work with the separate execution framework Hi-Way. (Citing from the paper [1]: "Together, Cuneiform and Hi-WAY form a fully functional, scalable, and easily extensible scientific workflow system.") [1] http://ceur-ws.org/Vol-1330/paper-03.pdf
Then only include it in your integration test code.
Rust version: fn main() { let (tx, rx) = channel(); thread::spawn(move || { // Something is being done or waited for here... tx.send(result); }); match rx.recv_timeout(Duration::from_millis(100)) { Ok(resp) =&gt; handleResponse(resp), Err(Timeout) =&gt; println!("Timeout"), Err(Disconnect) =&gt; println!("Channel hung up"), } } 
Any language with closures can do that.
go's advantage there's is that green threads are more lightweight. Having said largely I think it tends to be preferred to use socket timeouts.
Erlang: wait_for_onhook() -&gt; receive onhook -&gt; disconnect(), idle(); {connect, B} -&gt; B ! {busy, self()}, wait_for_onhook() after 60000 -&gt; disconnect(), error() end.
JS const response = await Promise.race( fetch(url), new Promise(r =&gt; setTimeout(r, 100)) ) if (response) { handleResponse(response) } else { console.log('timeout') }
It may be a little off-topic but for me is the ability to work in a team. gofmt make keeping the same style across a team very easy also the convention for testing e benchmarking make building a stable product much more pleasent than other language
&gt; go's advantage there's is that green threads are more lightweight. Well, yeah, obviously. I thought the objective was the wait with timeout. If the objective is coroutine demonstration, similar thing can be done in Rust with Futures... (Although I'm personally not a huge fan of that approach.) 
Thanks for the reply! So, with either libvlc or ffmpeg, you got encoding/decoding needs covered. I assume playback is also covered here, acc. to the first link you posted, right? A friend also suggested the **headless server** approach, which makes it something à-la-Electron. This seems like the best bet in regards to a modern, good-looking, consistent UI/UX all over Windows/Linux/macOS, but what about performance? I remember there was a Electron-based music player, and while it looked gorgeous, the performance was terrible, especially with big libraries. Of course, the **headless** approach would be different w/r/t this since the server would be written in Golang and it would handle all the heavy stuff, but I'd like to know the performance trade-offs of it. Also, which API implementation would you have chosen and why? Thanks again for your time!
I didn't know about _moggio_, looks pretty great, thanks for linking it! How has been your experience with it? Any thoughts worth sharing?
Round what type to what type?
I think this was a poor example considering that the lazy Fibonacci sequence has been used to brag about Haskell for decades: fibs = 0 : 1 : zipWith (+) fibs (tail fibs) fifthFib = fibs!!5
Because reasons! So there! Honestly, I don't know. Seems like such a natural thing to include. Maybe in 2.0 :) Meanwhile: func round(num float64) int { return int(num + math.Copysign(0.5, num)) }
How about Audacious - http://audacious-media-player.org ? Something like that in Go would be cool. :)
There's a long history on this issue: https://github.com/golang/go/issues/20100 I think the discussion got mired in the fact that there are different ways to round numbers. int(x+0.5) is a simple workaround.
[removed]
Well, most obvious is the float64 to int, but can be also float64 to float64, with declared round point(default .5) and amount of decimal places 
Thanks for that workaround, didn't even thought about it.
2 hours and 798 dependencies fetched later...
lol not necessarily for this example, but regardless, it was just show the same idea in a different language.
No worries I was just depicting my own experience :) Nice example!
Is there a RSS / atom feed?
JS is getting some interesting features recently. See: http://ember-concurrency.com/#/docs/task-function-syntax
Forgot about it, but I haven't used it. I'll try it to see how it goes. Thanks! :D
Rounding is not an easy task to generalize. There are so many types of rounding. Really there should be like 10 round functions not just one. Check out bankers rounding.
Good luck spawning 1000s of them.
Seems like libvlc is the way to go, will look into it later. Oh, I wasn't aware you could implement a native UI framework with a headless server. I always linked this with Electron-like concepts, where you would inject the necessary HTML/CSS/JS on the client-side. So, on Windows, I could develop a client, let's say, with WPF, as long as it supports API calls to my server implementation? I also wasn't aware of the **compact binary** format, will look into it later as well. Thanks for the much-appreciated advice, mate.
@maus80 Submissions should work for you, do you get an error?
RSS Feed is coming later today. 
I posted and you should be able to post. 
RSS is coming later today. 
Psst, https://godoc.org/golang.org/x/sync/errgroup
https://talks.golang.org/2013/oscon-dl.slide depending on your value of "easy"
Whoa sweet library. Somehow haven't heard of it before. 
Received mine a while ago, but it's just sitting on a table. I wanted to put it on my desk at work, but it's a bit too big. I really hope you do another run without the hole. Sorry to say, but it's kinda ugly with the hole, and the patch looks a bit weird too. I'd gladly buy another without the hole, and preferable a bit smaller. 
I don't think the difficulty of the programming challenge is the thing. I think it is the ease with which you can read the code and reason about it. The maintainability. Even using multi-threaded examples, the code is readable and easy to reason about. I think THAT is Go's strength. I see Go actually being quite boring and simple and that is a good thing. Boring and simple gives you maintainable and readable code, with good design behind it. It conveys what the intention is really well and the disconnect between the intention of the code and the implementation is responsible for far too many bugs IMO.
Day 10 of Advent of Code 2016 (the robot chip factory) has a really interesting solution using Go channels: https://adventofcode.com/2016/day/10 See e.g. [this solution](https://github.com/roessland/advent-of-code-2015/blob/master/2016/day-10/part1.go). Instead of a smart solution, this just simulates the whole factory using one goroutine for each robot. 
And in five years, enough people will use a compatible browser!
Well, thank you for telling me what you think. I will certainly look into doing another one with no hole if this one goes well. I can certainly involve you in the design too if you want. To get feedback on it I mean.
Note that this workaround doesn't work with negative numbers. See /u/Zy14rk's reply for a correct solution.
Go 1.10 will have a math.Round function.
This is kind of a weird question, because there are a lot of languages and the two "main" things that Go has are easy green threads and channels are in at least some of the others. At which point you need to look at things like the benefits of network effects. More developers means it's much easier to find a Go programmer than an ocaml/lisp/erlang one (I'd say dito train one too, but flames incoming). Obviously more developers means more available APIs to be able to import. On a similar note one of the surprising things for me, after using C/perl/python/lisp was std. lib. time and how easy it was to do multi timezone things.
I do, and I use flags to build that code. How else would you suggest to do this?
The code that is built to run your tests is not the code that is built to run your application.
bash (on a vaguely gnu userland).. I know it's not amazing and I'm very drunk at a wedding but I thought I'd throw this in FWIW resp="$(timeout 1s curl -q https://blabla.com)" if [ "x$resp" == x ]; then echo fail else echo ${resp} fi 
It's possible we're talking about different issues. I thought you suggested using flags to build tests differently than production code, including things in tests that are not in production. My point is that you don't need to use flags to do that. I haven't said it before, but changing code for testing implies that you're not testing the production code, but some different version, negating the benefits. If you need code that is only in the tests, then only include that code in your tests. That way you don't need flags to not-include the code in your production code.
This is beautiful. I'm going to borrow this.
95% of the way there without closures... #include&lt;stdio.h&gt; long fib() { static long a=0,b=1,tmp; return tmp=a+b, a=b, b=tmp; } int main(int argc, char *argv[]) { for(int i=0;i&lt;10;i++) printf("%ld\n",fib()); return 0; } 
I am genuinely interested even if this comes off snarky - why would I use an external library for a KV store when go has native maps?
C's select is an OS-level feature, while Go's is part of the language runtime and is more of a parallel switch.
I'm not very familiar with Badger but it looks like it persists data to disk allowing for much more data than can fit in memory, which would be the limitation with just using maps.
Goflow would've rolled off the tongue much better, and Go is the actual name of the language
I agree but goflow is already taken 
RSS Feed was added 
This is amazing to me. Thanks!
Ugh that's a shame.. did you consider doing a different domain suffix? 
.com &amp; .net were taken, any suggestions?
This should also work: // round rounds f to a nearby int. func round(f float64) int { if f &gt;= 0 { return int(f + 0.5) } else { return int(f - 0.5) } }
Thanks for sharing the lib, both are quite similar in term of functionality. However I think the dbcleaner is simpler and follows single responsibility principle better.
maybe. lol
Ada's "task entries" do though ..:)
I would suggest you to first extract "Content-Length" from the header. If the body size exceeds your limit, you can directly return an error and close the connection, in this situation, it will avoid unnecessary processing. Then if the client doesn't send you the "Content-Length" into the request header, you can fall-back on the "MaxBytesReader".
I would've said .io but that was taken too 😫 shame too cause goflow.io actually sounds awesome 😂
For monitoring, what about something like Graylog or Kibana? Complement it with Prometheus/Grafana and you'll have a very powerful setup.
I tried that one first 
bruh erlang has been spawning thousands of "goroutines" before that term was even coined.
These implementations don't quite work, as described in the issue. This will round 0.5 to 1 (and -0.5 to -1) which probably isn't what's intended. This is probably why the proposal was accepted. There are lots of edge cases and it's easy to have mostly working versions which are still subtly broken. Edit: See https://www.cockroachlabs.com/blog/rouding-implementations-in-go/ for more info. My explanation wasn't completely right. This implementation will also round things like 0.499999999999999999999994 to 5 as well.
I got tired of dealing with our ISP for doing port forwards and I didn't want to mess with iptables, so I built one in Go. I wrote a simple file format and had a basic port forwarder built in 100 LOC or so and it took about an hour and it's been running solid for months now. That's what I love about Go. If threading and sockets are involved in large quantities, Go will be quick and easy. If anyone cares, I can dig up the code, but honestly it would probably be quicker to just rewrite it since it's such a simple thing. In fact, I think every Go programmer should build a port forwarder while learning since it's so simple and useful.
I looked at doing something similar at one point, though I didn't get that far with it unfortunately. I did look at libraries that handle tags in audio files and I did run into a snag that most (all) of the libraries were a binding to a C library (taglib I think it was) that did not support the "album artist" tag which was absolutely crucial to me. I was going to send a patch to this C library to add this support for the album artist tag but got half way through it then sort of gave up on it. I came up with the conclusion I wanted to build a pure Go tag reading/writing library as it was a bit of a pain to link to this C library, but I haven't really got time for that so that is where my project ended. I also quite like the idea of headless music players like mpd, but I tried this many years ago and it also lacked support for album artist at the time which made it useless to me. I am not sure if mpd supports this now.
Just as a bit of an explanation why I didn't finish the patch to taglib is because it required you to add support for the album artist tag for all the different formats that taglib supports at the same time, mp3, flac, ogg + other more obscure formats. I got it working with some of the formats but never finished it.
https://twitter.com/francesc
The first step in solving any problem is admitting you have a problem. good for you - you have my support.
In that scenario it's effectively the same as doing: a := Vertex{} a.X = 5 You're not getting a copy each time you assign the field, you're just moving the value 5 to X, whereas this will produce a copy first: a := vertices[0] a.X = 5 vertices[0].X // won't be 5 :D Same goes for the assignment in `for` though, this won't give you v.X == 5's package main import "fmt" type Vertex struct { X int Y int } func main() { vs := []Vertex{ {1, 1}, {1, 1}, } for _, v := range vs { v.X = 5 } fmt.Printf("%#v\n", vs) } 
Go is pass by value. So when you pass a type to a function, you are passing the value, which is then copied. When you pass a pointer-type to a function it is also copied. All values are copied. pointer-types are special in that you can use these types to pass state into and out of a function. then the pointer-type can be dereferenced into a type. so in the example, you have a slice of two different types. one slice holds values of pointer-type *Vertex and the other holds values of type Vertex. You also pass the different slices into functions differently. one you are passing the pointer to a slice, and the other you are passing the slice(which is a struct containing three words: len, cap, pointer). So to answer the question. No. The []*Vertex slice is holding pointer-type *Vertex and the []Vertex slice is holding type Vertex. Drop your notion of reference at the portal into the Go universe. You have types and pointer-types, and these types hold values. Hopefully this playground is a effective visual aid: https://play.golang.org/p/kEYFzTwbwR it prints a textual representation of the data, the textual representation closely resembles how this data is stored within memory.
Shameless plug: I have a stats package with round and lots of other common functions. It's open source on github: https//github.com/montanaflynn/stats
I love how I take the time writing multiple posts to strengthen a projects security and you come here just to start shit like a little turd. I mean.. really? You are posting anon under a throw away days later. Could you be any more of a pansy? I gave you gold for both your posts, dork.
this is the same account, the one and only, I am the truth. Your posts have an overtone of self-superiority. You actually come here to ridicule people to inflate your ego. Also, this is reddit and the internet, where conversation can span days, weeks, and even months. I have a life, and I spent the last few days of that life doing other things. I am sorry I am not at your beckon call to reply the second you make a post in the thread of conversation. Don't get bent over it, oh wait, too late... *The crazy thing is that you are so full of yourself that you feel someone had to hide under an alias to confront you about another post of yours. I just got it - you think I am that other person. Hate you break it to you this way, but we aren't the same person, I am me and that person is, well, another person. The lack of context on the internet can lead one to make crazy assumptions. Take anonymity for example, paired with your mental state, and we get this thread on conversation. **Now if I ever made any comment that deserved gold it would be this one, yet you leave me high and dry - some friend you are. ***This is where you say "I aint your friend, pal", then I say "well, then I aint your pal, chum", then so on and so on.
@golangnews @golangweekly @golang
A slice is a struct consisting of a pointer to an array, a length and a capacity. // []Vertex m = {*,len,cap} // This part gets copied on function call | | +--&gt;[Vertex,Vertex,Vertex,Vertex] // This part does not get copied // []*Vertex k = {*,len,cap} // This part gets copied on function call | | +--&gt;[*,*,*,*] // This part does not get copied | | | | | | | +--&gt;Vertex | | +--&gt;Vertex | +--&gt;Vertex +--&gt;Vertex Slices are not arrays, they point to arrays. This is an array: // [4]Vertex a = [Vertex,Vertex,Vertex,Vertex] // This part gets copied on function call
@davecheney @robpike @kelseyhightower 
I enjoy following @golang_cls for news about changes to the language. 
I hear that @purpleidea guy does some dope shit :P
&gt; What world would that be? The only one I can think of is "desktop applications" which, let's be honest, is dead-er than dead can be. Hmm, maybe you're 100% using webapps all the day but it's not the case of a major part of the industry. When I cut, edit, and work on a 3D schema, do I run a webapp? When I do the same on a vidéo, do I run a webapp? When I'm viewing a file that I don't want to store in the cloud, do I run a webapp? My GNOME desktop environment and all its coreapp, are they webapps? I accord to you that Desktop apps does not have the "hype" these last years, as PC in general to profit to tablet and smartphone. But does tablet &amp; smartphone deprecated PC for serious business? Nope. Does WebApps deprecated serious DesktopApps for serious business or better, off-cloud use? Nope. For, outside of cli/serverside world, I gave the example of DesktopApps, but Embedded/IoT is also a subject, system programming (module of the kernel, drivers) also. For that last part, Go seems to be out of line (C/C++/Rust may be a better choice). &gt; Then there's what, mobile? That market seems pretty happy with ObjC/Swift/Java for the boring client-side stuff. I'm personally not dying to draw buttons and check-boxes in Go. But most serious apps have a pretty hefty server-side component as well. And that can definitely be Go. You forgot about Kotlin, which is greatly highlighted by Google at the Google I/O (no words about Go, I was sad...) in place of Java for Android. But if you look at http://kotlinlang.org/, you well see that Kotlin is also targeting native-binary. One of the main goal of Kotlin is to target Android (ART JVM), Server (Oracle JVM, OpenJDK, or native-binary like Go), Web (JavaScript) with transpiling. You can already build GTK/Qt/Vulkan apps, cli-app, serverside-app, and even Android apps or iOS apps (via native for iOS). Kotlin and Jetbrains goal is that you can build your Android Apps using the ART target, your backend with the native-binary target, and you're website frontend with JavaScript frontend. Which don't let so much space for Go. And it's sad because I largely prefer the syntax of Go. Some may answer me that JavaScript is on the same niche (web frontend, web/app backend with NodeJS, React Native for Android apps), but I will answer back that non-blocking I/O vs. goroutine is a largely strong argument. And Kotlin have some kind of goroutine-like lightweight and easy thread, or good'ol manual threading, at your choice, for what I've seen. And even if I prefer the Go syntax over the Kotlin one, Kotlin have a much decent syntax over JavaScript. &gt; So I that leaves us with web apps and games. Web apps are all Javascript client-side (and sometimes server-side) but once you're server-side, Go is a great fit as a REST-ful API server for a client app. For now. WebAssembly will permit an alternative to JavaScript in all brother, and I expect some C++ or QML Qt apps to be runned directly in browser gently kill some FrameworkJS for niche parts (high-performance GUI). So, a remaining of desktop apps in fact. For the backend part, I agree with you. &gt; Games are weird because few people are creating stuff from scratch - you just piggy-back onto Unity or Unreal or whatever and use whatever they use. So it lets us C++ or C#, basically. And most of AAA are C++/Unreal. Indies was much in loved of Unity/C#, but as Unreal is now "free of charge" to begin with, and just want a 30% cut-off as redeem to your charge, Indies begins to use C++/Unreal. For "homemade" engine, it's basically C++ always (Luminous Engine, Fox Engine, UbiArt engine...). I'm not a fan of C++, and dislike C#. But when you see what C# accomplished as a *true general purpose* language (Desktop, Games, Server, Embedded) with a ton of libray and support, I'm asking myself if Go can follow-up outside of the cli/server world. &gt; Definitely "server" language, but what interesting new work is not server-side? How many Silicon Valley startups have serious "client-side" job openings? Why do you tied all things to money and work? I currently holds a SRE job in Europe, in a hosting company. I'm not a professionnal dev, I'm a hobby dev. And even if I sometime need to dev in my position, I mainly do in Bash/Python (and some old pieces of Ruby). I completely don't care of "what is the hype in Silicon Valley", I'm speaking about if my current beloved language (Go) have an "avenir" outside of its server-purpose. TL;DR: I prefered to watch GitHub trendings than open position at SV. My interest as a hobby dev is toward OpenSource and Free software, not $ made at SV. And as a SysAdmin/SRE, I never have any problem to find a job. Thanks anyway for your answer.
@brianscott @goinggodotnet @freeformz 
That fails if you ever need more than 1 fibonacci instance though. That's the nice thing about closures. And adding another impl here for the record: fn main() { let mut f = fib(); println!("{} {} {} {} {}", f(), f(), f(), f(), f()); } fn fib() -&gt; Box&lt;FnMut() -&gt; usize&gt; { let mut a = (0, 1); Box::new(move ||{ a = (a.1, a.0 + a.1); a.0 }) } 
link: https://github.com/oracle/smith
Ah it's you again, you deleted the other account where you stalked me around various subreddits until you deleted it. Want to post your real name? You know mine. If not I have nothing more to say, your entitled to your opinion bud. * Because I won't humor anymore banter unless you reveal yourself, and stop being an anonymous coward I'll briefly explain why. It's because you clearly have a personal vendetta towards me. Since it's personal I find it rather cowardly you only post under anon identities. You want to make it personal, make it personal. Post under your real name and take ownership of the strong opinions you have formed about me. If not your nothing but a coward and for all that you may think I am, if nothing else I at least take ownership of my opinions, tone and actions under my own name and reputation. More than can be said for you. Why do I know it's you? The exact same writing style and you used the word "beckoning" again. You even edited your post denying it without me having to say it, paranoia is a symptom of the guilty. **You have every right to enter technical debate with me, I welcome it. If I'm wrong I'll concede and I'm sure that would be satisfying. Your ideas have the right to anonymity so posting ones different than mine I'll welcome and treat you like I treat names I recognize or not. But I take issue to the fact in a large technical discussion that I explain security concepts in depth, you chose a single line attacking my experience in the entire area the post was about. Without backing that claim with any technical merit. Anyone who had nothing personal against me would not say I lack experience while unable to find hints of such.** So, until you stop with the personal attacks and attack my ideas, or until you give your real name and criticize me with your professional reputation at stake.. since you are making this personal. It's no only fair since I have to post each reply with mine. Otherwise I'll reply to ever stalker post from here on out with "k" like I did before. Sorry. 
Well, it does what the comment says, round to a nearby int. It didn't promise rounding towards zero. But I agree, a more well behaved round func would be more complex.
https://twitter.com/bradfitz https://twitter.com/enneff https://twitter.com/dominikhonnef https://twitter.com/dvyukov https://twitter.com/_rsc https://twitter.com/dgryski https://twitter.com/mholt6 https://twitter.com/FiloSottile https://twitter.com/golang_cls https://twitter.com/golang
Isn't Erlang somewhat slower than go tho? 
It expires in like a year too. 2018-05-20T13:59:17Z
You are crazy. I just told you that I am not that person. So now I must be this other person who was also stalking you. Psst, heads up, everyone is stalking you, you are just so irresistible - with that big bald head, and pasty white skin. I want you now, right here and now, on the internet. Give it to me, or I will stalk you like the others. We will create club, and stalk you together.
yeah, but assuming that you're doing networking related apps, its [great](https://m.youtube.com/watch?v=uKfKtXYLG78)
maybe this will show the [difference]( https://play.golang.org/p/XJC266-4LC)
That's funny, every other language in the past 30 years has managed it. Seems like it would be a solved problem by now.
I'm not saying it's not solvable, nor is it poorly defined. But it's as simple as &gt; 5 round up. 
Best is to use git describe (--tags) for the version. It will use the last tag possibly appended with number of commits and hash of the current commit (but only if the last tag is not for the current commit) 
k
kk
&gt; Good luck spawning 1000s of them. Not sure what the point of this comment is since the same one has already been written and anwsered... I thought the difference between a native thread and a green thread was obvious. 
You're being overly optimistic there...
We're going to be tackling this shortly. We used to take this approach, but I'm wondering if it would be easier to just have a base Docker image with sample data included, then kill the container and spin up a new one per test.
Package looks nice, thanks for sharing! I've used https://github.com/DATA-DOG/go-txdb and https://github.com/DATA-DOG/go-sqlmock with some success as well.
[Steve Francia \(spf13\) ](https://twitter.com/spf13) - he is a Golang contributor and also wrote Hugo, Cobra, Viper and so mnay other stuff.
it's like asking why go doesn't have generics
I gave an offer so let's see how it goes
it's "brainscott" :) 
https://twitter.com/brainscott https://twitter.com/golangflow
Currently, I use their WebStorm w/ the go plugin. Is there any advantages to moving to Gogland over what I'm currently doing?
I may not be very much help, but are you defer closing (or outright closing) any files you open? Also closing io.readers and company. This may be way past your skill level, but it's something I recently came across.
now i have to convert my app to beego cuz there is no more update to this repo. Thank you kataras really, i'm not trusting other forks either. no guarantee for not to selling it AGAIN
Go automatically looks up what pointers are pointing to. So `joe.Name` looks up the struct that the `joe` pointer is pointing to, and then gets the `Name`. For `john`, it goes straight to the `Name`. In C++, I think you did `joe-&gt;Name` for pointers, and `john.Name` for values... but in Go, they're both dot.
You decide whether you take a pointer or a struct in the signature. So `func (p *Person)` takes a pointer, but `func (p Person)` copies the whole struct.
Ohh, yeah I just got confused trying to compare it to C++/C. Thank you
'If you are building a statically linked go binary and using scratch as your base, you are probably already building a microcontainer.'
Also consider that if you don't close writers &amp; consume all items from channels, you can end up with goroutine leaks. Looking at what goroutines you have alive after a load test may be useful.
Thanks! How can I view live goroutines?
With pprof. You can also send a SIGABRT to crash the server and get a stack trace for all running goroutines. If you use the web tool, you can render an SVG for memory and goroutines, which is very useful for tracking down these types of leaks. I was able to track down a nasty memory leak in minutes once I learned how to use the tools Go provides.
I haven't tried it myself but after a cursory search you could try this: https://github.com/zimmski/go-leak I'd be happy to take a look at the code myself if you want.
Thanks, it's indeed a promising tool but it seems it's no longer maintained and won't work with go1.4+
Thanks, will git a try! Also, for anyone interested, I found this talk about go profiling https://www.youtube.com/watch?v=xxDZuPEgbBU&amp;feature=youtu.be 
Ah that's unfortunate. I don't remember if anything in go-metalinter detects leaks. Possibly for goroutines? Are you using them in your handlers?
I'll take a closer look shortly, but the first thing I notice is that your comments maybe weren't written with godoc in mind. You can see how your code documentation turns out here: https://godoc.org/github.com/maudinski/sesh. If it interests you, take a look at the style of the stdlib docs and mimic it where possible.
9/10 times it's a http.Get/put/post that you forget to to close the body on. Even if it was empty you still need to defer reap.Body.Close(). Same for anything you open, but that one is more obvious. For anything else check out pprof, you can see active goroutines and memory alloced.
That turns out to be a surprisingly complicated question. But here's a simple example to get you thinking about how hard this can be: Suppose I have: func CloseAllTheThings(things []io.Closer) { for _, c := range things { c.Close() } } Ignoring error handling and such for now, how would a compiler statically figure out which implementation of Close will be called, bearing in mind that I can trivially pass this function a single slice that contains all of an *os.File, a socket, a random struct that I declared a `Close() error` method on, and a nil interface, any of which could be a purely run-time decision? And also, in a world of Go supporting plugins, may be an instance of some code that didn't even exist at the time that this function was compiled? It is somewhat true that Go probably could theoretically statically do more analysis than it does, but it is also true this gets to be a hard problem as it scales up into a real program, and even languages like Rust that try their very best to do as much statically as possible with most of the latest available programming languages tools [can still end up doing dynamic dispatch if you push them hard enough](https://stackoverflow.com/questions/28621980/what-are-the-actual-runtime-performance-costs-of-dynamic-dispatch).
Read this series. https://www.goinggo.net/2017/05/language-mechanics-on-stacks-and-pointers.html
Read this series. https://www.goinggo.net/2017/05/language-mechanics-on-stacks-and-pointers.html
Without getting too deeply, a few things: * The documentation for this package is incomplete. It does not state what it's for, what problem it solves, or how it solves that problem. All of this should be part of the package documentation such that it show up properly in godoc. See [this](https://blog.golang.org/godoc-documenting-go-code). * The Go ecosystem includes a number of useful linting tools. At the least run your code through `go fmt` and `go lint`. Those commands will complain about this code. * Avoid advocating for global variables. There is no reason that the session manager needs to be global. It is better to include it as part of any HTTP handler which requires it. * While `sesh.NewSessionManager` is not a perfect example of stuttering, it's still not idiomatic. Simply `sesh.New` is sufficient to convey the meaning. * The API of `SessionManager` would be cleaner if it could read a cookie from an `*http.Request` and write one to an `http.ResponseWriter`. You could include the cookie name when initializing the `SessionManager` so that it doesn't have to be handled by the caller on each request. * `NewSessionManager` should call `NewCustomSessionManager`, passing in the default value. Those two functions are copies of each other as it is currently written. Be DRY when prudent. * `defaultChainSize` should be a `const`, not a `var`. * It looks as if you're managing slice sizes and re-allocating yourself. Don't do this unless you have a compelling reason to do so (you don't in this case). Use the built-in `append` instead. * While I don't entirely understand what you're trying to accomplish (the documentation is incomplete) it appears you attempt to check if users are tampering with cookies. If that is the case your solution is almost certainly broken. You're going to want to use some flavor of crypto for this (and don't roll your own).
You might find this helpful. https://www.goinggo.net/2017/05/design-philosophy-on-logging.html
On an illumos based system you could preload libumem.so and enable debugging. The memory allocator will keep track of leaks, top consumers, use after free, and double free etc. 
You're right about that, I wasn't even aware that was a thing. Thanks in advance
Ok thank you for that, that was rather thorough. I'll keep all those things in mind. If you don't mine one more question though, on your last bullet point, what do you mean you couldn't understand what I was trying to accomplish? As in the whole program? Or just that I was constantly trying to check for cookie tampering within the program? Like I said I'm novice, but the point of the program was to be a package for easy-maintaining of logged-in state. I was certain that was the idea behind sessions, but like I said, I'm novice, so I could be wrong. Edit: My documentation could definitely be better. The string being passed to VerifySession and such is not the name of the cookie, but whatever unique name the user is using to store that person in their database. A username, or a user ID, or something like that. I'm definitely going to work on my documentation
One thing you can do is to compare 2 heap pprofs. You can do it like this: * Extract a heap profile `heap0.pprof` * Add some load to the application * Extract another heap profile `heap1.pprof` * Compare them with `go tool pprof -base heap0.pprof &lt;bin&gt; heap1.pprof` This way you can see exactly what is increasing over time.
Thanks **ord32** for the example, it has helped a lot. It appears to be working in my code, but I am having still one little issue. When I select a file to upload that is larger than the max and hit submit, my code now tells me it was too large, but then I get a "The connection was reset" page. Here is my code: r.Body = http.MaxBytesReader(w, r.Body, maxFileSize) //50M Max err := r.ParseMultipartForm(maxFileSize) if err != nil { http.Redirect(w, r, "/myfiles", 301) } file, header, err := r.FormFile("file") defer file.Close() if err != nil { log.Println(err) } out, err := os.Create("./files/" + header.Filename) if err != nil { log.Println(err) } defer out.Close() _, err = io.Copy(out, file) if err != nil { log.Println(err) } http.Redirect(w, r, "/myfiles", 301) I'm not posting into the same page as my form but to another HandleFunc. Could this be my issue?
https://twitter.com/rakyll https://twitter.com/Kris__Nova https://twitter.com/matryer https://twitter.com/ashleymcnamara 
You don't want to use the user id as a unique identifier for the session because they're guessable. Your sessions are only as secure as the cookie values are secret. You can use crypto to sign the cookie values, ensuring that the cookies were issued by your service. If you do that, you don't need to keep them all in memory. This implementation won't survive a restart of your code, and it won't work if you scale it out to multiple servers. Both scenarios fail because the client holds a reference to a slice in one instance of your app.
Those travis configs are okaaaay, but this one is better ;) https://gist.github.com/y0ssar1an/df2dab474520c4086926f672c52db139
source: https://stackoverflow.com/a/43785190 The issue is that the client does not read the response. When the MaxBytesReader limit is breached, the server stops reading data from the client. Also, the server fully closes the connection a half second after writing the response to the client. Many HTTP clients write the complete request body before reading the response and stop on any error writing the request body. These clients report "connection reset" errors and the like when the request body is sufficiently large and ignore the response written by the server. you can use Content-Length header or use javascript code to determine file size before uploading the file ...
Have you even read his post?
https://twitter.com/rob_pike
I added support for the PE file format. `goman` should now also find the README for Windows binaries. Can you please `go get` the latest version and test this at your end? Tests with a cross-compiled `goman.exe` were successful but I would like to confirm this on a real Windows system. Thank you.
You can try [stackimpact](https://github.com/stackimpact/stackimpact-go). It will give you historical view of in-use memory per line of code (uses pprof underneath) and you can spot where it is growing. More details in [this post](https://stackimpact.com/blog/memory-leak-detection-in-production-go-applications/).
Maybe it's simply due to the data structure. Lists of tuples with type and number would be more flexible and better searchable. Blaming a database driver doesn't help. 
&gt; but now it gives me error Fix the errors.
&gt; but now it gives me error which errors?
This is why I love programming, when shit goes wrong it's generally my own fault. Find and fix your errors, or at least give the people willing to help a clue.
[removed]
What pot of shit did you use to compare? Why not use a better maybe more agnostic data structure? As TheMue has said blaming a database driver isn't going to help.
MongoDB‘s shell is 10000 times better than mgo, and let alone pymongo
Any one who is familiar with pymongo or mongoengine or even MongoDB's default shell will say, mgo is a pot of shit!. 
A man who write a database driver to wrap the origin api is aim to make it more usable. But mgo back the car, it makes MongoDB so hard to use.
But it is not that hard to find solution with PHP. I am crazy about programming especially with Go. But when it comes to deployment, I can not find any solution to satisfy me. Still I am insisting on writing with Go.
How worldly.
Heroku error logs 2017-07-03T10:38:04.090899+00:00 heroku[router]: at=error code=H10 desc="App crashed" method=GET path="/" host=turalasga r.herokuapp.com request_id=c063ee5a-4a73-451b-a1d7-3d1eb6b05bf7 fwd="185.43.191.172" dyno= connect= service= status=503 bytes= protocol=https 2017-07-03T10:38:04.393113+00:00 heroku[router]: at=error code=H10 desc="App crashed" method=GET path="/favicon.ico" hos t=turalasgar.herokuapp.com request_id=7ea40084-38ad-4dc7-9b17-8036d7431e16 fwd="185.43.191.172" dyno= connect= service= status=503 bytes= protocol=https 2017-07-03T10:38:09.007090+00:00 heroku[web.1]: State changed from crashed to starting 2017-07-03T10:38:10.423771+00:00 heroku[web.1]: Starting process with command go-blog 2017-07-03T10:38:12.360909+00:00 heroku[web.1]: State changed from starting to crashed 2017-07-03T10:38:12.353276+00:00 heroku[web.1]: Process exited with status 127 2017-07-03T10:38:12.277685+00:00 app[web.1]: bash: go-blog: command not found 2017-07-03T10:39:41.981551+00:00 heroku[web.1]: State changed from crashed to starting 2017-07-03T10:39:43.394609+00:00 heroku[web.1]: Starting process with command go-blog 2017-07-03T10:39:44.873576+00:00 heroku[web.1]: State changed from starting to crashed 2017-07-03T10:39:44.858043+00:00 heroku[web.1]: Process exited with status 127 2017-07-03T10:39:44.814585+00:00 app[web.1]: bash: go-blog: command not found
The driver is intended to serialize data structures and use Mongo for persistency (top-down). You instead want to access a number of different structured documents (bottom-up). It's like trying to hammer a nail with a screwdriver and then blame it that it doesn't work. But it's very good for screws where a hammer fails. 
I've never user Heroku, but ut seems as if your $PATH variable in bash doesn't contain the path to your go-blog binary. A quick google search shows that you need to put .profile.d file in your build directory and set the path in there Good luck 
Just an information: Glide is an golang package so it is possible to install it with go get described within this comment: https://github.com/Masterminds/glide/issues/408#issuecomment-217493627
&gt; Indexing GOPATH should be a one time operation So no new code appears on GOPATH after installation ? PyCharm reindexing AFAIR happens only after I install/update packages.
Thank you very much for your support. But nope, no .profile.d is used here. I have deployed before and has been working until now. https://loginparol.herokuapp.com. But now for some reasons it doesn't work. Thank you.
I don't think this has anything to do with mgo. If you don't know the schema upfront you'll just have to use `bson.M{}` and then figure out the parts you need (there are libraries to help with that). That's the price you're paying to be schema-less.
[removed]
It's possible something is going wrong with the build process. I haven't used Go on Heroku for awhile, but if I recall correctly, the default Go buildpack expects your `main` package to be in the repository root. If your `main` is somewhere else, like `cmd/blog/main.go`, then that could potentially cause a problem similar to this. When I was deploying Go apps to Heroku, I found it was really helpful to read through the buildpack source so that I understood better what it was doing and what it expected. https://github.com/heroku/heroku-buildpack-go
What i'm trying to say is, you should try and use a .profile.d to set up your envorinment var. The error message seems pretty clear to me.... heroku can't find you binary called go-blog so you have to define that varaible in your deployment. try this: heroku run bash echo $PATH is your executabe in any directory listed there? If so the error is different. Otherwise create that file and ensure you set the path variable. 
&gt; So no new code appears on GOPATH after installation ? It definitely would appear, but unless the code added is a few gigabytes then the process is pretty quick. &gt; PyCharm reindexing AFAIR happens only after I install/update packages. Gogland does basically the same.
JWT generally refers to JSON Web Token. https://jwt.io
It's a single static binary, it has literally the least number of things that could possibly go wrong. You need to run an executable, that's it. Get a cheap vm from any company, Scp the damn binary to it, ssh to the server, ./Go-blog to run it. Done. Your issue isn't Go but the abstractions in front of it you don't understand. So remove them.
Yep,that's why I was confused when I read it and was like WTH?Had to Google it to make sure,for a moment was like my whole life was a lie but then no result for JavascriptWT and my heart started beating again normally.
Schema can not work. Because it need declare a struct first and then can it transfer a map to struct. But before I input the name of a field, how can I declare a struct?
Is there a "hammer" to solve my problem in Golang?
I know it has nothing to do with Go, I run it in local environment pretty well. Have you ever deployed on vm? I mean what would you recommend?
Correction, the data structure you working with is at fault. All you have to do is use a map or `D`type from`bson` sub-package as a target result when working with `Query` and BSON will be unmarshaled/deserialized just fine into it. Then you can examine it to your heart's content. The relevant documentation is at http://godoc.org/gopkg.in/mgo.v2/bson#Unmarshal 
Hey guys, I'm happy to announce go-astisub, a Golang library to manipulate subtitles. It allows you to manipulate .srt, .stl, .ttml and .webvtt files for now. Available operations are parsing, writing, syncing, fragmenting, unfragmenting and merging.
Which variables do you mean? The app shown above doesn't use any variable(provided by me).
Thanks! This is definitely harder than I thought it would be. Rust seems to do a better job at things like these, but then again Rust's compile times are a lot longer
Most generic datatypes regarding marshaling of JSON are interface{}, []interface{}, or map[string]interface{}. These structures are nested then. These interfaces are statically typed then when doing the unmarshaling, but you have to work with type assertions if the may vary. While JSON has this flexibility a static-typed language like Go is a bit more complex here. That's why it's so positive to know your data structures well. We do the same here with CouchDB. We simply serialize our types into the DB and later retrieve them, as deep nested structures.
Yes, on lots. All you need is the binary and a systemd unit file for the service. Start by getting the blog up and running and if you get stuck making a systemd unit file ask me for help, I got copy pasta on my workstation I'll post for you.
Thanks for the document, I will read it carefully.
He means the environment, that is how your shell finds programs to run. When you type "ls" your shell checks PATH to find an executable named ls. Read https://en.m.wikipedia.org/wiki/PATH_(variable)#/editor/2 Because heroku.. has an abstraction in front of everything I can't say what it allows. But try an absolute path to your binary, if that fails try placing this in whatever their concept of a profile or exports is: what_path_to_use=$(dirname /home/tesger/bin/go-blog) export PATH="${PATH}:${what_path..to use}" Assignment is for illustration, you just need to replace the second var with the surname that contains the binary. 
Non-Mobile link: https://en.wikipedia.org/wiki/PATH_(variable)#/editor/2 *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^87104
Maybe check out the official mongo-tools sources at https://github.com/mongodb/mongo-tools Most (or all?) are written in Go and use mgo, without the structs. Still, for me the structs are great. Clean code enforcing, strictly typed awesomeness. I don't get how someone could hate that so much.
OK, I will read it. Thanks a lot.
What do you mean exactly by "the memory still remains the same"? Total memory allocated to the process may stay the same even after objects are garbage collected and freed; Go marks the memory as reclaimable, but the OS may not actually reclaim it until there is enough memory pressure for it to need to do so - this saves allocations in the event that the process that freed the memory needs to allocate more memory again later.
Other comments have covered a lot of good points, but one I would point out as a Go developer: I would never use a session manager without plugable storage back-ends. Having only local storage available makes the application stateful and therefor much harder to scale, load balance, and keep available. In this case they aren't even persisted locally to disk - just restarting the process will lose all sessions. Some code review: * NewCustomSM should take an options struct; if you're planning on adding more options later, an options struct would let you do so without changing the function signature (a breaking change) * StartSession insterts the session at a particular location, but sets the new session's internal "spotMarker" to {-1,0} even though it knows the true value * The slices of slices doesn't make a whole lot of sense - I'm not sure what a "chain" is supposed to represent but it doesn't seem to add any value * Slices seem like an odd choice in general; just keeping track of "open spots" is a huge portion of the code and highly error-prone and inefficient. A map seems like a far superior option for this use case. * The cookies have no expiration/lifetime set, so as soon as the browser window is closed, the sessions end. A configurable session lifetime would be a pretty important feature, and will necessitate a function to refresh the expiration of an existing cookie.
You said a lot of things I've never thought about. I'm not sure how I would start to implement something with a plugable storage back end, but I'll do some research. Thanks man Edit: I initially wanted to use a map, but a lot of articles I've read said that Go's implementation of maps is not efficient after a certain amount of entries. Even at that, I more or less tried to structure the chains in a similar fashion to go's maps (which as the developers describe, is a slice of "buckets", and each bucket gets multiple values). The only difference is I think after some point in resizing of go's maps, it become a slice of slices of buckets... and so on. Either way, I'll have to consider everything you said. Thanks a lot, I appreciate it 
If it's different then why post the solution in Rust? It looks the same but performance wise it's completely different so your example doesn't answer OP.
We're talking about Rust here.
You should always set timeouts!
Yeah I definitely need to get into the crypto package. Some one else pointed that out as well. I'm starting to do some research in how how to store stuff in to disk and make it efficient for lookup times. My thoughts are store everything, and as sessions become used, store them in cache for a week or so, then delete them from cache until the user seems to be using them again. Thanks for the advice
You can override the default http client with a custom one where you can specify the timeout. In my opinion it is the responsibility of the user of the library to specify this kind of behaviour. 
You're comparing apples and Bolivia. The shell isn't a DB SDK, that's a pointless comparison. Python and Go are very different languages, so pymongo is a slightly better but still inapplicable comparison.
A fair opinion I think, it'd be super annoying to try to hunt something like that down in a bug, only to realize the package did it for you. This is a neat one, I'll be checking this out after work.
Right, interesting. What I mean is, see in the gist above, before the load test all functions keep their allocations to minimum. Once the load is getting heavier, the numbers are going up, but after the test (when theres no traffic) the heap allocations remain the same - if I start another test, the allocations keep increasing until there's absolutely no memory left and it freezes so I think the memory hasn't been marked as "available"
A guy I used to work with used erlang for a highly-concurrent/available application, but said they moved to C as erlang was being somewhat slow. Although they did sing praises about the language and its fault tolerance!
In my opinion the best approach is to accept context as the first parameter to function calls.
I think some of the other answers already provided good explanations on this.
I changed it. I think you made a fair point and I would love to reduce the change of people hunting bugs.
...so don't use it?
I think maps remain efficient up to at least the size you're working with but the only way to say for sure, for your use case, would be too spike them both, benchmark them, and compare them.
I agree context is useful. I've opened a PR with the context changes. Not sure if the way I implemented is correct. Could you elaborate on the implementation (https://github.com/barthr/newsapi/pull/1) ?
&gt; If it's different then why post the solution in Rust? My aim was to show how to wait for an operation with a timeout. That's how I understood OP's request, AFAIK they didn't mention lightweight threads at all. How the task is completed on the other end of the channel is another matter altogether, you can send stuff to the channel in wahtever way pleases you, the thread was just an example. If you don't like this example just downvote it and move along. 
There are a lot of decent answers here, mostly focusing on concurrency, but I think this is the wrong question. Can you use libraries? Then absolutely anything in almost any language could be turned into a one-liner by writing a library for it. Can't use libraries? Then it's down to what's in the stdlib for the language, ruling JavaScript out of damn near anything but giving most languages like Go, Java, C# a huge advantage. Ignoring even stdlib? Then it's down to syntax and built-in language features which is getting into very subjective territory and serious hair-splitting. Any program could be written in almost any language, and the number of lines of code involved is only a small part of the picture. There are lots of "elegant" Perl scripts that are inscrutable to anyone who isn't a Perl expert. Concurrency in Go is pretty good, the stdlib is really good, but that's only a small part of what draws me to it. It's the simplicity, the performance, the toolchain, the readability, the simplicity, the platform compatibility, testing, benchmarking, profiling, the Go 1.x compatibility promise, the easy of deployment, the ease of insight into stdlib (every function in the godocs links to the source - transparency I would have liked in C# or Java), the straightforward way that the stdlib works (the HTTP handler builds upon the TCP handler which builds upon the basic IO constructs, all in ways that are easy to understand and reason about). These are the things that separate languages, not examples of what takes ten lines in one language and twenty in another. This is why I flat out ignore language marketing based on "you can write X in only Y lines of code" - a bizarrely popular tactic that's meaningless in practice. It only demonstrates a single strength of the standard library, nothing more. It's pointless in a true debate of the strengths and weaknesses of various languages.
This exactly. The database abstraction layer isn't just abstracting database access, but the entire database interaction, including errors. It should abstract away database-specific errors into domain-specific errors, like the example of ErrNoRows -&gt; ErrNotFound.
Any chance you could post it here I would like to see it as well :) 
&gt; a lot of articles I've read said that Go's implementation of maps is not efficient after a certain amount of entries What? This is ridiculous, as a general statement. Where did you read this?
Plotting the mandelbrot set.Golang's complex128 data type and math/cmplx make it super easy.
Sure, [here is a gist](https://gist.github.com/cstockton/ac9a95f865607d2b5a2041ba5824eb94) that can serve as basic example for running a service on port 443 on bare metal.
I was being slightly sarcastic wrt. the one-time operation, cause I read your install/update/... as "golang instance/version" change, not package change. Yes, ideally this should be incremental process (no-op if no changes detected).
&gt; Yes, ideally this should be incremental process (no-op if no changes detected). It is like this, but when you have to scan 300k+ files (that's my GOPATH size atm) to see if there are any changes or not, it can take a bit to do it. Also, internal changes can affect indexing or installing / updating plugins which need changes to the indexes.
In my experience, a programmer that tries to blindly blame the tools is usually the one at fault
FYI this was fixed 6 months ago. https://github.com/thewhitetulip/web-dev-golang-anti-textbook/commit/3d488ca5c4cc3bdaa1ed95efadc5145fd9c112c6 I'm not quite sure what you're getting at by calling out the author's supposed nationality though.
Well, first—just to make sure this isn't an A/B problem—make sure you check out the `database/sql` and `database/sql/driver` packages. Second, I'd prefer the latter. However, if this is all local to your `NewAPIClient` function, it doesn't really matter—do whatever is the easiest to maintain and expresses what you're trying to do the best.
Nice. I see it does not work with ssa/ass yet. Those are text, should be pretty similar to srt, I guess. I remember having trouble with some of the available tools converting subtitles: long text in one of the formats crashed the tools during conversion. Hopefully, there will be some defensive coding for that. Will check it out closely later :)
In addition to what wrexer said: Go maps are not sorted by key! A key-value store generally lets you iterate or scan (filter) over the items in key order. Go maps won't let you do that. Concurrent/locking behaviour might also be different.
There are a few things to consider in addition to what you already know. First, consider memory allocations: the fewer you make, the easier it is on the garbage collector and fewer possibilities for memory leaks. Second, opening database connection returns a reference to a pool, which will handle multiple actual connections for you. Maybe you do not need to create new connections yourself (unless you are opening one per goroutine). 
nit: mutating the receiver/function argument is not observable at the call site.
Making it work with ssa/ass is a great idea, I'll add it to the project's roadmap!
https://github.com/golang/go/issues/3885 https://www.reddit.com/r/golang/comments/3n0lf8/go_maps_dont_appear_to_be_o1/ https://www.goinggo.net/2013/12/macro-view-of-map-internals-in-go.html - check out the "How Maps Grow" section, but the whole article is worth a read That second link is somewhat controversial, but has people running tests in it, so worth a look. I guess (and this isn't about go's maps, but about hash tables in general) the reason I elected for some more complex data structures using slices is because this way, the cookie can store information about the exact position in the data structure (which is what I'm doing), making it ALWAYS a constant time lookup, as opposed to hash tables, which are at best constant time lookups. Maybe my logic is a little off, but it seems to be working. And obviously, I need to account for things like parsing the cookie value, etc. I just ran some tests like 5 min ago of simultaneously running 10000 log ins and log outs on this package (StartSessions and EndSessions) and it was instantaneous. Let me know what you think though, I could just only be getting my hands on negative things about maps.
By all means github it if you can, helps others to learn 👍
I did. Two more minor things. * Consider adding a period at the end of all sentences in comments so they will be more readable on godoc.org. * Are the client methods `Do` and `NewGetRequest` intended to be exported? They look like utility functions that won't be used from outside. Not sure about it. I think it's a useful package. Thanks for sharing!
Let's encrypt is pretty good. I've used them before. I wouldn't recommend the fake certifications or browsers might block it
And here I was thinking that you still had to pay for SSL certificates lol.....
Magento was essentially the Spring of PHP
Some sites like GoDaddy still pull this scam. Last I remember they charge like $60 a year
JWT = JSON Web Token. JSON = JavaScript Object Notation. Javascript web token is wrong, but it isn't really *that* wrong.
Deploying on heroku is insanely simple, especially for go apps. https://devcenter.heroku.com/articles/getting-started-with-go#introduction ... the error you linked in comments indicates that somewhere your setup is incorrect. Can you link you code/configuration? Happy to help debug but need more information.
You need to install git and have it in your path 
If the API client depends on a database handle, pass it in on construction:`func newApiClient(db *sql.DB)`. But, more importantly, does an API client that connects to public APIs over the internet really depend on a local database connection? I get the impression you are mixing concerns. You may want to rethink your architecture completely (or, at least your naming if I have been given the wrong idea of what the structure is doing).
And at the base of LetsEncrypt is the same technology in CloudFlare's PKI server, and its written in Go: https://github.com/cloudflare/cfssl Its perfect for handling the lifecycle of masses of x509 certs.
By "fake certifications" I'm guessing you are referring to self signed certs. They aren't fake, they just don't have a chain of trust and so aren't good for public sites. They have plenty of valid use cases if you control the whole stack.
Come on. It says exactly what is wrong about 20 times in there. 
What did you expect when your OP can be summarized, with no loss of detail, as "shit doesn't work?" 
[removed]
A quick search for `golang ring buffer` give me this one https://github.com/glycerine/rbuf 
https://golang.org/pkg/container/ring/
Done, packages installed, but F5 still throws: Failed to continue: "Cannot find Delve debugger. Install from https://github.com/derekparker/delve &amp; ensure it is in your "GOPATH/bin" or "PATH". In fact, dlv was not installed in any of those destinations. And i'm a total noob with github, how i install delve?
nvm, i made a simplified version for my usecase https://play.golang.org/p/m6TDGiXFbi
Try "go get https://github.com/derekparker/delve" edit: in your terminal, of course.
Nope. There's no possible way
To import dynamically, there's 3 real options. One is to include a Go interpreter and use that for the Go libs. This would be the best solution for your end-users because of the debugging ability and tight integration. Two is to use the "go" tool to write and compile a plugin dynamically that imports the library and wraps it for use by your interpreter. This is the quickest solution but introduces the Go tool as a dependency for using the interpreted language. Third is to import the library and transpile it to your own language, then just run it. This is the best solution because people using the library can either read/use it as Go or as your custom language, but it's a massive amount of work. I recommend number 2, and if it becomes worth it in the long run, invest the time into number 3.
Oh no. Oh gosh. If the terminal isn't working, I don't know what to tell you... If that's true, that means you've been hit with the BlueNexus virus - you're going to need to find/buy another expendable computer, connect both computers with a USB drive, and try to coax the virus into your other PC. You'll know when the virus has switched PCs, because you won't be able to open the terminal on the other computer, but you will be able to open it on your own. After the virus has jumped ship, update Adobe Flash Player. It's the only thing that can keep the virus from returning to your original computer. If you're up to date, uninstall and reinstall it. Once the virus is contained on the other PC, you're going to need to find a safe way to dispose of it. BlueNexus is known for jumping airgapped computers - meaning if you throw it away, it could spread to other electronics in the dump and eventually spread into cities. We don't want that. I recommend filling your tub with hydrochloric acid, and dipping the PC in there for ten minutes at a time. Don't dip for longer than that, or the virus might realize what's going on, and enter hibernation mode. After you've dipped it ten or more times, you're going to want to ask Siri for the nearest metal foundry or swamp. After 3AM but before 4AM (that's when the NSA satellites install updates and aren't watching) you'll want to dress in all black, drive to the foundry/swamp, and throw the computer in. Before throwing it in, it's advisable to make it as discreet as possible, so that no one finds it and inadvertently releases any of the virus in the future. I recommend covering it in manure. Drive back home, and make sure to text your wife "hey, got some cream cheese from WalMart" or something like that so you have an alibi in case this ever comes back to bite you. Hope this helps!
It doesn't matter that you didn't use them. Things like .profile and environment variables are still used by your go program and heroku's deployment tool.
http://wiki.c2.com/?ProfileBeforeOptimizing - See if you actually need to speed it up. - Profile the code to see where it's actually spending its time. - Focus on the few high-payoff areas and leave the rest alone. Maps are very fast at exactly this use case, given a key give me some data. I dare say your not even close to needing the 40 million lookups per second hinted at by https://github.com/golang/go/issues/3885. If you do need crazy speed grab a KV store written for performance that knows how to index properly and fetch from disk.
TL; DR: "Pipelines in Elvish can carry structured data, not just text. You can stream lists, maps and even functions through the pipeline." +1 - - - Update: I installed Elvish and started working through the online guides, and every time I try something, a little bit of awesomeness pops up. Live coloring of syntax errors, zsh-like interactive completion, a capable (and IMHO less cryptic) shell script syntax, etc) Hint: Elvish is available through Homebrew and Linuxbrew (the home page does not mention this), but the stable version is still at 0.8, so use --HEAD to get the current status.
With something as elaborate as this why not use python or go? 
https://github.com/upspin/upspin
Use Python or Go for what?
Paraphrase 
Man thank you for your help. I have never used vm or something. Tha is why I don't know where to start. Should I buy VPS?
Do you even have a go path defined? For repos you 'go get' to go too?
That just shows how bad programmers are at handling errors :D
Well purchasing / budget decisions have to be purely your own. But I think it's a good learning experience if you have never done it before. I take it you run Windows as your main os? If so maybe download virtual box and the latest version of Ubuntu-server and test out a systemd service there first. There isn't much to it though, follow my gist in the other comment and just post here if you get stuck.
You're saying that because you're used to PHP - in reality, Go is far simpler to deploy than PHP is.
Here's a method to do something similar that avoids reslicing. https://play.golang.org/p/uGmyQcUqUr
If you use caddy as a web server, it has a built in HTTPS that uses Let's Encrypt. It's pretty awesome as well.
But doesn't this one always grow?
In the Add func we reset the index to zero when needed, so it just wraps around, never allocating new space 
Let's Encrypt certificates are limited to 3 months. If you are in control of your own services, this isn't a problem - there are plenty of tools to automate renewal or even webservers which are able to do this on their own. But if your hoster doesn't support this, you're out of luck and will have to pay a "traditional" CA anyway. There are also other things like wildcard certificates or extended validation certificates which other CAs provide, though the benefit or the latter is questionable at best. Working around wildcard certs can be a hassle with Let's Encrypt though and isn't always possible. 
Yes I use windows. I am aware of using Linux. I use it once in a while. Thank you very much for your support. I will do and tell you. 
If you consider how many php hosting sites there are, it is much simpler that golang. Although I prefer golang, php is easier in that regard. But for golang deployment I prefer Docker.
&gt; But for golang deployment I prefer Docker. Definitely agree here, it's super easy with Docker. &gt; If you consider how many php hosting sites there are I don't see how the amount of hosting sites makes it any easier. You're still dealing with lots of files, and being at the mercy of PHP's configuration on that host, if you're not setting it up yourself. At least with Go, it's just a dump and run kind of situation.
Sorry for the delay, I missed your messaged. I have a different error message now: $ goman -v task No source path in D:\Go\bin\task.exe - task is perhaps no Go binary path is absolute but contains no '/src/' dir: D:\Go\src\github.com\go-task\task\cmd\task EDIT: fix submited: https://github.com/christophberger/goman/pull/5
You should try Go-kit https://github.com/go-kit/kit . Its under active development and evolving rapidly
Some things to improve from a quick look: 1. remove globals https://github.com/hunterlong/AuthorizeCIM/blob/master/authorizecim.go#L10 2. GetTransactionDetailsRequest - I didn't expect this to be a struct, same with other types.
In the case you described, the "functional-like" approach would be preferable. As a general rule, aiming for readability is highly valuable and "good style" in Go too. (By the way: if you choose the opposite pattern in the end, it's preferable to not call it `newSomething`, which by convention is used for functions returning the created object. I tend to use `initSomething` in the rare case I pick this approach; or possibly `resetSomething`, or else, depending on exact semantics.) Regarding what is "more efficient"... in general, it's advised to *"measure first[, and only then maybe optimize based on that]"*. Technically, [`testing.Benchmark`](https://golang.org/pkg/testing/#Benchmark) helps here (there's also some tool to compare results of Benchmark before vs. after code changes, but I don't recall where to find it). It may well show up that compiler would actually optimize both patterns to same code! Anyway, one should also be looking at "measure" in wider perspective, not just of a microbenchmark, but of a whole program. Specifically: is your function going to be ever called in a hot loop/hot path of some code? Or maybe the connections will be pooled, so small performance differences don't really matter much? Even in case of a hot path, won't later calls of the actual SQL queries take long enough to make performance of the constructor irrelevant in comparison anyway? But please note that this comment is specifically aimed at the particular case you asked. If I were to look only at the one-line header/subject of your question, without reading the details, I'd actually answer quite differently! As a closing note, it's especially worthwhile to read the standard library code from time to time, to get some feeling for what's generally observed as "good style". (Though with some caveats in mind, too; e.g. usage of assembly wouldn't generally be a good idea outside of stdlib.)
I can only assume that he wants the actual shell syntax to be python or go, instead of (elvish?)
Please follow the [go community CoC](https://golang.org/conduct#unwelcome_behavior). Racist comments like this are not welcome here.
Something's been rubbing me the wrong way about these and I just finally put my finger on it. The best developers I know do not call themselves "C++ developers". They use what it takes to get the project done (not even "the right tool for the job", because often there are legitimate business and/or engineering reasons why the right tool for the job is not the tool they are using). They might know C++, they might prefer C++, or usually they know enough C++ to be looking for something else whenever they possibly can (familiarity breeds contempt, when it comes to C and C++). I trust the opinions of people who are simply "software devs" better than the opinions of self-proclaimed "C++ devs". I'm glad Murray is looking at Go. Perhaps that will help him become just a "dev" and not a "C++ dev". -jeff
http://tmrts.com/go-patterns/
Preface: I'm not a Go pro. I believe idiomatic go is "only bring in a library if absolutely necessary", and generally avoid frameworks unless you are already familiar with the underlying implementation details, where possible. So for a web server, use net/http and template before using one of the many other frameworks or routing middleware. I don't think most Go projects require a comprehensive framework to accomplish most tasks. Unlike Ruby and RoR that run with DRY principles to a fault (imo), Go is less interested in "perfect" and more interested in simplicity in design. You may also get a better answer if you specify what sort of server? P2P, web server, distributed system, number crunching, DAL, etc. 
Thank you! PR has been merged now.
yea, all of those methods etc. should be a on a struct.
Ah yes of course! I missed that!
Ok, the question makes sense then. I don't see much advantage from doing so, however. Shell scripting is so tightly integrated with shell functionality that they require special syntax anyway (for globbing, environment variables, pipelines, etc). There is just too much "magic" in a shell script. This does not match well with the syntax of programming languages, esp. of statically typed ones.
So far this whole series has quite a few errors and other mishearing statements, which are written with an increasing level of confidence
 answer := go doSomethingThatTakesALongTime() this is invalid syntax
From the author: &gt; I welcome friendly corrections and clarifications. There are surely several mistakes here, hopefully none major. 
&gt; bash: **go-blog: command not found** Isn't this the error? As itsamemmario said, go-blog is not in your path (so either build failed or it's building to a different location/name). This isn't really a go problem, it's a heroku problem. Personally I just cross compile a binary and deploy to a VPS as a service, but if you start from the heroku go example apps, it should be fairly simple to work out how to deploy yours once you have a functioning build on heroku. Have you tried running it locally according to these instructions and it works fine? https://devcenter.heroku.com/articles/getting-started-with-go#run-the-app-locally Have you followed all the instructions (including on dependencies) in that guide?
Yes, it is invalid, and the author knows that too. That is only an example of how goroutine could be (in his opinion). 
I don't think so: &gt; You could use the function’s result, but you’d just immediately start waiting for it, defeating the purpose (I wonder why Go allows this at all):
&gt; **The go keyword doesn’t return a future**. You could use the function’s result, but you’d just immediately start waiting for it, defeating the purpose (I wonder why Go allows this at all):
Yes, from that sentence I assume that the author thinks that: answer := go doSomethingThatTakesALongTime() doesn't return a future, instead, just immediately starts waiting for the result of doSomethingThatTakesALongTime(), defeating the purpose of the go keyword. And he wonders why Go even allows this, which is wrong, because it doesn't allow it.
Yeah, he's saying if your function after go returns a value you will get it instead of a promise/future, which is not true
You should take a look at https://github.com/fsnotify/fsnotify Cross-platform and pure Go.
How do you go about port forwarding? Does it rewrite incoming and outgoing packets like a firewall would, or is it a proxy like in the comment you responded to?
It's hard to help without knowing what exactly is the problem. Have you tried the official [Go tour](https://tour.golang.org/welcome/1) and [docs](https://golang.org/doc/effective_go.html)? Do you find them hard? Have you tried a [book](http://www.gopl.io/)? What exactly is that you do not get? If you are really having a hard time then you should start with the basics before you go about "smart contracts hyperledger fabric".
I read book and watched a lot of videos. Just not making sense to me yet. Maybe there's a better way to approach coding. Idk
Thanks for the info! Just a basic REST-like API server. It might hit the data layer, it might hit a message queue, maybe crunch some numbers. I guess I'm looking more for examples in enterprise environments. I mean, it's easy to hack something together, but creating a flexible server that stands the test of time takes a little more preparation. I figure being idiomatic would help meet that end. 
That was a good read. You're right
Heres a list of golang books: https://github.com/dariubs/GoBooks I really like An Introduction to Programming in Go along with other free starter books you can also get help from the Go Forum: https://forum.golangbridge.org/ and on slack https://invite.slack.golangbridge.org/ 
The best way to approach coding is to code.
I have done it before- several month ago. And it works fine. For some reasons this time it doesn't seem to work. One of friends here adviced me to use it as service. And I am now trying to do it. Thank you for your attention.
When you type `git` in a command prompt window, do you get an error message? If git works fine in a command prompt window, try the same in a terminal pane in VSCode. If `git` fails only there, it seems VSCode somehow reads a different `%PATH%` variable where the path to `git` is missing.
I have Ubuntu desktop installed on the Virtual Machine. Can I do the same here as well? Where do I have to begin?
As shovelpost said, you should define what exactly is the problem.
In this case you'll benefit from something like NGINX at the front as kind of a reverse proxy. This will handle a lot of the nitty gritty that you COULD do with Go if you wanted to but it would be a lot of work reinventing the wheel. Some reading material: https://www.reddit.com/r/golang/comments/5i2vfh/newbie_question_how_does_a_golang_server_compare/ https://stackoverflow.com/questions/17776584/webserver-for-go-golang-webservices-using-nginx-or-not https://stackoverflow.com/questions/16770673/using-node-js-only-vs-using-node-js-with-apache-nginx
Yes, ubuntu desktop also uses systemd. Follow the steps in my gist.
Fair point 
hey thanks! I'll be updating later today, thanks for your input!!
The best thing is just starting to code. Give yourself small projects for fun and you will learn as you try more experiments. 
There's also https://github.com/rjeczalik/notify
You might have made a mistake jumping straight into Go. Its not a more difficult language but there aren't many truly beginner resources. Its much easer to learn a different language and then transfer to go. I would recommend C. CS50 on EdX is a good starting point for code and C. Edit: Every resource I have seen for Go from the "Go Tour" to "An Introduction to Programming In Go" assume some prior knowledge or experience with programming. Edit: I believe this is a result of the fact that Go has been mainly picked up and practiced by talented and experienced programmers. Who don't need the level of help a true beginner does and are less likely to notice small assumptions that they innately understand but that can drive a beginner crazy. Edit: This is not to say you can't start with Go just that it may be more work starting out but on the bright side at the end you may be a better problem solver with a deeper understanding of the language.
FSEvents is not supported on OSX from what I see in their readme.
...but if anyone proves me wrong by designing a nice and usable Go-ish shell script language, I would not complain :)
As I already said, the author expects friendly feedback, however his tone does not sound friendly. https://www.reddit.com/r/golang/comments/6jz0jm/a_c_developer_looks_at_go_the_programming/dji6rlh/
You can get really far with just net/http, text/template, and encoding/json for web apps/APIs. If there's functionality you need you should generally prefer the stdlib to pulling in a third party dependency. I would start with the flag and log packages for cli and logging. Check out other libraries when you start building a feature where the stdlib is insufficient and either augmenting the stdlib or rewriting the functionality is tricky, error-prone, or requires a non-trivial amount of code. The only package I might recommend starting with would be httprouter instead of net/http.ServeMux just because you mentioned building REST APIs and I've found the standard mux becomes somewhat painful to use if you're doing /:resource/:id/:nested/:nid style routing, switching on HTTP method, other RESTy things, etc.
Just a student l straight passthrough. I have rules like: * listen port -&gt; IP address + port It's useful when you have one externally facing server and lots of internal devices that you want to expose to the outside world, but only expose one specific port. The logic is simple: * listen for connections on a specific port * when a connection comes in, open a connection to the preconfigured host and port * spawn goroutines to copy bytes between the two sockets My service does absolutely nothing to the packets, it just copies them verbatim. I've been able to do SSH tunnels, expose video feeds, expose test web servers on a nonstandard port, etc. I work doing embedded stuff, so we set some up for our customers to test with at our headquarters and provide a port off a domain name so our customers can access them. Our ISP controls our edge router and takes up to a day to respond to requests, so I built this to work around that and get services up and running more quickly. It works quite well and has been stable for a year or so.
You can access syscalls and since OSX is Unix based shouldn't that be enough to at least get the basic notifications working? The implementation shouldn't be too hard. Edit: Looking at some quick docs it looks like OSX built on top of kqueue. However it may be easier to just make a binding to one of the several C libs already out there for this. You'll have some overhead with the FFI but probably not enough to really hurt you. Or you can write to a shared socket from a C program that just watches for events so a golang program can read from that same socket to retrieve the events. Lots of options here.
Man this is a bad article
You have a grain of truth in there. I agree we should think of ourselves as developers more acquitted to some tools. But it would be disingenuous to say your experience does not shape somewhat your expectations and proficiency of a language. I think of myself as a developer specialized in C++, (although I have python and java experience) now I'm specializing in Go.
Elvish is implemented in Go, but not Go.
I've used both https://github.com/rjeczalik/notify and fsnotify. Fsnotify is pure Go because it uses syscalls. But it only supports kqueue on osx which is less efficient for tons of files because it needs a lot of file descriptors. rjeczalik/notify does support FSEvents, but it needs cgo to do that because it needs to access the osx core libraries. But you end up with less file descriptor usage when you watch a ton of directories. 
Hello guys, i am newbie in Go. I had this sitemap generator i've built in node.js. To enhance my studies i decided to migrate it to Golang. Before, it was taking 30s to complete (async), and now it only takes ~3s to complete with Go (channels &amp; goroutines). I am amazed so far. I am sharing this link here because any feedback will be great for me to improve as a Go dev. Thanks.
Yeah, I have noticed that most resources for go assume some basic level of programming knowledge. A quick Google search did turn this up though. No idea how good it is, but it looks promising https://www.udemy.com/learn-how-to-code/
Coding is hard.. especially when you're learning your first language. A lot of things don't make sense at first. First you do "hello world" and maybe a simple server, but after that you'll feel like your banging your head against the wall. That's the fact of life learning development. Just keep building things, post it on GitHub, and post that to Reddit. Then others can critique your work. When you hear go is an easy language to learn, that's coming from the perspective of existing developers. When you try to build projects, create a to-do list of the different parts you want it to do. Then figure out how to do each part. Finally crypto currency can be hard. Start with other projects, maybe create a file uploader returning the file meta data. Then try to create a multiple file uploader, again returning the metadata with file size. Just some ideas. And know there is a reason software developers are some of the highest payed jobs... Because software development is friggin hard. Those with a passion for it will persevere through the banging your head against a wall part and learn to create great software.
That does look promising though the amount of hype in the description does raise some flags with me.
Hi, I actually like how much time and effort you are investing into these posts. Since you are being very candid about your experience and open to hearing out opposing viewpoints take the harsher tones with a grain of salt. Speaking of opposing viewpoints.. avoiding the more minor or subjective statements, this hinted to me you may be missing some fundamentals here: &gt; However, you only get the full benefit of this when the work is happening purely in the Go runtime. The book explains that “Goroutines that are blocked in I/O or other system calls or are calling non-Go functions, do need an OS-thread”. So I guess you still wouldn’t want, for instance, a goroutine per network connection, if you are serving many network clients. There is a lot of content here and you probably didn't have time think it through, but this is backwards. I can see how it may make sense to hear "blocking" operations like syscalls for io sound like you would want to avoid too many of them. Because blocking sounds like the CPU can't do other work now. But replace your familiar notion of the term blocking with "yielding" and it will suddenly make more sense. A goroutine waiting for a system call is an opportunity for the scheduler to give another goroutine a chance to work. This means the cost of thousands of goroutines waiting for blocked syscalls is cheap. The cost of blocking operations that will not yield to the runtime is huge for even N goroutines, where N is the number of CPUs. I feel this is a core selling point for concurrency in Go, so perhaps you will reconsider your stance here. It allows you to worry as little as possible about "what" specifically a goroutine is doing and trust in the scheduler to find the most efficient way to fairly run all your goroutines. 
I follow your gist, but where should I place this service and other file?
I also mostly agree with what dtoebe said. Except that I think the basics of programming aren't that hard if you pick the right resources but the moment you go past the basics is like stepping off a cliff. I would also recommend trying to minimize how many different things you try to learn at once. It is very easy to get info overload and not learn something well enough because you are distracted of overwhelmed by the other stuff you are learning.
Alright, to elaborate a bit more. If you literally need to perform an action upon FS event, maybe https://github.com/cortesi/modd will be a suitable solution for you? It builds on the aforementioned https://github.com/rjeczalik/notify library and in my experience works great (at least on Linux). &amp;nbsp; I've worked around the FS events on different systems in the past and, sadly, it's a clusterfuck. Every system has it's own, macOS even has two (by historical reasons, building on BSD, it supports kqueue). Kqueue is no good for many files, as it opens descriptors for every file. FSEvents requires CGo and linking to IOKit, so cross-compilation is out of question. It's also not fully reliable (might skip events under heavy load, known issue, happened to me many times). Windows is windows :-]. The interface is strange and obnoxious, but AFAICT it performs fine, once working. Inotify is probably the best of them, but Linux only. Solaris has something, that I don't even remember the details. &amp;nbsp; Also, be aware that none of these solutions will work for user space FSes, such as NFS or SSHFS (with the exception of NFS and FSEvents, because Apple added support on both sides). If you asked me, I'd just go with the good ol' polling. Anyway, good luck :-). edit: Formatting
https://gist.github.com/cstockton/ac9a95f865607d2b5a2041ba5824eb94#file-steps-sh-L2 Make sure to take your time and digest what I'm doing, that means don't try to just copy paste. I won't answer another question unless: * Copy the Service file into your code editor * Ediy the service file with correct values for your program. * Copy the entire shell script from my gist into your code editor * Modify each line to work on your local virtual machine. * ( for example replace scp with cp ~/Desktop/go-blog ) If you don't know what to edit, do as much as you can and post the result with a comment above the area you are unsure about. Good luck!
To me it sounds like the author is trying to "fit" Go into a C++ mold. AKA he is trying to take a flat head screwdriver and compare it's ability against a Phillip's head. Both serve the same overarching purpose (to screw/unscrew a fastener) yet both accomplish this in different ways (phillps vs flathead). While you can make one or the other accomplish the other's goals it is counterproductive as you have both tools readily available for use. *For example:* &gt; It would be fairly easy to create a future type that uses a channel, then you could write an async method that uses the go keyword and returns the future. But I think it would be nice if Go made this simple case simpler by doing this for us. Maybe it does. Channels solve the problem of safely retrieving values between threads/goroutines; I fail to see the point in wrapping them in order to resolve the same problem. It seems to me like he is trying to fit Go into a C++ box so why not just use C++ instead? 
Yeah, I don't like to use 3rd party libraries if I can help it. This was my attempt at a canonical HTTP service, gained from experience with a few Go projects: https://github.com/otoolep/go-httpd
Shells are normally optimized for a different usage case than programming languages. A true shell has syntax that is strongly optimized for running (external) programs, with decisions such as unrecognized unquoted words being treated as string literals and support for features such as unquoted globbing, even though this steals at least one extremely common character used in expressions (`*`). A programming language's syntax is instead focused on writing expressions, statements, and other internal language features, with choices made on this basis. Take, for example, how shells and programming languages use variables. In programming languages you use variables all the time, so they can be used with bare identifiers (`varname`) and an unknown variable is often an error. In most shells, you must use a special introduction character to use to a variable (`$varname`), and without that the word is just treated as literal text to be passed to whatever. Needing an extra character on every use of a variable in a programming language would make people rather annoyed very fast, because variables are all over your code. But shells use literal text more than variables (as literal text is passed to commands that they invoke as arguments), so they optimize for not making you type extra to use them.
I have changed blog.service Unit] Description=ServiceName Documentation=https://example.com/doc.txt After=network-online.target Wants=network-online.target systemd-networkd-wait-online.service [Service] Restart=on-failure PermissionsStartOnly=true User=turik Group=programusername ExecStartPre=/sbin/setcap CAP_NET_BIND_SERVICE=+eip /usr/local/bin/blog ExecStart=/usr/local/bin/blog -flag 443 [Install] WantedBy=multi-user.target steps.sh #!/bin/bash scp blog.service turik@ubuntu:/etc/systemd/system/ scp $GOPATH/bin/blog turik@ubuntu:/usr/local/bin/ ssh you@example.com sudo su - # pwd: /root # make sure this matches the programusername in service # and DOES NOT start with a digit. groupadd turik useradd -g turik turik chmod g-w /home/turik/ chmod 644 /etc/systemd/system/blog.service chmod 700 /usr/local/bin/blog # If you need to run on port 443 setcap CAP_NET_BIND_SERVICE=+eip /usr/local/bin/blog systemctl daemon-reload systemctl start blog.service systemctl enable blog.service I have created these files in download directory. And when I execute steps.sh I get the following errors. Even if it have worked what should I have expect? Which url should I enter to see it is working?
Ah, so a proxy then like the code above. Don't you need to log accesses on it, or isn't access logging needed for those servers it forwards to? I think I might try that idea out, since I would sometimes like to expose a server inside my LAN to an external host without needing VPN access, because `tinc-vpn`'s Windows client is the exact opposite of the painless experience it is on Linux.
The network stack has a special merged poll'ing interface that solves this, so the article is wrong about that ... but AFAIK it is generally correct that syscalls that can "block" on IO (Eg. stat/read/readdir) will consume an entire OS thread ... so if you have a lot of go routines doing that your program will be blocking on IO a lot, and not doing much work.
The plugin and Gogland share the same functionality, in your case, there's no need to use another product.
You can log whatever you like. I didn't bother, but it would be pretty easy to put out a log of all connections.
Yes we can!
See the explanation of HandlerFunc in https://golang.org/doc/effective_go.html, which is just https://golang.org/pkg/net/http/#HandlerFunc.
That's an interesting way to implement it. I kinda want to try something like that now :P
its been deleted
If you want to learn to code check this out https://www.udacity.com/course/intro-to-programming-nanodegree--nd000
All his responses on his site are amicable. Whatever his thoughts on Go are, he always thanked people who corrected mistakes.
&gt; The network stack has a special merged poll'ing interface that solves this, so the article is wrong about that ... What do you mean special? The networking stack uses epoll because it can be more efficiently integrated into the scheduler. &gt; but AFAIK it is generally correct that syscalls that can "block" on IO (Eg. stat/read/readdir) will consume an entire OS thread ... Syscalls for IO block the currently executing G and M, sure. As do the "special" networking epoll* and every other system call. I'm not sure how it's relevant to my point though? The G would be blocked anyways, are you under the impression there is a single M or finite pool of M? &gt; so if you have a lot of go routines doing that your program will be blocking on IO a lot, and not doing much work. This is incorrect as I explained in my post, only a P is finite. Any given G (goroutine) needs a place to run, which is a M (think os thread) and once it has a thread of execution it needs a one of the P (think CPU core /is scheduler, bound to at most gomaxprocs, p is for processor), so it can make progress in it's execution. At any given time a M may block (i.e. syscall). When this happens the P is returned to the pool so another goroutine may obtain it to make progress on its own task. To be a bit more precise, there is no limit to the number of OS threads that may be blocked in syscalls. If you think about it .. such a design wouldn't be viable (think futex). This is why you rarely have to think about these things, cause the scheduler is in a much better position to prioritize system resources and will likely do a better job than if you try to be clever. Which is great, once less thing to think about, type "go func()" and enjoy free webscale.
Only run the setup script a single time to setup the service. After that all you do is systemctl start blog and systemctl stop blog to bring it up / down. You didn't change your script from scp to cp, you need to just simply make a single file from your vm, in the etcd systemd dir and put your service file in it. After that you just run through the setup steps a single time and your done. If it works you should try to visit your blog from whatever host or IP it's running from. Type journalctl -x blog to see log data, or something like that. I hate systemd to be honest, simply due to making me lookup a bunch of stupid flags to grep some asci text.. so google how to view service logs I have to man journalctl usually for most crap.
conceptually, no. The User object needs to be self-contained, not spilling its guts all over its consumers ;) this is all about modularity and separation of concerns. You can (and should!) write neatly modularised code within a single program, even if deployed as a single service. It gives you the option of separating out modules later. I write my code in nested packages for this reason. So my auth code is a package and imports any dependencies it needs, and I try to keep those dependencies as few as possible. Other packages import the auth package if they need to authenticate a user. Later, if you need to move the auth package to a separate service, you can write a stub auth package that calls it and provides the same interfaces to the rest of your system, so the rest of your code is untouched by the change. I would even separate the User display endpoints from the Auth package code (because they're actually separate functions of the system). This also helps keep the Auth dependencies low, because it's not dealing with http.
What is the purpose of this construct ? No web programming tutorial or book I could find explains the purpose of HandlerFunc. 
In the context of HTTP handlers, one benefit is that you can implement the `http.Handler` interface simply by wrapping a function with `HandlerFunc`. Alternatively, you would have to define a struct (probably empty) and adorn it with your function implementation. You can also create your own handler call signatures (maybe to include request, response writer and a db connection or next middleware) and conveniently wrap them for consumption by the http stdlib. Negroni does this. https://github.com/urfave/negroni
What are you returning to the user for the URL requested on their behalf? Are you generating the request to the downstream server or passing along the request you received? If you're passing the unmodified/slightly modified request you received directly to the downstream server and returning the unmodified/slightly modified response you probably want a reverse proxy. If it's something else then probably not.
May I ask why you chose the import path of "cirello.io/errors"? I usually just assume people want to mine peoples IP addresses since github already has some decent [stats](https://github.com/cstockton/go-conv/graphs/traffic).. just lacks an IP address or ability to set cookies if opened in a browser. So the only gained benefit (for the package author) is access to information beyond what is provided by github. Typing doesn't matter people copy and paste the go get a single time and goimports handles the rest. But the drawbacks are clear: * Some more security conscience developers won't even bother trying the package. * Some developers that may want to use your library may not be able to due to corporate firewalls. * Git over ssh isn't available, nor the security along with it. That said, [this function](https://github.com/ucirello/errors/blob/master/errors.go#L61) seems like an experiment that may have gone wrong? :) I say this since in the godoc you need to define multiple rules, describe the types it accepts, warn about panics, describe what happens when the same T is sent twice and finally describe behavior for zero values and I feel like I should read it again to make sure I didn't miss something! I would probably take a step back from the nice look at your API's call site and think about the cognitive load, potential damage from mistakes (panics or missing error info) and how easily they could happen. It seems to me all the function does is assign a "e.Op" and associate the root cause of "e.Err". Why allow it to be done multiple times when only the last one counts? Basically my point is I see no tangible benefit from the signature of E(op string, cause error). If you want to just make op and cause optional- maybe this would be a nicer API? E(op string, cause error) Op(op string) Cause(cause error) Self documenting, type safe, no panics. Just food for thought. Happy coding.
The *Client* type in http package is all that's needed. There is a full example in the http package: [https://golang.org/pkg/net/http/#example_Get](https://golang.org/pkg/net/http/#example_Get) For more insight, check the source code for *Get* function in http package; you'll notice it uses the *DefaultClient* which is an instance of *Client*
There are some new ideas in there (e.g., the Match function). I wonder if they would make a good addition to the errors package at [`github.com/pkg/errors`](https://github.com/pkg/errors).
The latter is more common. It is easier to test (sql.Open a local/in-memory/mock DB in test and give that to the client) and allows you to reuse the same sql.DB instance which is generally a good idea because it actually represents a pool of connections and is safe for concurrent use. EDIT: just realized you said you were doing the dbConnection() call in the constructor. It's often a better idea to pass the handle to the database as an argument to the constructor and do the sql.Open call in main or your test. Generally makes the whole system easier to test and reduces coupling.
It's just a .jpg image. Returning the image and nothing else.
This automatic dereferencing behavior for struct fields is mentioned in https://golang.org/ref/spec#Selectors. Probably worth taking a look at the other rules in that section since they can be a little tricky at first. :)
That sounds more like a "thread pool". A supervisor is generally more about handling failures.
Okay, then it's probably sufficient to do something like the following in your handler: res, err := http.Get("http://example.com/image.jpg") if err != nil { ... } defer res.Body.Close() io.Copy(rw, res.Body)
Not so unusual when u are working with json and you want to implement the marshaller for your own types. func (y *YourType) MarshalJSON() ([]byte, error) { 
Yes. For the full picture this example is missing an interface because this is especially useful in combination with a **single function interface** (like http.Handler). With this pattern in order to write various handlers implementations we don't need to create named struct for every case. It's enough to write a function and wrap it in the adapter (like http.HanderFunc, in the example above Fn).
&gt; May I ask why you chose the import path of "cirello.io/errors"? It makes the package name independent from the package hosting. IMHO it's a best-practice and more people should do it. Right now, if github goes belly-up, 90% of the go ecosystem would probably just… die. If everyone would use vanity-import-paths, they could just re-upload their package to gitlab or their own hosting and change the meta-tags on their own page. It also means you can, for example, redirect `example.com/deep/package/path` to `godoc.org/example.com/deep/package/path` and deliver a fitting meta-tag for `example.com/deep/package/path?go-get`; leading people who just type in the package path to the docs (github will 404 if the package isn't the repo-root). In short: Lots of good reasons :) [edit] also, the drawbacks you give seem kind of red-herringy, at best? &gt; Some more security conscience developers won't even bother trying the package. This makes zero sense. The info about where the code is hosted is transferred via tls and if you run their code, you obviously have *some* trust in the package author… &gt; Some developers that may want to use your library may not be able to due to corporate firewalls. I never saw any firewall that would use an https-whitelist, much less one that would include github. &gt; Git over ssh isn't available, nor the security along with it. Of course it is. The repo is hosted on github.
Ah, I know exactly what you mean, the use case and purpose. Been testing a few POC's for this myself for the past year or so. My focus has mostly just been with Linux and Windows but not OSX so I have not run into what you speak of. I first tested fsnotify ( https://github.com/fsnotify/fsnotify ) but did not like how it worked on Windows. Then I found Notify ( https://github.com/rjeczalik/notify ) which worked much better. Sadly I have not had enough free time to go further but I have big plans. For Windows use cases I highly recommend you take a look at USN Journals, https://blogs.technet.microsoft.com/tip_of_the_day/2015/03/28/tip-of-the-day-reading-the-usn-journal/ . It is definitely how any file monitor should interface with Windows for this task. Btw, are you planning on open sourcing the tool in the end?
A simpler option is to use an nginx or caddy server as a reverse proxy 
"but go doesnt have generics"
If I manage to do it, yes. Most likely it will be on GitHub.
Wow, this is how the go community that I am part of behaves? There is __nothing__ in this comment that warrants multiple down votes.
The upspin authors created the `upspin.io/errors` package for their specific case. The way I understand it, this is what they mean when they say "[Errors are values](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=16m13s)". Use the whole language to program with errors and construct a solution for your project. The package `upspin.io/errors` even copies some parts from the standard library so that they don't have to be imported again because "[A little copying is better than a little dependency](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=9m28s)" and uses the build tag "debug" to gather the stack trace. By taking that specific solution and trying to "sell" it as a generic one you are doing a disservice. Not only you do not let the community learn the meaning behind "Errors are values" but you are also "asking" everyone to use an extra dependency while they don't have to. I think we as the community need to take great inspiration from `upspin.io/errors` and start programming with our errors instead of trying to create the absolute one-size-fits-all generic errors library.
functions are first-class types. No different from strings, integers, structs, or maps. You can add methods to all of them, too :)
I'd look at Caddy instead of NGINX - it's written in Go and is more compatible if you want to get into doing funky stuff. I'd completely second the "no third party libraries unless you absolutely need them" advice. The standard library really does have everything you need for this, and having dependencies will reduce your "stand the test of time" quality. Keep it simple, straightforward, easy to understand, and don't be afraid of a bit of boilerplate or repetition. Good luck :)
If the interface you want to implement only has one function and likely no state, instead of defining an empty struct that implement that interface, a HandlerFunc is provided to implement that interface solely by providing a function. This is a time saving technique to implement an interface that has one function using a function. I know I said function a lot :)
In my experience from teaching a few people to code, it takes a good six months of daily practice to finally feel like "OK, I got this, I can do this". There's a spot about 1-2 months in where everyone feels like they're never going to understand this, and the temptation to give up is huge. To be able to code vaguely competently, you need to have about a dozen "things" understood. You start by learning one, and that's OK, and then you hit another, and you cope. By the time you get to your fifth new thing to learn and cope with, you're beginning to get disheartened. By the time you hit your tenth "what? I have to know about this, too?" thing then you feel like you'll never get it. But fairly soon after that, you stop hitting new things and you get to master the ones you've already met. In other words: don't despair, it does get easier. You can do this :) Don't worry about learning the syntax for each command. Every programmer has to google the syntax sometimes. The standard library is really well documented because we all forget how the bloody things work all the time. Understand how pointers work, it's probably the single hardest thing for newbies to get their heads around, but once you grok it you'll wonder why you ever thought it was hard. Then you can face channels with some vague confidence ;) good luck :)
reverse proxy can be used as a load balancer, cache, validator/hardener, gateway.
You should put a salary bracket in the ad for people not to waste their tine.
It's by design. It all depends on all the other skills one can bring to the table and the assumption is that if you are looking for a position in Dublin you already know the market well. We do not want to lose potential candidates just because of "salary filter". We're quite flexible on that regard.
Is they considered dirty, like changing the primitive prototypes in JS?
It lets you decide if you want to use a type+method to implement the `ServeHTTP` method and thereby implement the `Handler` interface, or just make a quick function to implement it. It adds flexibility to the architecture.
It's a pity no remote allowed.
You can't do func (s string) Foo() { } You have to have a local type to do it, so you're never adding methods a type that's not from your package. What you can do is create a new type that's analagous: type Goo string func (s Goo) Foo() { //valid } So there's nothing dirty involved.
&gt; Now I want to use Google OAuth2 authentication. Use [golang.org/x/oauth2](https://godoc.org/golang.org/x/oauth2).
Any slow-paced tutorial to use the library? 
We're quite small so every new employee will help defining company culture thus remoting is not an option at this time. 
&gt; are you under the impression there is a single M or finite pool of M? Yes, assuming M == OS thread, then my understanding is that it is limited to: https://golang.org/pkg/runtime/#GOMAXPROCS ...can you link to anything that implies M can grow without bound?
Yes, try reading the page you linked. &gt; The GOMAXPROCS variable limits the number of operating system threads that can execute user-level Go code simultaneously. There is no limit to the number of threads that can be blocked in system calls on behalf of Go code; those do not count against the GOMAXPROCS limit. This package's GOMAXPROCS function queries and changes the limit. Gomaxprocs=P in my example. Again you would deadlock if you only had gomaxprocs of possible blocked systemcalls.. think about it. Imagine 8 goroutines all acquire a Mutex to wait on a 9th that will unlock it, on a 8 CPU machine you would be deadlocked since your 8 goroutines are all waiting for a system call to return. The pkg doc at top of my [trace/encoding](http://godoc.org/github.com/cstockton/go-trace/encoding) package has several links if you want to investigate. Best one is the doc in src/runtime for high levelschediler details 
In that case you should say salary negotiable or provide a range rather than a hard figure. Having nothing in there about salary I think will filter more candidates.
&gt; This makes zero sense. The info about where the code is hosted is transferred via tls and if you run their code, you obviously have some trust in the package author… To you, sure. Would you like me to explain or will it be like prior discussions? I'll copy paste a snippet from a recent reply so I don't waste my breath, the subject was someone hosting their own download: &gt; You're statement is not true because in this case the "self" is a single individual, verse an entire well funded technology company with a entire team of trained security and systems engineers. Supported by intrusion prevention / detection systems, disciplined patching schedules, auditing mechanisms, resources to fund third party specialists to perform forensics in the event of a compromise, on and on. Do you honestly believe your "chmod" (ugh.. lol) compete with that? At the end of the day of EVERYONE hosts their own git repos you would have a much weaker overal security posture in the Go ecosystem. You now have N systems maintained by developers of all kinds of experience. Lots of surface area, lots of work to do to ensure patching and security maintensive, less resources because developers may run other projects on the endpoints, it just introduced a ton of risk. &gt; I never saw any firewall that would use an https-whitelist, much less one that would include github. I have seen many, some companies have very strict web access policies that operate on IP white lists. I'm not saying I agree with the practice, but I am saying it's a reality. &gt; Git over ssh isn't available, nor the security along with it. When the pkg is a simple redirect, sure. But the URL isn't self describing so I can't infer it's a redirect without investigating. So I must assume it is self hosted to be safe. 
what they said :) in fact, this is generally looked on as A Good Thing.
Cool, thanks for the info. 
Thanks for the advice. I can update the post in here but not in the ad itself.
Np
I kinda like them. My initial instinctive negative response has given way to admiration. We all have preconceptions about languages, especially "new hotness" languages like golang. The author is simply being honest about his preconceptions. You can see him trying to fit Golang concepts into his C++based world. And not liking the things that are different - that's just how humans work. I'd be fascinated to read the sequel though... "A programmer goes back to C++ after a year writing Golang" and see how his perceptions have changed :)
yes this is basically how http handlers are structured...it really feels like this feature was added to address some brittleness in the applicability of the handler interface
see https://godoc.org/golang.org/x/oauth2#example-Config
I would still use a reverse proxy. You get the expiring headers, content type and such. You'll also get the return code for free in case of a 404... Unless you want a completely new set of headers.
&gt; At the end of the day of EVERYONE hosts their own git repos you would have a much weaker overal security posture in the Go ecosystem. We're not talking about hosting. The import path is orthogonal to the hosting location. I don't get how it's (at all) relevant for security, what the import path is. The goal of binding the import path to your own domain is to retain ownership over it. What DNS-server is authoritative for that domain, where the HTTP connection is terminated, where the HTML containing the meta-tag is actually hosted and where the git repo is made available are all orthogonal to that and each other. For example: Make Google your DNS provider and host the HTML and the repo on AppEngine. You still have this one entity with an enormous security budget that you claim to be interested in, all the while still maintaining complete ownership over the name of your package and being able to change each and every one of these puzzle-pieces if need be. A github.com import-path compares unfavorably on every single metric here. You do not own github.com, so they have complete ownership over your import path. You are bound to their DNS provider, to their web-hosting and to their git-hosting. You are buying into exactly this setup (or more specifically: Whatever setup github chooses for you, with or without your consent) for ~ever. (Whether or not the advantages of centralized git-hosting outweigh the disadvantages is another can of worms. I have opinions, that are both more nuanced than you seem to assume, but also have no place in a discussion about import paths) &gt; I have seen many, some companies have very strict web access policies that operate on IP white lists. I'm not saying I agree with the practice, but I am saying it's a reality. I don't believe this to be true in the specificity necessary for your argument, but I also don't think arguing that brings us very far. Especially as, personally, I wouldn't worry about this too much either way. If a company wants to block access to my code, I don't see that as my fight to fight. Especially as my domain likely will host additional resources (like documentation) for my project, that developers will want. So making purely the code accessible doesn't help a lot anyway. (If my stuff *would* warrant fighting that fight, I'd probably host my stuff in the tor network or something of that magnitude. The tor project is better qualified to circumvent censorship than anything else I could come up with) &gt; When the pkg is a simple redirect, sure. But the URL isn't self describing so I can't infer it's a redirect without investigating. So I must assume it is self hosted to be safe. This investigation consists of doing "go-get -d" and "git remote -v" to see what was cloned. That hardly seems to be a significant overhead to sate your need of security. But I also think that there are far more concerning attack-vectors than someone redirecting a go-get; if you are concerned about that, I claim that you are likely misallocating your resources. Anyway. You are obviously assessing risks very differently from me and choosing very different tradeoffs. That's fine. I was just answering your question of why the author chose a custom import path; there are real, practical benefits to that. You might not value those benefits very much and do the tradeoffs differently, but hopefully you can at least accept that other people will have a different, equally valid opinion.
I don't know about your specific case, but if I was looking to go there, I wouldn't start from here... The kind of mindset that goes with EIP (and in fact Enterprise Java in general) doesn't really work with Go. The idiomatic Golang for converting a data stream from one format to another would be to write specific handlers for both ends and probably a channel with an interface in the middle (I don't know the specifics of your use case). Go tends to subscribe to the point of view that complex configuration is better off presented as code. In other words, rather than relying on extensive XML configuration of generic classes, we tend to write specific implementations. The interface model tends to support this, because inheritance isn't clouding the picture. But YMMV, do the thing and see if it works :)
There is a lot to be learned from rails, even though it's old news. like, things I've taken for granted as I've explored a few frameworks: - not writing SQL due to thorough Query Interface - human-readable logging in the console when developing - framework support built-in to the testing library - even just having an ORM (even if it does have performance issues) My least favorite server-side technology is javascript, as it lacks... about everything. :-( I don't like re-inventing the wheel, and when it comes to getting stuff done, I'll gladly use a bundled set of tools, and learn how to use them.
&gt; We're not talking about hosting. The import path is orthogonal to the hosting location. I don't get how it's (at all) relevant for security, what the import path is. Yes we are talking about hosting.. the hosted endpoint happens to redirect to another repository. Not understanding this may be the key reason you don't understand the points I raise. This import path is the canonical authority for how a package is retrieved, it's what allows you to change from github.com to gitlab.com in your example. But this is the VERY behavior that I don't like. At any given moment if your webserver is compromise (the thing serving the redirect) then a malicious repo may be injected. So- the import path defines where the repo is hosted. This has everything to do with security. Being a redirect is just one possible outcome of many. &gt; A github.com import-path compares unfavorably on every single metric here. You do not own github.com, so they have complete ownership over your import path. You are bound to their DNS provider, to their web-hosting and to their git-hosting. You are buying into exactly this setup (or more specifically: Whatever setup github chooses for you, with or without your consent) for ~ever. Yes. A company in the business of hosting repositories. I'm not sure how you can think that anything good can happen when thousands of developers of varying experience all enter this business. &gt;_&lt; With them- comes hundreds of hosting companies, some may be shared, some may have exploits on old cpanel systems, some may also run a old ass version of word press, on and on. The surface area for an attack on a specific repo goes from &lt;github&gt; into every possible permutation of all the factors of web hosting. We can agree to disagree here, but I don't think your opinion properly measures risk. I feel you are defending your own personal experience and use of this paradigm, which may be perfectly safe, I'm not saying it's impossible to securely host your own repo. I'm saying there is risk with advocating people do this.
Too cryptic for me. 
This looks great !
Full tutorial from start to finish https://cloud.google.com/go/getting-started/authenticate-users
Also try this: https://medium.com/@cgrant/golang-oauth2-google-example-for-web-and-api-59187ce8b119
Well, I disagree that the author has been amicable (he says 'thanks' a lot, I suppose) but hypothetically we aren't downvoting for disagrees regardless.
&gt; Not understanding this may be the key reason you don't understand the points I raise. I understand perfectly well. Please do not assume, that because I disagree with you, I am less competent. If you don't feel comfortable assuming a basic level of competency in me, maybe you feel more comfortable doing that for Russ Cox. He also uses custom domains in his import paths, so he obviously also came to different conclusions from you. &gt; But this is the VERY behavior that I don't like. We are talking about different things. I am talking about ownership of the string "example.com", whereas you are talking about hosting the web-server that serves web-traffic behind the IPs that string resolves too. And I'm trying to point out, how completely independent both are. &gt; So- the import path defines where the repo is hosted. No, the import path is a string identifying a repository. A server is where the repo is hosted. And a (potentially different) server hosts the HTML used by go-get to discover where that server is. And a (again, potentially different) server hosts and serves the DNS records that users ask what "example.com" means to find that HTML. All of these pieces are independent of each other and all of those pieces are independent of what the user actually types into their CLI to fetch your source code. You are still trying to build the dichotomy between "github.com hosts everything" and "everyone runs their own webserver that redirects to a repo location", but that is not what we are talking about. I tried to illustrate that by explaining how you can use a custom domain while having everything - DNS record, HTML and the repo - hosted by a single company. In the Google-setup I tried to outline above, fetching the repo means making a TLS-connection to a Google server that is probably colocated in the same datacenter as your ISP and then fetching *everything from this one company's servers* (contrast that, FWIW, with github, where all of this will still involve at least 4 or 5 different companies, from their DNS provider, over their CDN and traffic provider to the company that probably owns the datacenter they host their servers in). I'm trying to point out, that you don't have to touch - much less run - a single computer to host a package under a custom domain. You only have to sign the buying-agreement for that domain; all the other things can be outsourced to literally anyone you want to (including github, if they'd offer). &gt; We can agree to disagree here, but I don't think your opinion properly measures risk. Again, stop assuming incompetency. I am properly assessing the risk and I agree that the risk is, what you say it is, *in the scenario that you are talking about*. But that scenario has nothing to do with the question of whether to use custom import paths or not. That scenario is about the question of whether to host things yourself or not. &gt; I'm saying there is risk with advocating people do this. I'm not doing that. I'm only advocating for people to own the import path, nothing else.
This guy just links to another tutorial at http://skarlso.github.io/2016/06/12/google-signin-with-go/ which I tried its github repo and got 500 error. 
This is for GAE, not useful for me. 
So creating new types with `type` is not just aliasing ?
Are you the Rob Pike that I think you are ?
It is very difficult to help you when you do not explain the problem. The medium article I linked has a summary of the code needed to use oauth2 with Go. Did you try it? Did you encounter any problems with it?
You should really try learn the basic workings of oauth2 before using it. It's not that complicated.
Some background on oauth2: https://gist.github.com/mziwisky/10079157
[here you go](http://lmgtfy.com/?q=How+does+oauth+work) You need to internalize oauth better. Both tutorials in this chain are simple enough to get you going in go, but not if you don't know where you're going 
the authnetication code is independent of app engine 
Not *just* aliasing, no. When you create a new type this way, any methods that exist for the base type are not available on the new type, but new methods can be attached to the new type. There's also no implicit casting, only explicit casting, making it even less alias-like, and making it useful for things like enumerations.
https://golang.org/ref/spec#Type_declarations It an take a bit of work to understand clearly, but: type A string func (a A) Foo() {} func S(s string){} type B A // B does not have Foo() // You cannot use B in S(...) // You CAN convert B to string or A 
I think you may misunderstand the purpose of a [reverse proxy](https://en.wikipedia.org/wiki/Reverse_proxy) - if you're on the client end, you're not talking about a reverse proxy at all, which sits at the server end. You're talking about a normal forward proxy. Load balancing, etc would generally be handled by a reverse proxy on the server side, not by anything on the client side. If you're receiving HTTP requests and forwarding them somewhere else, then you are acting as a proxy. If requests are initiated some other way (e.g., user runs your program, which makes an HTTP call; or you receive an HTTP request, and in the course of some processing, you must make a call out), then you are not acting as a proxy, you are acting as the client.
**Reverse proxy** In computer networks, a reverse proxy is a type of proxy server that retrieves resources on behalf of a client from one or more servers. These resources are then returned to the client like they originated from the Web server itself. Contrary to a forward proxy, which is an intermediary for its associated clients to contact any server, a reverse proxy is an intermediary for its associated servers to be contacted by any client. Quite often, popular web servers use reverse-proxying functionality, shielding application frameworks of weaker HTTP capabilities. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
And it's worth mentioning that the banging-your-head-against-the-wall part *never stops*. It's just that the better you get at development, the more you accomplish *in between* periods of cursing.
This is why I've abandoned the standard mux in favor of... nothing. I hard-code routing. A mux is a runtime configuration of completely static behavior, bringing all the performance penalties and very little benefit. On the other hand, I can chain a series of standard HTTP handlers, stripping path prefixes as I go, and deliver a highly efficient router with little effort, no dependencies, and support for whatever URL path hijinks I decide to implement, including stuff like a dynamic path parameter that is itself a path, something dynamic muxes are hard-pressed to offer. Is it harder to change the API this way - rearranging the routes requires a little refactoring. This, however, I don't mind at all; it should be at least as difficult to change my API as it is for my clients to change to accommodate it. Routes, once set, should rarely (if ever) change.
&gt; I understand perfectly well. Please do not assume, that because I disagree with you, I am less competent. If you don't feel comfortable assuming a basic level of competency in me, maybe you feel more comfortable doing that for Russ Cox. He also uses custom domains in his import paths, so he obviously also came to different conclusions from you. This is why I don't bother replying to any post you make, it's always so personal for you. I didn't call you incompetent, I said you are failing to understand my key point. You said this has nothing to do with hosting. Well, you are wrong. Sorry. **A import path corresponds to its location inside a workspace or in a remote repository**. This remote repository is used by the Go toolchain. This repository must be hosted somewhere. This is not my opinion, it's just a fact. Since it's a remote location it brings along all the surface area with it. &gt; At the end of the day of EVERYONE hosts their own git repos you would have a much weaker overal security posture in the Go ecosystem. You now have N systems maintained by developers of all kinds of experience. Lots of surface area, lots of work to do to ensure patching and security maintensive, less resources because developers may run other projects on the endpoints, it just introduced a ton of risk. That is my position, you have taken the discussion into a completely different direction where you can feel like you're coming out victorious, which is "ITS POSSIBLE TO DO SECURELY". Sure, I never said otherwise, my prior response I made that very clear: &gt; I'm not saying it's impossible to securely host your own repo. I'm saying there is risk with advocating people do this. But here you bring in "Russ Cox" to prove to me I'm wrong? How does him hosting his own repo allow you to assume that he thinks if every gopher hosted their own import paths there is no more security implications involved than with what we have today as a majority of people using github.com. He may believe that, he may not, but what right do you have to form his position for him? It's very odd you are comfortable doing that. From here I'm not even bothering with the rest of your reply, where you are continuing to try to "prove" you can securely host repos. Again. Never said otherwise. Settle down, turbo. I know you host your own repos, I've seen the import path before on reddit, but I sure as hell wasn't going to mention it to you. You're not under attack by me posting this, I'm not saying you can't securely host your repo, I'm not saying you are incompetent. I'm going to go back to ignoring you for a while until I feel you can argue on technical merit without things being taken so personally. Happy coding bud.
Good point. I updated the article to mention that. I wouldn't necessarily call it simpler. One option involves a bit of code, another involves setting up and configuring another component and introducing additional point of failure. 
I purchased this: https://smile.amazon.com/Programming-Language-Addison-Wesley-Professional-Computing/dp/0134190440/ref=sr_1_1?ie=UTF8&amp;qid=1499285738&amp;sr=8-1&amp;keywords=golang and started doing programming exercises here: http://exercism.io/languages/go/about back in February and never looked back. However. I've also been programming for ages so YMMV with this approach.
[removed]
I'm not sure how well suited Go is to new programmers, but the official go tour is very good.
I'd say, first of all figure out what you want to do. Go is a great language and I love it but - like all languages - it's not universal and won't fit everywhere. Go is great for the web. Connecting things, running servers, talking to servers. It's also pretty good for command line apps, daemons, tools and stuff that has to be reliable. It's not a scripting language and isn't really suited to knocking up a quick script like you would with maybe Python/Ruby/Perl. It's growing in the data science community and things are appearing for UI but it's primarily a server-sided language. If you're still interested then great! Go check out the gobyexample site, the Tour of Go and some videos by Rob Pike and Francesco Campoy - I'd recommend "Concurrency is not parallelism" to get your head around the concepts of Goroutines/concurrency and the "Just for Func" series which is a great way to learn programming patterns and good practices. Hope you enjoy the language! I'd recommend VS Code with the official Go tools extension (by luke-something, forgot the name but it's definitely a luke) the static analysis and formatting tools for Go are really what make developing with it so easy.
Pro tip: golang might be too much to a newbie. I would recommend a language geared for learning such as BASIC (FreeBASIC will work for you as well.) In my not-so-humble-opinion, most programming languages are quite similar in the end (despite basic libraries and syntactic sugar) and you'd be well-served to learn basic programming with a language geared to newbies, that can then allow you to tackle other languages after understanding the basic underpinnings. Starting out from scratch in golang or C or python will leave you with basic knowledge gaps, doing-things-by-recipe-you-found-on-google, and some bad practices cos nobody told you any better. In the end, I do not think this will be a fast endeavour if you would like to become a competent developer. FYI, I started messing with BASIC thanks to my dad getting me a computer and making sure I had some shtuff available always before I was 10 years old.
&gt; I said you are failing to understand my key point. But you are mistaken. I understand your key point. &gt; That is my position, you have taken the discussion into a completely different direction Excuse me? You asked, in the post I originally replied to, the question "May I ask why you chose the import path of 'cirello.io/errors'?", coupled with these claims (among others): * I usually just assume people want to mine peoples IP addresses since github already has some decent stats. * So the only gained benefit (for the package author) is access to information beyond what is provided by github. * Some more security conscience developers won't even bother trying the package. * Git over ssh isn't available, nor the security along with it. So, you pretty much directly attacked OP, accused them of mining their users data, for having purely mischievous objectives in choosing their own import path and, moreover, that *there can't be any other benefit*. You also made some pretty strong claims about choosing an import path under your control has security implications, all of which are demonstrably and categorically wrong. All I did, was provide you with a good, technical rationale why people are actually usually choosing import-paths (namely, that it decouples the identity of their package from where it's hosted) and that the alleged security implications do not apply to the choice of import path (again, *that, and only that, is what you where directly referring to*). When you later talked about hosting, I also tried to show to you, how the question of where the stuff is hosted and the security thereof is independent of the actual import path used. That is not "a completely different direction". If you feel that the discussion changed directions, you did not read my initial point correctly, because I started this discussion to point out *exactly these things*. Notable, you didn't ask "why are you not hosting your repo on github" or "why are you running the HTTP-server to redirect go-get yourself", but you where *specifically* referring to the import-path. And that is just bogus. Your whole first post, btw, is already tellingly bogus on the surface (and if you actually bothered to check, instead of diving directly into your personal opinion, you would've noticed); because the actual setup of that domain seems to be pretty much what I suggested; the domain is hosted on AWS, the HTTP server is hosted on the Google cloud and the repository is hosted on github; all of which are big companies with exactly the same track records you are pretending to be interested in. If your complaint was actually genuine, this was 100% the wrong post to make it on. I am sorry. But I am, now, officially angry with you. If you understood what I was saying, why didn't you just say so (and if you didn't even more so)? Why not just say "oh, sorry, that was a mistake, I was actually talking about hosting your repository and the webserver yourself, instead of having a cloud company do it for you. Not about what the import path is. My bad"? Why not just say something along the lines of "yeah, sure, there are tradeoffs to be made; I personally would come to a different conclusion, but I can see your standpoint"? If even someone you consider an asshole, like myself, can do that, why is it so hard for you to muster that level of self-reflection? &gt; But here you bring in "Russ Cox" to prove to me I'm wrong? No, to get you to consider that maybe the issue isn't as clearcut as you are making it to be here. Russ Cox using custom import paths doesn't prove you are wrong. It just proves that *the issue isn't as black-and-white as you are pretending it to be*. Which is literally the point I was making from the very beginning. I recommend a level of self-reflection. I am too angry to deal with someone as stubborn and egomaniac as you are positioning yourself here. (and yes. You are not going to do that. It's easier to shrug me off as not understanding what you are saying. Never mind my actual qualifications)
I assume it's not your first renderer and you've ported it from some other language? The code is clean, very readable and way shorter than I expected for a working path tracer. There are some minor nitpicks, such as why do materials return struct values, which you pass later as references, instead of returning pointers in the first place. Not seeing any tests in a go app is unusual. Other than that, good job, that doesn't look like the first thing you've written in Go.
&gt; I am sorry. But I am, now, officially angry with you. **This is why I don't bother replying to any post you make, it's always so personal for you.** &gt; I recommend a level of self-reflection. I am too angry to deal with someone as stubborn and egomaniac as you are positioning yourself here. &gt; **I recommend a level of self-reflection.** I am too angry to deal with someone as stubborn and egomaniac as you are positioning yourself here. &gt; I recommend a level of self-reflection. **I am too angry to deal with someone as stubborn and egomaniac as you are positioning yourself here.** People won't always agree with you, if you get physically angry when they don't I think you are unfit to give recommendations to others on how to reconcile mental state. I'm not responsible for your emotions, grow up man, you're a professional, start acting like it. ¯\\\_(ツ)_/¯
This looks amazing! Code looks fine at the first glance, good job, man!
&gt; This is why I don't bother replying to any post you make, it's always so personal for you. I was the purest image of calmness, carefully crafting responses to you. I took the time to carefully point out and dissect where I perceive the misunderstanding that leads us to talking past each other. Which you then dutifully ignored, as they contradicted your self-view of being right. And instead, you accused me of changing the subject and not arguing on technical merit. And now having the audacity of telling me I should act like a professional. If you don't want people to be angry with you, don't treat them unfairly. Again, I recommend a iota of self-reflection. Read the thread, read my arguments, mull over what you actually wrote and how it relates to what I said.
Thanks for checking it out. &gt; why do materials return struct values, which you pass later as references, instead of returning pointers in the first place. Do you mean Surfaces? I see what you mean there with the repetitive "scene.Add(&amp;pbr.Cube" Also, +1 to tests... I just want to sort of get the "shape" of it right before I start writing formal tests. Not my first renderer, but I'm no expert. I play with a lot of graphics stuff in other languages (and now in Go!): - http://www.playfuljs.com/ - https://github.com/hunterloftis/pathtracer
Thanks! It's been a great, fun way to dive into Go.
Hi, I'm the author of this library. If you have a moment I'd love any feedback or code review comments you may have. Feel free to PM me if that's easier for you. Thanks!
At first glance through e.g. camera.go, for now I'd say rather just fairly small stuff: - "Camera simulates a camera" - hmh, personally don't like this much. Doesn't really say anything, not worth the letters in my opinion. Could try maybe dwelling a bit more on the properties it has, what is described about the camera, maybe why? why this and not something else? - as mentioned by someone else, tests would be advisable (and esp. consider *table-driven tests*) - Focus's godoc is non-understandable to me; I have no idea what the func really does (at first I thought maybe it's something similar to what LookAt does) Looking at https://godoc.org/github.com/hunterloftis/pbr/pbr: - you don't seem to have a *package doc* for pbr/pbr. Especially, I don't really know how to start using the package without some intro guide. - personally, I'd rather avoid putting the package in `pbr/pbr/`, I'd just put it in `pbr/` - by convention, consts should preferably be named same as normal variables (thus `Bias` or `bias`, not `BIAS`, etc.) - looking at `Cli` in godoc, I have no idea how to use it and what it does - "Hit describes an intersection" - of what? - "SampleFrame samples a frame" - ok, this much I guessed already from the name, but I totally still don't understand what the function actually does (kinda like the infamous `i++; // increment i` comment) and how to use it etc. *edit:* - ok, looking somewhat more at the API: I'd highly recommend trying hard to hide as much internal stuff as possible from the public API. E.g. for `Sphere`, methods `Intersect`, `MaterialAt` and `NormalAt` don't seem of any sensible use to the package user, they seem purely internal details, so they just introduce noise in the API. It would be cleaner and easier to understand if you made them private. Unless they are required for some broader 'Shape' interface or something, but I don't see one here (and anyway, in such case I'd put them (i.e. the Shapes) in some subpackage to group them more explicitly). - Renderer's `Rgb`, `Write`, `WriteRGB` seem partly redundant; also by convention it's good to try fitting some of the stdlib interfaces/func names, e.g. `WriteTo`, and avoiding clashes (e.g. I'd usually expect `Write` to have a signature fitting `io.Writer`; otherwise I'd try inventing a different name); also try using interface like io.Writer instead of taking name of a file - this way you give the user more possibilities. *edit 2:* ok, first heavier issue: [never ignore errors](https://github.com/hunterloftis/pbr/blob/62671fbab79ed75f0b04e2fdda0028a0dc052d73/pbr/scene.go#L67). And anyway, you should rather take an io.Reader instead of a `file string`. I see you may have copied this fragment of code from example code in rgbe package's readme, but that's very not good. Actually, that's the reason why ignoring errors even in examples is often frowned upon. *edit 3:* in Glass etc., describe in godoc what's the meaning of the *gloss* parameter and what values one can put there. Other than that, it's cool you've added such constructors. Ok, enough for now, that should give you some ideas for the direction to go with docs &amp; API cleanup. *edit 4:* ouch, looking at Scene.Add() - the parameter is of type `surface`, which is unexported, so user won't know what he/she can actually put there. You should make the `surface` interface exported. Also, you could make Scene.Add() take variable number of arguments, this should remove some repetitiveness from the code in cmd/ subdir.
The test you do have isn't written in Go, so someone on Windows can't run it without using a non-standard terminal. 
You might also use an existing tool to handle the watching and process the events in Go: https://github.com/emcrisostomo/fswatch 
Idea: create grammar/vocabulary profile based on known Rob Pike sources, then plug in comment history of this account to generate confidence rating. Even if it's not Rob, and they're just really good at pretending to be him, you can just act like it is and refer back to your confidence rating if that's ever called into question. Who needs truth when you have math?
Go to your local Google Developer Group meetup https://developers.google.com/groups/directory/
You were calm until you realized I wouldn't concede to your view, because we disagree. You told me the only thing that would have kept you calm: &gt; Why not just say "oh, sorry, that was a mistake, I was actually talking about hosting your repository and the webserver yourself, instead of having a cloud company do it for you. Not about what the import path is. My bad"? I'm not going to agree with a statement I find false. You accuse me of the same exact thing you are doing- refusing to accept an opposing viewpoint that contradicts your own in the name of being correct. But there is a difference between how we each react to this. I am not angry, you are. I didn't make it personal, you did. &gt; And now having the audacity of telling me I should act like a professional. You said I needed self reflection and was being a stubborn egomaniac. So I said you need to act more professional, out of necessity not audacity. &gt; If you don't want people to be angry with you, don't treat them unfairly. I accept fairness is relative which is why in a technical debate I am responsible for only one participants emotions, my own. &gt; Again, I recommend a iota of self-reflection. Read the thread, read my arguments, mull over what you actually wrote and how it relates to what I said. I seriously consider my character, actions and motives constantly. It's a redundant recommendation at face value, because it's not what you're asking me to do. You're asking me to succumb to your perception that I'm in need of absolution, certain I can only arrive to it through a change of my character. It's the only way you can rationalize how I could possibly disagree with you, after all you've completely negated every argument I could possibly make from your perspective. You somehow through the emotional response to someone disagreeing.. discard your engineering principals and don't even consider I feel the same way about a different position. You discard any chance I arrived at a different opinion through rational thinking, it HAS to be malice, ego, character or mental issues. You then go on to accuse I did those very same things to you, like say I brought up hosting first. No. It's the very first thing you said in the entire thread, literally the very first sentence: &gt; It makes the package name independent from the package hosting. I disagree with this statement, and believe it was the main reason we disagreed. You took me thinking it was why we disagree as calling you incompetent, how I have no idea. The simple fact is I don't think it's separate, I think it's possible to be separate- but that is an implementation detail. The import path is the repositories remote location and should be subject to the same security practices and criticism for trusting endpoints today. I tried to explain this and feel I did, but you were so emotionally triggered due to criticism towards a practice you followed that there was no possible way to discuss anything with you. You were angry and "triggered" from the beginning, I'm not sure there was a outcome that you wouldn't have found a way to be upset, it's all fascinating really. Happy coding.
You are using a statically typed language and expect it to behave like a dynamically typed language. Not possible because of how schema is in your db. Try using something like graphQL to avoid such problems but it means more code at both client and server end, pick your poison. 
Give GraphQL a try, which is a Data schema for something similar. YMMV
Nope, it creates a new type. This is actually handy for getting type errors on purpose when mixing up types. E.g., &gt; type FooId uint32 or whatever. The next version of Go will add aliases: &gt; type OtherInt = int OtherInt and int will be two different ways to write down the same type.
check out this [thread](https://www.reddit.com/r/golang/comments/6l86jb/need_help_please/?utm_content=title&amp;utm_medium=hot&amp;utm_source=reddit&amp;utm_name=golang)
Ill second the VS Code suggestion. I think VS Code is the best thing microsoft has done in years.
https://tour.golang.org/welcome/1
Thanks for reply
thanks for reply
all of your comments lead me to believe you should stop programming in Go and stick with interpreted languages.
Simple is good. I think a lot of developers lose sight of how simple microprocessors are. Go feels good, to me, because it reminds you how simple they are, while making it easy to avoid cutting your fingers off. It also makes it easier to write and reason about code that operates asynchronously and can take advantage of today's rapidly growing core count. Thanks AMD! I absolutely adore that Go spans the gamut from sub-RasPi IoT processors to AMD EPYC and beyond. It works incredibly well with Docker. Statically linked binaries lead to sub 10M Docker containers which make the world a beautiful place. :-) All of this comes from its simplicity and a clear vision of how code, and coders work today, and will need to work tomorrow. And it's really, really, really fast. :-)
There's only one way I know to learn a language: write a program with it. If you have code you want to write, jump in!
It's super elegant, yet not so simple where you are limited
Sorry for this stupid question. What is a "format preserving encryption" ? What format does is preserve ? 
&gt; how is go so cool? * [Go at Google](https://talks.golang.org/2012/splash.article) * [Less is exponentially more](https://commandcenter.blogspot.gr/2012/06/less-is-exponentially-more.html) These can pretty much answer your question. A more direct answer is that Go fills a niche between statically typed (boring and verbose) and dynamically typed (fun!) languages. It's probably much more fun to initiate a variable in a dynamically typed language than in a statically typed one because you don't have to specify the type. Go keeps that static typing but retains some of that fun. Example: a := 3.14 And there's also some conveniences like trailing commas, no semicolons, making something public simply by using a capital letter and of course `gofmt`. It is the combination of many little things like these that writing Go code feel good.
Stick with the standard library and only bring external packages if you really, really need them. No need for frameworks. 
I started go for a hackathon and used Gin, it was easy and nicely documented. 
I've build a very small api and it was an ease. It was the first thing I've written in go so you can do it too :) The only dependency I had was a database driver
I used gorilla/mux as the router on my api project. It is quite nice if you need a bit more for the endpoint paths. I would not call it a framework 
This is the type of router I typically use https://gist.github.com/KevBurnsJr/39d7233ec21989c4bb2b50ad95f6788b Adding data to url paths for API requests is only necessary in cases of backward compatibility. You can forgo mux by adding any required data as query parameters and maintain a very simple router. /acct?id=dave This URL is just as RESTful as the mux alternative /acct/dave but it's easier and faster to route.
I am curious about this as well. The README links to a NIST document that says, &gt; A block cipher mode of operation—or simply, mode—is an algorithm for the cryptographic transformation of data that is based on a block cipher. The previously approved modes for encryption are transformations on binary data, i.e., the inputs and outputs of the modes are bit strings—sequences of ones and zeros. For sequences of non-binary symbols, however, there is no natural and general way for the previously approved modes to produce encrypted data that has the same format. &gt; For example, a Social Security number (SSN) consists of nine decimal numerals, so it is an integer that is less than one billion. This integer can be converted to a bit string as input to a previously approved mode, but when the output bit string is converted back to an integer, it may be greater than one billion, which would be too long for an SSN. Which sounds a bit strange to me - I never have heard of an encryption algorithm that changes the data that it is supposed to preserve across encryption and decryption.
I was hoping to see a full-stack Go project, but the only Go part in the stack is a CLI tool "for hackers after all". The rest is mostly javascript (Node.js, Electron, React, Redux).
Perhaps ponzu is an option: https://github.com/ponzu-cms/ponzu Working api up and running in ~3 minutes, + you have to implement some simple interfaces. And the docs are awesome: https://docs.ponzu-cms.org Edit: i think ponzu is not the best option if you want to learn the language and the standard library
I assume this means the format is preserved on encryption. So if an SSN is encrypted then the output still looks like an SSN. Most normal schemes would pad the SSN and result in random block sized bit strings that definitely would not fit a database field that validated as an SSN.
If you'd like in-path parameters, this is worth building atop: https://github.com/julienschmidt/httprouter You're unlikely to need anything else beyond DB drivers.
Hello, I thought it was cool to see capitalone is using Go. I took a quick look at the code and saw a lot of extra allocations so I made [pull#3](https://github.com/capitalone/fpe/pull/3) to illustrate the techniques, but did not implement them across both packages. I also didn't realize there was a CLA until after I made my changes, I'll sign it if you wish to use them, if not no worries it was my mistake. I'm not familiar with this algorithm, but I did not see any glaring mistakes, assuming some of the areas you don't do bounds checks are covered by other invariants. I do think that if you were open to larger changes- you could remove a majority of the allocations by using the utf8 package backed by a byte slice. It has decode/encode and length functions you could leverage here, allowing you to remove the string in / out interface of rev. Just food for thought, it's not a big deal but 250 allocs is a lot for a crypto operation on sub 20 len strs. Happy coding.
What the performance difference between js and go? It would be interesting to compare the two in single-threaded and multithreaded environments and if golang performance scales linearly with the number of worker threads.
Not at all. It's not even a feature, just something that fell out of an orthogonal language design. Any concrete type can have a method. A function is a concrete type. Therefore functions can have methods.
I am no longer going to talk about the personal stuff here; I don't want you to use me voicing my displeasure about your mistreatment as further excuse to ignore the technical arguments made (and yes. You are ignoring them. You literally said so yourself, above) &gt; I disagree with this statement There is room for disagreement, when one is talking about how to weigh different factors or what importance one is placing on different arguments. But there is no room for disagreement about facts and that choosing a custom domain makes the import path independent of the hosting location is just a simple, technical fact. It is *not* independent for import-paths rooted at "github.com", "bitbucket.org" and a handfull of other sites, because the go tool has a hard-coded mapping for those domains from import path to repository location; but for all other domains, literally every single piece of infrastructure is exchangeable at your own whim. It would be good if you start acknowledging that. When I talked about how to set up a hosting at Google, I wasn't trying to demonstrate "that you can do it securely". I was trying to demonstrate this factual independence. That is, why I'm saying that the independence of import path from repository location is *demonstrably* true; because I demonstrated how you can change one without changing the other. I agree that different choices for those piece of infrastructure can have security implications; that is a fact too. And there can be agreement or disagreement of how to weigh those security implications against the benefits of having the hosting exchangeable - weighing the importance of different facts is the very definition of an opinion. That is, where we can "agree to disagree". But you can't just call a denial of basic facts "disagreement". &gt; The simple fact is I don't think it's separate, I think it's possible to be separate- but that is an implementation detail. It can only be an "implementation detail", if it's independent. That is exactly the point; you criticized the choice of import path. But the arguments you gave are exclusively based on hosting locations, which are, in your phrasing, "an implementation detail". And it just so turns out, that the very instance you chose to voice your criticism on, chooses an implementation that all of your criticisms do not even apply to. I'm advocating exclusively for the use of custom domains in import paths; not for the distribution of infrastructure. I'm advocating for decoupling the identifiers of packages from domain names; if you distribute a package, you should make sure you actually own the identifier and it doesn't become invalidated by the intentional or accidental censorship by some company. For example, it would be totally cool, if, say, github would start offering a "go domain hosting" service, where you can use them as the NS of your domain and they will serve the go-get discovery HTML on it for you, to point to your github-hosted repositories - because that would still mean, that if they go belly-up, you can just use a different service. Now, again, you can have the opinion that the independence of the import path from the hosting is a disadvantage. You can have the opinion that people *should not* own the name of their package, but that some company should, because you don't trust them to handle that property carefully. That is an opinion, a moral judgement, that's fine (I disagree with that opinion, but that's just weighing different risks and advantages differently). But that would still be very different from your original message, where you, among other things, alleged that there can not be any motivation for using a custom import path other than data mining. &gt; The import path is the repositories remote location That is, still, demonstrably and categorically false, unless we understand very, *very* different things under what a "repository" or a "location" is. And I tried to make that distinction very clear. In absolutely no physical way has the import path anything to do with any location of any source code, discovery information or… anything technical or physical. The import path is a string to look up in a table to look up the location. Where that table is hosted, what that table is saying about the location and everything else have nothing, at all, to do with the import path. You can criticize choices people make about those, but basing that criticism on the choice of import path is just plainly wrong.
As someone who is not a pro-programmer, I think this is the first language where I feel I know most of the language specifications by heart. It makes me feel in control of the language, very few gotchas! I think that the creators of Go were very brave when they created this; not being afraid of violation conventions.
No it's not for GAE only. You need to create an app and configure it in GCP Console to obtain OAuth credentials.
Thanks for clarifying. Apparently I misunderstood the cited text that talked about converting the SSN integer into a bit string and back into an integer again, which superficially sounded like a complete encrypting-decrypting cycle to me.
In my opinion, most enterprise developers are focused on business. Therefore, any language or framework that give them a head start in accomplishing their task, in this case integration, would be more readily accepted and adopted into an organization. Most developers in an organization like bank (where technology is not their main competence) has very limited technical resource to build framework from scratch due to either time or technical limitations or other limitations. So technologies like Java and its ecosystem (like Apache Camel) would have better chance of adoption rather than Go. I only wish and hope Go community would go in that direction because I am also looking for opportunities to adopt Go in our organisation where ever and whenever possible. 
Oh and that feeling of accomplishment, even after years old development, is amazing! Makes it all worth it.
Go is patently boring. Literally the main innovation of golang is enforced consistent formatting, which along with a small language makes code universally readable. I also enjoy how it pisses off the academic types so much (ignore 30 years of research!!!).
In fact, 3 days later from the post, I become a master of Golang.
Each of those languages are also incredibly complicated compared to Go though. Is there any simple statically typed language (like C) with type inference?
&gt; I also enjoy how it pisses off the academic types so much (ignore 30 years of research!!!). [This is what you get if you implement every single research paper into your language](https://en.wikipedia.org/wiki/C%2B%2B17)
**C++17** C++17 (or C++1z) is the informal name for the next revision of the ISO/IEC standard for the C++ programming language. The C++17 specification reached the Draft International Standard stage in March 2017, and is not expected to undergo any major changes before publication of the final standard later in the year. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
No language with unlimited power can be elegant. A language creator must make a choice between simplicity/elegance and power.
Antlr has a Go backend, try it
I could not disagree more. Python is a very easy language for beginners to pick up and I don't see how it would lead to any more gaps in knowledge than learning BASIC would. To be honest, this recommendation almost seems like you are trying to be different for the sake of being different. I don't see how learning BASIC will give a newcomer any special knowledge and will only delay them learning a marketable skill. On top of that, there is a wealth of information and tutorials on learning Python, which I think is the most important part. While you can find stuff on BASIC, it is substantially less than Python. At the end of the day, I don't think the first language really matters that much. Python is probably the easiest to learn, but also starting with C or Go is no big deal either. Millions of developers used C as their first language and they turned out fine. Maybe Go has some tricky parts that don't make sense to a beginner but that's fine! They don't need to learn and use the entire language right away. A beginner to programming could spend an entire school semester just playing around with basic Go syntax and learning how to build functions (similar to how schools teach Python in an intro to programming class), there's no need to dive into interfaces or mater goroutines.
Despite the name, we try to keep https://twitter.com/golangweekly rolling things out every day. It's also all based around items we've seen and reviewed, not automatically reposted from anywhere.
I regret not taking exact measurements when their behavior was 1:1. Roughly, though: - 1x JS =&gt; 5x Go =&gt; 15x Go + Goroutines - https://twitter.com/HunterLoftis/status/875783656765247488
That's true; it's just a bash script that runs and times the go program with common options. I should document how to run it without bash though.
Thanks for the detailed feedback! *GoDoc stuff*: I only wrote anything at all because my editor complains when I don't. I should go through and flesh it out. *Table-driven tests*: Thanks for the keyword, I haven't seen this before. *Package docs*: I see I can document a package by writing comments above it. Since lots of files compose a package, how do folks tend to choose the file in which to document the package? *pbr/ vs pbr/pbr*: Since root dirs get filled with metadata (.gitignore, .gitattributes, readme.md, etc) I like to keep source files separate. The only way I could think of to do this with Go's "package == dirname" convention was to use `pbr/pbr`. *Const naming*: Got it! *Hiding Intersect etc methods*: You're right! I wrote those methods before I realized that lowercase is still package-wide (vs file-wide) scope. *Renderer write interface*: Good suggestions; I'm not really very familiar with the stdlib interfaces at the moment, but I'll see if I can make `Renderer` a `Writer`. *Scene.Add*: Great suggestions, thanks!
Well, there is a standard for writing tests in Go that can time and benchmark things cross-platform, and wouldn't require you to point out how to run the tests at all with the testing package.
Not a stupid question at all! It's a newer mode of encryption, it's not quite as established as something like CBC mode, and it's more niche. What others have said below is correct - the ciphertext (encrypted form) and the plaintext *look* similar because they are the same format. Format can mean a lot of different things of course, but from the perspective of this library and in my opinion the NIST spec, it means radix/base. The SSN example is classic. For a given key, an SSN "123456789" may yield an FF1 ciphertext like "482959288". The "format" is preserved even though the output is in fact encrypted.
bummer man.
*or he's a kid...*
I find [Lua](https://www.lua.org/manual/5.3/) very similar in this regard. Somewhat surprisingly, authors of both Lua and Go arrived at quite many similar non-mainstream decisions and patterns.
You need a pet project to code up, that's my preferred way of learning a new programming language. Over the last couple of years I dicked around with go enough to know the syntax and how to read other people's code, but it wasn't until I had a few small, spare-time projects under my belt that I felt I really *knew* the language. Go is a popular language for microservices architecture and for writing simple web services in general. If you end up working with go you'll probably be doing those things, so read up and practice! Above all else, Always Be Coding.
One problem with generics *vs. simplicity* is that it's hard to make them useful†, while not spiralling into making them a [separate Turing-complete language](https://en.wikipedia.org/wiki/Greenspun's_tenth_rule) with [horrific syntax](http://www.boost.org/). † — where you'll always be accused of making them "crippled" until you *do* make them Turing-complete.
CAMLight
I have to disagree with you to an extent. I don't think Go is a good starting point for a beginner for the same reason you say Python is. There just aren't enough true beginner resources for go yet. I agree about Python, and C being good and I agree about BASIC being kind of questionable. But I think it's less important to worry about the first language and more important to find a course or sierries of courses on Edx, Coursera, Udacity, or Udemy. Check That the course is well reviewed from multiple sources and learn what they teach after that you can worry about languages and where you want to expand.
Quick reply: *Package docs:* Personally I usually try to choose some kind of most important file in the package and put it there. But especially if you write a longer intro comment, the convention is to create a separate file named `doc.go` and put only the (long) package comment there. Search for such files in the stdlib (I suppose the longest is in package fmt, but I'd expect most packages there have it). *Hiding Intersect [...]:* Actually, after *edit 4*, I believe you should rather keep them public, and make the `surface` interface public instead (i.e. `Surface`). This would allow other people to add their own surfaces and have them handled correctly by the renderer (as long as you didn't cheat by downcasting in your implementation). Personally, I'd then strongly consider putting them (i.e. `Sphere` etc., maybe also `Surface` itself but not necessarily) in a separate package, e.g. `pbr/pbr/shape` (shorter name than `surface`; also then `shape.Surface` does actually make quite much sense). *Renderer vs. io.Write*: I meant rather making it an [`io.WriterTo`](https://golang.org/pkg/io/#WriterTo), i.e.: func (r *Renderer) WriteTo(w io.Writer) (int64, error) or even better, make it return an [`image.Image`](https://golang.org/pkg/image/#Image), so that a user can then decide whether to [encode it as a PNG](https://golang.org/pkg/image/png/), or maybe as a JPEG, or display on screen, or whatever else. The idea of interfaces in Go feels somewhat like pipes in Linux if used properly. *Consts:* one additional question here is do you even actually need/want them exposed in the API, or are they again just a private implementation detail. 
I think we are on the same page
Correct, the input and output character space is the same. It's certainly a different way of doing encryption, but it fills a need in regards to adding field-level encryption to legacy databases and/or PCI tokenization
So admittedly I wrote this package mostly from an algorithm correctness standpoint as I don't yet know about how to optimize from an allocation perspective. That said, from a cursory glance, your PR gave a great intro on how to do that, so thanks for such a quick PR! Can you elaborate on the bounds checking and other potential larger changes? Or better yet, feel free to make GitHub issues for it? I think it'll be easier to continue a long term discussion there. Thanks!
Python is a terrible language that teaches some horrible practices.
Go is nice because it's about concurrency. Remember about Unix. Even though the UNIX system introduces a number of innovative programs and techniques, no single program or idea makes it work well. Instead, what makes it effective is the approach to programming, a philosophy of using the computer. Although that philosophy can't be written down in a single sentence, at its heart is the idea that the power of a system comes more from the relationships among programs than from the programs themselves. Many UNIX programs do quite trivial things in isolation, but, combined with other programs, become general and useful tools. They in a sense made this concept easier for any programmer. It's about relavancy and the continual ease of use. Remember inheritance used to be a coding pattern as well.
Extending the above comment, I'd suggest: 1. **https://tour.golang.org** — indeed 2. https://golang.org/doc/effective_go.html 3. https://golang.org/ref/spec (don't be afraid, it's surprisingly short!) 4. Ideally, read all https://golang.org/pkg, or at least the ones most interesting to you and/or important. The rest can be left for periodical reading, or even just on "as needed" basis. The docs are *very* good in the packages, many of them strive to have some kind of a guide and lots of example snippets. 4. Then, for "intermediate" level, to learn more about good practices, style, common patterns, etc., I'd possibly suggest, in somewhat random order: - https://blog.golang.org has some worthy articles about some patterns and style, mostly in older articles (though OTOH they can sometimes be slightly outdated, esp. pre-1.0 ones) - https://github.com/golang/go/wiki/Style - https://golang.org/cmd — !!! many highly useful tools! for many of them, docs are unfortunately split between golang.org and `--help`
Really neat project! https://github.com/hunterloftis/pbr/blob/master/pbr/sampler.go#L36 This rand variable is being passed down a couple of calling layers before being used. A simpler way is to seed the rand package in one file with func init() { rand.Seed(time.Now().UnixNano()) } and then when you need a random number, just use rand.Float64(), no need to create *rand.Rand and pass them around. https://github.com/hunterloftis/pbr/blob/a14583bfcdbf2ce027caea1b517275cb316775ee/pbr/cli.go#L69-L71 Since the only action is incrementing across multiple goroutines, take a look at the sync/atomic package, seems a more natural fit. 
What's wrong with turing-complete generics? It's not like anyone would ever actually leverage that except for proofs of turing-completeness and toys/experiments. A reasonably well designed generic class or function is typically pretty simple to use. C++/Boost is really one of the examples where people went nuts on generics, but even in Boost many of the often-used parts are fairly straightforward to use... Besides, seeing what hoops people are forced to jump through in absence of generics makes me really question the whole 'no generics = simplicity' premise... Seems more like a wishful thinking type of thing... 
&gt; I think a lot of developers lose sight of how simple microprocessors are. This is either a very good humour or a case of extreme naïveté. I have fingers crossed for the former :) 
Every so often my thoughts while coding in Go are: You have to love the devs! They created a modern language that is simple, yet powerful. They made so many decisions that I maybe don't like, but they have always a rational explanation and I respect that. Nothing is perfect (except reddit). As a kid I had some contact with BASIC, Turbo Pascal and C. Never could wrap my young mind around it. Started learing PHP around 16 yo, and for me it was great at that time. It was easy to learn, easy to use. Years passed, and with dev experience I understood that PHP is more poop than gold, but still, it worked. Again, years passed and I found out how I can make the poop at least look like gold. Tried to learn other languages many times (python, ruby, C#) but so many things I just couldn't understand fully. After months of coding, I always had the feeling that I was to silly or the language was too weird for me. About a year ago I took a closer look at Go. Just a few days in I had the feeling that I could - with enough sweat and time - do anything with it without getting knots in my brain. When I couldn't understand something, I took a look in the sources and noticed "hey, that's not rocket science!". Try to understand some C# sources and you will probably favor to pull out your pubes with a tweezer - at least if you're slow like me.
&gt; makes code universally readable What does this code print? func main() { a := make([]int, 1, 2) b := a a[0] = 1 fmt.Println(a[0], b[0]) a = append(a, 2) a[0] = 2 fmt.Println(a[0], b[0]) a = append(a, 3) a[0] = 3 fmt.Println(a[0], b[0]) } Not all Go code is as obvious as you would like to believe, and the rabbit hole of unexpected behavior goes surprisingly deep in my experience writing Go professionally for my full-time job. &gt; I also enjoy how it pisses off the academic types so much (ignore 30 years of research!!!) "Academics" were the ones who did all of the language development 30 years ago. Dennis Ritchie was a PhD-holder who created the C language, which is the most direct inspiration for Go. I'm not sure why using academic research from back then is somehow better than using research from the last 30 years... and there have been some *significant* advancements, but if it makes you feel like a rebel, then cool story. I'm not saying Go is a bad language, but I am saying that your attitude towards the possibility of improving programming through research is puerile.
The capital letter thing needs to die it's such a fucking meme
Will that make the various goroutines block? Initially I was just using the standard `rand`, and my concurrent version was actually slower (!) than the single-threaded version. After hours of debugging I discovered that the standard `rand` [uses mutexes to be thread-safe](https://blog.sgmansfield.com/2016/01/the-hidden-dangers-of-default-rand/), and since `rand.Float64()` is one of the most often-called functions in the renderer (called literally billions of times), that mutex was *destroying* performance. That's when I started instantiating a new `rand` instance for each Sampler and passing it down. I would love a method that doesn't involve so much argument-passing, but at the same time the explicitness is nice (and clear). Or for [default rand to have smarter concurrent behavior](https://github.com/golang/go/issues/9221).
The Go target was released with ANTLR version 4.6 end of last year. It is still new-ish and feedback is welcome. 
Likely meant the interface that is provided to programmers to interact with them, rather than the design of the IC.
This really isn't a Go issue. It more of a kernel issue which is why, like you said, twiddling with syscalls and modifying the socket is required. You need to tell the kernel what to send into the socket. A alternative may just be using a redirection rule in IPtable/nftables to redirect all traffic to a certain port on any IP address to your regular Go socket.
Hey! I know Francesc Campoy made 2 videos about the context package. I haven't watched them myself they are on my todo list :) but I have watched a lot of his other videos that I can recommend so hopefully this can help you out. Video 1: https://www.youtube.com/watch?v=LSzR0VEraWw Video 2: https://www.youtube.com/watch?v=8M90t0KvEDY 
I've used [goyacc](https://godoc.org/golang.org/x/tools/cmd/goyacc) with some success. I had to learn more about yacc to use it, but it worked. Also I had to write my own lexer, but that wasn't hard for my particular grammar. Rob Pike has a [video](https://www.youtube.com/watch?v=HxaD_trXwRE) about lexical scanning in Go that could also help.
Came here to recommend Francesc Campoy's videos... +1!
Nice I'll check them out thanks
https://blog.golang.org/context
RemindMe! One Week
I will be messaging you on [**2017-07-13 15:41:40 UTC**](http://www.wolframalpha.com/input/?i=2017-07-13 15:41:40 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/golang/comments/6lkw3q/parser_generator_for_antlr_or_any_bnf_grammar/djuw5hn) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/golang/comments/6lkw3q/parser_generator_for_antlr_or_any_bnf_grammar/djuw5hn]%0A%0ARemindMe! One Week) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! djuw5y5) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
Direct link to the [Go Antlr README](https://github.com/antlr/antlr4/blob/master/doc/go-target.md)
G2 includes various improvements for using in Kubernetes including built-in Prometheus ready metrics. G2 also implements scheduled jobs via cron expressions.
I actually thought this was an ironic post the first time I read it.
Correct. Modern processor implementations are fantastically complex, but the operations they perform are extremely simple.
Why?
Thanks /u/akavel, /u/plectid, /u/allhatenocattle, /u/Sythe2o0 for your code reviews. I've updated the project based on your feedback: - The [top level API](https://github.com/hunterloftis/pbr/blob/master/cmd/cubes.go) is much nicer now. - It has [package docs and better godocs](https://hunterloftis.github.io/pbr/docs/pbr.html). - I've updated the [readme instructions](https://hunterloftis.github.io/pbr/) with build, test, CLI options. - The Renderer returns an image.Image in [Rgb()](https://github.com/hunterloftis/pbr/blob/gh-pages/pbr/renderer.go#L38) and [Heat()](https://github.com/hunterloftis/pbr/blob/gh-pages/pbr/renderer.go#L52) for end users to use however they like. - The Cli is now [responsible for writing to pngs](https://github.com/hunterloftis/pbr/blob/gh-pages/pbr/cli.go#L72) - I also replaced some [magic numbers with constants](https://github.com/hunterloftis/pbr/blob/gh-pages/pbr/constants.go#L9).
Same here
Struct embedding is the way to go.. At the barest level, it is just "inheritance".. As far as I know, sqlx can do this... You tell sqlx to map the relationship on "loading from the db" by struct tags (reflection ish).. So basically, you convert your person struct to this type Person struct { ID uint64 `db:"id"` FirstName string `db:"first_name"` LastName string `db:"last_name"` Location Location `db:"location"` } Edit --&gt; I forgot to mention you have to make use of `StructScan` to get the data into the `User` Struct Edit -&gt; /u/ChristophBerger has a link to what embedding really is
Since you mentioned net/ http, I'll give you a related example. Think of a scenario where you have a HTTP service that needs to perform a bunch of expensive operations whenever a new request comes through. For example, you might start a sync/errgroup to issue a bunch of requests in parallel to some backend microservices. Since some of those backend services could be congested, you might even issue some duplicate requests and take the response that comes back first. Then, when all the results come through, you might start an expensive computation to combine those results before returning a response back to the user. Now, what happens if the user drops out whilst you're halfway through all this **expensive** work. Ideally you want to stop everything as soon as you realise that the work is no longer necessary. Contexts allow you to achieve this very easily. The context exposed by net/http request gets cancelled if the request times out (you can configure this at server creation time) or if it detects that the remote connection was killed. If you propagate the context through your request processing code paths, you can easily detect when it has been cancelled (via ctx.Done()) and return early without doing the remaining work. Of course, you can add your own timeouts and explicit cancellation hooks as well by wrapping the original context using convenience methods provided by the context package. Hope that made sense. 
I think Go does a great job of saying "how much unnecessary complexity and confusion can be avoided in a conventional, imperative programming language." But to be sure, you can still write confusing code if you want to. And mutable state combined with unhazy ownership is fertile ground for confusion (as in your example). I expect there to someday be a language combining FP or rust-like ideas with Go's radical simplicity, and it'll be awesome.
yeah it's a combination of different stack, golang will be part of it
Please use a subject like "Looking for ..." in the future for this kind of a post.
Leave host empty and it'll listen on all local IPs. The rest is not a Go question.
You cannot emphasize the word "legacy" enough there. This has no place in a sane world..
That does make sense. Nice to have a scenario to go along with the documentation.
&gt; but the operations they perform are extremely simple U wot m8? :D Even if I only consider the interface, I still wouldn't call it simple and definitely not "extremely simple". AMD64, for example, contains hundreds of instructions that can be used for all sorts of weird tricks (consider `LEA` for example and many others). After all, AMD64 is the CISC type instruction set, which _literally_ means _Complex instruction set computer_. But even with RISC-type CPUs, things don't really get much simpler. You've got delay slots, which admittedly aren't rocket science, but typically mess up newbie minds. Consider the way large integer literals (ie. 64 bits) are encoded on RISCs. And then particular CPU oddities; consider ARM for example, with its ARM vs Thumb vs other states where different instruction sets apply in each state. Or SPARC with its register windows and the weird stack bias (stack and frame pointers have a bias of `0x7ff`). Then there's the whole chapter on multicore stuff, such as atomic instructions, fences, cache coherence... And then there's loads of other stuff, really, this short comment doesn't even scratch the surface... If you think instruction sets / CPU interactions are "extremely simple", you either have no idea what you're talking about whatsoever, or you've got huge amount of low-level experience and have gotten to a level where it indeed seems simple... But that won't be the case for most people. _edit:_ typos
What is an example of a ceremony jwt-go has that you think is painful / unnecessary?
I've got [an implementation of JWT-based session authentication](https://github.com/lpar/jwtauth) you might find helpful. I recommend [go-jwx](https://github.com/lestrrat/go-jwx) for your library.
hey gar44, one option is https://github.com/go-chi/jwtauth - which does use jwt-go v3 under the hood
Ah, I didn't realize that. I've never used rand anywhere enough that it caused a material slowdown. TIL. Cheers.
yeah, it looks much cleaner. though the X in jwX is a bit scary! 
Well I don't want to learn yet another router to do the jwt. 
I'm not 100% sure I've been using it right, but I made some middleware that adds session and user info to the context on a request, so downstream handlers have that available automatically. It works fine, but it does feel like I'm using a sledgehammer to crack a nut.
I thought it was still pinned to v2.7? Has that changed very recently? edit: nevermind, seems like it changed yesterday (and I was just checking the status on the v3 updates yesterday afternoon). Thanks pkieltyka!
I would actually prefer building the API using Golang over Node.JS. Javascript is my least favorite of all the languages I work with and the development experience is the least friendly (Especially if you want to TDD). The reason I chose to go with JS on the server side is that it's the friendliest for beginners and more people can relate to the streams that way. When I did Golang over the streams, you can see the interest is going down because people feel it's "too advanced" So, Golang will be used for the CLI and probably the USB communication (and maybe other parts). I would love to do a series that is full stack golang writing a server side completely in Golang. If you have an idea on what to build, please feel free to come over to our subreddit and add it: https://www.reddit.com/r/FullstackNetwork/
This most definitely has a place in the world of PCI (payment card industry) tokenization. That's something that has become increasingly relevant. If you look at some of the work Voltage Security (HP Enterprise) has done, these algorithms are quite relevant to them
I understand your point, but just like any language, you HAVE to understand some of the mechanics of language to read it. Go's definitely not as readable as something like python, but if you understand the behavior of slices and how append is implemented (abstractly), then that code you have there is second nature. Also there was no need for the rebel comment. It's unnecessarily hostile
talking about "enjoying pissing off academics" isn't hostile but saying that the person enjoying pissing off academics enjoys being a rebel is somehow hostile? your definitions of hostility are interesting. I mean, "rebel" is exactly the attitude they were going for. &gt; then that code you have there is second nature I have programmed in many languages on many platforms for the past 10 years, and I've been programming professionally in Go for the past six and a half months. Now that I've done a case study on how Slices work, I *understand* why it happens. I do not agree that it would ever be considered "second nature", and it is not a good thing. Any other language would have a [push method](https://doc.rust-lang.org/std/vec/struct.Vec.html#method.push) that does not require you to state the name of the slice twice, and I don't know of any other language that will *alias* the vector type's internal pointer accidentally. It is *very* surprising behavior, no matter how much justification the Go community tries to provide for it. I do believe there are definitely use-cases for Go, but it isn't some revolutionary language for most cases, and it has some big problems that I would love to see get addressed for Go 2.0.
Hostility towards an arbitrary group of people doesn't justify hostility to the person. Yours was personal. But enough of that. I'm only a second year student for computer science, and I understand the behavior of that program by looking at it. Believe me, I'm no genius, and I've never done any 'case studies' on how a slice works. As for the append function, I believe it was mainly done for compiler/runtime reasons. You're not wrong, go is a very niche language, and it does have some weird syntactical choices. I'm clearly not as qualified as you seem to be, but even I can see that no matter what, the word 'append', knowing when append has to allocate new memory, and knowing that a slice is a pointer, is enough to know what that program is doing, even if it looks ugly (which i still don't think it does). Like I said, I am not a genius, nor am I trying to be r/iamverysmart, and sorry for run on sentences
&gt; Hostility towards an arbitrary group of people doesn't justify hostility to the person. Yours was personal. No, it wasn't personal hostility. It was hostility towards the attitude that user was showing, which was not helpful to anyone, and actively encouraged people not to believe that things *can* get better over time.
btw, jwtauth middleware works with all http routers in Go. If you check the import paths, it doesnt even depend on go-chi/chi.
Well yeah you're right about that
This is an excellent article. I've read it a couple times, but today I spent the time to fully grok it. Spend some time looking at the full code sample: https://blog.golang.org/context/google/google.go More specifically the httpDo method and how it works with the f function parameter. This example covers just about everything you need to know to work with go: channels, context, first class functions, select with channels, closures, and anonymous goroutines. 
This is a Go question, and your answer does not fit my issue. If I leave it as `::` it will listen on all assigned addresses. That is not what I want. It needs to listen on an unassigned address.
&gt; This really isn't a Go issue. It more of a kernel issue which is why Go is what sets up the sockets and listeners so it has to be setup through Go and before the server starts. &gt; A alternative may just be using a redirection rule in IPtable/nftables to redirect all traffic to a certain port on any IP address to your regular Go socket. That is actually a possible solution I hadn't thought of, granted probably not as performant as a direct Go implementation. Thanks!
I think I understand, but could you give me a small example? can you make a router chain for the following URL's /photos /photo/:id
Jet Brains also has their [Gogland in preview now](https://www.jetbrains.com/go/). I love PyCharm and just recently started trying out Go with it. 
Coming from C++, I feel that once you have generics, it's hard to not start putting more and more code and logic into generics, and trying to make everything "more general" — losing sight of the original, practical problem, for the "meta-problem" and "reusability". Also, I believe it's hard to resist the temptation of trying to put more and more proofs in your code, so as to make it "more robust", but also inherently more complex and complicated (because the proofs require you to invent and introduce new formalisms, which require more and more complex mathematical thinking, and again waste time). I've seen and done production code which was totally not toys/experiments. Bright people did it, and I can tell you it was brilliant and scary, and powerful, and over one's head. What's worst, it had bugs, and they were super hard to find and solve. Boost is cool and nice and fancy as long as it works; but you don't want to fall in its dark corners, or see it break; or, unfortunately, just want to extend it. That said, I actually *do* in fact miss some kind of generics or something, esp. for the reusability you mention. The problem is, I've seen the other extremum (read some Idris docs etc., written some proof-like C++ templates), am aware of its problems, and am painfully torn between the two. I very much wish someone finds/invents some nice sweet and comfy spot in the middle, which would have benefits of both sides. I wonder if Rust's approach isn't some kind of cool middle-ground, but I'm not sure, and can't say I know it well at all (just had some light reading).
It just reads a little naively. Out of curiosity, how good are you at languages like Rust, Haskell and modern C++? Go does many things well. It's amazing for the web and it builds simply. However, there's many trade-offs it makes because of that. There's no real direct access to threads, the lack of generics makes writing algorithms difficult (especially scientific ones) and because Go is garbage-collected, calling it "really, really, really fast" seems disingenuous. Go is a good language. But there are many others that are very nice. Go is great for the web.
Whoever decided that -0 should be a thing needs to get punched in the balls.
Yeah, in C++ one can get a bit, hm, carried away... We're talking Go here, though, I don't think C++-tier generics are likely. Think Java generics or TypeScript or the like, probably... 
Here you go https://play.golang.org/p/BDady7L3KJ
Very good explanation. Also it may (or may not?) be helpful to realize that the cancellation is "soft" — kinda more like a TERM signal than KILL signal in Linux, or more like a suggestion than an order in real life. So, you need to check it (the ctx.Done) explicitly from time to time; you may sometimes unnecessarily do some work after cancellation before you check/detect it. But it's ok, it's fully at your discretion to check it, it just allows you to sometimes free/stop some resources/work earlier than you could without the Context.
I use github.com/SermoDigital/jose. Your intuitions are right. I almost wrote my own implementation at some point because of the nature of go-jwt. 
Twice; they are breaking so many rules.
&gt; It just reads a little naively Haha. Been programming professionally since 1979. I've had several multi-year stints with languages running the gamut: BASIC, assembly language (6502 and Z80), C, Postscript, Perl, Ruby, and now Go. I'm confident we can agree my naiveté has been completely removed. &gt; Out of curiosity, how good are you at languages like Rust, Haskell and modern C++? I have zero familiarity with any of those. &gt; Go does many things well. It's amazing for the web and it builds simply. Agreed. &gt; There's no real direct access to threads I don't need that and this basically goes to my point "making it easy to avoid cutting your fingers off" &gt; the lack of generics makes writing algorithms difficult (especially scientific ones) I can see this, but have also found that there are frequently better, simpler methods to solve problems than ever-higher-level levels of abstraction. Do consider (and much to my point) that ALL ALGORITHMS run on processors, none of which support Generics. &gt; and because Go is garbage-collected, calling it "really, really, really fast" seems disingenuous. Really? This is pretty silly argument, IMHO. Current GC pause times on my app are in the range of 40us. The rest of the time, the GC runs asynchronously to my code. Cores are exceedingly cheap these days, and in production, our GC CPU fraction is .1%. If I needed REALLY optimize BOTH, I'd spend some time and avoid allocations, at which point this tired old saw breaks down completely. At the end of the day, I hear you, it's a perspective thing. Many Go programmers, myself included, come most recently from languages like Ruby and Python. From that perspective, I assure you, it's really, really, really fast. :-)
Simple -vs- complex is a relative thing. Microprocessors, even CISC types, are INCREDIBLY simpler than languages more complex than Go. Everything you mention seems to me to be covered by my clear statement: &gt; Modern processor **implementations** are fantastically complex
&gt; Whoever decided that -0 should be a thing needs to get punched in the balls. There are a number of important numerical methods where -0 is necessary (particularly w/ complex numbers).
But -0 still has a value of 0 and the negative symbol is purely decorative... Kind of like how the 16:10 aspect ratio is actually 8:5. 
Obligatory Ozzy: [Breaking all the rules](https://www.youtube.com/watch?v=vQxlZyyy_8A)
Jaana Dogan (@rakyll on twitter/github) has a great blog post https://rakyll.org/leakingctx/ that really helped me grok what contexts are for. (Seriously just spend an afternoon reading her go unwritten parts blog. the profiling thing just put up is awesomesauce) Also this talk https://www.youtube.com/watch?v=jUIh14avdDY about adding context to nats by Waldemar Quevedo (@wallyqs on the things) is great.
Videos in this thread: [Watch Playlist &amp;#9654;](http://subtletv.com/_r6lmfbm?feature=playlist&amp;nline=1) VIDEO|COMMENT -|- (1) [http://www.youtube.com/watch?v=LSzR0VEraWw](http://www.youtube.com/watch?v=LSzR0VEraWw) (2) [http://www.youtube.com/watch?v=8M90t0KvEDY](http://www.youtube.com/watch?v=8M90t0KvEDY)|[+12](https://www.reddit.com/r/golang/comments/6lmfbm/_/djuvnr1?context=10#djuvnr1) - Hey! I know Francesc Campoy made 2 videos about the context package. I haven't watched them myself they are on my todo list :) but I have watched a lot of his other videos that I can recommend so hopefully this can help you out. Video 1: Video 2: [http://www.youtube.com/watch?v=jUIh14avdDY](http://www.youtube.com/watch?v=jUIh14avdDY)|[+1](https://www.reddit.com/r/golang/comments/6lmfbm/_/djvkuik?context=10#djvkuik) - Jaana Dogan (@rakyll on twitter/github) has a great blog post that really helped me grok what contexts are for. (Seriously just spend an afternoon reading her go unwritten parts blog. the profiling thing just put up is awesomesauce) Also this talk... I'm a bot working hard to help Redditors find related videos to watch. I'll keep this updated as long as I can. *** [Play All](http://subtletv.com/_r6lmfbm?feature=playlist&amp;ftrlnk=1) | [Info](https://np.reddit.com/r/SubtleTV/wiki/mentioned_videos) | Get me on [Chrome](https://chrome.google.com/webstore/detail/mentioned-videos-for-redd/fiimkmdalmgffhibfdjnhljpnigcmohf) / [Firefox](https://addons.mozilla.org/en-US/firefox/addon/mentioned-videos-for-reddit)
Can someone give an example of a use case where the simple `if x &gt;= 0 { return int(x + 0.5) } else { return int(x - 0.5) }` solution is not sufficient, and the more sophisticated "towards zero" rounding is necessary? I'm having trouble coming up with one.
My comment wasn't completely accurate... This post goes over some of the specifics (and how this algorithm falls short, along with most others mentioned) https://www.cockroachlabs.com/blog/rouding-implementations-in-go/
Hi /u/gar44 There is a great example from a Udacity course I took [here](https://github.com/udacity/ud615/blob/master/app/handlers/login.go). Edit: I'll link the [Udacity Course](https://www.udacity.com/course/scalable-microservices-with-kubernetes--ud615). It's free. I'm not affiliated with them but I found it useful.
Another noob here, Ive been struggling with this as well. Struct embedding seems to be the recommended option but it feels kinda hacky to me to represent database relationships this way? Is there any alternative patterns for this? Also just to clarify, using OPs example, if I have a "location_id" foreign key on my person table, is sqlx smart enough to unmarshall "location_id" into the id field on the Location embedded struct even though it has the same db struct tag as the id field on the Person struct? 
&gt; Microprocessors, even CISC types, are INCREDIBLY simpler than languages more complex than Go. Not sure what languages you're referring to here, but unless it's some exotic extremely complex programming language, this just isn't true, especially the "INCREDIBLY" part. As someone who has written code in asm for at least 4 modern ISAs, I'd say they are about as complex as most of the not-so-simple most used languages... &gt;Everything you mention seems to me to be covered by my clear statement: &gt;&gt;Modern processor implementations are fantastically complex All the stuff I mentioned is what you need to deal with when you write asm code for the given CPU, ie. it is the complexity of the _interface_. The _implementation_ details are much juicier. Have you ever done any non-trivial work on the asm level on a modern CPU? _edit_: Just noticed the Z80 mention in the other thread. Yeah, that probably was quite simple, but CPUs evolved a little bit since then, you know? :D 
&gt; I don't need that and this basically goes to my point "making it easy to avoid cutting your fingers off" I don't see how not having access to threads is avoiding cutting your fingers off. You still run into race conditions and deadlocks with goroutines just like with native threads. 
I just finished a toy calculator to get my head around it. You need to be careful with identifiers and first letter casing because generated code may not be published when you want it to be. Beyond that, the generated event handler is a nice touch, so that you can ~~inherit~~ *embed* it inside your own struct and only create the methods you want to use. Edit: /u/dchapes, corrected The documentation (for Go specifically) is lacking, so just keep trying. It does work.
&gt; Do consider (and much to my point) that ALL ALGORITHMS run on processors, none of which support Generics. Thanks for the laugh :) So we should basically never use abstractions that make running code on a processor easier. Why are you writing in Go then?
Hi /u/ZicReddit it's a really good question and I hope people of this community will think about it more often. Unfortunately I'm late again for this thread, you see, every thread about Go usage in GUI apps on desktop platforms usually lists all GUI projects except ones I contribute to. I'm from the "other GUI projects" group. Ok, so I think that Go is a really general purpose language, and I'm constantly trying to prove it by making stuff that usually can be done using old-school native languages like C/C++. For example, writing a video player that can decode and play .WEBM videos (both VP8 and VP9), and with sound track (Vorbis / Opus): https://github.com/xlab/libvpx-go I also maintain a Go bindings to https://github.com/golang-ui/nuklear, hopefully one day the site golang-ui.com will get its content. And https://github.com/vulkan-go/ as for bleeding-edge graphics API. All this stuff is obviously linked to C, but at this point you can't deal with anything in pure Go, simply because there was no enough man-hours to rewrite the libraries in pure Go. We can abstract away from C like I did in WEBM player, so you can write cross-platform apps without touching any C, but getting rid of C completely is not a problem of the language, it's a problem of lacking human resources and faith that Go can be used outside servers. Businesses are adopting Go on servers, as it improves performance and lowers the cost of development and maintenance. On desktop, the gain is not as nearly good, the only thing you get by writing everything in Go is clarity, e.g. the code is clean and concurrency helps to deal with user input. That's it. But GUI and desktop app development actually goes deeper. Many things are stacking on each other, some app from 2017 still draws using X11 protocol dated '84. To make a voice/video calling app, like Skype, you'll need to get a video codec, and audio codec and a GUI framework. And if audio codecs are relatively simple to rewrite in Go (but still takes weeks), look at libVPX codec https://github.com/webmproject/libvpx which would take years to rewrite and it would be unmaintainable from the very beginning. So, the story is that the industry develops in C/C++, and desktop apps are composed of a bunch of C/C++ modules ([see Telegram third-party libs for instance](https://github.com/telegramdesktop/tdesktop#third-party)). The best we can do is abstract away all C/C++ stuff and use these components from Go as if they are written in Go themselves. Until enough time will pass, and someone will come up with a GUI framework that took 2-3 man-years of effort to complete. None of GUI framework projects in pure Go look like it, unfortunately :(
That is the first example in the blog post. There are 5 inputs it doesn't compute correctly: - round(0.49999999999999994): got: 1, want 0 - round(4.503599627370497e+15): got: 4.503599627370498e+15, want 4.503599627370497e+15 - round(-Inf): got: -9.223372036854776e+18, want -Inf - round(+Inf): got: -9.223372036854776e+18, want +Inf - round(NaN): got: -9.223372036854776e+18, want NaN You could choose to ignore the specials (inf, nan), but that still leaves you two inputs that are incorrect: 0.5-epsilon and very large numbers. Edit: fixed formatting. Thanks for below.
&gt; And this kind of initiatives tends to be unmaintained after the first years for all the other I found… The Qt binding from therecipe is from another kind, it's automated and generic, i.e. it doesn't need so much maintenance as previous one from go-qml project. However, Qt is paid and there's actually a subscription service, that concerns me most. It's not cheap either. 
There are a number of algorithms that won't function as expected if rounding has bugs for .5+-epsilon. 
If you know how to issue your own tokens in your app, you can put it behind [Caddy](https://caddyserver.com) and use the JWT middleware to handle authorization. Then you get HTTPS for free and a bunch of other useful middleware that can simplify your downstream application. I wrote that middleware, so if you use it and have trouble, let me know. 
Never said anything close to that. [Reductio ad absurdum much?](https://en.wikipedia.org/wiki/Reductio_ad_absurdum)
**Reductio ad absurdum** In logic, reductio ad absurdum (Latin for "reduction to absurdity"; or argumentum ad absurdum, "argument to absurdity") is a form of argument which attempts either to disprove a statement by showing it inevitably leads to a ridiculous, absurd, or impractical conclusion, or to prove one by showing that if it were not true, the result would be absurd or impossible. Traced back to classical Greek philosophy in Aristotle's Prior Analytics (Greek: ἡ Εις άτοπον απαγωγή, translit. hê eis atopon apagôgê, lit. 'reduction to the impossible'), this technique has been used throughout history in both formal mathematical and philosophical reasoning, as well as in debate. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.24
Really? It's well understood that the thread model has been extrremely difficult to reason about. Channels make it far easier, which is my point.
I don't want to use paid services just to be able to deploy JWT. 
It's free and open source
I never said that programming in assembly language was easier or simpler than programming in higher level languages. I do believe very high level languages have strayed a bit from load, compute, store which, at the end of the day, is all that CPUs do. Yeah, it's been a LONG time since I've written assembly language. Have you ever written single-cycle-deterministic-for-all-conditions code in order to paint pixels on screen, for a video game that was burned into ROM (so had to be bug free) and ran on a system with 128 bytes of RAM? I have. We all have our crosses to bear. 🙂
That about what I was thinking. Thank you. Is it that much faster?
Interesting. I'll have a look. Thanks
No, it's distinct for a reason. The simple number system you were taught in school is not "wrong", but it isn't the only one, either. There are plenty of useful systems where 0 is distinct from -0, and once that information is lost, it is impossible to recover it. Even in the simple school number system, it is easy to see that the limit of 1/0 approaching 0 can be seen as positive infinity and 1/-0 as negative infinity, a real difference between the two. 
&gt; But -0 still has a value of 0 and the negative symbol is purely decorative... From context I assumed we were discussing floating point values, where -0.0 is distinct from 0.0, and the negative symbol is *not* purely decorative. But integer number representations can also have negative zero, such as the one's complement checksum values used in every IPv4 packet.
To save a click, the "article" doesn't really say anything about a commercial product that's in Beta. The godoc documentation is pretty sparse as well.
We'll try to improve the documentation in the next days. Thanks for your feedback, sybrandy!
For those struggling with the list's formatting: * round(0.49999999999999994): got: 1, want 0 * round(4.503599627370497e+15): got: 4.503599627370498e+15, want 4.503599627370497e+15 * round(-Inf): got: -9.223372036854776e+18, want -Inf * round(+Inf): got: -9.223372036854776e+18, want +Inf * round(NaN): got: -9.223372036854776e+18, want NaN
Depends on what you mean by "much", which mux you're comparing to, how many routes you have, and how complex they are. Direct comparison in your particular use case is the only thing that can say for sure. In a moderately complex REST service, I found a small overall improvement over fasthttp. In most cases, routing is a very small part of the overall request processing time; when performance is paramount, you save microseconds wherever you can, and often the biggest bottlenecks (like the database) are difficult to optimise past a certain point. In the end, personally, I would rather have fewer external dependencies and better performance, even if the difference is small, because to me it comes at no cost. Others might not like that style of routing and that's fine, do whatever works for your project.
 var testData = map[string]string{ "sub": "test@example.com", "name": "Kevin Mitnick", "given_name": "Kevin", "family_name": "Mitnick", "email": "mitnick@example.com", } I see you're a fan :D
&gt; Yeah, it's been a LONG time since I've written assembly language. Then you are probably quite out of touch, because: &gt; strayed a bit from load, compute, store which, at the end of the day, is all that CPUs do. I find this reductionism to be tremendously disingenuous. I mean, that is all a fucking high level language does do, compute on data. But more to the point, using it to reduce the modern ISA of a processor with SIMD and specialized instructions for crypto, etc to a 6502 (which is close enough to what you are implying in your last para) is either disingenuous or plain ignorant.
Um.. it sure as hell seems like you did. You were responding to this: "the lack of generics makes writing algorithms difficult". Ie your counterclaim was therefore generally about the utility of abstractions or other tools in a high level language to make writing algorithms *easier*. Your "consideration" doesn't seem to answer the issue of ease of implementing algorithms *unless* the point was that all these abstractions were useless since they are going to get turned into machine code anyway. If that wasn't close to what you were saying, then what exactly was your point?
hey i know you are the author of chi, just wanted to say chi is the best web toolkit for go, by a mile. i exploit every freaking feature. i may have the largest chi routing table in existence. without chi's features my routing would be spaghetti. THANK YOU
&gt; "Next the ceil or floor func is executed and returned if it mutated the input, which can only happen if the original value’s fractional part was exactly equal to 0.5 since subtracted 0.5 from the input earlier." I imagine this should've said "which can only happen if the original value's fractional part was **not** exactly equal to 0.5..."?
https://github.com/ant0ine/go-json-rest is reasonably easy with good docs.
Yes, fix incoming. Thanks.
Agreed, this would be the usual way of linking a location to a person (in case of a 1-1 relationship). Just one minor side node: The term "embedding" is usually only [used for anonymous fields](https://golang.org/ref/spec#Struct_types), sometimes also called embedded fileds. The Location field above is just a normal field in a struct.
&gt; Um.. it sure as hell seems like you did. I either did, or didn't -- what it seems like I did is irrelevant. &gt; your counterclaim was therefore generally about the utility of abstractions or other tools in a high level language to make writing algorithms easier. It was not. I was simply pointing out that the microprocessor knows nothing about the concept of generics. &gt; Your "consideration" doesn't seem to answer the issue of ease of implementing algorithms unless the point was that all these abstractions were useless since they are going to get turned into machine code anyway. Wow, you read **way** to much between the lines. 
This is kind of random but I think I've seen your exact same username comment on Pornhub all the time. I shit you not. I have high functional autism so my memory is freakishly good but it definitely was you. Sorry to blow up your spot, I can delete this comment if you want lol
no need for /s fam
Oh, yeah, **huge** change to introduce a way to run the same operation on a range of memory without a loop, and to have crypto instructions to optimize crypto code. My goodness, what will they introduce next to confuse us old-timers? Native floating point? How will I ever keep up? Come down off your high horse, we're all in this together...
np. Good article.
In the words of Bob Dylan, "It ain't me, babe." I won't say I've never been there, but I promise you I don't have an account.
[removed]
What is your implication then? That generics aren't needed because no processor "supports" generics? You can use that argument against any form of higher level programming, because you can't run higher level code directly on a processor. So I'm really not sure what you're getting at.
I wrote a middleware library that makes jwt implementation super easy: https://github.com/adam-hanna/jwt-auth
I'm - naturally ;) - using https://godoc.org/github.com/tideland/gorest/jwt.
&gt; What is your implication then? My implication is that I like that Go is simpler and closer to the CPU than languages I've used recently. That simplicity outweighs my desire for higher level features like generics. &gt; That generics aren't needed because no processor "supports" generics? That's certainly a true statement. It would be great if Go 2 implements generics. But I won't lose any sleep if it doesn't.
Code that is hard to test is trying to tell you that it wants to be rewritten to separate out concerns so that they can be tested separately. Find out what is core to a routine, and what it depends on. Replace the thing it depends on with a mock who's state your test controls. Then you can test the core of the routine, without worrying about the rest of the side effects on the system. For example, func (c *config)dump(filename string) is hard to test because it wants to actually write onto disk. Instead, change it to take an io.Writer as it's arg. In production code, the caller will do os.OpenFile to get the io.Writer to the new file. In your test code, you'll use a bytes.Buffer, which is also an io.Writer. then you will look in the buffer to see if the config file is what you expected it to be. -jeff
Fair enough. I like Go for servers and simple CLIs but anything more than that and I'd go mad.
Hey guys, I'm happy to announce go-astitodo, a TODO parser written in GO. I know most IDE already parse TODOs but they usually have problems with multi line TODOs, can't parse assignees, etc. This is also a good start on how to parse AST. Cheers
&gt; I do believe very high level languages have strayed a bit from load, compute, store which, at the end of the day, is all that CPUs do. Yeah, that's exactly what I'm trying to say in the whole thread: CPUs do a whole lot more than just load, compute, store. Or, maybe you could say that that's all that they do, but they do it in a whole bunch of different ways with complex semantics... I'd wager that most moderns ISAs are _way_ more complex than the Go language... 
&gt; It's well understood that the thread model has been extrremely difficult to reason about. In terms of reasoning / semantics, it's mostly the same as Go's lightweight threads. The difference between native threads and goroutines is mainly that the latter is cheaper, ie. the difference is mostly in implementation, not semantics (not subtantially, anyway). Go's integration of lightweight threads is quite nice indeed, but it's not such a unique unbeatable thing as Go programmers seem to think, in fact, some other languages make it easier to reason about concurrent code than Go through various techniques (for example, depending on language, immutability of data structures or integration of the actor model or borrow checking (in case of Rust) etc)... &gt; Channels make it far easier, which is my point. Yes, and they have been used before Go was invented in various languages both _with native threads_ or with coroutines / lightweight threads like in Go. 
&gt; CPUs do a whole lot more than just load, compute, store I don't believe they do. &gt; maybe you could say that that's all that they do Now we're getting somewhere... &gt; but they do it in a whole bunch of different ways Yes, we can agree on that. &gt; with complex semantics How complex are the semantics when all you can do is read data from memory and/or registers, potentially compute upon that data and/or branch, store into memory and/or registers, rinse and repeat? Perhaps you refer to the complexity of scheduling the operations optimally so that the processor can be kept busy? That is certainly very tricky these days, but is outside the scope of my comments in that the semantics of code execution are quite clear and semantically simple, it's the optimization of execution that isn't. Again, the implementations are massively complex. Different execution modes, security features, virtualization support, etc. make that clear. And, of course, there's a ton of complexity doing the simple load/compute/store cycle extremely efficiently yields massive complexity in the form of hyperthreading, branch prediction, multi-level cache management, cache coherency on multi-core and multi-socket systems, etc.
I couldn't agree more. For me those giant generics were kinda crazy in c#. For example multicasting delegates... Fun, fine, and dandy to get the concept but in production it was reduculous. In Python it was fine to try to learn Django but when something went wrong, it was a giant headache. Go just felt and looked right and didn't hide anything I could not debug easily. I mean the language mostly tells you what's wrong itself.
&gt;Do consider (and much to my point) that ALL ALGORITHMS run on processors, none of which support Generics Lmao wot
&gt; How complex are the semantics when all you can do is read data from memory and/or registers, potentially compute upon that data and/or branch, store into memory and/or registers, rinse and repeat? To get an answer, read any modern ISA manual. Heads up: They're usually hundreds of pages long... &gt; Again, the implementations are massively complex. Different execution modes, security features, virtualization support, etc. make that clear. That's the **interface** provided to the programmer. It's more or less the equivalent of language constructs. The actual implementation of those features, underneath, as part of the microcode and hardware is more complex than anything we've discussed so far here... You're engaging in reduction ad absurdum here, you could say the same thing about complex languages like C++ or Haskell - that all they do at the end of the day is load, store, compute, which is true, but we're not discussing the high-level philosophical overview here, we're talking about the interface provided to the programmer. And I stand by my statement that those interfaces of modern CPUs, as specified by their respective ISAs, are very complex, IMHO much more complex than Go's language surface and even may rival that of complex programming languages. 
[removed]
&gt; That's the interface provided to the programmer Yes, we're talking about programming, not electron flow. Which is why I've REPEATEDLY agreed that CPU implementations are complex...beginning [all the way back here!](https://www.reddit.com/r/golang/comments/6livvj/i_know_this_isnt_the_type_of_post_this_sub_is_for/djv07kp/?utm_content=permalink&amp;utm_medium=front&amp;utm_source=reddit&amp;utm_name=golang)
And I'm repeatedly trying to clarify that I'm not talking about CPU implementation but rather it's interface. An ISA is a paper document describing an interface... I really don't know what else to say... 
Yes, do that. I've been slowly replacing nginx with caddy on all of my servers. I've completely stopped building a lot of functionality into every microservice; I let caddy handle it. Awesome kit.
I appreciate your hanging in there, and I understand your viewpoint. I clearly misunderstood that you were not discussing implementations -- this comment is where I misunderstood: &gt; But even with RISC-type CPUs, things don't really get much simpler. You've got delay slots, which admittedly aren't rocket science, but typically mess up newbie minds. Consider the way large integer literals (ie. 64 bits) are encoded on RISCs. And then particular CPU oddities; consider ARM for example, with its ARM vs Thumb vs other states where different instruction sets apply in each state. Or SPARC with its register windows and the weird stack bias (stack and frame pointers have a bias of 0x7ff). &gt; Then there's the whole chapter on multicore stuff, such as atomic instructions, fences, cache coherence... These **really** appear to me to be implementation details, as opposed to functionality. And I **did** mention that I never intended to suggest that programming in assembly is less complex than programming in a higher level language. The **only** point I was trying to make -- and I know this is frustrating from your perspective -- is that CPU operations are typically mismatched -vs- high-level language concepts, particularly with respect to OOP, some aspects of functional languages, and semantically rich languages like Rust. While such languages strive to free the developer from the minutia, I find that many, many developers becoming mesmerized by the continuous stream of new concepts these languages introduce, and lose their sense of [mechanical sympathy](http://embedded.fm/blog/2016/4/18/on-mechanincal-sympathy) and end up [being the snake rather than the snake charmer](https://www.youtube.com/watch?v=jGRpwOb4s4E).
[nubo/jwt](https://github.com/nubo/jwt) is a small (and limited to HMAC SHA-256) lib for JWT handling in Go that I wrote because in 2015 I found existing libs were to complex for my use case and/or too easy to use in an insecure way. I didn't write a tutorial but a README.md and [GoDoc](https://godoc.org/github.com/nubo/jwt) with many examples.
One of the greatest programming article I've read these last few months!
I've watched them and they are the resource that best made me understand context. Highly recommend.
Addressing your problem of having lots of side effects - using interfaces to mock out components in tests is a really central technique to testing in Golang. To get an idea, see [this article](https://nathanleclaire.com/blog/2015/10/10/interfaces-and-composition-for-effective-unit-testing-in-golang/) for instance. 
It uses another package for JWT which itself uses jwt-go inside. Not quite what I looked for. 
s/inherit/embed/
&gt; symbol is purely decorative Not when used with several math functions such as [math.Atan2](https://golang.org/pkg/math#Atan2), [math.Gamma](https://golang.org/pkg/math#Gamma), [math.Signbit](https://golang.org/pkg/math#Signbit), etc and, as already mentioned, it's sometimes very important to an algorithm to know if a zero underflow was from negative or positive. 
As /u/nagai points out, use interfaces to mock out bits of the code. I [wrote about how this enables a loose form of parametricity](http://www.jerf.org/iri/post/2923) a while back. You should also be able to use this to improve the testability of the code; the pattern of "complicated one-time setup -&gt; simple recurring usage" in one function is very common, and very easy to break into two pieces so the simple recurring usage can be tested. Also, all channels are also automatically "mocked", if you can redirect the appropriate end into your test code. There is nothing wrong with refactoring some code that creates a channel on the stack to one that creates it in a struct and gives the test code a chance to change it or use it. All in all, after a lot of functional experience, I have found Go to be wonderfully easy to test in my own code, with relatively small amounts of attention paid to using certain techniques to make it easy. And those techniques are almost without exception quite cheap, or even of negative cost (i.e., they're also the right thing to do in the medium to long term anyhow), once you get used to them.
Shouldn't the context be out of struct and passed as a parameter (by convention)?
Looking forward to using that new passthrough subdirective ;D
Seem tiny and neat. Will try it. Thanks!
Yeah whoever wrote that is some kind of genius! Actually, the sad thing is that I don't even use the middleware anymore myself. I have all my authorization in my app because it's using GRPC and I prefer sessions. The only place I use JWT these days is in the mobile app and for "magic links" that log in when you click on them in an email. 
Cool, much better. Still rough around the edges, but you'll learn the finer aspects with time. I do especially like the package doc - brief, clear, and to the point; an awesome intro and first impression, makes a world of a difference in usability and approachability of the package. Two more quick notes: - you totally don't need to setup your own hosting for godoc, there's https://godoc.org, it's owned by Google and people are used to just going to https://godoc.org/github.com/hunterloftis/pbr/pbr - regarding your TODO: image.Image is an interface; as a general rule, you'll never really have a practical need to make a pointer to an interface. As a final tip, I very much recommend studying the stdlib, you will discover many cool idioms.
Related: https://stackoverflow.com/questions/19167970/mock-functions-in-go/19168875#19168875
Wow! TIL. I'm really impressed with Go's tooling and ecosystem, had no idea godoc.org auto-generated Github package docs. Just linked there instead. Thanks for all your suggestions! 
To add to C2, I try to always restrict my goroutines given their purpose. If a goroutine is read only, I make sure to pass it in as read-only. Same with write-only channels. So: func receiver(c &lt;-chan int) { } func sender(c chan&lt;- int) { } func main() { c := make(chan int) go sender(c) receiver(c) } Closing a read-only channel is a compile-time error, so using the right types will save you from these types of errors. &gt; If you are ever using a channel outside of a select in production code, you are probably doing it wrong I don't really agree. Yes, using it outside of a select is often wrong, but it's also often right. I have code like this on occasion: func parser(c chan&lt;- string) { if wellFormed { c &lt;- "expected header of what I'm parsing" } else { close(c) return } for { c &lt;- "some part" } } func handleParsedStuff(c &lt;-chan string) { header, ok := &lt;-c if !ok { // not well formed, so skip this one return } for part := range c { // handle parts println(part) } } With a `select`, this would look terrible: var header string var ok bool select { case header, ok = &lt;-c: if !ok { // closed return } // ... case &lt;-time.After(time.Second): // give up, it's taking too long } So no, I think there are *plenty* of use cases where not using a `select` is the right choice. I do this with wire protocols that have a very specific format. The sender signals that all is not well by closing the channel before the repetitive data happens.
I don't use it much, but I'm still glad it exists. It helps by being a sanity check for gc, making sure they both implement the documented specification, rather than a single implementation becoming the specification. I did use it once to confirm a compiler bug was gc-only and not present in either of gccgo nor GopherJS compilers, which was neat.
Just wanted to follow up here: Is the above (Location as a field on Person) only useful for 1-1? The relationship I'm trying to represent is many-to-one (Many Person structs can have the same Location)
I don't personally use it much, but from what I've heard GCC might have better optimisations, especially for numeric code. By the way, does anybody know if gccgo still uses thread-per-goroutine model?