this is exactly the reason not to use such libraries without looking at the source, it implements left and righttrim with regexps and other such nonsense go is famous for not masking the complexity behind its operations
https://github.com/asaskevich/govalidator
... and full of interface{} 
+1
Zope... One of the argument to say that Python was not made for web app (joke). Go has all the features to build an ORM (see gorm and qor), it's just that theses feature are not the most commonly used in Go. I don't use ORM in Python to build web app, neither big framework, so I don't think that the lack of ecosystem will be a problem, just that we will not see a fast adoption. Your question is interesting. Comparing to others languages, C or dynamics, Go has a lot of functionalities for web app. Garbage collector, fast compilation (to test as quickly as restarting a Python app), easy deployment, everything in the stdlib (context is coming in 1.7). About the effort, compatibilities promise (and static typing) is the most valuable for me when I see how long it takes for people to translate code from py2 to py3. Guido is actually working on static typing (mypy) and said that the lack of static typing is one reason that make difficult the upgrade. So like you I need to be really sure before switching some web app from py2 to Golang instead of py3 for example... I'm confident when I see how strong is the Go team to keep it rock solid : https://docs.google.com/presentation/d/1JsCKdK_AvDdn8EkummMNvpo7ntqteWQfynq9hFTCkhQ/present
IBM Bluemix has support for Go
Written in PHP, complete with database crashes!
&gt; Can you elaborate on what you mean by denormalize the data? How much data are you talking about? For example, to sort by date, I need to make another collection with the date as the key, so that I can query by date.
These are not hard reasons, but the ones I have: * Adding sqlite means distributing native libs per OS. * Our binary size is important, sqlite may or may not be bigger than Boltdb. * Migrations. We need a system to ensure up to date migrations for clients. This can be done, but with schema free solutions like Boltdb this is much more painless. You just need to check your model at unmarshalling point and decide what to do.
If you don't mind bringing in another package, github.com/jmoiron/sqlx has a helper for this use case. https://godoc.org/github.com/jmoiron/sqlx#In
Oh wow, I don't know how I've never seen that! The package in general seems really useful! Thank you
I don't see the point of most of this. What's the point of IsNegative? What's wrong with &lt; 0? IsWhole is probably a bad idea to begin with given the nature of floating point numbers, and is something that's only really useful in JS where you _only_ have floating point numbers. You cannot assume that the result of any calculation is going to be whole. While in practice 5.*2. == 10., you should not be making these assumptions with floating point calculations. I don't know if that result is whole, I shouldn't care if it's whole, if my code relies on it being whole it's just taunting the floating point gods because one day something is going to change and the result isn't going to be whole. This, again, is something that only even makes sense in Javascript where you have to do things like use floating point values for array indices (WTF Javascript), but I don't see the point of it here. A number of these convert strings to []byte and run them through regular expressions, this is a bad idea especially when you think you're "sanitizing" input. Taking a multi-byte character apart and shoving it into a byte slice, replacing or removing some bytes and then converting back to string is bound to end in disaster and, depending on what you're sanitizing, is a potential vulnerability depending on whether the character classes used in the regexp are inclusive or exclusive. There are string variants in the regexp package, use them. Why are functions to validate a credit card number and an ISBN in the same package? What does one have to do with the other? And again, IsISBN is using byte slices with regexp presumably in a function specifically made to validate user input. This is a bad idea. IsJSON just wraps json.Unmarshal. Why not just use json.Unmarshal? That pretty much sums up my opinion of 80% of the functions here, come to think of it. Why is IsMultibyte second-guessing Golang's UTF code? I'm not sure if there'a a solution in the standard library, but a better guess would be to convert then string to []rune and use utf8.RuneLen != 1. And things like Each are just really out of place. How often do I have a []interface{}? Usually only when I'm passing it through to a *printf function. If I want to iterate over that, what is wrong with for range? I see where this is going, I'm coming from Ruby where you're doing things like this all the time, but it doesn't fit with Go.
Is there some way to use that function as more of a utility as opposed to it being my main database package?
One thing I've noticed with the new version of golang is when I run 'godep save' then everything is referenced in 'vendor' which is kind of a pain, because the logic of my application is in a separate library so every time I have to push an update I have to remove the Godep and vendor directories.
This wouldn't have happened if he had written his blog engine in Go. ;)
Wasn't meant to be a proper criticism. As for solution, first the problem needs to be defined, because from where I'm sitting as far as deploying goes, shipping a simple binary is just as simple as using Docker. IMO containers become useful only when can use something like Kubernetes, and if you're in this case I'd rather use something taht integrates well with systemd (like runc or rkt).
You can make the key a custom UID that starts with the date created. Though, yes, if you wanted to sort by something else other than date, you'd have to create another bucket (to utilize b tree indexing), or if the data set is small enough, sort it yourself.
Yeah j need to write a bash script. It would be interesting to set up a symlink though, I'll have to try that
Or simply install the Go plugin in any JetBrains IDE and skip all the configuration work :-D (yes, gometalinter inspections are not fully ported yet, but they will be). 
Sqlite is your best choice for a query-based db which is embedded.
The proposal sounds nice, but I don't think it's right yet. I think a better approach would be, to make the reference counting automatically in the GC and just reap goroutines that block reading or writing to a collected channel. That would have three benefits to the proposal: a) You wouldn't need to manually reference count (i.e. we don't need dup), b) It would enable some patterns that are currently impossible (e.g. using channels as iterators) and c) it wouldn't even be a language change, strictly speaking. But I don't think anything like this will actually be implemented, sadly.
A shame that this doesn't work as you'd hope: import ( _ "github.com/aliygur/godash" )
Should have used [Hugo](http://gohugo.io/)
thanks! this is slick. 
I'm not really sure what you mean by unnecessary dependencies. Here's a quick example that's a little more concrete, but still somewhat theoretical. library/one uses UUID's for something, so makes use of library/uuid to generate those. The core application, for completely independent reasons, also needs to produce uuid's, and uses library/uuid as well. The 'problem' is how to avoid having library/uuid located in both vendor/library/uuid and vendor/library/one/vendor/library/uuid. It doesn't seem to me that this is going to be something all that uncommon, and that can be reasonably put down to poor design choices.
I think you can use back tics.
That package just extends the base SQL. You still have access to all of the regular methods.
what do you expect? Per the spec, `_` imports only get "side effects". Are you saying that you want these functions available without namespace (a terrible, terrible idea)? You can do that with `. "github...."` if I recall correctly.
VC code + go plugin is pretty great as well.
Maybe my [go-workgroup](https://github.com/Spatially/go-workgroup) is along the same lines? And workgroups can be chained so that the output of a workgroup can be the generator of data for another workgroup. For example, like a map-reduce, fan-out/fan-in flow.
Yep, that might be a reasonable attitude/approach.
where r := mux.NewRouter() 
This probably isn't exactly what you are looking for but if you can work with something like Google Authenticator or DUO then the https://github.com/balasanjay/totp library is pretty simple to use. I'm not super familiar with the RSA SecurID algorithm so I can't comment on that.
Check the FAQ section here: https://github.com/mattn/go-sqlite3#faq One of the links from that section: http://www.limitlessfx.com/cross-compile-golang-app-for-windows-from-linux.html The link is for Linux -&gt; Windows but the method should work for OS X -&gt; windows too. You basically need to install mingw and then use the appropriate flags while compiling. Note: I have actually done this for Ubuntu -&gt; Windows and know it works fine.
Also, if both versions are the same, a smart enough linker should be able to remove the duplication. I don't know if go is smart enough today.
what are you interested in?
[**@peterbourgon**](https://twitter.com/peterbourgon/) &gt; [2016-03-02 12:16 UTC](https://twitter.com/peterbourgon/status/705003925003493377) &gt; \#gokit has several issues, many newbie-friendly, just waiting for contributions. Want to get started in \#golang OSS? https://github.com/go-kit/kit/issues ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) ^(Starting from 13th of March 2016 /u/TweetsInCommentsBot will be enabled on opt-in basis. If you want it to monitor your favourite subs ask its moderators to drop creator a message.) 
One problem I'm running into now: https://github.com/golang/go/issues/12432 I'm thinking it's better to avoid vendoring in libraries entirely, and I'll set up a docker container that comes with all the packages ready. That way, I can easily run tests in a container, but without having to do any vendoring inside the library.
Web, API, Microservice. Thanks
So it's faster at runtime for certain synthetic benchmarks, but the compiler itself is still measurably slower than 1.5/1.6, both of which are far slower than 1.4... **EDIT:** I'd appreciate it if the downvoters would explain themselves. Especially since my comment merely states the current state of things. Perhaps you are reading too much into mere facts?
 mv vendor/library/one/vendor/library/two vendor/library/two
I think you could say it's entirely why it got slower.
He's saying that making the compiler faster makes the compiler compile faster since the compiler is compiled by the compiler.
This is already taken into account with the 7% slower compilation figure given in the link. When you build the Go compiler, there is an automatic bootstrap process which recompiles the compiler with itself.
Perhaps we have different definitions for what constitutes a "synthetic benchmark". AFAIC, a synthetic benchmark measures the performance of an individual component; it doesn't actually perform a function outside of producing numbers and data used to provide a comparison. I think all of the benchmarks in the original thread fit that definition.
Using https://github.com/pquerna/otp and satisfied. There are many UI libraries for transmitting the secret to an external device -- using https://github.com/zpao/qrcode.react as my UI is React.
Damn. I was hoping there was some extra speedup not listed. Still, a damn sight faster than the 100% slower numbers in the initial thread about it. I'm expecting an optimization level flag to get added eventually, even with the devs being loath to expose extra options. Don't really need expensive optimizations running during development.
Yeah, I hope they can improve that before releasing.
The link says: &gt; Tip compiler (with SSA internal checks off) is about 7% slower than go1.6 to compile net/http (go test -a -c -gcflags=-d=ssa/check/off net/http) 
&gt;So it's faster at runtime for certain synthetic benchmarks, but the compiler itself is still measurably slower than 1.5/1.6, both of which are far slower than 1.4... I think you might be getting downvotes for the "..." as it makes it seem like you think you are revealing something profound instead of just stating unfortunate facts.
oh i missed that. must be blind today. was seeing some charts showing faster compiles of juju and kubernetes
It is faster on juju (one of the biggest go project) [link](https://docs.google.com/spreadsheets/d/1mczKWp3DUuQvIAwZiORD29j5LRb96QZC4mZDn72gAE4/edit#gid=2052978812). Other people have reported faster compile time too. It would be interesting to know why the op has chosen net/http as benchmark.
The library that this was based on was semi-interesting due to struct-tag based validation. A significant amount of this seems to come from that, which makes me wonder why the MIT license isn't reproduced.
What was your legacy code written in? Can you quantify the improvements, even approximately? 50/100/200% speed up?
Probably because your suggestion can be interpreted as compile time speed &gt; runtime speed. Most people would disagree with that.
I would recommend against it. Just obfuscates where a function/struct/whatever comes from when reading code. 
Seeing the compiler getting slower is somewhat sad. However it surprises me a lot that people who find that annoying and unbearable haven't done anything about that. It appears to me Go team would not stand in a way of updates to the compiler that would make it faster. So maybe stop whining and start hacking?
Just like "make" or "append".
net/http is known as a particularly large package in the standard library. It has been used in the past for compiler benchmarks. 
I honestly have no idea how my comment can be interpreted like that. Especially since it doesn't contain any suggestions.
How does it compare with [cayley](https://github.com/google/cayley)?
Has anyone stated otherwise?
Having looked at it recently, it is still terrible C-in-Go. A lot could be won if it was Go-ified.
Unfortunate wording. "So XYZ got a bit better, but ABC is still very bad". It makes it sound very negative, and does indeed make it sound like "ABC" is much more important to you. If you had instead said: "ABC is still very bad, but XYZ has gotten better", then it would have been positive, stating an improvement, and not making it sound like the negativity in ABC is trying to take away your firstborn child. Anyway, last time I looked at the compiler, it's was still a terrible auto-translated mess. A lot could be won by giving it an overhaul, but I suspect it might be a prioritization. The SSA backend is heavy, especially because it's attached after the existing IR, but it's rather impressive that it has almost paid itself off, considering the additional work it performs. There's *plenty* of room for improvement here, and the smaller and faster binaries that come from it is surely welcomed by the community.
I love Hugo. I use it for my own site.
Your specific problem here can seemingly be solved with an interface local to main.go: type Test struct { name string } func (t *Test) Name() string { return t.name } func (t *Test) SetName(s string) { t.name = s } ... type wee interface{ Name() string } func main() { var t1, t2 wee t1 = a.Test() t2 = b.Test() } Vendoring is not a Go problem. Everyone has this problem, and the solutions usually boil down to "lock people into using specific version of common libs" or "have all consumers use their own version". There does not exist a good solution to the problem, but the Go vendoring solution is similar to the NPM solution for the same problem.
I only do it when I'm importing my own packages 
Well, not exactly, but the way the opening post was formulated it sounded (to me atleast) as if the these performance improvements were tied to synthetic benchmarks, and not something that could be expected for other code.
Just because the contributors agree with "slower compilation is worse than faster compilation" doesn't mean they find it unacceptably bad. Otherwise something would be done about it. I personally find Go compilation times acceptable, even 1.6 is slower than amazingly fast 1.4. My comment was targeted at the people in community who throw phrases like "Whaa! This is not acceptable! It's so slow, I'm moving out!" This attitude I find surprising. If it's *so* bad, why nobody from the people constantly complaining about it steps up and does something? Maybe because it's not slow enough to actually do something? And if it's so, then the compilation speed is acceptable.
Thanks. Does that mean that there is no cross compilation luck with things like gonative, gox or goxc when using sqlite? I have not tried the limitlessfx way yet, but that post is a bit old.
Mac
Definitely start with the examples directory, the various stringsvc are very simple and a good place to start, then you might look at profilesvc to see how typical REST-ish services might look like, and then addsvc if you want something quite comprehensive. Also, Marcus Olsson is in the process of contributing a very elegant domain-driven-design example application, for now you can look at it here: https://github.com/marcusolsson/goddd Hope this helps!
Doesn't that open you up for SQL injection, though?
I worked on a mobile application: Go-ku: Sudoku Solver using React Native as the UI Layer and Golang as the business layer. Check it out! Only on Android right now
Interesting. I did not read it that way. Language is a funny thing, eh?
90%-99% of his posts are links and he has negative karma for me. So...
Me too.
I very much appreciate his posts, I think this would be a deader sub (and I a less-informed Gopher) if it wasn't for his sharing. I also think your method of resolving this is rude and shameful.
As others have already said please do not resort to personal attacks. If you have nothing to ask or tell anything related to Go then may be it is better you do not post anything here.
Is the Go code actually available in the repo?
really cool stuff! I am currently working on a project with golang handling all business logic but still native UI. would love to see how this turns out over time! good job
I found this: https://github.com/dgraph-io/dgraph/wiki/Differences-between-DGraph-and-Cayley But it's basically the DGraph author saying they haven't looked closely enough at Cayley to compare them properly.
Ohh, gotcha.
While I'm almost certain this post will be removed (or at the very least downvoted to oblivion), before it is, I would challenge you to provide even the barest sliver of input and content to the community that he has. I'm betting you can't.
FTR, it sounded the same to me. It strongly asserts the compiler is worse in one respect and it sounds like it downplays the effect the new compiler has on runtime speed (I usually attribute a pejorative meaning to "synthetic" when used with benchmark).
Me too. I ilke him! 
If you are using import . a lot then maybe you are trying to hard to make packages more like fancy name spaces. I find a lot of go programs i find on Github use WAY too many packages. One is probably enough. 
good job!
You're gonna wanna start small first. For instance, look at this logging library I created: https://github.com/iamthemuffinman/logsip. The code base is tiny and is pretty basic. Read the code, understand how it works, and see if you can take any lessons from it. Then, move on to another project and do the same thing. 
What are you expecting to see? Accepting arbitrary Redis commands is an improvement over generating a methods like https://godoc.org/gopkg.in/redis.v3 - where you have a few hundred to account for every variation of Redis command. You also still have to handle marshalling results into your data types, because you could be storing anything.
WebSocket is the different protocol. It based on TCP socket, what means that server can send data without request from client side. Client and server become "linked" with two-way data transferring channel. In this article simplified and weird long-poll technique was realized. Client initiates request -&gt; waits for response -&gt; initiates new request -&gt; etc.
I haven't felt the need to use gonative, gox or goxc so I can't comment on those. When using sqlite, if you have mingw installed, the regular `go build` command is sufficient to compile cross platform binaries
There's a section in the document about versions -- https://fedoraproject.org/wiki/PackagingDrafts/Go#Versions Basically it'll just be "version 0, revision [package version], git-hash" in that case.
FYI: https://github.com/nlamirault/gotest.el
Good news.
They're roughly the same with go 1.5. Oddly, with go 1.6, each http connection uses way more memory than a websocket connection, seemingly because it's keeping some buffers around until the handler returns. In the example I launch handleConnection() in a goroutine so that those buffers can be freed up. Even in the go1.5 case, where they use similar resources, I have tried SSE, streamed response, and websockets in production. They're all pretty much identical from the server side for this style of push server. Clients seem to prefer to implement streamed response and websockets though. Nobody seems to actually use SSE that much.
Yes that is the way I read it, so it seems I'm not alone atleast. Now there's nothing wrong in highlighting the synthetic aspect of the benchmarks, but the post seemingly tried to dismiss the results for this reason. Also these benchmarks are making heavy use of a lot of standard library code, the same code which is used in the majority of Go software out there, which in my opinion make the results quite relevant.
I gave CentOS as an example. Also, afaik, newer CentOS releases are still using that version. It is not a feature, it is a maintainance nightmare. Same goes for having programming language packages shipped by the OS. Unless those maintainers are really good at it and stick around for a while, this will cause issues. And it's also terrible to stick everyone to the same version. What if I need a newer one? I guess the world is not prepared for a: don't break the API while you add new features approach.
This is exciting! Btw. It crashes on my note 2 running Android v4.4.2.
Sorting maps
I was waiting for someone to do this. If you want to write a blog post about how the interop between Go and React Native works I'd certainly read it.
Awesome, am definitely planning for that! thanks for the encouragement! 
thanks! I've had someone else say it crashes on their Note as well and a friend of mine has a Samsung Galaxy Edge and it crashes. :( These Samsung devices and their AndroidAPI changes. That might be a reason it crashes. From what I've seen it's just Samsung devices. Hopefully I can figure out the issue soon. Thanks for bringing that up!
And before you start, see if you should actually begin with a monolith instead. I've made the too-much-separation too-early mistake before and it's painful to undo. http://martinfowler.com/articles/microservices.html https://signalvnoise.com/the-majestic-monolith-29166d022228
This is awesome, thanks for sharing! In order to create the apk from the source, do you just run (from your app dir)? cd android &amp;&amp; ./gradlew assembleRelease
You need to have a keystore in order to create an apk using the assemleRelease flag. That's usually used for created a release.apk for the play store. If you want to run it locally on a device (only way: genymotion wont allow you to run code on the Native side (C++, Go, etc.)) 1. Setup React Native environment: https://facebook.github.io/react-native/docs/getting-started.html 2. run cmd: react-native run-android I'll be adding that to the repo soon :) thanks for asking!
Nah the real fun is sorting by value
100% agree. Sorting in Go is really fun and trivial because of `sort.Sort` and interfaces that are satisfied implicitly. 
How would you go about sorting a `map[string]float64`?
haha yeh! Are you talking about https://github.com/gopherjs/gopherjs?
&gt; trivial
It is trivial. No lines of code needed. Sorting a map makes no sense. I thought you'd get it from the first link labeled (important) but two people had to spell it out for you.
very nice idea. I have one suggestions, though. I wrote an issue for it: https://github.com/dimiro1/health/issues/6
in that case it may not have the new import declaration completion that was introduced in gocode a few days ago.
Maps being unordered isn't a problem. The problem is getting an ordered representation of a map in Go is a pain.
Rad
The compiler and linker are getting cleaner and faster this cycle too. Mdempsky, iant, gri, and Crawshaw have been doing a lot of work in that area recently.
My book arrived today, can't wait to dig in! 
I believe some of the common code tooling, like "godef", will have trouble with this practice as well. Recently I used a package whose github repo didn't match it's package name, and the resulting implicit name broke several of these tools. I'm guessing godef and oracle would not be able to find the definitions with an " import dot"
Very nice -- I was wondering if binding Go directly to React Native was possible, as I was playing with getting GRPC to work natively with React Native.
...as if millions of `if` statements suddenly cried out in terror, and were suddenly silenced...
I have also started working on an abstraction on top of boltdb: https://github.com/raff/boltql For each "user" table it creates a boltdb table with the schema and information about indices (which field they are sorting on). Currently the data is duplicated for each index (instead of having a data table and separate indices) so reading from an index will access only one table (but writing will write to all indices). The database expects a slice of values and you should provide a marshaler that takes your structs and build the slice and an unmarshaler that receives a slice of values and stores them in your data structure. Fields are serialized to bytes using a compact sortable representation (variable length numbers) but when you use strings for keys you should use fixed length strings (actually fixed length byte arrays) to preserve order (non-indexable string fields can be stored as-is) 
Why would you want to range over something and not use it?
Probably to build up another data structure with the same length.
I think it would be easier to just use a [more traditional for loop](http://play.golang.org/p/XdxlSULPgb). While it probably doesn't matter for such a small array, I'm not sure if the compiler would optimize away the actual array accesses and I'd rather not rely on a trick. It's also more clear, where I'd see the "for range s" and think "for range what? I'm iterating over something and not using it? Well, I suppose that'll just execute len(s) times then," but I know what the other for loop does immediately.
That's a syntax error.
 s := []string{"one","two"} i := len(s) ss:=make([]string,i)
Is that for a self-compiled compiler? Or merely for the new code under the same bootstrapping compiler?
&gt; A lot could be won if it was Go-ified. Isn't "gone" the proper English word for that? ;)
True. There's so many options here. Parallelization. Caching of units of work (persistent memoization). Perhaps even sprinkling some assembly into the whole thing (graph coloring?). But...does anyone really have the impression that the current compiler is *slow*? (Having said that, better optimizing compilers are necessarily going to be slower than the really fast, simple ones, so improving the speed seems ultimately inevitable.)
&gt; if tomorrow we woke up and there was a generics implementation that was mostly good...we would rejoice I'm not sure. Perhaps. But whenever I look at such packages as, e.g., DataDraw (for C), I can't avoid the thought that simple cop-outs like C++ templates discourage people from seemingly more complicated but ultimately more performant solutions. And in the presence of decent modules, instantiating really good code by means of a code generator doesn't seem like such a crazy idea anymore.
This is just incorrect. The latest CentOS series is using kernel 3.10
But there's a trick to the interfaces - if you return on interface, you're returning a specific type form that library. It is not equal to an otherwise identical interface from another library. Furthermore, if local types are used in the definition of the interface, you cannot assert it to the other interface, as the fully qualified types won't match. In other words, the problem is that you're returning a type, and in this case it can only be fixed locally by the "confused" party (your application interacting with the type problem here). Returning interfaces would only make things more confusing ("Why are they asserting this to an identical interface?!"). Translating to a local type is a solution, but not a pretty one. However, you can fix it by *not* having libraries vendor other libraries, and rather require that the main project does all the vendoring. Figuring out what a library depends on is as simple as trying to compile it without having used go get to get everything. It works out rather well for us. 
Maybe this library will be a big and OP will want to refactor it to multiple files (possibly creating sub-packages too) and at the end of the day he's going to offer library's API under a single namespace.
The Go compiler already does significant escape analysis, resulting in many allocations not creating GC load. See http://blog.rocana.com/golang-escape-analysis.
The time.Ticker uses a channel that yields a value once per period. Often you don't care about the value, but only want to block until the value is yielded.
Thank you for your update, I wasn't aware of this (thus my afaik note).
I agree that looks like it should work. Can you produce an entire program that demonstrates the issue? Is there a race somewhere else? What does the race detector say?
I really don't mean to post snark (this sub-reddit has enough of that), but if all your application is doing is routing requests, and not doing any actual work, then maybe? The problem with those (infamous) router benchmarks is that routing performance is a tiny slice of your total request-response time, and *never* the bottleneck. The moment you read something from the request, you eclipse the time spent routing. Communicate with a database? Order-of-magnitude more! You would likely see a better performance gain by initializing slices to the size your DB result count (reducing slice copies) than by changing routers. You should also detail *why* you are faster: many zero-allocation routers in Go have been unsafe as they presume static parameters, or re-use parameters across requests (read: optimizing for benchmarks).
It's usually only useful for channels where the channel value is only informative as a sync event.
Go is so nice for these quick and dirty dev ops tools. It's often easier to write your own code than to look up the command line switches for some existing tool.
Ugh -- why is an interface{} used as the address parameter instead of a string? And why does the type assertion need reflect at all? Yeah -- this looks like newbie code. I wouldn't use it.
Proven to be the fastest (in ops/s) web Go framework is fasthttp. In most cases it's faster than vanilla http (from go std lib).
I just did that and it seemed to work fine.
Thanks! Can you reply when you have the CL completed? Thanks in advance!
No it's not, it looks that because is the standar is the fastest, no it's not it doesn't have a good mechanism for routing and all benchmarks outthere can show this
Sorry for the delayed response. Great point, I'll change it to private and run `-race` again, see what I stumble next.
Sorry for the delayed response: You can see the full library here: https://github.com/resourced/resourced/blob/master/libmap/libmap.go I captured the `-race` stack trace here: https://gist.github.com/didip/bd8b49f6b18fa6ee4190 Nothing surprising, typical race problem: 1 thread tries to set() and the other one tries to get() `go vet` does not return anything.
I doubt they'll bother.. the complex type is a bit of an inside joke by now, I'm under the impression that even the people in the dev team seem to think that nobody is actually using them (not even when implementing a mandelbrot program! : )
It was old code, I am coding 9years but I am new at golang I started to make some tests for reflect at the same time I started to write Iris, some code snippets are shit and I am thanks you @peterbourgoun for show to me, it's fixed now. I want more critism please look all the code if you have time!
Gin doesn't have it's own router, it make use of httprouter, Iris is faster than both of them. You can see the whole benchmark table on the github 'benchmarks' section. Benchmark code is also public just download and run it to check by yourself. I made a lot of tests before publish the graph. Also keep in mind that the httprouter doesn't support static + parameterized paths for the same path. Httprouter it's very good and uses faster algorithm ( radix tree ) but this has it's own disadvandages, on the other hand Iris is faster because Iris router can use cache (it's algorithm supports it). Thanks for your comment, I really appreciate it!
I have a little web experience ( almost a decade) I write an app for my personal tests with mysql database, json rendering all that you say ('small' app almost 9k lines) . I tested it with Iris and after I re-write it with Gin, Iris got well results, on some cases (routing) x3 faster than Gin, so yes it's new framework, still in hard development state, not a complete framework like others but I just started it and it seems to work better for my needs. Thanks for your comment, I really appreciate it, waiting for more!
Just to put something more concrete to my comments, I added your project to go-http-routing-benchmark and wired up the GitHubAll test for it. Here are the results on my machine Caching disabled: BenchmarkGin_GithubAll 50000 36235 ns/op 0 B/op 0 allocs/op BenchmarkIris_GithubAll 10000 132241 ns/op 0 B/op 0 allocs/op Caching enabled: BenchmarkGin_GithubAll 50000 35648 ns/op 0 B/op 0 allocs/op BenchmarkIris_GithubAll 30000 42653 ns/op 0 B/op 0 allocs/op So, in a like-for-like test it's significantly slower. Even with the caching it's slower but then it's not like-for-like - if we added a caching layer in front of Gin then that would no doubt be faster still (but then we're no longer testing routers, we're testing caches, so what's the point?). I'm not trying to be dismissive, but I think you should be careful of making grandiose claims if there are any irregularities in your testing methods and in the final results obtained. It's always good to try new approaches - I've done it myself and got pretty good results but I don't think the world needs another Go web framework unless it has something significantly new to offer - something like fasthttp for instance.
For context: 3.1GHz i7 (i7-5557U), 16GB RAM, SSD with `benchtime=20s` set to smooth out mobile CPU burst vs. thermal, I see a curious difference between that and `benchtime=60s`: BenchmarkGin_GithubAll 500000 58289 ns/op 0 B/op 0 allocs/op BenchmarkIris_GithubAll 500000 59423 ns/op 0 B/op 0 allocs/op ok github.com/kataras/iris 60.042s BenchmarkGin_GithubAll 2000000 57953 ns/op 0 B/op 0 allocs/op BenchmarkIris_GithubAll 2000000 53603 ns/op 1 B/op 0 allocs/op ok github.com/kataras/iris 341.316s (why is there a single byte per operation on the longer test? Buffer re-use issue?) Again, if I benchmarked these vs. gorilla/mux vs. goji vs. &lt;whatever&gt; with wrk on an application that does real work, I'd expect see all of this fade into the background. Pick a library with good code, a sane API and sensible defaults over raw speed. 
Enabled. No changes to source whatsoever. I can run without tomorrow (late here!), but even if it was 3x 'faster' than &lt;X&gt; I wouldn't recommend it.
https://github.com/alecthomas/gometalinter
Nice ! I'll have to run that on my projects.
This is old and there was already a thoughtful response offered (by Russ I believe): https://news.ycombinator.com/item?id=8817990
What you changed it to isn't better! Look at how other servers handle specification of listener addresses.
First of all I agree with you on the most parts, I posted this question here for that kind of comments and I'm thanks you again. But with "Not all routers can make a cache system" I mean that almost all other routers finds their named path parameters' values in the route search state. Without cache other routers maybe equal(most of them are x10+ slower) or (httprouter) faster, BUT if you make cache for these kind of routers (httprouter) you will not see big difference because again they must search again from tree deep to the nodes (radix tree is letter-by-letter based search algorirthm to get the named path parameters. These staff have their own advantages and disadvantages. For 1million requests Iris worked better on two machine I tested the httprouter's benchmark source, 2.5x+ times faster ( with cache enabled and read/write path parameters) without cache and without read/write parameters is slower for some nanoseconds. I am telling this from yesterday, also at the benchmark soure file: I have commented how to disable the cache (one line forward where the registering of routes happens) from the first day I publish this project... and again without cache only httprouter is faster than iris for shake... you write it like the iris is the slower :P again thanks you man
These results are fake, gin is always &gt; 50k and iris even without cache doesn't have so many nanoseconds difference, maybe you changed the words 'Iris' to 'Gin' and 'Gin' to 'Iris'? who knows... are you 'inlove' with gin and hate 'iris' for some reason? both are open source projects, try to be more objective and practical, realistic please, then try again, anyway thanks for your time!
You have absolutely right, (I don't want to copy source or use other for that kind of staff , not saying that it's bad thing to do, I love opensource*). No other frameworks are based on fasthttp as I read on fasthttp github readme, maybe Iris be the first go web framework based on fasthttp. I will read more about it, I want to make Iris as fast as possible, thanks you for your interest! 
cross-compile to another language, use the optimizations from it, etc
thanks all who liked my project: here are some updates: repo: react-goku and goku are now updated! I've added Development tips: for running from source, using golang, and connecting golang to React Native. I hope to write a blog post about this soon, dont have a blog of my own. Might just go with Medium :)
About the caching you are assuming that one wouldn't store the params in the cache as well, which is the way I would do it and then would not need to search the tree for them. As for only httprouter being the only one that beats iris without cache; this is the kind of statement you should avoid, because it's not true; others have spent countless hours refining their search algorithm's and may be a little perturbed. here's the proof on my MacBook Pro (Retina, 15-inch, Late 2013) 2.6 GHz Intel Core i7 16 GB 1600 MHz DDR3 using Go version go1.6 darwin/amd64 go test -bench=. -benchmem=true -benchtime=10s Gin: 56048 Bytes lars: 45440 Bytes #GithubAPI Routes: 203 Iris: 77000 Bytes PASS BenchmarkLARS_GithubAll 300000 52769 ns/op 0 B/op 0 allocs/op BenchmarkGin_GithubAll 300000 54004 ns/op 0 B/op 0 allocs/op BenchmarkIris_GithubAll 100000 143396 ns/op 0 B/op 0 allocs/op ok github.com/kataras/iris 48.896s and here is the gist of the code using your own benchmark: https://gist.github.com/joeybloggs/0f5e798d8b279fa364eb and I'm sure there a a few others.
Not sure what do you mean? Routing works fast enough for me: ... if strings.HasPrefix(r.URL.Path, "/assets/") { if strings.Contains(r.URL.Path, "..") { http.Error(w, "invalid URL path", http.StatusBadRequest) return } http.ServeFile(w, r, filepath.FromSlash(r.URL.Path)) return } fmt.Fprintf(w, "&lt;h1&gt;Hello!&lt;/h1&gt;") ... Of course, not as fast it could be, but it's sufficient for most cases.
No, they are what I get running the tests on my macbook pro. Nothing fake. No trickery. The fact that you suggest it's fake and that Gin should always be &gt; 50k (uh?) says to me that you either don't understand at all or are wilfully trying to mislead. It's not about hating or being in love with anything - it's about wanting hard facts from accurate comparisons, what comparison benchmarks done properly are meant to provide. Either way, I won't be switching to your router. Oh, and just for the record, I think Gin is a great framework but it's not the one I currently use.
I would suspect that a proper llvm pass should be able to find this optimisation, but I don't have time to try it out!
Yup, this is the answer. I was sharing map instead of copying. Thanks!
It's a custom app I wrote for a client. Unfortunately, it's not publicly available, so I can't really say much. I can tell you it's handled some requests in &lt; 1us and long requests end up in the millisecond range. There are several timeouts in the code to ensure that long requests don't stall anything. The main timeout ensures that getting the data from the back end times out after 20ms. Oh, and I still think I could make it faster. I just haven't had the chance.
It was never my goal to encrypt the IDs, just to obfuscate them, hence the simple transformation. I want to significantly raise the bar for things listed under `whys` in the repo readme and nothing more and for that a simple reversible transformation that costs a single allocation and next to no CPU cycles is better suited than a proper, heavyweight crypto. If I set out to encrypt the IDs you can be sure I wouldn't attempt to roll my own cryto :-)
&gt; why is there a single byte per operation on the longer test? Buffer re-use issue? Probably todo with the cache - I remember seeing something to maybe do some pruning which a longer test would cause to be included.
I'm new to Golang, as the post explains, and I would greatly appreciate any help I can get. Thank you in advance, should you choose to aid me in understanding the language.
Not to be mean but there is some bull-fuckery in your test results. Your benchmark is nearly 3 times slower compared to Gin when it is put in go-http-routing-benchmark. My results shouldn't be 3x as slow as your laptop and I **KNOW** my computer is better than your laptop. 
This is what I use. It works great for me. 
Except that it's really not. https://github.com/valyala/fasthttp
Perhaps I'm missing something, but it sounds like your original keys are monotonically increasing integers like PRIMARY KEY AUTOINCREMENT would generate. If they aren't increasing then you're running into the problems you had before. You mention that with an int32 there are 3,000,000 primes, but it seems that your system is susceptible because the attacker would know the plaintext and could easily check by doing a URL request. If two exist, there's a high probability your key is right. Could you explain where my reasoning is wrong?
I posted a question in the blog, but you'll probably answer quicker here. What did you use to make the pretty diagram? Thanks
I'll answer in both places! I used lucidchart. I think I've got the standard plan. It's an awesome diagramming tool! And it works well for me with a touchscreen Windows laptop.
No look down for the test of other person you make seems iris be slower... anyway I was late because I re-write the most of the router code... I make use of the custom httpfastrouter ( httprouter(gin's router) but with fasthttp) results (with cached enabled for both httprouter and my previous router code) was: 100k 20009 op/s 0/allocs 0/B and with my old version it goes again 100k operations and from ~19k-21k~ op/s 0/allocs 0/B , I spent almost 6 hours for 1k-2k NANOSECONDS... But I make it faster than it was before so thanks for your critism, I believe that your results were fake but no problem, the guy after you post some results too which you can see the difference, thanks for your comments and your time, I really appreciate it and sorry if I attack you
So to answer both of your questions: 1. Basically, use the standard library whenever there isn't a sure reason not to. It's well thought through and very well written, you shouldn't have problems with it. 2. Well, the no user input part at all makes me think it could be enough to use text/template. However, for future security's sake better use the html/template library. Because when you scale you may not notice when you actually start accepting user input and forget to change to html/template. Good luck with your web app!
[**@bradfitz**](https://twitter.com/bradfitz): &gt;[2016-03-14 18:14:00 UTC](https://twitter.com/bradfitz/status/709442470048731138) &gt;Who's using groupcache? [#golang](https://twitter.com/search?q=%23golang) &gt;I know [@Medium](https://twitter.com/Medium) is. Who else? ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/4aen81%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/joealcorn/TweetPoster) [^[Issues]](https://github.com/joealcorn/TweetPoster/issues) 
No, because the documentation for `database/sql` says that it handles its own pooling. Is there a reason to use one specifically for Postgres?
Run `SELECT * FROM pg_stat_activity;` when it runs out of connections - see what else is there.
while being able to interact with and build upon LLVM is great, it always left me with a sad taste in the mouth as developing with LLVM/CLang is such a pain the neck (once you have been spoiled with Go development process) I am longing for a set of pure-Go libraries to inter-operate with the LLVM ecosystem, such as: https://github.com/llir/llvm but nice article :)
1) Yes provided that you don't need more complicated route resolution patterns. The stdlib is fine but the routing paths are rather limited. 2) Html/template is preferred to text/template for html. The text/template lib has less functionality available to it out of the box.
I'm sure I'm missing something, but why would you order by ID? If you want to order by object creation time, why not slap a timestamp on the field, so you can actually show the creation time if you ever want to?
Every tutorial I've seen uses the JIT engine. Does anyone know of a tutorial that builds an executable (not necessarily in Go)?
* you might not have a creation date column and adding it just for the sake of ordering is a waste * you do have a creation date column, but you don't want to add another index * you have multiple inserts per second and random order of rows created within 1 second is not acceptable * you want to keep primary key index dense for performance reasons those are just off the top of my head - there are plenty more 
http://jordanorelli.com/post/32665860244/how-to-use-interfaces-in-go is still the best article on this topic imho
When benchmarking with wrk a REST api I made that hits the database, I had the same experience you did: The max amount of open connections managed by Go should not exceed 90% of postgres' max allowed or else the Go app is going to starve. I have no idea what causes it or if 90% is the right number, but after following that rule, I haven't had the application ever starve no matter the load.
Ah, do you have a single application server?
You still don't understand. If you run your code on multiple machines you will get different results - ok? Same with every other router. You even get differences between different test runs on the same machine. As long as the results are from the same machine they can be compared. It's not valid to compare results for different routers from different runs on different machines. You also can't look at a benchmark and say it's fake because it doesn't match the number you get on your machine any more than I can say your numbers are fake because they don't match what I see. All we can do is compare like for like and whether you accept it or not, those results are the ones I got when I ran your code vs Gin on my macbook.
Wow! This is cool! I'm very excited to try this out when it is released. I love text objects in Vim. And I have wanted the equivalent of "daf" for quite some time. Thanks! Beyond the commands mentioned in the video I think I will end up using "cif" (change inside function) to replace function bodies. I think it's very similar to "ciB" (change inside curly braces) but it's a little easier to type.
This is a great idea. https://github.com/sipin/gorazor also uses the same approach. Very good solution for apps that do complex html rendering.
The max connections parameter works fine, but you should not be trying to run that close to the server limit. Firstly, do you really need 100 connections? And are you leaving 100 idle connections in the pool? You could try lowering that. Bear in mind that if you hit the max connection limit in your app, you'll still get a connection when one is free. If you hit that limit in postgres, you're screwed. You can also use pgbouncer or another proxy in transaction mode. In general, using a connection manager with postgres is a good idea in a serious production site. https://pgbouncer.github.io/ Finally, the postgres default of 100 connections is pretty low. I generally up the limit to 500-800, but you may need tweak some sysctl settings. Source: I've been using postgres since 7.xish
This is *awesome* I do a YouTube video every day and I used some of fractals made by your program in [today's story.](https://youtu.be/dXNQMb4loHc) Thank you for making this!
It is a very performant approach. I toyed once with compiling text/template to native code. The performance was much much better, but I missed the ability to change templates on the fly when developing.
Did you update the project ? 'go get -u github.com/kataras/iris' and no change the default settings, the results are 100k total operations ~20k nanoseconds per operation 0 allocs and 0 bytes. If you change the default settings then the results ( on my machine) 30k total operations ~37-40k nanoseconds per operation 0 allocs 0 bytes. I run the tests multiple times with a time space between tries. I also test how much requests iris can handle per hour vs gin, test it urself and you will be surprised, Iris can handle x4 times much more requests than your favourite framework
Why would I have your project downloaded before if you just released. Your package benches at 60kns per. 
And hide the rate at which new IDs are assigned from anyone without at least moderate technical skills and motivation. Which is the best you should hope from just obfuscation. If you are looking for security encryption is your answer.
Poke. See my previous comment. 
Why can't you have both? ;)
It's been the case that in concurrent and parallel systems with shared mutable data, lifetime is hard. Let's go GC! ;)
That's one of the longest ads I've ever seen.
Why not just add/subtract x or multiply/divide by y if you think the numbers are wrong?
So what? You have to *interprete* 47% like you would have to interprete -10% or 180%. Such scale are always relative (one project compared to the other) or indicate trends (now worse than 4 weeks ago). Attributing meaning to the number 94% is, well, strange.
The main point I should have insisted is actually my last sentence. Applying a constant to the given results is pointless. OP wants other criteria 
If you want a similar "use" measurement, just scroll to the bottom of the godoc page to see how many packages import that library. 
&gt; OP wants other criteria I cannot read this from OP's post. But maybe you are right.
Haha awesome:)
It's not the same. delets the whole function including the comments whereas da} only understand what's between the brackets is. You also can put your cursor on anywhere on the same line and it still work. If you look at the details it has to many edge cases covered!
Rust and C++ allow finer control of memory allocation and cleanup. Things like RAII help make things more deterministic compared to GC. 
May be try to tune your db, this may help http://pgtune.leopard.in.ua/ 
"jamwt" specifically lists a number of reasons a bit downthread: https://news.ycombinator.com/item?id=11283688 &gt; We utilize lots of tricks like perfect hash tables, extensive bit-packing, etc. Lots of odd, custom, inline and cache-friendly data structures. We also keeps lots of things on the stack when we can to take pressure off the VM system. We do some lockfree object pooling stuff for big byte vectors, which are common allocations in a block storage system. &gt; It's much easier to do these particular kinds of optimizations using C++ or Rust. They also list advantages with respect to CPU (cgo has significant per-call overhead[0] and the project includes "fair amount of FFI work with various C libraries") and type system. [0] 100x compared to calling regular Go functions according to https://www.cockroachlabs.com/blog/the-cost-and-complexity-of-cgo/, not a problem for a few very expensive calls, but an issue for lots of relatively (internally) cheap calls
I would love some good examples of how to use it well, from front to back.
that's an upcoming feature. Just I wasn't sure how exactly I should go and implement it as there are many cases. If you have some ideas and you could share them via gist/snippet I'm more than happy to read :)
Just to be clear, HMAC is not encryption. 
Nice man! in the next post don't forget to tell us the name of the medicines you took for the memory ;) I need them too
&gt; there's plenty of room for both. And when I reach the "hypergrowth phase", I'll look into it. ... Facetiousness aside, if one does reach a good reason for exercising full control, Rust seems like a great choice.
@tty5, did you see hashids library? Isn't it solves the same problem?
The GUI would be the hardest part; first using the native window server, then rendering the graphical elements on the page properly. Of course, you could use a C library like WebKit or something to do the rendering, but cgo isn't Go. Far more feasible with Go would be a command-line browser like Lynx. All you have to do (well, basically) is a GET request, then pick the HTML elements you can display in the console. It's much simpler this way. The ultimate challenge here would be laying out the content in the console in a way that's meaningful and interactive, but I bet there are ways to do it like Lynx or even reinvent that a little bit.
https://carnage.github.io/2015/08/cryptanalysis-of-hashids/
Qt could be used for the GUI. Porting Netsurf (written in C) to Go is an option.
&gt; SOCKS can control access based on domain names supplied by clients. But transocks (or any iptables based thing like redsocks) only ever sees the destination IP and not the hostname. The hostname can only be seen(and acted upon) if the application supports (and was configured to use) SOCKS.
If the main focus is to implement HTTP using socket programming, why not start with something much simpler, like an http server? Go is absolutely GREAT for this purpose!
if the goal is to learn about networking etc then a 'simple' text based browser e.g. lynx might be a better goal. heck just try and mimick the 'lynx --dump &lt;url&gt;' for starters :)
Also I think Qt has a built in webview, you could probably pretty easily hack together something that could be called a browser with that.
I must add that the fanatic Rust fanboys on /r/programming severely down-voted the following anti-Rust thread, and on /r/rust they only hurled insults and finally deleted the thread, plus I was banned: Beware of Rust https://developers.slashdot.org/comments.pl?sid=8652809&amp;cid=51352141 You can tell a lot about a language by interacting with its community. It is one of the factors I use when I take a look a new language. That is why I chose Go :)
The whole project involves creating an HTTP server, a proxy server and a client using socket programming. I was drawn to Go for the former two but the later on is whats worrying me.
&gt; liter What do liters have to do with Haskell?
Thanks, I think that is definitely the way to go with this if I am going to use Go.
I think that reflection is a must in case like this. Not only because avoids you to write a code generator (that generates what? models from a schema? What did you mean?), but gives you the ability to handle anything related to the Scan method in a few lines. It's so easy with reflection to work with pointers extracted from structure fields or pointers to any other variable passed to the Scan method... Furthermore I don't see any other way to work with variadic functions of interface{} type
There is a class that i do not personally attend to that is done purely in go. Their next assignment is proxy server, http server, and a client. I have worked with go a bit, and i think its great for this kind of stuff, the hardest part would be the user interface, but getting to the point where you can say, fill a buffer with whatever you get through http should be fairly simple.
I would suggest to ditch the browser and implement a library and in Go that lets other developers use it for common HTTP operations. Much like Python's requests library. It would be best suited for this learning project. Once you are done with this and if you still feel passionate, you can start working on a GUI that fetches and renders webpages using the library you wrote but it would be completely different projects and most work would be around GUI and writing parsers/lexers, etc depending on how much you want to implement yourself. 
Saying that "cgo isn't Go" seems a little unfair. I understand it isn't pure and in that sense the development experience is not ideal. Seriously though, we are really just trying to build cool software. Isn't a modern graphical browser going to be using OpenGL anyway (maybe Vulkan for the super modern :p)? If you are using either OpenGL or Vulkan then cgo cannot be avoided. No? Honestly it may be quite difficult to work with WebKit in Go. I have no idea how the API is structured. And, as I understand it can be difficult working with some C application frameworks. I just think disregarding everything as impure is a little overzealous in this case. edit: Worth noting that even the runtime can suffer from using cgo. And it is worth avoiding when *possible*.
Hah. Okay. Well I don't entirely agree with him there either. That attitude is pretty exclusionary. As I said, sometimes you really can't avoid it. I don't think that population of users should be marginalized. I hadn't seen that site though. Thanks for the link.
I've played with the idea of a browser in Go actually. I'd suggest going through [Let's Build a Browser Engine!](https://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html) and trying to hack something with [`golang.org/x/net/html`](https://godoc.org/golang.org/x/net/html) for html parsing and [`golang.org/x/exp/shiny`](https://godoc.org/golang.org/x/exp/shiny) for GUI. Shiny is a WIP so be prepared to some API changes.
Thanks those are some really good references. I'll definitely take a look at that toy web browser engine. 
I did consider that. It's defiantly something that I want to try out in the future. But you know one step at a time :)
If the focus is really the networking stack, then check with your professor if you could write a web crawler instead. You would still have to specify a URL you would still be parsing html and you would still be making connections. In addition, you could have fun with goroutines and showcase what easy concurrency combined with robust networking could achieve. If the focus isn't the GUI, it should turn mundane questions like "how do I render lots of text on the screen" into "let's explore the effect of concurrent HTTP requests on a web server"... which is much more fun :-)
Rust is nice if you want to think a lot about memory, for optimization reasons, while don't minding using the full ASCII table when programming. No special character shall go unused!
From what I see, I would also ban an author of the post from the link, you provided.
Requires a Go compiler
A client can mean a lot of different things - a browser being on the extreme end in terms of complexity. For example, you could write a client that queries a restful api (maybe the HTTP server you wrote for this same project) based on user interaction or some other input, then renders the data in some meaningful way (without trying to render the entire DOM). 
A think that's a great point - what I may do is just implement a simplified client that just makes http requests and dumps the HTML to the console. I might loose some marks but I think that the main point of the project isn't to make a web browser so as long as I show that I understand HTTP I should be mostly fine :) 
The lecturer was pretty specific about wanting the web browser and GUI, but I think I will just scale it down to be a command line "browser" that just dumps the HTML to the console. I fell that the focus shouldn't be on making GUIs and rendering HTML, but rather understanding and implementing HTTP.
That is actually why I chose not to use rust for this. Don't get me wrong, I enjoy my manual memory management and C++. However, for this project I wanted to be focusing on HTTP and socket programming without getting lost in the memory management. Rust is definitely something I want to check out though and I am very interested in systems programming.
Could you explain this cgo vs Go argument? Why should or shouldn't cgo be considered to be Go?
I would guess you could for example build on this? https://github.com/headzoo/surf/tree/dev/browser
http://dave.cheney.net/2016/01/18/cgo-is-not-go Cgo eschews many of the things that make go good. Using cgo your go application is at worst just a go wrapper around a C application.
just practice more and make the cheat sheet yourself (only you know what you need on there)
There is also [ego](https://github.com/benbjohnson/ego). [Quicktemplate FAQ](https://github.com/valyala/quicktemplate#faq) outlines differences between these solutions.
Just run quicktemplate compiler - [qtc](https://github.com/valyala/quicktemplate/tree/master/qtc) whenever you need updating generated template code. It easily integrates with [go generate](https://blog.golang.org/generate).
My 2 cents: A really useful binding I wrote for Go is the `ac` text object, which looks for a matched set of braces (using the `%` operation), and includes the whole line for both braces in the text object. This makes it easy to have `dac` delete a struct literal from inside a struct definition, including the name of the struct being defined, the field name it's filling, and the trailing comma. I'm not sure how I could improve on that by parsing Go, but there's my common use case.
So cool
reddit doesn't fully use the github markdown spec. Codes blocks are indented with spaces four times. 
I used it to build my favorite website. https://c4english.com, This is one of them. 
I used Go to build backend for Hacker News Room [http://hackernewsroom.com](http://hackernewsroom.com), a web reader for Hacker News. (The front-end is React.) You can read most posts directly. It supports comments collapsing, integrated comments view. It's a hobby project. My deployment: * The app runs in docker on Debian. * I build the executable on mac and copy it to remote linux. * I put related resources (html, javascript, images) in a git repository. Highs: The performance of Go app is good. It uses few memory. I really like Go's memory efficiency. Lows: If you use goroutines and channels in the wrong way, there will be memory leaks.
For your k-v store, how come you use a Mutex and not RWMutex? Your GET method Lock()s the map and prevents concurrent reads - you could allow them using an RWMutex and RLock() instead. Did I miss something?
Well, I think it was trying to point out multiple ways of getting caught by the fact that the i is scoped inside the for loop.
I think it's a demonstration that even though it seems that all the references to it are inside the loop, the fact that defers get run after returning from the function and goroutines spawn another thread mean that it's actually not really within scope when the code is run.
I get that this is a microservice and all but, why are you deciding to use your own custom rolled db solution instead of using the standard database package to load an off the shelf datastore? Seems like it would have less overhead and also be less error prone.
You'll have the sysctl tuning issues with any language. Websockets (or any sort of connection) require file handlers, that's not a Go issue.
Python is different because it doesn't have block level scoping, only function level scoping. Go is surprising because loop variables are scoped to the loop alone, but get reused from one cycle to the next.
What about a custom handler that always serves the index.html if it doesn't hit a file?
Just 3? Java had an entire book dedicated to them. ;)
No need to apologize! I figured that was what was happening, I just wanted to be sure. Your packages have been a huge boon to my development experience, and I appreciate the explanation.
Are you going to keep the large monolithic ?
I agree with the first two. For the third, I think the main cause is the := operator and not the shadowing. Often you want to declare a new variable, so you use := and you forget about the second one which becomes shadowed. If the := operator was not "distributed" but used independently for each variables like that: :result, err = tryTheThing() // only results should be declared it would be less easy to wrongly implicitly declare a new variable because you would have to explicitly type it like this: :result, :err = tryTheThing() // both results and err should be declared 
&gt; On the rougher side, it is not that optimal as an API language compared with e.g. python, because its much lesser degree of metaprogramming facilities, and that it does not have a REPL. This work with the Jupyter project might interest you: https://github.com/gophergala2016/gophernotes
For me, the third one is more support for never declaring return variables in the function scope. It almost always leads to less readable code
&gt; Python is different because it doesn't have block level scoping I know; block level scoping is irrelevant. I demonstrated the same behavior with Python using only function-level scoping. &gt; Go is surprising because loop variables are scoped to the loop alone, but get reused from one cycle to the next. What programming languages *don't* reuse variables across loop iterations? Here's C reusing the variable across loop iterations (also, note that C binds `i`'s scope to the for loop): #include &lt;stdio.h&gt; int main() { for(int i = 0; i &lt; 10; i++) { printf("%p\n", &amp;i); } } 
This confusion is brought to you by return-only-once madness, not shadowing. Do the sane thing and the problem goes away: func DoTheThing(reallyDoIt bool) error { if reallyDoIt { if err := tryTheThing(); err != nil { return ErrDidNotWork } } return nil }
With a good vendoring tool, picking up the latest versions is just an update command away. 
Go is different than C though. In Go you can refer to a seemingly stack allocated variable with &amp; and promote it to the heap. Of course C uses the same stack slot for each loop. C is gonna be C. But that Go reuses stack slots without doing an escape analysis was a choice, not inevitable. It could promote loop variables to the heap if it wanted to. 
npm shows how many projects were using (downloading) particular package during the last week/month. "Use metric" of godoc doesn't degrade through time, so it is hard to value it. Imaging 100 abandoned projects used the package several years ago. It doesn't mean the package is still relevant. 
A big thank you for all your work on go-plus. I enjoy using this plugin every day!
Every use metric is flawed in some way, though. If a package in npm doesn't change often, requiring a new download by everyone using it, you're only getting a read on the number of new uses rather than total uses. 100 active projects that haven't re-downloaded the package won't show in the numbers, but 1000 toy programs that download the package can skew the numbers. Nothing is inherently better or worse about either use measurement.
Agreed, I prefer gopkg.in
I'm still not sure what the hang up is here. At first it seemed like the OP was confused that Go closes over values, so I demonstrated that this is normal behavior via Python example. Then you said that Go's behavior is odd because it reuses variables across loop iterations, so I demonstrated that C does the same thing. Now you're saying that C's behavior makes sense because "C will be C", but that Go's behavior is odd because "Go is not C". Could you please provide a clear example that demonstrates specifically what about Go's behavior is confusing to you? Because I feel like we're probably talking past each other.
Go's maps are safe for concurrent reading.
Which is why one should protect them with a [RWMutex](https://golang.org/pkg/sync/#RWMutex).
Indeed. But you still have issues if you declared the variable earlier in the function block.
All the more reason to have a minimal set of vetted dependencies. You shouldn't be using Joe Q. Random's Awesome Go Package where you have to worry about him deleting it or randomly changing the API. 
I had the same worry when I first started learning Go. As I became comfortable with the language the worry went away and the benefits of implicit interface implementation became more clear. Now I believe it is one of the best aspects of the language. It allows for better decoupling of types and packages, which is a very good thing.
&gt;Does go-qml depend on Qt version? Do you mean does it depend upon any specific version? The wiki seems to mention Qt 5.1 and 5.0 support, but you should try it with a newer version as well. I cannot attest to whether or not the project is still going on, but maybe the development has reached a stable state, which is why the commit history is old. I do not believe there to be any alternative QML wrappers for Go.
You'll never pry my hands away from Sublime! All kidding aside, this is fantastic
You could try setting different color schemes in your editor of choice for different languages. Might help to keep them distinct in your mind.
Nearly every language specific plugin will do this for you already. If you are using a plugin manager and the plugin doesn't do it, it will generally have support for this. For example, vim-plug uses this syntax (you don't need it for vim-go, but just an example): Plug 'fatih/vim-go', { 'for': 'go' } 
having implicit interfaces also has the effect of making interfaces smaller and more useful by consequence.
I just tried it with qt 5.5 and it worked. Not sure if there is a hard dependency with qt versioning or not. &gt; but maybe the development has reached a stable state, which is why the commit history is old. The readme mentions the alpha release. There are some bugs causing crashing on windows which are open.
Go is definitely more geared towards "the unix way" of command lines and hand running stuff. All my go dev iterations are basically: go install ./... &amp;&amp; appname where app name is the executable i want to run. Bouncing the app consists of me hitting Ctrl-C, Up arrow, and enter. Not as straight forward as hitting F5 (or whatever VS uses these days), but also not that bad. As for editors doing this automatically, i haven't seen one. Probably due to not having any concept of a project / solution. You may have luck with Intellij IDEA and the go plugin. That all said, /u/jeffrallen is right. Simple editor and command line is probably your best bet. Not sure I'd go as far as Notepad. I use Sublime Text with GoSublime plugin myself. 
Would this play nice with client side JavaScript? I'm coming from a the JS world and I can see this very useful for server side rending anything with data iterations and leave user interaction to the client using something like RxJS
Maybe, but what would you do instead?
The Go community has a slightly different philosophy when it comes to external packages. Gophers are the happiest when they are able to keep their dependency trees really small, which makes for programs that are simpler, compile faster and easier to maintain. These thoughts are more or less captured in the Go proverb: "[A little copying is better than a little dependency.](https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=9m28s)" That way of thinking has lead many gophers to try and go as far as possible with the standard library and use external packages if and only if it's absolutely necessary. Compare that philosophy with other languages where importing dozens or even hundreds of external packages is the norm, it's clear that a strong metric for their packages is practically necessary. Of course sometimes even a gopher will need external packages, especially when it's a large project. Sometimes it's necessary, there's no question about it. But even in that case, Go has been designed to be simple and to read well on paper; it's trivial for any gopher to check parts of the code and inspect it's quality before deciding to depend "forever" on it. Having a dependency is a trade-off so it's better to make absolutely sure that we need the code that we are importing and we cannot replace it with a few lines of our code. Now every gopher will use different measures when they decide which external packages to use but here are a few questions that I ask myself when I try to decide if I should use an external package or decide between two similar ones, in no particular order: * Is it pure Go? * Is it idiomatic Go? * Does it have sufficiently few dependencies? (ideally zero) * Which one seems to be used the most by other projects? * Which one has more GitHub stars and why? * What does the community think about that external package? * Is the code well-written and simple? * Will I be able to debug that code if something goes horribly wrong? * Are any big projects/companies using that package in production? * Is the code well tested? * Does the project have good documentation? * How stable is that package? * How many and what GitHub issues does it have? * How often are the package authors updating/fixing the code/accepting PRs. * Are the package authors committed to keep master with no breaking changes? There are possibly more useful questions but that's all I can think of right now. I firmly believe that taking good care of a project's dependencies (sometimes that means eliminating them) should be a constant exercise that every good coder should do. I could even go as far as argue that not having a central repository, metrics and package manager like Node.js does is actually a boon for the Go community but I digress. 
install atom-build. It allows you to throw the go build command behind a hotkey in atom. terminal is also a nice package, allowing you to start your build executable from inside atom.
In what way does MyClass implements Eater Giving you any more information? With most traditional statically typed languages all you're getting as an implementer of an interface are clues in the form of types. You still get this with Go, just without the boilerplate and you get a lot more flexibility
Vim-go only loads when you start editing a Go file. Otherwise nothing is loaded into your vim session, even all :GoXxx commands are not available until then ;)
ERP is a strong transaction system,is go suitable for it? 
 func main() { r := mux.NewRouter() r.Handle("/js", http.FileServer(http.Dir("../sitelocation/js"))) r.Handle("/css", http.FileServer(http.Dir("../sitelocation/css"))) // Also include every other folder or static file in the root you want to publish r.NotFoundHandler = http.HandlerFunc(notFound) // Fallthrough for HTML5 routing http.Handle("/", r) } func notFound(w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r, "../sitelocation/index.html") } Declaimer: I don't use MUX, so I don't know if this is 100% correct.
Just adding to reasons, In explicit implementations sometime you spend a lot of time in beginning of project to design your interfaces. At that time you might not know the best design you need. So you will end up doing more refactoring. In Go's implicit way, you can define your interfaces later in the project or add interfaces to old code without extensive refactoring.
http://vim-bootstrap.com/
Easier said than done. If you work with a team of developers, have CI/CD setup, and your projects are many thousands of lines of code, you'll learn very quickly that dependency conflicts are an unavoidable fact of life. 
oooo thanks, those seem great! i'll install them tonight after work!!
&gt; being in the Visual Studio world for the past 10 years it's tough to get used to spending so much time with CMD So take learning Go as a chance to correct that. As a person who has hired and interview developers in the past one of my major turn offs is if they can't work inside a command line. I get that Windows and Windows development tools don't let you get away with a lot of command line work (and the command line is terrible in Windows). Personally I recommend installing Git Bash (cygwin itself can be an overload when starting out) to get some unix tooling and behavior (and BASH!) and then use ConEmu setting up your tab defaults to run Bash. I recommend working this way and you'll either still not catch on or you end up loving the command line so much you'll wonder why Windows tries so desperately hard to keep you out of it (I feel in love with it, 90% of my work is through a terminal now -- albeit I quit working on Windows machines and got a Mac)!
That's essentially the main motivation for this whole exercise...I'm trying to broaden my skillset and knowledge-base...when you get silo'd into a certain type of work for a long time it tends to shape your thinking and I'm just really in the mood to spruce up my abilities. not to mention that over the past few years getting a chromebook for my wife, and various android devices, which have both been tastes of an "alternative to microsoft" i've really gotten a sense that I really like that alternative
Total slide gore. I couldn't read a thing. 
They could make nil checks just work, i.e: if someFuncReturningInterface() == nil { // works! } The fact that nil interfaces are typed is an implementation detail that can (and IMHO, should) be hidden away by the compiler.
This is false. For example, the contract for io.Writer: https://golang.org/pkg/io/#Writer Returning an error does not mean that the other value is invalid.
&gt; https://speakerdeck.com/mitchellh/advanced-testing-with-go Interesting. I see the port binding is zero. Does that just pick a random open port?
As far as I know, there is no difference between `nil` and `[]T{}`, so the caller would have no means to inspect the return value to distinguish between your "not found" and "found but empty" scenarios.
There is. []T{} != nil
Oh, cool. I didn't realize.
As far as I know there is no Levenberg-Marquardt. It's on my mental list, but I won't be able to implement it soon. There is a Newton method in the gonum/optimize https://godoc.org/github.com/gonum/optimize#Newton. The entry point to optimize is the local method https://godoc.org/github.com/gonum/optimize#Local. Depending at the problem at hand, you may just want to use the default BFGS. The is also https://godoc.org/github.com/gonum/diff/fd if you need gradients, though as a warning there are some facelift PRs under submission. We're happy to help answer mat64 questions, either here or (probably better) gonum-dev (https://groups.google.com/forum/#!forum/gonum-dev). As one of the developers I'm biased, but mat64 is the best matrix library for go in my opinion. It's well tested and feature complete. We are aware we need more usage examples, but to date we've been working to make sure it's feature complete and well tested. If nothing else, your feedback on what you find confusing is valuable for when we create less formal documentation. 
I'm one of the devs who worked on this. vCloud support is planned and is being tracked at https://github.com/apcera/libretto/issues/18
Thanks for this, /u/valyala! I'm a huge fan of mako and one of the biggest things I miss in Go. I love the idea of using interfaces for block placeholders, very smart. Some first impressions: - I do miss mako's one-liner %-prefixed and &lt;% %&gt; for multi-line declarations, seems less noisy. - With the `{% code ... %}` declarations, the `code` keyword seems maybe unnecessary? Seems like it could be `{% ... %}` and have a default pass-through if it doesn't match any of the other keywords you have defined (import, etc). - When using `{% code ... %}`, you end up having `{ ... }` in side of it which starts to look quite weird with `} ... %}`. Maybe another case for `&lt;% %&gt;` for multi-line pass-through code declarations. - Some keywords are consistent with Go but things like `{% interface Foo { ... } %}` rather than `type Foo interface` stands out. I feel that would ultimately be more in-line with mako philosophy of making it consistent with the underlying language, but it would require somewhat more sophisticated parsing. (Same with func which doesn't have a return value) - Idea: Would neat if there was a template language inside the template language to support for easy text output/accumulation from within funcs/code blocks. It would be kinda like JSX in React. Example: {% code func (p *page) Body() string { if (p.Foo) { % This string gets printed when Foo } % This string gets printed always i := 42 % String with a variable: {%= i %} } %} Lines starting with % would be treated as micro-templates that accumulate into a returned string buffer. Anyways, much of this is probably just a matter of getting used to things, and I understand it's probably too late to change the syntax, but hope the thoughts are useful. :) Again I appreciate your work, thanks for building this!
Have you looked into the go-imports tool? https://github.com/bradfitz/goimports It imports libraries automatically and gets rid of unused imports as well. 
Exactly, by returning nil we avoid the construction of an empty slice and have the benefit that the caller can append nonetheless to the return value, whether there was an error or not. Avoiding slice allocation would be preferred.
does this work for atom? edit: yes it does, thanks
True. But I like my chances of spotting it better when it's declared in the body
Yeah, do you have the go-plus plugin installed? https://atom.io/packages/go-plus
I was taking a look at the map implementation today, here's another safety vs performance tradeoff in the number of checks in every make(map) call: // makemap implements a Go map creation make(map[k]v, hint) // If the compiler has determined that the map or the first bucket // can be created on the stack, h and/or bucket may be non-nil. // If h != nil, the map can be created directly in h. // If bucket != nil, bucket can be used as the first bucket. func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap { if sz := unsafe.Sizeof(hmap{}); sz &gt; 48 || sz != uintptr(t.hmap.size) { println("runtime: sizeof(hmap) =", sz, ", t.hmap.size =", t.hmap.size) throw("bad hmap size") } if hint &lt; 0 || int64(int32(hint)) != hint { panic("makemap: size out of range") // TODO: make hint an int, then none of this nonsense } if !ismapkey(t.key) { throw("runtime.makemap: unsupported map key type") } // check compiler's and reflect's math if t.key.size &gt; maxKeySize &amp;&amp; (!t.indirectkey || t.keysize != uint8(sys.PtrSize)) || t.key.size &lt;= maxKeySize &amp;&amp; (t.indirectkey || t.keysize != uint8(t.key.size)) { throw("key size wrong") } if t.elem.size &gt; maxValueSize &amp;&amp; (!t.indirectvalue || t.valuesize != uint8(sys.PtrSize)) || t.elem.size &lt;= maxValueSize &amp;&amp; (t.indirectvalue || t.valuesize != uint8(t.elem.size)) { throw("value size wrong") } // invariants we depend on. We should probably check these at compile time // somewhere, but for now we'll do it here. if t.key.align &gt; bucketCnt { throw("key align too big") } if t.elem.align &gt; bucketCnt { throw("value align too big") } if uintptr(t.key.size)%uintptr(t.key.align) != 0 { throw("key size not a multiple of key align") } if uintptr(t.elem.size)%uintptr(t.elem.align) != 0 { throw("value size not a multiple of value align") } if bucketCnt &lt; 8 { throw("bucketsize too small for proper alignment") } if dataOffset%uintptr(t.key.align) != 0 { throw("need padding in bucket (key)") } if dataOffset%uintptr(t.elem.align) != 0 { throw("need padding in bucket (value)") } .... Although I'm not absolutely sure this is the implementation actually called by the compiled code. And generally maybe garbage collection optimization would mean minimizing the number of calls to this function anyway. https://github.com/golang/go/blob/master/src/runtime/hashmap.go
Transactions are something the DB takes care of, I'm not certain what you mean?
this is great ++
It was genuine, I seem to recall there being another Vim plugin for Go but I never had to use as vim-go has everything and is always improving.
the most shallow and pointless article I've read in ages. 
Was this from last night's SFGo meetup?
From the net/http.NewRequest docs: &gt; NewRequest returns a Request suitable for use with Client.Do or &gt; Transport.RoundTrip. To create a request for use with testing a Server &gt; Handler use either ReadRequest or manually update the Request fields. &gt; See the Request type's documentation for the difference between inbound &gt; and outbound request fields. 
Basically. Except I forgot to hit record last night (just like the other three speakers, who also forgot), so I had to give the presentation again this morning to myself, just to record it. 
That is helpful - having that bit put in front of me without the other stuff. I read that sentence from the documentation probably 5 times, I've poured through that package quite a bit, but quoting that relevant bit does clear it up quite a bit. The way I had read the package (apparently without fully focusing on it) made me think I could test the handler individually like this, and it looks like I cannot - not like this. I was going to put my muxing in the same file eventually anyway, but I can test the handlers through the muxing and the server and it shouldn't be that bad. I guess in the end I needed a kick to push me that way :-) All the same, ty tons :-)
That does help. I was trying to avoid setting up a server, and manually test the handler with a request - mostly so my unit test was just testing that specific bit. But the quote from above pointed something out to me that's obvious now - it clearly says I cannot do what I'm doing, I just missed it. I'll either change this to do ReadRequest, or I'll use this method - I'm not sure which way is going to look simpler. I might write a test for each way, who knows? Still, I appreciate the help :-)
Dang, that's frustrating. Thanks for going through the trouble to record it!
The net/http/httptest package can make writing tests easier.
The poop emoji looks like the logo for the entire video. Intentional?
You are using a mechanical keyboard? Maybe with blue switch？
This is a good point. RWMutex did make sense in our case, and speed was not the main concern, correctness was. Good to know though. 
I had saw that, and was using httptest.ResponseRecorder to inspect the response from the handler. It just didn't click to me that I couldn't call the handler directly - even though I read it quite a few times.
http://espeleta.info/2016/03/16/Swift-ang-Go/ this article has 7 alternative libs to QML
Or you can leave traces in and just turn them off: https://github.com/vhodges/dbg
It is definitely possible! Here's a [screenshot of the one I wrote](http://i.imgur.com/SXmwW3v.png). I wrote it mainly to browse reddit and HN at work at the time. The latest version was last committed in July 2013, so it's pretty old. The way I did it was that it worked like Vi (had a command mode, an insert mode, browse mode, link extraction mode...) **EDIT**: Holy Nostalgia Batman! I went back through my git archives, and found a [screenshot of the version before that](http://i.imgur.com/fQsLg8f.png) ... this was when I thought colours were a good way to identify stuff (no, it turns out having colours were less user friendly than having no colours) Oh I also integrated it with the JS engine that I built (also in Go, and JIT compiles to X86), so I could have fully upvoted articles on Reddit and HN (and login to wordpress to write in my blog) **EDIT 2:** More fun memories - [an unupdated architecture map](http://i.imgur.com/lkJ90rX.png) of the JS engine... I eventually completed everything. Everything was nicely pipelined from one stage of the compile to another. I tried adding a rudimentary AOT compiler, but I gave up on the project. 
Currently the tests are at only 70% coverage. None of the TOS renewal code is actually tested yet, since the staging server didn't change its TOS. Hopefully I'll get some mocking up to check those cases. This was built for adding to another project (not yet released). Ultimately, I'd like to see the certificate auto-renew in a normal configuration (some config options have to be changed for tests to complete). And that will take 2 months :)
We've used Gorilla quite a bit and have been pretty happy with it too. Is there anything in particular you're curious about?
Caddy is awesome! Good luck with the talk..
thanks joe, go-plus is amazing!
&gt; I don't like this approach, since it looks like overkill :) I agree, just a crazy idea but would be handy for very logic-heavy blocks. In some of my mako templates, I've found myself accumulating string buffers in those scenarios and just rendering them at the end. It's not super common so not a huge deal. &gt; This decision is intentional. Conceptually func templates may return only a string value containing their output (behind the scenes it writes output to a stream due to performance optimization needs, but it is just implementation detail). Allowing other return types would make quicktemplate easier to misuse and harder to properly implement. Agreed also. I actually wrote up a few variations for different syntax ideas to pull it further away from the uncanny valley of similarity, but none were enough to feel better. So good work, keep at it! :)
[Shelling out to OpenSSL/LibreSSL](http://play.golang.org/p/TyLE8UFQGc) will be the easiest solution. Getting anything else properly working across platforms will be several magnitudes of more effort.
&gt; All packages are now written in JavaScript (ES6) instead of CoffeeScript (hopefully this makes contribution easier) Great news. I haven't needed to poke at go-plus's source yet but this has stopped me in other cases.
The point of that slide was that the way we brought http2 into Go 1.6 prevented the poop from getting all over the net/http package. 
I use mako also. Why didn't you keep the same syntax as mako ? it could help to migrate.
It looks like you're on version &lt;=1.3 of golang. the crypto.Signer interface was added in 1.4. Furthermore, the GetCertificate function in tls config which makes certificate management possible at all was introduced in go 1.4. It later underwent further changes in go 1.5, which enabled this use case. I should probably add this to the README, but I can only say with confidence that acmewrapper will work in go &gt;=1.5
You beat me to it. :) I started writing something nearly identical the other day. I had hoped somebody would do this and was thinking of it when we fixed https://github.com/golang/go/issues/14268 (fix: https://go-review.googlesource.com/19381) 
erm, turns out that min version is 1.6 (a mini change was made allowing Certificates to be nil)
Good to know... I really need to upgrade at some point. I'm still on go 1.3 
Thank you for your hard work!
We use RPC over websockets for juju (github.com/juju/juju). Both for inter server communication and for client-server communication. We have both a go client and a web client. Works great, no problems. 
Does making your own listener and calling `http.Serve` instead of `http.ListenAndServeTLS` prevent HTTP2 support? Update: Found the answer: https://github.com/golang/go/issues/14374 Update: Mixing this package's example with the code in the above issue... This will run HTTP2. import ( "crypto/tls" "fmt" "github.com/dkumor/acmewrapper" "log" "net/http" ) func main() { w, err := acmewrapper.New(acmewrapper.Config{ Domains: []string{"domain.com"}, Address: ":443", TLSCertFile: "cert.pem", TLSKeyFile: "key.pem", // Let's Encrypt stuff RegistrationFile: "user.reg", PrivateKeyFile: "user.pem", TOSCallback: acmewrapper.TOSAgree, }) if err != nil { log.Fatal("Let's Encrypt: ", err) } mux := http.NewServeMux() mux.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) { fmt.Fprintf(w, "hello dolly\n") }) ss := &amp;http.Server{ Addr: ":443", Handler: mux, } config := w.TLSConfig() ss.TLSConfig = config listener, err := tls.Listen("tcp", ":443", config) ss.Serve(listener) } 
I did not look too deep. One first thought is that by reading the readme, I'm not sure what to really expect from the package or your service nor how to use it. Second thought, being that you have client code, I'd expect some (all?) tests to be using `package bandwidth_test`. This package can exist in the current namespace, but prevents your test from accessing non-exported methods. This will also give people a better understanding of how to use the package. And I agree with /u/eofig, have exported structs that we can use and avoid `map[string]interface{}`.
BTW here's the Thunderbird docs for signing/encrypting via PGP https://support.mozilla.org/en-US/kb/digitally-signing-and-encrypting-messages
Because mako is for python, while quicktemplate is for go :) Unfortunately Go and Python have no common syntax, which may be shared between templates. Definitely quicktemplate could use mako delimiters `&lt;% %&gt;` instead of `{% %}`. But I chose curly braces because they interfere less with surrounding html code full of angle brackets.
I use the standard golang implementation. No problems, except for Cloudflare sucking, but that's not Go's fault
Thanks for the reply, but please focus on the problem instead of code reviewing.
A lot of the time, the problem is caused by one of the little code smells, like the fact that on error you just log a line and continue.
sorry, but nope. No errors appeared at all. btw it is just a simple sample code. 
I've tried your advise but the problem still occurs. I found a similar post at google groups: https://groups.google.com/forum/#!searchin/golang-nuts/https$20leak/golang-nuts/AhtZS3OgGM4/8cJIzcAPMhgJ https://gist.github.com/rnapier/dfbae391898e11c2598c Maybe it is in fact a leak...
I'm going to go ahead and suggest that no one else reply to the snarky OP who obviously knows the answer and is just testing us.
From what I see in the mailing list you sent me near the end of the thread it seems like they came to a resolution and a explanation. It doesn't seem to actually be a leak from the looks of it but more of a "you need to optimize your code" situation. Go is making it very easy to build a scalable webserver but to make it scale in every sense (resource consumption etc) you need to fine tune it a bit
https://tip.golang.org/pkg/text/template/#hdr-Actions - see the new `{{ block }}` action.
Thanks /u/rukittenme and /u/elithrar_ , I will your links carefully and thoroughly as soon as possible! In the meantime, upvotes for you :)
This is not actually much of a language issue, it is more of a common web development issue. As such, this is not the best forum to seek advice if your objective is "count the unique page-views of a web page" rather than "count the unique page-views of a web page in my school/hobby golang project." If this *is* a hobby project, then the best approach would be to rely on a [cookie](https://en.wikipedia.org/wiki/HTTP_cookie), which I believe is covered by the godocs.
not that I'm aware of but modern office docs (docx, xlsx, *x) are just zip files with xml. You can extract and then just manipulate the xml then rezip them.
I definitely agree that checking some other generic programming forums would be great too. But, just for the record, I think we should also openly encourage asking questions like these in /r/golang and in the Go community in general. We're all here to learn things about programming, too, not _just Go_, otherwise this forum would have very little to no content at all. I think you probably share this sentiment anyway, but just wanted to raise for others looking and misinterpreting your comment. :)
Try io.Copy(ioutil.Discard, response.Body) before calling Close. In most real programs this is not required, because you actually consume the body to do something with it, maybe except for handling special HTTP status codes. By consuming the whole body the TLS connection may be reused on the next request. Here's the references to the implementation in 1.6: an early .Close() will send false to the readLoop(): https://go.googlesource.com/go/+/go1.6/src/net/http/transport.go#1154 the readLoop will not call `tryPutIdleConn` then: https://go.googlesource.com/go/+/go1.6/src/net/http/transport.go#1179 Does this explain what you are seeing?
build the system that records raw page loads and cookies separate from the deduping analysis. that way you can refine your deduping separate from the data. or, Google Analytics and it's cookies may be good enough
great idea. There is algo a portuguese channel on gophers.slack, it would be great to revive it
Incredible! Thanks so much for working so hard to make our developer lives better
Not in this case; I'm defending the general attitude of "only good code should be extensively debugged".
Looks really neat. I couldn't say from the documentation, but does the router accepts regex named parameters or just allows by catching using colons? 
Unless you want a test that verifies the exact implementation (call A with string B, then call C with args... I see this occasionally, but find it rather useless), it's not very testable. If you have a test database, you can test that the entry appears, but this is an integration test, and a potentially heavy one.
And that's a perfect explanation. Thank you for your efforts!
Some first impressions. Run gofmt. I think you did not do this because of your import ordering. Second thought, an advantage of TDD is you are forced to think of your API design and testing upfront, helping to prevent cases where dramatic refactoring is needed. Third, it would appear you are making a new connection to the db with each call of `getDB()`; you don't need to do that as the sql package handles connection pooling and is safe to access concurrently. Instead of creating a new connection each time, just pass in the db. As for testing, here are my initial thoughts. I tend to prefer passing an interface with matching methods into functions under test. You would have a test struct that matches the interface, and pass that in (and have its internals do what ever you need for your tests). If that is not easily achievable or your interfaces get unwieldy, you could look into dependency injection or mock objects. A sometimes unpopular opinion is to spin up a test database for the test run and remove it after. This may be the easiest approach, requiring the least amount of rework. A couple of other thoughts as I glanced through the code. I see there is an endpoint that returns all users. At this point, you may not have many users. If you plan on ever having a large dataset, think about paginating results. I see you are sending email through gmail. If you find deliverability to be an issue or you want to get some stats on your email, check out [SendGrid's Go Library](https://github.com/sendgrid/sendgrid-go) (disclaimer, I work at SendGrid). Cheers!
General advice: don't use microservices until it makes sense to do so. Only break the application apart when you need to independently scale that part of your service. Microservices can also be helpful when you have multiple teams, allowing a team to deploy on their own schedule. In this case, an about page probably does not need to be independently scaled or have its own dev team ;). If you don't want to use something like [go-kit](https://github.com/go-kit/kit) or [go-mircro](https://github.com/micro/go-micro), you can just just run one go service at `:$PortA` and run a different service at `:$PortB` using the standard http library. So service A would allow something like `curl localhost:$PortA/about` and when that request comes in, service A would call service B like: `resp, err := http.Get(fmt.Sprintf("http://localhost:%d/b-specific-page-for-about", PortB))`. This means that `curl localhost:$PortB/b-specific-page-for-about` would return the same as the previous curl. One just calls the other. 
&gt; A sometimes unpopular opinion is to spin up a test database for the test run and remove it after One way to do this is using a combination of docker and drone (http://readme.drone.io/). You can have a test database docker container, and have drone automatically spin up the db for tests, run through everything, and then shut it all down.
julienschmidt's benchmark repo hasn't had new results posted since June 2014, and he claims his httprouter is the most efficient. Take it with a grain of salt. I don't know anybody who actually takes the time to run the benchmark. I just tried and got a nil pointer panic. It'd be refreshing to have someone fork the benchmark repo, keep the results updated, and not create their own router thereby introducing bias. 
This looks pretty good: it ticks the boxes in terms of `net/context` support, good documentation and what appears to be a `http.Handler` compatible API. 
Ask over on the Gophers Slack community (https://gophersinvite.herokuapp.com/) as well. Lots of GCE users there. 
Handy! I hope he covers using urlfetch in a go routine I seem to be having trouble with that (works locally not on prod)
Will do, thanks!
Maybe because they want to support older go versions, or because they've never heard about it before (I just heard of it for the first time)
They're not identical at all. They have distinct API's (parameter handling, net/context), differing levels of maintainance (one new; one established), and this question gets asked for every. single. routing. library released. A great example is gorilla/mux: not the fastest in a benchmark, but one of the most powerful (full regex, query param matching, etc). If your first question of a routing library is "how fast is it" then your metric for evaluating these libraries needs to adjusted. 
GAE = ~~Golang~~ Google App Engine &gt;to save others the trouble of looking it up. Edit: &gt;Changed Golang to Google, cause it makes a huge difference. [Got confused by this guy's labeling of this video](https://www.youtube.com/watch?v=XxFUgMDRyUI&amp;index=93&amp;list=PLSak_q1UXfPrI6D67NF8ajfeJ6f7MH83S).
Err, Google App Engine is the product. It comes in Java, Python, PHP and go.
I watched all 140 episodes. Great content. Go routines are not supported in app engine. You can however use tasks and will need to rethink your app flow a bit
A few things I've learnt from using AppEngine that I can think of off the top of my head Prefer to pay more for datastore writes if it improves read performance - assuming you read data a lot more than write it. You can create your own 'composite index fields' that aren't in your struct which saves money vs indexed properties + a composite index. You can host multiple servers in a single instance - switch on hostname (e.g. api.server.com, auth.server.com). Have a separate module for front-end assets (e.g. SPA) costs nothing in instance hours. Version assets (scripts, css etc...) and serve with long cache times - like a CDN. Use task queue / delay for anything expensive that doesn't need to be in the immediate response. Go is significantly better at processing than python when it comes to mapreduce operations over the datastore (no more ndb memory issues, tens of thousands of entities in a single task request). Don't be afraid to use the Managed VM option if you want the best of PaaS scaling and flexibility of custom runtime (docker container). GroupCache + the GCE API can make auto-setup of a cluster easy (and cheaper than the memcache service which now seems insanely expensive). It takes a little extra work to setup but it is possible to make app engine an implementation detail. By that, I mean you use an interface to allow different storage backends and limit dependencies on appengine so you can run your app elsewhere using MongoDB or whatever. Even if you only ever run on appengine you still get the benefit of having isolated testable modules without having to fire-up the local dev-server in your tests.
Is there a statement anywhere saying go routines dont work with GAE tools? It doesn't make sense to be forced to do everything on main thread 
Ah this makes sense... somewhat frustrating unfortunately! Thanks for that.
People not using acronyms are the real mvp
Implementation used by facebook https://github.com/facebookgo/generics
Goroutines don't make much sense for GAE because you have to assume instances being killed and spawned all the time. The delay package should fit you case well.
Changed it. [Got confused by this guy's labeling of this video](https://www.youtube.com/watch?v=XxFUgMDRyUI&amp;index=93&amp;list=PLSak_q1UXfPrI6D67NF8ajfeJ6f7MH83S).
Cool project. How do you see this project fitting in with Kubernetes Deployments which aren't stable yet but will be in 1.3?
Good argument, I see your point. Is the name of the field configurable? We might need to use another field to route.
I know you've gotten quite a bit of "why don't you use a 3rd party router" over in slack but I agree with your stdlib first approach. Especially in a learning example. While the built in mux won't stand up as soon as you get more complex routing or real performance needs this is a fine place to start.
Go on app engine runs everything in one main thread. I seem to remember one of those videos from Caleb mentioning no support for goroutines on app engine. Found this: "Although goroutines and channels are present, when a Go app runs on App Engine only one thread is run in a given instance," the Go team members said. "That is, all goroutines run in a single operating system thread, so there is no CPU parallelism available for a given client request. We expect this restriction will be lifted at some point." http://www.cnet.com/news/google-app-engine-goes-for-go-language/ 
I'd recommend keeping as much of the data (locations, etc) external to the code. It makes the code a lot more generic, and then you can make an entirely new game by just writing up new data files. Note that you don't need a database or anything, you could easily write the data in JSON or (my preference) TOML. Of course, then you can't just hand someone an executable to run, but in theory you could hand them the generic executable and a game file to run... You might consider changing your code so that instead of always using fmt.Printf to write to stdout, use fmt.Fprintf to write to an io.Writer, and pass in os.Stdout in main().... then it opens the door to running the game as a server people can ssh into or something. I have a MUD that I was working on back in the day, it's no where near finished, but it has some good ideas, I think. You're welcome to check it out (I don't remember what state I left it in, so take with a grain of salt): https://github.com/natefinch/claymud Anyway, have fun! Writing games in Go is great fun. 
Seriously, if you down vote please write a comment about why you did.
 $ godoc os Stdin var ( Stdin = NewFile(uintptr(syscall.Stdin), "/dev/stdin") Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout") Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr") ) Stdin, Stdout, and Stderr are open Files pointing to the standard input, standard output, and standard error file descriptors.
Genuinely curious--where did you get this information (that they will be changed eventually)? On many OSes, stdin, stdout, and stderr *are* files, so it seems odd that they *wouldn't* be *os.File objects. What would their type be if not *os.File?
Thanks for posting this. However, there are a handful of concerns present: - The HealthCheckHandler should be writing []byte, not a string. - The related test should call handler(w, r) directly. My play code from the other thread a few days ago needlessly wrapped the handler - "http.HandlerFunc(handler).ServeHTTP(w, r)". - In the same test, NewResponseRecorder should be NewRecorder (there are a few places with this error). - The section on testing nested handlers isn't quite clear to me. - As an aside, testing handlers always seems to be functional or integration testing. When external dependencies come into play, the test crosses into integration test territory. How much your tests do/should overlap is up to the user. - Further within that aside, naming the tests according to their testing scope can help for running only certain families of tests (i.e. "TestFunctNestedHandler", "TestFunctEndpointHandler", "TestFunctRecoverEndpointPanic", "TestIntegEndpointHandler"). Even further out in thinking, naming the files code_internal_test.go, and code_external_test.go may make sense depending on whether the test is in the same package or not. - In the context example code, ctx.Value("app.req.id") needs an assertion ("ctx.Value("app.req.id").(string)"). I didn't look over the database code. Here is an updated play with more of these things covered - "http://play.golang.org/p/RwePHIGm5L". I hope this is helpful.
Stole it all from: https://github.com/golang/go/issues/13473
No, no, please do.
GitHub project: https://github.com/gdm85/go-libdeluge As explained there, this uses native RPC (not the JSON-RPC from the web UI)
I use stdlib + lumberjack (naturally ;). log.Printf with %v or %#v works well enough to print out human-readable objects for the most part. Check out https://github.com/davecgh/go-spew if you want a more complete pretty-printer (navigates through pointers etc). https://github.com/inconshreveable/log15 is a pretty good structured logger if that's the way you roll. I find that one toggle-able log channel for debug messages and one channel for always-on messages is all I really need... we use a levelled logger at work, and I really find I only use two levels, debug+ or info+ I also really liked this post about how to make packages that accept almost any generic logging package: https://0value.com/about-Go-logging 
I have found it very useful to differentiate between two types of logs: support logs and diagnostic logs. Support logging is the stuff that the ops team needs to know, it's "error" or "critical" log level, it is a notification rather than a log. It is part of the user interface of the application. There should be unit tests to ensure these notifications happen. These are the (very few) things that are important enough to get you out of bed. For these logs I have a Reporter interface, with a mock for testing, and an EmailReporter for production. Diagnostic logging is printf debugging, for which the stdlib is perfectly fine, and which you remove before committing anyway. They are different animals, not just different severity levels. I learnt all this from the excellent "Growing Object-Oriented Software, Guided By Tests". Anything that isn't important enough to get you out of bed, and isn't debugging, is a metric. We have metrics for HTTP errors, handler speed, you name it. Metrics are often far more useful than logs. Prometheus rocks. If you really do need a fancy log package, I like https://github.com/inconshreveable/log15. &gt; logs be a standard size on disk That's not up to your program, that's up to the environment. Log to stdout, always and only. &gt; automatically annotate where the message was created log.SetFlags(log.LstdFlags | log.Lshortfile) will prepend file name &amp; line number to all your log.Println(..) 
&gt; But that doesn't mean that those variables need to have that type. The file handles obviously must be files and on start-up there would be *os.Files in those variables, but that doesn't need to stay that way. I wasn't arguing that it *needed* to be that way; but I assumed the proposed change wasn't only for change's sake? &gt; io.Reader resp. io.Writer. So what would be the type of the thing underlying the interface? Or perhaps you mean to suggest that that would be private?
It's totally irrelevant to the main topic, but anyways, what would you advice instead? It's not bad if you check if the arguments are proper.
Then make it "not bad". After scanning the article, I also suggest that you distill the example code down further. I still haven't voted either way, but am impressed with your efforts. Keep it up!
This will answer all your questions: https://github.com/golang/go/issues/14106
Sorry, that wasn't entirely accurate. I thought you were using frontend instances but you mentioned below that you use backend instances, which don't have this limitation. Just use runtime.RunInBackground: https://cloud.google.com/appengine/docs/go/modules/runtime ManagedVMs should also not have this issue, there looks to be a BackgroundContext() call for those: https://github.com/golang/appengine/blob/0b869404e81685c5f3f2e5126bc2309215c7ad72/appengine_vm.go#L54
It's corrected now if you want to check it out. The problem is that if you don't validate the id, the client could supply any combination of slashes or points ("/" and "\" and ".") to get to arbitrary locations in your filesystem.
The stdlib log is very good, once getting into larger projects though, I find a logging library for logging to multiple sources and adding notifications for different severity levels helps greatly. I created https://github.com/go-playground/log for easy log handler creation, easy log level specification per log handler, concurrent logging and low overhead if it can help. I can also recommend https://github.com/Sirupsen/logrus in the end there are dozens out there though, try a few and pick what works best for you.
You can also check out my series: https://jacobmartins.com/2016/03/14/web-app-using-microservices-in-go-part-1-design/
Have you re-run the benchmark several times? There is always some small variance between runs, and with such a small difference I'm guessing it could be the reason.
It'll be hard to find an explanation for a 0.26ns difference. For all we know, it could just be arbitrary. 
One minor typo - // Our handler might also expect an API key. r.Header.Set("Authorization", "Bearer abc123") r should be req // Our handler might also expect an API key. req.Header.Set("Authorization", "Bearer abc123")
That is the reason why go needs generics.
So you link to a tweet that links to a comment that explains bradfitz's comment from 4 months ago *sigh*
You could try a service like [Datadog](https://www.datadoghq.com/) (there's a free trial) to see if you have the same problem there.
It isn't because we had no need for that, but I can probably add that in if its going to be the difference between a usable lib vs not :)
Sorry for the late response, he uses avast.
Again, sorry for the late response. He uses Avast 
An alternative: https://github.com/fiorix/wsdl2go
i'm new to Go started as a learning project (background in iOS Development).
It is feasible. To keep it reasonable you will need to monitor resource use as you hit a lot of network traffic and file io
Rather than one writing a single program that does it all, I'd recommend, if possible, first gathering all the relevant files into one place. That might easily be done using a shell script and SSH? If you can get it all into one place, you'll be able to run the parsing step more quickly and start over more easily.
Fair point. I'm so used to having `systemd` or `upstart` manage all this for me, sometimes I forget how nice it is to be working on Linux. You don't need "expert devops". With upstart you add the single line `console log` in your /etc/init/&lt;job&gt;.conf file. With systemd you don't need anything at all, by default stdout goes into the journal, which is compressed, rotated, size-limited and searchable. - https://lincolnloop.com/blog/2013/jun/20/joy-upstart/ - http://www.darkcoding.net/software/the-joy-of-systemd/ 
As I pointed out, correcting the code in this way is superfluous. This will add an empty method that is then used, but there is no gain doing so. Further, if one is testing an http.Handler and the ServeHTTP method is doing anything interesting, it is likely warranted that the type's methods should be tested separately. If the intent is to run functional or integration tests, it is likely that the Handler is being passed as an arg and the receiving function will deal with calling ServeHTTP. A common exception to this is nested Handlers which must be tested via a ServeHTTP call.
Spring (http://shopspring.com) has been using Go for production purposes for the past 3 years. We're a mobile shopping direct to consumer market place, currently have 900+ brands live on our platform, from small brands to American Apparel, Urban Outfitters, Uniqlo (http://www.instyle.com/news/shop-uniqlo-essentials-spring-app) Our setup: * all on AWS * all of our backends are Go on top of Postgres * total of about 9 separate binaries (4 for serving consumer traffic, 5 for supporting platform integrations) * deploying with OpsWorks (slow) and moving to Docker+ECS+CloudFormation Highs and lows * amazing at scaling up with the team (currently 30 people on the tech team) * fantastic at "just working" - haven't had any significant issues that we'd blame on Go or its ecosystem * lows: not good at writing quick hacks (an internal tool was built in Rails) or very flexible ETLs (data pipeline stuff that takes in data in one format and spits it out in a different format) * high: amazing for stable, reliable, production code that can't break Let me know if you have any other questions. We hosted a talk at Spring exactly about what we've learned for being a GoLang company - https://www.youtube.com/watch?v=5xTNCTD0B4M - excuse the poor sound, it's our first recorded talk. Let me know if anybody has any further questions, happy to comment and share what we've learned.
I'd first use bash. If it gets too complicated, then switch to Go.
You want to look up struct literals. https://tour.golang.org/moretypes/5 Here's an example of what you might do: itemresp := &amp;api.RetrieveResponse{ 200, 2000, map[string]Item{ "firstItem": Item{} }, 1458676981 } If you want a bit more control (such as excluding some parameters): itemresp := &amp;api.RetrieveResponse{ Status: 200, Complete: 2000, Since: 1458676981 }
Thanks for the pointer! I tried running jsonparser benchmarks with added easyjson. It's 182us vs 368us for large structs and 14us vs 22us for medium structs in favor of easyjson. For small structs it's 2.0us vs 1.7us in favor of jsonparser. However, the benchmarks turned out to be actually skewed in favor of jsonparser: small benchmark unmarshals 4 fields out of 9, strings are returned as byte slices, a "nothing(...)" call for ffjson and the like boxes a lot data into interface{} and makes quite a few allocations that are irrelevant to the benchmark (I removed nothing() calls for benchmarking small structs). Just parsing the 4 fields as strings makes it only 1.9us vs 2.0us in favor of jsonparser for small structs. Parsing all the fields makes it 2.0us vs 3.9us in favor of easyjson. So I would assume easyjson should typically be 2x or more faster and maybe roughly the same for small structs if not all fields are actually required. jsonparser, though, might be better for querying a large json without actually unmarshaling it completely. It'll be quite some work to add jsonparser to benchmarks in easyjson since a lot of parsing code would need to be written by hand, but I might look into it at some point. 
Something like what you want could be written in Go, or one of the many other languages. Which language is the right choice often depends on which language you're most familiar with (assuming that you're the one who will do the coding). A Go programmer would definitely be better off using Go, while someone who's more familiar with C/C++ would be more productive sticking to C/C++... 
This json serialization benchmark seems weird: the output is mostly http headers, not json.
Have you considered providing it as a library for other Go programmers as well as the rss-puppy command?
I use Multiwriter() to log one output to several tatgets (file, online service and such). For example one target is a writer that watches every string being passed. If it contains 'error' then i get an email.
No.
Nice to see this.
Why would you? Very rarely is there some sort of language pre-requisite to learn another language. I don't need to learn Latin or German to understand English, for example.
Nah. My prior experience was mostly JavaScript (NodeJS). I did a semester of Java and C++ each and never did anything significant in those courses. Start with gobyexample.com and the Golang tour. Todd McLeod on the Youtubes is also amazing at explaining go. If you have the money, I definitely recommend his Golang course on Udemy--they usually have coupons. C++ wouldn't really help you too much with Go. C on the other hand, Go was built with C. You don't absoultely need to know it but if you did, wouldn't hurt. 
What about gabs? https://github.com/Jeffail/gabs Also, I saw other users mentioning in other threads that it might be easier to create the structs of your expected JSON input/output and unmarshal properly
please dont, learning go only os enough in most of the case imho. save your life on something else :)
I think it's cool, and actually something I have been looking for. Thanks for sharing!
It is not about the time it needs, it is about the fact that unused code has an influence on the speed of the code produced. I don't think the benchmark function of the Go standard library is unreliable.
Why should it be arbitary?
It's not about the method or what it does. In fact I tried several different versions to see if there was a speed difference and this one turned out to be the fastest one. The fact that removing unused code changes the performance of the from 1.52ns/op to 1.26ns/op was rather suprising to me (which in % is rather big). This could be completly harmless or a weird case for the compiler/optimizer or there could be a bigger problem somewhere. I am wondering if something on such a small piece of code happens if similar things could happend on a bigger scale in a bigger piece of code? And because I don't know and can't judge that I posted here to see if someone knows.
Thank you! I've wanted something like this but my need wasn't great enough yet to write it. It was frustrating to use the built-in json to unmarshal into a struct just to get clean result handling from an API and to see it be SO inefficient.
Absolutely. 
Also a fair point :) I didn't realize it was so easy.... other people had wrestled with it at work, so I figured it was more complicated than that (I hadn't messed with it myself).
[removed]
I'd stay away from duck typing and interfaces until you get the hang of things :)
Here's a link to the Go course my Todd McLeod: https://www.udemy.com/learn-how-to-code/
Do you want to briefly explain the differences between your library and [sideshow/apns2](https://github.com/sideshow/apns2) (&gt;1000 stars)? 
Just updating on this - runtime.RunInBackground works perfectly
I am trying to keep the code as simple as possible so that it is more of a beginner's guide but you bring some excellent ideas that I will incorporate in a follow on article (maybe part 3,4 or 5 - since part 2 is well underway). Thank you very much for the constructive criticism I really appreciate it and I will check out your repo as soon as I get some time. 
Open an issue: https://github.com/golang/go/issues
To answer your question, I tried testing the code myself and I have to admit that this doesn't look arbitrary at all. My results are along the same lines as yours. In my case, it was 2.38ns with the method in and 1.98ns with it removed. Here's the weird part. If I add 2 print statements before the last print statement such that the end of the main function becomes something like: fmt.Println(result.T.Nanoseconds()) fmt.Println(result.N) fmt.Println(result.String()) the times are reversed. Now it's 1.98ns WITH the method and 2.38ns with it removed. I'm no expert on these matters but it looks like this might have something to do with garbage collection.
I've used wrk in the past for that task.
wrk is also my go-to. Written in C, extremely fast, uses keep-alives, and scriptable via Lua (constructing payloads, headers, etc). Combine that with Go's profiling tools (net/http/pprof) and benchmarking (testing.B) you have a stack of tooling to seek out bottlenecks. I also find HTTP load testing to help provide context for individual benchmarks that might not have a performance impact once you take the network into account. 
Yes. 
For programs, [use the built-in benchmark support](http://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go). For services, write a go client and wire it into [buster](https://github.com/codahale/buster).
don't like to compare things sideshow/apns2 is a great package, my package started as a learning project i want to expanded it for use with goroutines checkout the examples (pipeline).
Vegeta is an HTTP load testing tool and library written in Go: https://github.com/tsenart/vegeta
I think you just need to use ScanWords() instead of Scan(). The latter scans whole lines by default (unless you set a new SplitFunc). [edit] And then your for loop should close after the append statement. 
Good points. Although for the complete gopher appearance I miss the lower front teeth that are so prominent on the gopher picture in Wikipedia.
Thank you, thank you. I do what I can to keep the level high. Speaking of generics, when DO we get them? They would make error handling much less verbose!
To reiterate what ChristopherBerger said, you're getting the result you're getting because lines is `[][]string{{"0 1 2 3 4"}}` and not `[][]string{{"0", "1", "2", "3", "4"}}` like you assumed. If you [explicitly set temp_element](http://play.golang.org/p/MQCz2G7IRM), it works like you'd expect.
You should watch https://youtu.be/yg7zsuasIIE and https://youtu.be/lJ8ydIuPFeU
I call up E_T. https://youtu.be/3TFdomgFjvg
Yes, considered and dismissed. We have a working X509 infrastructure, so PGP is no option in this case.
Well, not always easiest. You have to twiddle with the path to openssl and also take care, that it's installed. Having a native go lib would make this a lot easier. But because of the lack of working pkcs7 libs this looks like the way to go.
Along with profiling, benchmarks and siege I can definitely recommend gcvis https://github.com/davecheney/gcvis as well, being able to visualise your apps memory and garbage collection in real time (or near real time) helps allot.
I don't disagree that a go lib would make things much easier, currently one just doesn't exist. Bundle openssl binary with your program as a fallback; in case you don't find it from PATH.
I'm interested in this topic too. Mid April is a hackathon in my town and i want to participate to build a tool for automatic UML generation from go source code. Basically lay out all structs with their respective methods and all interfaces they implictly implements as diagramm (because sometimes i wish such a tool if i inspect foreign libraries)
Then I guess you won't so why'd you ask?
Another vote for wrk here. It can be hard to carefully nurse out exactly what's going on, but it's probably the best tool for doing so I have found.
Speaking of Buck Teeth, I think you've nailed the perfect question to make us Gophers grind them to stubs :-) Well done that man. The perfect "Gopher Troll" (that needs a gif of some sort, but my photoshop skills are terrible, and it's time for bed.) EDIT: [alright, I didn't really need to go to bed...](http://imgur.com/rxLZo6U)
You should definitely learn at least C and all the crap around it (autotools, pkg-config,make and co).It can give you a serious edge against developers who don't know all that.
Oh .. not again..
I think he knows Go and wants to know if it's a good language for beginners.
No worries :)
Please, if you down vote, write a comment about why you did.
[https://github.com/rakyll/boom](https://github.com/rakyll/boom) is a straightforward to use HTTP load generator. 
Maybe I'll try to find the problem with github.com/fullsailor/pkcs7, depends on my mood and especially time. An OpenSSL binary bundle in a cross-platform case doesn't sound that desirable for me. A single static go binary is my favorite. ;)
Does information stop being relevant just because it's old? 
I'll take that into consideration with future shirts. Thank you:)
Neat series OP thank you. You are young and motivated, keep up the hard work.
Apologies, my first comment was sent too quick and in fact is wrong. I had a closer look now and what I actually should have suggested is to add this line: scanner.Split(bufio.ScanWords) just before for scanner.Scan() { This sets the scanner's split function to one that splits by white space. (The default split function splits by line.) This way, if your stdin is 0 1 2 3 4 the scanner returns separate tokens for each number. I tested this in the playground: https://play.golang.org/p/qPP5J7HASu If you run this, does it produce the expected result?
I meant the second.
Non-mobile link: https://groups.google.com/forum/#!topic/golang-dev/XYgHX9p8IOk
No, you can go ahead and learn Go first. I've written a lot of code in both C and C++. While Go definitely has some similarities in terms of syntax, there are things that are done differently that will catch you out. You kind of have to unlearn a few things from C/C++. For example, switch cases look identical, but they do NOT fall-through by default in Go like they do in C/C++. That'll catch you out. Likewise, Go's interfaces require different thinking to OOP using classes. Oh, and learning C/C++ makes you want to stick a semicolon at the end of everything. 
Neither. the golang gopher is actually an (Oryctolagus cuniculus) rabbit named Glenda who had species reassignment after "Plan 9 from User Space" failed to garner wide appeal. She also dyes her hair blue (not her natural color) here's a picture of her from back in the 90's: http://plan9.bell-labs.com/plan9/img/spaceglenda300.jpg
You should add links in your articles to the other articles of the series for easy navigation.
Added!
A few comments about the "threading" part of the post. - Go routines are far cheaper than threads and, as such, maintaining a non-terminating thread pool like you've done in the post seems excessive. If you'd like to execute task processing concurrently, it would be enough to just execute in a go routine and send the result via channel to another go routine for return. - Also along those lines, if you're going to implement a non-terminating thread pool, there's really absolutely no reason to use a WaitGroup. A WaitGroup exists simply to add(Add())/subtract(Done()) from a counter and block until the counter reaches 0 (Wait()). If your go routines never finish (i.e. endless for loop), they'll never subtract from the counter and Wait() will block forever. - Go routines are not threads. It's better to think of them as paths of concurrent execution. Treating them as threads will lead you to under-utilize some of their most valuable attributes and keep you thinking of them as heavy, semi-process oriented objects that require the care and feeding that normally comes with a thread (i.e. pools).
Very good series, I think using microservices is good foor scalability. Even though it isn't necesarry for your appliciation.
Isn't -X a valid flag anymore? And why can't I use %v to print a boolean?
I think that's a very valid question. My personal opinion is "I'm not sure." On the one hand it's a fairly comfortable language to work with that seems to work in a way that makes sense to me. On the other hand it has a lot of features that are difficult to appreciate until you've worked in other languages. My first languages were assembler, pascal and C++. I'm only mildly scarred for life.
A couple of things: First, since you have `KHasher.k` which is the number of hashes, why not allocate `.k` the number you need instead of letting append do the heavy lifting? It's a bit wasteful. Also, the package would be a little more extensible if you allowed the user to select their own hashing functions instead of your implementation of murmur + the stdlib's fnv32. KHasher really doesn't need to be a pointer since you don't have any methods that modify `.k`, and `.k` is not exported. This theory is also pretty common in things like bloom filters. For example: https://github.com/EricLagergren/bloom/blob/master/bloom.go#L73
Yes you can.
Great guy and teacher.
Here is some other Gophers: https://github.com/hackraft/gophericons (note the [licence](http://creativecommons.org/licenses/by/3.0/), I'm not very familiar with CreativeCommons but I'm guessing it requires giving credit to the authors) My favorite is the wizard: https://raw.githubusercontent.com/hackraft/gophericons/master/png/12.png
That is weird. I can see your comments in my inbox and on your profile page, but if I click "permalink" or "context" it takes me to a page with the whole thread (except your comments) in the "you are viewing a single comment's thread" style. Anyway, good point. Still, if it has lots of features that make you appreciate it compared to other languages, does that not make it superior to those languages (and therefore good as a first language)?
This is a fantastic blog post, thanks!
Damn, thanks for catching that. Is it possible that go output list in `[elem1, elem2]` format with the comma? It just make it so much easier to debug.
OMG, you're right! The similarity is obvious. How could I have missed this!? I only wonder how she managed to shrink her ears. Perhaps just a side effect of species assignment.
It is too easy and too well known. In fact, better formula is h[0]=ha ; h[i]=h[i-1] + hb + i-1 Or simpler h[0]=ha ; h[i]=h[i-1] + hb ; hb += 1 Without storing previos value is a bit ugly ha+hb*uint32(i)+uint32(i*(i-1)/2)
I added benchmarks for easyjson, library itself looks remarkable. 
Author of `jsonparser` here. First of all thank you for such amazing library, its performance looks remarkable considering that it is almost `encoding/json` replacement. I added it to benchmarks as well, and it beats `jsonparser`in small and medium tests. But as Victor mentioned all benchmarks are biased. It's hard to fully compare jsonparser and easyjson (or ffson), they a true parsers and fully process record, unlike jsonparser which parse only keys you specified. If you searching for replacement of `encoding/json` while keeping structs, `easyjson` is an amazing choice. If you want to process dynamic JSON, have memory constrains, or more control over your data you should try jsonparser. `jsonparser` performance heavily depends on usage, and it works best when you do not need to process full record, only some keys. The more calls you need to make, the slower it will be, in contrast easyjson (or ffjson, encoding/json) parser record only 1 time, and then you can make as many calls as you want. In addition `easyjson` also provides serialization.
Actually not. But with C experience you can get good vision about what's going on behind the scene.
It's so that you never quite know if you're shadow banned. 
Please run `go fmt` on your code. Also, import "fmt" import "net/http" is unnecessary. You can just use import ( "fmt" "net/http" )
Why does everybody seem to struggle with the GOPATH? I set it once to where I keep the go directory and never had to touch it again. I'm not sure what other people are doing but it seems like many people change the GOPATH per project?
 https://revel.github.io/
Sure, Go could be a great choice for a web app, but I guess it depends on the scope. What kind of web app are you hoping to build? In terms of frameworks I've tended to shy away from anything too elaborate and instead just lean on the stdlib + [Gorilla Mux](https://github.com/gorilla/mux) (for richer routing) + [Negroni](https://github.com/codegangsta/negroni) (some common/useful middleware). 
The core of Go is built around writing good web-apps, so it isn't like other languages where you *need* a framework to build things. Take a look at the [building a webapp](https://golang.org/doc/articles/wiki/) tutorial. You'll write a Wiki in about 90 lines of code. There are a lot of middlewares that "just work" together because they follow Go's architecture. You could extend the Wiki by adding markdown support and basicauth in about 5 more lines of code.
Thanks for the feedback, I'll answer each point seperately: 1. Yup, I forgot to write (which I will correct), that you should use more goroutines than the cores your system has, as the switching between goroutines is so cheap. Creating a worker pool is a good idea (and I will write a seperate post about writing pools), but here I prefered to make a static goroutine count from which each one is like a seperate program itself. 2. I know, I even wrote that they won't ever terminate, but I also wrote that if the user wanted to add some exiting mechanism to their goroutines then they would add Done() calls in the goroutines. And additionally I got a mechanism for an endless block at the main goroutine (sure I could've just used a channel which never would get any information into it). 3. I think point 1 answers this. It's all true, that's why using more goroutines than cores is beneficial. Again thanks for reading, commenting and the feedback! I really appreciate it!
I'm happy you like it! This application is only for example purposes, although it's anwyays good to start with a microservice architecture, as it doesn't add so much overhead anyways, and as we know, most software lives and evolves longer than we'd think.
Hi, could someone please explain the following to me? : "using unsafe package simplifies a lot of code by allowing to use 'switch' for filling out structs and working around limitations of standard functions like 'strconv.ParseInt'". Thank you. 
Yep, this is one of the nuances in Go that people struggle with
Don't know about others, but for me I had to try 2-3 approaches for it on Windows 10. Not getting my setup to run almost broke my motivation.
Maybe it's a bit easier on a Linux system. I just set the GOPATH environment variable and that was it.
The problem was actually that the installer didn't set the variable, and in windows you don't really set system variables as path yourself usually. Also when googling it everyone seems to use *nix distributions and therefore that's what they explain.
Please no, anything but Revel, I hear so many Go developers making this same mistake of making this their first framework, myself included, then they move on to Martini next, another mistake. Revel is weird, it doesn't use the normal Go build process, it puts routes in a text file which I don't like one bit. Either use stdlib as so many here have already suggested, or Negroni, or Gin, or Echo or Gocraft web is somewhat interesting too. But try to avoid Revel and Martini.
That's terrifying. Yeah, the database needs to be moved over to scrypt or bcrypt ASAP.
Google knows me well enough to know that I have all of the information on STDs that I need. 
No problem. RE: Worker pools, there's a great example here: https://gobyexample.com/worker-pools
While I've never had the issue myself, I do believe the installer (especially on Windows) should set the environment variable itself, for those not knowledgeable on messing that sort of thing.
Honestly, I'd let them know just how incredibly unsafe their app is. Who knows -- you could get some business out of it. But at the very least it's a courtesy.
"You have to set this shell variable" seems like an uncommon requirement for a base toolchain to require. It's not difficult\*, but it is weird. \* that said, environment variable editing is uncommon on Windows and few people have to mess with that sort of thing. Additionally, the UI for changing it got significantly improved in Windows 10 which probably obsoleted a bunch of preexisting how-to guides. 
It's not much different than martini. It's just a one framework for everything. Sure it's much better than martini (a lot faster), but still, as they say themselves: "It features a Martini-like API". It's MVC, idiomatic Golang usually isn't MVC.
Appreciate the fantastic work as always. Thanks!
&gt; It's not much different than martini. It's just a one framework for everything. Sure it's much better than martini (a lot faster), but still, as they say themselves: "It features a Martini-like API". So let me get this straight, you are basing your conclusion entirely on their description? Just a pure qualitative comparison? &gt; It's MVC, idiomatic Golang usually isn't MVC. You also seem pretty misguided to even think that it [Gin] is MVC. I'm not sure where you got your definition of MVC from, but MVC is Model-View-Controller. It is an architectural pattern. A way of separating concerns / organising code. It is definitely achievable with Gin, but it is not an enforced pattern. You can sure as hell shove everything in a single handler. There is no _coding by convention_ that you would normally see in other MVC frameworks, e.g. Revel, and Beego (or Laravel in PHP). But the beauty of it is that you can do it, if you want to... With regards to "idiomatic Golang", I'm not exactly sure I know what you mean. The fact that Gin handles each request in a separate Go routine, and _avoid_ any sort of memory allocation should already be indicative of it being "idiomatic" (heck, it even takes advantage of defers, and recovery through its "crash-free" / recovery middleware). It is also well-documented with good test coverage. Errors are propagated through return values, and it employs interfaces pretty heavily. Obviously, it's not 100% perfect, pure idiomatic Go code, but neither are most Go projects (even those under the official Go repository). Sorry, I just find it annoying how there's almost an immediate knee-jerk reaction against using any sort of "framework". I know you recommended using a "http router (like gorilla mux)", and "middleware like negroni", but what you are essentially doing by combining the two of them is doing what Gin is doing. 
Thanks for the comment, I will check.
technically the GOPATH isn't even part of go. It's a shell variable. It's used this way because this is how Nix systems are supposed to function. It's shocking to me how little most engineers seem to know about the command line these days.
Good job and thanks again!
I haven't come across or heard of this issue before, but I'd love to know more. Mind elaborating?
Go is pretty awesome for web apps, as many people here have said - you don't NEED a framework, but there are several to choose from should you want to try one. I've been finding it an interesting project to develop my own "micro-framework" toolkit based around how I like to work. It's a good way to learn your way around the language and the libraries.
&gt; Force users to sign in again. (Does the legacy app allow that?) 1) How can you force users to sign in again? I mean how would you go about that programmatically? If sessions were stored on the server I'd imagine it would be simple to delete the sessions but remember that the legacy app uses those two cookies. 2) What if a user enters a wrong password when the change md5 -&gt; bcrypt is happening? The cherry on the pie is that the legacy app does not have an automatic password recovery system (at least as far as I know) so if say a thousand users lose their passwords because of the md5 -&gt; bcrypt change It won't be a pleasant situation. P.S. Bashing the legacy app on reddit is surprisingly entertaining.
I think that's a good point. I don't think of languages as being superior or (conversely) inferior, just better suited to certain problem domains. I'm coming to Go as a very well seasoned programmer who has worked in several languages, and when I use it I feel I'm having an adult conversation with the computer. One feature I think a "first" programming language should have is that it can fit in your head. (Outside of libraries you can pretty much recall pretty much all the useful language rules without referring to a book). I think this is also true of Go. It's definitely a better choice than Java or C++, I think. 
I'm not sure why people have so much trouble with it, either, but there is [a proposal](https://github.com/golang/go/issues/12488) that might help eventually.
yes and none
I used that on purpose for something recently. I had a function that couldn't be run inside a loop, but I needed to check inside the loop if it should be run or not. So I did the check and deferred a call to the function if necessary.
&gt; How can you force users to sign in again? I mean how would you go about that programmatically? If sessions were stored on the server I'd imagine it would be simple to delete the sessions but remember that the legacy app uses those two cookies. Gag. (Sorry for harping on the legacy app, but wow...) I suppose, then, you can't unless you were to require a change in the cookies (at that point you might as well rework the entire auth system) or simply not allow the user to do anything (i.e., only show the login screen) until the flag in the DB was flipped. &gt; 2) What if a user enters a wrong password when the change md5 -&gt; bcrypt is happening? I assumed you'd validate the password *before* hashing it with bcrypt. &gt; The cherry on the pie is that the legacy app does not have an automatic password recovery system (at least as far as I know) so if say a thousand users lose their passwords because of the md5 -&gt; bcrypt change It won't be a pleasant situation. Heh. Backup the database first? Or, better solution -- write the changes into a new table (probably what I should've suggested in the first place) and then once everybody (or a sizable amount) has transferred over, use that table while on-the-fly updating for new people. Might take some sample testing to get down, but it's been done before. (Back when everybody had to change over to bcrypt in the first place.) &gt; P.S. Bashing the legacy app on reddit is surprisingly entertaining. :D
not really a direct comparison, i don't think. we (the authors of both projects) have been talking extensively for a while now, and while there are still some differences, things are probably converging more than not.
&gt; I assumed you'd validate the password before hashing it with bcrypt. Well the suggestion from /u/earthboundkid was that switching to bcrypt is a "no brainer" which I assume means trivial and transparent aka a user simply logins as usual and has no clue that now bcrypt is used. So how would someone validate the password in this case? &gt; Backup the database first? Or, better solution -- write the changes into a new table (probably what I should've suggested in the first place) and then once everybody (or a sizable amount) has transferred over, use that table while on-the-fly updating for new people. Might take some sample testing to get down, but it's been done before. (Back when everybody had to change over to bcrypt in the first place.) So yeah, as I've said before, it might be considered a "no brainer" in theory but in practice things are quite different. It makes me glad I don't have to deal with this problem. Thank you for the suggestions nonetheless. 
&gt; We can then check if the user is authenticated by checking this token and generating the necessary cookies. That sounds like an interesting approach. So my Go service could produce a sha1 token which I could store say on boltdb. I didn't quite get the second part though. Could you elaborate please? 
&gt; You already have your token in boltdb(user logged in to xyz.com/ No that is not the case. The legacy app creates two cookies on successful login and that's about it. I cannot do any changes on the legacy app. So I guess this idea won't work for my case. Thank you anyway.
I'll try to explain what I meant by this. You can convert a byte slice to string without copying using unsafe package. This is not a good idea for the strings you actually use to fill in the fields of a parsed structure, however this approach may be used for temporary strings that only live within a limited scope. This is useful for calling strconv.ParseInt with data from the input slice since it avoids making a copy (see, for example, https://github.com/golang/go/issues/2632). Also it's much simpler (and quite fast) to do a switch statement on a string to determine what field of a struct is being parsed than to implement the same logic manually for []byte-s. 
&gt; but it is weird Indeed. Here's a quote from the GOPATH proposal linked elsewhere below. &gt; q. why do I need to make a sub directory, can't go just work in my current directory ? &gt; a. no, not really, Go works with packages, and packages are a directory &gt; &gt; q. oh, ok, well I put my code in src/hello.go and it didn't work ! &gt; a. ahh, well, src is special, you cannot put code directly in src/ &gt; &gt; q. ok, so I put my code in gocode/hello.go and it didn't work, you told me src/ was special so I didn't use it &gt; a. err, right, sorry, you need to use src/, but you can't put any code in that, try src/hello/hello.go &gt; &gt; q. ok, thanks for helping, that worked, but I have a question, why do I need all these directories, shouldn't Go be able to figure this out ? &gt; a. *insert long technical explantation about package names being derived from import paths and how src/ would name no import path so technically not be importable into other package, not that that it matters 'cos its a main package* &gt; &gt; q. what's a package, i just wanted to try helloworld.go ?!? &gt; &gt; This is taken pretty much verbatim from my experiences having to justify the $PROJECT/src directory in gb. 
And it's fairly pointless. const MyMsg = "oh no" var MyError = errors.New(MyMsg) If I have to make `MyError` a variable though it conceptually a constant, what's the point of allowing simple types to be `const`?
Hello, yesterday I did a comparison of the web frameworks written in go, the results are controversially. I though that the http-router is the faster but it's not (?) . The winner seems to be a framework called 'Iris' I didn't knew it until yesterday, second is the framework 'Gin' and the http-router is third. My github fork of the https://github.com/julienschmidt/go-http-routing-benchmark/ is here: https://github.com/goc0der/go-http-routing-benchmark/ . Take a look and let's discuss it.
I think you are using the defer function incorrectly. The defer function "f.Close()" will be called only when the function "thisIsWhyWeCantHaveNiceThings()" exits, so you are opening the same file ("testlogfile") 100000000 times without closing them inside the "for" loop.
&gt; Well the suggestion from /u/earthboundkid was that switching to bcrypt is a "no brainer" which I assume means trivial and transparent aka a user simply logins as usual and has no clue that now bcrypt is used. So how would someone validate the password in this case? This is SOP for pretty much any auth system that works. Create a new database column called "auth_type" and set it to MD5 to start with. After that, when a user logs in, check their auth_type. If it's MD5 and the password checks out according to the old system, use the password to generate a new bcrypt hash and write auth_type = 'bcrypt' and the new hash to the database. It's also a good idea to add a column for a secret salt at that point. Again, this is a standard practice for pretty much all auth systems that work. It has nothing to do with Go and everything to do with normal security practices. Literally every language used on the web has multiple frameworks to automate this process in various ways. 
&gt; I cannot do any changes to the legacy app. You don't have to. You already said it's reverse proxied using Apache. You could make your Go app reverse proxy it instead. Your Go app would grab everything under "/goservice", and pass every other HTTP request on to the legacy app -- except, your new app would handle all the authentication with the end user, and do it securely. The new app would then fake up a login to the old app, and maintain the old app's cookies internally.
ISTM, the legacy app is completely insecure (MD5 has been a security worst practice since 2005), so it should be removed from the public internet. If the constraint is that you can't modify the code for the legacy app in any way, put a new app with its own authentication system onto the internet and have it proxy calls to the legacy system on a private network. Users will authenticate to the new system, and if the calls pass inspection for the new system, the new system will make an insecure call into the old system. The old system should not be on the public internet because breaking MD5 costs about [&lt;$0.65](http://natmchugh.blogspot.com/2015/02/create-your-own-md5-collisions.html) nowadays.
Well wait group is part of the sync package.
Indeed, that is a good plan. Nevertheless in practice that would mean downtime for the users while the go proxy app would be deployed and tested not to mention that it's not trivial to write. I think I'll stick to just the go service instead of trying to patch up the legacy app. But again nice idea.
Learning how to do the networking code via straight sockets in C will allow you to understand the basics of how things work ... creating sockets, listening, accepting, dns resolving, etc... From there, the abstractions in `net` will make more sense. The [doc page for net](https://golang.org/pkg/net/) will give code snippets and it really sorta is that easy at the basic level. Past that, you'd need to specify some goals in order to target the learning material better.
The standard libraries are fine, but I've used this in a few projects lately and really like it: https://github.com/ant0ine/go-json-rest 
I'm assuming you've turned on LazyQuotes and are running into this scenario? http://play.golang.org/p/jrdy1_zgpl Are there normally qualifiers (double quote) or is it just this record that causes the error because it happens to have a qualifier as part of the value?
That CSV file is malformed. An overly-generous CSV parser may accommodate somehow, but here's what you should do: fix the file. Just as you wouldn't expect a compiler to assume you meant something else when it encounters a syntax error, neither should you expect your CSV parser to assume you meant something else when there's malformed input.
What `s` is, if this was good Go code and not a straw man attack on short names, is almost certainly either the method receiver for whatever I'm looking at, or a variable that was defined and used very near where the wg was referenced.
&gt; Node.j's for sure, and then rewrite everything in golang once you get sick of callback hell. Not true. there is `async` promises ect.
What I was getting to is that you can roll your own reader: http://play.golang.org/p/NR-HcgCeZ_
https://whispering-gophers.appspot.com/talk.slide#1
Fix the 52GB file, or roll a custom comma separated value dialect parser. CSV is easy and probably a good Go learning exercise. Just add that special case for quote and comma interactions and hope it doesn't break somewhere else. Depends on the situation, fix the source so it creates right CSV is ideal of course.
https://golang.org/pkg/net/
This release puts glide at the top of the heap, IMO.
Thanks for pointing this out. What it was supposed to imply, is reload the server to see the changes and not recompile.
You could read line by line and feed it to the CSV parser, that way it will never have more than just one line to read. :-)
&gt; "Mutability by default (aka no const keyword)" [What?](https://golang.org/ref/spec#Constants)
pretty much what barsonme and faaace said. Defer acts on function rather than block level and as such can hold processes open longer than expected. If put into the context of Javascript defer works in the same manner as setTimeout(function(){},0) which is a bit counterintuitive. 
This is mainly the cause of how the error type is defined, as it is a struct rather than a string. You can satisfy the error interface with a type defined string. type ParserError string func (e ParserError) Error() string { return string(e) } const ( ErrNotEnoughData ParserError = "Did not receive enough data" ErrDataTooLong ParserError = "Received data is too long" ErrCRLF ParserError = "No CRLF" ErrWhitespace ParserError = "All Whitepace" ErrPrefixed ParserError = "Prefixed message" ErrMissingParams ParserError = "Missing parameters" ErrTooManyParams ParserError = "Too many parameters" )
The app is insecure. Period. It is trivial to hack MD5. That's fine if it's a bulletin board or some other non-critical app. But at the same time, you can't have 5 minutes of downtime? That makes no sense. Either it's not critical and the security issue isn't a big deal, or it is critical and the security issue is a big deal. Either way, you can spare five minutes of downtime.
I really prefer using nginx in the front, keeps all this out of the main go application so it can focus on solely providing API endpoints. Just a personal preference though.
I started development of maven plugin to make some business with GoLang in maven infrastructure https://github.com/raydac/mvnGoLang
Writing an SMTP daemon seems to be a common first project in Go! It was my first concurrent Go project. I like the console aspect of mat. A couple fun next-steps: 1. Look at Rob Pikes lexer talk and convert your handler into a finite state machine: http://www.timschmelmer.com/2013/08/state-machines-with-state-functions-in.html 2. You might consider adding in my MIME parser library, and emulating its included mime-dump command so the user can see pretty-print of the message content: https://github.com/jhillyerd/go.enmime/tree/master/mime-dump I'll also plug my (still going) SMTP project, Inbucket, which offers a web interface and message storage, POP3 API, RESTful API: http://www.inbucket.org/
I keep a list of other language X -&gt; Go rewrites: https://quicknotes.io/n/vzb7 
low performance :/ it's very slow I did a benchmark before 2 days of this framework...the results are these: https://github.com/goc0der/go-http-routing-benchmark
kataras I presume? back with a new name? You are still pushing your misleading benchmarks. I thought initially you were just ignorant about how to do them but now I realize you are really determined to try and mislead people. The performance of your framework really isn't bad but it is simply not what you portray it to be. You are comparing a cache when everyone else's benchmarks are measuring the router. https://www.reddit.com/r/golang/comments/4a8yit/is_this_the_fastest_go_web_framework/ I wouldn't go near your code in a million years because you simply don't listen to advice, try to mislead people and then insult anyone who points this out. Good luck with your framework.
The link doesn't work.
It works for me. 
Who am I? can you run the benchmarks first and after tell me lier? I am new gopher I dont know many people yet!
Sorry, it was down for a moment (the joys of deploying new version). It should work now.
I appreciate this article more than the other $Language -&gt; Go articles because it goes into depth of what exactly the issue was with the existing language. Too many of them simply say that the existing code consumed "too much memory" or "too much CPU" which was magically fixed by shifting to Go. That's nice, but did you try other approaches in the previous language? Did you try to fix your problem rather than simply jettisoning the existing code? I commend the author of this article for doing just that and explaining in simple words why Node wasn't suited for this task. Without this, the article runs the risk of being dismissed as hipsters jumping ship to the latest hot new language, rather than careful engineering.
&gt; the easier solution is to just make the users login again to /goservice :p Yeah! That was my first thought. I was even thinking to use gorilla securecookie to keep it simple like in that [article](https://mschoebel.info/2014/03/09/snippet-golang-webapp-login-logout/) (though I am not sure how secure that would be being client-side only). Other people have proposed other good solutions too like auth2 and server side sessions. The main reason I am avoiding two logins is because it is not very desirable (by the owners) and thus I am just trying to make it as seamless as possible. The second reason is that since my experience with authentication is limited (I've always used ready-made solutions from frameworks in other languages) so I am concerned about how good/secure my own solution will be. Naturally, limited experience makes something appear bigger and more complex on someone's head than it might actually be. Nevertheless I might end up doing two logins in the end. As people have pointed out, the existing system is already insecure as it is. By making a new authentication system in the Go service at least, I'll get the benefits of something more secure (hopefully) while at the same time I will learn a lot of things since with Go I have to reach the lower level areas of the code. Having that new authentication system will also give the benefit of maybe using it in the future to proxy the legacy app or on a new project and the learning experience is very valuable so it's like two birds with one stone. &gt; but yea you if you want to reverse engineer the cookie code no problem :) Yeah, that is what I will attempt first and that was the main question of this thread as I was not quite sure how correct my approach is. Apparently my approach is fine but there are bigger problems that have to do with the legacy app. Regardless, this thread has helped me learn, understand things better and finalize my decisions so I thank you and everyone else for your time.
devd is a live reload server. https://github.com/cortesi/devd modd is a watch dog on file changes. https://github.com/cortesi/modd
&gt; you can't have 5 minutes of downtime? That makes no sense. Just transferring what I've been told by the owners. Also proxying or disturbing the flow of the app in any way, downtime or not is not very desirable either. But in the end this is not about the legacy app but about my approach in the go service which is reverse engineering the legacy app cookie code as /u/mc_hammerd brilliantly named it.
There are many more blog posts than that. This would be a great resource if it were more complete. Maybe move it to the official wiki where it can be more easily crowd-sourced?
Use a vendoring tool. Good list and info at https://github.com/golang/go/wiki/PackageManagementTools . I'm a gvt kinda guy myself.
IPFS support would be nice. https://ipfs.io/
https://xkcd.com/927/
How will this compare to or be better than gx? https://github.com/whyrusleeping/gx
The [documentation](https://golang.org/cmd/go/) (any my own experience) has suggested this doesn't work. &gt; Get never checks out or updates code stored in vendor directories. You need a 3rd party tool to do it
1. install godep. $ go get github.com/tools/godep 2. create 'vendor' folder in your project root dir. 3. run $ godep save (this will do the magic). Check vendor folder. You'd see all dependencies. Now every 'go build' will look for packages in the vendor folder (NOT $GOPATH/pkg or /src folder). EDIT: You are free to use any other go vendor tools. https://github.com/golang/go/wiki/PackageManagementTools#go15vendorexperiment
you're completely right. I deleted my comment.
 GOPATH=/tmp/vendor go get github.com/whatever cp /tmp/vendor/src project/vendor That's enough for a simple project. 
Npm has scoped modules now which work awesome. People just aren't really using them.
Use the blockchain technology! Then it can be free of any central organizer and be safe from evil governments etc! Freedom!
Thanks, it's a fresh air in the middle of big companies showing how to handle millions of connection.
Suggestion: banners should be baked-in. Don't want to pollute the fs with a txt file nor want to specify command line args just for that. Otherwise would use! EDIT: also the ASCII banner should be automatic. Seems like I have too much things to do on my own. 
The flags are optional, if you want to use the banner api directly you can. About pollute the fs you are right, I will change the API of banner.Init to accept a Reader instead of a file name, so you can use wherever you want as a banner content. Thank you for your feedback. EDIT: The changes are implemented.
yep! $ go build -v 
Kids these days...
Developer at Digg, haha. "Yeah I got a job doing repair work on the Titanic"
Nice thank you and have a nice Easter!
&gt; If your project has a /vendor directory, go get will install there. I don't think so. "Vendor directories do not affect the placement of new repositories being checked out for the first time by 'go get': those are always placed in the main GOPATH, never in a vendor subtree." Source: https://golang.org/cmd/go/#hdr-Vendor_Directories
+1 to that suggestion, whyrusleeping/gx and its underlying ipfs should be the base of any investigation towards that end.
Snap out of it and get back to reality.
The ~~guy~~ person is gainfully employed and working with Go, I don't see the problem. edited: to cover my ass
[govendor](https://github.com/kardianos/govendor) is much better than Godeps.
What makes it so much better?
In my opinion if you set your gopath for each project then go vendoring maybe useless but I defer to others here that have a lot more experience in go vendoring than me (the noob :-)) 
Yeah. And rsc said this before (regarding runtime.Gosched) &gt; runtime.Gosched has never really been useful. If you are calling it, your program is almost certainly buggy. We should just delete it, but it is occasionally useful for writing tests or demonstrating failures. https://groups.google.com/forum/m/#!topic/golang-dev/hu-HJDDJmyI
It's interesting that you link to a website to generate ASCII art text. That page seems to be just a web frontend for the (open source) [`figlet`](http://www.figlet.org/) command.
Well, I rarely if ever write any JavaScript, but if I write something that's worth sharing sometime and you manage to top google results for "npm alternative" when the time comes, count me in. I've long considered npm one of the nastiest tumors that makes web development such a horrible experience.
Actually this package doesn't seem to generate ASCII art at all...
I know, But it is easier to just access the website and generate the banner.
My bad - I should have updated that to "draft".
Someone tested it on 80 and 48 core machines and it was pretty decent actually. The Gosched part is the only clean way to handle atomic loops without access to specific hidden inline functions, time.Sleep is clumsy and causes random allocs. 
Thank you :)
I agree with others - this belongs in runtime. Current benchmark's looks strange - numbers doesn't correlate well. Additional info required! =D Another reason for this being builtin is that interface{} is an ugly hack. And if we can tolerate it in some parts of our code, doesn't mean we accept it as a good practice. But more importantly, is that any cast to interface{} is additional allocation, where most of the time, your channels are strongly typed (primitives or structs). Not only it verifies your code and shows your intentions, but it also increases performance. It's great research project and applaud you for doing that. But I would strongly recommend against using this lib in production code. If you can, and looks like you do, please continue the discussion with core devs. Channels were "frozen" subject for too long, and it would be nice to see someone working on making them better.
Well - writing into the closed channel was always a big no - no. I believe it's a right thing - they are channels, not generators or mailboxes or actors. While I agree that writing into the closed channel would make some things easier, at the same time it could also create additional area for subtle bugs. Aside from that, it would also require a change of syntax - something like ch, ok &lt;- val. But what "ok" type then? With val, ok := &lt;-ch you have type deduction and an actual assign, so this doesn't break semantics. Maybe it would be better if send operation would be returning bool itself? Something like ok := val &lt;- ch. But that doesn't look very idiomatic in my pinion.
Thank you for the comment, few points: 1. Using 1.7, the extra allocations from using interface{} don't exist, you can test it yourself by using go tip and running the benchmark. 2. This works fine in production, and as an added bonus, I'll be adding a gen.go to use with `go generate` to produce typed version of the code, but it is still WIP. 3. I'm actually working to include this in the std lib, however if it doesn't get picked up, I believe the implementation is very safe for production, specially after I finish the specialized version.
That's why `Chan.Send` returns a bool and there's a `Closed() bool` func.
Correct Equip is for part 3 where you will actually use a weapons/shield that you take out of your bag or pick up as you walk around. 
Iris is built on top of fasthttp. While its nice to see other http server implementations, it's not a fair comparison. Caching routes can lead to resources usage spiking under heavy loaded environment.
You don't have to create the vendor directory yourself. The first `godep save` will do it.
No reason.
Please link to part 1 near the start part 2, I had to google it.
I've added a typed channel generator. https://github.com/OneOfOne/lfchan#generate-a-typed-channel
*Some of your dependencies may also have the vendor folder, and some of its dependencies may have vendor folders, too. And so on...* But that should be considered to be a bug in that package, no? As far as I understood the rule is: packages -&gt; no vendoring, binaries -&gt; vendoring. Or in the words of Andrew Gerrand: https://groups.google.com/d/msg/golang-dev/nMWoEAG55v8/GXh7DT7HknoJ Also note that the govendor whitepaper suggests bad practices: https://github.com/kardianos/govendor/blob/master/doc/whitepaper.md#package-developers Packages should not use semver. semver is used to mark breaking API changes. In Go an import path should be API-stable. 
Then, when is it better to don't use one GOPATH per project ?
Looks weird and super poorly designed.
You are likely being downvoted for not saying why you think it is "weird and super poorly designed."
you are explicitly implementing Eater so you may read a little about it, and therefore understand the "contract" you are entering into
I tend to not spend spare time on stating the obvious.
Or you can just use GVM - https://github.com/moovweb/gvm and that will all be done for you in 1 simple command. 
&gt; Did you try to fix your problem rather than simply jettisoning the existing code? I agree, the author did do a nice job of explaining all her attempts to fix the existing code. &gt; Two weeks later, after my initial crash course introduction to Golang, we had a brand new Octo service up and running. I also think this statement speaks volumes about the Go language. Only the author knows how much time she spent trying to optimize and debug the existing before moving to Go, but when she did, she was able to rebuild the service in two weeks. Go really shines with how easy it is to pickup the language and be productive. The speed of the language once compiled is great, but even greater is the ability to build resilient, enterprise grade applications that perform as you would expect them to. Of course the author said there were some bugs that she had to work out in the Go code, but I think the simplicity of the Go language makes it easier and more fun for us to focus on the task at hand and worry less about if the code is going to do what we think it's going to.
its a good example because the functionality of eat is ambiguous. I just think that the concept of the interface is weakens to the extent that you may as well just pass a list of methods. I wouldn't mind this loosey goosey approach, it it went all the way loose, so that a field called "eat" that pointed to a method that had the same stereotype of the method on the interface would allow that type to satify the interface this way as well. Or give some way to alias a method name to allow interface to be satisfied like so: me.Consume(cake) me.Consume((Eat() &lt;- Devour()) pie) 
Vendoring in Go is pretty easy. I'll explain how to do it manually so you can understand what the many vendoring tools are actually doing. Go 1.5 supports an experimental feature which allows you to store the external packages you use in a folder called **vendor**. In Go 1.6, the feature is enabled by default. You can enable the feature in 1.5 by setting this environment variable: GO15VENDOREXPERIMENT=1 To test vendoring on a current project, simply move all the external packages to a folder called **vendor** in the root of your project and your program should continue to compile without any errors. You don’t have to change any import paths. If you have the same package inside the vendor folder and outside your package folder, the one in the vendor folder will be used. Source: http://www.josephspurrier.com/how-to-use-go15vendorexperiment/
I've been using gobrew for this but that does look more versatile.
I think the link to official doc on this is better.
What is obvious to you is not obvious to everybody, particularly newbies. You don't have to be a dick, you're choosing to. In addition, in the combined time it took you to comment and then reply you could have just stated something of use, particularly if it is so obvious to you.
Hmm... It should be as simple as running `govendor add +external`. Otherwise, open an issue.
*I prefer the use of https://gopgk.in for this, though.* Same thing here! Creating new namespaces is the way to go.
As a musician, been thinking of implementing one myself for months and there we go. Good job, fanks!
FYI, there are upcoming changes to the compress/gzip library that will make compression of already compressed data very efficient and well as better handling of small file sizes.
I highly recommend a look at https://github.com/kardianos/govendor for pkg mgmt and vendoring in Go. The project has iterated a lot since the Go 1.5 vendor experiment, the code base is very clean, easy to work with and powerful. The docs are still being improved, but if someone has a question just open an issue (I've talked to the author a bunch and he's very bright and responsive)
That would be fine, I will keep my package up to date. Could you please provide your source? I don't find any post about this kind of change in * https://github.com/golang/go/issues?q=gzip * https://groups.google.com/forum/#!forum/golang-nuts * https://forum.golangbridge.org Thanks BTW!
https://github.com/dimiro1/banner/pull/2
Guy asks for a solution for his restful architecture, top answer is non-restful approach lol.
Seconded. If you need some help with this, I can dig up some code I have.
This can be done with JWT using an expiration date. On each request you verify it is a valid token and hasn't expired. All of the state is in the request so it is RESTful.
I also use JWT it's fantastic. Regarding expiration, I use 2 hours for access tokens and infinity for refresh tokens. So to revoke access I invalidate the refresh token and the user won't have access after 2 hours. It's a compromise between storing something and nothing...
Not a bad approach. Our requirements are a bit more strict so I store a "jti" header (a unique token ID, jti is used because it's reserved for this usage per the spec). I invalidate those and publish an event in the system (websocket) to ensure anyone that cached the acceptable tokens they have seen stop accepting them (this is in a distributed app).
Very cool. Any plans to add scales as well?
You can also store the entire config in a single atomic.Value.
Shameless plug: I wrote a little middleware for working with JWT in Go webapps --- [https://github.com/thermokarst/jwt](https://github.com/thermokarst/jwt). It is fairly flexible, and pretty straightforward to use.
I've used https://github.com/dgrijalva/jwt-go for JWT based authentication.
It depends what means "better". Better because it has more feature ? because it's simpler ? because it's faster ? Best is to try.
&gt; Is Elixir much better than Golang? at what?
Every language has something that other one don't. You look the whole package relative to what are your needs. OP didn't say anything about use case so I can only compare design philosophies which dictate performance, libs, tools and other things people already commented on here.
then yes, it is
Functional languages are far more than a "academia fad"...have you been under a rock for a few years? 
In golang world word "template" is quite specific. And go doesn't have generics and such.
I love gogs. It works great and the project is really picking up steam. It's a great project showing the power of golang. 
Foreword: Potentially a stupid question, and perhaps should be stand-alone. My company is interested in applying Go to a highly iterative mathematical problem (lots of basic math computations). Looking at gonum it appears to provide all of the functionality we need, but I'm curious about the computational overhead of the c-bindings. I'm a mathematician and not much of a programmer, so I'm not sure how to evaluate that problem. Any thoughts?
Klaus Post, the author of https://github.com/klauspost/compress, is in the process merging many of his changes into Go tip. You can see the CLs here: https://go-review.googlesource.com/#/q/-status:abandoned+project:go+compress/flate+owner:%22Klaus+Post+%253Cklauspost%2540gmail.com%253E%22 Compressing already compressed data will be faster due to a technique known as "fast skipping". Compressing small files will be better by just by general optimizations to the compressor and by reducing memory allocations. Edit: I will say that there is a very minor benefit of avoiding gzip for very small files. Gzip has an overhead of 18 bytes. However, personally I would not say that it is worth making a distinction in this case. You probably have far more overhead due to TLS/TCP/IP/Eth headers.
So much this. Although, I do think golang needs something similar to maven or Nuget. I am very familiar with maven and it was always a joy to work with after the initial learning curve. Although, XML-based is no fun, but the semantics of it always seemed fine to me. Their version coordinates seems fine, althought it is aligned to java packages and their recommended naming structure.
Here's a (very incomplete) list of (very well known) companies that use Go: https://quicknotes.io/n/1XB0-companies-using-go I don't think there is such a list for Elixir. So "many users choose Go lang instead of Elixir" is just false. Internet is large, you'll find people enthusiastic about just about anything, be it Forth or Elixir. When you pay attention to trends like the above "how many companies use Go vs. Elixir in production", how many people install Go vs. Elixir plugin for Atom or Visual Studio Code, it's obvious that Go wins 100x. 
Could you give a bit more context so I can provide a more targeted answer? What alternatives are you considering? Why Go as opposed to those alternatives?
&gt; We iterate over parts, ignoring the index position (_), filtering the parts to return The first time I write this function... func (parts Parts) Spares() (spares Parts) { for _, part := range parts { if part.NeedsSpare { spares = append(spares, part) } } return spares } ... I forget to put the blank index (_,) in the for loop and it fails to compile. I have to go back and add it in. Thankfully Part isn't an int or it would cause a harder-to-track-down runtime error. Don't forget to add in these times in your analysis. 
God forbid the author post something they've worked on, because it means they want you to use it right now.
Perfect, I will follow the subject. Thank you for the info!
There's nothing wrong with writing a package and making it available to the community. If someone finds it useful, all the better. Vendoring in Go precludes what happened when left-pad was unpublished.
I like the project, but why trying to copy GitHub to the point where it even visually looks like GitHub? Is it to make people rapidly comfortable with the GUI? Edit: why the downvotes? I'm only asking a question about the design of Gogs...
It depends on if you expect others to use this go project. If the project is meant to be a standalone application (not used as a go module fetched with go get/install)it should have 3 folders labled src pkg &amp; bin in the root. If it is meant to be a library used by other go programs it should have the go source files in the root along with tests. Take a look at this for guidance: https://golang.org/doc/code.html
tl;dr: The library would parse the JSON response from a http.Response.Body and then call http.Response.Body.Close(). The JSON decoder did not drain the response body completely (I believe it would leave a "\n" dangling) and subsequently calling Close() on response body killed the connection! Filippo's PR just drained the http.Response.Body before calling Close() which lead to a significant speedup. Neat!
I use this at work mainly for the fact that I can self host it on our servers and not have to pay github for private repos.
Also use `time.After` to close long running go routines.
The convention is: no snake_case (use camelCase or CamelCase); imports from the standard library and third-party ones should be separated by an empty line (goimports will format them that way for you): import ( "log" "net/http" "os" "strconv" "github.com/aws/aws-sdk-go/aws" "github.com/aws/aws-sdk-go/aws/session" "github.com/aws/aws-sdk-go/service/ses" simplejson "github.com/bitly/go-simplejson" "github.com/spf13/viper" ) 
Personal experience, I pay for Github instead of using our Gitlab install at work because, well, frankly, Gitlab is a horrendous mess. The layout of Gitlab is so bad that I would rather not code there than have to look stuff up every time I want to go into Gitlab. Github is a well laid out site. Gogs is not a 1:1 clone, but fairly close. If the layout drives adoption, more power to it.
I am self-hosting, on localhost:3000, going through the install process. Step 2 is signing up with gogs.io which includes entering your email and a captcha.
I was investigating this same issue with other gophers a couple weeks ago. Transcript: https://gist.github.com/mholt/eba0f2cc96658be0f717 Basically, the net/http docs only talk about closing the bodies, not draining them. Here's what it currently says (client.Do()): &gt; When err is nil, resp always contains a non-nil resp.Body. &gt; &gt; Callers should close resp.Body when done reading from it. If resp.Body is not closed, the Client's underlying RoundTripper (typically Transport) may not be able to re-use a persistent TCP connection to the server for a subsequent "keep-alive" request. &gt; &gt; The request Body, if non-nil, will be closed by the underlying Transport, even on errors. And for Get(): &gt; When err is nil, resp always contains a non-nil resp.Body. Caller should close resp.Body when done reading from it. It is ambiguous what "done reading from it" means. In this case, apparently, it meant draining every last byte. I have to admit, I was surprised. But I bet explaining this somewhere in the docs would take away the surprise.
&gt; In this case, apparently, it meant draining every last byte. Not only that, you actually need to reach EOF, too. This is what json.Decoder won't do. A reader can return non-zero number of bytes and EOF; or it can return the number of bytes and nil error, and the next call to Read will return (0, EOF).
It should be easy to benchmark the C overhead of BLAS/LAPACK calls. The code is all in gonum, and so even adding a "t := time.Now() ... time.Since(t)" pair should give you a pretty good overview. At that small of a size lapack might not even be worth it. Depends a lot on the specific implementation, but Go is pretty fast. For example, using the Go implementation of Ddot is as fast as C or faster for large chunks of slice size (especially including overhead). If you do end up benchmarking, it would be great to see the results. You say that gonum has what is needed, so that's great. Honestly, the reason I have invested time into Go is because I want to write performant code and not hate my job. In my opinion, the biggest downside to Go is the lack of libraries, so if those are already in place or you can help create them that eliminates one of the barriers. If you do use Go, you may want to decide to be on tip. Tip can call Fortran directly and I'm seeing speedups of 10-30% on simple benchmarks (and only getting better with SSA).
Not really the power of Go, the un-power of the people who wrote gitlab, which is a Ruby thing.
Thanks, You are right. docker and cockroach are both large. I was wondering if any project, commercial or free has reached higher magnitudes of SLOC. 
Design is hard, and Github's design is at least proven to not be completely bad. Therefore, copying is an easy way to not fail at design. Also, a *lot* of people like familiarity.
How do you deal with sessions, routing, cookies, etc. then? Do you just search for whatever modules are available for that and use that?
I might use it for a couple of pet projects. I use gitlab at work, how's the head2head between them?
Why doesn't Close() drain?
Response to your edit: In fact, avoiding small data gzipping inside a classical TCP/IP context is not so because of the gzip algorithm itself, but because of the network packet size. Here, we only compress to save network bandwidth. And if the response already fits into a single packet (1500 bytes in general), we just loose time and energy by (un)compressing, both on the server and client side. For the record, the mod_gzip of Apache 1 had an absolute lower limit of 300 bytes for its mod_gzip_minimum_file_size directive (the mod_deflate of Apache 2 lost this directive without justification). Nginx also have the gzip_min_length directive, but with a default of 20 bytes (for the "flexibility" I suppose).
Feels like I'm using no RAM at all. No RAM at all. No RAM at all…
I've just found https://go-macaron.com/ and looks really nice. It seems it's using dependency injection. It this ok? I remember seeing some posts here that the GO community is king of against this? Should I look for something else?
GitLab has more features. Gogs should be enough for many people, though. The big advantage of Gogs is it is stupidly lighweight. You can easily install in a VPS with 500mb of RAM and it is fast. Also work very well on Windows for many companies out there that use Windows Server. GitLab, on the other side, is hard to install and absurdly heavyweight.
I know this a silly question, but can it also host mercurial repos? I'm really looking for a self hosted bitbucket type product. And golang is just icing on the cake. 
This works fine for small files, but for anything larger you may want to save some memory with using an io.Reader and json.Decoder: var c map[string]interface{} f, _ := os.Open('./filename.json') if err := json.NewDecoder(f).Decode(&amp;c); err != nil {}
A couple of minor pointers in addition to the ones already posted. You don't have to name your errors *err1*, *err2*, etc... just keep reusing the name *err*. Instead of writing fmt.Println("...") os.Exit(1) you can write log.Fatalln("...") See: https://golang.org/pkg/log/#Fatalln Have a look at JSON tags. You will need this when you dont have full control over the input JSON. *edit: formatting*
There could still be 10 GB of data left on the wire. That would take hours to close.
I asked the same question here https://github.com/google/go-github/pull/317#issuecomment-202847335
Interesting. Running the same &gt; find . -name "*.go" | xargs wc -l on gonum is 146,781 (there's no vendoring). About 15,000 lines in the cgo BLAS and LAPACK wrappers, but otherwise pure go (30,000 of which is the partial Go lapack implementation).
That's bigger than my mongodb spark cassandra cluster all combined in multiple regions all over the cloud cdn. So, do I need to Drain? When do I Drain? Not sure why Draining Body before Close sped things up. I guess for Filippo's testcase, payload is never as big as 10GB? I assume closing TCP connection with 10GB renaming in the network and opening a new connection yields better throughput than to draining 10GB just to reuse TCP connection. Should I Drain for few bytes or microseconds then decide to Close when Drain didn't complete in time? 
Pretty old post. There was a very heated discussion on this on HN. 
Well I'm glad I never invested in that tech, now. Whose open fork is set to become canonical and GPL'd, then? ;)
For this to be a tutorial, and not just an overview, the **Method 2 (govendor)** section really needs to be quite a bit more detailed. Consider having a basic "hello world" program with a dependency, show how to set it up, and what the source folder looks like after govendor has done its job. Typo on #2: "Go you your project" Examples for #4: "govendor add +external" really doesn't tell me much. Do I run that exact command, or do I run it per dependency of my project with an argument? Consider adding information on how to update the dependencies (or see if they have updates available if that is possible with govendor?)
"dependancies"
I wouldn't call godep obsolete. If you use Heroku you have to use it to import all your modules. None of the other methods are supported.
for me the error is detailed here: http://pastebin.com/uPuCpg40 it seems like the JNI file is only being created for ARM not for x86. What commands do you run when you do your gomobile bind?
i didnt realize this was out for 1.6 yet! what is the command to build to x86. Is it any different than just setting the target to android?
I'm trying to figure that out myself :) 
I don't think underscores in method names is very Go-like, we use that in Python but Go prefers names like populateConfigFromFile rather than populate_config_from_file.
Posted the following there: Check out https://github.com/sendgrid/go-gmime (disclaimer, I work with SendGrid, but did not put together anything in the lib)
Excellent post. I had the same incredulous reaction when I read the original post, and I have only a passing familiarity with GIS systems. Glad to see my intuition was right here. I might take a shot at pumping the data into PostgreSQL with a spatial index and see how that performs. My hunch is that even this KISS approach would have been faster.
That sounds right. To be clear, I wasn't suggesting that they wrote their own raft implementation. I was only remarking about their decision to include raft as a library instead of saying "you must point InfluxDB at a running Consul deployment in order to cluster InfluxDB". Respected JVM projects like Kafka use this model saying, "you must configure Kafka to point to a running Zookeeper cluster". There are definitely downsides to the approach taken by Kafka. But I'm sure that the upsides include less painful clustering and the ability to devote more development resources to enhancing your core business logic (in InfluxData's case quickly storing, querying, and moving time series data).
No, because vendoring is "the" way to handle dependencies in Go and GitHub/GitLab/BitBucket is "namespaced" by usernames anyway.
It's a shame that the book doesn't have a "Testing" section.
If you vendor the deps for your app, the sudden "repo went bye-bye" isn't a problem. If you didn't have your deps vendored, someone else will very likely create a new repo to house that code if it's at all useful. That or you go to your colleagues and get a copy from their $GOPATH (assuming you aren't working solo) and push that to github. Once the new repo us up, simply adjust your deps. 
I like httprouter. It does exactly what I need it to do amd keeps things simple.
I would guess that Postgres would be slower, just due to the latency of going to the database and back. Even with their relatively brute-force approach, they're still dealing with fractions of a millisecond.
Wow hadn't seen that Lyft post. Might need to dig into that one.
I'm really not surprised. These organizations tend to attract the kind of people who know best.
Big-O notation is used for analyzing asymptotic time complexity, so it's pretty unnatural to plug in values for your parameters and use the resulting numbers as any sort of indication of performance. Technically, a O(1) algorithm could take arbitrarily longer than an O(n) algorithm when you fix the parameter *n*. I know they were intended as very rough calculations, but you make the same point about performance with your benchmarks, so I think that section was unnecessary. Very good analysis otherwise, though.
What do you mean by "infrastructure OSS damages"?
Damage by Open Source Software done to you when you've based parts of your infrastructure on one of them &amp; later it gone commercial; without warning - And good news! You're already a client!
Great post, and way to back up it up with the code! I'd love to see Uber respond.
Uber should donate /r/buckhx a few grands...
Great post. When I read that Uber blog post I was a co-pilot to a coworker who was working geographical information retrieval in our system and after some quick napkin math we concluded that we could do the same at least 200x faster. The entire cost would be parsing queries and rendering the results, the rtree lookups themselves would be on the order of two digits nanoseconds.
IMO it's hard to forgive that he mentions prepared statements so late as SQL Injection protection. I still don't understand why any sane person would not use prepared statements all the time.
Not surprisingly, Google has a lot of Go code. I can't give out precise data, but there are a lot of executables whose dependencies exceed a million lines of Go. Indeed, I found several _single Go packages_ in excess of 200,000 LoC, all generated of course: some were protocol buffers, one was a test, another was some kind of framework. Files like this are a good test that your tools use only linear or n log n algorithms. If you give people tools that scale, they will do crazy things. As always, software engineering operates at the margins of "what can I get away with?".
You shouldn't write error details out to the error page -- unless, by "error page" you simply mean a custom page that looks nice, rather than plaintext "Internal server error"... error details can sometimes contain sensitive information that makes it easier for attackers to exploit your system. Anyway, in Caddy how we handle this is we log the error (and/or stack trace, if applicable) to the error log. This is not public and allows the website owner to get the full details of the error. Caddy can serve a custom error page that looks pretty, or if you don't set one, it writes a simple, generic plaintext error message. The exception is if you specifically turn on error details in the response; in this case, Caddy will write out the error details to the error page -- this is useful in local testing/dev situations when you don't want to keep looking at your log, and you just want to see the error when you load the page. However, as I said, this is a bad idea in production. To answer your question: Yes, I prefer that web apps write error pages that look nice, but they shouldn't contain error details.
I think you are better storing currency values as integers instead of floats which are not always precise. There are also very specific rounding rules for accounting purposes.
a proper decimal type is in the works, see https://github.com/golang/go/issues/12127 also if you only care about printing you can just use format string https://play.golang.org/p/GaL-ZryNMP
Storing "clean" floats seems ok to me. The main problem is computations produce "unclean" results. The money func zeros the extraneous bits (45.296200000001 becomes 45.300000000000).
A panic should be an indication of an exceptional problem. Log the issue and send out the most basic of messages in a sure-fire way. Otherwise, if something occurs like an err returned from json.Marshal(), I have a helper function which logs the issue and prints an HTML version of the basic error message.
Remember, not every web server is used to serve user-facing content, and not every web server is used to serve HTML. It would be strange for a JSON API to spit out HTML in the case of an error. The plaintext that results from only writing a header isn't a lot better, though. I haven't looked at the specific cases you're talking about, but it would make sense to be able to define what content is sent.
From the linked post: Representing money as a double or float will probably look good at first as the software rounds off the tiny errors, but as you perform more additions, subtractions, multiplications and divisions on inexact numbers, you'll lose more and more precision as the errors add up. This makes floats and doubles inadequate for dealing with money, where perfect accuracy for multiples of base 10 powers is required. ------ Don't know what you mean by "clamping". The solution I have demonstrated removes the tiny error after each computation, so there is no cumulative affect. A decimal type in the language, that removes the need to fix errors, is clearly a better solution. Using only integers would probably drive me crazy, especially with percentages.
Thank you so much!
&gt; Considering the first point we decided to give up external caches like Redis, Memcached or Couchbase mainly because of additional time needed on the network Not sure what this even means..
This
I try to name my variables in a way that makes the type more obvious.
Thanks for sharing! This chat snippet is indeed revealing. One of the nice things about Go IMHO is you can quickly answer some questions by digging into the std lib code. This is the case with net/http as well, but that part of the lib is a little more complex that the rest. 
I'm now up and running. Here is what the fix was: Delete your the go mobile src/package and binary from your $GOPATH (the bin, pkg, and src folder artifacts). Then reinstall gomobile and it works fine. My tool chain just wasn't set up correctly after all.
This is amazing. Is there some kind of research-phobia going on in this industry?
I think there's just research-phobia in lots of startups in general. In the rush to get a product out, they don't have time to scan the literature, or don't have the background to find it or understand it if they do. The downside of having people who can put together a website but don't have the academic underpinnings I guess. People optimize for different things. (OTOH, my github is filled with implementations of academic papers, so you can guess which side I fall on...)
Wow, just looked at this repo. Good work to whomever created this.
Check out [Go Report Card](https://goreportcard.com/report/github.com/otobrglez/socol). It'll show you some additional tips.
Skimming the source code, this isn't as bad as it sounds. Each cache shard is implemented as a pool of bytes, and some overhead to maintain a ring buffer in the bytes. "Deleting" the objects is as simple as iterating where the head of the ring buffer is. The other part is that they seem to use a number of shards in the 1000s, and eviction is just per-shard. Even under load, they have a relatively low number of expired elements per shard. I also have trouble believing that the local HTTP overhead is so high that memcached isn't a solution, but whatever
This can be done, although it will be somewhat slower at first. Obtaining similar performance would take quite some time and will need experimenting a lot. I'd be grateful if you could file an issue on easyjson github page.
That literally tells/means nothing. 
Yet another thing written because people cannot understand existing technologies and posted most likely for marketing purposes. 
I know it's not much but this started out as a pure Golang project and I just found it mildly amusing that the Microsoft C# creep has started.
Probably it's there for a good reason... for example I would consider writing the UI in C# if needed
No.
You could try the Guru tool (godoc.org/golang.org/x/tools/cmd/guru), which plugs into many editors. Among other things, it can show the type (and fields and methods) of any expression you select.
[This](https://github.com/search?utf8=%E2%9C%93&amp;q=user%3Amicrosoft+language%3AGo&amp;type=Repositories&amp;ref=advsearch&amp;l=Go&amp;l=) happens.
What project is this?
Cool it's nice to see other MSFT stuff in Go
Float for money handling? rounder? Please tell me that you are not working in bank in which i am storing my money. Read how Mt. Gox went down doing things like you try to do. You should ALWAYS operate on full numbers, there is no exceptions to this rule. You only show floats to your customers.
You are essentially calculating with integers, you just use 53 bit integers. So yes, if you round *after every operation* -- and as long as you stay below 2^53 cents, which is a reasonable assumption for most applications, but not all -- you can actually get away with using doubles (in my opinion. After thinking about it for 5 minutes. Don't blame me if you do it, it breaks and you get sued). However, you don't really gain anything. You are doing *exactly* the same dance as if you just used int64 from the beginning, except now the compiler won't tell you if you fuck up. Oh, also your rounding is wrong and might get you sued. But that should be easily fixable.
And that's the reason this community is awesome.
Change `"localhost:3000"` to `"localhost:8000"`, no? You can't change the port of an existing connection though.
Ok, maybe the government can't use it. I'll rethink with integers, but I still think it's a good solution. Thanks for the comments. 
This is great. Emacs's go-mode will soon have optional support for this tool.
Excellent article. I was really surprised when Uber proudly promoted their solution, the same week I was posting about using s2 for massive polygons lookups http://blog.nobugware.com/post/2016/geo_db_s2_region_polygon Guess which article gets more audience...
Just as a heads up you got the link to the atom package wrong. Should be: https://atom.io/packages/godoc Great tool though!
This is certainly a trade-off when using any language that doesn't have required type declarations. I do a lot of Python work and the situation is similar, if not even worse! Go doesn't have "dynamic initialization" per se. The compiler is actually smart enough to determine a type at compile time, which basically saves you from typing a few characters. This is called "type inference." Lucky for you, Go does not force you to make use of type inference. It's perfectly legal to declare variables ahead of time with their concrete types like so: // Type inference using the ":=" operator myStr := "A string" // Without type inference var myStr string myStr = "A String" These two snippets equate to the exact same thing. In fact, the compiler will likely compile both in the exact same way, meaning there isn't even a performance hit!
I would just say, give my solution a try with money related code. If you can find a problem I would almost be relieved. Right now all the comments are negative, but I can't find a computation where it doesn't work.
It looks to me like the tool also wont work with temp files. If I run the command on the temp file it reports and error like this: gogetdoc: couldn't get package for c:\users\jussij\temp\tmp3c4hzf#213: can't find package containing c:\users\jussij\temp\tmp3c4hzf#213 But if use the actual file name it works as expected. Now of course the work around is to just use the actual file name. But the issue with doing that is for the *gogetdoc* call to return the correct results the editor has to also save any file changes prior asking for the documentation, which is not what the user would expect. I think passing in the file name as an additional command line option would be a cleaner option? 
That's 299 cents / pound and you would have to truncate and/or round and/or clamp at the end anyway. Tell me the last time you paid half a cent for anything. Stocks are always bought and sold in whole stocks and their prices are also in whole cents. Interest may have 0.08% or something like that, but it is multiplied by the whole cent value of your balance before being truncated back to the whole cent.
If you want to select the port based on an integer, you could use something like: net.Dial("tcp", fmt.Sprintf("localhost:%d", port)) To change the address is similar: net.Dial("tcp", fmt.Sprintf("%d.%d.%d.%d:3000", addr&amp;0xFF, (addr&gt;&gt;8)&amp;0xFF, (addr&gt;&gt;16)&amp;0xFF, (addr&gt;&gt;24)&amp;0xFF)) assuming the address is in little endian.
Details: https://groups.google.com/forum/#!topic/golang-dev/DpMyPbclI3o
For unsaved files, there is https://github.com/zmb3/gogetdoc/issues/4 which should eliminate the need for operating on temporary files.
When go first came wasn't superfast compile times a big selling point? Think I remembered a demo compiling the whole class library in 9 seconds. What happened since then. Stuff like generics really hurt compile speeds but there is no support for generics. Go is a very simple language so how come the compile speed is so poor?
I love Scala but his assertion of it being good for writing command line utilities is quite off the mark if you ask me. You want command line utilities to be very fast to launch, not having to wait for the JVM to fire up. There's a reason Docker, Cloud-Foundry et al are written in Go and not Scala. 
&gt; I see definite advantages over using integers. Joe's butcher shop sells hamburger for 2.99/lb. The pkg weighs 1.7 pounds. On Monday's there's a 5% discount. Doesn't seem very integer friendly to me. You didn't understand what I was saying. You are also calculating with integers. Your code is equivalent to using integers. Except that you truncate to 53 bits instead of 64 bits and you don't get compiler-checks that you do it correctly. But all the ugliness of using integers and all the extra logic to make sure that you get the correct integers *still has to be there*. You might not think this is "integer friendly", but you are proving that *yes it is*, by *using integers*. &gt; If your just assuming using integers doesn't have problems, then I think you're wrong. Using integers (as in "the variable type", not as in "the concept", like you do) has exactly no problem that your approach doesn't have, but it has two huge advantages: a) The compiler guarantees that you don't forget to round and b) the subtleties involved in using less precision than you might need become obvious. Again, to be 100% clear: *You are using integers*. If you think, using integers has problems, than *you have those problems and then some*. &gt; My solution may have issues but I haven't been able to find one so far. Yes, and I directly asked if you have looked and the implicit answer seems to be "no". One point where the shortcomings of your approach are pretty obvious is: Split up a restaurant bill equally between 10 People. No, that's not easier with integers (after all: You are using integers), but at least it's *obviously* a hard problem when using integers. But I still also recommend that you actually sit down and think hard about a) what precision you need and b) the implications of expressing a base-10 concept like financial rounding with binary calculations to the precision you have available. I mean, really, literally, sit down, take a piece of paper and *do the calculation*. *If* you come out with a "yes, that's fine", you can claim that it's fine to save your integers in float64, though you still have all the readability problems and opportunities to fuck up without compiler checks. However, I don't have the time of doing the job of random strangers on the internet. Go ahead and continue to believe that you don't use integers, or that saving integers into float64 somehow makes them better, that's your own timewaste. I'll just pray that I'm not your customer.
That has been explained exhaustively, both on this subreddit and on golang-{nuts,dev}. I'd also like to point out that even a go with increased compile times is still orders of magnitude faster than anything else.
Thank god they came to their senses about SQL. Maybe it's worth actually taking a look now.
Interesting stuff, thanks for sharing
Did you check that you are reusing already allocated memory as much as possible? I found out that this doesn't really improve the performance overall, but makes the deriviation between one benchmark run to another much smaller. You can see how many allocs you do with the go test benchmark runs if you enable the memory flags.
As a devops person the first thing I look for CLI tool is hard JVM dependency, 100s of random jar files, scala libs and generic type safe maps. Sounds about reasonable!
I'm a Python coder trying to get into Go, and this is something I've definitely noticed in the community. Optimisation is a much bigger topic amongst Gophers, which from my perspective, is amusing. The first program I ported to Go didn't seem to run significantly faster than the original Python, at a bit over 1 second. Then I realised I was using `go run script.go`, so the wallclock time included compilation, and the penny dropped when I also noticed the units in `log.Printf("done in %v", duration)` weren't seconds… The Go version was orders of magnitude faster. And these people want *more*???
What was wrong about redis? 
Looking for feedback on the API and/or suggestions for performance optimizations!
[__crackers__ we just want to Go FAST](http://img.pandawhale.com/post-40322-I-feel-the-need-for-speed-gif-JN84.gif)
I wrote [git-freeze](https://github.com/nicerobot/git-freeze) to facilitate this. It defaults to supporting submodules but can also utilize subtrees. Here's a [discussions of using this technique](https://www.reddit.com/r/golang/comments/492w0u/do_you_like_go_get_want_to_vendor_your_code/).
I use this build script; it produces a slightly elaborate version string that is really useful for knowing what commit/tag the build is based on and which files have changed: https://github.com/mholt/caddy/blob/master/build.bash
&gt; The solution I have demonstrated removes the tiny error after each computation, so there is no cumulative affect. So every single simple integer operation on an integer number of cents gets replaced with a floating point operation followed by a floating point rounding operation? Other than terrible performance, what do you see as the benefit of your approach?
I'd also recommend checking out https://www.bitballoon.com/ You basically create HTML/JS/CSS and bitballoon will capture all the input from the form and database it. You can then link it up to Zapier and connect it up to various other services without having to write any code. https://www.bitballoon.com/docs/zapier/
Interesting post. I'm a Perl developer now working with Go for a few months since starting a new job. Obviously we are in different worlds now, coming from a loosely typed language to a (use) strict one, but I'm not sure the "need for optimizations on smaller levels" is that much different between Go and Perl or any language for that matter. As a Perl developer, I always revisit certain parts of code, trying to optimize them as much as possible, and over the years I've optimized small and large parts of my own and colleague's code with significant gains.
You need to use an editor that is go aware. I use vim and vim-go, but you have a lot of choices. Not only can I jump to a variable definition immediately, but as soon as I save the file, I get visual error markers in the editor for any thing the complier didn't like -- including assigning or using a variable in a way not consistent with its type.
Type inference is a good thing -- and common to a lot of languages. Do yourself a favor, and just use an editor that is go-aware. You'll find that the issue mostly goes away.
Here's how the "ooh, look how concise Scala is" argument usually plays out with a mid to large codebase. Team of 3-5 people write a bunch of green field code for the first time with Scala. Six months down the line, developer A needs to fix a bug in developer B's code. Full stop. Developer B used totally different incantations of flatMap than developer A and developer A's code looks foreign to developer B. Productivity plummets. Arguments ensue about which idioms should have been used, lengthy debates happen, team standards evolve and now twelve months in all developers are writing Scala that more or less looks like Java with a bit less syntax. One of the things I *love* about Go - minimal idiomatic debates, no magical guesswork to the syntax. As as a result, reading and maintaining someone else's Go is often very easy. The language may be verbose and nil checks do become tedious, but revisiting old code is trivial and doesn't get in the way. Languages that let you be overly concise aren't necessarily a good thing. Rest assured that flexibility will be abused.
The JVM slow startup time argument isn't much of a thing anymore and hasn't been for several years. For example on a ~2015 MBP: ❯❯❯ time java -Xmx1G -Xms1G -jar rest-oauth-client-1.0.one-jar.jar ... java -Xmx1G -Xms1G -jar rest-oauth-client-1.0.one-jar.jar 0.40s user 0.04s system 220% cpu 0.198 total That forces a 1GB RAM slab allocation and completes in under .2 seconds. A large Scala application would take longer, but there's nothing overly slow about the JVM's startup time in and of itself. That's also not to say using Scala is a good choice for CLI tools, but JVM startup time isn't an argument against doing so.
If the consumers of the library repo all use a tool to "flatten" the vendor tree, then by all means, please vendor the library's dependencies. If your consumers of the library just use "go get", then you may want to hold off now checking them in them. It may still be worthwhile to copy locally and check-in dependencies that are purely used within your project, are not exposed in any API, and where a duplicate package won't hurt anything. Even if you don't check in your source code, you could still include a meta-data file that can pull down the exact versions you used so you can test with consistent revisions and people who use a compatible tool can also be offered those revisions. If you use govendor (github.com/kardianos/govendor) this would be equivalant to vendoring your deps, but then adding "vendor/*/" gob to the ignore file. This will check in the meta-data file but leave the dep sources. Then you can run "govendor sync" to pull in those exact revisions. 
I'm doing a test and benchmark driven development. Sure it takes more time but once you know how to optimize your code you instantly code the "Go way". I'm coming from PHP ;-)
&gt; java -Xmx1G -Xms1G -jar rest-oauth-client-1.0.one-jar.jar ... java -Xmx1G -Xms1G -jar rest-oauth-client-1.0.one-jar.jar [The horror...](https://media.giphy.com/media/12ZXZv7aoviBgI/giphy.gif)
Yay! :) Honestly based on the description, I was expecting somekind of htop-style visualization rather than JSON.
This is probably the best way, because no, there is no standard way. I'd avoid that `VERSION` file idea, as not only are you prone to forget it, but it'd start straying into the domain of what a package manager does...and we already have too many things competing in that space :)
there is also https://github.com/zenazn/goji/tree/master/graceful ..which even though is a subpackage of goji, it works with anything that uses http.Handler
do you use integers in go for writing money related code ? I agree you absolutely cannot use floating point without taking special measures.
seems like a lot of work.. I find this to be more manageable: https://github.com/pressly/chi#examples
Thank you! Curious: is the array/slce situation still noticeably different if you specify a cap of 3 when making the slice? i.e `fooslice := make([]foo, 0, 3)`? Or, for that matter, allocating a *length* of three and assigning like you are already with the array? I ask because using arrays directly is generally ugly when it interfaces other code, so keeping things slice-like is nice if it doesn't carry a performance hit..
100% agree. When the announcement was made that 2.7 EOL was extended I tweeted: &gt; Last 5 years have been spent making the jump from 2.x to 3.x less difficult, not more compelling. There's certainly an element of that from a Python perspective. I don't have enough history/experience with Ruby to know if the 1.9 -&gt; 2.x transition was similar, from what I can tell it's not quite so fractured. I also think that the Python authors underestimate how restrictive the GIL is. I spent years believing that "getting rid of the GIL would hurt single-CPU performance", and then here comes a language with better performance _and no_ GIL hamstring in an 0.x version, and it worked just fine. Obviously it does not have the same semantics as Python and it's a bit apples/oranges, but it was _certainly_ worth looking into.
Glide does this for their builds, if you need an example. https://github.com/Masterminds/glide/blob/master/Makefile
I considered that later on, and my intuition is to agree with you: the append() is the expensive part, not the use of a slice.
Also the addition of SSA slowed it down a bit, but I think some low-hanging optimizations mitigated that a bit. 
This sounds like an issue with your driver, not gorm. I use gorm, but with postgres, so I don't know what the specific deal is with mysql. Here's an example of using gorm with mysql: https://github.com/ant0ine/go-json-rest-examples/blob/master/gorm/main.go 
I haven't written any money-related code in Go yet. However, it's safe to say I won't be using floats when I do.
I had a bit of free time so I did a quick test. I used the census tracts GeoJSON loaded into a table with a geometry column. To load the data, this psql script worked for me: \set content `cat nyc_census_2010_tracts.geojson` CREATE TEMPORARY TABLE geojson (data jsonb); INSERT INTO geojson VALUES (:'content'); CREATE TABLE census_tracts ( id serial primary key, ntaname text, boroname text, shape geometry); INSERT INTO census_tracts (ntaname, boroname, shape) SELECT geom-&gt;'properties'-&gt;&gt;'NTAName', geom-&gt;'properties'-&gt;&gt;'BoroName', st_geomfromgeojson(geom-&gt;&gt;'geometry') FROM geojson, LATERAL jsonb_array_elements(data-&gt;'features') geom; The query looks like this: SELECT * FROM census_tracts WHERE ST_Contains(shape, ST_Point(-73.9590, 40.7830)); Benchmark results on my rather non-idle i5 2500K workstation: number of threads: 1 duration: 10 s number of transactions actually processed: 110003 latency average: 0.091 ms tps = 11000.222998 (including connections establishing) number of clients: 4 number of threads: 4 duration: 10 s number of transactions actually processed: 278934 latency average: 0.143 ms tps = 27892.978816 (including connections establishing) And latency distribution for median, 95%, 99%: CREATE EXTENSION file_fdw; CREATE SERVER files FOREIGN DATA WRAPPER file_fdw; CREATE FOREIGN TABLE geobench (client int, tx_no int, time int, file_no int, time_epoch int, time_us int) SERVER files OPTIONS (filename '/home/ants/code/gis-build/gofence-profiling/nyc/pgbench_log.7665', format 'text', delimiter ' '); SELECT percentile_disc(ARRAY[0.5,0.95,0.99]) WITHIN GROUP (ORDER BY ROUND(time/1000.,3)) latency_ms FROM geobench; latency_ms --------------------------- {0.076,0.127,0.311} Edit: did another quick test on a larger database by translating 52 replicas of the shapes accross the globe. CREATE TABLE tracts_100k (LIKE census_tracts INCLUDING ALL); INSERT INTO tracts_100k (ntaname, boroname, shape) SELECT ntaname || ' ' || offs::text, boroname || ' ' || offs::text, ST_Translate(shape, offs, 0) FROM census_tracts, LATERAL generate_series(0,360,360/50) offs; INSERT 0 112736 latency average: 0.109 ms
Go slices grow with extra capacity to avoid a constant reallocation and copy of memory. Not sure what the exact aglo is, but it's probably not crazy different than: Here's an example on play: http://play.golang.org/p/FcRm_2gGTf package main import "fmt" func main() { orig := make([]bool, 2) next := make([]bool, len(orig), int((float64(cap(orig)+4))*1.15)) fmt.Println(len(orig), cap(orig), len(next), cap(next)) } 
&gt; npm allowing deletion of packages. I get my golang packages from github. Someone could easily delete their project from github. &gt;npm lacking code signing, so the package could be put back with different content without anyone getting errors. Somone could delete their github account which can easily be hijacked by someone.
Thanks.
I haven't looked at that sort of thing yet. It sounds interesting though. I should play with that soon.
I guess the fact that this is allowed? I don't find it really funny. If you follow the languages rules, then anything is fair game really. But just because you can do it, doesn't mean you should.
Yeah, it got a little slower over the years as Go matured from 1.0 to 1.6. Go is finally mature enough that it makes sense to optimize the compile times even further. There was no reason to optimize prematurely considering that the Go compile times were and are best in class.
Greatly appreciated ;) edit: Anyone know of any other in depth resources written on this (maybe from someone with more experience)?
i use Slack at work (and for extra-curricular projects). the lack of a quick &amp; easy way to search the Slack Team Directory for a phone number or whatnot bothered me. so i wrote one. its written specifically for Google App Engine (so there's no main() func) but it would be trivial to "convert" it to run on a regular server. note that due to how HTTP requests are made from Google App Engine w/Golang, i had to fork &amp; extend https://github.com/bluele/slack into https://github.com/rickt/slack-appengine so that the HTTP requests are being formed using App Engine's helper funcs. hope it can be useful to people. it is for me and my team!
I am beginning to like this new Microsoft.
Just recently I researched those and I've settled on tylerb/graceful because it seemed to handle everything a little bit better than the others. 
just use jenkins.
upvote for humor
Really good article. Didn't see a github link on the page sadly. Would have loved to see a broader / more complete implementation 
Ah, that sounds exactly what I'm working on (http://everythingstays.com)! Interesting! Can I ask why you chose to write a package manager for a language, in a different language?
I've noticed, I was having a look at your project and really liked it. Not a fan of npm at all though. With regards to developing a package manager for JS, in GoLang - I'm a strong believer that different languages have their own unique strengths and weaknesses. Using JS for a CLI seems really anti-climatic. Sure, JS developers would be using the tool but I believe it would encourage JS developers to expand their knowledge and become more of a Polyglot. In my opinion, Go is a perfect language for building CLIs. JavaScript is an interpreted languages that needs a number of workarounds to get a flexible CLI. I realise this is a risky decision but at the end of the day, if nobody uses it - it's not a wasted effort because I've learnt a lot. I also try to avoid JS wherever possible! Having viewed your project - we would love to have some input from you regarding the IPFS implementation.
Personally I'd roll my own with a background process watching a channel for the os.Signal (SIGINT specifically) and kill the listener in there and wait for the wait group to complete. 
You're on this page, correct? https://tour.golang.org/moretypes/12 Let's say yes. Check this out: https://play.golang.org/p/SA5l2Us-q4 capacity doesn't grow constantly.
btw, doing some dumb testing (and copying that stuff over and over) it looks like the size of the array is just doubled if it's not big enough? w/e, it doesn't matter - it works no matter what for what I always need :-)
&gt; It's not that there is a single huge file (machine generated) that is single-handedly responsible for the compile-time regression Uh, well, actually.... https://github.com/juju/govmomi/blob/master/vim25/types/types.go (I mean, no, that's not *single handedly* causing the problem... but it definitely is causing its own host of problems).
Me too! I just started working here a couple years ago.
Was that intended to be funny? Jenkins is a pain in the ass, but a lot of people like it. . . 
https://www.imperialviolet.org/2014/04/19/revchecking.html Please read this to understand why revocation is broken. This is from Adam Langley, a core author of the crypto stack for 'Google Go'.
~~crypto/tls does allow you to do the revocation checking manually, but isn't on by default. See: https://godoc.org/crypto/tls#Certificate at Certificate.OCSPStaple~~
Thats for a server to supply it's ocsp information. Essentially "the ca signed this token that my cert is still valid today. Don't bother asking them." Is there a way to turn on checking for a client request?
You can use x/crypto/ocsp. The Response struct contains the validity/revocation status: https://godoc.org/golang.org/x/crypto/ocsp#Response
I'm not sure it if was intended to be funny, I assume not. It's just that I've never been a fan of it. Over the years I've been frustrated that Jenkins had such a huge market share that there were no other viable (open source) competitors. Kind of like the world of source control when we were all forced to use subversion before git came along and saved us. :) My frustration continued when CI as a service started to become popular because I prefer an internally hosted solution. It exciting to see the new CI systems, I can't wait to see where they get to over the next year.
Nice, I've waited for this for years.
I applaud the effort. As someone who knows Haskell, how do you feel about the crippled language that is Go?
Convention is that you do not vendor dependencies for libraries. If an app pulls in a library, the vendoring tool (e.g godep) should vendor transitive dependencies as well. 
&gt;https://www.imperialviolet.org/2014/04/19/revchecking.html &gt;The critical question is what to do in the event that you can't get an answer about a certificate's revocation status. If you reject certificates when you can't get an answer, that's called hard-fail. If you accept certificates when you can't get an answer that's called soft-fail. The reason for the article is to explain why most implementations chose soft-fail or no check at all as the default. Go allows you to manually check for revocation if you must. Spent the last hour researching how Go does this, here's a quick example: https://github.com/alexmullins/ocspchecker/blob/master/main.go
There is also the following implementation (I'm not a cryptanalyst and don't know if it's correct): https://github.com/cloudflare/cfssl/blob/master/revoke/revoke.go Go should have a solid, well-tested revocation check included in the standard library.
Fantastic! Now we can use Go on my startup's [IBM 3270](https://c2.staticflickr.com/2/1086/1367406603_02506c0d95_z.jpg?zz=1) terminals!
What platforms/devices do you need to support? What features do you need to support? There are [several protocols](http://www.dynamsoft.com/blog/document-imaging/document-scanning-twain-wia-isis-sane/). However some drivers/devices have bugs in their implementation of the protocols. Search for a particular protocol and you'll find [some libs to use](https://github.com/search?l=C%2B%2B&amp;q=twain&amp;ref=searchresults&amp;type=Repositories&amp;utf8=%E2%9C%93). tl;dr; if your scanner supports scanning into a folder, just use that. :)
Care to provide a link for the uninitiated? So far what I've gotten from Google searches is * "Why is Go so fast?" and "Go compiles super fast" - which apparently don't hold any more? * The SSA stuff, i.e. trading compile performance for runtime performance * The SSA stuff has been integrated but just not been cleaned up, there need not be a tradeoff between runtime vs compile performance * The C to Go migration of the compiler slowed things down * 1.7 will make things even slower .. or maybe it wont Maybe it's time for someone to put all of this in a blog post?
Oh fuck me.
Really nicely written. 
I don’t understand the commotion. Aren't multi-variable indexes are a database technicality nowadays?
Some examples pushed! And some bugfixes.
😜
Not a very good april fool. I wish you had prepared something more elaborate. That would be fun.
Hey, I thought simplicity was appreciated around here! :p Besides there's already a more elaborate one. ;)
For what it's worth, I consider this prank to be idiomatic.
Rob Pike wrote a great article on "the mechanics of append" and it's well worth the read. The exact answer is near the end of article https://blog.golang.org/slices EDIT: just to elaborate: The reason why it doubles size is because memory allocation is an expensive operation. Making an array bigger means allocating a bigger second array in the memory and copying all values from the first into it. If you this every time you add and element to your array, you slow down your program considerably. 
ding ding.. winner.. You guessed one of our consultants that rips off the company. Theres another big CF consulting company that pushed concourse on us though. 
Perfect, I'll try these out and will post any issues on GitHub.
Wait, you work with Pivotal but a different company is charging you for Concourse support?
You are probably LF this: https://godoc.org/golang.org/x/tools/cmd/stringer
Thanks. 
Preaching to the choir a little :)
pivitol provides support for CF while another company implemented this over the top deployment system to get deployments into CF. I work for a very large company who just tosses money at problems in hopes that things become better.. but consultants just dig their teeth in and make things way too difficult. 
Good job, mate.
I'm not sure if I'm following. Are you aware that Concourse is a Pivotal initiative?
Okay. It sounds like your getting a third party to provide Concourse support. That might be part of why you're having such a bad time with it.
For sure, but there's at least one subscriber who's here to absorb a little Go knowledge while mostly using other systems. Can't remember his name, though.
Very new to Go. But what about making a money type with an int for dollars and an into for cents? Then develop a few functions for operations and deserializing?
I even said it was an April 1st (0401) prank in the commit hash! http://i.imgur.com/n4nFV2s.png 
Yo! Not that I need any persuading not to use node.
love that url 😂
༼ つ ◕_◕༽つ praise olig15 ༼ つ ◕_◕༽つ
This is the one-liner I use: CC=$(which musl-gcc) go build --ldflags '-w -linkmode external -extldflags "-static"' server.go Change server.go for the file (or files) you want compiled. You can also switch $(which musl-gcc) for your musl-gcc binary of choice, instead of the one found in $PATH.
the funny thing is, if any functional language couldn't return another function to be executed, then the same post would be posted anyway
Got me!
/r/programmingcirclejerk in 3...2...1
I wrote a [Sudoku solver](https://github.com/carlmjohnson/sudoku) in Go a couple of years ago, and I was tinkering with it again this week. It was based on a Python version written by someone else, so I figured I'd go back and benchmark it for comparison. My Go version processes all the puzzles in the test suite in about 200ms. The Python version? At first, I assumed it was broken because it wasn't giving me an answer… Then I realized, no it works, it's just much, much slower. It took around 15 minutes to complete the test suite. I think the big difference is that the Go version is using bit flags for testing set membership and the Python version is using a `set` filled with strings for `1`, `2`, etc. Probably you could if you tried get the Python version to compete with the Go version if you used a `list` of `int` to do the calculations. But it's not natural to think about performance in the same ways in Python.
Did Rob Pike upvote the post?
I have been using goos="linux" with cgo_enabled=0 and copying the binary into a scratch docker image with the entrypoint set to run the binary 
&gt; Not to mention that open source projects on Github are not permanent. Are they permanent on GitLab or BitBucket? Doesn't that apply to any open source project regardless of the language or platform it's hosted on? 
Nice article. One little nitpick: http.Handle("/", router) http.ListenAndServe(":3000", nil) This is unnecessary, and results in the system having to go through `http.DefaultServeMux` before handing it off to `router`. `http.ListenAndServe()` takes an `http.Handler` as the second argument, though, and passing one to it causes it to use that instead of the default mux. In other words, you could also do this: http.ListenAndServe(":3000", router)
Do you guys support MMS? 
Did you figure out why the C++ version was so much slower? I was being flippant wrt the speed of Go vs Python. It's really rather natural that optimisation is a bigger deal with Go than Python, simply because if execution speed is an absolute requirement, you wouldn't be using Python anyway.
What do you have against node ? Asking for a friend
I work at DigitalOcean and I was thinking, "well that's a surprise".
Anyone have the link to the official golang template post that he mentioned? His link is broken.
Ahhh... don't bash Haskell. Poor Haskell. Should've been something weirder like BF. 
Sorry, I forgot to add it! I've edited the post, but to be sure you have it, [here you go](https://golang.org/doc/articles/wiki/)
Been working professionally with Node for a while. Despite all it's quirks, there's a certain elegance to developing with ES6+ and TypeScript especially. Yeah I'm always going to recommend Go over it, especially for large projects (large Node projects are some of the ugliest code I've ever seen). Why recommend Go over Node? Go will age well and scale up to large teams well, but Node absolutely and completely doesn't. Things will stabilize in a year or two -- after tooling, build processes, and packaging conventions stabilize -- but everything prior to then will be some crazy garbage. Leading companies will have the staff on hand to enforce minimum standards and expectations when it comes to Node development, but everybody else will be left in the cold. Go brings these standards to *everybody else* without scaring too many away.
Check out this suggestion from Merovious: http://play.golang.org/p/3RT-fzmruI If you're new to Go it may not be clear what's going on, but its a good example of how to write Go code.
Oh, I'm sure he knew it was a joke. He just never misses an opportunity to remind us all how much computers used to suck and how they suck differently today. He does so light-heartedly and with humor, though.
There is the FAQ which does more than "hint": &gt; Generics may well be added at some point. We don't feel an urgency for them, although we understand some programmers do.
&gt; Go's package management literally relies on GitHub 100% false, but everything else you said sounds reasonable.
JavaScript. 
How is it 100% false? I could see you saying "That's not completely true" because you can technically host Go packages off of GitHub (You can also host node packages off of npm, btw), but I think calling it "100% false" is pretty close to 100% false, unless I'm missing something. The vast majority of Go packages are hosted on GitHub. In fact, I tried to verify this and I could only find lists of Go packages that are hosted on GitHub. I can't even find a *list of popular repos* that isn't posted on GitHub *itself*. Go's tutorial doesn't even use examples from outside GitHub. (this is all except for the built-ins, which is true of any language I've ever heard of) Actually, let me restate that assertion in a stronger but less specific way: Go's package management relies on worse principles than JavaScript's. The packages are more likely to be located in different locations entirely (though I've pretty much never installed a Go package from anywhere but GitHub, but I have yet to program in Go professionally) (I consider this a bad feature, as opposed to an agreed upon place to find packages), and those locations are more likely to be low quality (say what you want about npm, but it has high uptime, it's fast, and it has guaranteed licensing and packages are now pretty much guaranteed not to be removed, unlike anywhere Go packages are usually found). It's also worth noting this entire criticism chain is not actually a criticism of node itself, but a criticism of npm. Yes, they're *pretty much* inextricable at this point (in that npm is packaged with node), but it's not quite as inextricable as *literally having the same binary*, which Go does.
&gt; Go's package management *literally relies* on GitHub Of course that statement is completely false. You could argue that Go _developers_ rely too much on Github, but that's very different from saying Go's package management relies on Github. Personally I don't see the difference between npmjs.com and github.com. Having a centralized list of packages is not a feature I've ever cared about. Not even when I'm using npm. Google is a better choice for finding libraries, because it knows more about which libraries people are talking about and have the best documentation. Anytime I find myself on npmjs.com I immediatly look for the git repo url (Usually on Github) and head over there. I want to see how many stars and forks the library has. I want to see how the author is responding to tickets. I want to peek at the code. I'm sure there are types of developers who like sites like npm (feels mostly like _marketing_), but I'm not one of them. I like code. I want to look at the code. To me the difference between npm and Github is like the difference between Mac and Linux, and I prefer the transparency and openness of the latter. I like that Go doesn't hide the intricacies of package management behind a shiny facade.
The Unix cp tool?
 From the [Go Slices Blogpost](http://blog.golang.org/go-slices-usage-and-internals): &gt; Go's arrays are values. An array variable denotes the entire array; it is not a pointer to the first array element (as would be the case in C). This means that when you assign or pass around an array value you will make a copy of its contents. (To avoid the copy you could pass a pointer to the array, but then that's a pointer to an array, not an array.) One way to think about arrays is as a sort of struct but with indexed rather than named fields: a fixed-size composite value. Slices are pass by reference, while arrays are pass by value. This means that the array is actually copied when put inside the map and when you get it out of the map it is copied again. I would imagine that is why the slice is immutable when in the map. Check this playground. http://play.golang.org/p/UqhxWXE_Xo You'll notice that modifying the result of getting an array from the map actually doesn't modify the original array, while modifying the slc variable modifies the original slice. 
I'd like to point out that go get command actually clones a git repository. It doesn't really have to be github.com. It can be a local repository, it can be gitlab, any site with git. 
&gt; any site with git , Bazaar, Mercurial or Subversion.
For any serious Go project, the recommendation is to vendor any dependencies (using govendor or similar), making your builds and deploys completely independent from external sources, until someone decides to manually update a vendored package from upstream.
This, It would never occur to me to add a dependency for such a trivial thing, and I am pretty sure a lot of the projects that relied on left-pad also relied on lodash, which provides "_.padStart()". The problem is the lack of understanding of the environment, which is a huge problem in programming and pretty common in the community. 
The tests are with SSA enable and his down and plus sides ?
Thanks for putting this post together! Appreciate all of the effort to quantify the 1.7 changes, and it's awesome that they are a net improvement in all dimensions!
What kind of website do you want to create? Can you give the link to the current site? Any other site that has a similar structure? What does the DB contain? It's hard to recommend anything useful without knowing anything about the project. Here's the basic principle https://play.golang.org/p/gFDz-bDtSy
yup! You can specify any valid media URL (imgur/s3/etc..) or upload the media directly to bandwidth and use that location.
so this one builds binary against musl libc statically, and I can do this on non-Alpine environment, provided I have musl installed? 
Aaand that's it? A comparison of helloworlds in both langs?
Both the Go compiler and the runtime where converted from C to Go.
So, I have learned something new today, but it doesn't seem that `go get` supports only public and internal repositories, not private ones.
It's a website for our buddy's real estate company. [Here](http://www.tamborrel.com/) is a similar example. The db contains each line of markdown that is necessary for Hugo to build it correctly. So for the example site that I linked there would be a folder for the menu item "buying" that contained a markdown file for each of the links in the drop down menu. And each home under /buying/featured-listings would have its own markdown file. So the content folder of the site would look something like this: . |-content |-Property Search |-Explore |-Buying |-search-for-homes.md |-featured-listings.md |-house1.md |-house2.md |-Selling |-... THANK YOU for your help btw
This is true of npm as well. It's *a little* more difficult because you need to use .tar files, but I was recently maintaining a node module through tar (on GitHub), and it really wasn't that bad.
I see what you're saying, but the lessons you're learning from go get's lack of features can be applied to npm too. The difference is that you don't need to. By the same logic, you could argue that a complete lack of package manager is better because then you learn to manage the best practices to manage dependencies. But then you have to do all the work yourself, and you're probably going to mess up unless you're extremely experienced (and Go of all languages should not be gearing towards the extremely experienced).
A reference to the relevant part of https://golang.org/ref/spec that states this restriction would be handy.
The article was done well enough that I'm reading through the tutorial right now. Though additional articles would be interesting, the author seems to have accomplished their goal.
Is it an improvement yes. I would not depend on it, and better isn't good. Ultimately getting out of that trap with NPM is harder than it needs to be. If the paid version of NPM wasn't impacted by this issue, that would be telling. 
Why would you depend on GitHub but not npm? I fail to see how "getting out of that trap" is harder with npm than it is with GitHub. I'm not trying to argue that npm is perfect. That's never been the argument.
Are you just looking for a way to serve static files (specifically Markdown)?
There are a lot of interesting ideas here (both the article and ponylang site are appreciated), and maybe, if I had greater capabilities, expressing purpose with the language would be more appealing. However, at this time, Go's simplicity is far too comfortable and useful to me to spend much time digging beyond the tutorial. I may reconsider this in more time and as I gain experience.
Most NPM users that I know are dependent on NPM being up to do a build... Once I have the code once and I know I'm going to use it it goes into my personal repository. The only time I need github to be up is the FIRST time I pull the code, after that I own it. EDIT: Post lunch dip stupidity removed
I found Pony interesting from the article and not from the example
It's not mentioned in article but we also try [concurrent-map] (https://github.com/streamrail/concurrent-map) and fnv is used there. Currently [hash function] (https://godoc.org/github.com/allegro/bigcache#Hasher) is configurable so we can test it. [There](https://github.com/allegro/bigcache/pull/5) was propose to use [farnhash](http://www.infoq.com/news/2014/04/google_farmhash) but we decided to let user configure it. 
I can see why it is called "Pony". It seems to have a few similarities to Go concepts, but caters to those that say "Daddy! I want a Pony!", and gives them everything Go doesn't have. But then, caring for a Pony is quite a responsibility. After reading through the Pony tutorial, there is much more "language" to comprehend (i.e. 6 types of reference capabilities, and the specifics of receiving them and converting them between types). It looks really cool, but it also makes me appreciate Go's stance on simplicity. 
Why then, given a map of with an int value can I say m[i]++, and that sticks but m[i][j]++ doesn't?
#
That depends on whether or not I choose to put the dependencies in version control. Typically, I don't put the dependencies' sources in version control. Do you do that with Go? That seems a little silly. I've never worked in an environment where the whole dependency structure is included in the repo. NPM used to handle this poorly, so a lot of old modules tend to have a lot of bloat, but in a year or two, this won't be a *terrible* strategy, but I still probably won't do it because I see almost no point in doing that. If you wanted, I could copy the project to a flash drive and give it to you and you could just keep working off it. edit: I did a little research and have found some Go projects on GitHub. None of them that I can see include their dependencies in the actual repository. A couple of them use gopm, though, so surely that's skewing things. Most of them seem to just kind of inline the dependency declaration in the files that require them (as part of the import statement). That's the way I was taught it, and then the dependencies get installed in your local Go path. I'm not even sure how you would put the dependencies in the repo, to be honest.
Imho it's always better to build your artifacts on the same system / configuration that's going to run them. 
Correct. This leaves the linking to gcc (specifically, musl-gcc), indicating it to statically link musl in and the `-w` flags strips debugging symbols, reducing binary size. Doesn't require disabling cgo, which is a huge plus, although os/user and some other package were broken at least up until 1.5, with 1.6 supposedly fixing os/user. However I have not run any tests on that and I don't even remember which other package it was, but I do remember it being irrelevant for my web application (a RESTful, DB-hitting server).
I mean, is it exaggerated? It seems like they've been very transparent about the speed loss. It's a fairly moot point because the speed is still fast as you mentioned--but the stats speak for themselves, no hyperbole needed.
I think it's also worth emphasizing that using the new Go compiler resulted in a slower *compile* time (time to build), not the actual performance of the application at runtime. A 2x loss of runtime performance would almost certainly never fly.
You mean like this? ;)
i watched an interview on InfoQ (I think) of the creator of Pony, and this is actually why it's named Pony. He wanted everything he couldn't have in other languages, all at once. A friend teased him about wanting a pony too.
https://github.com/tristanwietsma/tabler Wrote it a while ago for a proof of concept.
Why even use a database? Just put them in files and run a hugo server. Plus you can create your own layouts if you know html. This isn't even a hugo problem. More of a problem of not understanding how templates work.
The standard library is the "minimal web framework" for Go. If you want more than that you want something like negroni+gorilla or gin. Please don't take this the wrong way, but web frameworks are something that has been done to death in Go. I'm pretty sure there's at least a new one every week, and they're all pretty much identical. If you want a project to learn more about Go and push the boundaries a bit from the usual, why don't you try making a desktop application with a GUI? Personally, I've never seen one posted here on this sub :)
No, my intention is to finish writing the article tonight. I just published a first draft and it got picked up here :) Edit: I should have made it clear in the article that it is a work in progress.
Is the 120 second enforced GC issue still there or has it been resolved? Could you comment more on Go being a non starter for soft real time, because we were just about to start using it for an embedded Arm project that does need soft real time. I thought Go 1.5 ensured GC was not more than 10ms usually: https://talks.golang.org/2015/go-gc.pdf Is that not correct, or was 10ms too much for your application?
Only April fools post that actually got me. Haha
Nice article. Even though I'm a bit of a Go fanatic, it's nice to see an opinion from someone who's tried the language but neither loves it nor hates it. A couple of comments ^(that I may add onto when I'm not on my tablet): &gt; It took me a while to warm up to Go’s design around dependency management, but not having to run and manage everything through a slow and complex system like Bundler hugely improves the development experience. Finally, someone with a similar opinion to mine. Having gotten used to Go's package management, I find most others, such as Gradle and Cargo, to be incredibly annoying. My only real complaint is the error the `go` tool throws if a remote package has a relative import. I've argued with the devs over that one, but they always just give their usual dismissive answers. It's true that a lot of the time it's not *too* big of a problem, but it can really become an issue when you're dealing with GitHub forks that contain multiple packages that all reference each other. &gt; No generics This is always the biggest complaint I hear from people when I try to get them to at least look at Go. Yes, there are certainly times when generics would have been useful, but it really is an issue a lot less of the time than you'd think. It's nice to see that you agree after trying the language. &gt; Worse yet, the encouraged patterns of passing errors around through returns can occasionally make it very difficult to identify the original site of a problem. This is an acknowledged problem, but, because of the compatibility guarantees, they're a little stuck until Go 2. Hopefully something will get done about it then. &gt; Debugging I have just recently discovered that Visual Studio Code's Go plugin, which is actually written and maintained by Microsoft, has pretty decent debugging support using [Delve](http://www.github.com/derekparker/delve).
Mirrors my own experience very closely.
Really nice post. One nitpick: &gt; Closing a channel causes any Goroutine that was listening on it to fall through having received a zero value of the channel’s type. Not really, you need to check the second return value to see if the channel was closed: v, ok := &lt;-ch if !ok { return } ... Even better - use for range where applicable: for v := range ch { ... } It'd be interesting to see govet throw a warning when a channel is read in a for loop without testing the second ok value. [edit] I often nil the channel if it was closed, but I don't want my processing goroutine to stop: for { select { ... case c, ok := &lt;-newCh: if !ok { return } ch = c ... case v, ok := &lt;-ch: if !ok { ch = nil continue } ... ... } }
Keep it up mate looking forward to see the upate
The author has one gripe about the community that reads: &gt; The best single example of this that I’ve found so far is a request for a non-zero exit code in Golint. &gt; The community articulates the problem and shows an obvious demand and willingness to help. &gt; Meanwhile the member of Go core can’t manage to build even a single cohesive counterargument, &gt; but even so, the issue along with all its ideas and suggestions are summarily rejected. The issue thread on Github actually ends with a comment from Russ Cox from a few days ago: &gt; This is clearly a feature that is important to a significant class of users. I don't see why this is "wontfix" https://github.com/golang/lint/issues/65#issuecomment-202415765 So actually someone from the core team has indeed acknowledged the importance of this problem.
From a quick glance over the feature list &gt; * Structurally typed interfaces seems to be contradictory with &gt; * No implicit interfaces (You need to be explicit) Can anyone explain what's actually going on?
&gt; My only real complaint is the error the `go` tool throws if a remote package has a relative import. I've argued with the devs over that one, but they always just give their usual dismissive answers. It's true that a lot of the time it's not *too* big of a problem, but it can really become an issue when you're dealing with GitHub forks that contain multiple packages that all reference each other. Not only forks, but also if you want to use something like https://gopkg.in It works fine for a single package, but if you if your repo have multiple packages that reference each other, should the import path contain github.com or gopkg.in?
On the other hand, dsymonds point that golint has too many false positives to fail a build on also makes sense. Much autogenerated code doesn't pass linting (protobuf for example) and last time I checked not even the stdlib was lint-free.
&gt; should the import path contain github.com or gopkg.in The import path should be the one true canonical path. If they use `gopkg.in` (which I personally don't like as it's not only git specific it's github only) then that's probably the `gopkg.in` one. The package author can/should enforce this by using an [import comment](https://golang.org/cmd/go/#hdr-Import_path_checking). IMO import comments should be added when *any* import alias is used/created.
Yes, me too. I'm glad this bug will have a happy ending :)
&gt; Being able to compile and run your entire test suite in under a second 1 changes the entire development experience in such a fundamental way that it’s hard to adequately describe. Does anyone actually have this experience any more with non-trivial apps? We've been working on a small API project that's maybe 5K LOC* and it takes 20+ seconds to compile now after all the speed regressions in Go 1.5. edit: 5K is my code only, no idea what the dependencies add up to