&gt; I like the idea, but personally would be a tough sell to my team when compared to Github's friendly UI, It's just a storage format and exchange protocol, there's no UI here (just the basic command-line flow). In theory, Github could implement their frontend on top of this, which would be great for everyone. &gt; also appears not to support comments on explicit lines/ranges, only whole commits. It does, as far as I can tell: https://github.com/google/git-appraise#review-comments range.properties.startLine
can someone pleaee ELI5 why/when would one use b4 := byte(344), and expect b4 to be 88 without compiler warning? I dont tend to overuse byte type as other ppl I know, but I hear them complain about different-than-expected behaviour during string manipulation. 
If you do this you are a Bad Person. Don't be a Bad Person. Bad Persons don't pass code review. We don't like Bad Persons.
I consider your "functional purist" argument to be misdirected, because the inclusion of a few constructs does not turn Go into a purist language, and I've never mentioned anything like that. OO is orthogonal to functional programming, hence Scala, and functional code always has imperative bits. The Javascript world is experiencing a shift at the moment toward frameworks like React or Redux. Facebook also released a popular library called Immutable JS (what is the motivation?). Why are people switching frameworks, which is very strenuous, as opposed to just depending on documentation? Some is momentum driving momentum, for sure, but surely some of it is because front end code bases tend to experience more turnover and thus maintenance issues than the back end, and new developers need to be able to identify which bits of code are imperative and which bits aren't. A developer can work on a module of code, a widget on the frontend, and understand a graph of dependency. Or you can just depend on documentation? Functional idioms also permit people to easily reason about multi-core distributed systems, because it's easy to identify parts of your problem for serialization and concurrency. Hence, MapReduce.
Line seems to be supported ([source](https://github.com/google/git-appraise/blob/master/commands/comment.go#L34))
Handling SIGINT or SIGTERM are the most common ways on Linux, but they might give you trouble on Windows. Depending on your setup, you can give the user some other way of signalling the application. For example, in a goroutine you could start a web server and listen for network connections. If the user goes to `host:port/diediedie`, the application quits. You could have whatever authn/authz you like on top of that, so that jerks can't kill your jobs.
Do you have any references to that from before October (that's the earliest I could find)? For comparison, git-appraise has been public since August and has history going back to April. Regardless of timeline, it's still nice to know about that; thanks for the pointer.
I get it, though you're only reinforcing my feeling. I don't really care what the criticism is, it's the internet after all. What I'm looking at is how the community reacts to all the noise. This isn't the first article or comment thread coming out of the community that feels hostile or pretentious. I think the Go implementers not wanting to change the language on the whims of some blog articles is a good thing. I'm sad I feel comfortable walking away from a great language because the community feels toxic. How about some tips to make this comment constructive: - A review, even if negative, even if repetitive, is valuable feedback. If you don't like the negativity or repetition, what can you do to address it? I've seen the same criticisms and rebuttals a lot, but I don't see clean documentation of it on golang.org. - If you don't like a rant you see, ranting back hurts the community. If you can ignore it, just ignore it, if you can't, politely refer to documentation on the discussion.
Well the go FAQ actually addresses [almost all of them.](https://golang.org/doc/faq) its pretty comprehensive talking about everything from virtual memory usage reasons and how pointers work, to why generics aren't in the system or why most changes to the language won't be accepted. And sadly when I've pointed people to the reasoning for some of these things the only replies generally say that it's not a good reason or they ignore many of the reasons and throw the baby out with the bathwater with a half baked solution. And ignoring it is near impossible. A link a while back on hacker news was about the new GC in 1.5, the new GC was largely ignored with all of the comments bickering about generics or a package manager. Its relentless, and really tiring for someone that just wants to talk about the damn language as it is and not about what someone *should* have.
Take the Tour of Go http://tour.golang.org/ and read the official FAQ https://golang.org/doc/faq
Where'd you get the word "best" from?
&gt; while people that actually use the language don't seem to see these as major issues. I write Go for my day job and the lack of generics and higher-order programming is a real problem. So much boilerplate and automatically generated code for what could be a simple generic function. (Specifically, given an array of entity IDs of some kind, do a batch fetch from the backend and return a []*T where T is the entity type in question. interface{} doesn't really help here because the point is that the data access API should return a slice of T instead of requiring casts everywhere.) ~~I once heard a quote that resonated with me. Paraphrasing, "The worst mistake the golang community has made is the politicitizing of generics."~~ Edit: Found the actual quote. "I think politicizing of technical matters is an extremely damaging pattern in the long run, and I hope Go finds a way to repair this." https://www.quora.com/Which-language-has-the-brightest-future-in-replacement-of-C-between-D-Go-and-Rust-And-Why 
You may write one with Go, actually.
They should be fixed right now (at least on the website). /u/scythelx covers the root of the problem :)
Python has lot of libraries like pandas, numpy and matplotlib for analytics. Pandas and numpy are written in c. so speed should not be an issue. Golang ecosystem may take few more years to catch up python. Continuum has anacoda with all python packages bundled for anaytics. https://www.continuum.io/downloads. You can try julia language too for analytics. It is still young but promising. http://julialang.org/ . 
I'd love to help you out with it.
Please also take a look at r/gogamedev !
Never heard of that before but was pretty sure I'd find something. For this, there's a [blog post](http://blogs.wandisco.com/2014/07/29/distributed-code-review/) from July 2014 and a [Youtube Demo](https://www.youtube.com/watch?v=8eSjN3B6lm0) from June 2014.
DigitalOcean have droplets starting at $5/month with 1TB of transfer included. If this is outside of your budget, I'm not sure what you were expecting.
if you are a student, digital ocean offers 50$
I am really interested about any options that I might be missing, so bring them on :). What do you mean exactly with option gameplay?
&gt; methods promoted to the outer level This is new to me. What is this called, so that I may read further information on it?
In order to make a good game, gameplay usually matters more than fancy graphics. As an example, the critically acclaimed game "[Thomas was alone](https://www.youtube.com/watch?v=Jc0C8H1YgUM)" consists mainly of simple shapes jumping around the screen. But I think there is a little confusion here. The poll asks "How would you like to program games in Go?" which is very different than "what would you focus on?"
Unfortunately I don't know if there is a separate name for the promotion of methods, but you can find out more about anonymous/embedded fields in the language specification: https://golang.org/ref/spec#Struct_types
I'm a bit confused on the difference between **abstraction layer** and **skeleton like GameMaker** ?
I'm working on a [hobby project](https://github.com/dnaeon/gru) in my spare time, so that I can learn myself a bit of Go. One of the things I needed for my project was a way to record and replay HTTP interactions in [etcd](https://github.com/coreos/etcd), so that I can test things out easily while developing. The result of this was creating [go-vcr](https://github.com/dnaeon/go-vcr), which does pretty much what I initially wanted for my other project and allows me to record and replay HTTP interactions easily. Thought I'd share it here as well, in case someone else finds it useful.
I am working on this https://github.com/tanema/amore at the moment. A go implementation of Love2D, working on audio right now but I have slowed down because I have never done any proper openal stuff before so I am learning a lot.
Yes. I too am doing these in Go. [https://github.com/adampresley/adventofcode/tree/master/2015](https://github.com/adampresley/adventofcode/tree/master/2015)
True, I probably caused the confusion there... I do agree that gameplay matters most, but no gameplay is possible without any form of UI.
i doubt it will in the startup space unless someone can put out something that can compete w/ rails or javascript frameworks for MVPs. edit: Go is currently uncompetitive when it comes to building MVPs but it doesn't have to be. There's nothing stopping someone from creating an `omakase` batteries included framework in Go and I would welcome it.
It's based on requests. If you're expecting high volumes of traffic, you will not find a free service. 
You don’t expect any income from selling the mobile apps? You can get pretty far with a $5-10/mo droplet on DO. I’m building a mobile backend (Android and iOS) for my current client, it will run fine on a few Heroku dynos. You have to specify what kind of workload you expect in order for us to give any reasonable estimates. Did you consider using a BaaS instead?
A lot of Ruby people have been putting effort into Elixir &amp; the Phoenix framework. Haven't looked into it too much yet, but it looks very promising.
it does look very promising, i would bet on elixir producing the next mvp framework over go
It can if you want it to. Modifiers run on CONNECT requests and responses and it seems that most browsers (we've tried anyway) send along the domain (and port) in the Request-URI line when attempting to make the connection. That should allow you to intercept it before the connection ever gets established. Alternatively, you could set up the MITM support that Martian has built in and do it that way, but it requires a bit more work since you have to create and install a custom CA certificate.
This is really encouraging thankyou. I am researching/planning an application to regulate access to certain websites (whitelist) on a schedule for people who have attention or executive function disorders - scratching my own itch and hoping to help others too. I'm really excited about this project and this solution is 100x better than maintaining a dozen browser extensions. Thanks alot!
I've been playing around with [/x/exp/shiny](http://www.godoc.org/golang.org/x/exp/shiny) and [/x/mobile/exp/sprite](http://www.godoc.org/golang.org/x/mobile/exp/sprite) and it's been promising. An input lag bug on mac has seemingly been fixed witch I will test out soon.
I just finished making a golang backend for use in IOS and Android. One thing I did find trouble with was linking my .aar file with the android project because it couldn't bind correctly. I was using Android SDK 23 with Android Studio 1.5. I assume you would be using this with golang 1.5. Anyways to fix this I had to download the master branch from golang, build the downloaded master branch then I had to create the .aar to stop the errors. Other than that it was super easy!
I thought it was already dominating 2015... am I missing something here?
cute.
That Makefile has some pretty nasty things in it, though.
Have you tried https://revel.github.io/? I use it quite often for MVPs myself. Or are you referring more to the lack of ORMs?
Hi, so I was browsering your site then I was assaulted by a pop up asking me to register, for no reason. I closed the tab and decided not to continue visiting your website since it forced me to register just to view some links. You should make it optional or you're going to lose a lot of visitors. The quora/linkedin pattern is going to kill your website.
I have never seen an article worth reading on medium.com. Always seem to be fill of drivel.
Well, if someone clones the repository, they have the repository there. But it needs to be at $GOPATH/src/github.com/hlandau/acme, for some value of $GOPATH. So unless they've used go get (in which case the makefile is irrelevant), the repository is almost guaranteed to be in the wrong place. So I don't think there are any good solutions here.
Nice and clear explanation on performing OCRusinga few command line tools and glue in go. 
oh god 
What happened to the path separators in that command prompt? Are the slashes so fancy they're in a different encoding?
Awesome will look at those. Thanks for the helpful response!
Gophers are running on my screen. How nice.
revel includes router, i18n, async jobs, session/flash management, etc. oauth sorta depends on orm of course but a lot of this stuff is there ready to go and very well documented.
That article is from 2013. And a lot of it is outdated :)
For a statically compiled language, the JSON parsing is amazing (largely thanks to runtime reflection and struct tags).
&gt; In the Japanese-language locales of Microsoft operating systems, the yen sign in code page 932 character encoding has the same byte value as the backslash in ASCII. It is also used wherever a backslash is used, such as the directory separator character and the general escape character, essentially making it a backslash with the appearance of a yen sign, a peculiarity that stems from JIS X 0201. https://en.wikipedia.org/wiki/¥
Mostly paraphrasing whet the_jester mentioned: * Files in the same package (basically 'in the same folder') constitute **one** package. Go as a language attributes no meaning to source code files, only to packages. (Technically one may have kinda two packages in one folder, one for the actual package and one for the test, but this is uncommon). * if you come from Javaland: Yes, stop thinking "Object orientedly" as the Java version of object orientation is useless, painful and completely unnecessary in Go. With Go you can have sensible and usable designs, no need to force it into Java-style OO. * Things which are conceptually related belong into one package. If a package alone does not provide usable stuff (but requires other packages to be useful) than the package is too small. Take a look at the stdlibrary to get an idea. * No, there is absolutely no notion of inheritance. Never, never ever think of inheritance if you program in Go. Never. Not even if someone comes up with embedding to "model" inheritance or "do something alike". Don't. There isn't. You will get burnt if you do. So don't. Especially as there is no need for inheritance.
TIL Docker was written in Go
UI as User Interface - some thing the user does interact with. Or what do you mean?
ok :) I have put in a PR with the change. It only changes a single line in the existing test-set (which is an improvement), so I expect to merge it shortly. I added your file to the test-set, I hope that is ok.
then you open the go binary in a hex editor and find the db password with a ctrl + f
Sounds less likely you have an informed opinion on market needs and more like you have different needs.
&gt; Should I stop thinking "Object orientedly"? Is there any form of inheritance? No, you should not stop thinking "object orientedly"; however, you should completely forget about inheritance (in every programming language). Inheritance was a mistake from the start, and it requires all sorts of hokey hacks to make it solve problems that composition + interface polymorphism solve naturally (for example, late-bound `this`, `protected` members, and subtype polymorphism). Moreover, anywhere you use inheritance, you could easily use composition and interfaces. All of this applies in any language that supports interfaces and composition (like Java); however, Go supports composition and interface polymorphism by default, and if you omit the name of the inner object, the compiler will allow you to delegate to the inner class automatically: type HasMethod struct {} func (hm HasMethod) Do() { ... } type UsesMethod struct { HasMethod // anonymous struct member } // this is valid even though there is no explicit `Do()` declared on // `UsesMethod` UsesMethod{HasMethod{}}.Do() &gt; When should I split things up into different packages Split whenever you think you have something worth reusing. Different people have different ideas about what is worth reusing; I prefer more fine-grained packages to fewer large packages, for example.
I'm confused as to why they cared so much about the source code not being accessible. If they did their cryptography right having the source code wouldn't allow anyone to break the security.
Get your head fully wrapped around zero length channels. That's the key to unlocking the proper use of goroutines.
Adding onto this if you want to look at patterns for web development, take a look at https://github.com/ilgooz/stack which is great for starting off building a RESTful API in Go
I also was not a fan of rice requiring something on the host system. Not for something provided by the stdlib. I'll be tinkering with your implementation later on!
Quick method i used before is to have a global map[string][]byte to store the images, string is a hash of the uri for the file. With a sync.rwmutex. Now i use https://github.com/diegobernardes/ttlcache
This is just a tip that I noticed now that I've been using Go professionally and personally for a couple of years, but I never see anyone talk about the language in this way. In addition to being object oriented and fairly low level with great concurrency support, Go is also at heart a stream-processing language. You'll notice this if you spend enough time poking around the stdlib. Most functions that work on byte data are written from the standpoint of a stream implementation. So, while its perfectly fine to, say, have a method that's like "saveToFile", you might want to design your libraries in such a way that the saving mechanism is backed by a stream writer that simply takes a file as an io.Writer. This makes for a much more homogenous and efficient design, as these streams can be processed in chunks. This is important if you're working with a lot of data as you don't have to load it all into memory at once. Hope this helps with one little piece of the pie.
Use packages for code independent of your application (your 'package main' code that glues everything). For example I would include specific HTTP handlers in main. Use interfaces to say "this code can work with types implementing these behaviors or information." I think interfaces can implement a superset of inheritance: one piece of code can apply to many types. Those standard object oriented patterns may lead to trouble in Go. I'd just suggest keeping an open mind and make a bunch of stuff.
I kinda laughed at their pros and cons. &gt; Javascript - We don't need to learn something new and difficult. - Easier and faster for us to build it, because we have lots of experience with building JavaScript Applications. - We haven't built a production application yet, we only played around with it. Wha? You've learned Javascript but not yet build a production application? Kinda seems like these guys didn't completely know what they were doing! 
Minor note: if you have files a.go and b.go in package C, they can see each other's internals (lowercase named variables and struct members) but *not* each other's imports. Imports are local to a file. 
Quite happy about this! 
Blog post here: http://blog.docker.com/2015/12/containerd-daemon-to-control-runc/
Ofc. My question was around genuine interest rather than being sarcastic. Though it might sound like that. I apologise for that! 
So, is this kinda like the little porn/stripper animation thing that you could download for Windows a while back? (The one that would dance in the bottom corner of your screen and stuff.)
Yeah, they provided some really crappy excuses for how they chose their stack. _Any_ binary that's running on the client can be disassembled. I'd be more interested to hear how they can safely authenticate votes, rather than hear "C++ is hard so we used JavaScript". Yet another crappy "hey, we use Go!" post that doesn't really do the language any justice. :(
Site is completely unusable via mobile. Can't even scroll the page...
By corporate policy anything Google does is "the first X ever", and anything Apple does is "the best X ever". Both are lying.
https://tip.golang.org/doc/go1.6
named block in templates! and http/2 in core! it's just like christmas!
works great for my very basic needs. prior to that i used godep (which i was very unhappy with); was happy to be able ditch it.
That's a very good tip, thank you for sharing!
I know, a little too early to tell. But I'm entering the realm where compiling is starting to take longer. Any word yet on compilation being faster? Thanks Still don't mind tho, just &lt;3 Go too much! ʕ ϖ ʔ
&gt; triangle equality issues Could you explain what that means? Especially in the context of Godep and how it differs from Glide?
I'm aiming to target a different audience, but I do need to give K&amp;D a read to see how well I'm doing. Thanks to both of you, and I'm sure you'll be hearing more from me in about a month (Chapter 5).
&gt; You'll just end up drowning in type errors because those two packages can't interop. That's actually *kind of* a good thing, in a more general packaging sense. Unless those packages have a specific compatibility contract, or you know you're using the exact same version in both the "internal" and "external" copies of the package, then some of the hardest, most unexpected, hard to find and crazy bugs can come from mixing two different versions of a library together. Unexpected, because suddenly a bug can appear after you've simply updated your dependencies or cloned on another machine. None of your own code has changed a smidgen. Hard to find, because who knows where down the dependency chain the bug is coming from? Naively, you might start looking in your own code to start with. The actual collision of incompatible behaviour may indeed occur in your own code, or anywhere else in libraries making use of the problem one. But the cause of the problem is nowhere near the collision site, it's at the signature or behaviour of two different versions of a lower down library. Although everything can tend to turn out hunky-dory 99% of the time this happens, the other 1% can manifest some super nasty bugs. I'd usually regard a package manager not allowing two different versions of a library in the same codebase as a plus. However the problem here is Go's inflexibility of where the package can be located, which allows a developer to single-source the one version to their needs much more effectively.
&gt; need to specify "prefix:" on arbitrary tags. [encoding/xml claims to support namespaces](https://golang.org/pkg/encoding/xml/#pkg-overview), are they being defined in the document properly? &gt; need to have self closing tags Wait, encoding/xml doesn't handle self-closing tags? :/ &gt; need to not escape ' " tab and occasionally even **&lt; and &gt;** Then your third parties aren't producing valid xml, sigh.
I thought you were supposed to be able to vendor the standard library with the short paths. Maybe file a bug? 
On XML: &gt;need to specify "prefix:" on arbitrary tags. Isn't ``&lt;t xmlns="prefix"&gt;&lt;/t&gt;`` the same as ``&lt;prefix:t&gt;&lt;/prefix:t&gt;``? &gt;need to specify "prefix1" and "prefix2" on arbitrary attributes You can, playground: http://play.golang.org/p/HKvvcwF9mf. This also shows namespace on root element. &gt;need to have self closing tags (not just open,close tag pairs or omit the tags entirely). IIRC, ``&lt;t/&gt;`` is the same as ``&lt;t&gt;&lt;/t&gt;`` in XML. HTML on the other hand can be dumb about things like ``&lt;textarea&gt;&lt;/textarea&gt;``. &gt;need to not escape ' " tab and occasionally even &lt; and &gt; I can see how you would like to not escape quotes in text nodes, but I'm pretty sure that not escaping angle brackets outside of attribute values will produce invalid XML.
We're using https://github.com/tools/godep
Now make templates hint to being resolved at the compile time for generics!
&gt; compilation being faster? No work on the compiler speed has been done during the 1.6 development phase. It'll be as fast as the go1.5 compiler (i.e., about 2x slower than the go1.4 compiler).
The actual language vs. the compiler/standard library/tools/etc.
very glad to hear glide is helping you keep your hair! we/they spent considerable time discussing specifically this problem :) it's more conventionally referred to as the "dependency diamond" problem - http://www.well-typed.com/blog/2008/04/the-dreaded-diamond-dependency-problem/ so, triangle is basically right - just, missing one point! as folks have noted, this is an intrinsically unsolvable problem without input from the user to indicate an acceptable range of versions. this is why glide added support for semantic versioning - so that such version ranges could be specified, and used to figure out if an acceptable compromise can be made that satisfies both of the intermediate dependencies. of course, such compromises entail a second step: every main package is the entry point into a potentially unique set of resolutions, governed by answers to these sorts of diamond dependency issues. so glide has to compute the deps for each point of entry into the graph, and store them relative to that entry point. there's still a bit of hinkiness in how this works, i think, but it's a good step. i'm not sure how well godep handles the transitive dependencies question - i think OK, but it has no capacity for dealing with version ranges, so it can't actually make compromises when necessary. And, unless the authors of the intermediate deps are both diligent about pinning to the same version of the shared dep, it's pretty much always necessary.
Sadly, no. 
looks nice! so far for my very simple needs hand mgmt has been alright.
This blog post does a really good job explaining how groupcache works as a client/server. They also have a github repo example to play with. Groupcache is really cool but could be overkill depending on what exactly you are trying to accomplish. http://capotej.com/blog/2013/07/28/playing-with-groupcache/ 
We enabled auto-scaling on it and forgot to implement the health check handler, so the frontend load balancer was sending still-booting instances traffic. Fixed.
Hi Filippo, Russ's change to `go/build` is a big step, but I still have lots to do to make go/loader-based tools such as oracle and gorename work correctly with vendor directories. 
Hi Alan, thanks for answering. I didn't test gorename, but at least the basic functionality of the oracle seemed to work pretty smoothly. Did I just get lucky/use too simple tests?
This link should tell you everything you need to know: https://golang.org/doc/effective_go.html#methods 
To get the best answer, can you state what kind of applications you want to build and what language you are using at the moment? In general, concurrency is significantly less effort than most other languages. Go also an easy to learn language and it's safer than C. However, you'll get a better answer once the question above is answered. In programming, it's better to be explicit.
It would be nice to see the architecture for a large concurrent application (e.g. a game server). What in the standard library would be close?
If Go main feature is the easy of using multi-core, which gives a boost in performance, so what I am targeting is building process-intensive applications. I am thinking of importing some open-source GIS libraries from c# into Go, and if I can see a boost in the performance. Is it worth that big investment? 
You do not need a specific language to take advantage of multiple cores. Even the single-threaded Node.js language has a simple way to use multiple cores: Just run multiple copies of your program, and have a tiny program hand out web requests to the different cores. As long as the "work to be done" is much longer than the "work to hand out the work to be done", it can work. The "handout code" must be specially coded and worry about performance/memory/etc, but usually only needs to be written once. See [Embarrassingly Parallel](https://en.wikipedia.org/wiki/Embarrassingly_parallel) problems. On the other hand, if you are doing a lot of very short jobs, or if the jobs need to talk to each other a lot, the "work" to hand them out will quickly become a bottleneck. In this case, Go is the perfect language. It's a good compromise between performance and simplicity. Other languages like C or Java can give performance, but debugging multi-threaded problems is a nightmare. This is a Go forum, so obviously, we're going to recommend Go. Personally, I liked the idea of Node.js, but it's "callback style" really turned me off -- you have to constantly jump around the page to follow the execution of the code, even in the simplest of examples.
IMHO The go website has great examples on using concurrency / go routines without having to dedicating too much time into the language. 
Would *love* to see Gopy updated to support modern python. Looks awesome if you're trying to support a legacy Python app and need to inject some sanity.
[Here are some open-source GIS libraries in Go](https://github.com/golang/go/wiki/Projects#gis).
yep. and the biggest python dependency (pyroot) is still stuck at py2. LHC sw stack won't take the risk of switching to py3 during data taking. next shutdown is 2018. here are the constraints from CERN :) that said, I do plan to support py3 if only because LSST (a telescope being built in Chile) has plans to eventually move to py3 (and I am also working for these guys) the issues tracking py3 (and other python vms) support: - https://github.com/go-python/gopy/issues/48 - https://github.com/go-python/gopy/issues/12 
wow thanks
I agree - if you're working on a traditional "web app", then your bottleneck is likely to be elsewhere. I work on a high-traffic server that does not use db or templates, though. I originally used `gorilla/context`but based on the amount of reqs/sec we do, it just wasn't worth it for ease of use. We actually thread a `net/context` object through the request with our own handlers so that we don't need to maintain a mutex on them. The server doesn't actually need any anti-csrf functionality, I just thought I would mention it. Thanks for the `goji/csrf` link, btw! 
I don't see this as "highly available". Highly available to me would be a redundant deployment of a service behind some sort of load distribution system with health checks and a couple 9's of uptime. What you have here would more appropriately be called a supervisor or watchdog. Also, the design is strange. For example, what's with the wait and max functions returning functions that take a config? And then passing those to the watch function? Why go through these contortions? Just let the user create the config and pass it to the Watch function. If I were to bother formalizing this, I'd rather see something like the following. This is more discoverable (better auto-complete), more understandable on a quick glance, and simpler yet just as flexible: watchdog := &amp;WatchDog{ MaxRestart: 5, RestartDelay: 1*time.Second, Callback: func(ctx context.Context) error { var i *int *i = 100 return nil }, OnError: func(err err) { log.Println("callback failed:", err) } } ctx, cancel := context.WithCancel(context.Background()) watchdog.Run(ctx)
I believe there will be a post about `glow` in the gopheracademy advent-2015
yes, you miss two words: java and scala
For structure/map comparison, reflect.DeepEqual might be useful for you.
It's already pretty fast. With that, I don't think that should be the focus of new releases unless it becomes a problem or there is large demand for it.
[Version 0.8.0 added lockfile support] (https://github.com/Masterminds/glide/blob/master/CHANGELOG.md) 
Looks decent, still fails on printing big structs with branchy structure: no indentation.
Well, it won't. It just tells whether structs equal or not. What you really wanna know for tests is what's the actual difference between the compared objects.
func is executed immediately. Nothing particularly to note. defer func executes the function after everything else in the function it is called in finishes, directly before it returns. If you put the deferred call above the regular call, it would still print last. go func executes the function in a separate goroutine. It's likely that the reason you are not seeing it print anything is that the program is finishing and exiting prior to the print command from that call being executed. If you want to guarantee that goroutines finish, you should look up WaitGroups in the sync package.
`defer` gets ran once the surrounding function ends. `go ...` creates a go routine (like a new thread but not a thread, a better thing) to complete the function. What I suspect is happening is once `go func` is called, `main()` returns and the `defer func` gets called and the application exits before the go routine has finished. Try add `time.Sleep(3 * time.Second)` to make the program wait before exiting.
Noob question on my phone right now, if you have multiple defers, what order do they get called in at the end? Either queue or stack, id imagine
Your config name is better. I'll update code.
The best unit tests are so self-contained that they don't touch outside stuff, only their own RAM. Since you are doing filesystem operations, your first step should be to switch to Afero for your FS ops. https://blog.gopheracademy.com/advent-2015/afero-a-universal-filesystem-library/ 
What is changing in Go 1.7?
Should have used `ctypes`.
Nice.
&gt; I know its true for c to give more performance than go Statements like that are a bit misleading. There are many forces at work, and it's impossible to tease them all apart. But understanding them is the key to understanding performance. So let me try and explain: 1) **It's true that Go's compiler is fairly weak compared to very mature C compilers.** So on average, Go code will be slower than C code. (This is improving dramatically over time). Go's garbage collection also takes CPU time. So first pass, Go will be slower than C for the "same" code. 2) But all is not lost: **For any program of sufficient complexity, a well-optimized program in a slow language will be much faster than the "first pass" of a program in a faster language.** Programmers assume they know how to "make things faster". But [speeding up random parts of your program won't make it faster](https://en.wikipedia.org/wiki/Amdahl%27s_law), which is why you hear "optimization is the root of all evil". Only speed-ups in at the actual bottleneck tend to matter. In other words, better compilers can give you 2-5x performance, but changing your algorithm in one spot often gives you 10x-100x performance. Any experienced programmer can tell you war stories about this effect: Pulling some calculation out of a loop, unrolling a loop, memoization, caching, applying the [Schwartzian transform](https://en.wikipedia.org/wiki/Schwartzian_transform), etc. So the question is: Is Go a simpler language that leads to less time wasted debugging problems? (especially in a multi-threaded situation)? Does Go have better performance analysis tools to help you find the bottlenecks? If Go is faster to get working, can you take the time saved and apply it to optimizations? Would that optimized Go codebase perform better than an un-optimized C codebase? Would writing in Go make the programmer happy, and therefore not quit after the current project, thus saving money on maintenance next year? These are messy questions with no scientific way to answer them. There is also the [Sapir–Whorf hypothesis](https://en.wikipedia.org/wiki/Linguistic_relativity) applied to computer languages: Let's say you want to write the word count program. If you start with Go, you will use a Hash because that's the "natural" data structure. If you start with C, you will likely start with an array, because a using a more complex data structure for performance is a lot more work. On a large data set, the better data structure will make the Go program faster to run. (Heck, the same argument applied to Perl, back in the day -- For some tasks, it would have taken weeks to write a C program that ran faster than a Perl program written in a day.) So some language features might accidentally lead you to better algorithms. And we know better algorithms are worth more than a "slightly more optimized" compiler. &gt; is it true for java? Yes, just like my Go example, there can be situations where Java accidentally leads you to a better algorithm, or gives you more time to do performance analysis when compared to C. For example, I pulled up a random [C vs Java](https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=gcc&amp;lang2=java) page on Debian's benchmarkgame. Sure enough, the last benchmark shows Java to be slightly faster. (And Java has a start-up time handicap, so it looks a lot worse on small data sets than large data sets.)
FYI, as an added bonus, if you change the exe filename to gopher.scr and drop it in Windows\SysWOW64 you can set it as a screensaver. When you initially set it, you will need to kill the processes it starts, and then when it starts you need to Ctrl-Alt-Del to kill it, but it works :-)
Great article. The fact this switch was driven from the bottom is quite inspiring. Translated into russian: http://habrahabr.ru/post/273535/
But Scala-&gt;Go is not so common.
I would be interested to know why go was chosen over Java in this case. I would have thought that java was a more obvious choice where they company is already using a JVM language.
&gt; no WTFPL
I started to touch on this [here](https://www.reddit.com/r/golang/comments/3xje9s/moving_a_team_from_scala_to_golang/cy5upni), but at the end of the day, moving from Scala to Java is going to feel like a step backwards. I can't imagine any Scala dev willingly moving back to Java. Besides that, Go brings a lot of new things to the table besides making it harder to write unmaintainable code: clean syntax for lightweight concurrency with typed message passing, single binary deployment, implicit interfaces, and most importantly IMO, the first language that actually makes composition over inheritance possible without needing to write tons of boilerplate. It doesn't even have the option of classical inheritance, so you'll never waste cycles trying to figure out if something "is a" thing and should inherit from a superclass or not. Java doesn't have any of those benefits.
At first I thought this was a machine learning project to generate *new* licenses. It seems to be a tool to assist in copy/pasting the text of an original license. The one I always use - WTFPL - is missing.
Sure, but I wouldn't really say that the amount of "extra" in java is all that hard to understand. Even the most complex generics in java aren't all that hard to understand (you aren't defining your own types of operators). The things that he complained about in scala are things that Java doesn't really have. It may be more crufty than go, but I would have thought a shop looking for a simpler language that is already using a JVM language would go to Java instead of Go. It has pretty much the same benefits listed as Go does (more developers, easier to train up developers, simpler language) plus the added bonus that you can get it to work with existing Scala libraries that you've cooked up. Not that go is a bad choice for a language, but rather I would think Java would be a good choice for a shop that is already using the JVM.
How would go fix the bug you encountered?
Was a little bored and thought I'd put together a little memory game. Thought I'd share :)
Simply by allowing us to bypass the other project. It's not the most practical idea ever, but it sure is fun entertaining it! There are plenty of other reasons that a rewrite in Go would be appealing. It's very unlikely to happen anytime soon though.
I'm really hoping teamtreehouse will be doing some go videos, they are top notch. Will take a look at this Lynda one. 
&gt; you can use those already written scala libraries in Java. The other way is not too hard, but using scala libs in java is not *quite* as easy. Easier than in go, for sure.
you can still use it to check if you need to iterate more or not... reflect also provides everything to do that :)
see also https://github.com/tcnksm/license
I hadn't heard of them before. That was a good read. Thanks.
Yeah, that works. I guess that still feels repetitive to me coming from dynamic languages since I'll end up making a fetchXXX method for every new type. I'd just have a single generic fetch method in ruby, or in a language with generics. 
The [go/doc](https://godoc.org/go/doc) package parses [annotations](https://godoc.org/go/doc#Note) to [Package.Notes](https://godoc.org/go/doc#Package.Notes). Use the [godoc -notes flag](https://godoc.org/golang.org/x/tools/cmd/godoc) to display the annotations in godoc.
Having done concurrency in both Java and Go, as far as I am concerned there is no contest: Go makes it much much easier. You can say whatever else you like about Go and you might be able to convince me that it needs subclasses, or generics or whatever, but I ain't budging on the concurrency aspect for any non-trivial concurrent problem.
I find your rudimentary version to be elegant. I like to keep scripts in the src directory that contain things like this.
This is excellent! I would love to have an editor plugin that could do this live.
1. The return type indicates that there is at least one code path where an error would be returned. I would expect them both to return if `GetAll` failed, but neither do. 2. Use an interface to provide `GetRawContent() []byte` and `SetSafeContent(string)` just like in /u/skidooer 's answer. Note, he updated the method name to use a setter method instead of just `SafeContent` -- which only works if you own the definition in your app for `Post` and `Page`. 3. Add at least a comment explaining what Bluemonday UCG Policies are -- because obscure acronyms from third party libs suck most of the time, or refer to the Bluemonday comment in the `policy.go` source [here](https://github.com/microcosm-cc/bluemonday/blob/1f0bc57c5484fb9207c08d5ed7475feaea9e3002/policy.go#L38). In addition, you might add a `SECURITY.md` file to your project outlining how using Bluemonday (and potentially other security-minded libraries) will ensure the safety and security of the application.
Also https://github.com/google/todo-tracks
I started writing one a long time ago, a bit after the transition was complete. I never finished it. I'm actually working on converting another one of our internal services to Go, however. I expect that this time around it will be a lot less like a 'translation' and more like a 'write this the right way, in a different language'. I will likely complete the post with a reflection for each service. Hopefully, that will be complete in by the end of January, and I will give it my best effort to finish the post and link it here on reddit.
what's wrong with apt/yum/etc?
You can very easily take control of an externally defined type by embedding it into a locally defined type and overriding/adding the desired methods. 
Is there any point in caching the SafeContent right here ? type content string func (ctnt content) Safe() template.HTML { parsed_content := blackfriday.MarkdownCommon([]byte(ctnt)) html := bluemonday.UGCPolicy().SanitizeBytes(parsed_content) return template.HTML(html) } type Post struct { ID int Content content } type Page struct { ID int Content content } // post.Content.Safe() // page.Content.Safe() You would have to check how this interacts with datastore. 
Nothing :) I just mean that it would be rad cool to be able to hack on this kind of stuff in Go :).
Yes, why didn’t you check the list of Apache projects by language? https://projects.apache.org/projects.html?language
You could do something similar to the sort package. Here's a sample: http://play.golang.org/p/dNsxw7KasV
Probably unsafe (because you don't seem to know why it works). It works because you're extending the slice to *capacity* of the slice (the length of underlying array), which in this case happens to have space. https://golang.org/ref/spec#Slice_expressions relevant bit (but try to read and understand *all* of it): &gt; For arrays or strings, the indices are in range if 0 &lt;= low &lt;= high &lt;= len(a), otherwise they are out of range. For slices, the upper index bound is the slice capacity cap(a) rather than the length
I don't know if the programming style is sound. But this works because slices are only wrappers to arrays. Slices have length and capacity which means an array of 10 elements (capacity) might look to a slice as having 5 elements (length). Program:- http://ideone.com/BfA7ft Output:- [1 2 3 4 5] 5 5 Now [1 2 3 4] 4 5 Now [1 2 3 4 5] 5 5
Good one. The Video tag isn't loading for me btw. 
There are 3 projects with Go: * Apache Etch * Apache Lucy * Apache Thrift
[removed]
As of 0.8.0, the glide.yaml file only needs to know your projects dependencies. "glide update" will walk the complete dependency tree, get/install packages, and figure out versions. That includes dependencies of dependencies to all depths. The complete tree is stores in a glide.lock file. For example, in a glide.yaml file you might fetch k8s.io/kubernetes. The glide.lock file would contain more than 100 dependencies for the complete kubernetes tree. "glide install" doesn't walk the tree. Instead it uses the glide.lock file to know what to fetch and version to set. By going it this way "glide install" can be much faster and everyone can install the locked versions. The glide.lock file should only be updated by glide itself.
[removed]
If you have a build script or makefile or something, you could use `go build -i` to install the dependencies as well, which speeds up all the following builds as well. Useful if you're using e.g. Godep.
The idea is mostly to work towards making these things possible :) I think it's good to have a dream to work towards to :).
Besides, you do the same thing over and over again because you don't use the `i` in your loop. Use a for-range clause: v := []int{1,2,3,4,5,6} for i := range v[:len(v)-1] { v[i], v[i+1] = v[i+1], v[i] } What do you want to do? Bubble sort?
That link is a 502 for me.
I've been doing it in the console. If there's a built in way then I'd love to hear about it too
For example: https://golang.org/src/bytes/buffer.go?s=4333:4465#L119 A race condition surrounding this and similar methods seems like it would be prone to eventual failure. I edited this because my original answer would likely have come across far more snarky than I intended. I'm sorry if any offense was taken.
Etch is written in Java and Lucy is written in C. Thrift is more of a "cross-language" project.
[io.Writer](http://godoc.org/io#Writer) doesn't document that the method needs to be safe for concurrent use, so you can't assume that it is. Both a writer that is concurrency-safe and one that isn't fulfills the interface. An \*os.File, to the best of my knowledge, should be concurrency safe (you probably will get weird results of interleaved writes if you try, but your program won't *crash*). A \*bytes.Buffer probably isn't. So if you don't know that an io.Writer you get is concurrency-safe, don't use it concurrently without locking.
Thanks all. I think based on the feedback the best path forward is to use shared stdout, stderr streams for multiple instances of my logging handler, but inside the handler use instance-level buffers to create the logged output before writing it to the underlying target. This will ensure things are ordered as well as still be safe for concurrent use since the Writer returned by logrus is safe for concurrent use. In my previous implementation of things it didn't matter as there was a single logging handler, but I switched things to using a different mux per route and thus I ended up needing multiple logging handlers in order to chain the middleware per mux.
Feel free to ask if you run into issues. I really want to see Hydra used in the real world. I am super excited to fix all the issues you find and help you solve this difficult topic in the blink of an eye. You should not use Hydra in production yet, but if you need its capabilities now, you can definitely use it and rely on using it for the next years to come. We have a strong commitment to support Hydra as we're using it in all the awesome applications we write for our customers. Hydra is being used for example at https://de.serlo.org, one of the world largest OER (Open Educational Resources) Plattforms with over half a million page views every month!
Sorry about that, this can be pretty confusing. The martian.proxy host is only available when configuring **through** the proxy. So you need to set wget to use the proxy and then send requests to martian.proxy/configure. I'll work on making this less confusing this week.
It's a good overview, though some of the statements are a bit misleading, such as "Since cancel nodes don’t have any information stored within them and are used for their Done() channel alone, they should only be an internal node in the tree." Also, modelling processes as FSMs is useful in languages that don't have something like goroutines, but is not as applicable to Go where the callstack and separate goroutines are often a better modelling structure.
By the way, the source currently looks like this https://github.com/akutz/libstorage/blob/feature/dadd/api/server/handlers/handlers_logging.go. You can see what I'm doing in the file.
https://github.com/ccirello/goherokuname for a more complete wordlist. essentially the same.
The loop was there, as I was testing it the GC reacted. But I see that it doesnt touch it for obvious reasons now.
Sorry about that. At the time, I was giving the GC time to react. I know now that is nonsense.
[**@\_holographer\_**](https://twitter.com/_holographer_/) &gt; [2015-12-19 19:10 UTC](https://twitter.com/_holographer_/status/678291256322220032) &gt; Powered by @nats\_io : Integration Patterns for \#Microservices Architectures, by @DavWilliams https://www.youtube.com/watch?v=f5gZdK8ir4M \#natsio ---- [**@\_holographer\_**](https://twitter.com/_holographer_/) &gt; [2015-12-19 00:21 UTC](https://twitter.com/_holographer_/status/678007334019448832) &gt; Don't. \#natsio \#microservice \#integration \#patterns \#antipatterns http://www.slideshare.net/Apcera/integration-patterns-and-antipatterns-for-microservices-architectures &gt;[[Attached pic]](http://pbs.twimg.com/media/CWjEE7MXIAIoR2m.jpg) [[Imgur rehost]](http://i.imgur.com/TymoVPg.jpg) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
I'd imagine it gets added to idle pool if it is not full and closed otherwise. Note that reusing idle one might be fast enough that dialed one wont finish dns resolve, even if cached
lol they lie about competition(zeromq footprint) then dont show one that is faster than them on comparision ( again, zeromq )
You might actually be interesting in something like: https://gopkg.in/fsnotify.v1
I was thinking along those lines, reading every time stdout had bytes but I was a bit lost on how I'd achieve that. Most examples I've found were reading only once.
A very simple way to tail a file is: buf := make([]byte, 1024) for { n, err := f.Read(buf) if n &gt; 0 { // do something with buf[:n] } if err == io.EOF { time.Sleep(time.Second) } else if err != nil { // handle error break } } Adjust the sleep time up or down to taste. 
And that is, at the core, what "tail -f" does so you may want to just roll your own all in Go instead of trying to "tail the tail"
This feels like a classic [XY problem](http://xyproblem.info).
I do this, and also use build arguments when building the docker container. e.g. `docker build --build-arg GH_API_TOKEN=insertgithubtokenhere`. You can generate a one-off token for the purposes of building using the [Github "Authorizations" API endpoint](https://developer.github.com/v3/oauth_authorizations/#create-a-new-authorization). The API can also be used to delete the token after use.
Here is a language agnostic solution: http://beyondgrep.com/ I've found ack extremely useful and simple to learn. 
Interesting. Maybe good documentation will make QOR awesome.
like 90% of Github projects unfortunately.. weird that almost every developer assumes that everyone has the same expertise in that specific project.
Awesome, thank you!
There are many cases it doesn't cover for now, like nested funcs or variable definitions that are not func parameters. I tried to keep it simple and cover the most useful case with no false positives. If you spot any false positives (or false negatives), let me know :)
A little OT, but my first thought was that you porteded [surf][surf] to Go. [surf]: https://en.wikipedia.org/wiki/Surf_(web_browser)
This could be incredibly useful if it actually works as described, good work OP.
Finding out that the design is fundamentally flawed would be the stuff of nightmares. 
How would this work without type hierarchy if you can select the type? It wouldn't be very effective. If you add type hierarchy then you bring back some of the "hidden baggage" stuff the language tries to avoid. Things would spiral and you'd no longer have the feeling of a type costing exactly what'd you'd expect it to cost. Why can't we just come to the conclusion that the language was meant to be improved C where everything is DIY (boilerplate)? Why can't those that want to learn to navigate those water and know how to reduce the boilerplate and code copying do so and those that really need generics use a language that's more suited to them? Why doesn't this crowd throw support behind something like Nim which I'd love to see grow instead of trying to change Go into something its community doesn't seem to want or need?
Hi @HighlyPositive The project is still at the early stage, although it is used for production internal already, API is still keep changing. We are going to launch the first stable version in the following months, maybe when go 1.6 launch, will have more documents then, sorry for the trouble.
This looks really nice. I always find myself not fully taking advantages of interfaces; this will surely find its way in my primary Makefile build workflow and help me remember stuff like the example mentioned in the README (``io.Reader`` instead of ``os.File``). =)
gvt here. It is basically gb + GO15VENDOREXPERIMENT. Super simple to use
This is a pretty good approach. I may end up using this. Thanks
Are there any reasons for wgo and gb being omitted? If not, their addition to the article would be appreciated.
As one of the authors of [Glide](https://github.com/Masterminds/glide), we're always open to feedback. Our goal is to make a package manager for all the major use cases that's as easy to use as those for other languages. If there are any issues or you have any feedback please feel free to let us know.
You need to create a third container that acts as the "base" of both of your service containers. e.g. common.Dockerfile: FROM whatever RUN go get databaselibrary service1.dockerfile: FROM common RUN go build service1 service2.dockerfile: FROM common RUN go build service2 Alternatively, you could just ensure the first few statements in service1.dockerfile and servic2.dockerfile are *exactly* the same and docker will cache and share the common layers between both images.
The benefit of go generate is, that you put the commands to be run into your source-code and people just have to run go generate and it goes out and finds all those commands to run and runs them (by the way, have you ever tried writing a portable shell-script? What a nightmare). It is the go way of "we don't want meta-stuff in our repo".
He said "database library", not database. Your solution is overcomplicating a very simple problem.
Look here: https://gobyexample.com/methods
I'd really like to avoid turning a library into a service just to accommodate Docker. It seems like it should be easy to build two containers with a shared dependency library. Maybe it's possible to put multiple dockerfiles (one per service) at the repo root so they can both use the shared library? 
You have to prefix Score and Name with 's.' because Score &amp; Name are fields of s (type Scoreboard). Like here: http://play.golang.org/p/YagF7ocuxR
go generate doesn't do any dependency checking, compiling, or branching (as far as I can tell). Unless I'm missing something, writing a portable shell script of that complexity would just involve putting the commands on consecutive lines, and putting a hashbang at the start.
Looks great! One thing that would be nice is having the source code somewhere to refer too. 
This is a great theory, but it's totally unrealistic in my experience. Any project of significant size either becomes polyglot (thus requiring non-language-specific tools) or accumulates build-related flags (thus requiring a layer above go build) or generates enough code that it becomes a nightmare to constantly rebase and merge against. Of all the things I grump about with Go, it's the intrusion into workflow that annoys me the most. The language should not dictate the tools. We already have a nearly universal interface to building projects - it is called "make". Go should have just emitted makefile snippet.
Thank you wonderful people of reddit!! Another question, whats the differnce between func (s scoreboard) addingScore() (string, int) { blah blah } vs func (s *scoreboard) addingScore() (string, int) { blah blah }
Thank you!
I feel like it's worth mentioning here that **go generate** is more geared towards the developers/maintainers of a package. Unless it's your code, and you specifically know you need to call it, **go generate** isn't something you should need to run.
https://golang.org/pkg/bufio/#example_Scanner_lines
The first is a value (pass by value) and the second is a pointer (pass by reference).
Your answer is not wrong but I think your wording is dangerous. There is no OOP in Go, you can apply certain concepts of OOP programming to Go but it's not supported by the language. The inheritance you speak of is not inheritance, it's embedding and has caveats that are not included with true inheritance. Saying they're the same is miseducation. Embedding more closely resembles Composition than Inheritance. It might be beneficial to keep this in mind in future. Also structs are not classes and strict methods are nothing more than syntactic sugar for more readable code segments. If you define a type Animal as such: type Animal struct { LegCount int } And then a type you want to "subtype" with animal called Cat: type Cat struct { Animal Lives int } You get exactly what you give. You have a type `Animal` with a single field, and you have a type `Cat` with two fields. You don't have a subclass of `Animal`. You have a `Cat` that _has an_ `Animal` as part of it's structure. The act of embedding (field with no defined name) gives you some sugar that allows you to call "methods" from the type it's embedded in. So in this example (as was previously shown) you can call your `LegCount` value in two ways: `myCat.LegCount` or `myCat.Animal.LegCount`. You could not, however, pass your `Cat` into a method as an `Animal`. This works in OOP languages but not in Go: func (a Animal) GetNoise() string { return "" } func (c Cat) GetNoise() string { return "meow" } func PrintAnimalSound(a Animal) { fmt.Println(a.GetNoise()) } You can't call `PrintAnimalSound` with `myCat`, you have to pass in `myCat.Animal` which in turn prints nothing. As it's calling the method on `Animal`, not `Cat`. This is not inheritance. (http://play.golang.org/p/4F0uZzJ5CV) Instead, in Go, the way you would achieve this type of functionality is through the use of interfaces. If you defined Animal as an interface instead: type Animal interface { LegCount() int GetNoise() string } Then you can define a `Cat` like: type Cat struct { Lives int } func (c Cat) LegCount() int { return 4 } func (c Cat) GetNoise() string { return "meow" } And you could define a `Dog` type Dog struct {} func (d Dog) LegCount() { return 4 } func (d Dog) GetNoise() { return "bark" } And suddenly our `PrintAnimalSound` works. In Go, interfaces are implicitly matched, so we never actually say that `Cat` implements `Animal` or that `Dog` does. We just define the methods `Animal` suggests and our type can be used as that interface. In this case, any type that defines a `LegCount() int` and `GetNoise() string` functions are considered an `Animal`. (http://play.golang.org/p/weKptwZpU4) Long story short, in Go there is no inheritance - there is embedding. Embedding is a _has a_ type relationship, not an _is a_ type relationship. Using interfaces, and embedding you can emulate some common OO principles but not exactly and not as you're used to. **edit** Spelling, and details
Thanks, it looks like a very nice linter! Have you seen /u/campoy talk Program Analysis? If not, I invite you to. [At the end of the talk](https://www.youtube.com/watch?v=oorX84tBMqo&amp;feature=youtu.be&amp;list=PLDWZ5uzn69ezRJYeWxYNRMYebvf8DerHd&amp;t=2649) he mentions a very similar tool he built. And he speaks about an issue with the first version of his tool: it tells him to use simpler interfaces in functions like ServeHTTP, i.e. to use ServeHTTP(w io.Writer, r *Request) instead of ServeHTTP(w ResponseWriter, r *Request). Does your tool avoid these kinds of false positives?
Oh, wow. His approach is very similar to mine. The algorithm slide is actually a simplification of what I am doing. As you say, this simple algorithm has many false positives. See for example [this test case](https://github.com/mvdan/interfacer/blob/master/testdata/files/implement.go), which tests for false positives related to implementing interfaces or func types. My algorithm, aside from keeping track of usage and receiver calls, also keeps track of interface and func types. It uses those to discard function definitions that satisfy any of them. As to /u/campoy's narrower, I would have probably found it before writing mine if he had published it somewhere. I googled and searched on github for a program like mine before writing one from scratch, but found nothing. If he indeed did write a package similar to mine, I'll welcome suggestions and criticism if his is better than mine in any way :) Edit: At the end of the video he says he uses oracle to avoid the false positive case that you mention. My method is simpler, as it only uses go/types, and I also think it's more robust. It works at the func level, not at the type (struct) level.
Make is horrifying. Should Go have a preprocessor as well? (edit: in fairness, I don't really see the point of "go generate" either...)
You don't have to manually write Makefile to use make. As an API to users, make is beautiful and simple
This needs to happen
In what way are Page and Post different? In the gist, they look and behave identical. Can they be merged into a single type? This would give you instant code deduplication. 
At work I'm using go-bintool. It works great.
Can't agree with you there. RethinkDB is an amazing database. It's also not a proprietary, non-free cloud platform.
I liked these composable pipelines a lot. but the one issue I have with the SciPipe library design is that it couples one processor to the other at "assembly" time. using a whiteboard/blackboard approach (where processors are only coupled to that component) would be more composable, I believe. That's what I did for my concurrent processing framework: - https://github.com/go-hep/fwk - http://talks.godoc.org/github.com/go-hep/talks/2014/20141022-binet-go-fwk-conc/go-fwk.slide#27 
So far I've only developed and tested on 1.5.2. Could you open an issue? Before you do, make sure you've got the latest version of x/tools, which is where go/loader comes from.
Check out "Go execution modes" in https://github.com/golang/go/wiki/DesignDocuments to see a proposal for them. I'm not aware that they're implemented atm.
I thought it was part of 1.5 release, wasn't it?
wgo and gb is not listed under this wiki: https://github.com/golang/go/wiki/PackageManagementTools#go15vendorexperiment Therefore, they were not added to article.
Thanks! Nice, quick, and succinct. :-) I'm relatively new to Go, and still figuring out what tools best suit my needs. Since I just started test driving the new 1.5 vendoring experiment, I was looking for something to handle dependencies like this. So far, it seems to fit the bill quite nicely. I have been using wgo, and it's worked well. That said, with the new vendoring approach having per-project vendor directories, and glide managing those, I don't think I need wgo anymore.
If you ever have to use Debian-based systems, you would probably like and you could maybe contribute to https://github.com/lapingvino/jogurto
Your answer is wrong *and* your wording is dangerous. Sorry, I had to do that. The object oriented programming paradigm does not require inheritance. The only thing required for the lange to support OOP is objects, which can be arbitrary data, and methods, which can be arbitrary routines or functions. Even C and assembly can be used as a full OOP environment, as OOP does not require that syntactic sugar ties methods to objects. A function taking a structure as first argument is therefore enough to have a "method" on an "object", and it is in fact the way many languages implement OO. Inheritance is not a defining feature or requirement of OOP, and interfaces is often considered a superior form of polymorphism ("implements over extends"). Saying Go does not support OOP on that remark is like saying C++ does not support OOP because it does not have interfaces, but you can "emulate it". TLDR; Go supports objects, methods and polymorphism (through interfaces), all with syntactic sugar and compiler support, and is fully OO by any definition of the term. Inheritance is not a defining aspect of the OO paradigm, and writing OO code in Go is natural.
Great idea. Wanted to look for something like this. Small details: the passw needs 6 chars and i like it if that is shown right away and not as a warning after submit. Also, after the warning (on mobile, iphone) i cannot scroll anymore to the submit button.
They have different fields in their struct. For example, page has a title, post doesn't. 
So, the answer is not right now (maybe in the future). However, multiprocess RPC doesn't have to be hard or ugly (and it's not even all that slow): Plugins in Go are as easy as Pie: https://npf.io/2015/05/pie/
Some build modes have been implemented, notably not buildmode=plugin, unfortunately.
Yes, the HTTP server runs each handler function in its own goroutine. This means you must not access global (or otherwise shared) variables from a handler without holding a mutex lock. The answer to your question depends on what your server does. A stateless server like a static content server can construct the response from the request (and read-only resources) entirely in the handler goroutine. A mostly stateless server may need to acquire a lock for a brief while to inspect or update a shared variable, or send a message to another goroutine and wait for a response. A highly stateful server like a database will have an elaborate locking or communication scheme.
Why do you think that worker and request queues will improve the throughput of the server? To me that sounds inherently slower (because you add another layer of scheduling on top of the one that the runtime already does with goroutines). The answers are, imho: Yes, every requests runs in it's own goroutine. No, you shouldn't implement a worker or request queue. Goroutines aren't threads for a reason. You shouldn't apply the patterns from thread-based programming to go, you should just use go's native concurrency model, it makes things a lot simpler.
You are wrong too, because you are talking about subtyping and not about inheritance.
Do you mind providing sources backing up all of your claims?
Well this has the whole separate process rpc problem where I can't guarantee the plugin will exit if the main app crashes, as well as having to write a bunch of boiler plate code doing func Hi(a int) { client.Call("Hi", a) }
The problem with this is that it doesn't help the ecosystem, where by anyone can just start using anyone's plugin. You'd have to know how to build the project just to be able to use a plugin, which is a high entry bar for a novice.
Adding a goroutine to your handler won't magically make your code run faster. In fact it will probably make it run slower. There is probably some other bottleneck you can try to fix. On a related note, do you really need to be worrying about any bottlenecks right now? Can you honestly say that you're going to get so much traffic that you need to be optimizing right now?
What if there were some kind of middle ground option between compiling external source into your main app, and running each plugin as a process via pie? What if there were something like a plugin manager which is the only external process that starts and communicates with your main app over RPC. This plugin manager could compile discovered plugins at startup (or be triggered to restart/recompile during runtime). It could then host all the plugins in one external process, and delegate for the main app. And you only have one extra process at this point, which can "dynamically" load plugins. Any value in this alternative? 
Inheritance creates a subtype. If Cat extends Animal then Cat _is an_ Animal. This relationship is such that from then on a Cat can be used anywhere an Animal can - which is, at it's core, what subtyping is about.
I've been writing games with Go as the logic server and an internet browser for the user interface. Websockets give you bidirectional asynchronous communication instead of just the request-response of HTTP. This keeps the graphics engine out of Go. Web technology is the best proven use of Go today (Google spends to develop, deploy, and keep Go open source). So it depends on what you are trying to learn about or do with the language. I'm just saying I think you'd learn more about Go by writing networking stuff, as a spare timer.
I don't do much game programming but I remembered seeing this link in the Go weekly newsletter. https://gitlab.com/xojoc/engine
How the GO15VENDOREXPERIMENT will help to standardize theses tools if we need to have one tools for a project and an other one for a dependency of the project ? 
Would you mind talking a bit about your stack? Are you using gorilla websocket? What do you use for the frontend? Html5 canvas? Very interested in this!
Are you jealous because you can't make a shooter game?
My pie package avoids the non-exiting plugin problem by making the plugin run as a subprocess, with communication over stdin and stdout. Yes, you need to write the wrapper around the API, but that's really minor, and likely something like that would be required in most architectures in a statically typed language.
Ok, I understand all that. My concern is line 23: `f := Thing{x:3};` Why not `f := &amp;Thing{x:3};` instead?
Sorry; wrong thread. I'd like to blame the mobile UI, but I think it was plain and simple user error. Was looking at the snake game repo. 
Go is a bit frustrating haha. Before i go into deleting the "top card" in the deck i think i have several problems. http://pastebin.com/NBnNZ5av The first is i modified the code to test whether or not the code in terms of the deck is doing what i want. I get two errors: ./Blackjack.go:72: syntax error: unexpected ) ./Blackjack.go:77: syntax error: unexpected } Second of all, is this the right approach? I feel like with the way i created the deck it was faulty. Any advice on the approach?
https://golang.org/ref/spec#Calls: &gt; If x is addressable and &amp;x's method set contains m, x.m() is shorthand for (&amp;x).m():
Passing references around instead of copying values should be seen as a performance/memory optimization. Mutating variables is source of many bugs and is never formally required. So it makes sense to pass everything by value and copy everything, you don't take the address of anything and you save yourself some pain; the computer won't mind doing the tedious job of copying. Once the code is correct, one may think about saving cpu and ram if needed.
Yes, I'll write that mod shortly. Thank you. Also, I have vim running gofmt automatically. I ran it from the terminal &amp; nothing changed. (Not sure if that's an error on my part or if gofmt didn't modify it.) Regardless, I figured out what you were referencing and fixed it. 
type conversion (since MyFloat is defined to be a float64): f := MyFloat(-math.Sqrt2) In the above, "f" can be used anywhere that a MyFloat is expected, but must be converted back to a float64 wherever float64 is expected. v := &amp;Vertex{3, 4} As others have stated, pointers to structs are most useful when you know you will need to pass a reference to the struct to some function. By default, the struct will be passed by value (ie, a copy of the struct) which is both less efficient and potentially broken if the function is expected to modify the struct such that the calling function can see the changes. 
I've had good luck with gorilla/websocket (https://github.com/gorilla/websocket) so far. Just set a route to a websocket upgrade request, then do your custom logic that wires the socket to your server. Here's some working Go code from my game: http://pastebin.com/9Nxgvtja For the frontend I use Javascript and HTML/CSS, with jQuery (for ideally easier platform independence). Here's the main client file for the game: http://pastebin.com/RBrbAPXu I use HTML elements for the interface as this is a turn based game without much dynamic visual content for this version. Tables, Divs, and Spans are about it. Javascript/jQuery can handle keyboard input, I wrote an arrow keys handler. The https://github.com/pciet/talk package is what I use to wire specific websocket connections to a match against another person. The basic goal was for the server to send and receive asynchronous messages to and from multiple clients. Here's the main application glue code for the server that does the wiring when a match is made: http://pastebin.com/WrP844HA The game is playable at http://mclnds.com:8080/login - username/password are created when you type them and sent without encryption, with the password hashed/salted into a database in memory only. If the server app crashes (it probably will from assertions I've left in) a bash script restarts it automatically, but since there's no drive database it loses all of the username/crypt pairs. I don't own the game design (characters and character stats, and how the game actually works by hand) so I cannot share this code in its entirety. You gotta have two players to start a match.
&gt;Not interested but, I worked for Pixar, then Silicon Graphics, and helped make Jurassic Park. I can do more than shooter games. As if anybody gives a shit
https://www.cs.utexas.edu/users/wcook/papers/InheritanceSubtyping90/CookPOPL90.pdf
Apparently you and at least one other person does. In fact, you took time just to respond to me, so I must mean something to your life which, I presume, is busy. After all, you could be talking to anybody else right now but you chose me over all others. I **am** the most important person in your life at the very moment you responded. So YOU give a shit.
All compile stuff should be taken care of by Go, if you write your package using 'Go idioms', including those for interfacing with native libs. Even when using native libraries, or when writing assembly. To interface with native code (ie, C/C++) you need to write swig bindings. To do ASM, you need to write the .S files. These files have the same file naming scheme as the others, so they are included for the right platform. (ie, _unix.S _darwin.S etc.). I'm doing this from memory, so this may not be the right names. Swig is kind of painful for C++ code, but slightly easier for C code. The point here is that any library can be written to be 'go get'-able and not require separate Makefiles or other parts. Internally, we have a couple of C++ libs that we use in Go code. Those libs are 1) available via internal debian repositories 2) correctly have the entries for pkg-config and 3) are made to be cross platform. We have no problem using 'go get' for the packages that bind to these libs on both OSX + Linux. I'm fairly certain with minimal modification it would be able to compile on Windows as well, but no one on our dev team uses Windows. I will not lie, the learning curve to get the libs/packages able to be 'go get'-able out of the box is very very high. But, like most things challenging/worthwhile in IT, it's a fun learning curve. (btw no one on the dev team is on \*bsd or any other \*nix besides OSX/Linux either, but I'm pretty damn certain it would just 'work' if we tried there)
f := &amp;Thing {x:3} , f is a pointer, point to a Thing object f := Thing {x:3}, f is a Thing object. f := Thing{x:3} is literal initialization, no value copy exist. So there is no performance problem. var f Thing f := Thing{x:3} This is value copy, so it has performance problem. 
Have they solved the issues with tools like go vet, oracle, etc. not working with vendored packages? If not, I don't really understand why everyone is switching to the tools built on top of this experimental feature. Do you not use those tools?
Greetings everyone [paked](https://github.com/paked) here (maintainer of engi). While I encourage people to build real games with our engine (and if you are, please shoot me an email if you ever need any help [it is on my GitHub]), it is important to note that we are going through a state of flux. I am trying to keep a relatively stable API, however we are removing things which no longer make sense. If you have any objections, or would like to suggest a *new* feature [please open up an issue on GitHub](https://github.com/paked/engi/issues/new) edit: or Pull Request if you are so inclined :)
I think it's bad for Go to use such style. I think the receiver should always be the pointer. User can make the function not to modified receiver by add decoration like "const", just like C++ does. By this way, developer need not worry about performance issue caused by value copy.
Thanks for pointing that out! I just added the gif of the gameplay
Actually go just hands it off to the OS to verify. It doesn't do the verification and therefore the loading of the cert store itself.
Feel free to join r/gogamedev !
You could add the context that this is the approach the sprite library for mobile is taking ;).
while it's true one can do good science with crappy tools, having a set of robust software tools does help and increases someone's (and the reviewer's) confidence in the results. Time-to-publish is an important quantity to minimize but... I myself would be very glad if my field (high energy physics) had a library like biogo to back it!
That's exactly what I thought when I was told they use Golang, as all the other the similar labs at the uni use Python, R and a touch of C, and all my other friends doing dry lab genetics for honours are learning Python. I'll ask the guy who's head of the programming stuff and see why they use Golang.
I guess not 
I can find you some sources, but I need to know what claims you are referring to. There's many papers on the subjects, but Wikipedia gives a decent intro to OO for the lazy.
Inheritance (implementation inheritance) and subtyping (interface inheritance) are two completely different concepts. Subtyping is about allowing you to create a type that can "be" a different type (an is-a relationship). Interfaces permit you to do this (interface inheritance, "implements" in Java). If you're confused about the wording, consider the interface as the supertype, your class as your subtype. Inheritance (that is, implementation inheritance, or "extends" in Java) is about inheriting functionality from a different type, and although this can be simulated to some extend with embedding (and yes, even to a useful extend), it does not exist in its full form in Go. 
If thats true, i wonder why the most talented people are the biggest jerks all the time...
Apart from possibly the tour on golang.org, Caleb Doxey's little introductory Go book is the best resource I can think of. It's brief and very to the point: https://www.golang-book.com/books/intro . I also had a great deal of help by gobyexample.com
Thanks heaps, that book's exactly what someone mentioned me but I could remember its name.
Hope you will tell us why they choose it...
how i think of it is like this: * `&amp;` is address-of * `*` is im trying to use this var (and its a pointer) so its for two different paradigms (ways of writing code) with pointers you can do this func plus(v *int) { *v++ } x := 9 plus(&amp;x) Println(x) // 10 without pointers (x never changes) func plus(v int) { v++ } x := 9 plus(x) Println(x) // 9 // x is still 9, it never changed, only the local variable v incremented so you have to do this, without pointers (works) func plus(v int) int { v++; return v } x := 9 x = plus(x) Println(x) // 10 
Love it!
https://github.com/biogo/biogo is a good way to start using bioinformatics in GO
It depends what the goal is. Go is not a good language for research, but of course you can choose worse. However it is an excellent language for writing robust cross-platform tools and utilities. I used Go to write my [MSc thesis](https://github.com/egonelbre/spexs2) in bioinformatics. In the end it performed decently and ended up with a quite nice code-base... and due to improvements to Go runtime, it's getting faster by the year.
While I can't speak for the others (and it would be nice if they spoke up) I can speak for Glide. In Glide with have the novendor command (aliased to nv) that lists directories but skips the vendor one. So, you can run commands like: go vet $(glide nv) This will vet a project while skipping the vendor directory. You can do the same for other commands like test. You can do that with Go 1.5 today. It's not perfect (would be great if the go toolchain just handled it) but it's functional.
I am not a clever man. http://play.golang.org/p/wTrNtFdnmI
This is exactly what I was looking for. Thank you!
I had it as my `make todos` :)
There is still the portable implementation which just takes an *RGBA image like what shiny buffers provide. I have a POC platformer engine built with the sprite engine that runs on desktop with shiny and mobile with gl.
How about something like this? https://play.golang.org/p/TzB-qochQM
Hey /u/Midnightblues, I've been trying to delve into machine learning. I think I get the very high level concept of it where you have an algorithm and you just train it to do tasks, but I can't really find any good beginner level introductions for this. How'd you get this far into making your neural network library? Do you have any tips for someone that sucks at math, but is capable of doing tasks logically?
Thanks! I'm going to go check this out. Most of the material I find talks about the concepts, the math, and what a Neural Network is, but learning that way just kills me. I've been trying to find hands-on-from-the-ground-up type of material, because I learn by doing things best. :) Edit: Does Stanford provide anything on this like MIT Open Courseware?
It seems I may have been wrong about Go not being Object Oriented. Although Instill stand by that I can certainly see popular opinion is against me somInstep down from that argument. 
http://neuralnetworksanddeeplearning.com/ free book, easy to understand, focus on fundamentals. You won't disappoint.
I took a machine learning class that covered neural networks. But all of this was done just by looking at the algorithms and implementing them. The resources other people provided should be a great place to start!
As and edge case, what should happen if I have the following input?: []string{"one", `"two`, "three", `"four"`, "five", `six"`} Should it produce: []string{"one", "two three four", "five", "six"} Or: []string{"one", "two three four five six"} Or even: []string{"one", "two", "three", "four five six"} Or something else entirely? In other words, how should we be parsing the back-ticks? Right to Left, Left to Right, Outer to Inner, or something else? How does it handle odd numbers of back-tick quoted elements? How does it handle more than 2 back-ticked elements?
think of it as command-line and you are dealing with filenames with spaces in them $ cp "file name with spaces" "file name backup" []string{"cp", `"file`, "name", "with", `spaces"`, `"file`, "name", `backup"`} therefore, your example should be an error. 
Kudos for that solution, you still lose a point tho for allocating a new slice
http://play.golang.org/p/BWtiiPJ1M3
For me this is the interesting bit: &gt; In GoshawkDB, transactions are run only on the client. It's correct to view the client as an incomplete cache of the objects stored by the server. Transactions are run to completion entirely within the client. The list of all objects read, created, and written to is accumulated and then sent once to the server for validation. Thus if the client's cache of objects is valid, no matter how big the transaction is, there will only be one round-trip made to the server. In the case that the client's cache has become out of date due to some modification being made by another client, the server rejects the transaction, asking that it is rerun against an updated cache. The client will apply the updates and then automatically rerun the transaction. So bulk of the work is done on client side. Interesting way to handle a complicated problem. I wonder how that would pan out in practice. It also begs the question why it isn't done on other distributed databases.
great solution, you win !
This is what I believe to be a good balance between speed, reduced allocations, and maintainability. http://play.golang.org/p/hjDV7KZ9HH
I am not an Author, but I can answer. It's not another http router or middleware framework. It's just a set of helpful function to create responses. This lib is somthing similar to https://github.com/unrolled/render. Basically you can use any framework or library that suppports `http.ResponseWriter`.
Which sounds like Gin's `c.JSON(httpCode, jsonnableStruct)`, `c.String(httpCode, stringToSend)` and so on and so forth, where `c` is `gin.Context`.
The linked course is a Stanford course and it's free. I took this course. The teacher makes it as practical as possible. Each concept has a hands on programming assignment. It's the best one I've seen out there.
I did not realize that. I just signed up for it and it appears to be online, so this will work out great. :)
I think you're missing the point. To be blunt: it's in poor taste to just stand back and say "what does this offer over X?". This library is clearly taking a different approach to something like Gin. Where it actually stands to be a high quality package is another thing entirely. You could argue that Gin is just bloat over httprouter if you wanted to take the 'everything has been done before' stance.
This lib is not a muxer/router. You can't compare the performance due to that aspect alone, and that's ignoring the diminishing returns that router performance gives you relative to DB access times, template rendering (slower than you think), etc. The benchmarks that Gin, Echo, et. al publish all focus on the routing only, which is an extremely small slice of the pie. Gin isn't alone here in overemphasising this, though. You might use this lib because you prefer gorilla/mux (or one of the 1000 other muxes) and other libs outside of Gin's `*gin.Context` wrapper for your use-case. 
The orange text in the header isn't very legible against the photo behind it. It's not that you don't need a join-like operation in your Go version. It's that once you receive on the channel the goroutine doesn't have anything else to do. If there's no synchronization between the main goroutine and others [the program will exit without completing them](https://play.golang.org/p/GFF2srIOf_). Erlang doesn't use CSP, it uses the Actor model.
You can also draw an analogy between the `go`and `return` keywords when both are used for tail calls. `return` would be the sequential version of `go`. (and thinking in a functional way, everything is probably a tail-call)
I wonder if this Go version only manages to synchronize reliably because of the random sleep in the main goroutine? The main goroutine kicks off the child goroutine which will read from stdin and then send the time on a channel. But the main goroutine immediately proceeds with printing "Go" and then checking for a response. There isn't actually any synchronization between the two goroutines to ensure that you are ready to read a response before starting the test. I figure it's simply the random sleep that makes is appear correct. Can anyone confirm? 
Sending/receiving over an unbuffered channel _is_ synchronization. You don't need to check whether the other end is ready.
&gt; But without the sleep, is it possible that you are not yet reading from stdin by the time "Go" is printed? There is no synchronization that the reader is ready to accept a key press before the test is started for the user. I think you're right. The sleep is actually deterministic ([see](https://godoc.org/math/rand#Seed)). Looking at things more closely I'm afraid that the `time.Now()` call in the spawned goroutine might happen before the one on the main one. 
So I guess it behaves like expected... but it's tricky. Also, I see that the `FAIL` message is prescribed by the excercise, but it's pretty horrible. From reading the code alone I assumed that the message means something like _Ooops... This should never happen, but I couldn't figure out how to write the code such that it never does._
For safety?
Type safety when using multiple types and performance. If you need fields of different types in a map, you have to use interface{}, which means you'll be making a type assertion for almost every lookup, which could fail at runtime instead of compile time. Structs also allow the compiler to know the size and offset of every field at compile time. This means fields can be accessed with a single memory load. Maps, on the other hand, require a hash of the key to be generated, which is then used to lookup the value. A map lookup can be 2 or 3 loads, depending on how the underlying hash table is implemented. 
First of all did you ever looked how a map and a struct is implemented? The map will store the whole name as string(or whatever you use as key), will use a hash table with Buckets to lookup and the value itself somewhere on the heap. (http://www.goinggo.net/2013/12/macro-view-of-map-internals-in-go.html) Compared to a struct which is just a 'layout' how the memory is 'structured'. So the compiler knows at compile time which item is accessed and just need to use the offset which is calculated by the compiler aswell. That costs by far less than looking up an item with a key. And don't forgot an optimization. Also It's important that the struct is one block of memory if you use a map you will probably end up having lots of small pieces of memory. Also It allows you to work with other programming languages. However for this I would advice defining the struct in C because that's basicly more safe because of the alignment. Another important point is that go is a static typed langauge. In alot of places where safety is important(I cann't proof that, It's my opinion) static typed language will just make your life easier. The compiler is basicly powerful enough to detect alot of mistakes by enforcing static typing. The probability you make a small typo is kinda high so setting some variables you never wanted to set or to get can be really dangerous. Also It would be hard to differ from public and private fields. I think you should inform abit and also make a performance test once you will notice huge differences. 
I was hoping that by dereferncing the pointer in dealloc I would trigger Go garbage collector to free the memory. Is there a way to force this?
Yes, that's good C solution and the basic comments makes sure its actually understandable whereas the ambiguity of the original code in the article is so bad that it takes a reddit thread to work out whether the code actually works by design or by coincidence (still not sure)
Slight correction: Arrays store a known number of values, slices store an unknown number of values.
The actor model and CSP are pretty similar though right? Isn't the actor model mostly different in that senders and receivers are more decoupled.
The Go garbage collector doesn't track pointers passed to the C world (because that would be absurd). Your dealloc function is a no-op. This is especially true in Go 1.6 which can *move* pointers without telling you and will likely throw errors about your code above. The Go recommended way of keeping objects alive while allowing reference passing to C-land is to store a copy of the object in a map and delete it from the map to "deallocate it" (which the GC will do on its own time). var tableRef = make(map[uintptr]*Table) //export tableNew func tableNew() C.uintptr_t { table := &amp;Table{"Lala"} utable := C.uintptr_t(uintptr(unsafe.Pointer(table))) tableRef[utable] = table return utable } //export tableDealloc func tableDealloc(ptr C.uintptr_t) { if table, ok := tableRef[ptr]; ok { fmt.Println(table.name) delete(tableRef[ptr]) } } 
I don't know. Seems like a lot of nonsense to avoid wiring up a simple switch statement to me. Maybe I'm getting old and curmudgeonly, but this is the kind of stuff I see in other languages that drove me to Go in the first place. I understand what you are trying to do here, but it just seems so... unnecessary...
But then you can easily save a post in a page struct. Just leave the title blank. A type field can help to distinguish a post from a page, if required. And then the two functions can collapse into one.
its two different paradigms (ways of writing code) structs are similar to OOP concepts, most of the time when you use a struct you are going to have many structs: type listitem struct { icon bmp, text string, tooltip string } // quick ex: drawlist([]listitem{ item1,item2 }) func drawlist (list []listitem) { for i,v := range list { fmt.Println(i,":", v.text) } fmt.Println("Choose an item (#):") } //ex 2: type player struct { mana int, abilityPower int, hp int, act int } if player1.CastsSpell() &amp;&amp; player2.castsSpell() { if player1.abilityPower &gt; player2.abilityPower { // player1 wins } //.. etc } maps are dictionaries/hash tables, kind of like an array but with a lookup key var m map[playerID int]player = {} var player1 = m[1] player1.dostuff() use structs when you will be duplicating common functionality (like player1,player2,badguy), or you need struct methods (player1.isAlive()) or when you will be encoding the data to json structs are also used to read and write binary blob (serialized)/packed/zipped data to files. ex: first 12 bytes are the first field in the struct and its type is INT64, next 36 bytes are type String and that is field 2. structs are also used to interact with hardware drivers, things like USB/serial ports and Arduino/rasperry pi drivers
In go, you can also declare functions on maps. Also, why shouldn't you use maps for serialization of JSON data?
I don't understand what you're trying to say. Could you elaborate?
&gt;Great package management Nah. I love Go but this is not great package management. Should be phrased as **Easy to get packages**. 
I have been using gorm long enough to like it. The only thing that I don't like is lack of documentation on the source files(godoc). The chainability is the best thing one could ever ask for querying database in golang. 
How would you do it without at least one separate thread?
Got an example?
Just on a quick read-through of `bot.go`, it seems a little weird to have BotID as a package variable. I would expect either a `bot.New()` function that returns something with a `PostMessage` method (though I might just rename to `Send()`), or for postmessage to take BotID as a parameter. That way, code using the library could act as more than one bot if they wanted to. Haven't looked at the listener yet.
Excellent point. I originally had the handlers from the distinguished_taste_society_bots repo built into the main repo and was serving the bots on Heroku, then decided to make the project more generic so others could build their own bots using the library, and the BotID was one of the leftovers from that. I've just pushed up some changes based on your recommendation. Thanks!
I don't really understand why you're saying here. 
deliberate i'm sure. i love not having instance fns be indented a level, and also that you can put them anywhere you want -- no forced grouping into a single file is great.
I think it's because Go was designed in part to encourage good style. I can't be bothered to look up any sources on this. Maybe it was just a nice little bonus from Go's simplicity and object composition. If your code in other languages has many levels of indentation, you may be able to clean it up a bit (probably by using helper methods with simpler functions). This would give you some of the readability and simplicity you're seeing in your Go code. This is all just guesswork on my part though.
Structs not only provide a _structured_ means for grouping data it also provides some documentation by having the field names and types known before hand. Here is a very simplistic example. http://play.golang.org/p/73UQnuT9vl If I modify this from it's current stat to just use a map, it won't run. http://play.golang.org/p/kHDPn3c7Xn The reason is that we have to use a `map[string]interface{}` to get the same results as the previous `SimpleUser` struct where we're storing a `string` and an `int`. We can't create a `map[string]string` or a `map[string]int` because neither would allow to fully represent `SimpleUser`. So how would we fix it using a map? We have to add a cast `u["name"].(string)`. http://play.golang.org/p/12ypzf-HRu Alright, so you might be thinking, "Of course, so why use a struct?" And that's a good question. Because `u["name"]` might not be a `string`. We cannot make any guarantee that the user's `"name"` property will be a `string`, heck, or even be in the map. Let's see what that looks like. http://play.golang.org/p/S0LFHdm-bY With a struct, those fields are zeroed if not set, and they cannot be assigned the wrong value. http://play.golang.org/p/TvNdHpyjzi So, to conclude, you would use structs for safety. Both at compile time, and to provide a meaningful storage method for related data. Just throwing everything into a map works in quite the opposite way, unfortunately. If I were to get a `map[string]interface{}` back from a library call instead of something like a `User struct` I would immediately discontinue use because no guarantee could be made now (or ever) on the structure of that map and this could lead to random crashes in my software because of it. I'm not dissuading the use of maps, but maps should be used when representing an unknown grouping of key/value pairs or to relate some common key to an uncommon or expensive to generate value. Structs should be used to group meaningful units of data like a `User` a `Game` or any other number of things. I would also recommend if you're consuming a JSON API to decode into a struct rather than a map, again, no need for additional casts and the data is immediately typed and available. 
Use an interface.
One of the main reasons is the convention of short (mostly one-letter) identifiers (e.g. variable names), I think. It improves readability by making the code narrower and dissecting expressions and statements easier, as counter intuitive as that sounds to Java or C++ programmers.
This isn't so much a Go thing as it is a programming thing, but you comment far too much at times. For things like... // Attachments is a list of attachments added on to the GroupMe post Attachments []Attachment `json:"attachments"` Is the comment really necessary? It can be pretty easily inferred, as you've named your variables very well, and the additional comment is just unneeded extra noise. Compare something like this to your block in listener.go... if strings.Contains(strings.ToLower(post.Text), strings.ToLower(t)) { term = strings.Replace(strings.ToLower(post.Text), " "+t+" ", "", -1) term = strings.Replace(term, t+" ", "", -1) term = strings.Replace(term, " "+t, "", -1) go handle(strings.Trim(term, " "), c, post) h := &amp;c v := reflect.ValueOf(h.Handler).Elem() v.Set(reflect.Zero(v.Type())) } A block like this, to someone who's not familiar with the problem domain, is extremely hard to decipher, and some well placed comments could really help out, or better yet refactoring the code into another function. I'd try to go through and determine which comments are *really* necessary. The Go specific stuff (i.e refactoring the Bot into a struct and allowing for multiple to be used at a time) I think has already been covered well. Hope you're enjoying Go! :D 
Yeah compare to Java at least Go code is lot more vertical than horizontal.
woah, thanks for the effort, even though /u/jasonmoo's solution did not top that list of benchmarks, I think it is the idiomatic way of doing it.
[dear god, make it stop](https://www.youtube.com/watch?v=5kj5ApnhPAE)
Lots of curly-brace languages don't need to be indented like Python. But my real question is are you programming on a mobile device? How narrow is your screen that being limited to 80 chars (PEP8) is sensible? Also, most languages have the notion of line continuation. So you could conceivably make lines almost as narrow as you like. This is just one of those nonsense things programmers love to compare for no real reason. _shrug_
Humans find long lines hard to read. Tons of research has been put into this and 2-3 inches is about optimal. 80 chars is actually probably to wide, depending on the font size.
https://golang.org/pkg/strings/#Contains
You may also be interested in `strings.ToLower`, so that you can search for red, RED, rED, or any other capitalization, without writing them all out yourself.
[Reflection is never clear.](http://go-proverbs.github.io/)
...but we're developers. Humans find lots of stuff hard to do. :)
http://baymard.com/blog/line-length-readability
That sort of thing will definitely be in the pipe-line. GoshawkDB is language agnostic - it just happens that the only client that exists currently is in Go. It should certainly be possible to build tools that allow interactive exploration of the object graph.
Empathy is good. Many C++ programmers lack it completely.
For `go doc` the OP is correct in commenting things like Attachments as it starts with a capital. That said, the stdlib gives a good guide to the terse style, and that they're sentences and should end with a full stop. "triggers will be lowercased when matching so are case insensitive" is too verbose, for example. The user just needs to know that "Triggers is a +case-insensitive+ list of terms...". The comments use a mix of styles: "will take a" v. "takes a". handle() has a comment describing search, not handle. It's unusual to see strings added together for Print*(). Instead, pick a more suitable function, e.g. this could use Print, with the \n being explicit. fmt.Println("Handling term \"" + term + "\".") Does PostMessage have to convert to string? Could bytes.NewReader be used instead?
I am posting this just to increase the list of golang documents in google. Hopefully it might help someone who has the same issue as I had today. concept is very simple but for new gophers like me it might be confusing at start.
BoltDB is as reliable as the application/infrastructure running it. As it's a single-process, file-based store, there isn't much to 'go wrong', but simultaneously there isn't a way to provide 'failover' (in the same sense as (e.g) Postgres). Which is OK, because BoltDB is great because of its simplicity. What are you looking to use it for? 
Widely used tools on 10k servers scale use BoltDB so I'd say it's pretty solid. Good example is https://www.consul.io I'm sure you need to do some legwork to properly use it though. 
You assume that it is implemented correctly (not making a judgment). There is a big difference between working correctly in a distributed context versus in-process. I can tell you from personal experience that there was a large period in which the in-process [syndtr/goleveldb](https://github.com/syndtr/goleveldb) database was implemented incorrectly and would blow up in production but not in its distribution tests: it uses (or past tense: had used) [finalizers](https://golang.org/pkg/runtime/#SetFinalizer) to manage file descriptor cache state, which would cause periodic crashes due to violated state invariants. Finalizers are fundamentally unpredictable due to dependence of the runtime version and are unlikely to manifest themselves in tests. This meant divergent behavior between production and what one got when running the software on an engineer's workstation. The reason is the difference of behavior for garbage collector/memory allocator when the system under test experiences memory pressure.
A very common idiom is to have an "out" parameter in functions that use reflection to make their result, which also enables the caller to pass the desired return type to the caller. It's useful in such situations, so that the function can set the pointer to nil or change its pointee. "encoding/json" does that ([example](http://play.golang.org/p/MJdLhYHNov)).
I think it would be more idiomatic to return a (socket, err) from your initialization method than to pass the double pointer. There are definitely situations where the double pointer is necessary, but this doesn't feel like one to me.
you should use it for json, but the use case is different i believe. i think a map equates to an json array (a list with a unique key of things of the same type == converts to array), while a struct converts to an object.
why do people keep posting these fluff pieces in the Go subreddit... most people in here use Go already. On top of that the same stuff has been written about 1000's of times by now and none of this is new.
(... Totally forgot about cake day.)
Except to use sqlite you need to link with the C library, which is a pain on Windows for example. On projects where I need a simple datastore, I generally use bolt.
I don't know much about Windows. But being pure Go also mean that programs using BoltDB can be cross-compiled for different platforms. This can vastly simplify the distribution of cross-platform software. 
This tool is roughly similar to the python version (from Google for Android) of the repo tool. It reads a manifest file and checks out the projects in a directory. You can specify the branch to checkout, it works with both git repos and mecurial. 
When you find yourself doing something like this in Go, you might want to think about why you're trying to "communicate by sharing" instead of "share by communicating". Passing double pointers and then sometimes having to do double dereferences seems like an easy way to create confusion and get hard-to-debug errors like nil pointer dereferences. Edit: make-&gt;might
I have definitely experienced random bugs and crashes while using the datastore. But I think it's generally quite good as a portable embedded store. One great thing about BoltDB is that the entire database can be serialized in an (atomic) transaction using Tx.WriteTo. Unfortunately any kind of more sophisticated replication would need to be implemented externally, and may not have ideal failure modes in all important cases. BoltDB is not bulletproof, as OP has noted. Look at the risks and recovery modes and ask if they are acceptable for the application in question. 
You should run `go fmt`. At the moment your indentation and formatting is a bit all over the place. :-)
there is a ton to get "wrong" for file based DB...
I like my code to be narrow enough to fit on half of full hd display, altho 80 is a bit too small
versioning is main part of useful package management
That's fair. I only used bolt on projects where losing data is not that important, so I can't really say how reliable it is. For that type of projects, the build/deployment simplicity of bolt vs sqlite3 is worth it I think.
Haha, I like it. :)
Yeah, this code is just plain bad. Go allows multiple returns, so there's no reason to use reference parameters as a workaround for the lack of multiple returns. The reason to use pointers is to tell the program to reuse memory or (less often) to quickly signal that a return value is optional/nullable without using a struct/tuple. Double pointers don't have a place in modern Go. In the example in code [1], supposing that `changeSample` took in a larger data structure than an `int`, then the whole point would be for the caller to be the one to allocate and reuse that larger structure. Having the function take double pointer removes the whole point of memory reuse. It's like buying a new book, putting it into the shredder, and recycling that, all so that you can say that your book was printed on recycled paper.
I, too, would like to see a more nuanced take on the switch to Go. Taking all its features together and after using them for a while. For example, it's great you can write `x := 1` and not name the type, but what does that mean for your code, for the idioms you develop, etc. That's probably the least interesting feature to pick on, so what does `go get` do for your development? What does the concurrency model enable? I haven't used Go enough to really answer these questions yet, but if I had I'd consider writing up something like this.
Very true. I also thought I should use channels (share with communicating) but still tried to solve it pointer the way to understand how Go works. As I mentioned, for me the main point was getting what is happening, otherwise "share with communicating" is the golden rule.
That, you are right about not being possible in this case. I didn't explain the whole project. But I commented below what was my intension and it was possible to do it in another way too (channels) and why I used pointers. Main point was understanding how go works in this case. The final code wont end up as the example.
It's probably not in your path. Presuming `GOROOT` is set, try: export PATH="$GOROOT/bin:$PATH"
Dude... What OS? How did you install it? Literally any information that we could use to help you. Anyway, "git shell" probably means "I installed Git and got Git Bash and I'm calling it "git shell". So yeah, you have a bash shell. Cool. ... Git... doesn't come with Golang, so I'm not sure why you'd expect it to just work.
Can any of you guys who say you don't need a separate thread post an example on playground?
or do yourself a favor and install Rapid Environment Editor (for windows) http://www.rapidee.com/en/about
I feel pretty much the same. Or the entire width of a full HD display turned 90 degrees to portrait. Not huge, but certainly larger than 80.
If I knew this was going to be a competition I could have improved my impl. a bit more lol I just wrote up something quick :P
Nope, not a bad idea, as long as you're the only person that needs to update and redeploy it in the long term. If you ever might need to hand it off to anyone else, a more regular approach would probably be better. HOWEVER more generally, it is usually a good idea to spend some time to find structure, even if at first it seems like you need a docstore. Often you are just deferring future pain by throwing schema to the wind.
If you don't need persistence to disk, this should be fine. If you do need persistence then the latest versions of MySQL, Postgres and SQLite can all store and process JSON data with varying degrees of convenience and abilities.
I have helped on a small project which also took this approach. Just make sure you have a nice clean interface to your data layer so that if you need to change the implementation all you need to do is re-implement your "data" interface and then change your wiring. 
This reminds me of http://thedailywtf.com/articles/The_Storray_Engine
By successful you mean what? Funded by VC? I don't want to hurt anyone's feelings, but my humble opinion is their architecture (or rather lack of it) is a disaster. E.g. look at [this](https://github.com/mattermost/platform/blob/master/web/web.go) **1174 lines** or [this](https://github.com/mattermost/platform/blob/master/api/user.go) **1782 lines** of masterpiece in a single file. Can it be simplified and/or split into multiple files? I don't like haters and don't want to become one. BUT, I'm dead sure at the end we'll see one more article on "how bad monolith is", "microservices rock", "go is so special it doesn't need web-frameworks". Of course, they will compare their crappily implemented monolith to less crappy microservices and make big conclusions out of it.
This has more to do with data model design than Go. [REST](https://en.wikipedia.org/wiki/Representational_state_transfer) is one way to think about the data model architecture that specifically describes URLs. In this case, REST likely suggests "POST /reminders" with a (usually JSON-encoded) body containing a date. Respond with a Location header pointing to the newly created "/reminders/{id}" resource.
I don't worry about performance. Reliability is more important (for me).
Who is coming? I'm also there.
Build Constraints is what you're looking for: https://golang.org/pkg/go/build/
This. Don't overcomplicate it until you've proven you need the extra functionality.
If I manage to make it, it will just be a day trip out from Amsterdam. 
Really really cool! Thanks for sharing!
I'm not sure what your specific question is, but in a template you may iterate over slices (or any pipeline) of values with the `range` action. The `html/template` documentation has a good example of this: https://golang.org/pkg/html/template/#example_ In general, the documentation for `text/template` should get you started with fully understanding the possible template actions.
A map also serializes to and deserializes from a JSON object. A struct is just often more useful in Go, since the fields and their types are statically known, as well as being more efficient, since fields are stored directly and at known offsets which don't need to be computed on each access.
&gt; Nope, not a bad idea, as long as you're the only person that needs to update and redeploy it in the long term. If deployment is so difficult that you are the only person who can support it, you are doing something wrong. Deployment should be easy and no person should be a bottleneck for deployments. What happens when you are on vacation and something goes wrong and nobody other than you can deploy a fix? Nothing good, that's for sure. Don't let a poor deployment process lead to bad development decisions. Fix your deployment process first!!
http://danluu.com/file-consistency/ ( from [/r/programming]( https://www.reddit.com/r/programming/comments/3wn9e9/files_are_hard/) ) + few linked papers TL;DR version: some guys tested it and only DB that really didn't had any corruption was SQLite in WAL mode (relatively new feature, not on by default AFAIK)
Some suggestions: A readme, maybe some screenshots. What are your goals? Not sure what you mean by chatting app "backend", but you might like my ssh-chat project: https://github.com/shazow/ssh-chat I'm also building an IRC server toolkit in Go: https://github.com/shazow/go-irckit
Yes to all, after copy-pasting the authorization code it says unauthorized. Does the script all work as-is for you? I have another Google apps account I will try this with to see if the outcome is different. Any other ideas? Thanks for your help :)
Bolt author here. We originally used Bolt at Shopify as the backend for an analytics database we wrote. While I was there, Bolt was solid. It was marked as version 1.0 after we had been running 1TB of data for about six months without issues. I've also heard of other companies running with 3TB+ databases without issue. With regards to issue #348, I'm currently refactoring the test suite to allow much longer running and more complex simulation testing. I have never seen that issue occur personally but I'd like to get to the bottom of it, whatever it is.
SQLite is a solid library for sure but I disagree about SQL being the best choice for persistence. Translating object types in Go back and forth between a relational engine via a string-based query language means that you incur a lot of overhead during retrieval and you lose compile-time type safety. I've found that protobuf encoding objects into Bolt (or any KV store) to be much easier and more bug free than working through the database/sql package. It also gives me more control about how I store data so that I can optimize data access when necessary.
Well, Node is web-scale, so there's that.... &lt;/s&gt; But seriously, your question is too general. Golang is great for some web apps, sucks for others. If you want an end-to-end framework with a lot of convention and tons of usage/contributors, you might be better off with node or even Ruby. The web framework world in golang is still kinda iffy. That said, I personally don't like the loosey-goosiness of JS, and I think grunt and node_modules suck, but YMMV. Good luck!
Web-scale?
IMO anything you want to be reasonably confident in, Go would be a better fit. Go in some cases may be a bit more verbose or require a bit of extra code but it's worth it. Namely error handling and just general robustness due to static typing etc. Go's streams via reader/writers are also much nicer than Node's. The only things I would say Node maybe excels at is a) JSON parsing speed (v8 is fast here, Go is slow when the input is arbitrary), working with arbitrary objects (bit painful with Go, but rarely necessary). That's really about it from my experience with the two. While working with Node in production I've seen a number of cases where a single bug takes down the entire application, only to restart and crash again moments later. This sort of thrashing is pretty bad with Node, thankfully similar is usually isolated in Go, even if Go isn't perfect in that respect. So I think it depends on how important your project is! Node may be quicker to bootstrap in some cases but yeah.
https://www.youtube.com/watch?v=bzkRVzciAZg or https://www.youtube.com/watch?v=b2F-DItXtZs
Wut?
https://www.techempower.com/benchmarks/ these were the benchmarks that convinced me to learn go and node. back in the day go and node were top 4 only behind openresty and java servelets... tbh go wins some benchmarks and node wins some benchmarks, *i would use whatever you want*.
I would suggest learning a compiled, strongly typed language first. It's a bit more overhead to understand the types, but the compiler will make it easier to debug than digesting python stack traces. Go and C are solid candidates, with C++98 and Java rounding out the set. Java and C++ require more boilerplate, which isn't conducive to all learning styles. If you're okay with the boilerplate for toy programs, the IDE tooling makes Java and C++ good places to start. If minimization of and understanding of the code is important, C and Go are definitely better options. If you do choose to start with Go, I suggest you avoid concurrency for some time. It's touted as a major strength, but it's not very inviting for new programmers. Debugging deadlocks and go-style fork bombs isn't quick, easy, or suggested for the sane. Once you have a solid understanding of types and control flow from typed languages, Python gives you a good platform for understanding the object-oriented inheritance that is ubiquitous in many languages. While I prefer the Interface composition of Go, most of the general programming community lives and dies on inheritance. Python is not a bad way to dig into understanding that flavor of object-oriented programming. Avoiding inheritance simply leaves you on too small of an island to really get involved in the programming community. EDIT: If you're in the academic community, get to know the scipy stack (numpy/scipy/pandas) as soon as you're comfortable with types and control flow. The scipy stack is currently top of the heap for crunching data, with a fistful of libraries building on top of it. Machine learning, neural networks, and the family of statistical libraries are much better developed than most.
You're worried about backing the wrong horse, that the language you choose will wind up irrelevant, useless, or otherwise unsuitable for your needs, but don't worry. Learning to code is really all about common concepts. Once you understand those concepts switching languages is incredibly easy by comparison. As a big fan of Go, I have to say that Python is your best bet for starting out. Go is a **very** easy language to learn once you know how to code in general, but starting from scratch means you need all the resources you can get. As a popular language that's been around for much longer, Python has the necessary tutorials and communities to help you get up and running quickly.
it's going to depend a lot on your style of learning. something like python is easier to get stuff done in fast, but it's a more complex language, and it has a harder-to-understand model of computation. just go with whatever seems interesting, and don't be afraid to switch if you get bored or more interested in something else. learning any language puts you 98% of the way to learning a different language.
*there is a ton to get "wrong" for* code that interfaces with C as well. And your own link and comment shows that SQLite, even as awesome as it is, is not immune to these problems. 
No matter what language you pick, you're going to want to dive in and really try to see it from the inside out. Go is not a *bad* choice. It's a great 2nd or 3rd choice. But, to really appreciate Go, I think you need bad habits (from other languages) to unlearn. Very ready to be wrong on that point though. Try Python? It's got a great community, and a lot of libraries to work with. Javascript is very accessible and right in your browser - it's a nice language to start with. C++ or even C# are nice languages. Yeah, sure, there's a lot of boilerplate, but a good IDE can help you dig through that - I don't like the junk on C#, and the bad habits Visual Studio teaches you, but *it is really easy to use*.
Here is my current $GOPATH and $PATH with non golang stuff stripped out, and enough to run `gomobile init`. Hope it helps. Basically make sure you have your GOPATH inside your PATH. GOPATH=/Users/adamgeorgeson/dev/go PATH=/Users/adamgeorgeson/dev/go/bin:/Users/adamgeorgeson/bin:/usr/local/bin:/usr/bin
I don't know how I feel about the multiple queries benchmark, go is so low on the list I feel like if they had multiple queeries there weren't using any sort of concurrency method and just had 20 in a row synchronously. I can't imagine 20 go routines with a channel receiving taking that long to do 20 queries
Will you be there on Friday evening as well ? Maybe we can organize something then ?
Just updated document and one benchmark for local mode.
So very much this!
Another vote for Python over Go as first language. Much easier to learn and lots of potential project to dive into and learn from.
I think you did not really give enough info about where you want to go, but my two cents: * You cannot just learn to program. After 8 years of being a full time dev, I still learn new stuff basically every day. You will just improve * day to day dev tools are much more complex than languages itself. Given that a lot of tutorial stuff nowadays points to Github, I suggest you get used to git first. Git is not a programming language, but if you try to understand it, you will be confronted with some CS concepts and Git is also useful outside of programming stuff * in case you are using Windows, I suggest you use a *nix environment for developing. Ubuntu is a good dev environment IMHO. * you can try simple tutorials which run in the browser and see which language you like most: eg. https://tour.golang.org http://tryruby.org http://www.tryerlang.org/ https://tryhaskell.org/
[removed]
I recall reading about someone who taught Go to a class in primary school. It went better than expected. He had previously used Python in a similar setting. Especially gofmt was a good thing. And the language is simpler than Python. The conclusion was that he was going to use Go in the future as well.
Yes! Learning a language (as opposed to learning programming) will only make you dependable on it's gimmicks to design your code.
As others have mentioned here, The key is to learn to program. The arguments for and against any particular language entail bringing a can-opener to a worm cannery. Go is a wonderful language, but unfortunately it's very opinionated. I agree with most of it's opinions, but these don't really matter until you get to the nitty-gritty of Object Orientation (how do we structure the program), generics (to do with the type system, another area of debate...), etc. I'd recommend starting with something like Python (scripted, but beautifully formed) or C# (Available on most platforms despite being a Microsoft language). Once you have your brain working with the general (language agnostic) concepts of conditional branching and looping, you can start to appreciate the subtleties of "composition". This is where "Object Oriented" ideas come into play, and are where the dragons lurk. Go comes from the idea that "Interfaces" can be used to express most relationships between objects. An interface is, simply, just "what something can do". Many languages support this concept, but Go is quite opinionated in this regard, in that interfaces are implicitly fulfilled (If something *can* satisfy the interface, it automatically does, rather than explicitly saying that it does.). Most other Object Oriented languages rely more on a class hierarchy. The composition relies more on extending base classes to enable functionality, and interfaces are more explicitly defined. Don't worry if this is confusing, it will become more obvious as you learn other languages. Also, Interfaces are not the "be all and end all" of OO programming. Do a Google search to find out more about inheritance, abstraction, encapsulation, isolation and all of the other goodies that OO (loosely defined) entails. The point is: Most languages out there do things the more traditional ways that Python, Java, C++, C# etc do them. Go is slightly different in this regard. You are better off, as a new-comer, to learn the more common idioms before looking at Go. As others have said: Start with Python, then look at Go when you find you need a compiled language :-) You'll appreciate the difference much more if you do.
I'm going to say basically the same thing as everyone else here, but I'll attempt to say it differently - instead of finding a language to code in (Go, Python, C), find a mentor and learn what they do. You're learning both to code and a coding language at the same time, and it will be hard to differentiate which is which. Find someone you can learn from, learn the concepts from them in what they do, then go learn whatever languages you want. If it's a Go mentor, great. Check out Meetup for local user groups. 
learn a full oop (object oriented programming) language (ruby, c#, java). after you can learn golang. so you will be able to see difference. (how golang approaches programming etc). imho if you want to work as a developer, first you should check career websites and search 'what companies looking for' in your country. i mean, in every country there are trending programming languages. so you should learn them first so you can able to jump a job quickly :) otherwise want to continue as a hobbyist go with whatever you want. and don't forget to learn a programming language every year '-'
I'll arrive at 9pm (21 o'clock ;-) ) at Brussel Airport on Friday ... so too late. But Saturday would be fine.
Personally I learnt mostly c++ from the beginning. It's a bit hard with the memory allocations and pointers but when you learn to handle it then most other languages are easy. The learning curve for me: first really fun with basic tasks. Then quite hard and confusing when you realise that you don't really know anything. Then hard and fun going into patterns or best practices and code design choices. After that it's fun. And the you switch to a language with garbage collection and you'll be quite impressed with how easy everything is. And then you'll continue to learn for the rest of your programming career ;-)
Python or Ruby
Nevertheless, you need to pick a language to start learning programming. And the choice of language can either facilitate (say, Python) or hinder (say, C++) progress.
There are some problems with statically typed languages for complete beginners: - The compiler errors will probably be unhelpful, if not totally inscrutable. - Unless you've been programming for a while (particularly with large/complex codebases) the benefits of static typing are not obvious. To most beginners it just seems like needless pedantry and annoyance. - For C specifically, there is *so much* low level scaffolding you have to implement to do anything that most people would consider interesting. The consequences of even a minor mistake is typically "Segmentation fault (core dumped)" which gives hardly a clue as to what went wrong or where the error is. I think the number one most important thing for beginners is to find an interesting project/problem and then make meaningful progress towards solving or implementing it. If the experience is too frustrating the tendency will be for the learner to get stuck and give up. Python is a nice choice because it avoids most of the above issues (not all of them--exception messages can still be really mysterious to beginners) and has a huge number of possible applications: games, scientific analysis, system utilities, etc. 
Hey /u/gernest_, I @'d you on Twitter. Do you just need/want _access_ to a better machine (eg, will SSH work?) or do you need it to be there with you?
No, I meant that I would ship it, haha. I have several servers that I rent that I could give him access to if he wants SSH. Just throwing ideas around. Also, agreed - if he wants his own VPS, that's an easy fix.
I don't have a spare machine but I am happy to donate money or a virtual machine if that works?
Hey, thanks for the advice. I have tried to set up PayPal account( a couple of weeks now). the bad news is paypay doesnt work in my country, I can only send money and buy stuffs but not receive money.
What botnet are you talking about?
hey, I need a machine with me. I spend most of my time offline. I left alot of details from the post to keep it relevant. Thanks btw.
He says he would ship it back at the end of the year.
&gt; You would ship a computer to Tanzania? A poverty stricken region at that? That can't be cheap. We're talking several hundred dollars at least. I've just checked with UPS. From Europe to Tanzania, shipping a laptop costs around ~$350 and an average weight PC around ~$2000.
What about alternatives? Western Union can send to Tanzania, and the fees are doable. Regular international bank transfer is also an option if you have a bank account that accepts such a transfer, although such transfers are a bit messy. If you figured out western union or something similar, I'm pretty sure you could gather the money required for a decent machine rather quickly, as I and seemingly many others would not hesitate to send you a bit for help.
Thanks, I'm really bad at skimming sometimes.
My original plan was just to ship my unused PC to Tanzania, but UPS and DHL both gave me prices between $1000 and $2500 depending on exact weight, so I'm trying to find some online retailer in Tanzania that will accept international payments. Shipping stuff to Tanzania is hard :/
Yeah, absolutely understood. I will do some Googling. /u/gernest_ can you recommend any retailers?
That would be great, thanks! If only I could find a Tanzanian retailer that accepts international payments... I'll let you know if anything turns up.
Seeing other comments, you say PayPal doesn't work. It's similar here, so maybe you can get a Skrill card? Or Payoneer? You could use that card both locally and internationally, we could donate some money, and you can use that card to ger paid for some remote work! Don't have any spare hardware or means to ship it to Tanzania, but I would love to donate something, your work and your spirit is amazing, you deserve it 100%.
Unsafe SSL negotiation error, can't see the site.
Thanks, I haven't heard of those cards before, I don't think they are here in Tanzania but I will check it out.
No, they are not, they are international. Payoneer for example, it's sort of like a bank, but not really, they just issue prepaid cards you can deposit money to, and use that card anywhere. You can sign up, give them your details, they will issue you a MasterCard, ship it to your address in a regular envelope. Once you receive your first payment/deposit, card will be activated. Then you use it normally - you can pay stuff online or in stores, withdraw money from ATM, etc. Cool thing is, people can deposit you money worldwide. I will shamelessly give you this referral link - https://share.payoneer.com/nav/bc6JcFnV-iCFP31AxQhME-p2L6_mTaIGe_x-0OpoqJGGMqgbXn7P7XXTXmNTY1v7h2ycHNCLg4za8aPO16hvNA2, once you get your first deposit, we both get $25, and I will gladly send those $25 your way. It is totally safe and legit, I am using it for my full time job. I am in Serbia and economically, law is pretty much fucked up, there is no good way for me to get paid from the US without country robbing me. This way, I have a US issued MasterCard and all funds received cannot be taxed by the country.
Well, it couldn't hurt to check :) I'm very open to anything that will get a nice PC/laptop to this guy. So please check both Canada to Tanzania and Turkey to Tanzania. If it's noticeably cheaper with your account, let me know. For shipping weight, 3-5kg for a laptop and 10-20kg for a PC seems reasonable, I think.
Let me know if I can contribute.
Stop using Internet Exploder? &gt; This site works only in browsers with SNI support. https://www.ssllabs.com/ssltest/analyze.html?d=blog.gopheracademy.com
Why you want to create a fork of Gogs? Wouldn't be better to contribute to the existing one? I use Gogs and it is getting better with time, but seems to have few contributors. Hope you get a good computer. Good luck!
I was able to get a quote. I just used the capital city so it will certainly vary based on where OP is located. But the quote I got was $265 CAD. I estimated 7lbs and 16x12x4 in for size (assumed a laptop). So shipping isn't totally out of the question. 
Hey fr4nk3n, I posted an update to my original post, maybe you can help shed some light if you have experience with the dev console and stuff. Thanks!
I have two old PC's which are still quite useful. Is there an organization or project that lets me send this stuff to people who really need it (in the sense of poverty holding them from acquiring a PC)? I mean I might be able to get 50 bucks here, but that's not really worth the effort. More importantly though is that it would be for a good cause.
Do you still need a website, I have one that I think accepts US payments. 
I sent you a PM which should help you out a lot!
Wow, $265 CAD is great! OP [seems to be](https://github.com/gernest) in Mwanza, so it'll probably be a bit more. I'll keep you updated if/when he replies to my PM.
I lied. The website fools you by pricing everything in USD but only accepts Tanzania payments. 
+1
If you're here for the typo, that's fine too. ;)
I used rethinkdb for about a year on a project at work (back in 2013, I think). It's extremely easy to setup and use, and the admin interface is superb. Truly a pleasure to use. Honestly, though, performance wasn't stellar at the time. We weren't using anything complex in it--we really just wanted a place to keep schemaless metadata. It handled data just fine, but basic retrieval queries took several hundred milliseconds to complete. Eventually we just ditched it and started using postgresql and its fancy json datatype (still using that same setup, just with jsonb now). Another thing that turned us off of rethinkdb was disk usage. Compared to an un-normalized mysql table with only a primary key index, rethinkdb took almost exactly 32x space on disk (iirc) for the exact same data (irc logs). That got out of hand very quickly. I'm 100% certain they've made performance improvements since we parted ways. I also know they've made great improvements in the data storage. I've tinkered with rethinkdb since we stopped using it at work. It's really great. But I haven't done any benchmarks since we switched to postgresql. I want to, just haven't had time. I say try it out!
Generating Go structs from Django, not generating Models from SQL.
Yeah that seems strange, I was able to reproduce the error you got "Unable to execute Apps Script function. googleapi: Error 401: ScriptError, unauthorized exit status 1". Seems like it could be a change to the dev console that wasn't accounted for in the tutorial, I know it has changed some in the last few months.
Posted on HN as well. Just to give you more exposure. ;)
Hey, I maintain the Go driver for RethinkDB and while I havnt got anything running in production I hope I have useful information. Regarding the learning curve as mentioned RethinkDB itself is very beginner friendly for both developers and sysadmins, I find that RethinkDB abstracts away much of the complexity and provides an easy interface through both the query language and the web UI. This is more of an opinion but I also find the functional query language great for working with and the basic compile time checks have helped catch many errors. The performance of RethinkDB is not quite as good as other similar databases but this is rapidly improving and from what I have seen these performance improvements are not impacting the quality of the rest of the system. I think this is probably a more important point as other databases have tried to focus on performance over data consistency initially and had problems later down the line. I have also tried to make the Go driver as easy to use as possible, it has come a long way since the initial version (and its predecessor rethinkgo) and now includes some pretty useful features for connecting to RethinkDB clusters of any size. For people who are new to Go the driver can be quite different to the other drivers as Go is statically typed which means that API is slightly different, however once you get used to this difference it is in opinion easier to use than the other drivers. I hope my answers help, if you (or anybody else) has any other questions let me know!
Why the downvote? An explanation would be nice.
Ah. 
I haven't done much UI work, but my gut says you should try a goroutine that just manages the UI. Widgets, user input, IRC comms, would all send updates over a channel to the UI layer. This would then be responsible for batching the draw calls, and no mutexes would be required. So your widgets responsibility would be "process incoming messages; figure out draw updates, then put those in the queue." For batching, have you looked into a select statement with `time.After`?
Looks cool. It looks like the generated code is case-sensitive, so you could call it like `PillString(strings.Title(inputPill))` if you wanted your code to be more user-tolerant. :)
thank you, respect - frequencynine 
Thanks, that will be very helpful but right now I only need a physical one.
I'd be interested in helping. I've used osin quite extensively as well. I'll take a look around and see what I can contribute. If you have anything in mind, I'm happy to help with coding, reviewing, or whatever.
Why not https://github.com/campoy/jsonenums?
What kind of data do you think Rethink handles best? I.e., compared to Redis or Couch, or another nontraditional database. 
I'm working on a proposal titled 'Building a Web Startup in Go'. It will be about based on my experience at build https://localraces.com from scratch by myself in all Go. There is a little JavaScript, but only when required. Given that title what would you like for me to talk about? Consider this like an AMA, but if the question or answer is really good I'm going to use it in my proposal and not answer.
I'm in too, please pm a PayPal address :)
I know we are using it where I work to hold about 80GB of Geo-spatial data and it handles it all like a champ! Is it the fastest thing out there? Nope. But when it comes to managing the DB, scaling, sharding, and recovering from outages I can say it's been the best for us so far. I've found it REALLY useful when I'm starting out a project that may not have a solid DB structure - or one that may well need to evolve over time (though this can be said for other DBs like MongoDB). dancannon (maintainer of gorethink) has been really helpful in helping my sort out a few issues as well and responded SUPER quick (so I think you can expect he'll continue to maintain the driver). I DID have a few little issues (mostly of my own doing) when I wanted to start doing nested queries (joins) but I can show you some of my easy solutions for this if you'd like. Cheers! _G
Hey dan I'm currently trying it it and it's quite fantastic and easy to use, I just have one quick question I can't really find on the docs, when doing an update, is it possible to get the value of the thing that was updated? I'm updating something then wanting to use data from the row, but I'd rather just have it returned from the update rather than 1 from update and 1 from find
I am Nigerian prince with tons of money I donate, too. To prove your worth, please give bank account number and I will deposit $one million US. Thank you.
* main thread * UI thread * IRC Connection * IRC Connection 
I'm not sure if I follow you. The IRC connections have lots of program logic which I want to keep separate from the rest to avoid spaghetti code.
Where is the code? /edit: sorry, did not mean to be rude but you said you've altered djherbis example? I can not see a second link, only the wikipedia article? Would be interested in this. 
Closed source? What do you fear?
It's going to be monetized later.
you should add nginx...
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/bestof] [\/u\/gernest\_ asks the community whether he could borrow a computer. \/u\/callcifer helps him out.](https://np.reddit.com/r/bestof/comments/3z0ipr/ugernest_asks_the_community_whether_he_could/) - [/r/humansbeingbros] [\/u\/callcifer helps \/u\/gernest\_ get out of poverty.](https://np.reddit.com/r/HumansBeingBros/comments/3z0kbm/ucallcifer_helps_ugernest_get_out_of_poverty/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
It's doable, here's my thoughts on it though. - If you rip out all the apache modules and compare nginx vs bare apache, you get the same performance. - The target audience for this software tend to just end up reverse proxying nginx directly to apache anyway, so there isn't any gain for them. I'm likely going to just have it disable less-common Apache mods in a future release. On a side note, I've thought about having nginx just serving static content, but that'll add to memory footprint.
you can set up load balancer easily and from 1.9.1 nginx has option using socket sharding. https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/
Unfortunately I don't believe it is possible to read the updated document as part of the same operation, this is a limitation of the RethinkDB query language.
If you're not interested in using an existing router/mux library (of which there are *many*), then you can look at their pattern matching code: * https://github.com/gorilla/mux/blob/master/route.go * https://github.com/gorilla/muxy/blob/master/matchers/mpath/mpath.go * https://github.com/goji/goji/blob/master/pat/pat.go * https://github.com/julienschmidt/httprouter/blob/master/path.go The simple approach would be to use mux with a path of `/persons/{name}/stat` and then call `mux.Vars(r)` to lookup whether `vars["name"]` exists in 'a list of persons'.
&gt; Hey dan I'm currently trying it it and it's quite fantastic and easy to use, I just have one quick question I can't really find on the docs, when doing an update, is it possible to get the value of the thing that was updated? &gt; Hey thats a good question, I initially implemented the driver with stricter types however after some testing I realised that due to the fact that ReQL was designed for loosely typed languages that wouldnt really work. For example the following query is actually valid (I am not saying you should ever do this, it is just valid): r.DB(r.Expr("tAbleNaMe.").Downcase()) If I can ever think of a good way of supporting both use cases I will definitely update the driver to be more type safe.
If the path is simple, like `/person/name` then you can slice the path on the length of `/person/` func person(w http.ResponseWriter, r *http.Request) { name := r.URL.Path[len("/person/"):] w.Write([]byte(name)) }
awesome, thanks :) nothing concrete right now, I'll keep this PR updated: https://github.com/ory-am/fosite/pull/1
Will it be a good idea to use query parameters instead of paths. This is in terms of pattern matching and handler definitions.
i dont believe you,,
When I wrote it wasn't such a full field as it is now. I was familiar with the Android repo tool and liked the simplicity of it
Much, much better performance now. I'd check it out again :)
Thanks! 
https://github.com/davecgh/go-spew
Thanks for organizing this. :)
* [godebug](https://github.com/mailgun/godebug) * [Delve](https://github.com/derekparker/delve) * [Package log](https://golang.org/pkg/log/) Each has it's own pros and cons.
Write tests to uncover what you can!
[Rob Pike's answer to the question: "Are there any plans for a debugger?"](https://www.youtube.com/watch?v=VoS7DsT1rdM&amp;feature=youtu.be&amp;t=46m11s) &gt;There are plans for a debugger but they are very sketchy.
Since Golang [doesn't support](https://golang.org/doc/faq#overloading) function/method overloading, the only solution I can think of is to have a separate method for every type. I.e.: * `func DB(string) Term` * `func DBTerm(Term) Term` P.S.: I have looked into the official Java driver and got a little disappointed. public Db(Object arg) { this(new Arguments(arg), null); } public Db(Arguments args){ this(args, null); } public Db(Arguments args, OptArgs optargs) { super(TermType.DB, args, optargs); } If I understand correctly, it accepts any type and make all checks on runtime (just as JS driver) throwing exceptions if input arguments are of incorrect type: // RethinkDB Admin Console: Data Explorer e: Expected type STRING but found OBJECT in: r.db({"test": "xxx"}) e: Expected type STRING but found NUMBER in: r.db(123) That's pretty sad.
that was my first thought too but I couldn't set it up on my Windows
I used to use LiteIDE, after I started using atom.io but finally I selected VS Code due to its great integration with delve debugger
Delve doesn't support Windows yet.
fmt or log package. Or Delve (from IntelliJ IDEA) if the code is complex. There are still some issues with Delve but it's getting there. More support from the Go team for issues that slow/block development of Delve would be nice. 
LiteIDE uses gdb which has issues with Go. In my experience gdb is only useful in simple cases where println works just fine as well. For more complex situations it fails. 
I'll be there!
doesn't matter :)
yup, that's going to come in the close future! :)
Not that anyone cares, but he's an un-fucked version of the code: http://pastebin.com/knjwzVYC 
To be honest, it's always a pain to debug code in any language. Your best bet is to structure your software as much as possible into small independent pieces that can be tested (and unit-tested) quickly and easily. Inevitably you are going to have to test the integration of these components, and this is where having a solid logging strategy comes in handy. Debuggers are great in a pinch, however, if you find yourself regularly using a debugger then that is a clear sign your application is due for a serious refactoring. So, what do I use to debug my code? log.Println and solid unit tests, and only on rare and exceptional occasions do I fire up a debugger. 
You can use [http.HandleFunc](https://golang.org/pkg/net/http/#ServeMux.HandleFunc). In this function, a pattern ending in a slash defines a subtree (details [here](https://golang.org/pkg/net/http/#ServeMux)). So, you can register a handler function with the pattern "/person/" like the below example. package main import ( "net/http" "fmt" ) func handler(w http.ResponseWriter, r *http.Request) { if is_valid_name(r.URL) { fmt.Fprint(w, "This is a valid name") } else { w.WriteHeader(http.StatusNotFound) fmt.Fprint(w, "Error 404 - Page not found") } } func main() { http.HandleFunc("/person/", handler) http.ListenAndServe(":8080", nil) }
It sort of does. See issue [276](https://github.com/derekparker/delve/pull/276). You have to compile with a GCC toolchain for cgo to work on Windows.
Ah mispaste, sorry for the confusion. Fixed! :)
That is awesome! Will come in handy! I haven't tested it yet but I'm quite sure I'll use it heavily. :-) Thank you!
Works like a charm. 
What, so now we are posting repos that haven't been updated in over a year and have a grand total of 60 lines of code that don't do anything? Seriously, stop wasting our time. There is quite literally *nothing* here worth posting to this sub.
[removed]
No worries Gernest. Wish you luck! 
Guys, I have an Idea to help Gernest. It's simple. I used to get hardware for free for my projects in return for promotion and text ad. Sometimes I do security audit on devices. I found out that when you ask nicely to companies and they see a good cause, they'd be willing to sponsor stuff. So how about we'll collectively ask Lenovo/Acer/Asus PR to be a sponsor for gernest project? Idea: collectively tweet to Lenovo/Acer/Asus etc and link to this thread. If you like this idea, please reply with a cool hastag such as #UpgradeGernest 
I've commented on DI libs before, see https://forum.golangbridge.org/t/goldi-lazy-dependency-injection-framework-for-go/1280/4. Here's the [example](https://github.com/yourheropaul/inj/blob/master/example/main.go) rewritten using [idiomatic Go](https://play.golang.org/p/K3SWz-Lc91). When writing frameworks always keep an idiomatic example for comparison.
A word of caution. It's a work in progress PR which, by reading the comments in it, still has open issues and will have them after it's merged.
It doesn't modify the original slice, but the memory backing the original slice. A slice is just a description, (pointer, len, capacity), of a chunk of that backing memory. You are giving two descriptions to `copy` that happen to be pointing to the same backing memory. As https://golang.org/ref/spec#Appending_and_copying_slices says, they are allowed to overlap and it copies the minimum of the two lens. Your `copy(s[i+1:], s[i:])` is pushing the run of elements from i+1 forward one element, leaving duplicates at s[i] and s[i+1].
&gt; What's a better way to think about this? What is the problem with thinking about it exactly this way? Because that's exactly what is happening, it copies all the elements from s[i:] to s[i+1:], which effectively means, it moves them all up one element (to make slot i free to insert the new one). With a couple more elements this is more easily visible: http://play.golang.org/p/86FVKcZdha Perhaps your confusion is between slices and arrays? i.e. that a slice doesn't really carry it's own memory, but that it's only a view into an array and that the "elements" of a slice are really the elements of the array it points to. So s[i:] and s[i+1:] really point to the same underlying array (which is the same as s). Thus, copying the elements from s[i+1:] to s[i:] moves the elements of the underlying array up one slot, starting from i. By the way, I don't know what the intended effect of your code is, but if it was supposed to be an insert, i.e. changing []int{0,1,2,3} to []int{0,1,8,2,3}, it's slightly incorrect, as there is a slot missing. You need to do something like this: http://play.golang.org/p/ugnvSktSOM
That's a good point, and it raises some questions issue about the nature of the Go idiom (which I realise isn't, and couldn't be, centrally or canonically defined). What are the limits of magic, and how low a bar must be set to make something easy to maintain? To what extent could reasonable trade-offs between functionality and explicit, verbose code be seen as idiomatic? Now, I have no idea what the answers to the questions are, so I will no longer describe the package as idiomatic. I think that the structure and implementation of the code and the API are Go-y, but the concept is probably slightly outside the minimum way-to-go comfort zone. Thanks!
I wish I'd read that thread a few months ago, you make some very good and instructive points about the utilitarian concerns of programming. I would have pitched the documentation differently, and come up with a set of better use cases (I almost certainly will still do that). This package was born out of the extremely rigorous testing requirements of a bunch of similar-but-different medium-to-large e-commerce applications, where it added - and is still adding - a tremendous amount of value for the army of testers. I think perhaps I'm not being clear enough in the documentation that the package is for that scale of project, or for very hardcore BDD, and not the silly examples I used to illustrate how it might work. And thanks for the idiomatic example rewrite! I was so fixated on how to implement BDD-style tests that I forgot to compare it to good ol' simple and straightforward code. Unless you object, I'll incorporate that into the next iteration of the documentation.
The beauty of the go tools is that, all they need is the source and they just work. I am not sure why there's so much effort put into having an official configuration file while not exploring solutions that would work how the other go tools work. This is Go, not Ruby on Rails.
The mindreframer repository is not a real repo, it's just a huge repo of copies of other ones. 
Sure, go ahead. Also, with regards to examples, [read my rant here](https://medium.com/@egonelbre/obliterate-facilitated-code-480978338ffb#.su52km8iz).
Surprising to whom? Dependency Injection should be used as architectural pattern, and is therefore nothing a developer involved in a project suddenly stumples upon. To the contrary, it's a grounding base of the applications architecture and therefore to be understood by every participating developer. The goal is, as always, to get rid of complexity. With DI you do this by a technology that must be understood (and brings complexity on its own), but then helps to make things easier. For me, the principle of least surprise doesn't apply here. **Edit:** I wonder who downvoted this comment. As I understood Reddit, downvoting should only occur for posts that don't contribute to the discussion. I'd be really interested in why this comment didn't do that, so that I can improve my comment behavior.
&gt; 1000 Go Repositories And Houston, we have a problem ... already.
Before coming here, I tried to read your documentation and the examples, to understand what `inj` was trying to achieve. Unfortunately I didn't get any wiser, neither on DI or why it was a good idea. Without knowing more, I have to agree with the other posters here, that this seems like a really obscure way of sharing data, that could just be accessed directly. Furthermore, I am concerned about goroutine safety. I am sure you have that handled, but it isn't mentioned anywhere.
In your last example, you can also fold the copy into the append by appending the end of the slice to the beginning (with a little overlap). This is shorter and ensures that the append doesn't copy the whole slice (if the capacity was full) only to have the subsequent copy immediately overwrite large parts of it if inserting near the start. See https://play.golang.org/p/bUJdNpKIeB
In my opinion go-kit attempts to be a set of low level libraries designed for creating microservices. Micro on the other hand is a higher level "framework" for creating microservices. For example Micro comes with build-in tools such as the API gateway which are important parts of a microservices platform. Another difference is that Micro provides support for more languages than just Go (although Go is still the main language unless I have misread)
I thought about that too, but preferred cleaner and more understandable code. As OP is apparently a beginner with go and slices in particular, I didn't want to mix too many concepts in and instead illustrate the basics. :)
Nice work on the writeup! It's very helpful to combine go, databases, and some lesser known html features. 
Great writeup! 
Why would I use this for an abandoned text editor over a plugin that has years of work on it?
I am the author of Glow. It's trying to make map reduce super easy to write. Pachyderm is interesting also. 
Hi. Micro author here. I wrote micro based on my experiences in building a global microservices platform at Hailo (read more about that here https://sudo.hailoapp.com/services/2015/03/09/journey-into-a-microservice-world-part-1/) and my time at Google before then. The goal of micro is to provide a complete set of libraries and tools that will essentially simplify building and managing microservices. Micro will become a microservices platform but in itself is completely agnostic of the underlying runtime. So you can choose to use kubernetes, mesos, docker swarm or just run on VMs or bare metal. The focus is really on first principals which means the development aspect and then the tooling should provide the requirements to manage distributed systems. As Peter Bourgon mentions. There's a need for a discovery system and by default we use consul BUT discovery is entirely pluggable and there are other implementations for etcd, kubernetes and in memory gossip in the go-plugins repo. Every aspect of micro is pluggable so the choice for integration is completely up to the user. At Hailo we chose zookeeper for discovery, rabbitmq for communication, protobuf for encoding and ran our own orchestration system on AWS. We also use protobuf in Micro to strongly define APIs but encoding formats are a choice so you can use json-rpc, bson-rpc, etc which there are implementations for. So if you throw a request at a micro app with Content-Type application/json and a json-rpc encoded request the app will use the correct codec. Feel free to ask questions. Note: I will add. Micro is purposely opinionated. I found based on my experiences at Hailo and Google that an opinionated system essentially allowed you to put focus on what really matters, solving problems for the business. It also means people get distributed systems and scale for free by just using what's provided to them. Cheers
I see that you are saving the HTML/CSS/JS front end code in templates.go which I believe is a great solution for distributing/deployment. Nevertheless there are a few questions I would like to ask about this practice, since it's something I recently had to mess with: * Do you use some kind of tooling (maybe go generate) or do you directly edit template.go and in this case how do you format the template code? * How convenient is it to work with the front end code in this format during development? * Have you considered other solutions (like [go.rice](https://github.com/GeertJohan/go.rice) or [go-bindata](https://github.com/jteeuwen/go-bindata)) maybe if your front end code grows? Thank you P.S. Sorry that my questions are not Micro specific.
To add onto the above comment for anyone interested, the micro-dashboard that chuhnk linked above is one approach you can take to build webapps if you prefer to use JS frameworks instead of just templates. In this case we have a React+redux app. It's still an incomplete work in progress as I figure out how it integrates with the rest of micro. The architecture of how I would interpret *microservices web architecture* is where each webapp is self-contained and includes its own web server. Each webapp's own web server is a first-class microservice in its own right. To me, this basically means it can be discovered by other services. Currently it's not as straightforward, but micro-dashboard's service will fire up its own HTTP server and register the address and port to the registry. You can see it here: https://github.com/Margatroid/micro-dashboard/blob/docker/dashboard/dashboard.go So how do people actually visit your webapp within the context of a bigger micro setup? Currently, Micro's own web component is the entry point. It has a proxy feature that will forward all requests to micro-web.com/foo to any web service that registers itself as "go.micro.web.foo". https://github.com/micro/micro/blob/master/web/web.go#L288 By having each webapp have its own accompanying service which is also a web server, the service itself can act as an API between the webapp and the other services. It's still early days for frontend development for micro, but this is one approach you can take.
+1 for "piece of piss". I am Aussie too and have never used it to describe the usability of a database.
Well, I've gotta give credit for that idea to Bugs Everywhere, not myself. I've been kind of disappointed for years that distributed bug tracking never took off because it's such a useful concept. Being able to do "bug list" (or "be list") and get a context-sensitive list of outstanding issues for your current branch of whatever you're currently working on just helps streamline things so much. *My* idea, which this tool is based on, is to use the bug title as an identifier instead of a sha1 hash, and to store attributes in descriptive plaintext files. It's not, technically, as robust, but it means you don't need the tool to browse the database (for instance, you can browse the issues/ directory of my repo on GitHub directly) I think one of the reasons distributed bug tracking never took off is that existing tools are hard to use, so I wanted to try doing something that people can play around with the idea on an individual basis without going all-in.
care to develop? too small a data sample? repositories are not packages? what do you mean?
Thanks for being less lazy than me :)
HHAHAHAHAA I CAN REMOVE ALL SYSTEM FILES THROUGH MY GO PROGRAM ... crap
This is based on [Alan Shreve's talk from dotGo](http://www.thedotpost.com/2015/11/alan-shreve-conceptualizing-large-software-systems), so all credits go to him. It should still be considered a prototype: there are more rewrites that would further improve the output.
Thanks for your feedback! I interested to update this project with this idea...
While the idea behind the talk is great, the thing I really didn't like is how he spent the first 10 minutes of a 17 minute presentation with just pure fluff.
I am sure he would be happy to hear that feedback :)
Please be patient, when I have the pc i will be able to work on your PR. __EDIT__ : trying to change the tone. 
I learned C++ as my first language. Not too bad.
Thanks for sharing! That's a great and insightful talk, and I absolutely like the magicless approach, together with all those nice side-rants. For other readers, some of the points of the 45 minute talk are * DI/IoC-Containers are great if you have deeply nested dependencies; but only fewest applications really have them. * (Currently not applying to Go:) Dynamic Proxies (used to implement things like interceptors and AOP) are great, but for most people, problems can be solved with a lot less magic.
RethinkDB guys themselves claim you shouldn't try to shoehorn RethinkDB into storing very structured data (e.g. financial records - use Postgres, it might be faster), or into doing computationally intensive queries on data (use Hadoop or Cassandra). My guideline would be - if you are starting a small new fun project, don't be afraid to put everything into RethinkDB. If you're maintaining a production application, move data where you can benefit from realtime changefeeds, or any other RethinkDB/ReQL features you like. Any kind of JSON document should work well with RethinkDB. Not so sure about blobs. The main advantages are not so much being "good" for some type of data, but the features (changefeeds, joins, data explorer, clustering, ReQL), open development, upcoming features, etc. * For super-fast key-value storage, stick with Redis. * For fast structured data, stick with Postgres (if you're not hitting its bottlenecks and limitations) * If you found something you don't like about Mongo, try RethinkDB * If you're sick of SQL structure migrations (agile development, fast prototyping), try RethinkDB * If you want to join a friendly community of developers and users, try RethinkDB * If it's your first time with NoSQL databases, please do start with RethinkDB!
No, it hasn't been published - that's why I wrote this :)
This is one of many articles out there, that let me think at the end "ok, interesting introduction, so where is the tofu/meat of the article? Is there a second page, where do i have to click? Oh, wait, that's all. Well, blogosphere sucks." Edit: more edible phrasing 
Not everybody eats meat ;)
Qt binding for Go (Windows / Mac OS X / Linux / Android) https://github.com/therecipe/qt
Thanks for the feedback. Some quick responses: 1. As /u/Sphax pointed out, I need to work with a local git repository, not GitHub. The reason I used the Exec is that I didn't think a Go git library would be likely to support the esoteric options that I need to stash the index (ie. git stash create and apply) or support git clean, and in practice it's fast enough that "bug commit" feels fast and is relatively constant time, even with all the process invocation. I also intend to move that code out into a library/interface so that I can support other DVCSs (for some reason, distributed bug tracking seems to be a bigger thing in the Mercurial world.) I do intend to eventually add an option (or another app) that imports from GitHub issues, so I'll have a look at Go-Github for that. 2. Thanks! I'll look into them. 3. I've noticed that a lot of libraries seem to use []byte where I'd expect a string. I'll look into it, since that seems like a more Go-ish way of doing things, and strings don't seem to add as much functionality as I'd have expected.
It would be great if we could gather modern UI practices and gotchas with some added Plan 9 wisdom to create an awesome UI library.
It prints as an empty line in the terminal. It seems like this function isn't running properly
I'm not sold on this. However, thank you for not falling into the reflection abuse trap.
Yeah I also found out over on the Splunk forums that my first method is good but I need to add an intermediary before running the second method/endpoint. Apparently there needs to be a check to see if the first method finished on the remote server before I can run the 2nd. Thanks!
Thanks for your comment. But I don't want to sale it to someone, just share my work to the community. I would love to answer the questions or discuss.
Perhaps naming could have been better given that there is already pretty popular go project by same name - https://github.com/mattn/gom 
I don't know RethinkDB, so it's hard for me to give specific advice. In general, my advice for using packages that expose a lot of interface{} values is: don't.
Yeah! Reminds me of dokuwiki and how it keeps wiki articles in plaintext. Great all around.
I think this is probably considered an anti-pattern in Go. We have channels, or sync.Cond to achieve this kind of thing by communicating between the goroutines instead of "checking" for updates every ms by sharing memory. https://blog.golang.org/share-memory-by-communicating https://golang.org/pkg/sync/#NewCond
Looking at the package you mention, you can take two routes: * just pass a struct where the field names matches the fields in your row, or annotate the struct with **gorethink** tags just like you would do in json [example here](https://github.com/dancannon/gorethink/blob/master/encoding/decoder_test.go#L17-L19). * implement [Unmarshaler](https://godoc.org/github.com/dancannon/gorethink/encoding#Unmarshaler) on your structs and do the decoding in there. This is harder to implement by the looks of it. Take a look [here](https://github.com/dancannon/gorethink/blob/master/encoding/decoder_test.go), there's a bunch of types defined which should help you.
Well, without having one channel per goroutine, how does one send an alert to 100 goroutines? As for sync.Cond, I didn't know about it at the time. Must have missed it. Looking briefly at the tests, it looks like locks are heavily used, which I was trying to avoid, but that may be just how the test is set up. I'll have to give it a try when I get a chance. Thanks.
Note: you can make durations more easily and reliably by using `1 * time.Millisecond` instead of `time.ParseDuration("1ms")`
&gt; Polluting packages. I'm used to languages like Java where I can hide my private helper functions inside of a class without polluting the codebase... Go doesn't seem to work like that https://golang.org/ref/spec#Exported_identifiers
I *think* that I organized my Post struct https://github.com/mrnickel/StaticSiteGenerator/blob/master/post/post.go however my worry is that these structs will get pretty large...
Why do you want to hide your function from yourself? You have control of your package, and you don't need to worry about users calling it if it's unexported.
If it's any consolation, it doesn't grow super fast. If you get it to print hello world twice, or won't be 4.6 megs.
If you haven't already, look at https://github.com/spf13/hugo for inspiration and general feel for how things are organized in a well regarded Go-project.
on my phone so just commenting here so I can read over this tomorrow morning At a glance though it would be nice to have a reloadable config file.
And yet your code base can pollute quickly if any func can simply access anything.
It's been improved at the moment see [ all: binaries too big and growing #6853](https://github.com/golang/go/issues/6853)
In Go 1.5 max procs defaults to num cores ... No need to explicitly set it to this value.
FYI, you can save posts for later viewing. 
 try this : package main func main() { print("Hello World") } 
Glad you liked it!
That's a good suggestion. A shared package could be created that reloads the config when it changes and then reconfigures each of the components. Do you have a suggestion for how to reload the config file?
&gt; ... but all the models and views in one folder would get difficult to manage. Not really, it simply requires to (re)learn how to organize your project. It doesn't mean all your models/views will be in the same folder. It would be a fairer statement to say that related models and views are in the same folder, but that's not quite the truth either. In some cases you would have a "webserver" folder, which is an echo of the root folder structure... You organize based on *what is valuable* and *how value is created*. In your example case, I cannot suggest any structure, because it is not *valuable* ... I mean, you cannot go to a non-developer and ask whether they would buy it from you. I could imagine a fun conversation :) Q: What does it do? A: It's a website. Q: Yes, I understand it is a website. What can I do with it? A: You can login. Q: Why would I want to login? A: Because it's a website. Q: Yes, but what problem I can solve with it? A: You can connect to a database. Q: What is in the database? A: Your login information. ... 
Nice! I'm finishing up the first release of [a project](https://github.com/jordan-wright/gophish) I've been working on for a while, and it's nice to see the similarities in our approach. Thanks for the great read!
Thanks for this post. Very informative. 
Thanks for the post. I implemented something similar with Gin framework. My only gripe with Go, is that you can't further organise files. That is, under models have sub-folders for example. As these would then be individual packages rather than the models package. But this limited MVC is better than nothing :)
It is actually useful in scripting languages where you have operations that return strings (even if they are quoted). Like in a shell: &gt; x = 1 # is this a number or a string &gt; y = x + `wc -l /etc/passwd` # the "wc" command returns a string
As a long time Java developer I totally agree with you. All the places I worked, I notice this practice of over organizing artifacts. I hope this does not become trend in Go.
I went into this a little in my [go performance tales](http://jmoiron.net/blog/go-performance-tales/) blog post, but I've read significant portions of the map implementation since I wrote that. The reasons that integer keys are generally faster than string keys are: 1. hashing is O(n) on the length of the key (for ints N is static, for strings it's not) 1. integer comparison to find the bucket is a little faster 1. intgers can always be stored inline in the hash because they are always small enough They are both faster than hashing other types (eg `struct` types) because there are fast paths for strings and integers in the map implementation.
It's a *really* bad idea to recommend the built-in [print](https://golang.org/pkg/builtin/#print) function(s) to Go newcomers (and you meant `println` anyway). More importantly, it doesn't address the real reason behind the OP's FAQ (omitting `fmt` only saves ~1 MB, and understanding why is part of the question).
My initial simple naive recursive brute force [solution](https://play.golang.org/p/Qx3XgxlyMy.go) runs ~~as fast as yours~~[edit: on the problem input I was given, on my machine, without spending lots of time benchmarking, the `time` command reports they are both well under a second; thus in all reasonable senses, equivalent in time] without any such futzing. It also has has sane error handling.
Please, for the love of FSM, make security a central part of the book. It's 2016, we've had a long history of shitty insecure web apps thanks to crappy tutorials and books (i'm looking at you PHP). In a world of security headers, CSRF tokens, O-Auth, OpenID and Let's Encrypt, building insecure web apps is inexcusable. I did a quick search for the word "security" and it found one reference. I haven't read through much of the book yet though.
You should be able to get syntax highlighting for code snippets by using: ```go syntax in markdown.
Thanks to /u/Emporer_Earth for the nudge. [VODs](https://www.youtube.com/playlist?list=PLeGxIOPLk9ELh9tsPZMzau6CzMjfMzp9-) are appearing online now. (I've also updated the original blog post).
yes of course, I have mentioned in the book that security should be integral to application. The seventh chapter is on authentication and web security, once I write that I should be able to satisfy your concerns. Thank you :-)
Yes, you are correct, I attribute this mistake to multiple edits but no careful review :-D Thank you very much!
No worries! I think it's particularly important on the book description, considering that is what first impressions will be of.
Three back ticks is actually only available in Github flavored markdown. And yes it works for blocks. Anything between a start and end set of three back ticks is a code block with highlighting in the specified language. 
I think the OP's point is that security cannot be confined to a single chapter. For example, - When explaining how to make a form, you should explain CSRF and white-listing of parameters. - When explaining how to capture GET vs POST methods, be sure to explain the many security implications. (GET parameters are logged by reverse proxies and browser histories, web accelerators request GET w/o user clicking, GET is more likely to be cached, etc.) - Even when explaining web server development, explain the security implications of binding to 127.0.0.1 vs 0.0.0.0. (I.e. when developing, do you trust everyone on the local network? What if you open your laptop in a cafe that happens to be across the street from Defcon?) - Explain concepts like "never use a client filename without security scrubbing" and "security problems when using UTF-8" 
So, your approaching this problem from the entirely wrong direction. You should not care what packages you will need when you have an idea what your writing yet. Here the approach you should be taking: you want to build a bot that connects to Mumble. So find how a Mumble client connects to Mumble. Most likely your going to need a network connection so that tells you what you need already. Have you looked on the internet of Mumble libraries already exist? Is there one for C if not for Go? If so you can use cgo to leverage that work. Next is your functionality, what do you want the boy to do? The answer to this question will tell you more packages to import. Long story short. Start working on the project now. When you need something that you don't have find the package that gives that to you. 
Great work, thanks for the share!
This might help Go on ios: https://github.com/golang/go/wiki/Mobile#building-and-deploying-to-ios
https://www.nostarch.com/tangledweb.htm + OWASP's top 10.
This doesn't address your question directly, but I did a proof of concept getting a Go codebase running in iOS. The biggest pain when building the app was narrowing down the app's scope to communicate through what is really a very limited interface. Im not sure how you're building, but to build a library that works with iOS, you need to use `gomobile bind` gomobile bind -v -prefix "" -target=ios path/to/package/in/your/GOPATH
Basically, RTFM. :-) it is such a simple question that typing it in and submitting took more time than typing it in to Google which would have yielded an answer immediately. 
~~As fast as mine??? So, because your comment was condescending, I did some digging and testing.~~ ~~First of all, your solutions average run speed is =&gt; 71519995 ns/op That's ~480 times **slower** than mine. But I go one further.~~ ~~Since you are doing some brute forcing, your biggest enemy is the size of data. So I increased mine to the double of the original.~~ ~~BenchmarkCalculateSeating 1000 1394902 ns/op~~ ~~BenchmarkCalculateSeatingWithVendor 1 7354386458 ns/op~~ ~~Notice, how number of operations went skyrocket with yours (you are the vendor in this case) and the sample size was limited to 1 since it was running so slowly. Run time increased to a full 10s, where as my solution almost didn't even feel the change~~ ~~Now, I don't mind clever solutions. If your comment would have said, "hey dude, look this is some easy, awesome solutions without permutation and all the stuff, what do you think?", I would have answered, "Wow, that is awesome man. Great job and good for you for finding some other way around a problem.".~~ ~~But that was not the case. You don't have to be this way about things, we are civilized people here who like to learn, and share knowledge. Please, at least TRY acting like that.~~ edit: Well done, for finding a different solution which is more compact in size. ;) Good job.
What he means is that you need to swap out "Sneak Peak" for "Sneak Peek". :) It's the difference between a look into the future and a mountain hiding behind other mountains before it shivs you in the back like a. . .mountain.
You are right of course. Usually I am not. I just lost my temper there for a second. Though I tried to still be civil about it. :-) Thanks for the heads up. The second part. You are right again. This was a practice thingy but you are right in that I ignored a couple of things because I was focusing on the implementation, but it does make it much harder to read. I will amend that. Thanks again for your comment! :-)
Nice! This looks *very* useful as a generic expression parser, but the [list of unsupported statements](https://github.com/japm/goScript/blob/9783027d95b754001b04b8d14722821c26dcfe5e/eval.go#L182) is very large. Not everything on that list is solvable, but there is room for improvement.
The approach I'm describing is not just about the final structure, but also about how you arrive at that structure. If you implement database and/or authentication first, you've already gotten the basics wrong. *I'm currently writing about my approach, but research is difficult and knee deep in literature (only few thousands pages more to read) and tons of experiments to do + usual work day, is not very fast way to produce content.*
Bingo. I don't think there should be a single chapter on security. Every chapter should discuss security relevant to the context.
Learn how to handle errors. Just printing them and continuing with the execution is will crash your programs all the time. Maybe it's to early for you book project.
Nice! I wonder what https://github.com/golang/debug will be used for when ready.
Good point, I'll modify things today :-)
thanks!
They are homophones and a fault of the writer, i.e. mine, don't blame the entire language for that. I should have realized that when I wrote or while I read it countless times. My Bad.
Why?
If you mean the programming model: &gt; Processes in Elixir/Erlang are the equivalent of Goroutines in Go, lightweight threads of execution independent from the system’s thread. But Elixir implements Erlang’s actor model in which the lightweight threads are the main entity which is directly addressable. When you spawn an Elixir process you get a PID that you can use to send messages to that process, the process can pattern match the messages received to decide what it is and what to do. &gt; The channel of communication is completely transparent to the processes, and in fact multiple VMs can be connected in a mesh network so you can send messages transparently to other processes in any other computer in your network. Multiple processes can be bundled in process groups allowing you to send messages to the whole group in order to distribute the load. Since the network is transparent to the processes, there is no debate microservices vs monolith, you can switch between the 2 models with minimal effort. &gt; This actor model contrasts with Go’s CSP model, in which the communication channel is the main addressable entity and the goroutines are anonymous and can not be addressed directly. https://texlution.com/post/elixir-concepts-for-golang-developers/#processes
Well, I didn't implement database and or authentication first, I started out with my application, then i wrote the application and then I started working on this book. here I started out with models, views and thought that I'll add more content as I go ahead. I'll PM you on reddit.
You shouldn't need to recompile to update a blacklist. You should use a database, or hot reloading config file for updates like that.
This is an XY problem if I've ever seen one. Jeez.
A section explaining how to perform server validation after a POST would be useful. Are you going to use a Post/Redirect/Get (PRG) model? If so that could be a good way to introduce sessions. Also agree with the comments on security. Best of luck.
Great explanation! Thanks for sharing
The writing is a bit thick and you ramble on about other things rather then the main subject at hand (How to write golang web applications). The general section is almost like history lesson and it is somewhat out of the scope of the book. You should assume that your reader knows that information already, or put it in a different section. So overall needs much editing but that is to be expected. Code wise your architecture is intelligently laid out and it made me happy at it's simplicty. Good job, keep up the good work!
My idea behind the chapter for general talk was that when I was learning web apps for the first time it took me a *lot* of time to figure out what goes where, it might sound simple now that we have views templates and everything else. But I wrote it for someone who is totally new to web dev. This is a valid point I'll put it in a different section. Thank you about architecture! &gt;The writing is a bit thick I am sorry I didn't understand what you mean
Hey, Cool! I've been looking into creating something like this as well. Good to see how you implemented. 
That is a fantastic explanation. I'm glad it touched on the fact that processes in Elixir/Erlang are addressable whereas goroutines aren't. If there was one feature that I wish could be added to Golang with respect to goroutines it would be to be able to directly address them so they could be monitored. E.g. supervisor pattern.
I'm unaware of such a plugin, but to be honest one shouldn't be necessary. Dependency management and compiling are much simpler in Go than languages like Java, so normally `go build` is all that's needed. One way to fetch all the dependencies of a project you've already got is `go test -i`. There's probably a better way, but I don't need it often enough to look for one.
Yes, I am. If you can find the time can you initiate some content?
Awesome!
Yeah, I'd probably just go with a `blacklist.txt` file - have your program read that file to get the list of users to block every time it starts up, so all you have to do is edit that one file.
For those still in doubt of the veracity of this, hopefully /u/gernest_'s [GitHub profile](https://github.com/gernest) helps add some genuineness. 
i need to have the build artifacts stored in an Artifactory repository from where our automated deployment systems finds artifacts that are to be deployed. Maven is the easiest way to get deployment to happen, and the vast majority of the code going into this repository is Java. Using a Maven cmake plugin I was able to get to where a C++ program is being managed in this fashion - was just hoping to do the same for a Golang program.
I wouldn't fight the type system here. Go really doesn't want you to write generics like this, so don't. I would pass closures over a `chan func()`. By using a closure, you can capture arbitrary state when you make it and write any number of things to a "return" channel. Anything else you do will have way more `interface{}` and reflection. package main func main() { funcChan := make(chan func(), 2) resChan := make(chan string, 2) funcChan &lt;- func() { resChan &lt;- "hi" } funcChan &lt;- func() { resChan &lt;- "hello" } go func() { for f := range funcChan { f() } }() println(&lt;-resChan) println(&lt;-resChan) } 
Why?
So the context is, I'm developing a web app. This web app has a button, when clicked, makes the server call an API ~15 times. But this API only has a limit of 1 call per second. Therefore I need to rate limit my calls. I don't want to drop the calls, but instead place it in a queue so all the calls will eventually complete. I have NO idea how to do this. What I'm confused about is how I would be able to use channels and a ticker/timer to process concurrent requests. To further elaborate, I then had this idea where I send functions over channels so as I place them in the queue and tick them off one by one, I can send them back to the function that originally created the channel, which had created a block so it would wait for something to return from the channel (&lt;- this is what i really don't know how to do... the wait for return part with concurrent requests).
You idea seem interesting. The example repo you provided "knowledgebase" is it a SPA? I am used to mode/view/routes to identify the pages. How do i go about here?
CSP vs Actors? That's a matter of taste. If you mean the whole network transparency thing, depends on what your app does. Erlang is a higher level language designed for distributed "control plane" applications, the abstractions it provides can have big performance costs when applied to other problems. Go is a lower level, more general purpose language.
You can encapsulate all functions in functions of type func(). When you send them over the channel, put the function invocation in a closure inside these simple functions.
It's down. https://godoc.org/github.com/gorilla/mux
I am asking why did they include Go
Mode/View/Routes are less important in an application than the content on the pages - i don't disagree. Hence my question was related to the entry points. Usually by looking at the urls i can identify the location of the mode/view/controller. But the repo code did not provide any easy identification.
As types are deducted, having this rule allows you to control the resulting type. Supose you receive a json with undefined field types and you want to operate through them, casting and converting all would be meaningless for the expression purpose. Besides that, nothing is written in stone, any convenient rule that avoid tons of casting can be implemented. Other options could be fail on conflicting types or implement a type hierarchy where ej: string &lt; bool &lt; int* 
When I write a command line tool in Go, I tend to shove all the arg parsing and flag handling into an `init` function. I don't know if that's considered good style or not, but it works for me.
&gt;It's for an application for operation nunya. &gt;as in nunya business. &gt;--- &gt;Now that I got my shitty snarky remark out of the way, I am making a "ban" list for people if they abuse a system on a server. I want to update that list without having to reinstall the program every time. What a dickish response to a reasonable question. Your approach is dumb by the way; you shouldn't be recompiling a static hardcoded list for a ban list, that's idiotic. Use a text file or a DB.
Alright, here is the codez: https://play.golang.org/p/XZvb_4BaJF *Notice that it's not perfect. You have a queue that is executed every second. If the queue is empty and a new item is added, the new item can wait for almost a second before being executed.* But this should get you very close to what you need anyway :) This code can be split into 3 section: * The rate limited queue executor, which I call the server (I'm horrible at naming things) - The server doesn't know anything about the functions. All it does is start a never-ending goroutine that pops the oldest function in the queue, once every second, and calls it. The issue that I talked about above is in this section of the code BTW and I could help you fix it if you want. * The Button Click functionality - This shows you how each button click could call 3 diff functions (you could obviously make more/less function calls) using the server and make sure that they are each 1 second apart from each other. You can even add a timeout to any of the functions (to fake latency) and they would still get called 1 second apart. This is the only place that you need channels because you want to make all the function calls as fast as possible (if the first function takes 5 seconds, you only want to wait 1 second to call the second function) and then wait for them to finish so you need to know when they are all done. * The Button Click simulation (the main func) - this just shows that 3 button clicks would work as expected. You can also put them in a goroutine to simulate 3 users clicking the button at the same time and it would still work.
This is one of the few cases for the sync library. Specifically, a mutex. var rateLimiter = sync.Mutex{} func rateLimitedRequest(w http.ResponseWriter, r *http.Request) { rateLimiter.Lock() //make your synchronous rate limited call here go func () { time.Sleep(time.Second) rateLimiter.Unlock() } () //Handle the rest of rateLimitedRequest here. } Or, you could do it with a buffered channel. https://tour.golang.org/concurrency/3 var rateLimiter = make(chan bool, 1) func rateLimitedRequest(w http.ResponseWriter, r *http.Request) { rateLimiter &lt;- true //make your synchronous rate limited call here go func () { time.Sleep(time.Second) &lt;-rateLimiter } () //Handle the rest of rateLimitedRequest here. } The buffered channel approach would allow you to rate limit it to n per-second (whatever your buffer limit is) instead of just 1
I was looking at that. I'm still looking at your code. I'm a newb so it's good to see how this was implemented. 
Just on light side of things, never call the language as golang on go-nuts channel, people get really mad at you :D
Good thing you can run it locally, eh.
Instead of `go run`, try `go run -race` instead. Although the 3 job variant seems to run smoothly, it too has a data race.
In the mean time you can run godoc for packages you have locally downloaded: 1. `go get -u golang.org/x/tools/cmd/godoc` 2. `godoc -http=:8080`
I'm not sure I follow, but don't forget that your custom DateType is still a time.Time, and behaves exactly the same (other than any additional methods you decide to tack on). You just need to assert back and fourth to get access to each set of methods. Maybe post a little more info about what your trying to solve for?
Silly as it sounds I'm creating a very simple ORM. Instead of using reflection to handle conversion between Golang struct "models" to a SQL type, I'm creating my own types and "Fields" that go in the models. As of now, I've gone back and decided to just set the value in DateField to time.Time like I had it originally. I may return back to custom field types and will utilize what you've told me for the time types.
/u/slimsag gives the answer below, [check it out](https://www.reddit.com/r/golang/comments/3zv5yr/is_godocorg_down/cypiwgl)!
Elixir (Erlang with nicer syntax) is Go's main competitor right now when it comes to high traffic, high performance web servers, IMO. Of course, like others have said, it's not as good for CPU heavy tasks, but for most web stuff it's very promising... It's a totally different language though. Completely functional (not multiparadigm) and embraces modern FP language features. I think a microservices approach that leverages both languages for things they excel at could be very powerful.
Main author of OAuth2 spec believes it's so bad he wants nothing to do with it: http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/
FYI in case you are unaware of it's existence: https://github.com/jinzhu/gorm Haven't used it myself yet, but I have a project coming up that i plan to try it on.
Next time you have a problem with a blocked goroutine I highly recommend using the net/http/pprof tool. You can get a goroutine dump and see what every routine is doing.
Yep I know of it and have used it a bit. I'm just writing mine to, well, just write it :D Nothing exotic as replacing it but I will show it off once I'm done, I am proud of what I have so far.
Thanks, I was kinda looking for this, but haven't tried it yet. I was thinking of doing something like this last night just as I was about to go to bed LOL. #duckdebugging
Thanks! This made a lot of sense
This is a great start. I don't know how far you, but I'm going to list a few things that I would change/add: * You explain how web applications in Go work, which is valuable, but it's not the best way to teach how to make one. This is because when you teach how something works you want to dissect it into the smallest parts and discuss each section, but when you show someone how to accomplish a task, you should demonstrate the fastest and most reliable approach. What I'm talking about is obviously frameworks. I think that it's great that you don't focus on any frameworks, but you should really teach people how to set up their code so that they could use frameworks and maybe even list some that people could look at for different sections of their application. * Routing is a big deal if you're making a web application or a server and I think that you should focus more on that. At least separate routing logic from your handlers. Seeing your handler check the method and/or process the URI was a bit painful since that is a clear job of the router. * I did not see form submission/validation. I would even show how to submit a file. * Modern web applications are usually written in JS so I think that you could have an entire chapter on that. At the very least, show how to route an Ajax request to a handler, unmarshal the JSON into a Go structure, do something with it (save in DB) to create an updated Go structure, marshal the updated structure into JSON and use it as your response. * Sessions/cookies are very important to a web application so I think this needs a section. Maybe even show how to create a log in? * People already talked about security and I think that they are very much correct about this. Security is huge. * One of the best things about using GO is scaling and performance. I understand that this book might be for beginners, but people should know the main advantages of using Go for a web application (being able to build huuuge web apps/servers). I would even say that if you seriously want a small web application then Go is probably not the best language (even though I love Go). So some suggestions would be to show how to talk to a DB over http or sockets because a scaled web application will not have its own DB on the same box. You could also show how to do basic caching. As I said, this is a great start. I wish I had this resource when I was starting with Go! :)
OS X netstat output: I believe *.8080 is ALL addresses. Not a good security practice if it is confirmed. Active Internet connections (including servers) Proto Recv-Q Send-Q Local Address Foreign Address (state) tcp46 0 0 *.8080 *.* LISTEN
Thanks, all the posts here helped, I think I'm going to use something like this: https://play.golang.org/p/dNzqmD9qjO
I have a package (not public) I developed to provide a strict subset of bearer token authorization. I mention this to share my thoughts that so many do-everything libraries out there have so many vectors for errors that it makes me uncomfortable. When I only need a specific path through those features but functionality unrelated to my needs are apt for abuse and thus my app can be abused, I'm troubled further. With that said, an oauth package with parts I could compose simply to provide only needed functionality might entice me to at least consider it.
was thinking the same after i wrote that. so i added the edit.. good thing that godoc don't has a default `godoc -http` is not working but it could have a note in the `godoc --help` page
FYI: the reason it works with ints and strings is, that you aren't using ints and strings, but untyped integer and string constants. A literal 42 or "foobar" has no type, only when you assign it to a variable or use it in an expression does it get one and it's the type that's needed at that point (with a default of int/string). Effectively, that means if you do type Foo int var foo Foo = 42 the 42 will have type Foo. But a time.Time literal *is* typed, so you can only assign it to a variable/field of type time.Time.
One more thing, the framework is designed to be replaceable, so if you don't like my implementation you can switch it out for yours.
This is looking really good, you might want to share on /r/security as well. As far as I can see with this implementation the OAuth token is still a golden ticket, if an attacker can get at it in the network stream they can do whatever they like. 
You seem to be only committing on the 'unstaged' branch -- this makes use with 'go get' out of the box non intuitive.
This is intentional because the API is not finalized yet and I want people not be hit by BC breaks every day :)
https://www.reddit.com/r/security/comments/3zy5zj/im_building_the_most_badass_securityfirst_oauth2/ :)
I never understood why these people don't just use public key crypto. Just sign a short random string with a private key and do the verification via checking if the signature matches. Tada, unfakeable serial numbers (modulo, of course, the problem of reuse, but that is either impossible to solve anyway, or the solution is the same as for regular serial numbers).
Good information. I was wondering why I was able to do it without anything yelling at me. Thanks Merovius
This is EXACTLY what I was looking for. I wanted syntax highlighting in markdown and I couldn't find any easy way to do that! Thanks! What languages does it support?
Thank you for your feedback, I'll notify when I work upon all these comments. &gt;I wish I had this resource when I was starting with Go! :) I am flattered :)
i will do my best!
Could you refact the lib without GORM depends?
sounds good, but there readme is so poor one can't understand what this tool is supposed to do. And why one should try it. 
hmm that is the hardest part of opening a github account :D finding a proper handle
It's probably best to always be explicit, but calling `Load()` with no params will load the environment in the file named `.env` so.getenv alone won't work unless the variable is already in your environment
Even though it is limited to scripts you define, it is definitely the first attack vector I would try if I knew about it. Certainly a good dos target. 
It's sad to me that the Go solution is to write a new map function for every combination of types you're interested in mapping to/from. Other languages get by with a single map function, but to achieve equivalent versatility, Go requires N map functions for every type (where N is the number of types) or N^2 map functions. Of course, N is infinite, which is very bad news indeed (at least, if you care about type safety or code readability). It's more troubling when we consider that map() only operates on two types. Consider algorithms that operate on M types! The Go solution is to write N^M functions to achieve the same versatility as some other languages (at least without giving up static type safety)! :(
its not problem, just write the For loop instead of
&gt; At least separate routing logic from your handlers You know, I have gone through some open source go projects that the go authors themselves wrote/ folks from google wrote, they do this check in the handler itself, it made sense to me, so I used it this way.
&gt; One of the key features of PKV is that it is easy to revoke product keys because both for business reasons (customer changed his mind) or security reasons (evil customer leaked product key). I don't see how this is at all easier with PKV than with my scheme (let's call it Signed Product Keys -- SPK). I would claim it is probably even harder. You would somehow need to transmit the information about the revoked key anyway, in my scheme you can do that with, like, a couple of bytes of the signed data (which could just be sequential integers). Doesn't get any easier than this. &gt; The problem with using asymmetric crypto is that you would have to externally verify that the public key still is valid in order to make sure the product key is still valid to be as unbreakable as you assert. Since if the private key was leaked, you have to find a way to invalidate all product keys generated with it. Why do you see the private key being leaked as more likely than your algorithm and inputs being leaked which would give the same ability to crackers? This sounds like an unfair asymmetry in assumptions to me. In an abstract way: In every possible solution there is an algorithm with certain inputs and given both, arbitrary many keys can be generated (by definition, because that's what you are doing). There is no difference in how likely this is in different solutions, so this scenario can not be used to argue in favor or against a certain solution. &gt; (which might add up if you want to revoke say 5k product keys, whereas including a blacklisted PKV key needs only a uint32) A blacklisted SPK only takes up exactly as many bits as you need to encode it's ID. A uint32 is probably completely safe (it certainly is, if it's safe for PKV). Again, there is no asymmetry here: If you have N different keys that you want to blacklist individually, you need at least log₂(N) bits to distinguish them (from an information theoretic point of view) in both schemes. If you just sign this log₂(N)-bit identifier and use the signed thing as a product key, you need to transmit (at whatever time and in whatever way) at least log₂(N) bits for each blacklisted keys, which is the minimum (also for PKV, as I said, from an information theoretical point of view), so this is not a disadvantage. &gt; but this would require additional checking logic, too Yes, the checking is a lookup in a sorted list (or some other implementation of a set with lookup, like a hashtable). That's about 3 lines of code in any language, at most, and takes pretty much no time at all for all reasonable sizes of the list of revocations. And again, I claim, that this is pretty much the theoretical minimum, as you *somehow* need to check your key against membership in some revocation set in every solution that allows revocation. &gt; With async crypto, if done correctly, that would require you to manage multiple public and private keys, basically forcing you to set up a whole PKI with revocation lists etc. I disagree. For example, if you sign sequential integers, you simply need to include a cutoff-point per version into your code. Or just include the version number in the signed data and check against that. One Keypair, same power, negligible overhead. And, also here, there is no difference between the solution, as you need to *somehow* include this information and whatever much information you need for that you can just include in both cases at exactly the same time. I am very confident that there are no serious disadvantages to SPKs, to the point where I would be happy to write down the appropriate protocols to get a strictly better feature set than PKV. Plus the trust, that what you are relying on are actual algorithms designed for security and battle-tested by hundreds of researchers around the world.
It's almost like a lack of generics is a barrier to providing the functionality people want.
For all intents and purposes, shell scripts cannot be made safe as a web-service. If you are exposing a shell script to the internet, you are giving anyone with access to that script remote execution privileges on your host. This has been known for a long time. There's a reason that UNIX hosts do not permit you to set the SUID or SGID bits on shell scripts.
net/http wrappers in Go have become the new "JavaScript framework". Every day a new one and it's not clear what benefits do they bring over the old one.
Also note, from [the documentation](https://golang.org/pkg/testing/#hdr-Examples): &gt; The entire test file is presented as the example when it contains a single example function, at least one other function, type, variable, or constant declaration, and no test or benchmark functions. 
Well, I think you are looking at it from the wrong point of view. Go is a system language in all of its glory. C doesn't have generics and it gets by just fine. There are a couple of ways you can work around it with templates but that's it. And to be honest, last time I used maps and reduce and filter was with java, ruby and python. :-) And I very much hate Java Generics. Don't get me wrong, I know that they are useful. But they make for a freakishly convoluted and complicated read all together. :-) I mean, look at this: public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z) Also, to be honest, I only used those syntactic sugar methods because they were available. But I actually could have written a much more readable for cycle. Now, again. These methods are useful of course, they do have their place. Just not in Go. This language isn't built that way. And that's one of its features for which I fell in love with it. But it might not appeal like that to others. And that is okay. :-) I'm a jealous lover anyways. :-)) 
I know generics are a bit of a sore point in the Go community. I do think the language would be better if it had them, but on the other hand no generics is probably better than something ugly like Java-style generics.
I couldn't tell your tone obviously, but I was hoping you weren't suggesting that not having generics prevents the ability to deliver any application functionality. I am not going to going to debate developer efficiency, but in no way are generics required for delivering any type of software.
Some time ago I also built server to expose shell scripts as json rest http server, you can find it here https://github.com/phonkee/goexpose It can do much more than just shell scripts..
As /u/RandNho suggested, it would be interesting to add support for channels to go-itergen. It took a while to get the time to do it but here it is.
For loops aren't very composable compared to `map()` and friends. The ceiling on abstraction is low.
Yea agree, I really like this library but not being able to define my backing store is a deal-breaker (we use event sourcing with Redis and DynamoDB).
Is it possible to fix your eyesight? How much would it cost?
Meh, people are always going to want to share their own solutions for things – it's the nature of open source. The beauty of Go is that more often than not the standard library can do more than what you need.
Any idea what the security problem is yet?
Might be related to a padding oracle attack in the TLS code that Filippo Valsorda fixed https://twitter.com/FiloSottile/status/679514109747015680 / https://go-review.googlesource.com/#/c/18130/ \* edit: never mind, that's slated for 1.7.
Thanks! I did my best to design it as smooth as possible.
This won't compile (go test) either, since you'd have two conflicting test packages in the same directory.
I would say no. The concept of a function should be a small standalone unit of work that does one thing. If you group all of the logic for multiple end points into a single you violate this principal and create an easily avoidable section of potentially bug ridden code. 
It's a known vulnerability not specific to Go, the author of the TLS implementation made a comment: // BUG(agl): The crypto/tls package does not implement countermeasures // against Lucky13 attacks on CBC-mode encryption. See // http://www.isg.rhul.ac.uk/tls/TLStiming.pdf and // https://www.imperialviolet.org/2013/02/04/luckythirteen.html. So it's been known, and yes there are exploits.
How does this compare to Hashicorps CLI library in real world usage?
Quite favorably, I dare say!
If you want to set a filename hint, you can also add: w.Header().Set("Content-Disposition", `inline; filename="myfile.csv"`)
awesome thanks!
https://golang.org/security#tmp_3 &gt; Fixes are prepared for the current stable release and the head/master revision. These fixes are not yet committed to the public repository.
I don't see anything wrong with having error always be nil for the in memory implementation. This is what happens with bytes.Buffer: https://golang.org/pkg/bytes/#Buffer.Write
well, if it's good enough for the standard library, it's good enough for me. thanks!
Thank you both so much captncraig &amp; allhatenocattle, that worked beautifully. Just in case anyone was interested, I tried a quick proof of concept to serve an xlsx file instead and it worked a treat. package main import ( "fmt" "io" "net/http" "github.com/tealeg/xlsx" ) func main() { http.HandleFunc("/test/", serveSheet) http.ListenAndServe(":8080", nil) } func serveSheet(w http.ResponseWriter, r *http.Request) { w.Header().Set("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet") w.Header().Set("Content-Disposition", `inline; filename="test.xlsx"`) spreadsheet(w) } func spreadsheet(w io.Writer) { var file *xlsx.File var sheet *xlsx.Sheet var row *xlsx.Row var cell *xlsx.Cell var err error file = xlsx.NewFile() sheet, err = file.AddSheet("Sheet1") if err != nil { fmt.Println(err) } row = sheet.AddRow() cell = row.AddCell() cell.Value = "I am a cell!" err = file.Write(w) if err != nil { fmt.Printf(err.Error()) } } 
Thank you - answered my next question before I even asked it!
What should I do if I wanna use another data provider?
You means like Redis? just use the redis connection in the callbacks. I think you will hold the redis connection in a config package, so just use it in the callbacks is ok.
A few more questions. Why do you call it "service" (is every Go package a service?) and what do you mean by "transparent"?
I added a disclaimer in the repo. I actually shouldn't have built this program - the more I think about this. Thanks for your feedback guys, somehow I was so deep into having fun with Go I didn't realize that this is the terrible CGI we escaped from all over again. Next time think, then build it.
Previous discussion: https://www.reddit.com/r/golang/comments/3zw91k/im_building_the_most_badass_securityfirst_oauth2/
What is this and why: https://github.com/ory-am/fosite/blob/unstaged/rand/bytes.go
You can just create a struct representation of the JSON to easily unmarshal it in. Something like type GeoLocation struct { GeoLongLat string `json:"geo_longlat"` } Here's an example in the go playground: https://play.golang.org/p/brVaEAKNaq
Here is a working code: http://play.golang.org/p/gzNRFXNk2B "{}" is only for "object" notation". If you want an array, you should use "[]". "{-96.8207,32.7825}" is not valid JSON.
This is the solution you want. But if you actually want to traverse JSON recursively, well I've done it for something if you're curious https://github.com/quii/jsonequaliser If you could tag code as NSFL this would be it ;)
The value n your `geo_longlat` isn't valid JSON that can be unmarshaled into anything but a string. https://play.golang.org/p/s1SWQNUqRt 
Huh? Edit: I think, I got what you mean. You mean to say I should stop using passive aggressive redirections? I wasn't trying to. I seriously wanted to say that whatever he likes. I dint want to tell anyone what to like. 
Thank you for kind words.
I'd be interested in joining or creating a team if anyone's interested. I'm a web dev with most of my experience in javascript (frontend frameworks and node based services and CLI tools) and mongoDB. I've built one simple REST service in GO + Mongo. I don't have any ideas for a contest app at the moment but there's still plenty of time.
C'Mon cherry pick more 'bad' stuff from java. look at c#: T Max&lt;T&gt;(T x, T y) where T : IComparable C doesn't has generics because It's kinda old and not that easy to implement. But C also has less overhead by design than Go. The way C targets low level is completly different. You should really look into this before you start talking about this. However C has a kinda strong way so called Macros. A macro could be easily used for simplify a Max 'function' into one line. Also almost noone writes a web server itself in C nowadays. Lots of people just use C for performance reason and then use js or python or whatever in addition Talking about generics is for me no discussion if It should be implemented the only discussion for me is how It should be implemented. Also the question is what are generics?
a) the geo_longlat value is just a string for json. So that's all you're going to get. b) you are seemingly trying to decode the string contained in geo_longlat as json. But it's not actual JSON, it's something else. {} in json denote objects, so they'd need keys that aren't there. You might try something like this: http://play.golang.org/p/S1wOCmAXdr i.e. rewriting it to be valid json, but that might be brittle and lead to unexpected results if you get weird values. The real answer is that the people whose API you are using should make their stuff correct and replace `"{-96.8207,32.7825}"` with `[-96.8207,32.7825]` because there is no reason why this can't just be json all the way. 
The different is all db operations in the callbacks is in same transaction, that's means you could make sure data consistency. For example, I have two callbacks, the first callback updated some attributes, like changed `available_quantity`, but the second callback find something wrong, so the state should not be changed, and the `available_quantity` change made in the first callback should be rollbacked. In this case, transaction will help that.
You can just open the logfile and set the Stdout/Stderr of the [exec.Cmd](https://godoc.org/os/exec#Cmd) to this file. No need to do any Copying or piping.
To do an external test package, you should add `_test` suffix to the package name. So try `package thing_test`.
The go get step is not needed AFAIK, `godoc` command comes standard.
i could just tell you to search through the group, but instead i'll try to be more helpful. check this: http://www.infoq.com/presentations/go-gc-performance see the slide around the 27 minute mark. that leaves a lot. and i mean _a_ _lot_ of room for applications. notice that we're talking 200, 250 gigabytes of heap sizes now! 
Here is another example on usage I usually create a wrapper function like so https://github.com/go-playground/generate/blob/master/misc.go#L12 granted this example is just to the console but could be written anywhere
No need for the extra layer of complexity. The net/http does it perfectly!
That step insures that the binary has the latest updates. It also installs it if you don't have it, which would be the case if you installed via source according to [the Go 1.2 release notes](https://golang.org/doc/go1.2#go_tools_godoc) when it moved to the tools subrepo.
I've waited for this to be a reality ever since node knockout two years ago. Thanks for helping put it together!!! Edit: will there be t-shirts. ;)
the other posts dealt with logging so for the execution i would put it in a go routine `go cmd.Start()` if that doesnt work... use a function go func () { cmd.start() // log } fmt.Println("app continues").. at least it will not block. logging... from http://stackoverflow.com/questions/18986943/in-golang-how-can-i-write-the-stdout-of-an-exec-cmd-to-a-file go func () { cmd := exec.Command(...) outfile, err := os.Create("./out.txt") if err != nil { panic(err) } defer outfile.Close() cmd.Stdout = outfile cmd.Stderr = outfile err = cmd.Start(); if err != nil { panic(err) } cmd.Wait() } havent tested this =O. hopefully it helps
You don't know at compile-time what type your mapped function will return? That's not a program I ever want to debug, sorry. Edit for clarity: not your `Map()` function, the mapped function that you're applying across your data collection.
I see, makes sense about installing from source.
First off, Go is OOP. What it's not is inheritance-style OOP. Structs and Interfaces encapsulate the entirety of OOP. Organization is generally by functionality. A package is a piece of functionality, with the file contents completely dependent upon dev preference.
The pause time is when all free memory is released to the stack/os. The entire stack and heap are scanned between STW pauses, so stale objects aren't ageing through multiple cycles.
Is there an advantage to do both a flush and sync? I have been looking at using mmap for my project and found that some people use flush and others sync and some even neither. 
I think Image Processing could be interesting. One cool thing that the Golang stdlib has is gif support, you could try something with that. I'd imagine XML parsing could be done much easier via Unmarshal, personally. 
Is there anyway you can just copy source files across rather than using big formatted strings? In terms of long term maintenance, having the static typing will probably catch some bugs.
Go has a concurrent GC that normally uses 25% of your GOMAXPROCS threads for concurrent operations and only pauses for some cleanup work (which gets less with each release). If the GC can't keep up with your allocations it will force your goroutines to assist, thus slowing down allocations and shortening GCs. Also with Go 1.7 (coming out I think fall) the sweeper will be mostly "removed" (see https://github.com/golang/proposal/blob/master/design/12800-sweep-free-alloc.md)
I wonder what is a reasonable default `CHMOD` for a directory (e.g. `views/` or `controllers/`)? 755? [777](https://github.com/Gacnt/GoWebGen/blob/master/createfolder.go#L9-L26) is too much privileges, isn't it (cc /u/Gacnt )?
+1 for copying source files. OP, look at the approach used by Revel Framework. They have [`skeleton`](https://github.com/revel/revel/tree/master/skeleton) directory. When you run `revel new /path/to/project` it copies everything from `$GOPATH/.../revel/skeleton` to your destination directory. Along with this some files are treated in a special way (e.g. `your-key` may be generated and inserted).
1. Netflow (v5) Collector 2. Caching Proxy Server (a-la Squid)
Hi. This might help you. http://blog.sgmansfield.com/2016/01/an-analysis-of-the-top-1000-go-repositories/ It's a blog post about analysing a 1000 large go repositories and how they are structured. Might shed a light on how the big ones do it. 
make app to generate ideas of what app to make
http://gofy.cat-v.org/
I'm in Portland OR but it looks like the contest is done remotely. And registration is closed already?
Author here, any feedback about the code itself or the format of the post are welcome :) Thanks OP for sharing this :)
Aren't those directories for your own use? Unless you advocate them to be 0700 I think 0755 is the most reasonable choice.
Never really had this problem. What do you do everyday? What's kind of a pain in the ass? Start there. Start scratching that itch and you'll never run out of new things to do. There's always a better way to do everything.
How about a simple Markdown Books builder and publishing app? I have just started working on it. The source is https://github.com/gernest/pablo Im doing it so as to help people in my country have access to books. 
Tbh I'm a scrub when it comes to file permissions, I just googled and 777 was the first thing I seen. 
I am glad that more people are thinking about project generator. It provides more flexibility than full blown web framework. Less stress when upgrading version numbers too. If you haven't look already, http://go-bootstrap.io generates web project, just like yours. I created it to minimize busy work when building internal app or micro services.
Good idea, I didn't know how people wanted their keys to be generated, I could bcrypt a uuid or something or maybe just use a uuid 
A suggestion would be perhaps write the skeleton generator as a cookie-cutter template in Python? I know the purpose of this is to have a go project generated in GO; Though with the power of Jinja2 Templating, and the ease of python you can make some sweet project templates for your project. I use CookieCutter to generate SpringBoot applications in Java! The other option is to write CookieCutter (Python) inside GO! Nonetheless, what a great resource!
I am quite interested in something like that, would you mind sending me a link as well?
What I'm saying is that it doesn't matter, because permissions of your views and controller directories is irrelevant to security of your *running, compiled* Go program. What you want to set them as on your local machine is irrelevant in this context.
It's a little easier for them to do that, because their imports are sourcing their `github.com/revel/revel` so they can just put that in their `.go` files, I'm trying to make `GoWebGen` independent of that and to be able to use the controllers that are generated in the directory, I could do it like `revel` if I wanted to import the `index/common` controller from `github.com/Gacnt/GoWebGen/controllers/&lt;sub&gt;/&lt;file&gt;.go` but I'd rather it be sourced from the new project. 
I agree it doesn't matter to the compiled Go program. However the permission bits seems to be a required parameter to MkdirAll, used by this program. So what /u/anonxgh seemed to be pointing out was that 0777 might be too permissive even to the developer own computer. I think /u/Gacnt should use 0755 instead.
I've wanted to make a Morse code interpreter reading from a blinking light source in a video.
GC load is not about the size of memory but about the number of pointers that need to be scanned. 1TB []byte slice takes no time to GC. Create 1 GB of small structures that all reference each other via pointers and GC will spend a lot of time chasing those pointers. That being said, no GC will keep up with terabytes of heavy allocations. Neither will straightforward manual management with malloc/free. There is no magic technology that absolves you from perf tuning your program, especially if you're planning to do something that requires touching terabytes of memory. If your program dos lots of randomly-sized, randomly ordered, small allocations with malloc()/free() (i.e. the "efficient" manual memory management) then even with the best memory allocator you'll spend majority of your CPU time in malloc()/free() calls and you'll fragment your memory and you'll find yourself having gigabytes of total free memory but unable to allocate a contiguous 1 MB chunk. Go's GC used to be relatively simple but with 1.5 it's very good, will be even better in 1.6 and probably will continue to improve for Go's lifetime because, reading between the lines from Go commits, the improvements are driven by internal Google needs and if there's a company that exercises Go code with 1 TB of memory, that's Google. Go's GC is probably in the top 5 implementation out there. Maybe Oracle's Java's GC is better and if you really need absolutely the best, you can give your money to Azule for their Java implementation. If Go's GC is not good enough to keep up with your software, then you're unlikely to find a better implementation that will and it's time to start writing your code in a way that optimizes the thing that is slow. Generating lots of garbage is slow. I once significantly sped up poppler by adding a simple custom memory allocator because the way the program was written, it was allocating a lot of (small) strings all over the place. GC'ed code can also be optimized: use less pointers (you can e.g. replace pointers to objects with an index into an array of objects, the array serving as a custom pool allocator). The good thing about Go is that it makes those kinds of memory optimizations much easier because, unlike Java where everything is a reference (i.e. a pointer), Go allows embedding structs by value. For example, I've sped up a binary-trees benchmarks by 4x by implementing node references with integers, not pointers, and allocating nodes in bulk. See http://blog.kowalczyk.info/article/u5o7/Speeding-up-Go-and-C-with-custom-allocators.html
Wow. I would love to see it ported to the [i](http://www-03.ibm.com/systems/power/software/i/).
Seconded. Just "Wow".
Still looking to make themselves relevant I see
&gt; lean and mean &gt; Prerequisites: PostgreSQL And at least 8 packages already imported, plus Bootstrap. Opinionated, sure. Lean? Not so much.
Unnecessary comment. Not selling $300 laptops at Best Buy doesn't mean they aren't relevant. I actually took the time to google some information about them. They seem to be going strong these days. They work more with huge corporations and do a lot of R&amp;D. I don't know if they still get a lot of research subsidies from the government.
lol ok, I feel sorry for IBM engineers to be quite honest. Treated like shit, paid under par in almost all areas, with many either working soulless jobs in professional services or improving RPG or something. It's where innovation goes to die. I can't wait until they spinoff Watson to Lenovo. 
Treated like shit and underpaid? I've heard the opposite, but I don't really know to be honest.
Compared to working at almost any other large tech company during a tech boom, yes. The upside is that they're ridiculously easy to get into as a new grad. Not selective in the least - that's why my a good portion of my classmates will end up there and do nothing else, and not ever work at Google or whatever. 
I do pentesting mostly and writing reports for pentests. So there are quite a few things to automate. Thanks for idea.
I recommend inheriting from the parent directory. If the user wants their source to be 777 or 700; that's their prerogative.
I'd recommend using the same DB for development, testing, and production. If you're already using datastore, I'd continue to use it. Otherwise, like u/itsmontoya said, BoltDB is a solid choice.
Cool. I also tried to make some XMPP client library. But your library is quite clear. https://github.com/kpmy/xippo 
I'm not familiar with ascii doc.
Couldn't agree more, BoltDB is amazing. Plus it's a pure Go solution.
Too hacky, I hope we can execute native Go soon.
And where do you plan on working?
Pick a python/node/rails command line app and port it.
Make an XSLT processor.
Thanks! I didn't realize until you wished me.
Interesting. Thanks for sharing.
Thank you all! Have a great Monday!
Might be socket vs TCP/IP overhead. [See benchmarks](http://redis.io/topics/benchmarks#factors-impacting-redis-performance).
Cute. You're one of those idiots who thinks that financial institutions like banks just run ruby-on-rails on commodity Linux hardware, am I right? 
If you like GAE, maybe you should try AppScale (https://github.com/AppScale/appscale).
Also, Redis is single-threaded unless run as a cluster, whereas BoltDB can take advantage of all CPU cores.
It works for Google and they have better uptime. Paypal's a bank, too, right? 
I would love to see a comparison to other schema-less datastores. I'm working on a project with mongo now but it definitely feels like overkill. This might be a worthy drop-in replacement. Might test it out myself when I get a minute. 
I believe someone put up a similar method using python a while back.
&gt; You don't know at compile-time what type your mapped function will return? That's not a program I ever want to debug, sorry. It's perfectly reasonable to want to write a library with generic algorithms and *not* know what types your user will provide. The Go standard library has loads of such examples (e.g., fmt, encoding/json, text/template, html/template, sort, database/sql, etc), but most of them sacrifice type safety and performance by taking an empty interface. It totally punts on `math`, giving us a float64-only implementation and leaving us to reimplement for other types. My point is that there's not presently an efficient way to write performant, type-safe, generic algorithms, and doing so is not an unreasonable desire (I would go so far as to say it's common!).
OMG, if you can replace mongo with bolt, do it! mongo is a beast. Bolt is simple and easy. Also, hello, transactions! This spoken from someone who works on a mongo-backed project at his dayjob :)
I had considered other options (namely aerospike) but I went with mongo because it's already in place and maintained by another team. Also I wasn't aware a system like this existed TBH. 
Anyone considering things like Redis, Bolt, RocksDB, etc. should also look at ScyllaDB: http://www.scylladb.com/
Only for reads though. Writes require a lock. 
Yep, it's all very dependant on use case. Here's what the BoltDB author has to say on the subject: https://news.ycombinator.com/item?id=10881450
I'm using Aerospike for my main project which is an ad server type application. I love it. With it, I am able in a distributed way, to scale to the moon. It's very very VERY fast!
Yes you have to keep track of a file on disk with bolt. I'm not sure I like the idea of keeping data in the executable, but it is an interesting concept.
Thanks!
There is now a working example at https://github.com/ory-am/fosite#see-it-in-action
We were not even remotely using bolt properly. We were keeping almost everything in memory all the time and serializing it to bolt periodically and on shutdown, really just for persistence. Our pain in going to redis is transforming all of these locking data structures into a key/value access pattern. Once done though, it works really nice.
&gt; Next time think, then build it. No, writing from inspiration is important, don't lose it, just find the balance.
Software designed to survive and distribute when the internet is 90% nuked.
Because we also wanted to give ourselves the ability to scale out and run multiple instances at the same time. We could have had an intermediate step with bolt as a k/v store, but straight to redis works as well.
I don't really get the difference between this and a private (onsite) cloud. Conceptually it seems the same, but the implementation hardware is different? Basically just a single large machine instead of a bunch of smaller ones? Are they running a load of VMs on the mainframe or does it have some kind of special tech? If I have a blade server running a load of VMs, how is this different conceptually and hardware-wise from a mainframe? If you were building a new system today, what would be the use case for the mainframe? Google, wiki and the IBM site don't really tell you what's inside the magic box.
OOP is a way to organize data and algorithms that work on that data. All programming languages are OOP if you still call it OOP after removing the idea of inheritance and classes. "Object Oriented Programming" is thinking of data and algorithms packaged together in classes (an object's "type" is it's class), which was never accurate to the reality, even if it was a strong stepping stone towards clear features to organize programming with what all computers are: data, and a set of computers instructed by data. Go programs are just types (data), functions (algorithms), and interfaces (glue?), like it has always been.
Conceptually it's either a single large machine, or sometimes a small cluster of machines which present as one machine. While they can run VMs (and this was where VMs started), they are not used the same way as in a cloud. There would be relatively few VMs, they would not be running a PC operating system, and they might be emulating some 1960's mainframe (e.g. IBM 360) to run a 1960's OS like MVS ("man versus system") to run legacy software. In cloud-based architecture, you have thousands of VMs, each supporting a relatively few users, and you have a problem as to how you get all those machines to address a single back-end database - hence the trend towards distributed databases where the version that different users' sessions see may not be entirely consistent, but you basically program around the problem. On a mainframe, all the users for a given database may well be on the same machine. As to why you would use it - well, I'm not a mainframe person, but here's a plausible case. Let's say you want to buy a blamfindle widget from Amazon. Amazon is running on a cloud architecture. While you are getting around to checking out your purchase, someone else nips in and buys the last remaining blamfindle widget. But because they are on a different VM, for a moment the database is inconsistent and Amazon allows your purchase to go through (I'm using Amazon as a plausible example - I don't know if this can happen with their particular architecture). This isn't a big deal provided that it doesn't happen too often: you'd just get a polite message a few minutes later to say that unfortunately they cannot fulfill your order. No big deal, and this relaxed attitude to consistency is the idea behind something like MongoDB. Ok, but now suppose you do the same thing with payments out of a bank account with £12k in it. Transfer £10k to another account in one web session, and do the same to a different account in another concurrent web session. It's conceptually very similar to the Amazon example - two transactions happening at the same time on different VMs. But in this case the error would be a very big deal, so having a single back end system is one way (not the only way) to avoid the problem. A mainframe is the sort of system that might be used for this because it can handle so many connections to a single system.
It seems that is the convention in the standard library.
Please don't post links that use custom redirectors. A direct link to https://gophercon.com/ would be best.
That'd work for scripts that are loaded upfront, but not so much for binary executables, depending on the OS. Like Windows locks running executable files entirely, to keep [demand paging](https://en.wikipedia.org/wiki/Demand_paging) simple, and is also why even the most trivial Windows updates still require reboots.
Thankfully, not only is Hoverfly open source, but their Gatling load tests are too! So I did some investigation. I can confirm that the issues they saw were due to the fact that they were using TCP instead of Unix sockets to connect to Redis. When properly connected over Unix sockets, both BoltDB and Redis had nearly comparable performance (BoltDB was still consistently just slightly faster).
What kind of difficulty are you facing? Maybe you do not need a SQL DB but just a different KVDB whose query language better supports your requirements.
Something almost like cjdns?
One minor point. The file descriptor issue is specific to LSMs with leveled compaction (LevelDB is one of these). LSMs with size-tiered compaction don't have this issue. However, there are different trade-offs. This is a good article comparing the two types. http://www.datastax.com/dev/blog/leveled-compaction-in-apache-cassandra p.s. Much respect for Bolt!
So, a class with data and associated methods is OOP, but a struct with data and associated methods is not? All because one could possibly use inheritance? Yes, OOP-style programming can be done in C, but it's not a feature of the language. Go allows methods to be declared on a specific type, just like Java, C++, Python, etc. That's the basis of OOP. The inheritance vs composition and duck-typing distinction doesn't change that. Either way, interfaces are a just a subset of functionality that are defined on an object.
I don't think this really adds anything to the official intallation instructions, and it doesn't really have anything to do with Centos specifically.
Yes, I know about other similar utilities. I even tried to start a pull request to add a feature I needed (base- and extended- templates) to one of them, but it turned out it was easier to do it all from scratch. Feedback (and criticism, of course) is welcome. 
Personally, I would use a relational DB or document store for this use case. KV stores are great, but they tend to suit use cases where fast retrieval is more important than complex querying: this is their trade off - fast retrieval at the cost of simpler data management and/or query capability. My recommendation would be Postgres combined with pgx (https://github.com/jackc/pgx). PG can scale up very well and there are solutions to scale horizontally as well, however, I imagine it will be a while for any company before they reach that kind of level. HTH
I believe that's a type assertion. It's like type casting but for interfaces (where the casting might fail/not be compatible) Edit: https://golang.org/doc/effective_go.html#interface_conversions
Its a type assertion that the type of v is a function that accepts a single string. https://play.golang.org/p/YUXrlLpjwC https://golang.org/ref/spec#Type_assertions 
I agree with @itsamemmario docker is a good way to go. We use tutum(recently purchased by docker) that hooks into each docker server and have found it invaluable. You can setup what's called a stack file with all of your dependencies(just like a docker compose file) making setting up an environment a breeze. To take it a step further you can also hook dockerhub into it so when updating your application all you have to do is build your new docker container, lush it to dockerhub and then tell tutum to update your entire app on all servers your service(s) are running on making deploying into production a click of a button. Hope that helps
looks pretty cool. using native code is actually sweet. will try it out
I started with a key value store ( Redis and Boltdb ) for my food project ( bestfoodnearme.com ). I was originally going to use postgresql, but I did not know what my schema would look like. So in this case key value was easier to get started with. In the long run, I would recommend moving to a relational db. You could always use the key value store in postgresql ( hbase )
I use a Makefile that handles building all the micro services, sass to css etc. For my development, I have a config package that picks the dev stuff is the environment variable DEV is set. Otherwise by default, I run the production version. On osx, the iTerm2 has script support, so I have one script that starts all the micro services. 
Hello. Sorry for late reply. 1. For me: It's a flexible prefix. I no longer need to carry the same duplicated code (with the necessary functionality to me) between projects. 2+3. It's a bad backport from another package. It's my fail. Changes have already been added (benchmarks on a readme page too).
&gt;look, I've even read your code and wrote a benchmark instead of telling how cool I am, how awesome &amp; production ready the code I'm working on and calling your code "crap" and you "stupid hipster" (or whatever) I appreciated that :) Thank you. And I would be grateful for the assessment of the updated code :)
I use Redis and BoltDB in my current project. Because BoltDB is memory mapped, the kernel handles the paging for me, and I do not run out of memory on my server. I was originally building an in memory trie of geo location that was one of my micro services. It ran fine on my macbook, but I have some lean servers and memory was an issue. Since the geo information does not change, BoltDB was ideal. I use Redis for the other stuff that requires high write volume / real-time stuff but lower memory usage.
If you would rather use a non-relational database, I would suggest trying a document store rather than a key-value store. i.e. MongoDB.
Thank you! I definitely look into Postgres and PGX! Have a good day!
Thank you. Well, the problem is complexity of query. If it was a simple stuff, I guess I will solve the problem with the key. However, here's the case: 1. Location=Boston, age&lt;35, computer skill=9 2. Computer skill = 9, Golang=True, Java=True 3. Location=Dallas,Java=True,Computer skill&gt;5 There are so many different possibilities, and I am wondering if I need to create all the keys for each possible cases. Thank you
Neat, hadn't seen this yet. Sure, backbone stuff is cool and necessary, but what about robust network applications? Servers as a service are a big thing today, but once that Instagram or Facebook server set gets shut down then it all goes away, plus there is always the government control and man-in-the-middle attack stuff. So my suggestion is a robust distributed network application. We absolutely need a working distributed trust system too (if your three neighbors say incompatible things about this fourth stranger, how do you resolve your opinion of that fourth person?).
Great!! Thank you so much! I now know which direction I will head.
&gt; both of which produce runnable executable files that run perfectly on any other computer, but hang on the desktop So the problem is specific to just this one computer. I would conclude its not a Go program problem. Its just that Go programs that you created do manifest a deeper problem on this computer. 
Have you tried temporarily disabling the antivirus software on that machine &amp; re-running that "hello world" program?
 I suspect there may be a fair amount of merit to this. However the computer seems to function properly for everything else, it's just go programs that fail. If I could get it working it would be really great, but it's not overly important.
THIS! I can't believe I didn't think to disable the anti virus, but doing so let all the programs run flawlessly. Thank you so much.
&gt; Go does have methods, but my understanding is that they are just an annotation for regular functions to make code more readable (x.Do() is the same as Do(x) internally). Plus enabling interfaces. This is true of C++ and Java, it's just hidden behind the compiler as the keyword "this". Python requires that class methods have the "this" keyword as the first parameter, in order to have a reference to the calling object. The entire attached method construct was originally built around such a setup, Go does the same pattern while adding the ability to name the calling object whatever you want. &gt; Go is narrowed to avoid many of the pitfalls those languages experienced - in my mind, part of that is removal of unnecessary abstractions. From my understanding, the goal was to strip out all the excess from previous OO-languages. We all got a little carried away with adding abstractions to C++ and Java in the real heyday of inheritance-style OOP, hoping to solve every problem via abstraction. I enjoyed a lot of it, but the languages started bloating really quickly. My first language was C++98, which makes C++14 look incredibly verbose (C++ community is really focused on getting some of the complexity deprecated and removed, now). Also, I've seen some Java devs talking about removing some inheritance from their code and using Go-style composition in its place. I haven't seen that code, but they've seemed to enjoy it. Who knows, it could become a solid design pattern for another community. In the end, a good programming language helps us to think of a program in a little different light. Go-style OOP did that to me and I've enjoyed every minute of it.
Good to hear! Have fun.
Really interesting project.
I'm a content curator at Outlearn
In both Firefox 43 and Chrome 47 this just gives me a page with an Outlearn logo and an endlessly pulsing progress bar.
Thanks for the heads-up, we are investigating. I deleted the post so others won't get the same issue. I'll repost once we have figured out what's going on.
I'm a content curator at Outlearn.
Possibly because he means there is a bit too much logic in a template language, some people prefer template languages to remain fairly "dumb" and not put too much logic in them. It's the reason why I don't like Mako templates in Python for example, it's like having a programming language on top of your template language.
Shouldn't the parse time of templating just be done once at startup and then essentially free after that? Are there benchmarks?
Website is horribly broken on mobile safari (iOS 9.2), so I can't read it.
Yes, you generate the go code once. After that you just call the functions. I made a comparison for this template: https://github.com/tkrajina/ftmpl/blob/master/example/comparison_with_gotemplates.tmpl ... but it is far from being a definite measure. You can run it with "go test -v . -run=TestComparisonWithGolangTemplates". On my MacBookPro ftmpl is cca 8-10 times faster. The generated functions are pretty straightforward (see: https://github.com/tkrajina/ftmpl/blob/master/example/compiled.go) so I think it should be faster almost always. But, anyway, in most cases the template execution isn't the bottleneck (but database queries, other (web)services are) so this isn't really the ultimate reason to go for it. For me personally the reason why I prefer this approach is because it's typesafe (the build will fail if I mistype the field name in the template or call a template with wrong parameter types). Also some things are a lot easier to implement when you can type any expression in the template. Let's say you have a for loop and you need to implement something only on every third item. It's much easier when you can just enter any golang expression with "if": {{! if i % 3 == 0 }} ... {{! end }}. Of course, as robvdl mentioned... You must be careful to not write too much code. But I think most developers nowadays are aware that application logic should be implemented somewhere else. (BTW the {{! ... }} template placeholder is not multiline like in PHP or JSP)
I've just been looking for compiled templates in Go. So far I've only found [Ego](https://github.com/benbjohnson/ego), have you seen it/any thoughts? I'm a big fan of [Mako templates in Python](http://www.makotemplates.org/) and hoping to find something feature-competitive with that, but Ego still has a long way to go.
Mobile update coming shortly to fix styling, was a side-effect of some other recent changes, poorly tested. Agreed, totally bogus, we're on it.
I get that, the learning curve was hard for me too. I've just gotten into docker and it takes some time to wrap your head around how all dockers interact. What really helped me is the following links: use docker-machine https://docs.docker.com/machine/ for a VM run this docker https://hub.docker.com/_/golang/ with -v "/path/to/project/on/local/machine:/path/to/project/on/docker/vm" this creates a docker vm with go installed and allows you to compile and run your project on the vm. then read this on how to connect ~~this to your localhost~~ to your docker using the vm's ip address $ docker-machine ip &lt;vm-name&gt; https://docs.docker.com/engine/userguide/networking/default_network/dockerlinks/ basicly -P -p is your friend. my final command looks like this docker run -P --name sharedVolume --link mongo -v /Users/itsamemario/Go/src:/go/src -it my-golang-app EDIT: i might have led you in the wrong direction. You have to connect to the vm, not your localhost.
Thanks for sharing this project. It's very similar to a project I've been working on called Afero https://github.com/spf13/afero. Afero is a drop in replacement for the OS package but also includes support for backends like Sftp, (S3 soon), CopyOnWrite, MemMapFs and much more. It would be great to join efforts as the goals are so similar. I'd love to hear what you think about Afero. 
Honest feedback is the best kind, thanks :). What Outlearn adds is ability to track your learning so you can remember what you have done. It also lets you publish your own paths and soon you can clone the existing ones to create remixes. Based on the comments here we can clearly do a better job at making the benefits clear right when you land on the site. We'll keep on working on that!
Thanks for the feedback, it helps us continue to make things better. The site has a pretty robust publishing mechanism for any users which accounts for a lot of the load time. We want to enable users to take a path they like, create their own remix (cloning paths coming soon), and then share it with others. The way we think about the screenshots is that most people would not actually read them because the text is too small. But hopefully it gives a quick sense of what the link is about so the reader can decide if they want to click on the link.
Yup; maybe a little clearer if you separate the type assertion from the function call: package main import "fmt" func main() { var fn = func(a string) { fmt.Println(a) } var v interface{} = fn var fn2 func(string) fn2 = v.(func(string)) fn2("astring") } If you just tried to do fn2 = v we'd get a type error from the compiler, so we have to do a type assertion: fn2 = v.(func(string)) Note that if v isn't really a func(string), then this'll panic at runtime. (I'm just elaborating on what schoenobates said, in case it's helpful to anyone.)
I think I've seen that thumbnail (from this article) on my front page about 3 or 4 times. Great article though.
I didn't know this one, agree with you now. I should probably change the naming to not mislead. Or I should just return an error when update &amp; delete queries don't affect anything
thanks for feedback
This is completely unusable on mobile.
Do I assume correctly that pgx can be used as a drop-in replacement to pg and that it will work well with sqlx?
This isn't as exciting now.
!!! time to name and shame. What was the virus app and why is it complete garbage?
~~Dude bro. I made this thing. You may find it useful (you will need ruby).~~ ~~https://gist.github.com/penguinpowernz/c231ad9c94c7d39e45eb~~ ~~At least for me jumping around between project folders it is. I just run `goset` in the directory I want to be my new GOPATH and it sets all that up for me.~~ ~~Also, note that the path to go itself should be in GOROOT. Mine is currently `/usr/local/go`. Also make sure that You put `/usr/local/go/bin` into your PATH (set in your `$HOME/.bash_profile` or whatever).~~ USE THE GOPATH, LUKE
This SO question should (mostly) answer your question: http://stackoverflow.com/questions/24537443/meaning-of-a-struct-with-embedded-anonymous-interface I'd try to go in more depth but I'm on mobile, sorry.
So ... the declared type of a pointer is significant and can be dispatched on.
nil is just a value.
The traditional method dispatch syntax we're used to is just syntactic sugar in Golang. See: http://golang.org/ref/spec#Method_expressions Essentially, this: var t T t.M(x) is equivalent to this: T.M(t, x)
Not much talk yet about your project here on reddit. You seem to have a lot of care and thinking going on here. If you've achieved what you set out too, this is certainly a step beyond what we have right now capability wise.
But how do you manage multiple projects? Let's say I develop two completely different programs. Should these share a $GOPATH? I have them in different repositories. At the moment depending on what project I work I would always have to change the $GOPATH.
dont get it either, can someone help?
&gt; I understand why the code doesn't work, but given how strict Go is, why is this even allowed to compile? Because there is - in general - absolutely no way to prevent this at compile time. For that, the compiler would need to know what value is saved in that embedded interface and that is in general equivalent to the halting problem, which isn't solvable in general. So go falls back to a runtime-check, which is the sensible thing to do. &gt; I understand why the code doesn't work Do you really? No offense, but that is not really my impression. For example: &gt; I would expect embedded implementation to behave in such a way that a struct must implement the entire methodset of the implemented Interface, even if none of those methods are called, but it seems to do the exact opposite of this. I don't know what you mean here. Baz *does* implement the interface, it has methods `GetBar() bar` and `SetBar(bar)` and the implementation of both is to call the respective method on the embedded interface. The code panics because that interface is nil, but that is something that the compiler can not know in general (see above). So this *must* be a runtime check. You then assign a *Baz to a FooInterface and again, *Baz implements this interface due to how method sets work. &gt; It seems to me that it's performing the same action as when a user embeds a struct for subclassing/inheritance in that it's making those subclassed/inherited methods available. Yes, that is exactly what is happening - if you look at the [spec](https://golang.org/ref/spec#Struct_types), it talks about embedding a type and "promoting" fields or methods to the struct that embeds it. This is what's happening here, but the promoted method is on a nil-interface, so it panic's. So your whole problem boils down to "why does [this](http://play.golang.org/p/9UCpXL0k2P) compile?" and the answer to that is given above. &gt; Is there any reason for this, or is this just functionality that should be added in the future? I would be really curious what kind of "functionality" you are talking about. So far you haven't really said *why* this shouldn't compile and how the compiler should figure that out.
No, the point of making interface embedding work is that you can overwrite specific methods of it. Did you understand the [sort example](http://play.golang.org/p/0a5e8gh4A8) and how reverse works? And do you understand that, without interface embedding you would need to do [this](http://play.golang.org/p/MIVxhjbksj)? And why, thus, it is useful to embed interfaces?
Thanks! It always takes time for people to adopt something new, especially when it's a departure from the norm. With something as critical as a data store, people need to gain trust with it first, and that can take time. Hopefully, as GoshawkDB gets faster to get going with, gets more clients, and gets a few more features, it'll grow a community. It was interesting watching the reaction to Aphyr's "Call me maybe" post on RethinkDB - several people wondering why it's not more widely used and the suggestion being that people have been burnt by adopting other data stores too early. A lot of the work I'm doing at the moment (eg this blog post) are trying to give people confidence to use GoshawkDB by demonstrating it really has been designed from day 1 with a clear sense of what semantics I wanted.
Exactly, that's why it's called `GOPATH`, not `PROJECTPATH`, many projects and their dependencies can live there. You can set multiple `GOPATH`s for multiple projects and change the variable value as you go, but that's not really recommended.
Fwiw, there's one context where `GOPATH` it's not used, and it's on `gb`-based projects, where each project live with its dependencies on an isolated place in your file system. http://getgb.io/
PGX does support the standard SQL packages as well using the package github.com/jackc/pgx/stdlib. I've never used sqlx I'm afraid so can't comment on whether it works or not: sorry!
http://tip.golang.org/doc/code.html#Overview
&gt;I just want to build and run a simple Go app, so why am I messing with the &gt;GOPATH which doesn't point to the installed version of Go, but instead a &gt;folder that I have code in? Because the go version you use is determined by the command you run, if you do go run main.go you're defining the go version in go by using the path. &gt;And why am I not even setting it to the folder containing my main.go, but &gt;instead one directory above it with a ./src folder in it? So that It knows where to look for dependencies, this way you can install dependencies without being root. &gt;And why do I then have to run go build from ./src and not my the location of &gt;my GOPATH? Because when you do go build or go run you specify a set of files, if you do go build main.go and main.go isn't there it won't work. If you do from GOPATH go build src/my/package/path/main.go then it should work &gt;I feel like I must be missing something? Given the issues wrestling this, I'm &gt;scared to do some simple directory layout in my project to group things &gt;together in a sane way because of the various ways Go treats folders in &gt;your project. Is there a simple answer here that will let me move past &gt;fighting the build system so I can write some code? Check similar projects.
Related question: How do you treat related projects that aren't golang? Do you put them in the same folder structure under GOPATH? I have this project where I've split up the functionality in multiple different services using different languages, and all the code is put nicely together in subfolders under the project folder ...except the Go code that needs to live somewhere else. It's a bit annoying.
support for openid connect?
yes, support for the open id connect specification is planned and architectual decisions have accordingly been made. It is just a matter of days until open id connect is supported. If you want to give implementing open id connect a try, use [this issue](https://github.com/ory-am/fosite/issues/17) to report problems or ask questions
Sounds like you're trying to dereference the pointer? You can do that with the `*` operator: var value int var ptr *int ptr = &amp;value // get the address of value value = *ptr // dereference ptr
The idea is pretty simple: C:\go\src\helloworld\main.go - this is your actual application C:\go\src\hello\what.go - let's say this does some task that computes the actual string "hello world" and that "helloworld" needs to reference it (import it). You'd only have to ever import "hello" since everything is under the C:\go (aka GOPATH). Go's premise is that you make a lot of small packages that do ONE thing. That way the code is easily reusable by other packages. You can make as many packages as you want.
nice progress.
Both of your c++ examples introduce undefined behavior by dereferencing nullptr. Static vs dynamic dispatch doesn't matter. They are both ticking time bombs that violate the standard. http://www.viva64.com/en/b/0226/ is a good read about this. In short, the 'this' pointer is always guaranteed to be non-null (except if UB has already been hit, then you're screwed already). Compilers can take advantage of this and optimize out entire branches where 'this' is asserted to be nullptr, because it can never be. You are also incorrect about c#'s methods being virtual by default. They are not. The virtual keyword is required to introduce a virtual method that you can overload. The reason why calling (non-virtual) methods on null pointers in c# throws an exception is that it's required to by the standard, not because it segfaulted when looking up the method in a vtable.
Yeah but wheel
Came here to say that.
nope it's completely sane to run integration tests against docker images! :) it's at least more sane than mocking the sql interface or similar nonsense. The API of dockertest has gotten a little messy, I'll try to find some time and clean up the stuff and version dockertest with gopkg.in
your api looks clean :) didn't have time yet to look through everything
Just use the built in time.Duration.String implementation.
I could not load the site because it requires running JavaScript code which is not free software. It would be great if I could read the static part of the article without running JavaScript code. (It's static text, isn't it?) Oh well, I guess there aren't a lot of users with JavaScript disabled on your site, but still. The title of the post seems interesting though
What about using direnv to manage it on a per-project basis? It has a "layout" for go as well. https://github.com/direnv/direnv/wiki/golang I find that between direnv and glide (https://github.com/Masterminds/glide) it is a good way of isolating out your project dependencies and nuances, while still adhering to the GOPATH requirements. That way I can still have multiple projects in my workspace but keep my workspaces isolated. FWIW - Often if you work with clients it is not totally a great idea to have all your projects interconnected as people can come back after some time and you need fixed constraints on the project. Go 1.5 vendoring helps a lot though.
Thanks for the corrections. I've updated my post. Having behavior that appears to work but is actually undefined per a dense, lawyerly spec is not something I miss about C++. :) EDIT: To nitpick, my non-crashing example is never dereferencing or comparing against this, so I'm not sure it's actually hitting undefined behavior. I just went and looked up the standard and 5.2/5.3 is like 20 pages long! Maybe I'm not looking at the right version of the standard? I'm curious if you happen to have the specific text at hand that you believe makes this behavior undefined.
Yes, and I love that. It 's a great way to avoid nil pointer panics. The main idea is very simple, if your receiver is a pointer, it's always possible that it could be nil. type Foo struct { name string } func (f *Foo) GetName() string { if f == nil { return "&lt;none&gt;" } return f.name } Note that GetName is really just syntactic sugar for func GetName(f *Foo) string Which makes it a lot more obvious that f can be nil, but the function will still get called just fine. Nil pointer panics only happen if you dereference the pointer, which happens when accessing the underlying memory (e.g. struct fields, if it's a pointer to a struct) *or calling functions defined with a value receiver, not a pointer*. That second one is probably more common as a cause of panics. If your method with a pointer receiver calls a method with a non-pointer receiver for that type... you'll get a panic if the pointer is nil, because go will implicitly try to dereference the receiver pointer when you call the other method... and panic.
It's 2015. Enable javascript. Edit: 2016. Stupid brain.
I'm sure it's a great library, but this is the fourth post on /r/golang about it in 13 days (or the third in 6 days), all but one posted by you. Please shill a bit less, thanks.
Hey, the first was to get as much feedback as possible in desinging phase and this one is to present the results. Sorry if this annoyes you. I did not want to spam and thought genuinely that this would be ok :)
The clearest language I can find about the issue is in section 9.3.1 (linking to a draft because the standard isn't actually free... http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf#subsection.9.3.1). &gt; If a non-static member function of a class X is called for an object that is not of type X, or of a type derived from X, the behavior is undefined. So even when the method does not access the instance at all, the behavior is still undefined because it was not called on a valid instance to begin with.
Huh, so for "foo *f = nullptr", f is not considered to be of type "foo *"? Oh, C++...
The answer is that it depends. You can have multiple projects in a single GOPATH. Each project will have a main.go in a different package. Often this is the right way to go. All the projects will share the same dependencies, when you upgrade a library each project will be updated. This works well when all the projects are updated and deployed together (like micro services). If you don't work on and/or deploy the projects at the same time, you might consider multiple GOPATHs. A common example would be a consultant that has multiple clients. You probably wouldn't mix code for multiple clients in the same GOPATH.
Yeah, so what happens when this is a library and you add an error case? Doesn't that break all the programs that depend on the library? Sum types are cool, but I'm not convinced they'd be worth integrating into Go. A type-switch is very similar, and is typically what you do when you need to check for a specific error. (Sometimes people check for a particular *instance* of error, but this is not so good in general because you can't return any case-specific information.)
https://www.youtube.com/watch?v=PAAkCSZUG1c&amp;t=8m15s
Some context: I'm working on a project with is fairly heavily dependent on doing things on intervals or after certain amounts of time. In JS we have packages like [Sinon](http://sinonjs.org/docs/#clock) that provide fake timers, and can advance time while calling functions scheduled to run on intervals and after timeouts. I was surprised that I wasn't able to readily find a similar package for Go. There were a few (such as [this](https://github.com/jonboulle/clockwork)), but they generally lacked the "easy access" functions like `.After`, or support for Tickers.
A db with powerful query capability (like Postgres) probably does make the most since, but I was thinking ... Looks like you may have 1 table with lots of records and many records having the same values (ex. Java=True). Should you index all the search fields ? If not, I think the database will have to read every record for every query. Will these indexes cause any problems ? With something like Bolt, you can segregate data into buckets. For example, a Golang bucket that contains candidate ids that have Go. Of course you could have separate tables in the sql solution as well. I'm sure figuring this all out can get complicated, but there may be multiple good solutions.
I'm also looking for something like Mako for Go (Mago ?). Thanks you for the link to Ego, it could be a good start to make it. But i don't think it should be feature-competitive, like Go it should be just more simple.
You're confusing embedded interfaces with the keyword "implements" in other languages. When you embed the interface, you're defining a member variable which can hold data. Any object you assign to that variable will be type-checked to ensure it implements the interface methods. The containing struct doesn't need to define anything, because the member is required to do that.
For educational purposes only, also see Rob Pike's [filter package](https://godoc.org/robpike.io/filter) that does this kind of thing much better. E.g. although a call to `filter.Apply` can't be compile time checked, it's fully and completely type safe at runtime; that is `type T int; func f(T) T; var v []T; filter.Apply(v, f)` is fine but `filter.Apply(v, unicode.IsLower)` will panic at runtime without any effort/requirement that the caller check/assert anything. Most important to note is the package comment: &gt; The package is an experiment to see how easy it is to write such things in Go. It is easy, but for loops are just as easy and more efficient. &gt; **You should not use this package.** or as worded on the [github repo](https://github.com/robpike/filter): &gt; I haven't had occasion to use it once. Instead, I just use "for" loops. **You shouldn't use it either.** Or in other words, if you're programming in Go then write Go code, not poorly translated Ruby code.
Ohhhh, right, that makes sense. I was still thinking in Go-land where the method can be defined directly on the pointer type, but obviously that's not how C++ works. Autoformatting is the devil. :)
Yes that's a backwards incompatible change and rightfully so. If I add a new error case and my clients are blind to it, I'd prefer them to break silently rather than loudly. type-switches are only aesthetically similar.
Point well taken. We'll work on it :-).
Neat idea! Curious why you decided to use the JS-like callback function pattern instead of just returning the URL (or other parameters)?
I see, that helps make some sense. Thanks!
&gt; My understanding of interfaces is that they are specifications that require an object to define methods that have a certain method signature. The interface doesn't care how you implement them, it only cares that these methods are defined so on any struct that implements the Interface, the interface methodset can be called on it. The Interface should not define these methods itself. That is correct. It is also a tautology in go, as you can't define methods on interface types (well… an interface type has a method set, but that's just the methods that a type needs to have to satisfy this interface). You should probably, to start understanding what is happening, differentiate between "interface types" and "interface values". &gt; The "functionality" I'm talking about is that any struct that implements an Interface to have the methods required by said Interface to be non-nil at compile time (which you mentioned isn't currently possible) It's not *currently* impossible, it is *in principle* impossible. &gt; If Interfaces in Go are meant to define default behavior for embedding objects You keep rephrasing stuff in weird ways that I don't understand. No, interfaces are definitely *not* meant to "define default behavior". They are meant to define a method set. They are meant to basically duck-type, to say "anything that has these methods can go here". A variable/field of interface type can hold a value of any type that implements the methods Type Embedding - an orthogonal concept - is meant to promote fields or methods of a type and make the embedding type "inherit" (that's the wrong word, because it isn't really inheriting anything, but oh well) these. Both have many uses and their composition has even more (because that's pretty much what orthogonal means). One example is, that you can make a new type implement a given interface by embedding an existing type that already implements this interface. And a special case of that example is, if the embedding type is an interface type itself (this is the special case of a special case that we are currently talking about). This special case of that example now has a couple of interesting usecases, none of which can be described as "defining default behavior". For example, the aforementioned sort-case: Selectively overwriting methods of a given interface. Note, that "defining default behavior" is as far as you can possibly get from describing what you are doing there. You are not defining default behavior, but you are extending user-provided behavior - the wrapped sort.Interface - to do something different. Another use case, not mentioned so far, is separating the required from the offered interface. In C++ you might do that by defining a set of purely virtual methods - the required interface that a consumer of your API needs to implement in a derived type - and then add a set of non-virtual functions that call these virtual functions - the offered interface, that is defined in terms of the implementation of the required one. A user can then inherit from that class and provide an implementation of the required interface in the form of overriding the purely virtual functions to get the functionality of the offered interface. In go, the way to do that is by defining an interface type for the required interface, embedding that interface type into a struct and then defining additional methods that call into these interface-methods - again, the offered interface. A user of your package can then implement the required interface in their own type and embed a value of that type in your provided struct to get the offered interface. This is a very good example of how composition can be used to replace inheritance. In any case, I have a huge problem with your phrasing because a) it is completely mischaracterizing what is actually happening and b) you are reducing "the meaning of interfaces" to how you are misunderstanding the special case of a special case of their use. I am more and more certain that your real criticism is, that there is a zero value of an interface type (namely nil) which still has all the methods of that interface type. But that is a corollary of a) interfaces being first-level types, b) memory being zero-initialized (so every first-level type needs a zero-value) and c) the halting problem as stated above (as the compiler can't know if at any given point an interface variable contains the zero value or some other value). a) and b) are individually *very* much desirable properties and c) is a logical consequence of what a program is. So I find "there might be a runtime error when I use an interface value uninitialized" to be an extremely low price to pay (especially as there are, for example, also runtime-errors if you use a pointer-value uninitialized).
See also: https://github.com/benbjohnson/clock
because dockertest retries the callback for X times. this is required because the docker image might take a little while to boot
Well, they're undefined behaviour, but apart from virtuals, I know of no compiler that does something "unexpected" in that sense. clang, gcc and msvcc all leave "this == NULL" branches behind in the code, even at -O3 (Or it did a year ago when I worked on a terrible codebase that called methods on nullptrs). But that aside, the current use of "undefined behaviour" is largely misguided. No one benefits from a compiler that choses to ignore your code because it has the permission to do so (despite also having the permission to do something sane!). Leaving the undefined code in leaves you with a slight change that the result does what you expected (and it often does, btw). Removing it gives you a 100% guarantee that the application doesn't do what you tried to tell it to do. Who would want their binary to be small/fast, but at the cost of guaranteed broken? If compilers want to bitch about undefined behaviour, which they're permitted to do, they should do so with compile errors rather than removing code. After all, if they detect undefined behaviour for optimisation purposes, they could also, idk, PRINT AN ERROR INSTEAD SO YOU REALIZE YOU WROTE BROKEN CODE?! You need to specifically enable warnings for undefined behaviour, and they don't even catch that much! If my memory serves me right, the oldest use of undefined behaviour in language specs stated that it simply meant that the specification did not contain the necessary details, and that the implementor or user would have to look somewhere else for the details as to what the action would do, including implementation details and common sense. I forget where this was. Algol or something? Idk. Anyway, there's plenty of rants about the idiocy of undefined behaviour online, and there are people with much better arguments out there than me.
Oh no doubt UB is undesired, but I believe fault here lies with the specifications (or rather, the lack of them) and not the compilers. There are so many areas where UB is taken advantage of by modern compilers that if they printed warnings for every optimization they made because of UB assumptions, there would be too many to consider. I think a better solution is to use runtime checks for UB (such as http://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html) if you really can't dump C and C++ for whatever reason. Then you get errors for actual UB in your program rather than printing way too many warnings to reasonably consider.
I like how they provide plenty of detail about the exploit. Even a punter such as myself can broadly grasp what's going on!
&gt; I've already had to re-define the methods on the types, so the hard work is done. You don't necessarily have to redefine the methods. You can use field-embedding and have some or all of the defined methods promoted. But the real usecase is that package A doesn't need to know about interfaces that package B defines. That means a) less imports, thus faster compiles and prevents dependency-cycles and b) more importantly that you can define your own interfaces for *other* people's types and thus, for example, easily generalize them or mock them out. For example quite a lot of people define an interface that encapsulates the most important methods of [*log.Logger](http://godoc.org/log#Logger). Now, the log package itself doesn't define an interface, but you can take an interface with the relevant methods and then you (or users of your package) can either put a *log.Logger in it or define their own loggers. You should also try to not look at language features isolated in go, but instead look how they compose with other features. go is explicitly designed to be orthogonal. A good example is the type-embedding mentioned above. It combines well with interfaces to let you easily overwrite methods of an interface. Lastly, you are approaching the problem from the wrong side: The opposite of structural implementation would be, to explicitly state which interfaces you are implementing. But that would actually be *more* work, so you would need to *add* to the language to do that. So rather than asking "what's the point of having structural typing" you should ask "what's the point of specifying which interfaces I implement"? In particular "I've already had to implement the methods, why should I need to do more?". :)
Basically, If you are: - On a 32 bit machine - Running a tls server - with rsa for keys An attacker who knows the plaintext (so likely not a mitm vulnerability) and signatures of ~64Million messages could derive the server's private key. Not very good at all, but also limits the number of people affected somewhat by excluding 64 bit machines.
64 mill. messages can be created in a couple of minutes. It's really not that hard once you can snoop the connection.
You don't need to snoop a connection. Just go to e.g. the website and reload it a bunch of times. You know what the plaintext is, so you can perform the attack, extracting the server's private key.
Ahhh true. I do use sublime text. Might take your/natefinch's advice.
agree with using something like Postgres, you can build complex queries and move that logic to the database rather than your application. Takes less than a week to learn but worth it.
Ha. That's fair. 
This is designed so that you _would_ use the interface `clock.Clock`. The package provides a default implementation that basically returns what the time package does, as well as a mock clock that provides time functions and structures based on the fake time (which you control by adding or setting the time).
I think you mean loudly rather than silently. :) I guess the counter-argument is usually to handle an error, you just need to know, "hey, it's an error," not care about every specific kind. Like, there are an infinite number of causes of errors that can cause anything to fail, and it seems like distinguishing new error cases shouldn't be a breaking change? But that said, I've never used a language with sum types in anger, so I might be missing something. It does seem like a very nice feature.
Can't explain your results, but are you converting the key from a string to a byte slice, []byte(key) ?
Is there PoC in the wild? "in the wild" = easily found in a day or two
 diff --git a/database.go b/database.go index cf712b4..575f759 100644 --- a/database.go +++ b/database.go @@ -217,7 +217,7 @@ func (db *ListlessDB) goGetAllSubscribers(modsOnly bool) (subscribers []string) db.View(func(tx *bolt.Tx) error { members := tx.Bucket([]byte("members")) c := members.Cursor() - for email, metabytes := c.First(); email != nil; email, _ = c.Next() { + for email, metabytes := c.First(); email != nil; email, metabytes = c.Next() { log.Printf("Iterating over database member: %s, meta: %s", email, string(metabytes)) meta := MemberMeta{} err := json.Unmarshal(metabytes, &amp;meta) After debugging for about 45 minutes, it came to this. I knew your boltdb code was fine. You were just using the `metabytes` from `c.First()` instead of updating it on each iteration. Fun problem!
nice
Fix my bugs plz
Only MIPS64? :(
OMG thank you! I had been meaning to switch to ForEach anyway.. That's a subtle and irritating bug, I wasn't even looking there for the source!
This made me chuckle: “struct functions” Functions with receivers are called methods (not limited to structs) Edit: https://golang.org/ref/spec#Method_declarations
does that one made the compile speed get faster?
That's exactly the use-case I'm concerned about. I don't want to mix up different projects and the dependencies of them.
1 in 10 people downvoted!? :/
&gt; Generics. This is divisive to newcomers, but decisions made to build fast and smart binaries, no generic functions exist. Not sure what a "smart" binary is, but I don't see how generics would affect runtime speed. It seems like they would only automate-away the boilerplate code, no? &gt; Note that interfaces will allow alternatives to sidestep this issue with still some extra code but better organsation. ^ And that is just false.
It would affect compilation time, I imagine.
Yeah, well. I wish he was a bit more specific about how you can replace generics, since he hints there's a better way to do it but doesn't mention how.
It looks like rotor benchmarks from [the article](https://medium.com/@paulcolomiets/async-io-in-rust-part-iii-cbfd10f17203#.cvl15bi45) are somewhat broken. See [my comment](https://medium.com/@valyala/nice-article-d1d52c61c44a) for details.
And there is https://github.com/mrmorphic/hwio Maybe you can also list the onces you tried and did not work (well) ? 
Interfaces are for code reuse. They separate the "signature" of an object from the implementation. If you're writing a library function that operates on a sequence of items, you probably don't care that the sequence is an array list or a linked list. You may not even care that it has a finite number of elements. In this case, you just care that it implements: type Sequence interface { Next() *Element } Then you can write your library function, and it will work for all kinds of sequences (ArrayLists, Arrays, LinkedLists, etc), rather than having to write one library function for every conceivable kind of sequence.
Go is similar to Java in its structure. Interfaces can do the same job in both, but Go also uses interfaces for composition instead of subclassing. Instead of Dog extends Animal, you have Dog interface *contains* an Animal interface. Package hierarchy should be obvious considering that. Do you have like 300 bases classes or something because you can't subclass? Use composition with interfaces.
I've updated the post. The errors I get are to do with importing the `syscall` package.
Any idea how to fix the issue I'm getting? Is it the OS I'm using or is it up to the library to update?
https://github.com/go-gl/examples/tree/master/glfw31-gl21-cube Heres the code example i used
 * Loss of Version Info - Then let's use tools that preserve version info and store it in a consistently formatted file. I don't see how this is specific to mono repos. * Forking Packages - I agree if you make changes to a vendor package without upstreaming it anywhere you are shooting yourself in the foot. So don't do that or upstream the change somewhere. * SDK to API mapping - I can see this both ways. But often the client and server share significant packages. And don't copy the repo, just copy the packages you need. * Build and Test Bloat - That I can see with the given tools. The solution would have a smarter test runner that works on sub-trees and not repos. 
Ok, we've no fixed the glitch. Sorry about that!
Ok, we've no fixed the glitch. Sorry about that!
Noooo, I'm developing on Windows 10. It'll be running on raspbian once I put it on the raspberry pi. 