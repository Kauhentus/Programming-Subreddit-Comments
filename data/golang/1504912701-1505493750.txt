Have a look at: https://github.com/golang/go/issues/8082 What you want would be doable, if pkg/errors would make use of anonymous interfaces then the using package would also define that anonymous interface. The issue above would make it easier (and less ugly to the eyes).
1. Disagree about the single large block and know size in advance: As linked in the blog post: https://www.imperialviolet.org/2014/06/27/streamingencryption.html strong large data without chunking is not an option. 2. About the recommendations to prevent key reuse: As far as I can see there is no tamper-proof solution without external meta data or without deriving unique OUSIDE of the format spec. See https://github.com/minio/sio/issues/5 to get an impression why. 3. About the cryptographic experience: The auther of sio and DARE is currently responding here ;-) https://github.com/golang/crypto/graphs/contributors About your concerns about misue: DARE and sio are not designed to be used by people without any knowledge about cryptography. It's is much more a primitive which can be used to build secure systems by people like you - Security engineers and developers who have some understanding of building secure systems. I'm very thankful for feedback here but we more or less considered the points you're are making here during the design of DARE. The "features" are not left out because we forgot them - they are left out because they don't give a significant improvement or have some downsides. Nevertheless it is easy to overlook something while designing a crypto format / protocol, so I'm glad that people take a critical look. 
&gt;A master header with a chunk/package size value makes random access &gt;much more performant. Currently, to seek to byte X this library must read the &gt;header of every package between byte 0 and byte X. A master header would make seeking not easier. The size of a package is already included into the header and it is recommended that all packages expect the last one are full packages (64KB). However, this is not always possible - imagine appending data to an already encrypted blob. If you encrypt a data stream with sio you can already compute an the offset and read just a range. This functionality is not included into the library itself because there are some special cases where seeking is not trivial (like a concatenated encrypted stream). In such a case a general seeking implementation would produce wrong results. At Minio we have exactly this kind of problem (S3-multipart upload) &gt; Also, I agree that key derivation should be moved into this library. As far as I can see this does not improve anything. See: https://github.com/minio/sio/issues/5 &gt;Finally, the docs could do a better job. Thanks for the feedback, I will make this more explicit.
I've implemented something myself to let me use Go as a shell scripting language, using a Python script as the "interpreter" that does a bit of massaging of your Go code and makes it runnable. * "Go Shell" interpreter: [gosh](https://github.com/kirsle/.dotfiles/blob/6df07c0685dff99a46bbecc0ac3ed696f888be54/home/bin/gosh) * Example script: [SimpleHTTPServer](https://github.com/kirsle/.dotfiles/blob/6df07c0685dff99a46bbecc0ac3ed696f888be54/home/bin/SimpleHTTPServer) (inspired by Python's SimpleHTTPServer, but not single threaded) I use a standard `#!` shebang, and the Python script removes it and writes the Go file in `/tmp` to guarantee a dedicated folder and unique file name. The down side is the shebang isn't valid Go syntax and so the tooling around it (`go fmt`, etc.) fails. I may investigate that `//usr/bin/env` approach to work around that.
((popcorn))
&gt; I'm not sure why you read my post as defensive It was the tone you used. It's possible that I misperceived, but another commenter described another of your comments in this thread as 'defensive' as well, independent of my comment. I don't want to beat a dead horse, but consider changing your tone if you don't want to be perceived as defensive.
After looking at it in more detail, the complexity of extendSetMaybe() can be reduced, so it can get inlined. And that allows Set() also. But don't think that effects much as the benchmark spends 60%+ of it's time in make() and copy(), dynamically reallocating. * 0.68s 39.31% 39.31% 0.68s 39.31% runtime.memclrNoHeapPointers /usr/local/go/src/runtime/memclr_amd64.s * 0.49s 28.32% 67.63% 0.49s 28.32% runtime.memmove /usr/local/go/src/runtime/memmove_amd64.s That's what happens when keep having to double allocation size til get to 10^8 bits. 
I'm less defensive and more anti-fluff. As I said elsewhere, this article contributes nothing.
Why is it a requirement for scripts to be interpreted? I know that historically that has been the case, which makes sense in a time when compilation could take a very long time. I don't think it makes sense for something like this. The binaries Go makes aren't super huge, and can be made smaller with stripping and gzipping (last I tried back on like Go 1.4). With this, you're playing with the language in a way it wasn't strictly designed to be used, and you're going to have distribution problems. You have to distribute the Go runtime to all of your hosts, and you have to distribute any dependencies you have. At what point is it easier to just compile the binary and throw it in RPM? FPM will let you package a single binary in like 5 minutes, and you only have to do that work on the initial build. After that you just update the version and re-build. Distributing a 10MB binary should not be a difficult task in a modern datacenter. You could use something like Puppet or Ansible, you could use something like Bittorrent if you want P2P so you aren't bottlenecked. You could even write a small package management like bash script that takes the script name as an argument, checks if it's on the server and up to date, downloads it if it's not, and then runs it. All of those solutions seem more reliable and better than trying to run a compile across a shit ton of hosts. Ever seen what happens when something like Puppet tries to run a compile across all of the VMs in a cluster simultaneously? It's not good, at all. There's a reason CentOS and RHEL randomize the time that the cron job to update man pages runs at.
Huh. https://github.com/willf/bitset/blob/1a37ad96e8c1a11b20900a232874843b5174221f/bitset_benchmark_test.go#L95 Removing the allocations from the hot path, his benchmark becomes roughly comparable to the Java one. I think this microbenchmark might have been an allocator benchmark. Go's GC strategy most likely won't win over Java's bump allocator, in a microbenchmark that has no need to collect garbage.
Yes mum.
The session is only used to store information for the round trip, so once the round trip is complete you can delete the session.
This is similar to canonical import paths making forking difficult. I think the obvious solution is one that wasn't considered in the article: Fork it, but without changing the name; require that the forked package be imported as `github.com/pkg/errors`, even though that isn't where it is hosted. This makes it not `go get`-able, but otherwise solves the issue.
I like your explanation - a journal, a tree, and a lock gets you a long way :-)
The problem with that approach is that it doesn't work for packages with build tags. For example, for package runtime: "cannot load package: [...]/src/runtime/defs1_netbsd_arm.go:7:2: _EINTR redeclared in this block". Do you know a way around that for ParseDir?
Your example should include leap days and Thanksgivings :)
But then tools no longer work for those files, so that's not perfect either.
Quirks? Huh? Go is one of the quirkest-free languages that I know.
Yes, I know what you mean. I haven't found a better way but will gladly update my code if I ever do. That said, the main question is what do you need the *ast.Package for? If it's for creating a *doc.Package, the above fields should be sufficient. As far as I know, there's no other use for *ast.Package. For all other things, you'll either use go/build to get a *build.Package, or use go/types if you want to do type analysis.
hi /u/kostix My previous implementation wasn't very good as it would leave behind temporary files and it used a lot of RAM. So, I created a copyAt function using io.Copy and io.WriteAt that reads 64kilobytes of data from http response and writes it to a writer. This way, RAM usage stays at around 20 mb regardless of the file you are downloading. And previously, It discarded any downloaded packets in case of an error but now it doesn't discards downloaded bytes and only downloads the ones which have not been downloaded. Release: https://github.com/ishanjain28/pluto/releases/tag/v1.4 
/u/plectid I have not found this to be true in practice using multiple parts certainly increases download speed. The HTTP overhead in using multiple connections is probably ok. I released a new version which has a lot of bug fixes, uses lot less RAM and shows some stats, https://github.com/ishanjain28/pluto/releases/tag/v1.4
How do I perform check hash to be sure I have got all the bytes in correct order? I tried to google about ranged request gotchas or caches that don't work well with ranged requests but could not find anything, Do you have a resource where I can read about this? I am writing unit tests that downloads a file from a server using pluto and then in the normal way using http.Get directly and then calculates their md5 hashes to make sure it isn't buggy. 
There are a lot http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/
I released a new version of Pluto that fixes a lot of bugs, uses less RAM, shows stats and is more polished. Release link: thttps://github.com/ishanjain28/pluto/releases/tag/v1.4
The go/build portion in that listing takes care of all that Edit to clarify: it handles all the stuff with gopath and build tags and gives a list of the files that apply to the given build.Context (which defaults to the default context which is the current GOOS/GOARCH). Note the fileCheck closure: it tells ParseDir to only parse the files which go/build identifies. (It would be really nice if this were helper on build.Package or there was a helper func in parse, but it's not a lot of code to write.)
How are they corrupted? If they are cut off early, have you considered that you may be slamming the server so hard it starts falling over? The static files in your sample code probably wouldn't have that problem, but if you are asking for dynamic resources, possibly from someone less well provisioned than the Google urls you showed in the example, it's at least a thought. 
Here's a corrupted example: https://i.imgur.com/R4SYOzN.png They are stored on google butt storage. :( **edit**: I'll see if I can make some sort of pool and limit the number of simultaneous downloads. I'm not sure how to fill it all up sequentially without blocking and then blocking x at a time when reading from a channel or something :/
A lot of those aren't "quirks"; you can do lists like this for every language. The intro to that article says exactly that: &gt; Go is a simple and fun language, but, like any other language, it has a few gotchas... Many of those gotchas are not entirely Go's fault. Some of these mistakes are natural traps if you are coming from another language. Others are due to faulty assumptions and missing details. &gt; A lot of these gotchas may seem obvious if you took the time to learn the language reading the official spec, wiki, mailing list discussions, many great posts and presentations by Rob Pike, and the source code. Not everybody starts the same way though and that's OK. If you are new to Go the information here will save you hours debugging your code.
I'll just leave this here in case anyone finds it interesting. I use this all the time: $ cat .bash_profile | grep gorun gorun() { GOBIN=/tmp/gorun go install -v $* &amp;&amp; $(GOBIN=/tmp/gorun go list -f '{{.Target}}' $*); } Usage: gorun script.go gorun full/import/path gorun ./relative/import/path gorun # same as gorun ., that is use Go package in cwd It's nothing more than a convenience thing to be able to accomplish the functional equivalent of the following, just with less typing/less steps: go build -o /tmp/o &amp;&amp; /tmp/o (It actually uses go install, so the dependencies are saved rather than discarded, for faster future compilation times.)
A script is just a program.
Tbh, the way you say it, it sounds like the premise of some really weird fantasy book in Alice in Wonderland Style.
Not all DBs horizontally scale, though. There is not enough information here to know for sure. We don't know the DB, any hardware specs, the time for those queries to execute, number of incoming requests etc. If you have tons of capacity on the DB server then why not run a couple of queries in parallel? It sounds like premature optimization otherwise.
I find the assume role/MFA config options that are built in to the CLI to work nicely - see http://docs.aws.amazon.com/cli/latest/userguide/cli-roles.html [profile admin] role_arn = arn:aws:iam::123456789012:role/admin source_profile = default mfa_serial = arn:aws:iam::123456789012:mfa/jonsmith If you run `aws --profile admin ... ` then it will ask you the MFA code and cache the resulting session for an hour. 
Could you elaborate on why os.Args[0] is wrong?
I'm confused about os.Args[0] usage, there's [os.Executable](https://golang.org/pkg/os/#Executable), but tbh I have no idea what it would return from a `go run` command. I'd hope something similar to `os.Getwd() + "/temp-name-garbage"`.
Nice 🤓
Imporant note: [`fallocate`(2)](http://man7.org/linux/man-pages/man2/fallocate.2.html) is documented as "[t]his is a nonportable, Linux-specific system call", there is a `posix_fallocate`(2) that is more portable. As for Go, the package `syscall.Ftruncate` function only exists in the Linux package¹. (The BSD version defines ` SYS_POSIX_FALLOCATE` but doesn't implement a wrapper function; the Linux version doesn't define that nor appear to implement a wrapper function). However, `trunctate`/`ftruncate`(2) exists on many OSes and is also implemented as [`syscall.Ftruncate`](https://golang.org/pkg/syscall/#Ftruncate) (and [`syscall.Truncate`](https://golang.org/pkg/syscall/#Truncate)) for both BSD and Linux so it should likely be the preferred portable Go way to allocate space in a file. Except of course none of that is portable to MS Windows, as always, any use of `syscall` should be guarded by OS build constraints. I don't know what the equivalent would be for other OSes. ¹ At this time this also appears to be the case with `golang.org/x/sys/unix` as well. 
&gt; ``` func reddit doesn't use that kind of markup. You can select "[formatting help](https://www.reddit.com/wiki/commenting)" below the comment entry/editing box for details but preformatted text or code should formatted with four leading spaces (or a leading tab). Ideally you should edit your post to have the correct formatting (add the leading space to all code lines).
For me, Go will probably never replace Python and bash for basic scripting tasks. I write lots of utility scripts and tools and have an informal workflow which consists of 3 stages. 1. I run a number of shell commands. After a bit, I get annoyed by the repetition. 2. I convert the commands in to a shell script. Sometimes, the script grows enough that I get annoyed again. 3. I convert the shell script to a Python script. Usually, depending on the use case, it will stay in Python but now that I use Go, there is a chance I'd convert it go Go. For me, the flexible syntax/typing in bash and Python allow me to write simple scripts more quickly than I could in Go. I actually enjoy bash (usually), Python and Go so this all works well for me. 
So your solution to what you found would be ANOTHER language that transpires into Go? Just go find another language and leave Go alone, if you don't find it fitting your needs. I dunno WTF is with all these people coming out of the woods attacking Go all of a sudden. I've been using it over 3 years now and not once ran into problems with which I had issues. .NET... I did... constantly. Go has been the most lightweight, solid performing, and fun language I think I've ever used. For this... I'll stick with it. I feel bad for newcomers coming to the language. All I see now is hate, people bitching about generics, and why it's not more like {insert other language}. I also see a LOT of blogs and articles giving bad code and advice. Not sure WTF that's from. All of a sudden, everybody is a fucking know-it-all, and suddenly knows why Go isn't and what Go should be... but they continue to get things wrong. It's embarrassing for the Go community. Go has one of the best communities, awesome standard library, with some of the smartest folks in CompSci behind it. Period.
[removed]
Seems cool! Not sure what I'd use it for though. Also, kudos for writing documentation :D.
Is there any chance of supporting something like `rsync` from inside the container, or does that already work? SSH key auth would also be great instead of passwords... :)
See that: https://en.wikipedia.org/wiki/File_system_permissions#Numeric_notation
Those numbers originated from Unix (I think) and are pretty much well known. But, for most usecases you can avoid them, there are simple `os.Open` and `os.Create` functions. `os.Open` opens a file for reading. `os.Create` opens a file for writing.
I looked there and it said that 0777 allowed everything so i tried that and got errors saying there was a problem with my File variable and nothing worked.
If you are being tripped up, I'd recommend just using os.Open or os.Create as the docs say in os.OpenFile. The wikipedia entry on file system permissions is helpful if you aren't familiar with them: https://en.wikipedia.org/wiki/File_system_permissions 
**File system permissions** Most file systems have methods to assign permissions or access rights to specific users and groups of users. These systems control the ability of the users to view, change, navigate, and execute the contents of the file system. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Try 0660.
Yeah thats what I keep reading. The problem is neither of those work for appending. Because os.Open is read only and os.Create truncates if file already exists. So I guess I am falling outside of most use cases.
Yeah thats what I keep reading. The problem is neither of those work for appending. Because os.Open is read only and os.Create truncates if file already exists. So I guess I am falling outside of most use cases. 
This worked. Thanks. Though Im still confused as to why the function doesn't just use the os.O_APPEND to figure out what permissions you want.
Yeah, so then you need to search and study how FileMode numbers work :)
Very nice. I have wanted something like this for a very long time. Has this been tested in production ?
Thanks everyone.
&gt; Has this been tested in production ? No, fresh from the oven, still very hot. But existing tests do all pass. Bug reports *very* welcome.
Thank you so much for this! I've been toying with GraphQL myself but the lack of good resources for Go has hampered my progress in the area. It's great to be able to read someone else's code, get a sense for how they structured things, defining the schema and queries etc.
Glad it helps, though i'm far from being an expert at any of the fields covered in the project, i'm doing my best to make things work, help would be highly appreciated ^_^
Not sure what problem is this trying to solve.
I recently did some performance testing with the particular library for GraphQL being used here, and it's actually less performant than the Node.js version, and the code ends up being littered with `interface{}`. I recently tried the same thing with [this library](https://github.com/neelance/graphql-go), and found the code to be far more idiomatic, without `interface{}`, and it was a _lot_ faster too. It does seem however that the none of the Go implementations are mature, and none of them are well documented. The Node.js one in particular is excellent in this regard, which is unfortunate. I'd like to see more people use GraphQL with go, and help push the libraries forward however, and that's also what I intend to do once I get started on something a bit meatier...
&gt; Not sure what problem is this trying to solve. Possibly related: * https://en.wikipedia.org/wiki/Write-ahead_logging * https://sqlite.org/wal.html
**Write-ahead logging** In computer science, write-ahead logging (WAL) is a family of techniques for providing atomicity and durability (two of the ACID properties) in database systems. In a system using WAL, all modifications are written to a log before they are applied. Usually both redo and undo information is stored in the log. The purpose of this can be illustrated by an example. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Yes mum.
It's for code generation, so I need the full AST. Another use might be something like gofmt or other syntax transformations.
I got a Go job from someone I met at GopherCon. We're still hiring; see https://www.kentik.com/careers/?gh_jid=156284.
Turns out, it might have been a mix of too much downloads at the same time and an error deeper in my business logic where I ended up with a race condition of trying to download 2 different things under the same file name at the same time. Also, if you look at my second link where I first implemented a download guard, I changed the ``for`` and ``if ok`` check over the channel to a ``for range`` on the channel. It simplifies the code and it's much more readable. https://play.golang.org/p/OeapCYh08Z
It is a masterpiece and swiss army knife as most of your work! Many thanks! It is far beyond my knowledge though :P But i think it is a very important part and good contribution to the Go community. Especially when trying to create a performant DB (in writes). For example putting this in front of BoltDB would make sense, am i right ? (making that db more of a eventual consistency but higher writes) I am also right that this works with concurrent reads and writes but only one writer at a time ? I looked at the test coverage, for WAL testing. But trying to figure out how to apply this into a DB scenario with various commands and states is hard. Is it possible to do some examples just to illustrate the WAL mechanism of writing, commiting and then read from the commited ones ? Again thanks for your work! 
Kallax doesn't support MySQL :( That's why I have built similar to Kallax solution - go-queryset (https://github.com/jirfag/go-queryset). It's also typesafe with code generation, no strings and no empty interfaces. But it also supports mysql, sqlite, postgresql, mssql with the help of GORM.
this is insteresting to read, i should take a look to that one, didnt know about it...yeah the `interface{}` thingy ends up being kinda exhausting :/ 
Previously submitted but that was before the web component was made. 
The neelance library is really easy to implement, but lacking in documentation. But if you read the code in the "example" directory, it's not hard to figure out.
Storing the passwords in plain text doesn't seem ideal. [Bcrypt](https://godoc.org/golang.org/x/crypto/bcrypt) might be the next thing to look at.
as long as there is no ill will....forking is a fundamental freedom of open source and this is a positive outcome
The issue is this: [~]% pwd /home/martin [~]% cat a.go package main import ( "fmt" "os" ) func main() { fmt.Println(os.Args) fmt.Println(os.Executable()) } [~]% go run a.go [/tmp/go-build323064242/command-line-arguments/_obj/exe/a] /tmp/go-build323064242/command-line-arguments/_obj/exe/a &lt;nil&gt; I would expect the result to the `a.go`, so I can use `filepath.Abs()` to get the full path to the script (`/home/martin/a.go`). This can be useful in some scenarios. For example if you have a helper script in a project that initializes the SQL database you typically want to get `db.sql` relative to the script's path, so that both `./import-sql` and `/path/to/project/import-sql` work. You can work around this by calling the Go script from a wrapper shell script which passes the path as the first argument, but that's kinda annoying. This is what I meant with my comment: it's all *possible*, it's just tedious and cumbersome. 
Sure, see my other comment here: https://www.reddit.com/r/golang/comments/6yxlhm/story_writing_scripts_with_go/dmsn9kh/
Ah ok, gotcha.
I'm not sure if it's well known - I've encountered CDN providers that weren't aware. You run into this if you rely on ranged requests at a large-ish scale. There aren't really any easy fixes, since it's hard to find the caches that are at fault. You can detect it if you have a content MD5/hash for the whole content, but then you have no idea where the issue is. If you have something like zsync that builds a whole set of chunks with hashes, you can detect it, but not really work around it. The best solutions tend to be to take intermediate caches out of the equation, either with HTTPS or by setting http cache headers that strongly discourage caching by intermediate parties. 
Use race detector (-race, https://blog.golang.org/race-detector) to find out about potential issues due to multi-threading/races.
If you're going to generate code, why not generate code that directly calls database/sql? it would be just as type safe as yours, without the whole gorm reflection slowness behind the scenes.
FWIW I'm a newcomer and I'm loving go. Taking the advice of the community and reading more before I complain.
I agree. For a second there I was interested to see another take on ORM, but now I'm not even sure. I wrote several ORM generators myself (although promptly scrapped, due to design flaws), and my main priority was always to decrease allocs (which is not hard, if reflection is not used), and this is complete opposite :)
I agree that Go has a great community, you are not one of them though, I've used Go since 4 years ago, there are good things on it, but somethings need improvement that's why they decided to build Golang 2 listening to the community which is a great decision. I think Golang as a transpiling target could be great because of the tooling and the libraries, and I've seen some attemps to build something such as oden, goby or have.
If k is 0 or 1, then highA and highB will be negative, which seems like a good place to start looking for issues. If you know it doesn't work with 7, for logic this simple, you can even trace through it yourself to see where you're going wrong.
A package with one function has the node feel all over it. Which of course some may not see as a downside. I personally prefer to use [gosigar](https://github.com/cloudfoundry/gosigar) for getting info about memory, cpu and such. It's still small enough for me.
* It's an order of magnitude harder to develop and maintain, because GORM have already done a lot of work to make all DMBS compatible code. * GORM is the most popular ORM for golang, and go-queryset is fully compatible with it. * The main purpose isn't speed, but usage convenience.
Brilliant! What I'd like to see, however, is a package which implements a known algorithm, that is, compatible with an already existing implementation, like F5 or steghide - not just another unique snowflake.
Absolutely.
Check out https://gnorm.org - it's what I'm working on right now to generate code from a database schema. 
It always an appreciated effort if the guide would help others in using go in Raspberry Pi. (Y)
Try https://github.com/src-d/go-kallax I like it a lot
Kallax is cool, I was inspired by it when developing go-queryset. But kallax doesn't support MySQL and another DBMS, it supports only PostgreSQL.
Well, since go is a compiled language, I'm sure you understand well the reasons why you won't end up with the file name for whatever file has main() defined, but only the compiled binary somewhere. Go run is not an interpreter, so there's really no reason to expect what you say you expect. That being said, I'm sure shebang support *could* be added. I'm just thinking that it never will. Judging from this [SO](https://stackoverflow.com/questions/2482348/run-c-or-c-file-as-a-script), more fuckery can be added in front of your go code if you really really really want to. Also you might want to check os.Getwd() if you're just interested in the working directory. There's a good chance that it will report the correct path.
I use `gobwas/ws` for my latest ventures in WS domain, you could try that out too, it doesn't use net/http, or fasthttp, instead it lives on its own tcp port, what I do is have API that returns the address and then the WS client uses it.
... Miranda ... (Had to be done)
Thanks, I'll take a look!
`addrCh &lt;- addr` blocks until something takes the thing its trying to send, which can't happen if the goroutine at the end of main hasn't spawned yet. You could reorganize it so that `GetAddressChan` had its second half after a `go` keyword, or you could do what you suggested and pass in the channel to use. As far as idiomatic go goes, you probably already know that `panic` is generally to be avoided. It'd be more idiomatic if `GetAddressChan` returned a channel and an error. 
Thank your for your note. I don't want to have to pass the function a channel. I want it to return a channel so I can treat it as a generator. I have tried restructuring the code so the generator send part is in a goroutine, but even then it doesn't work. Please check the update to the post.
Any goroutines left running when the end of `main` is reached will stop execution. Adding in some blocking operation at the end of `main` (or in this case, not putting the end of main after `go`) will prevent this.
It doesn't seem to make a difference if I block the execution after `go` statement in `main`: ch := make(chan int) _ = &lt;-ch Only thing that seem to work is if I don't use any goroutine in either `main` or `GetAddressChan`, but make `addrCh` a buffered channel with buffer &gt; number of email addresses in the file. (or if I block main from exiting **and** use said buffered channel)
~~Because your range over addrCh will end as soon as there's nothing left there, which will be immediately, because the goroutine sending things to the channel hasn't spawned yet.~~ &lt;- this is wrong, sorry I rarely range over channels myself Then I'm not sure, can you make a link to a https://play.golang.org/ snippet with the updated code? See this: https://play.golang.org/p/epTpwuycD0
Won't the goroutine for `addrCh` spaws as soon as `GetAddressChan` gets called and blocks until someone receives a value? At least in the second case in which I wrap `for` loop sending the values to `addrCh` in `GetAddressChan` in a goroutine instead of wrapping the `for` on `range` which receives values. It doesn't work in that case either. All this seemed easier when I was reading the code/doing examples only. It seem very much like a simple example code, but I am unable to figure out what I am doing wrong.
I'm not following what you're saying. Can you write up what you're trying in a snippet? This is an example of how this would work, without using the mail stuff: https://play.golang.org/p/7yvWLDMy4M
because it looks like it's just a wrapper on top of gorm, not a fully fledged ORM.
haven't done much work on ws but wondering: why isn't websockets in the stdlib?
It's `bufio.Scan`'s doing I think. If I use a normal slice of strings instead of `bufio.Scan`, everything works as expected. I should study it more to find out what it is doing that is causing this, and how to work around it.
https://xkcd.com/1425/
Where do you thing I got my inspiration? ;)
You could make this page much friendlier with some SQL &amp; Go code on the front page ;) Just the usual "products table" example would suffice.
The real solution here, imo, is don't use fasthttp. Then all your issues are not issues anymore.
Big Bird https://i.ytimg.com/vi/3OYuJKvr9f4/maxresdefault.jpg (66.50% bird, 9.79% banana, 9.76% banana, 9.70% banana, 9.58% banana)
Really glad to see this. Thanks for creating it!
That's not how developers solve issues, go face it or or go home.
If you want to add it to the [SFML Bindings page](https://www.sfml-dev.org/download/bindings.php), you could provide a PR or open an issue on the [SFML Website repository](https://github.com/SFML/SFML-Website).
I disagree. My opinion is that fasthttp is too far removed from the consensus around interoperability of HTTP libraries in the Go community. I believe therefore you'll always be chasing some sort of kludge or fix for working around that. I think you'll find less problems over the lifetime of your project, and save on man hours invested, if you use something else. There's nothing wrong with stopping to take stock and review the use of one particular library over another, if you find one thing is too annoying or problematic to work with, poorly supported in the ecosystem - swap it out for something else.
Websockets were a response to the limitations of HTTP1.x, the standards were changing frequently while Go was being developed so it made no sense to have it in the standard library. It makes even less sense now that HTTP2 is well supported in Go. Incidentally it's my understanding that fasthttp also has interoperability issues with HTTP2 and the Go standard library. For most teams and developers this alone would exclude its use from any project.
Makes me think of the Silicon Valley episode, hotdog or not hotdog... 
Agreed, fragmentation is best avoided. I probably should have researched existing tools more deeply before writing my own. My goal was to write a super-simple implementation, and in that regard I think I've succeeded. The actual steganography code [is quite small](https://github.com/lukechampine/jsteg/commit/d35a0bb4e6c545d4f1dd2a28eee514228dab3409). I'm sure the density factor could be improved and the package could be more configurable, but I'll leave it alone for now unless there's demand for more features.
Thanks for this, I'll definetly take a look. One of my issues was indeed the whole "everything goes through `interface{}`", which just doesn't sit right with me. You lose many benefits of the language and tooling around it because of it, and it usually detrimental to performance too.
Not exactly sure what this does. You get a File like structure, and what do you do with it? How is this better than just a normal file?
&gt; How is this better than just a normal file? Write-ahead logging wraps updates to a File such that they become atomic and durable. Please see also the reply to /u/SentraFan.
Thanks for the tip, will do
Nice job. I built something similar (https://github.com/MohamedBassem/gormgen) also on top of gorm. But didn't maintain it.
I'm glad this got picked back up, thanks!
You can go incredibly far with vertically scaling a DB like Postgres/MySQL. By the time you hit the limitations of a machine with a few TB of NVMe disks, 512GB+ RAM and 2x E5s (56 total logical cores), you're either very rich, or you've been wasting time and money from the start (with a few exceptions, of course)
It's used to terminate the for loop so that the function can exit.
[removed]
Aaah thank you sir 
I would amend that to it returns from the function to escape the loop. The difference is that if there was some final statement after the loop but before the end of the function, it would not be executed. 
And `break` would only break out of the select. You could break out of the loop with a label in this case since there are no statements after.
This looks cool, but is it non-free and do you collect telemetry or personal information? Looking through the code I see: * [stripe.tmpl](https://github.com/thestrukture/IDE/blob/2b725f67f7b803ef498849aa9aceafe7a99bffd4/tmpl/ui/stripe.tmpl) * [privacy.tmpl](https://github.com/thestrukture/IDE/blob/master/web/privacy.tmpl) The privacy statement is a bit broad and I noticed it uses google analytics in these templates. What is collected? Also how does it related to https://github.com/cheikhshift/Gopher-Sauce it seems to be the same author just different structure / dates. I also saw while looking for any network requests / telemetry "tests/gos.xml" contain a possibly private key used to send mail, may not be but figured I would ask in case it was overlooked: mg := mailgun.NewMailgun("thestrukture.com", "&lt;snip&gt;", "pubkey-.." ) 
&gt; (Your New Parser) -&gt; (Your AST) -&gt; (Go AST) -&gt; (Go prettyprinter) -&gt; (Go compiler). When generating a (Go AST) from (Your AST), you'll have to be careful about putting good information into the Pos fields. If you don't, then the (Go prettyprinter) will generate very badly formatted code. It could be far easier to generate Go source directly from (Your AST). You can even easily intersperse that Go source with references back to your own language's source using Go's //line directive. It's difficult to put those directly into a (Your AST) -&gt; (Go AST) step because Go source comments are stored separately from the (Go AST). 
People mistake embedding with composition all the time. Embedding is not composition. Composition is a method of designing the objects in such way that they can be combined together to create more objects. An example can be: combining UI elements into a horizontal split gives you another more complex UI element. This element can be further combined with other elements. Another example: web server middlewares. You design middlewares separately, then combine them to get a more complex middleware, eventually leading to a complete web server. EDIT: And to someone who gave me a downvote, read something up: https://en.wikipedia.org/wiki/Object_composition
I have expressed the same idea in the blog post. I start with a *author struct*, then use it to make a more complex *post struct* and then finally I create a website using a slice of *blog structs*. The way to achieve this in Go is by using struct embedding. 
You miss the point. Composition and struct embedding are two separate ideas. You can do composition perfectly without struct embedding. Struct embedding is just a syntactic sugar that let's you promote methods of one struct to another struct, and thus save you from some typing. Nothing more. EDIT: Take a look at my blog post (https://faiface.github.io/post/how-i-built-audio-lib-composite-pattern/) where I use composition completely without struct embedding. Not that I was avoiding it, but it's completely useless in my case.
Thanks for this but just curious but is there something lacking in current editors you find? Or is this just a itch? 
In this case, that would be over complicating things. But I am generally against labels and breaks to labels. There usually is a less clever way. 
Site appears to be down
This looks like an web IDE with some Go backend (I suspect trying to use Language Server?). I was expecting an UI written in Go for it given the title. And since it's only a website, why would it not work on Windows? Good luck with the development but it looks like it's in very early stages of development (or the screenshots don't do it ant favors on that side).
We use something like that: if err != nil { log.Println("action failed: ", err) return } One of my colleagues has written a wrapper func named *Check(err) bool* I get accustomed with all these if's so they don't bother me anyhow.
It's a bit thin on explaining how it works, or what the overhead is in terms of size.
Great, someone attempted to upload a malicious payload.
Fixed the issue.
Well, thanks for telling me not to use fasthttp, that really helped me...I've figured it out the issue digging in the source code...
People. What a bunch of bastards.
What happens if the crash happens while writing records to the WAL? I guess that makes the WAL unrecoverable?
Let us know when it's back, thanks!
If there are no return variables, return will just end a func early
Neat project, what advantages does this have over VSCode or Sublime?
FastHTTP is not a good library. In real world tests stdlib smokes it. My team has spent extensive time benching it in numerous scenarios. FastHTTP is only good for extremely fast responses (EG, hello world)
this blog post is such a good read. please write more of them!
Super interested in this and would love to read it when it comes back. If you want to give me a poke I'd love to see it.
Thanks, that's really encouraging, I'll do my best!
Anything that will be different to https://github.com/volatiletech/sqlboiler ?
Embedding is by definition composition from a pedantic comp sci perspective is it not? I think your taking the primitive definition and restricting it to abstract concepts (people, middleware). But each time you embed a type you are performing composition in it's most primitive form: type strInt struct { string; int } // or c struct strInt { string s; int i; }; Here we created a composite structure strInt. In Go we can allocate one: obj := strInt{"",1} I created a strInt using a **composite literal**. Composite. Composition. If Go's type system did not support composition you would not be able to build useful programs. Edit: Reading your second reply it seems your point is: &gt; "Composition and struct embedding are two separate ideas." I agree that they are separate ideas because one is much more abstract (composition) and one has defined semantics as a feature of the language. The post reads a bit like you think the author wasn't performing composition, or perhaps composition may not even be achievable with embedding. I guess I don't even see the value of your post other than pointing out what you feel are more concrete uses of composition, but doesn't disqualify the authors blog post I think. The very act of combining a string and int is composition.
I was wondering about that. Thanks for the tip. Do you think there is any value in compiling to Go's AST but just implementing my own Go prettyprinter?
It looks like /u/msgtonaveen is referring to [object composition](https://en.wikipedia.org/wiki/Object_composition), which seems to be achieved by struct embedding. You're referring to [functional composition](https://en.wikipedia.org/wiki/Function_composition_(computer_science)). So aren't you both talking about composition? Or am I missing something? Edit: formatting, non-mobile links
Non-Mobile link: https://en.wikipedia.org/wiki/Object_composition *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^110222
Embedding also grants access to the embedded types Fields- as well as an additional field name becomes reserved under an identifier that is the name of the unqualified type. No matter what you have a new assignable field and even if it isn't "useful" you still created a new data type through composition.
"composition" is an idea. Struct embedding is a means of achieving composition. Faiface's beep library is another way of composing data types, without using struct embedding
Exactly. We have awesome vscosde, vim go, Sublime, golangd, eclipse etc. Why though?
Use a go routine in the function, and not in main. You don't need a buffered channel. You want the program to run until all addresses have been printed, but main will exit as soon as it starts the printing goroutine, as written. https://play.golang.org/p/Fu6qVdDesZ
A few things... sqlboiler creates their own boilerplate, with gnorm, you're in control of what gets output. The things I don't like about sql boiler: 1. The fluent interface is almost always a bad idea in Go. 2. It says it's type safe, but it's totally not... take the example query Where("age &gt; ?", 30).... there's nothing that ensures that age is a valid column, or that an integer is a valid value for that column. What if age is actually a string? Finally, Gnorm is not just for go code. It could generate protobuf output, a REST API, etc. 
Yeah,... it's tricky, because you write the templates, so you can make Gnorm output whatever you want. I added a demo video. I'm working on some example templates, too.
Can anyone explain to me the use of .gxml (gos.gxml), which looks like it's the entry point for the app? Why not just use a normal main.go?
Been playing with neelance library, it's pretty straightforward...i'll use that library for the project, here are the changes https://github.com/klud1/graphql-docker-api/tree/migrate-lib
for the record
&gt; Embedding is by definition composition from a pedantic comp sci perspective is it not? It absolutely is. And I wouldn't even call it a pedantic definition either. 
Formatting is a bit of a mess, but it looks to me like you got networking wrong: you don't need the `ports` directives for the two dbs. The `auth` container will be able to connect to the dbs because of the `depends_on` directive. Plus, you don't connect to `localhost`, but use the containers' names instead. So remove `ports` from the dbs and change `AUTH_DB_PORT` to `5432`, `AUTH_DB_HOST` to `auth_db` and `USER_DB_HOST` to `user_db`. Should work, let me know if it doesn't.
Nice, congrats on shipping. You'll probably want to include a quadtree [constructor](https://golang.org/doc/effective_go.html#composite_literals).
Plugins are only supported in Linux, for one.
(Author of Badger here) Badger is being actively developed. We've spent quite a lot of effort into stability and performance. We need it in Dgraph, so it's something we'll keep maintaining. In fact, we're doing benchmarks against BoltDB and LMDB (expect a blog post in a couple of weeks). I think if your application doesn't need transactions (most don't), then there's a significant benefit in switching to Badger -- it deals with write workload really nicely, while giving close to the performance of BoltDB in reads.
It should be working now! :) Edit: Nope, but the source is at [github.com/chocol4te/isitabird-go](https://github.com/chocol4te/isitabird-go)
It's up :)
I think I broke it by uploading a webp file to it. Sorry bout that.
How? 
My biggest problem was that when I looked for Go XSD tooling I didn't find it, so my first instinct was, "OK, first I'll write XML Schema tools for Go" - which is a rabbit hole straight into hell ;-)
Is this a question?
Not on topic, but: &gt; Some people say that Go can’t express good abstractions. They mostly refer to the lack of generics. That’s because in most object-oriented languages, people are used to creating abstractions around types. In Go, the right way is to create abstractions around behaviour using interfaces. When you follow this principle, you find that Go is very powerful at creating abstractions. A C++ developer will likely complain that you baked in float64 in your interfaces. A typical C++ library would abstract the value type and allow custom behaviour using traits. In this case, you would get support for float32, uint8, uint16, etc. Traits are more static and faster than Go interfaces, but the compilation time is then 100x.
I do love your GCP Podcasts as I can listen to them on the train, I never get the time with juntforfunc as there's no easy way to download your jff YT vids locally :(
For what I need I found it to be the fastest
https://github.com/fasthttp-contrib/websocket or https://github.com/leavengood/websocket
What do you need? Are you really going to be serving static strings with no lock contention what so ever?
There is ... YouTube-dl :)
While I have a full example and nice pros: Is it considered bad practice to name your slice types to use a pointer receiver Add method to append? type posts []post func (p *posts) Add(more ...post) { *p = append(*p, more...) } With such code, I now tend to add this, but I don't see it often used, so I wonder if it's considered too tricky. I like the fact that it's quite simple on both sides, hides the implementation on the user side (also looks better than appends), and allow easy code evolution on API side. list.Add(post1) list.Add(post2, post3) https://play.golang.org/p/ouhPAobTx6
Short answer, no. It's still very new (6 months old or so.) It was basically mentioned as an early release in 1.8 and Linux only. I'm a bit surprised it didn't start in golang.org/x/plugins but the compiler changes may have made that difficult (need to mention that the plugin docs mention it being incomplete.)
Yes, embedding is a primitive form of composition. My point is, that people interpret "composition over inheritance" in such a way that instead of inheritance we should use embedding. Which is completely not what it is supposed to mean. There is a huge value in composition and many people just think that embedding=composition, which sort of puts them on a wrong path. EDIT: Oh, btw, mere struct creation is composition, too. Yet we don't say "composition over inheritance" = create structs.
If you use firefox, there is also Video DownloadHelper extension. Or with Windows, Internet Download Manager.
Also, Fransec will be talking about io.Pipes tomorrow at Golang Syd!
yeah, but it's a manual step whereas with the podcast app the episodes are just there. Thanks for the work though, learned loads about golang from you!
&gt; Go has one of the best communities Right after you said &gt; Just go find another language and **leave Go alone** He asked a very simple and straightforward question your response was just meansprited. You are obviously not one of those who makes our community great. EDIT: Just checked your short 2 months history and it seems this is not the first time you ask people to leave this subreddit.
OpenID + Image Processing on backend
I haven't tried that so I can't give advice. I have thought about stripping out all the line positioning information from a clone of the Go AST, and modifying the Go-derived parser and pretty-printer. The comments would then also need to be changed to attach directly to the AST nodes in the parser instead of the pretty-printer as happens now. One issue with all that is if a Go 2 has quite a different syntax to Go 1. Because such a Go 2 would need to use the Go 1 AST, one's own AST would need to stay compatible enough with the Go 1 AST to work with that. 
People have mentioned various downloaders but so far haven't mentioned [`ytdl`](https://github.com/rylio/ytdl) which is written in Go, and provides both a command line tool and a package.
Yeah, that helps a lot! And I agree, who wants to write *that* code? 
Yet another great tutorial, with an opening from a great country! :) The writer/footer correction makes me think of this classic: https://youtu.be/Ub7MkK-a0hU?t=13
I think it is a failure. It is only half-baked and wasnt even finished in the next release. It is standing in contrast to all this "let's all think about a usecase before adding some feature/generics - and then let's make it right" talk...
Just tired of people coming here and other places, complaining about Go... how it's not working for them... and how it needs to change to fit their needs. Sorry, how I was raised... if something doesn't fit your needs or objective, you find another solution. You don't demand the solution you're looking at change to fit your needs. That's only 10% of the battle a lot of us face in here. I agree that I don't 'increase' the community warmth by these kinds of responses; however, people who demand these things don't either... and seeing as my responses to which you're referring are to those... hopefully I don't need to further explain why I don't think they're as deconstructive as you assume.
&gt; Especially when trying to create a performant DB (in writes). In theory, WAL *may* improve write performance under certain circumstances. Commit, OTOH, is pretty expensive compared to not using any journaling. &gt; For example putting this in front of BoltDB would make sense, am i right ? Sorry, I don't know much about BoltDB. I guess /u/tv64738 might have an insight. &gt; I am also right that this works with concurrent reads and writes but only one writer at a time ? It's a bit more [complicated](https://godoc.org/github.com/cznic/file#hdr-Concurrency). &gt; Is it possible to do some examples just to illustrate the WAL mechanism of writing, commiting and then read from the commited ones ? [Example](https://godoc.org/github.com/cznic/file#example-WAL).
Yeah sigar and friends are perfect for monitoring applications, but a bit heavyweight when all you want to do is keep from swapping/thrashing. I don't want to maintain a one-function package, I'd prefer if something this trivial were part of the stdlib...
&gt; It's a bit thin on explaining how it works, or what the overhead is in terms of size. It works by collecting writes in a journal and replaying the journal on Commit or reopening the WAL after a crash. [Journal overhead](https://godoc.org/github.com/cznic/file#hdr-Journal_allocating_and_size).
&gt; What happens if the crash happens while writing records to the WAL? I guess that makes the WAL unrecoverable? * [Crash before Commit](https://godoc.org/github.com/cznic/file#hdr-Crash_before_Commit). * [Crash during a Commit](https://godoc.org/github.com/cznic/file#hdr-Crash_during_a_Commit). * [Crash during journal replay](https://godoc.org/github.com/cznic/file#hdr-Crash_during_journal_replay). 
How does it compare to https://github.com/paulmach/go.geo/tree/master/quadtree? :) That was has been around for a while already.
If you don't see something often it's usually not because your so clever no one else thought of it ;) I believe most prefer appending because: list = append(list, post) list.Add(post) // add does what? Is add for math? Is add for adding to a database? To a map or other complex structure with locking? Essentially I have to look up the Add method because it could mean anything. Append can mean only a single thing so the mental load is zero.
Doubtful. Give it more than 7 months...
Lol. Yeah. And the image processing is so fast that it matters that the HTTP lib needs to be a few microseconds faster.
Would you mind comparing `gnorm` to `xo`, which on the surface seems very similar?
They are very similar. Gnorm was written after I started using xo and wanted something better. Here's the differences: 1. xo is *only* for generating go code. The functions and data available to your templates have a ton of assumptions that you're generating go. Gnorm can generate protobufs, apis, docs, code in other languages, etc. It makes no assumptions about what you want to generate. 2. xo only outputs code to a single directory. Gnorm lets you customize the directory so you can, for example, output code for each table in a different directory. This makes namespacing a lot nicer (you don't have to prepend everything related to the user's table with "UserTable-" to avoid name conflicts). 3. Gnorm has better documentation. This was a headache when trying to use xo. What functions are available, what do they do? What data is presented to my template? You have to go look at the code. Gnorm has a documentation website as a first class part of the project. It's one of the things I am very keen to keep maximally useful. I did a bunch of work early on Hugo, and so I'm used to having documentation at my fingertips when writing templates. 4. xo can translate specific queries into go code. I've heard this is used by a lot of people. Personally, I'm not sure I understand its utility, but it's something gnorm can't do. 5. xo supports Oracle, MS SQL Server, and SqlLite, which Gnorm doesn't support, yet (gnorm supports Postgres and MySQL, though I definitely intend to broaden DB support). 6. There are a few missing basic features in gnorm that are coming real soon now, that xo supports right now, such as including indices, constraints, and keys... but these are the very next thing I intend to implement, so they won't stay a differentiator for long. All that being said, xo is a fine project, and I don't think you'd go wrong using it at work or on a side project, if it does what you need.
Yes. Take a look at https://godoc.org/fmt#Stringer
That's exactly correct. There's an interface [`fmt.Stringer`](https://godoc.org/fmt) which, if implemented on your type, is used to get the string representation when calling `fmt.Print` and family.
It has to be called String() because fmt.Println is simply checking to see if that function exists. It can't check for all possible itterations! Further more, anything beginning with a capitol letter is an "exported" function, meaning it can be run from any other package when imported. If you make the S lowercase, then the function can't be run in another module.
Also, if you change the name to string() or whatever(), you'd have to change your fmt.Println lines to look like this: fmt.Println(ByteSize(2048).string()) 
There's been no indication that I've seen that it's made significant implementation progress. It's still in a planning stage, so syntax suggestions would presumably be accepted, but they'd probably prefer those suggestions in the form of an experience report. 
The Go devs have previously stated that 2.0 is pretty much going to look exactly like 1.9. They don't want to have a situation like in python where changing from 2 to 3 introduced so many changes that people simply haven't migrated their code. Instead, the idea is that they want to do small changes all the time, and keep releasing. The next version may be called 2.0, or it may be 1.10, but there certainly won't be any big jumps.
Thanks for taking the time to respond! I look forward to trying out Gnorm soon. I have a Node/Postgres app that I'm wanting to port to Go, and these generating tools seem very convenient.
Make it then.
Thanks for that. answers my question clearly.
 const ( KB = 1024 MB = 1048576 //KB * 1024 GB = 1073741824 //MB * 1024 TB = 1099511627776 //GB * 1024 PB = 1125899906842624 //TB * 1024 ) If `MB` is `KB * 1024` as the comment suggests, why don't they just write `MB = KB * 1024`?
The next version of Go is 1.10. [milestones](https://github.com/golang/go/milestones).
[removed]
What you have described here is generally called ```stutter``` and does definitely look ugly. The ```go vet``` tool will even warn you about it with the one exception of your example above. 
See [the go2 blog post](https://blog.golang.org/toward-go2).
Yeah, I'm aware of that. It is pretty ugly, I agree. But the alternative is to have a chaotic `services` directory in this case. Placing interface and implementation code in the same directory makes sense in most other programming languages (since they'd probably live in their own self-contained subdirectory/subpackage), but trying to do so here while following Go's conventions causes directories to inflate to ridiculous sizes and become unreadable. What, then, is the "Go way" of avoiding such bloat while still following conventions? 
I wasn't building a youtube Downloader because I thought it was sorta frowned upon and ethically not a good to build. I can build a Youtube downloader in like 3 hours. Use a third party Service for parsing and use [pluto](https://github.com/ishanjain28/pluto) for downloading.. Now I think I'll just start building it right away.. ;) And since that doesn't solves the problem you have, Are you okay with mp3 versions of justforfunc that can be played in a podcasts app? I can do the same with mp4 files too if there is an app for like video podcasts..
Nice to see people actually putting effort in producing experience reports on the topic of generics - instead of just pointing to solutions, people making points on how the current approach fails or is sub-optimal.
So remove "service" from the subdirectory types and packages. - services/ - user/ Then it's `user.User`, which is generally an accepted form of stutter, and is also short.
Your current ```userService.UserService``` is actually idiomatic, though I would see /u/Slythe2o0 's reply for a more concise way. The issues with stutter come about when you do things like ```userService.NewUserService``` or ```userService.UserServiceRegister```. 
WALs usually sit in front of write-in-place designs, BoltDB is a copy-on-write design. With a WAL, the only reason for BoltDB to do CoW would be for the atomic snapshot views, and there'd probably be a cheaper way to achieve that. Having both active at all times is wasteful. Then again, I'm biased because I think a better solution is to have a higher concentration of writes on the few top-level nodes of the tree: https://github.com/boltdb/bolt/issues/360
Doesn't that lose the "context" of the package, then? Glancing through the code quickly, a casual reader wouldn't know if the `user` package was referring to a `service`, or a `model`, or a `template` or a `controller`. The naming conventions work reasonably well for libraries ( an imaginary "http.Router()" is fairly self explanatory and "pretty" code ), but I haven't actually figured out how to make code look good in web application code.
I changed that myself. Just cultivating the habit of reducing unwanted computations. :)
Cool! Thanks for the detailed answer. That example made it much easier to grasp. Will play with it now :) Keep it up! 
But there's no reason to up a major version number without breaking changes. 
All of the other answers about implementing the Stringer interface are great. It is also worth mentioning that capitalization plays a big role in Go as well. so swapping the method name from String() to string() is more significant than you might think. See here: https://tour.golang.org/basics/3
Thanks for chiming in and it make sense indeed now :) Neat idea with that buffered parent top-to-down indexing strategy. Now we only need talent coders like [https://www.reddit.com/user/0xjnml] or yourself to get it started ;)
You can run your own playground with your own set of restrictions.
Don't plugins also have to be EXACTLY the same build tooling version, architecture, flags, etc? Also IIRC no interop with go/cgo. Hashicorp's "reuse fd#0" and RPC over http/json plugin schemenis, by comparison working and very usable. (Edit for anyone interested: plugins aren't expected to use stdin, so they reopen stdin as writable, and write some."find my RPC server here" line that the parent process reads.
Run vim + vim-go + the other Go tools it needs and you'll have a good editing experience (aka an Integrated Development Environment). The question is however, and maybe because of my lack of understanding, why do we **need** such an editor for Android / other mobile platforms. In which conditions does it need to operate? What are the cases where the above vim combination wouldn't be enough? 
Thanks! The check function was the thing I was missing. Works great.
There needs to be interest for this as well as people to actively work on the support for other platforms than Linux and OS X (support for OSX has been re-enable in the latest Go Tip). I haven't seen anyone interested in adding support for this for Windows. Also the unload functionality is a big problem same as it doesn't allow reloading a plugin. The interface with how plugins are used is also showing the issues with Go's type system. I wouldn't say they are a failure, but they definitely need more attention and people working on making them more useful than they are today (and I'd love to be called wrong on this one but I don't think 7 months will be enough given the current state / evolution). 
So you know what DB OP is using? I meant to say "a couple of queries in parallel per request".
IMO - it's not a failure, but its uses are far less than they might have been, and it sounds like there is no plan to change that. It is simply NOT a 3rd-party plugin system. That doesn't mean it doesn't have utility as a 1st party plugin system.
You inspired me to finish documenting and releasing [mine](https://github.com/lpar/kpwgen).
Your question implies that a package like `user` should refer to either a service or a model or ... and never to all of them. But this is common in Go: What's related is grouped in a package.
You should return errors instead of panicing.
Computers are fast and cheap. Humans are slow and expensive. You shouldn't be sacrificing readability to prevent 4 multiplication operations. The operations don't even happen at run time - they happen at compile time: % cat &gt; main.go package main import "fmt" const x = 2 func main() { fmt.Println(x) } % go build -o x2 main.go % cat &gt; main.go package main import "fmt" const x = 1 + 1 func main() { fmt.Println(x) } % go build -o x11 main.go % sha1sum x2 x11 515ccebaedfdedd5f3adba0d600b1d02873670b6 x2 515ccebaedfdedd5f3adba0d600b1d02873670b6 x11
What's Hugo really usefull for?
&gt; They don't want to have a situation like in python where changing from 2 to 3 introduced so many changes that people simply haven't migrated their code. Python 3 comes with a `2to3` tool which will actually deal with loads of the boring stuff for you. Package renames, function renames, and whatnot. Easy! It's not necessarily the *quantity* of changes, more that some changes can't be easily migrated except by manually auditing your entire code base. The biggest issue in Python 3 was of course entire *raison d'être* for "Python 3000" in the first place: the unicode change (everything else was tacked on later). No script in the world will ever be able to figure out if a bytes or unicode object was *intended*, so all the changes need to be manual. Ugh. I don't care if Go 2 changes loads of things, as long as I can run a script to update my source tree *and* be guaranteed that it will update *everything*. A simple example might be adding a new keyword; with the Go 1 comparability guarantee that can't be done because local variables or functions will override that and will cause problems, but Go 2 could do that. It would also be easy to write a script to tell us where those variables are used and automatically rename them (e.g. by adding an underscore or some such).
Hugo is a static site generator that turns your content files (e.g. written in Markdown) into static HTML pages unlike a CMS that regenerates a page on each request. A more in-depth description and a list of pros and cons for the usage of a static site generator can be found [here](https://gohugo.io/about/what-is-hugo/)
The audio only version would be superb, I can download them myself but a friction free version would be superb! I can always review the video later.
&gt; Instead of having type specializations, the backend could change and a JIT compiler is used to generate code once a hot loop has been found. HAHAHAHAHAHAHAHAHA. No. &gt; This won’t happen. At least not until AppEngine allows for such things. Go has a long standing policy of not having runtime code generation due to use in AppEngine. Maybe JIT can be used as an option for Go compiler, let users choose generating code at compile time or run time. JIT is not only a generic solution, it also has many other usefulnesses.
Uhh, channels as iterators is a bad idea. https://github.com/chewxy/gorgonia/blob/1dee6d288652eeb5138eae4793653150c219335e/tensor/iterator.go#L566 Any codebase that has that, maybe doesn't deserve language changes at this time. Make it be good Go first.. (found via https://github.com/chewxy/gorgonia/issues/135 )
Sure, language changes are okay. You need to have a reason though. A lot of language syntax is arbitrary, so most of Go's syntax probably won't change if only because there's no reason to change it. But if you can come up with a reason for some major change, then people are open to listening to your arguments. I think people are misunderstanding what they said about backwards compatibility. What they said was we won't have a Python 2 -&gt; Python 3 situation, where Python 2 code needs major manual work before it is useful in Python 3. There are many ways to allow language syntax changes such that we don't have a Python 2/Python 3 scenario.
Could you point to some code w.r.t the Hashicorp comment?
How is it a bad idea?
Gladly: - plugin: https://github.com/hashicorp/go-plugin - Mitchel talking about the design: https://youtu.be/SRvm3zQQc1Q
Video linked by /u/Loves_Portishead: Title|Channel|Published|Duration|Likes|Total Views :----------:|:----------:|:----------:|:----------:|:----------:|:----------: [2016 Kickoff - Hashicorp &amp; Go Plugin Architecture](https://youtu.be/SRvm3zQQc1Q)|LA Golang - Santa Monica|2016-02-19|0:53:34|48+ (100%)|3,596 &gt; Mitchell Hashimoto from Hashicorp discusses how the team... --- [^Info](https://np.reddit.com/r/youtubot/wiki/index) ^| [^/u/Loves_Portishead ^can ^delete](https://np.reddit.com/message/compose/?to=_youtubot_&amp;subject=delete\%20comment&amp;message=dmvdudb\%0A\%0AReason\%3A\%20\%2A\%2Aplease+help+us+improve\%2A\%2A) ^| ^v2.0.0
&gt; Maybe JIT can be used as an option for Go compiler, let users choose generating code at compile time or run time. I'm intrigued. This would sound like a supercompiler pass or something
What about [an approach like this](https://play.golang.org/p/bteBawo7SK) where you just do everything as unsafe operations on a slice of bytes? Then you don't need to care if the bytes represent an int or float, 8 bytes or 4 bytes… The hard part is that Go isn't great at inlining, so the operation calls will probably end up being really expensive.
Hi! I have done some refactoring. I took into account your suggestions and have refreshed the vision of the library. Could you look on it and share your opinion?
&gt; an approach like this That was an early approach. Doesn't scale to these cases: * Network memory (misguided attempt at "ooh let's use the cloud to do computing!") * GPU memory * Manually managed memory You end up having to store pointers - and 3-word structure stores it better than `[]byte` &gt; you don't need to care if the bytes represent an int or float, 8 bytes or 4 bytes Right now Gorgonia does what you do in your play example. It just doesn't store them as a `[]byte`, but in a rawer form &gt; `binaryiop` The binaryiop func type in the playground looks interesting. Could be an idea to explore
I wish they would just go back to the C way of &gt;int x = 7 instead of &gt;var x int = 7 which is just so stupid and unnecessary. They did it purely to be different when it is just weird and janky.
channel based iterators are generally slower than say your bog standard stateful iterator + mutex locks. The method was produced as a convenience tool for end users who may want to use Go's channel semantics
&gt; instead of just pointing to solutions It really felt like that was all I was doing tbh. 
Until Youtube wants to provide an offline experience, which makes inserting relevant Ads harder, thats the way it is.. I too thought about a tool that converted an Youtube channel to a Podcast, if the channel owner agreed to it. That is probably against the terms of service anyway, and the content creator wilil receive even less for his time investment..
You are incorrect. It was done for very good reasons and it is actually C's style that is the stranger one. See https://blog.golang.org/gos-declaration-syntax for a discussion.
hahaha, I noticed too late and decided to somehow fix it without rerecording. next time I'll try to add some joke into it :P
You can change the code inside the `/` handler to be: f, err := os.Open(r.URL.Path) if err != nil { if os.IsNotExists(err) { http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound) return } http.Error(w, err.Error(), http.StatusInternalServerError) return } http.ServeContent(w, r, info.Name(), info.ModTime(), f) f.Close() It will require some extra code check just to know stuff like if the file exists, or if the path is a correct one and so on, but that way, you can still serve your static asset. The reason why you're not getting is because you're using `http.FileServer` which is a full featured file server, which is a handler by itself, but not getting called as a handler. It's meant to be passed to a function that can execute handlers.
here's what i do: /api /user.go /store /user.go /schema /user.go /schema defines all the relevant structs (with the appropriate tags) that my service will use. - this includes the data that is exchanged between my service and db as well as the data from service to http response. Usually they are the same, but on some occasions you might want to do in-memory aggregations. As an example... type User struct { Name string `json:"name" bson:"name"` } type AllUsersResponse struct { Count int `json:"count"` Users []User `json:"users"` } /store defines the Interface for all the interactions that my service supports type Store interface { GetAllUsers() ([]*schema.User, error) GetUser(name string) (*schema.User, error) } type MongoStore struct { session *mgo.Session } func (m *MongoStore) GetUsers() ([]*schema.User, error) { // m.session.C("users").Find({}) } func (m *MongoStore) GetUser(name string) (*AllUsersResponse, error) { // m.session.C("users").Find({"name": name}) } /api defines the routes that my service will support (i.e. using echo) func SetupRoutes(e *echo.Echo) { e.GET("/api/users", func(c echo.Context) error { // users, err := store.GetUsers() }) e.GET("/api/users/:name", func(c echo.Context) error { // users, err := store.GetUser(e.Param("name")) }) } Of course I'm severely oversimplifying the code examples but what I'm hoping you'll pick up from this is a clear division of layers in data transfer when you organize your packages this way...
Probably also worth linking to: https://gobyexample.com/interfaces
I think you can also use `http.ServeFile` by changing all the above code to: http.ServeFile(w, r, r.URL.Path) This is way less verbose but the above code can help you out understanding the overall flow.
Really getting concepts on io.Pipes in a way that I hadn't before, as well as other simpler concepts within it. Thank you. A lot of the other justforfuncs somehow find a point they go over my head, this one hasn't, and has been the best of the learning for me.
Glad it was useful! I'm curious about the ones you've had issues understanding. Could you tell me more.
you should use the range option. the first example will continue to print "" after the channel is closed on every iteration of the loop due to the [behavior of closed channels](https://golang.org/ref/spec#Close). the range option works as expected since "the iteration values produced are the successive values sent on the channel until the channel is closed" [from the range clause spec](https://golang.org/ref/spec#RangeClause).
OT: I loved GopherCon Singapore !!! Such a surprise ! Hope it will be organized again in 2018... 
As a rule of thumb, anytime you see a channel receive and it's not part of a select block, you're probably doing something you could have done more easily with a mutex. 
A combination of unnecessary overhead with silly restrictions on API, especially around errors and early termination. For inspiration on how to do it right, see https://golang.org/pkg/bufio/#Scanner
I have never seen a supercompiler that comes very close to living up to its promise on anything but very tiny scales, and at great CPU cost. I don't think Go is going to be where that changes.
The problem with JIT is that a lot of the easy stuff is already done in Go. Go is already only 2x-3x slower than C, which may make it sort of slow as fully-compiled languages go, but it already beats every other JIT except Java that you've ever heard of. Javascript, for all that you may have heard about how fast it is, generally strains to get to 10x slower than C, _with_ all that JIT'ing. There are some things I can imagine a JIT doing but it'll be an awful lot of complexity for not really that much gain. (I hypothesize there's an effect where people read a series of stories about how this microbenchmark is 75% faster in the new version of JS and this other microbenchmark is 4x faster and etc etc etc. and don't realize that these things are all separate speedups, not things that directly compose together, and that they forget the whole JS shebang started out years ago in the 100-500x slower than C range. Thus we get people who still believe JS is a "fast language". It is only a "fast language" within its own space of language types; in general, a lot of other languages are _much_ faster than it is. And even in the dynamic language space LuaJIT spanks JS.)
&gt; https://github.com/golang-standards/project-layout Oh that's just retarded. Unless you have the consensus of the core developers, don't name your pet project "standard". (And if it is "standard", it belongs in the golang organization.)
Please reconsider your word choice. 
Would have to take one as an example, but I was not a programmer before I was put into a job as a golang programmer. In part due to a reorg. So my general statement regarding golang teaching is, it really is catered towards people who have programmed in other languages. There are a lot of things assumed, and that makes it quite challenging to understand. I'm now several months into this job, and I keep increasing my own knowledge, so it may just be that I know enough core concepts at this point that learning is easier, and it's less to do with justforfunc changing in any way. I'll go back and watch a few and see, but I think that's probably the case.
Its creator gave an excellent talk about it at GopherCon 2017. The talk explains a lot of things, and perhaps the answer you're seeking may be there too. https://www.youtube.com/watch?v=x-LhC-J2Vbk
keyword: option. :) &gt; Go is already only 2x-3x slower than C Do you mean the runtime performance. In fact, JIT will make the the runtime performance better. Now the instructions produced by gc is the same for all x86 CPUs, no matter what the detail model a CPU is. JIT will do some special optimizations for different CPU models. Yes, producing instructions needs some time, but this is a one-time cost.
[removed]
I have a cron job that calls youtube-dl and then sticks it somewhere that gets copied to my phone at home. :) 
Also compare [cdecl.org](https://cdecl.org) vs [godecl.org](https://godecl.org).
question, are there statically typed languages out there that use a tiny virtual machine and bundle that VM with each compiled program? 
I've seen third party once or twice in some larger projects.. but I just assumed it predated vendoring. Is this good information to give new Go developers? Furthemore is there some newer spec or document that names third_party some kind of official thing that I missed?
From my limited experience, the infinite loop for + select is useful if you are reading from multiple channels. You will also have to add the logic needed to break away from that loop. If you are reading from a single channel, the range is pretty solid. It will iterate until the channel is closed and empty.
Java? /troll But I think CLR works somewhat like that minus the small part
Mike Pall is a god. I don't think it's particularly fair to compare his work with other people's. Also Lua has better internal structures than JS. JS' crazy internal structures came about from poor specifications of the language 
I totally agree on both counts. I consider LuaJIT to be a demonstration of how fast even a relatively nice language can be made to go if you don't subscribe to the idea that "languages aren't slow, only implementations are" (as my understanding is that LuaJIT is cut down somewhat from Lua, but still quite nice), and the general inability of the other languages to get to its speed as further confirmation that, yes, you can't just take a language that had no thought given to speed and make it go fast.
I used graphql-go. It's ... OK. My main issue with it is that there doesn't seem to be any good approach to limiting the amount of data retrieved from a backing database based on what the query is for. This seems to be a hard problem, judging from how rare attempts to address it are. It's also verbose as hell. Usable, though. 
&gt;In fact, JIT will make the the runtime performance better. The problem isn't that JITs can't make Go better. The problem is that a JIT that makes Go better will be _much more expensive_ than it would be if Go was a much slower language and it was leaving tons of performance on the table. It is leaving performance on the table, by the priorities of its developers, there is room for an improvement, but it isn't leaving _tons_ of performance on the table. (You should think about performance logarithmically, in which case, 2-3x isn't actually that much room for improvement.) And JITs generally cost more than their proponents estimate, are slower than they estimate, and take much _much_ more work than they estimate to create and make work. Speeding up Javascript with a JIT by comparison was really quite easy, even in the beginning, because it was such a slow language to start with. Of course a _really_ good one took a lot of work, but the fact that the bar was set so low initially made it a much more obviously valuable proposition. If you're going to go this route, I'd suggest a much better bang-for-the-buck right now would be to just go ahead and lift the compile-time speed requirements and make a conventional optimizing compiler. Just because the Go team has the priority of a fast compiler doesn't mean that all Go compilers written by anybody else must be fast too; the core Go team's goals are met as long as they have a fast compiler and a language that _can_ be compiled quickly, even if somebody else writes a slower and more thorough compiler.
 The `third_party` convention comes from https://opensource.google.com/docs/thirdparty/ and in the case of Go, I would only recommend it if you're hard forking the project, when it moves beyond vendoring.
It depends on where you want to draw the line. Every statically-typed language has a "runtime" of some sort, yea verily, even C, and a whole lot of assumptions about calling conventions and such, which is why calling a C function from Go is such a violent affair, as it is in many other languages that fully reject the shape of the C runtime. They're not "VMs" in the sense that they have an independent bytecode that is being interpreted, which is probably what you really mean. My real point here is more not to underestimate the runtimes being provided by these languages; they may not make it to "VM" in your mind but they probably make it farther than you think.
Have you tried dgraph I have never used but know it due to badger. I contributed to project and I think it's a nice fast key-value store if you don't need transaction system. 
My notes for `graphql-go/graphql` indicate it was an `interface{}` hell. `neelance/graphql-go` looked better. There's also https://github.com/sevki/graphql with introductory blog post at https://fistfulofbytes.com/graphql-and-g2sd (see also GraphQL to SQL translator at https://sevki.org/g2sd ) Semi-related, https://github.com/rgraphql/magellan is not GraphQL but is inspired by it, if you only want "something like" graphql.
[removed]
awesome video, thank you! Those `Multi` types look really cool. I have found myself using `chan io.Reader`in the past and I feel like there are use cases for `io.Pipe` in those places. Are there plans to make those buffered like channels, where maybe the write is not blocked if there is nothing reading yet? could you have simplified the `writer` type you created by embedding the `*io.PipeWriter` inside it? type writer struct { *io.PipeWriter done chan stuct{} } *edit:* you'd end up having to override(?) the `Close` method to send on the `done` channel anyways so nevermind.
Usually the query is for a service not a direct connection to the database, so you'd put in the limit in the service layer. Perhaps a deeper example and I can help further. 
Thanks. I guess I will just implement my own session management. The Gothic seems more like a naive simple example more than a library that can be used by most applications.
Very interesting. Is it resilient enough to survive format conversions or anything like that?
Ok then, I'll start working on it today after college. Shouldn't take long.. ;)
Use the range, it behaves better when the channel closes.
&gt; you can't just take a language that had no thought given to speed and make it go fast. As V8 has shown, you CAN... but you have to spend a shitton of money and manhours and many many fun variety of hacks like Lithium and Hydrogen and many phased JIT compilations on it. 
Another alternative: https://github.com/ilyash/E
The empty "pkg" package is definitely not a standard, even it is considered as anti-pattern by some.
If you use the code as-is then it should be vendored, but if you made your own changes to the forked code it should go in the third_party directory.
It's not necessarily pass-by-value - `context.Context` is an interface. Read through the `context` package.
Hey man, sorry- almost missed your reply. First I just want to say good job at accepting criticism constructively and applying it to your design, I think the outcome certainly speaks for itself. So I am not going to look at the code itself but I can comment on the interface at [godoc](https://godoc.org/github.com/regeda/go.failover). First thing is first, I don't think you need Master prefix on both your function names, it stutters in one and does't help clarify what it is for. Remember your package name is "failover" so everyone else will see it as failover.Master and failover.Slave, when next to failover.MasterMaster and failover.MasterSlave I would say the master prefix names may even be more confusing. It makes me think that there is 2 classifications of each function for both the prefix and the suffix or something, such as also a failover.SlaveMaster failover.SlaveSlave. But since no such association exists I think removing the failover suffix would give it a very nice api. It would also help clarify what exactly the Handler signature is this for: type Handler func(context.Context) (error, func()) I assume func() was the result of letting the user set their own result, and you have the good sense to try to avoid race conditions for them by ensuring if Slave is triggered before Master returns you only call at most one func(). But is it worth the tradeoff of such a unusual signature? Remember a big win with accepting context is integrating with the bazillion lines of code out there that looks like: func(context.Context) (error) So maybe instead simply change your handler to that. Then is there a reason you accept many masters in Master() but only one slave in Slave()? Might be nice to be able to shift to the entire group of slaves and would make it a bit more symmetrical with Master(). func Master(ctx context.Context, masters ...Handler) (err error) func Slave(ctx context.Context, master, slaves ...Handler) (err error) Now that you lost your func() {} what's a good alternative? Well most developers just use sync.Once for this exact scenario and call it a day. Being explicit on documentation with an example that uses sync.Once would be beneficial, but removing it from your API allows people to synchronize with whatever way makes the most sense for them. Remember many people may simply be calling another API that is already guarded by mutex or communicated to by channels. Now is the package very large? Not realy, is it super interesting to write or design? Not really. But it does it's one thing correctly, clearly and with very little restrictions. At the point it joins my very small list of packages (along with errgroup!) that I import without thinking twice about when the need arises, because proving it's correct is zero-cost and I know when I'm trouble shooting a problem there is ZERO doubt in my mind I will end up digging through a bug in this pkg. Good job again and even if you don't change a thing, it's still much better than it was I think. Happy coding man.
To me, it seems that dependencies being unable to silently override dependencies within my application is a feature, not a bug. As in, if I depend on github.com/foo, and they depend on /bar, I feel like I don't want my other dependency /baz to be able to silently replace my /bar dependency, even if they properly implement the interface. I would want any such functionality to require me to explicitly allow the override in some fashion. Am I misunderstanding your point? Or do we just disagree? 
"Tagged union with unsafe package" - good luck to debug GC issues. Go already has tagged unions - interfaces. Use it, and all'll be good.
Yes of course as everything in Go is passed by values. Even pointers are passed by value.
[removed]
Please see the Recoverer. Due to the fact, that the events are emitted in parallel goroutines, it is not possible to return an error. That's why there is a Recoverer interface to catch panics. https://godoc.org/github.com/desertbit/event#Recoverer Thanks for the feedback.
Hmm. I got totally opposite answers
The [selfie project](http://selfie.cs.uni-salzburg.at/) seems to come quite close: &gt; An educational software system of a tiny self-compiling C compiler, a tiny self-executing MIPS emulator, and a tiny self-hosting MIPS hypervisor.
Everything in Go is pass by value. What is your efficiency concern?
You must be young. I have been coding since assembly 86 and turbo pascal and I build few businesses in the last 20 years. There is no battle and if there was one it is to have more people adapt a language not to get offended by each question and ask them to leave.
That's not a reference. A reference is not a pointer, a reference is a more abstract concept. In Go, pointers are passed by value as literal pointers as opposed to as references. If Go arbitrarily changed the things you passed around so that they became pointers when they were not, that would indicate pass by reference behavior. Go doesn't do this, it copies whatever you send through (which in this case is a pointer)
the people saying "everything is pass by value" are being obtuse - they know or should know what you mean. Again, look at the `context` package. Many if not all of the constructors return pointers that implement `context.Context`.
&gt;So my general statement regarding golang teaching is, it really is catered towards people who have programmed in other languages. There are a lot of things assumed, and that makes it quite challenging to understand. Yup, I think the same but with some re-reading/re-watching and asking around in IRC/SO you can get most of the things :)
`context.TODO()` and `context.Background()` return pointers to said type.
Try telling someone that pass by reference and using pointers are equivalent in a language that actually has references as separate types from pointers.
[removed]
There is medium (180GB/s, ~30 servers) video service that serves video by go's net/http. Go allowed to use hdd drives more efficiently, make more fluent custom caching layer and custom mp4/dash fragmenter (using magic of interfaces), make flexible custom traffic shaper. Logging is certainly of "make yourself" kind.
From a readers perspective, having all the context really helped me understand your arguments.
Since there is no `*` in front of the type, it is passed by value. func foo(ctx context.Context) // Pass by value func foo(ctx *context.Context) // Pass by pointer However, `context.Context` is an interface. All interfaces are implemented with two machine-size (i.e., 64-bit on most machines) words, so they are small values and in most cases it is acceptable to pass them by value. Source: https://research.swtch.com/interfaces
And how do you think references are implemented in programming languages? With pointers.
Sometimes.
[removed]
&gt; [...] passing the address of a pointer by value is called passing by reference. No, not at all. Some languages do have actual references some don't. Go is in the "don't" camp. Passing a pointer to an A is not "pass by reference". Passing a pointer to a pointer to A is even less "pass by reference". 
Ok than how else could it be done?
A reference is a sort of interface, you could imagine it in go as ` type Reference interface { Dereference() Value }`. So anything that satisfies that could be a reference. If you wanted, you could have them be array indices or map keys, for example. Usually you'd use pointers for efficiency.
I know what is reference. I'm talking about how are references implemented in programming languages (and Go). Always it's pointer or some variations to it.
That's not true. If you wanted to implement a reference in whitespace, for example, you'd need it to be the number of stack pops needed to reach the desired value.
Thanks but your solution doesn't quite work. Not sure why. This solution worked for me func homeHandler(w http.ResponseWriter, r *http.Request) { http.FileServer(http.Dir("static")).ServeHTTP(w, r) if r.URL.Path == "/" { r.RemoteAddr = strings.Replace(r.RemoteAddr, "[::1]", "localhost", -1) log.Printf("Request of %v from %v", r.URL.Path, r.RemoteAddr) } } func main() { http.HandleFunc("/", homeHandler) http.Handle("/ws", websocket.Handler(EchoServer)) log.Println("Serving to :3000") log.Fatal(http.ListenAndServe(":3000", nil)) }
I mean implementation of the language. How do runtimes of Go, Java, and so one do it? To what assembly are references in C++ translated to?
I just gave you a non-pointer reference implementation. The resulting assembly would be a number that indicated how many times you pop the stack to reach the indicated value. Also, as we've already discussed, go does not have references.
Well this is pointless... This is like saying wheels don't have to be round, you can make square wheels. Ofcourse you can but nobody does it because its stupid. Same reason why nobody is making compilers in whitespace (and also because its probably not turing complete).
If the language doesn't support referenced memory, you can't use pointers to memory as references. I'm not sure what the debate is here, I've already said that a reference is generally a pointer. Also, cursory searches reveal that whitespace is Turing compete.
[removed]
You want to be rational, but I rather see you are trying to rationalize. These are different things.
[removed]
Imagine you are writing C++ compiler or Java interpreter. And you are smart person so you don't use whitespace. How do you implement references? That's the discussion. I thought whitespace only has stack. MB. But my point still holds.
You'll never please everyone. &gt; A: Check out this program I wrote in JavaScript! &gt; Z: lol weakly typed &gt; B: Check out this program I wrote in Python! &gt; Z: lol dynamically typed &gt; C: Check out this program I wrote in Go! &gt; Z: lol no generics &gt; D: Check out this program I wrote in Rust! &gt; Z: lol no higher kinded types &gt; E: Check out this program I wrote in Haskell! &gt; Z: lol no dependent types &gt; F: Check out this program I wrote in Idris! &gt; Z: lol no &lt;whatever thing is "better" than dependent types&gt;
[removed]
&gt; Z: lol no &lt;whatever thing is "better" than dependent types&gt; linear types (which are a little orthogonal to dependent types), but Idris also has them I think?
You're just wrong on this, trying to be quirky or whatever and go against C when C is totally right on this. For functions you can do whatever you want but variables should be declared type then name because it's clear and there's no nonsense syntax needed. int x = 7 It's just so clean and perfect. You go into the huge long winded meme lines where you're like HA C I HAVE YOU NOW and then show off that if you construct a huge line of functions calling each other then it looks a bit janky and then you design the entire language around this when it isn't something people would even do more than a couple of times. Here you go, here's a syntax that is enough of a meme for you to feel good about being different while actually looking somewhat good: int x = 7 x : = 7 function add(int x, int y) int { *int x = New() You declare variables like a normal person. You can auto type if you want. Functions look nice and you declare the type like Go rather than like C because that seems to work well. Pointers are declared like that because it looks kind of nice and clearly shows that it's a pointer at the front so it's unambiguous. Look how clean that looks, it looks like an actual real person language that people with jobs would use rather than the current front end developer random syntax cobbled together full of exceptions because the rules don't really work. Just move the language to that otherwise I'll have to cobble together my own shitty language or a compiler that compiles my slight syntax changes into Go and then uses the normal compiler and it will be terrible.
I've used https://github.com/neelance/graphql-go in production and really enjoyed it.
As a person who is just starting to learn go I find this to be widespread in the community. Whether it's the lack of generics, the error handling, the boilerplate code, the verbosity, the lack of a decent way to manage deps, or the tie to github they don't want to hear any criticism and have endless rationalizations for the language. 
&gt; You want to be rational, but I rather see you are trying to rationalize. These are different things. Can you explain? What makes this, in your view, rationalization?
[removed]
GraphQL is more like designed for Node.js, I was trying to use GraphQL with Go but .. it just makes the structure more complicated.
[removed]
I finally got this "issue" fixed, well it's not a properly issue and I solved it making some simple changes: 1) I think the most important change here was swapping from default http library to gin-gonic, where at first gave me the same amount of responses on workload as default http, but the things get started changing when I disabled al gin-gonic middlewares and logs, which is good because it means that it has on this scenario a very close performance as net/http but doing more 2) tracking down the bottleneck was on mongodb connection, for some reason it was taking more time than expected to retrieve the resultset. Reading more about how this driver works I found that changing the consistency mode to strong it should get a better read time, which happened as expected . The only gap here is I haven't found yet a way to set this mode on nodejs mongodb driver 3) there are more few minor changes that helped with little pumps like copying the connection on each request and using a struct to map the resultset In the end I got 20% average better performance to go code and both are keeping around 10% of connection lost or timeout Final considerations that are important: - this is a study model just, it meant to give me some to work with golang using my day to day needs - all services and servers are running on the same VM, so it's not a production ready solution, again, it's just for studies - With great performance comes great responsibilities, golang leaves in your hands several options to get the best performance according a specific use case Cheers everyone
What is the state of i18n?
&gt; the error handling, the boilerplate code, the verbosity That is how Go is. I do not think that a lot "rationalizing" happens here. Pasta al pomodoro contains a lot of tomato and is red. This is a fact and if you do not like red dishes and/or tomatoes: Stay away from Pasta al pomodoro and do not try to convince others that pasta al pomodoro would be so much better if they simply would get rid of these damn tomatoes. &gt; the lack of a decent way to manage deps Nobody is rationalizing this problem away. People are actively working on dep. You might want to help here instead of complaining. (Also note that this is not a language feature. Neither Maven nor Composer are tied to Java or PHP.) &gt; the tie to github There is none. You must be mislead to believe this as most code is on github. The go tools knows about bitbucket.com, hub.jazz.net, git.apache.org and a few others and can work with arbitrary servers. And please stop thinking about `go get` as "this is how I have to manage my project"; it is not. &gt; the lack of generics This is a bit painful. But it seems that if you think of testimonials stating that nice, large projects can be done without generics without too much pain as "rationalizing away that generics provide helpful set of features for programmers" you are probably misinterpreting the generics discussion. Nobody doubts that writing a typesafe container would be _much_ easier and _faster_ and _better_ and whatnot with generics. What "the community" expressed often is: A lot of business functionality can be provided with the two type safe containers slice and map built into the language; it is possible to build systems in Go despite the lack of generics. (Probably because lots of systems do not need a plethora of data structures for hundreds of types to be valuable.). I think it is 100% clear to the community that if your task is to "write a type safe red-black-tree to store arbitrary types" or "write a type safe and fast matrix class for arbitrary semirings" then generics would help (a lot) and the task is almost undoable without generics. 
Hugo supports i18n since version [v0.17](https://github.com/gohugoio/hugo/releases/tag/v0.17) and improvements have been added since then. You might have to be a bit more explicit about your expectations.
I skimmed the article and found I mostly agreed with it. I didn't like static typing until I started using Haskell a lot and now you can pry it from my cold dead hands. It's not just that "the types" are static in Haskell, but also the effects. This means you can literally make things completely impossible when coding certain functions. Which helps with bug finding, not lines of code produced. I tell people that over time you might initially get more out the door with a dynamically typed language, but maintenance is where a good type system (not just statically typed) REALLY makes a difference. Over all the article seemed fairly balanced from my brief skimming :)
Yeah, I like Haskell too. As a mathematician I find it *extremely* elegantly designed. But personally, I like it for its aesthetic value - in practice, I just think closer to the machine than the math when programming. I am comfortable in the middle :)
Tiny nit, your second `d.sum()` on line 90 should have been `d2.sum()` like so: https://play.golang.org/p/7UBbwNSGyU
I hope it helped
I don't consider V8 fast. It's still ~10x slower than C. [Node, which I believe is V8, doesn't even make it into the fast half of the graph](http://benchmarksgame.alioth.debian.org/u64q/which-programs-are-fastest.html). (For some reason, that page has two graphs, and it took me a while the first time I saw it to realize they're basically just one graph, just weirdly cut in half for some reason.) If Node isn't V8 it's probably still a decent proxy. (Also, I'd point out that a lot of the stuff on that site is numeric stuff that ought to be just about the best possible case for JITs, and that's still where it comes out. I wouldn't be surprised it's more like 20x slower than C on real code.) This is what I was saying in one of my other posts. I think people read series of posts about this microbenchmark is 75% faster in this version and that microbenchmark is a whopping 10x faster, and people don't realize that these things are very carefully crafted to get the largest number possible on their microbenchmark where real code may only have sped up by .4%, and the sum total of all of these composed together still leaves you with a fairly slow language. Go is a compiled language with very little time given during compilation for optimization, and it _still_ runs 3 times faster than V8 or so, and it's pretty obvious to everyone that it's still got some performance improvements that could be made if we were willing to pay the compile time.
wtf is wrong with the chart?? wtf (FWIW I agree with you, I still think Go can get massive speed bumps from inlining and better analysis. I want my `l=4` option back!)
Don't mistake "the community" for one person. There's always someone willing to rationalize a thing, but that doesn't mean everybody is always rationalizing. My point here has nothing to do with Go or /r/golang; it's generic. I've participated in a lot of communities over the... sigh... decades, and I don't see the Go community as being particularly prone to that more than anybody else. I remember Python people claiming that nobody should ever care about how slow the language is. Heck, I _still_ see people saying that. (And I don't mean that they're saying it often doesn't matter, which I agree with; they are shocked that it matters to anybody, and that "well just hack out the fast bits in C" is neither particularly appealing to a lot of people, nor as easy as they claim, nor often as performant as they claim if you have to keep going back and forth in representation.) I remember a rather lengthy debate with /r/haskell I had where I pointed out that a linked list of 32-bit ints is a terrible data structure for strings. It was repeatedly "explained" to me how wonderful this data structure is because it was easy to do inductive proofs on it. (Which is not a thing anyone actually _does_, but if they wanted to, it would have been easy, I guess.) Then about a year later, the first iteration of the bytestring libraries showed up and all of /r/haskell was abuzz about how fast they were. Well... yeah. Linked lists of 32-bit ints are a terribly slow data structure for strings, even _before_ you think about what it does to caches. Beating them wasn't hard. And don't even ask what $SOMEONE in the Perl community will say about every last one of Perl's idiosyncrasies.
I think I've said it on /r/golang before that to a large degree, I don't really want "generics" per se, I just want a type-safe solution to the containers problem. And part of that is that the way the `interface{}`-based containers must inevitably box, with all the performance loss that implies, _right in the place where I presumably am caring about performance since I want to use a different data structure_. Given that Go is a great choice for network servers, and how many network servers end up being really, _really_ interested in good performance, it's weird to me that there's a hole here. (I'm not sure that I wouldn't ultimately just be happy with the Go team basically saying "You see [gen](http://clipperhouse.github.io/gen/)? Here's some additional tweaks from the go team and a bit of integration of that use case. We're done here.")
I agree with this sentiment and you have put it in much fewer words than I did. I use Haskell as my daily "thinking" language, but not really my "doing work" language. To add to the discussion, I strongly believe at this point adding a type system to Go will yield more performant programs (by trading binary size and some amount of program analysis time for much greater performance, which is a sacrifice *I* am willing to accept, but clearly not everyone shares my view) Edit: we live in 2017-2018 now. A few extra megabytes of binary increment shouldn't matter. Just puttin' it out there
I thought he was being pretty fair (and I'm *not* a `go` fan). At one point he references his view through his own lens: &gt; In my opinion, Go manages to hit a good sweet spot (that is, its design agrees with my personal preferences on this)
[try this](https://gist.github.com/georgetso/517de63494ae83a5cecbf25909a7bd48)
Here's what it comes down to: All programming language terms only have _concrete, defined_ meanings within a given language context. There is no universal definition of "pass by reference". There are more variations on the theme than there are official names for it, since there's 2 or 3 names and probably dozens of variations on the theme. "But jerf, surely something like pass-by-value is unambiguous?" No, it isn't. In some languages, if you "pass-by-value" anything you can get to by the original value can't be changed. In a lot of other languages, including Go, if you pass a struct by value that has a pointer in it, you can still follow that pointer and modify something that will be visible to the original caller. Some languages have complicated concepts of "const"ness in them for which "pass by value" is simply inadequate to explain the situation. In immutable languages, you "pass by value" in effect even though under the hood it may be implemented via passing a pointer! In Go, as with many languages, everything is "pass-by-value" making the term rather useless (a term is only useful if it distinguishes between at least two cases), so the relevant question is whether you're passing in a pointer or not. Incidentally, on the topic of how no term is universally defined, I would _generally_ consider the distinguishing characteristic of a pointer vs. a reference that you can do pointer arithmetic on the pointer. However, while Go has "pointers", it doesn't have "pointer arithmetic". But I still call them "pointers", because that's what the language calls them and I'm relaxed about the fact that I have an opinion about the "general" meaning of a term that a particular language/language community disagrees with, because that happens in every community for nearly every term. Others would say the distinguishing characteristic of a reference is that you can transparently change the original caller's value and you don't see a "pointer" involved, but there's really no meaningful difference I know between a "reference" to an int in such a language and a "pointer" to it in Go, except the terminology and how transparent the syntax may make it.
&gt; note that context.Context is even [an integer](https://github.com/golang/go/blob/2d69e9e259ec0f5d5fbeb3498fbd9fed135fe869/src/context/context.go#L169), not a pointer. This is incorrect as stated. `emptyCtx`, which you link to, is an `int`. But `emptyCtx` does not implement `context.Context`, `*emptyCtx` does. Further that underlying type is only used for `context.Background` and `context.TODO`. Other implementations of `context.Context` include [`*cancelCtx`](https://github.com/golang/go/blob/2d69e9e259ec0f5d5fbeb3498fbd9fed135fe869/src/context/context.go#L316) (created by `context.WithContext` and `context.WithDeadline`), [`*timerCtx`](https://github.com/golang/go/blob/2d69e9e259ec0f5d5fbeb3498fbd9fed135fe869/src/context/context.go#L411) (created by `context.WithDeadline`), and [`*valueCtx`](https://github.com/golang/go/blob/2d69e9e259ec0f5d5fbeb3498fbd9fed135fe869/src/context/context.go#L479) (created by `context.WithValue`). So everything in the context package that implements `context.Context` happens to be a pointer. But that's an implementation detail. The OP appears to be asking why people are using `ctx context.Context` as arguments instead of `ctx *context.Context` and the reason for that has nothing to do with implementation details of any specific implementer of `context.Context` being a pointer or not. It's simply because it's an interface and you very very rarely ever want to use a pointer to an interface.
I didn't say everyone was always rationalizing just that rationalization is widespread in the community. 
Don't touch error handling. Properly done ADT based error handling would be better, but exceptions are much, much worse.
FYI, you should probably be [aware of patent issues](https://medium.com/@dwalsh.sdlr/using-graphql-why-facebook-now-owns-you-3182751028c9) before using GraphQL.
To stretch your analogy. The problem is that pasta al pomodoro seems to be giving some people acid reflux so they take antacids after eating every meal. By that I man I see a lot of libs that do code generation in order to get around some of the shortcomings of the language which is a symptom that the language has some serious shortcomings which ought to be fixed. But nothing will get fixed if the community has internalized these things as being somehow necessary or unchangeable. 
I think it's because in your code you're serving the "static" folder, whereas in my code I'm serving `r.URL.Path`
Generics will come.
Doc: https://tip.golang.org/pkg/math/rand/#Shuffle
Imagine tearing the type and data parts of `interface{}` apart, storing the type only once per container, and enforcing it to match for every store. That's not really "generics", but would do plenty. Now, I wonder if reflect &amp; unsafe would be enough for that ;) (And yes, code generation is how you get performant container types, today.)
The performance of interfaces isn't good. Lots of unnecessary allows. I think the GC bit should be manageable if I take care not to overlap pointers, but I'll need to think more about it.
&gt; And part of that is that the way the interface{}-based containers must inevitably box, with all the performance loss that implies Yes, the performance loss of boxing is a shame. But FTR, there are not that many boxing containers in the stdlib and the latest addition is providing still providing significant performance gains, even without statically specialized code. &gt; right in the place where I presumably am caring about performance since I want to use a different data structure. I think this is a thing that experience reports are for and would be interesting. I do coincidentally actually have one in my pipeline for the overhead of interfaces, but its considerations likely won't cover the container usecase. &gt; Given that Go is a great choice for network servers, and how many network servers end up being really, really interested in good performance, it's weird to me that there's a hole here. I would say you can make the prediction, that the performance loss of `interface{}` for containers would imply that people would spend more time optimizing for that (be it by adding a new language feature, by improving the compilers inherent capability to deduce types automatically or by some other way). And that the observation seems to be, that this is not the case. So there is an unexplained gap between prediction and observation. There are multiple possible explanations for that gap though. One is, that people who are in need of that performance end up not choosing Go, so their needs don't end up being accounted for. Another one might be, that they just live in constant pain of the lack of performance. A third one might be, that the prediction is just speculation and the slowdown ends up being negligible over the general complexity of a complex data structure. The push for experience reports lately has been to discover the explanations for such gaps. If people suffer from degraded performance in their `interface{}` based containers, it would be great for them to write that up. It should give a much clearer picture of what the scale of this problem is.
Interesting, when I'm using Haskell I don't feel like I'm doing "mathy" stuff at all. I feel like I'm programming. Guess just different perspectives. Haskell is probably the best language I've used for "imperative" programming, mostly for the reasons I mentioned in my comment above. I love being able to take an Int and say you semantically mean a UserId so thats what you are and then create a function that only uses a UserId and have the compiler do the "unit tests" to make sure everywhere I use the function semantically the Int is really a UserId, but under the covers it is just an Int (no runtime overhead). Anywho, I'm not a mathematician so perhaps thats why I feel the way I do.
fuck yeah!
Just wanted to say that Haskell is very capable of being a "doing work" language. You may not use it for that and I think thats just fine, but if others come across this comment I'd like them to know it isn't just a "thinking" language which it is often stereotyped as.
Go is somewhat idiosyncratic and quirky; whether that's a good or bad thing is up for debate. The problem with some people who are "just starting to learn go" is that they will complain about the same tired old things over and over again, often without any knowledge about *why* things are as they are. We get stuff like "my one week with Go and here is my strongly worded conclusion!11!1!". So the reason some people may appear it's not because they don't want to hear criticism, but it's because this particular criticism has been discussed *time and time and time again*. Generics, error handling, the verbosity: been there, done that. Many discussions can be found already. --- Also, dismissing what other people are saying as a new (and by definition, "ignorant") person to the language "as endless rationalizations" makes it sounds like you're not exactly open to hearing new point of views ;-) Just sayin'
[removed]
&gt; I remember Python people claiming that nobody should ever care about how slow the language is. They still say nobody should care about the awful semantic whitespace indentation.
Could someone explain why this is important or useful?
Go's ugly reflection is the only proof one needs to demonstrate the silliness of this blogpost.
so it means the value of constants is calculated at the compile time? 
Yes, I realized it after I published the link but didn't want to edit my comment. Good catch!
&gt; I would say you can make the prediction, that the performance loss of interface{} for containers would imply that people would spend more time optimizing for that (be it by adding a new language feature, by improving the compilers inherent capability to deduce types automatically or by some other way). And that the observation seems to be, that this is not the case. That kinda seems to be begging the question in this context. A thing that has no way to be manifested in Go won't have been manifested in Go. And there [are things for it that have been written](http://clipperhouse.github.io/gen/), and that's not the only one either.
Brillant
me 2, this stuff I dont get
Go 1.10? What was the fuss about go2? I thought go2 will be after 1.9
I could imagine it being useful for testing. Getting randomized / unsorted input can be a pain to code yourself. All the little helper functions reduces boiler plate. Or, what if you wanted to protect an API from users relying on sorted order... I'm sure there are plenty of uses.
Go uses semantic versioning. http://semver.org
No, it is very brittle. It will not survive converting to a different format, resizing, or even resaving the JPEG with different quality settings. Originally my plan was to create something that would survive reencoding/transcoding, but that turns out to be pretty tough. Basically, the more resilient the method is, the less "sneaky" it is. This makes intuitive sense because in order for the secret data to survive transcoding, it has to be visually detectable; but if it's visually detectable, it's no longer secret. Still, it may be possible for a method to survive JPEG -&gt; JPEG reencoding while remaining mostly undetectable.
To implement the [Monty Hall problem](https://en.m.wikipedia.org/wiki/Monty_Hall_problem) in your app. Maybe you're writing a web-based game and want a choose-a-chest minigame in it. C++ has std::random_shuffle if you want to search the Internet for other examples. 
**Monty Hall problem** The Monty Hall problem is a brain teaser, in the form of a probability puzzle (Gruber, Krauss and others), loosely based on the American television game show Let's Make a Deal and named after its original host, Monty Hall. The problem was originally posed (and solved) in a letter by Steve Selvin to the American Statistician in 1975 (Selvin 1975a), (Selvin 1975b). It became famous as a question from a reader's letter quoted in Marilyn vos Savant's "Ask Marilyn" column in Parade magazine in 1990 (vos Savant 1990a): Vos Savant's response was that the contestant should switch to the other door (vos Savant 1990a). Under the standard assumptions, contestants who switch have a 2/3 chance of winning the car, while contestants who stick to their initial choice have only a 1/3 chance. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/golang/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
Non-Mobile link: https://en.wikipedia.org/wiki/Monty_Hall_problem *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^110717
Either you did not understand my point, or I did not understand yours :) &gt; A thing that has no way to be manifested in Go won't have been manifested in Go. But you *can* implement `interface{}` based generic containers in Go. And if they are too slow, that slowness *can* manifest in Go. And going further, yes, you can then also compare that speed to a hand-rolled specialized implementation to assess the benefits, but that's not even that important (but it *would* make an interesting experience report. "We need $generic_datastructure. We implemented it using `interface{}`. We observed $performance. Which isn't enough. Optionally: We then experimented with a specialized instance and observed $performance_benefit"). You called it "weird" that Go has a perceived hole there. I think when things are called "weird", that is just a catch-all term for expectations and predictions not agreeing with observations. I just tried to put this disagreement into more specific words (and come up with possible explanations). You posited, that a) `interface{}` has a non-negligible performance impact, that b) custom containers will often be used in performance critical parts of the program, that c) the kind of programs Go is targeted at are interested in this performance benefit and d) thus it would seem logical that Go would need a systematic solution to *not* use `interface{}` in containers. The observation, though, is that 1) Go doesn't have this and 2) it still seems to be at least somewhat popular in the targeted field. The disconnect has different potential explanations. Most probably, either one or more of the assumptions is wrong or one or more of the observations is wrong. I can't pass any judgement on which it is. But from what I can tell, at least a *potential* explanation might be, that the penalty isn't large enough to deter people from using Go or motivate them to systematically fix it.
No, it rather seems like there is no way to please some. Note that the complaints are all coming from `Z`.
Out of curiosity, can someone tell me what is wrong with this method? I'm using it in prod so I hope it's decently normal. words := strings.Fields("ink runs from the corners of my mouth") // my solution for d, s := range rand.Perm(len(words)) { words[d], words[s] = words[s], words[d] } // rand.Shuffle solution rand.Shuffle(len(words), func(i, j int) { words[i], words[j] = words[j], words[i] }) fmt.Println(words)
No, because whatever API you'd provide would still need to live inside the language and thus exchange data via interfaces (and thus do boxing and unboxing, which is where at least some of the performance penalty comes from).
Nothing is wrong with it in terms of correctness, but rand.Perm allocates and populates a slice where it's not really needed. EDIT: DOH, I was wrong, see /u/funny_falcon. It's possible to write a correct shuffle using rand.Perm, but this is not it.
I find the standard library docs really easy to read, but if you're reading something which isn't part of that library, I'm not surprised if you're having issues. Documentation is 100% human written.
How is any Vue related setting, in this case the history mode, relevant to Go/this setup? What am i missing here?
I mean, of course it'd be slower than a version using the underlying type directly, unless there was some sort of unsafe variant of `reflect.MakeFunc`. But it'd have less storage overhead, and fewer pointer indirections, than something that stores `interface{}`s.
I find most Go projects are better documented than other languages I've used. The fact that Go has a lot of tooling that encourages you to write documentation helps, I think. However, docs are still generally written by humans, so the total quality can vary significantly. Do you have some specific projects you're having trouble understanding? There may be some pointers we can give. One thing I find can be confusing at first is that standalone functions that return a type, are grouped under that type in godoc.
Can you point to some examples of what you consider real bad? Then we can discuss it with more context. I think Go's standard library documentation is excellent. I really enjoy how explicit, clear, and succinct it is on average. It says everything that's important, nothing that isn't. I use [godoc.org](https://godoc.org) to read it most of the time, it has a helpful F keyboard shortcut to jump to any identifier quickly. What do you use?
What IRC channel do you use?
After using it for a while, I like godoc a LOT more than python's docs. It grows on you.
I found that almost all libraries from [the awesome go list](https://github.com/avelino/awesome-go) included really good documentation. I agree, though, that there is also a decent number of libraries that lack documentation in key parts, or are somewhat misleading. In those cases I would usually just click the names in godoc to get to the source code on github, since most of the time the code is really easily readable. This is not to say that I think good source code doesn't need documentation, but it certainly helps in cases where it's lacking.
It's really hard to read until you do it for awhile, then it gets easier to read than any other language. I felt bad at first, because when I communicated that it was hard to understand, people just repeated back it's far easier. Now that it's becoming easier for me, I get their point. Once you get into a flow with it, it is easier. 
Coming from Python, I too found godocs hard to read in my early days of go. Thing is godoc != docs.python.org. Godocs is more of an api reference. Can it be fleshed out, certainly ive run into a couple of repos with examples that dont assume you already understand the how and the whys of the library. But most of what you will run into is a concise explanation of what a function/method does but not how, when or why you would use it. And that, IMO is the main difference between the two. 
&gt; Passing a pointer to an A is not "pass by reference". C'mon ... a pointer is a reference. Quit being pedantic.
Thanks for the explanation. I ended up using the select version since I later discovered that I have to make the goroutine end at some point by listening for a done/quit channel and that cannot be done with the for range version.
go2 is still in "daydreaming" stages and hasn't even made it to planning.
Go docs can provide runnable examples which are very hard to beat when it comes to understanding an unknown package. Can you provide some links of the docs you are reading? Maybe they are just inadequate.
The godoc is technical, it's not a tutorial format like many of the Python docs. It takes a little getting used to, but its conciseness and correctness (most of the time) is really helpful.
Up-to-date! Woooo! I've been woefully hoping something like this would happen.
Don't use retarded as a pejorative. We're adults here. We can come up with a better description. The term is offensive to many people. I understand that many of us grew up with this as a commonly used word. Times change.
[removed]
Excellent argumentation.
The godoc docs tend to be dry, but well-organized, consistent, and complete (as far as code coverage goes). Most often the element I need most that's missing is examples. It's easy to look at any one piece and see what it does, but without idiomatic examples it can be really hard to figure out how all the pieces are intended to fit together. When I find the godocs are lacking in examples I'll first look for a README, then `_test.go` files.
Interfaces is a part of language, so Golang's authors will work on improving its performance. For example, Go 1.9 already inlines some casts from interfaces to native types. So, using interfaces you will offload part of work to brilliant Golang core team.
That library's docs look pretty typical, and yes I too usually find them hard to read. In my opinion the generated documentation rarely does a good job of describing their context. There are pervasive (and sometimes large) assumptions that you are reading that documentation with an existing grasp of what the package's purpose and jargon are. I think people just assume the generated package API docs are enough, and there's little/no need for human-to-human language to be added. It can be very frustrating.
For me it's about choice. If you *really* want foo, then sure depend upon it. However, if you just want something that you can call StackTrace().Stack() on (which is usually the case when people use interfaces), then point that out instead. I wish Go types allowed that.
I second this,`graphql-go/graphql` is painfully verbose, i'm using `neelance/graphql-go` and it's light and easy to use.
1.9 in this sense is not a decimal number. It's a period delimited set of numbers that can increment independently. It's similar to how the rating system for [climbing goes from 5.1 to 5.15.](http://www.mountainmadness.com/resources/climbing-rating-systems)
Well, references and pointers to values are different things and a lot of confusion stems from thinking mixing up these two concepts. Being precise in your language is helpful in reasoning about stuff. When you reason about a physical system you do not mix up power and energy.
I'm sorry to disappoint you: 9+1 = 10.
thank you! very interesting. I suppose you never benchmarked against any other server? (only net/http). and congrats on the stats, that is a lot of video! :)
thanks. &gt;There are many ways to allow language syntax changes such that we don't have a Python 2/Python 3 scenario. can you list them, please?
#go-nuts on freenode :)
Your permutation is not correct, ie it is not uniformly random. Correct permutation permutes "next" field with one of "already permuted". Knuth Shuffles https://en.m.wikipedia.org/wiki/Random_permutation https://en.m.wikipedia.org/wiki/Fisher–Yates_shuffle 
Non-Mobile link: https://en.wikipedia.org/wiki/Random_permutation *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^110753
This is one situation I would love to have generics, ```Source&lt;T&gt;.Exec(T)``` would be much nicer then ```Source.Exec(interface{})```
&gt; wtf is wrong with the chart?? Nothing??
There isn't a list. Any possible change is unique and would require custom solutions. For example, some changes can be made using a tool like `go fix`, while some other changes might require support from the compiler - like it might have to support both versions of the syntax or something. But those are not the only two options.
Most people seem to say that neelance/graphql-go is the way to go but there is almost no documentation. Which leaves me to decode it using the star wars example. Not a big deal but I just wish there was a bit more documentation.
okay, so other than those two options do you have any other options in mind? Thanks.
good thing about open source projects is that anyone can contribute :) any of us can take some time to start with the docs things though!
In case you don't believe me, run your solution with just 2 words. You will see that order never changes.
When I started around 5 months ago, it was a little bit weird but I read a blog post by Rob pike on this -- &gt; https://blog.golang.org/gos-declaration-syntax - and I have been fine with it since then
I'm also fine with it. It's just still "a little weird" for me and I'm just curious if it will stop being "a little weird" for me after a few months. Thanks for your reply!
If the purpose of Exec is to pass mutable data, the flow nodes should serialize to bytes (probably using gob) between links. Using interface{} and func(interface{}) error is just a lazy abstraction in this case.
No need to sugarcoat it, it is a downright terrible idea.
The purpose of Exec is to pass data, not necessarily mutable but I could it could be, but even if I did serialize and pass bytes I would have to deserialize and check for type errors on the other side, that sounds a lot more expensive then a type check 
This is my first go project and I've been impressed with the lanugage so far. I was originally thinking of writing a tig like git repository viewer in C, however I'm glad to have chosen go in the end. The speed of developement has been much quicker, the standard library is far more comprehensive and the tooling is helpful and easy to use. I'd appreciate any feedback on the project. I've attempted to follow best practices but I am still relatively new to the language.
I broadly agree; and I will say, that was a very well written post too. I'm currently trying to weight this up personally. One problem I am currently facing is that there doesn't seem to be any other language that hits so many sweet spots better than Go for me. I would use something like Kotlin - the language is _fantastic_, but I don't want to be on the JVM, Rust code is too low level for me (and not as straightforward to understand as Go too, Haskell is a bit too deep in FP for me, Node.js is too dynamic and not as performant as I'd like... the list really could go on for a very long time. At this point, I understand why Go doesn't have generics, and having come from a background of mainly PHP and JS I'm quite used to having to deal with not having types, in fact Go is a _lot_ nicer than both of those thanks to it's type system. I've also tried Scala and it's type system was incredible, but the language is not nice to work with at all. Overall, I'm glad Go doesn't have generics right now, and I think the current solutions to problems where you might use generics can even in some cases help lead to nicer code. In some cases though, you do have to resort to `interface{}`, and that's okay in my opinion.
It hasn't been weird for me after a few months, but it's definitely frustrating when I switch between Go and C... especially when writing inline C and they're in the same file. :S (Edit: To clarify, I do prefer the Go way at this point.)
&gt; But it'd have less storage overhead, and fewer pointer indirections, than something that stores interface{}s. Not even sure about that. Especially the pointer indirections. The thing is, you either store the data inline, or you store it indirectly. But at some point someone is going to do that `Get(key T) V` and then what? You need to return an interface, which has to have a pointer to the value. What will that pointer be? Something that points into your data-structure and will potentially become invalid at the next insert? Or will you have to copy the thing at that point either way? But anyway. Not really important :)
I find godoc to be good for API documentation, and maybe showing some basic examples, etc. but for _guides_, like cookbooks and that sort of thing, you're not going to find a replacement to making something a bit more custom. There are some libraries that have both godocs for API documentation and some more complete documentation elsewhere. In some cases you might not need to do that though. Some people may think godoc is the one true documentation tool, and never leave it though unfortunately, and as a result some things aren't very well documented sometimes.
I'd only just commented about this the other day, and am thinking about going through the code with a friend of mine to fill it with godoc comments as a starting point. This will hopefully transition into us having a good understanding of the library, then being able to contribute more.
good. there's too many people doing shuffling wrong without having even a hint of that.
Why should it be annoying? I think that it's as natural to have the type after the variable as before it (or around it as often is the case in C). In Pascal one writes for example "var x : integer;" and in Haskell one writes "x :: Integer".
It's the other way around for me. I was forced to write some java the past weeks and found myself writing types after the variable name. We had good laugh after
I've been Sherlocked! https://github.com/carlmjohnson/go-utils/tree/master/shuffle
It's not a big deal because it is easy to write your own shuffle, but it saves you the time looking up the proper algorithm on Wikipedia, and for those who don't look it up, it's easy to do a shuffle wrong by mistake and not realize that your output is skewed. Edit: See elsewhere in the comment section, where someone didn't look it up, and got it wrong in prod as a result. :-)
again, keyword: option. The right of the decision is from users. Optional JIT for Go compiler is a great for two cases: 1. JIT off and generate code at compile time. Result: long compiling time but faster run time performance. After all, if you need the generated code, you will generate it anyways. 2. JIT on and generate code at run time. Result: faster compiling and both performance lost and gain at run time. Runtime JIT is not only a generic solution, it is also important for many other areas, such as bug data processing. In fact, the run time JIT is just an embeded Go compiler. It can exist as a standard or third party package. It even doen't need to be maintained by the core Go team, and there can multiple third party JIT implementations. Conclusion, JIT is just an optional need for different users. It doesn't do harm for the users who don't want it at all. btw, &gt; Speeding up Javascript with a JIT by comparison was really quite easy, even in the beginning, because it was such a slow language to start with. I think the real reason Javascript with a JIT is **it has to be with a JIT**, :) 
Thanks for this feedback. So writing go is totally natural for you. Could I ask if that extends to every part of the language? (every syntactical portion). For example slices seem a bit weird for me still, etc. To you is everything natural now?
Given the context (go), I think it was pretty obvious that he meant passing a pointer vs a non-pointer value.
I guess because I didn't write Pascal or Haskell. I'll take your reply as "totally natural since day 1" for you :)
Thanks for this reply.
Then you should had answered that Context is an interface, and interfaces are implemented to be small values?
It has uniqueness types.
I've been writing production Go for a couple years now, and started coding Go back when it was pre 1.0. I honestly don't care about the types being before or after. It is just the way Go does it vs another language. That being said, if I write a bunch of Go and then have to jump into a C++ project, I will end up writing the type after the name and then get confused for a second when it complains. 
I don't know what "inlines some casts from interfaces to native types" means, but it's not likely that the Go team will ever implement zero-alloc interfaces because that would require interfaces to vary in size. It also requires all uses of interfaces to be known at compile time which is impossible in the case of plugins and it would require a significant overhaul to the compilation process (nothing that takes an interface or is composed of interfaces can be compiled until link time). I doubt very much that the Go team is interested in making this tradeoff (and for good reason). At best, they can only avoid allocs for things that are pointer-sized or smaller, and I think they used to do this but reverted to the "everything is an alloc" because the GC had to inspect every interface value to see if it was a pointer or an int. Maybe they are stuffing small things into interfaces, but this optimization is still too limited.
But isn't that just a fault of the author and not a limitation of godoc? Godocs support examples. 
I am by no means a go expert. I guess, the language you're writing the most in, feels the most natural to you. What part of slices seem weird to you? Writing in go is a great experience and I like every part of the language, even though I still discover new things every now and then. Edit: fixed some spelling errors
this is a great answer. can you do me a favor and as you write your next program, tell me the last few syntax errors you make - whatever they are. Even if you leave off a bracket or brace or something. you can reply at any time. (i.e. if you're not writing anything now.) thanks.
A lot of people have agreed that godoc is great for easily providing an API reference. I agree as well. But I wonder if it would make godoc even more useful to offer extended directives and roles like what Sphinx offers. What if godoc had better support for referencing, sections linking, and other formatting options so that you could generate more useful "guides" in addition to the API style docs?
I'd like to ask you this same thing (copied from another comment): &gt;can you do me a favor and as you write your next program, tell me the last few syntax errors you make - whatever they are. Even if you leave off a bracket or brace or something. &gt;you can reply at any time. (i.e. if you're not writing anything now.) you could take a few days to get back to me. I'm just curious what things still stick with people after a few months. even if it's something mundane like parentheses, etc. thanks.
Definitely, but it's less of a guarantee and most often the missing element, because it is optional.
&gt; By that I man I see a lot of libs that do code generation in order to get around some of the shortcomings of the language which is a symptom that the language has some serious shortcomings which ought to be fixed. I don't know. I'm still not convinced that it's not rather a proof that you can be perfectly productive in a language without generics. Like, everyone always criticizes Go for being old and backwards and just generally sucky. But for something that supposedly sucks that much, there are pretty darn huge and *wildly* successful projects written in it. Maybe those theoretical arguments for why Go sucks… don't carry that much weight, empirically? Just one possible interpretation of the observations, of course.
Perm will work if you copy from one slice to another. If you do it within the same slice, your results will be skewed because items can be shuffled more than once as it goes along. 
But we already have a shuffle function :p https://gist.github.com/sno6/755131435b9947fe2ecaee10295f44a6 
In recent versions of Go, yes. it's one of the many optimizations enabled by the recent SSA compiler work and is specifically called out in [this video](https://www.youtube.com/watch?v=uTMvKVma5ms) from Gophercon 2017. That said, even if it weren't, you're talking about obfuscating your source code to gain fractions of nanoseconds at runtime. That's NEVER the right trade off unless you've profiled your code and found this particular path to be worth optimizing. Donald Knuth (who probably knows more about optimizing code than either of us ever will) famously said &gt;The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming. And he said it again in this way &gt; Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. Please don't give into this evil. Always start by writing readable code and then if/when you need better performance, profile your code and only optimize the bottlenecks. Trust me, the people who you ask for help from (like us) will really appreciate it and be even be more likely to help if they can understand your code at a glance.
I'm not really saying that encoding would cost less than a typecast. What I'm suggesting is that there are other ways to provide interfaces for this kind of problem that don't involve generics. The benefit of moving to a byte encoded format is that if you wanted to create distributed/networked flow graphs, the concept of moving data between remote nodes is already part of the usage pattern. Barring that, you could probably use context.Context instead of a straight interface{}, which might be a good improvement allowing for deadlines/timeouts per node action.
I... [did](https://www.reddit.com/r/golang/comments/6zkzwu/is_contextcontext_passbyvalue/dmw2n87/). It was the first response in this thread.
That's not saying any of the things you should have said. It is pass by value, interfaces are values, and interfaces are small. "Read the package" is useless advice here, nothing about the passing mechanics in Go or about interface size will be learned from doing that.
[Python docs are manually curated separately](https://github.com/golang/go/issues/18342#issuecomment-267683549) from the source-code, while Go docs are auto-generated from the source-code. Manually-curated docs will always be superior to auto-generated docs, but carry the obvious disadvantage of additional work for the library developer. For auto-generated docs, Go docs are pretty good. However, I still have my gripes. My main gripe is the inability to have a user-defined sections to group consts/vars/types/functions together that are semantically related. I proposed supporting godoc sections: https://github.com/golang/go/issues/18342 I haven't gotten around to working on a prototype, but my mock of what certain packages would look like with it shows that it improves readability of docs.
lol ok dude. "Yes of course as everything in Go is passed by values" is totally more helpful. whatever.
I didn't assume what the efficiency concern was and instead asked for clarification. You did.
I was thinking of things like map or tree performing equality comparisons on lookup could have the data right there, and not behind a pointer. All it'd really need to know is the size of the key data type. But yes, if any of this matters, codegen is simpler.
I'm surprised none mentioned this library https://github.com/playlyfe/go-graphql which is the fastest. I find it very easy to use it and it's being used in production by playlyfe..
[removed]
[removed]
I like the look of this library... As of right now I'm looking at this library and neelance's library
Deadlines is probably a good idea. For the most part this is supposed to be a real time like system, so at run time you would do something like wire a door sensor to a buzzer. Or wire a node that is outputting the temperature to a PID node with the output going to a node representing a fan. But even if i serialize I still have no idea what kind of data is in the byte buffer unless I have a predeclared envelope type and want to deserialize twice right?
Please compare [cdecl.org](https://cdecl.org/?q=char+%28*%28*x%28%29%29%5B5%5D%29%28%29) vs [godecl.org](https://godecl.org/?q=var+x+func%28%29+%2A%5B5%5D%2Afunc%28%29+rune) and tell me which you'd rather deal with on a daily basis.
I'm with you. I have zero objection to the language having generics, but I object to losing the aspects that drew me to the language in the first place. If they can be added in a way that doesn't compromise those things, I'm all for it. I've written 100's of thousands of lines of C# code, I'm pretty confident with it, yet I still find myself preferring Go these days. If I absolutely had to have generics, I would use a different language, but I just don't find this as important in practice as all the other things I care about that Go does well.
I actually thought Python's documentation was absolutely awful, [and so do others](http://cryto.net/~joepie91/blog/2013/02/19/the-python-documentation-is-bad-and-you-should-feel-bad/). As an example, look at [statvfs](https://docs.python.org/2/library/os.html#os.statvfs). Without prior knowledge how is anyone supposed to know what this function does? What type of data structure does it return? What type is path? A quick glance tells you nothing and even reading the short description doesn't make it absolutely clear what is happening. Compare that to [Golang's os.Stat](https://golang.org/pkg/os/#File.Stat). Even without reading the description I can see what the types of the returned value as well as the arguments passed in. The types alone give me a good idea of what the function's purpose is. The description explicitly states the purpose, and I can click on any of the types to see their exact layout and what they contain. I would argue that even a non-programmer could look at os.Stat in the godocs and understand what is happening. At the same time, established programmers might look at python's os.statvfs and still not understand exactly what it is doing. 
I've used https://github.com/graphql-go/graphql in production for an internal tool. The doc isn't perfect but I was able to build something relatively robust. None of the go implementations support parallel resolvers. Who ever does that first will probably become my go to. 
[removed]
I see people saying the godocs are hard to read, but I don't really understand why. I'm not saying they aren't hard to read, but was curious to know what made them hard for you to read early on, and what could have been done to make the documentation better.
I'm mostly a Java dev at the office but all personal backend projects write in Go. it's kinda weird when I write types in Go-style in Java and than scratching my head trying to understand why it's underlined. :D 
i don't see where you'd need to deserialize twice. you'd send bytes (or an io.Reader) to Exec() and the node would unpack, do some logic, then return a Reader or bytes to the engine for the next node in the chain to process. You'd never unpack the envelope twice. that said, I can see why in an embedded/iot context that slowing things down (even by a little bit) could have a big impact on responsiveness for large flows.
Go is mature and robust for the space it was designed for. The big area where it is lacking is the GUI space. There are a bunch of libraries using Go's C bindings to interface with the common popular toolkits, but as soon as you're dealing with C you lose some of go's best features such as cross-compilation. If you have access to every platform you build for it isn't a big deal, but if you're a LInux guy trying to compile for Windows targets its a bit difficult, if you're trying to compile for Mac I'm not even sure that's possible yet. With native Go (no C bindings) you can compile for any platform Go supports very easily.
Jerf, your comment is the only comment that made any sense in this thread. Thank you. I was very confused, why? From my experience/background outside of Go "passing by reference" is when you do two of the same thing: 1. Pass a pointer to a function for memory optimization so it doesn't copy the full object. 2. Mutability: Pass your parameter to a function so that any modification happening inside the function are kept when the function return. I'm well aware of the doctrine that Go is all "pass by value" (except for Slice, Maps...) but I know I could do the above two things in Go. I went to that thread hoping to get any clarification and everyone seemingly contradicted each others and used different terminology (pass by pointer??). Then you came along saying that "pass-by-reference" means jack shit and it's just languages coming up with their own rules and jargon.
I like its consistency. I think "here is my variable which is a..." and I either infer the type or specify it, so the type is always derived from what comes after it. I've found it harder to not immediately type an open parentheses after "if."
a SOAP server? in general most of enterprise integration tools, protocols and co. There is a reason why Java steal leads the enterprise space.
&gt; The big area where it is lacking is the GUI space Unless Go ships with something like openGL support in its std lib you'll always need C bindings.
Only when I switch language but then I find it more annoying when I start to type without parentheses. :3
I've written a custom container type for performance at least once. I might have preferred not to, but it just required some benchmarks, tests and time. It's worth noting that I may not have found an existing container that satisfied the requirements. A different area of that code uses an interface{} LLRB library, because that's a pain to implement and probably not worth it, and I ended up putting two types in it since I needed the type assertion or switch anyway. It's dangerous to generalize, but I think in many cases where you need it, it's often a data structure that's reasonably easily implemented using the existing generic ones (particularly slice and map) and is just mildly irritating. As he points out though, people have spent time working around this, either by duplicating container structure logic, or through the various compile time code generators. I've implemented a stack a few times on top of a slice, sometimes with multiple copies in a single code-base just because it almost feels less dirty than interface{}. Still, I think your line of argument treads dangerously close to suggesting that people who had issues should have left so that there was evidence of a pain point.
What's with all the down votes on the OP?
I wanted to write a terminal audio player last year; I wasn't able to find a: - mature and maintained TUI library. termbox is very low-level, ncurses bindings had some specific issues (I forgot which, sorry); - library to decode compressed audio formats (mp3, vorbis, flac, etc.) - library to deal with the system's audio out in a cross-platform way (preferably through pulseaudio). I believe someone posted a project here the other day with some cool multimedia support, but as far as I could find last year that didn't exist for Go. All of this is possible in Go of course; just needs someone to sit down and do it. Since this was a hobby project with a limited "time budget" I wanted to get things off the ground quickly. I ended up using Python. --- Another issue that bit me very hard is the [inability to use setuid()](https://github.com/golang/go/issues/1435). It was very confusing as I was alternating between my Linux desktop and OpenBSD laptop at the time and was just learning Go. It only works incorrectly on Linux. Took me some time to figure out that it wasn't in fact *my* fault that files were being created with the wrong permissions! It's kinda annoying because now I need to run my daemon as root just because I want it to listen on a privileged port :-/
nope, always been that way for me
YES!!
Do you mean you have to run as root in Linux or OpenBSD? In Linux the solution is [setcap](https://wiki.apache.org/httpd/NonRootPortBinding). That does not remotely solve all setuid issues, but it does solve that one.
You are not arguing that those problems don't exist, just that they are well known and have been rationalized away by the community.
In Linux; dropping privileges in OpenBSD works fine. setcap is an option, but it shifts the configuration from the program author – who usually knows exactly what permissions the program needs – to the system administrator. Not a good idea IMHO, for various reasons.
Robust scientific libraries (scipy, numpy, pandas, etc)
&gt; Go is mature and robust for the space it was designed for What space was it designed for? 
We're getting there! I've so far used gonum and gorgonia in production level services... and Go has replaced python for a lot of things I do (except the things that require interactivity- jupyter still wins but /u/dwhitena just showcased something this morning that I think will change the way Go is used in datasciences )
Annoying is the wrong word. Mentally I think of it more like switching between UK/US driving, it takes only a couple of seconds for the thinking part of your brain to accept/know/whatever that the rule is X or Y ... but after years of exposure the non-thinking part of the brain just does things on it's own sometimes and is wrong, so the thinking part of your brain trusts it a little less. And it's almost never the order of "data string" vs. "string data" but the parsing order of the type "[]string" vs. "string[]" and sometimes the "x, y string" shortcut. This is esp. annoying with the parsing order because I know it's not just different but better the non-C way.
I agree that there are more descriptive words out there, but his intent and point seem to be portrayed clearly. Are people offended by the word choice due to the slang use of the word to mock the mentally challenged?
You get more accustomed to it.
Distributed services connecting over well defined protocols doing a lot of work. Back end services serving external clients. 
Where did you get the impression that an interface was an int? As a datatype, an interface is a collection of functions. In implementation, it's a pointer to a type and a value. 
No one but you is as vehemently interested in this change. You'll need to write your own compiler, sorry.
I cannot point to a particular guide or tutorial, because learning experience is highly individual, but the Go wiki has a [list of resources for learning concurrency](https://github.com/golang/go/wiki/LearnConcurrency) sorted from beginner to advcanced.
I'd extend this to general server-side applications and all sorts of command-line tools. Although I cannot say that this is what Go was *designed* for, Go is defintely very well suited for these areas.
Well if you want to collect anecdotes, I ran into that issue with the Go version of Enjarify. I got a measureable performance increase by replacing the initial interface{} based implementation of a custom tree structure with [a "template" monstrosity](https://github.com/Storyyeller/enjarify/blob/go/go/src/enjarify-go/jvm/treelist_at.go). And before you ask, yes the custom data structure is necessary here - trying to use an ordinary slice would waste over 16gb of memory.
More accurately, it means that Go's flaws are not crippling, at least for now. Of course, tons of things have been built in PHP and Javascript as well. There are many factors behind a language's success.
oh yeah command line tools in go are just light years better than most. Not ever having to worry about pip or gems or what version of the run time is on the prod box i need to run it on is just liberating. 
Just a few generics.
Check out Glide. https://github.com/Masterminds/glide I just started a new job working on a number of repositories that use it and it seems to be pretty solid. yaml file in project root defines repositories and versions / hashes running "glide install" imports the deps into the vendor directory .gitignore the vendor directory and CI pulls dependencies at build time badabing, badadone.
Either you will play well with default Golang ecosystem, or no one (except you) will use your language. I'd like to use strong typed functional language on top of Go's runtime. But I will never use unsafe undebuggable reflection-unaware crap. Hope the sanity be with you.
What are you saying "nope" to, and always been what way to you?
thanks for this!
nginx wasn't capable to compete at the monent, because it had no io threads then. And nginx's proxy-cache and mp4 was not as flexible (and mp4 probably still not as flexible, but I didn't checked). There is no need in other go's servers because requests are very heavy weight, so net/http overhead (compared to fasthttp) is still negligible. 
after build vue project you gonna have a index.html and dist folder. just host it with go http stdlib. but if you use the vue-router it gonna be an issue with path. since vue is just a single page app. so we gonna server all the path to the root path /
Yes
Using this is better: ``` setcap 'cap_net_bind_service=+ep' /path/to/program ```
1. The concurrent GC has been implemented in 1.5, so see [this](https://golang.org/doc/go1.5#gc) and — most importantly — [this design doc](https://golang.org/s/go15gcpacing). Basically, the only knob controlling the GC is the [`GOGC`env. variable](https://golang.org/pkg/runtime/) and its [`runtime/debug.SetGCPercent()`](https://golang.org/pkg/runtime/debug/#SetGCPercent) counterpart. You can also force garbage collection with [`runtime.GC()`](https://golang.org/pkg/runtime/#GC) but note that prior to 1.9 that would be an STW operation. 1. No, you can't switch the GC strategy. See [this](https://blog.golang.org/go15gc) for backgrounds and the roadmap.
Haha! So cute.
@chewxy is correct: the most visible scientific-related project is [`gonum`](https://github.com/gonum) and there's [Go HEP](https://go-hep.org/) ;-)
thank you!
Re. `setuid()` — there's little which can be done for this in Go because things like `setuid()` were invented with single process mentality in mind. With Go on Linux, you should possibly use the `os/exec` to spawn `/proc/self/exe` with the appropiately set `SysProcAttr` field of the `exec.Cmd` struct used for execution. There, the `syscall.SysProcAttr` contains the `Credential` field which can be used to set specific UID, GID and a set of auxilliary groups for the process to be created. The problem of passing the state between both processes exists but it can be solved in a number of ways with communicating the data via an inherited file descriptor in some easy-to-parse wire format such as `gob`.
Please read this go-to article — ["Go Data Structures: Interfaces"](https://research.swtch.com/interfaces) by Russ Cox. Note that it in the up-to-date "reference" implementation of Go (there are many in fact) "short" values (those which are less-than-or-equal to the size of the platform's pointer) are no longer cached in the interface values but this is an implementation detail you should safely ignore.
It was weird for a while, but the rationale made sense. I still tend to get tripped up by omitted types in longer function definitions like `f(a A, t, u T, z Z)`. I'll look at something like that and wonder what the type of `t` should be. 
I'm not exactly sure what's happening here, can you post the code you're trying to use? Are you using an `xml.Decoder` on the `Body` of the HTTP response? Or doing something else?
Are you not using encoding/xml? https://play.golang.org/p/60Im6cr4Iv
There's also (in alphabetical order): - https://github.com/astrogo - https://github.com/biogo
I recently needed some ffmpeg stuff to do. I guess a Go native full ffmpeg clone will remain a dream, and I will have to do with https://github.com/giorgisio/goav for now.
This is exactly what Go can do unless I'm missing something? type UserId int No | or parametric types in Go though...
if i find it annoying that the type comes after (not before, like C) - it's always been this way for me.
A mature toolchain for mobile dev. https://godoc.org/golang.org/x/mobile is a nice start, but still experimental.
dunno, I'm using chi and all I do is route f.e. /app and /app/* to the same handler, serving my vue app. This also allows me to have different routes not related to vue ... f.e. i have a simple landing page that i DON'T want inside my SPA, but rather be a classic server rendered site, so i have a "/" route for it. Not to mention all the API routes.
thanks.
[removed]
[removed]
Jenkins (history of tests) and sonarQube. Why the downvotes?
It's lacking the ability to interact with Xserver
There's [`golang.org/x/exp/shiny`](https://godoc.org/golang.org/x/exp/shiny) which makes use of [`github.com/BurntSushi/xgb`](https://godoc.org/github.com/BurntSushi/xgb).
&gt; I see a lot of libs that do code generation Really? You must work on different stuff than I am.
I tried it, looks good, is easy to use but needs more features, a viewer is probably not enough for me to use it. Coding wise from what I saw it looks good. Using interfaces is good, looks well done.
Sorry wasn't trying to say Go couldn't do it. For the record I like go as well.
Nothing wrong with that, tbh.
Of course, it's all a matter of opinion but I always found the python doc awful. The index isn't that good and it's really difficult to find the thing you want since there's pile and pile of text and complex examples of things I don't care about with shit tons of terminal dump. For example, let's say I'm looking on how to make optional arguments with argparse: https://imgur.com/a/vZQzV utterly useless. So many results because they are just dumping the terminal and it always contain the "optional arguments" text. Godoc is a technical doc while docs.python seems more like a giant brick of a book.
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/XxrCw1T.png ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dmy16ne) 
This package is useless for more complicated namespaced xml, no concept of xsd either. It really needs to be re-written as a dom parser like the html package.
Out of curiosity why dont you want to use the JVM?
No for me go's way feels more natural.
I think I'm slightly confused, why not just: ``` func JS(v interface{}) template.JS { j, _ := json.Marshal(v) return template.JS(j) } ```
As I said, it does not remotely solve all the issues, but it does solve this one. Using the capabilities system is better than having your program run as root indefinitely. We don't always get to choose the choices that are offered to us.
I am looking thru the code and it doesn't seem like the mongo connection is ever closed. Also, you should get a new connection every time you want to use it because mongo connections are not thread safe. 
Semantic versioning != Decimal notation.
No.
I find them hard to read because of the terrible typesetting. I usually just read the source code.
I read this: https://www.golang-book.com/books/intro
Which would be fine, and kind of what exp/shiny was doing. Problems with shiny are that the maintainer abandoned it, and they never got to the point of adding gui primitives. Great for going 3d smoke simulations though.
semantic versioning isn't new. Almost all software uses it. Take a look at [semver.org](http://semver.org/)
Calm down, you're not thinking clearly. The unsafe bits are managed by a compiler, just like in Go, so they're not unsafe, and if you're using one of these types from Go and using unsafe or reflect instead of the typesafe public interface, you're doing it wrong. In particular, if your program depends on the private interface of another package, you're doing it wrong.
Not even at first (while I do C#, I also do TypeScript which is the same order as Go).
Even that is unnecessary, `&lt;script&gt;var data = {{.Data}};&lt;/script&gt;` works as-is.
By pure chance, I just came across [this post](https://medium.com/samsara-engineering/running-go-on-low-memory-devices-536e1ca2fe8f) that might be of help--scroll down to the section "Tuning the Garbage Collector", where the author describes how to tweak the GC for a low-memory scenario. TL;DR: The GC only returns those pages to the OS that are unused for 5 minutes. To trigger this more frequently, use the method `FreeOSMemory()` from the `runtime/debug`package that forces a GC cycle and returns as much memory to the OS as possible.
ic i usually host my SPA as a separated server and a api or backend that connection with database as a sub domain
The right way to get setuid with Go, or really any heavily multithreaded program regardless of language, is to start a new process with the right uid: https://golang.org/pkg/os/exec/#Cmd.SysProcAttr and https://golang.org/pkg/syscall/#Credential
I wrote https://github.com/tv42/quobar with nothing but a low-level pure Go X11 communication library https://godoc.org/github.com/BurntSushi/xgb and it's perfectly doable.
I really don't understand what this is. We're not talking about localization as in translation of stuff to other languages?
[removed]
Other than having to support older versions of Go or recursive interface definitions is there any reason to not always declare interfaces as an alias like this?
i usually use a global session (that never close) for quick query and copy/clone session for big query then close it when done. more info: https://stackoverflow.com/questions/33275357/should-i-copy-session-for-each-operation-in-mgo
I would like to see more examples. Seeing a bunch of abstractions sometimes leave you confused. 
The problem is that Linux `setuid(2)` *wasn't* invented with a single process mentality in mind; on Linux it's a per-thread operation (where on OpenBSD, and in POSIX, it is per-process); and since goroutines don't map 1:1 with OS threads. Which isn't really a problem, it just means that we need runtime support that doesn't exist. That runtime support is actually a source of bugs in libc implementations (http://ewontfix.com/17/), but since the Go runtime is managed, it should actually be simpler there; someone just needs to do it. The problem with the `os/exec` approach is that you never fully drop the root privileges; you still have the root parent of the unprivileged process waiting for it; you can't tell it to not fork (*grumbles about needing a call that takes the same arguments as `syscall.ForkExec()` but doesn't fork*). My approach has been to just have a C wrapper that takes care of calling setuid(), then exec()s the Go program.
They way OpenGL works at the OS level is that drivers provide their own implementations of libGL, which is: C calling convention. If Go does add OpenGL to the std lib, it would probably just be moving the C binding in to the std lib. I suppose they could do do some trickery to bang out the C calling convention from Go, similarly to with the `syscall` package.
I used it for the longest time, but sadly gosublime is buggy/unmaintained so I switched to vscode + vscode-go and never looked back. https://github.com/Microsoft/vscode-go
Tried, and gave up. The tools integrations just weren't very good. Using gogland by jetbrains currently, and like it pretty well. I tried atom too, but its debugger kept breaking after updates.
Feel free to use whatever libraries you want, but you can do this with the standard library pretty easily. https://play.golang.org/p/BPLxVI8E1H
I have read that post before. I still wasn't sure what to do so I did a little more investigation. I found out that mgo actually uses a connection pool. Which means you should always copy sessions because you won't have to worry about the handshake. An existing connection is returned if it exists. Also, most importantly, if you are in a highly concurrent environment then you shouldn't use connections that are blocking. A web server is highly concurrent in go so I opted to use connection pools. I scale tested this while monitoring connections with mongo. It worked well. Hope this helps! 
Yes.
Glad to know I'm not the only one who finds Gosublime buggy
so you use clone or close?
Why not just exec ffmpeg?
The first misuse of aliases, though not the last I believe.
OMG.... anonymous interfaces.
I use Copy 
It's not a very elegant solution. It's similar to running git commands in the shell and parsing the output instead of actually using a git library.
The only issue is with gosublime. It takes a decent chunk of memory and sometimes the function signatures stop showing in the status bar. But ST3 is great in itself. Shifting to another editor will be too painful to me right now. So sticking with ST3+GoSublime for now. 
I don't see the problem, when the command line interface is so familiar and dependable it's essentially an API. It's also the same regardless of language and OS.
Aw sucks, why would you use Go for core services like this? Why not something like Rust instead of Go? 
This isn't an exercise, but a list of topics. It's one of the most useful resources I've found to understand channels, but not by itself. You would still need to cover the same topics in other places https://github.com/ardanlabs/gotraining/tree/master/topics/go/concurrency/channels
i wrote that and i disagree with you, it is not the first misuse.
_I wrote that and i_ _Disagree with you, it is_ _Not the first misuse._ &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ^- ^rmars ------------------------------ ^^I'm ^^a ^^bot ^^made ^^by ^^/u/Eight1911. ^^I ^^detect ^^haiku.
I went from Atom -&gt; VS Code.. but seeing the speed and efficiency of Sublime 3 I was temped to try gosublime. Thanks for the heads-up. I think I will keep Sublime installed for a general purpose editor when my vi skills are not enough.
I realize that this use isn't to permit gradual refactoring, but, while that was the reason it was necessary to introduce the concept into the language, it is not, therefore, the only possible valid use of the feature. I don't see how this isn't a perfectly legitimate use. It's exactly equivalent to having written the Packer interface as type Packer interface { Pack(interface{ Weight() float64 }) error } which permits the same level of decoupling except that the version written with an alias is easier to read, use, and document. I like easier to read, use, and document.
Same, I started out with Gosublime, never really had major issues with it (some minor ones but not critical), but when I saw that there was a visual debugger with vscode-go, having been so accustomed to that style of debugging from my days in VB.NET/C#, I was excited to give it a try. Haven't gone back. Then the other features like easy git integration, peeking definitions, better autocomplete. Only problems I've had with vscode-go are symbol rename doesn't ever seem to work, and the slight pain of keeping the underlying tools updated.
aka: Have you thought about 'Rewriting it in Rust'?
Haven't played with new features yet. Why is it misuse? And what are the drawbacks?
I find the symbol rename working only when the file is properly compiling. As of updating the tools, you can `cmd+shif+p` then `Go: Install/Update Tools`
because go is from google, and fuchsia is from google.
thanks for this experience
sure, they could've chosen an external system level language, but do that when you already have a system level language in house?
This subreddit is overall a good place to ask questions. The [go bridge forum](https://forum.golangbridge.org/) is probably the friendliest place to ask newbie questions. If you want real time help you can always ask Slack and go-nuts on IRC freenode, assuming you are on the "right" timezone. If you want help with *really* technical stuff [golang-nuts](https://groups.google.com/forum/#!forum/golang-nuts) is your best bet. 
Yeah, that makes sense. 
I thought so too, but moving to VSCode was about as seamless as possible. I miss a handful of plugins, but for the most part have no desire to use Sublime unless its to just open a text file real quick.
Oooooh neato, didn't know that.
Interesting. Folks have been wanting something like this for quite some time now: https://github.com/golang/go/issues/8082 (though it would be more interesting if it applied to all interfaces).
&gt; Why the downvotes? Those both seem pretty niche things.
The JVM is more expensive to run (i.e. more RAM usage vs. something like Go), and there's a lot more to "tune" than something like Go.
Not sure why people are getting so mad at you. Go is not the best language for every use case. Neither are Rust or Python. This is literally the sort of project that Rust is designed for, and it is better at it, as long as you are okay with the higher cost in programmer time. I think Fuchsia is designed in such a way that Go is actually more practical for core services than usual because of better isolation. Also, because Fuchsia is so young, writing the code in a higher level language makes sense. Rust could be used later as an optimization. 
+1 on the ability to use the new type alias as a means to write better, self documenting code. One of its nicest aspects. Though the grandparent could be referring to how the article specifically uses it to decouple 2 packages, which is closer to a misuse.
Thanks for giving it a try and for the feedback. I agree that GRV's lacking in features at the moment, it's still quite early on in the development phase. In future I would like to add features such as a tree view, status view and perhaps a contribution/graphs view (like in github).
Yup. It's okay for brief sessions (Sublime is my main editor), but VSCode and (neo)vim are way better for Go. 
If Go has a complete and stable libraries for Kerberos and HDFS, it could encroach Java territory even further.
I really can't think of any drawbacks
And I should mention that the xml I'm parsing isn't well formed (in that it's just a bunch of fragments).
Imagine a world in which you can do syscalls directly in Go without shimming out to C (cgo).
How is decoupling two packages a misuse?
[removed]
Isn't that the world we live in already? The standard library syscall package is implemented directly in assembly. https://golang.org/pkg/syscall/
At some point all values in a computer is just a number. In this case it would probably be a pointer to a memory location.
Came here to say the same thing. I thought python had decent docs usually but I've found that overall I like godoc more.
It could use a full XPath implementation, followed by support for XML Normalization, XML Signature and XML Encryption. Then it would be possible to support SAML.
Or Go could be made better if needed. It's not like they don't have people to improve it (like they do it with every other language they have) 
You mean you need to be able to read incomplete `&lt;Activity&gt;` elements, i.e. non-well-formed XML? If that's the case you'll probably need to [stream parse](http://blog.davidsingleton.org/parsing-huge-xml-files-with-go/) it SAX style.
You live in that world.
Not sure what the real purpose if this package is. Total RAM != what your app should consume.
It depends. In the authors case it was because he was writing one package that specifically used the other and just did this as an example. Unless you had a reason to decouple at this level you'd normally want the coupling to help the compiler enforce type errors and it would increase readability.
I've done the same thing, written types after variable names in other languages. Slices seem natural enough to me because back in the day I implemented a similar data structure for lists (arbitrary-sized arrays) in object-oriented Pascal. The way slices work is basically how you make lists work without the overheads of linked-list traversal; the only thing that's weird compared to other languages is that the details are visible to the programmer.
SFML = Simple and Fast Multimedia Library, https://www.sfml-dev.org/
Make that argon2 or scrypt. And better make sure that redis password is *really* secure.
CI/CD, test runner, graphical representation and tracker of failed/passed tests with detailed notifications about them?
Nope. It annoyed me probably more than anything else about the language at first, but at some point I got used to it and now I find it fine. I'm not sure I like it better overall but that's just taste; it's certainly at least as good if taken in isolation from previous experience.
Depending on what you're writing you'll get better performance out of the JVM though. I guess as always it depends on your constraints. 
Onion seems to be a tiny embedded dev kit, MIPS, 580 MHz, 64MB RAM, 16MB flash, arduino form factor, $7.50 plus accessories. RPi Zero W is $10 and gets you 1GHz ARM11/ARMv6, 512MB RAM, MicroSD.
Also, https://godoc.org/periph.io/x/periph/conn/gpio might be a better idea as a hardware access library.
I'm using ST3 + GoSublime. No problems detected. Kubuntu, Go 1.8.3
What the hell is http://golangserver.com/ ?
Uhh wat https://github.com/cheikhshift/Gopher-Sauce/tree/master/pkg/darwin_amd64/gopkg.in
Yup, but switched to Gogland!
That reminds me of BoltDB's `Update` API, https://godoc.org/github.com/boltdb/bolt#DB.Update
Well, why people are downvoting /u/fakeNAcsgoPlayer is because Rust was suggested, but there were no concrete reasons why Rust would be a particularly good choice for Fuchsia. I don't know if golang is a good or bad choice, I haven't investigated the design criteria. In my own 10-second analysis, it seems like it could be a good choice, I was thinking about golang when first reading about Fuchsia last year.
Everything is passed by value. That value may be a pointer.
[context.Context](https://golang.org/pkg/context/#Context) is an interface. It's size is two pointers. Copying up to 16 bytes shouldn't give you vague terrors like that.
I hope you've learned Ocaml before attempting to create new language. Ocaml is one of greatest functional-pragmatic languages. 95% of Ocaml's semantic will comfortably live on top golang runtime without any tricks with unsafe. Ocaml's algebraic types (ie "tagged unions") matches Go's interfaces cleanly (because they are also separately allocated). I'd better use "Ocaml over Go's runtime", cause it will have smooth 1:1 mapping with Go's types.
&gt;disgusting design choices, do not implement this, please I'd argue that some of this is pretty smart and easier to read. 
In that case, an array index is a reference too, and words mean nothing.
&gt; Manually-curated docs will always be superior to auto-generated docs Not true for the case where they no longer match the actual source.
 func lineListSource(ctx context.Context, lines ...string) ( &lt;-chan string, &lt;-chan error, error) { func splitter(ctx context.Context, in &lt;-chan int64) ( &lt;-chan int64, &lt;-chan int64, &lt;-chan error, error) { No, thank you.
Is fucsia usable as a daily driver yet if I can already use Linux?
give it a few years
Can you write that up and [post it in the wiki](https://github.com/golang/go/wiki/ExperienceReports)? That is exactly the kind of experience report the go team is looking for, AFAIK.
Thanks so much ! I guess I will stick to your proposal :)
Also prefer gogland link for anyone interested https://www.jetbrains.com/go/
There are roughly 666 CI/CD frameworks. Jenkins is not bad, but lack of an API to interact with it is not on the same level as "no viable GUI support".
i tried doing this in a home security project i was working on. ffmpeg seems impossible to use. theres a trillion different arguments and options, and the error messages are literally nonsensical. It would fail to transcode my camera and give vague errors about missing frames. Trying to get help from others ended in "that message doesn't say enough" well its all ffmpeg will give me. It's not wonder 0 people have taken up the effort to write a Go native library for this, its a shitshow.
No. Languages which are not memory safe have to be ripped out of our core infrastructure and die. Go is a pretty good tool, actually, for a system networking service. Networking is kinda what it's specifically designed for.
I'm not really sure what else there is to write up about it, and I'm kind of worried that if I did, it would be dismissed by people saying that it somehow doesn't count.
It's an xml file used to organize Go code. Find more information about gxml here : http://golangserver.com/docs/markup.html
The original project was intended to be a cloud service. Sorry about the confusion the port was very rough... But it is free to use 🤖.
As far as I can tell: No, this seems like a great use for aliases. You cannot attach it to methods to interface types anyway, so you don't lose that functionality. As far as I can tell only recursive interfaces would indeed be a impossible to create with this way of naming interfaces. These can be quite useful though, but you will find out easily when defining them that it doesn't work. Another thing to check out before converting all your code would be performance changes. It's hard to tell if it has any impact, good or bad (at least with my limited knowledge of the compiler internals) 
&gt; There are pervasive (and sometimes large) assumptions that you are reading that documentation with an existing grasp of what the package's purpose and jargon are. But aren't those assumptions correct most of the time? If I have no clue what HTTP is, why would I want to use an HTTP library? If I want to learn about HTTP, a specific implementation's API reference is probably not the most suitable place to start at.
The basic requirements of an experience report are a) what was a problem you where experiencing, b) how did you solve it, c) why wasn't that great. You can easily clear that bar by e.g. by pointing to a commit where you moved from `interface{}` to the specialized generated code, if the commit-message contains some benchmark before-and-afters. Or quickly write down that information in a gist. It's not the volume that is important, but the content. The bar isn't *high*, it's just that so many people (me included, FWIW) tend to philosophize about theoretical problems they never ended up solving - meaning it probably wasn't an actual business problem after all, because in the engineering field those tend to get solved one way or another. You have code. You have numbers (or can easily attain them). You clearly had a problem worth solving and solved it and are dissatisfied with the solution you chose. Your experience report would be valued.
Unfortunately Fuchsia/Magenta still lives in the non-memory-safe world :(
How can a greenfield project be a rewrite? 
Fuchsia/Zircon* now.
I've dabbled, but it's tooling and standard library are horrible. It's syntax is also awful, but I could live with it if the other issues were fixed. ReasonML over Golang would be fine, but I still like a C-like syntax a la Rust. :)
`context` is actually a pretty nifty and efficient design *where it matters*. Basically, you are passing around const-pointers (the pointer part comes from the fact that you are using an interface, which uses pointers under the hood. The const-part comes from the fact that the interface doesn't let you mutate the values), giving you an immutable linked list. But what's more, it's a tree - forked contexts (e.g. when spawning a new goroutine which then creates its own child-contexts) safely share all the memory with their parent. The important consequence of all of this is, that `context` *doesn't require synchronization* to do it's thing in a concurrent program, while still sharing most of it's memory. There are channels involved in cancellation and the like, but the data-structure itself is totally concurrency safe. It's a pretty cool design, honestly :)
I sometimes wonder if I'm the only one who is confused about the definitions of M, V and C and the consistency in how they are applied. I figured that the Views were the thing that is presented to the "user", so I'm confused about why your API and routes are under your controllers.
Interesting. Given that Fuchsia is a real-time OS, I wonder if the Go scheduler and garbage collector will need to be changed/avoided to ensure certain operations can be completed/cancelled by a hard deadline. Perhaps the core services being implemented don't need real-time guarantees? I am looking forward to reading the code for the network stack.
I like immutable data-structures, but I currently handle this by writing things as if they are immutable, without any language-level enforcement. What would a language-level enforcement give you? This is a genuine question, not a criticism
A [long discussion](https://news.ycombinator.com/item?id=15237923) on Hacker News on the topic. TLDR; quite a few unhappy comments. I'll be interested to see the material impact in terms of analytics... I wouldn't be surprised if it is quite a lot of hot air. No doubt mholt and team will eventually find the right path for what is undeniably a great project.
[Example header](https://urlscan.io/result/8093833b-8ac7-4d18-8f20-a02373f577a1#transactions): This free web server is made possible by its sponsors: Minio, Uptime Robot, and Sourcegraph HN thread: https://news.ycombinator.com/item?id=15237923
Correct me if I'm wrong. If you use their binaries, a commercial license is required for commercial use. If you build from source, it is Apache licensed, which allow Commercial use without buying a license.
I think mostly it seems like the wrong tool because Go is garbage collected, which you typically don't want in core services. Google's doing a lot of good work with making garbage collection performant, but you still need to stop execution of the program to free unused memory. They're smart people though, maybe it'll be great.
You're obviously not trying hard enough. :)
I was actually wondering about this when they announced Fuchsia. I thought it was weird that the core components were built in Dart. I figured Go would be more performant for a lot of these tasks. 
Try return &amp;int32(r.info.Quantity)
Now it says `cannot take the address of int32(r.info.Quantity)`
For those using gosublime, there is https://packagecontrol.io/packages/LSP that talks to the same language server that `vscode-go` uses and is generally OK. I switched completely to VSCode personally for many other reasons including many fun and useful ways to extend it.
i guess i solved it though by doing the following func (r *system) Quantity() *int32 { q := int32(r.info.Quantity) return &amp;q }
Besides `traefik` there is also https://github.com/labstack/armor as a nice alternative from people who brought a wonderful `echo` framework.
You're gonna have to make the result of the cast a variable, and return the address of that. I'm on mobile so I can't type it out myself. But basically a cast is an operation, but that operation never gets saved anywhere, so you can't take the address of it because you can't take the address of something that isn't stored. You can have a variable store the result of the cast to int32, and then return the address of that variable. 
Right! that's what i just did, you learn something new everday! func (r *system) Quantity() *int32 { q := int32(r.info.Quantity) return &amp;q }
Glad you got it sorted out!
thanks for the explanation! i had no damn idea of that!
Yeah after years of using ffmpeg I just wrap exec for it for all my projects. My latest project uses it in a lot of fancy ways, but is not open source. Here's an older project that wraps it: https://github.com/anacrolix/dms/tree/master/transcode, and a standalone library that I use from all my other projects: https://github.com/anacrolix/ffprobe. At least the avconv/ffmpeg fork battle is over (c. 2013?), it was a nightmare when they took different flags.
^ I believe that is correct. The op title is misleading.
Well, the short version is, go has a GC and a scheduler and the low level stuff that one needs to do while writing OSes pretty much require managing your own memory and scheduling. One has to know exactly when things will happen. The overhead go's runtime bring with it is a good trade off for higher-ish level work, not so much for OS level stuff. If you work around them with your own memory management and scheduling, then you're writing C that looks like go. Doing so might trip more people than pure C or pure go.
user interfaces, sysui, apps front ends, seems flutter based, flutter uses dart. For , non go, example the rust Xi editor has a flutter front end. There is a lot of go in fuchsia, package management and update manager are go based "pm - The Fuchsia Package Manager" "Amber: An update system for Fuchsia" https://github.com/fuchsia-mirror?utf8=%E2%9C%93&amp;q=&amp;type=&amp;language=go 
I don't like most bots, but even I must admit, haiku bot is cool.
Uhm go doesn't need C for most things. In fact that's one reason I worry about stability of Go on Mac OS. 
Now for QNX...
Ahh yes. And $50,000 pays for how many weeks of a full time developer's salary? I don't know how many hundreds or thousands of hours the caddy devs put into that product... but there's a ton more to creating a usable application than the std lib net code. That's actually kind of the whole point of caddy - it's supposed to be easier to use than the alternatives. It's not like apache and nginx suddenly don't exist... but there was an opening in the market for a web server that was easier to set up while still being fast and secure.
&gt;to ensure certain operations can be completed/cancelled by a hard deadline. Are you sure they are aiming for **hard** real time in Fuchsia ?
It's still Apache licensed. We should be celebrating when open source devs find a way to make money working on open source (which, by the way, we still don't know if they actually will make money). Open source is awesome, it makes all our lives better... but it's really hard to get paid. Caddy isn't some corporate sponsored OSS project that gains the company revenue through some other means. It's two and a half years of work. It's 778 commits / 507,405 ++ / 83,674 -- from one developer. Money is not evil. Money is what pays the bills so that people can work on open source.
The TCP/IP stack implementation is https://github.com/google/netstack which is a platform-independent library.
I could be wrong (I'm not the parent), but I don't think the issue with the Mozilla Grant is that it could be used to totally support the project or its developers in lieu of a commercial license. It's more about using open source grant money for what ultimately became a commercial product. I have no idea what the terms of the grant are, but I have to say it feels a bit strange for that money to be used in this way. 
&gt; low level stuff that one needs to do while writing OSes You are confusing a kernel and a service running under a microkernel.
It's apache 2 licensed software. https://github.com/mholt/caddy/blob/master/LICENSE.txt
It's apache 2 licensed software. https://github.com/mholt/caddy/blob/master/LICENSE.txt
If you dig around a bit, you should find some [Rust](https://fuchsia.googlesource.com/magenta-rs/+/88580e68f95830124e09f727c3090408056755ea/GETTING_STARTED.md) in Fuchsia. 
&gt; As of version 0.10.9, Caddy emits an HTTP response header, Caddy-Sponsors, which is similar to the Server header that Caddy already has, except that this one credits our sponsors who make it possible to keep Caddy free for personal use. This header cannot be removed by the Caddyfile, and its presence is required by the non-commercial EULA. This requirement is waived by the commercial license, so the header is not present in those binaries. This makes zero sense to me, in what way does a sponsor benefit from wasting bytes in each http request? Expanding to offer business support is OK, along with a few nuisances that it causes as the model settles in such as urls, docs, distribution methods, etc. I feel attempting to force people to utilize the new support system by adding undesired "features" to the existing software already in use by your users is not. More so when the software wouldn't have the success it has today without those users and 130+ contributors. It's not clear if removing the sponsor headers / building your own binary revokes your license or not.. either way this sure is bizarre.
It could be nice if the compiler interpreted taking the address of an unaddressable variable as assigning it and then taking its address, maybe. It's not extremely verbose, however.
It would be good to know what problem you're trying to solve. The garbage collector is intentionally not tweakable. This isn't java. The default works for the vast majority of cases.
Recently switched job and is now a full on Java at Amazon. I still subscribe to this subreddit and seeing Go progress daily makes me miss it so much more.
Godocs is way better than Apple's Objective-C Docs in iOS. At least I can read the source code and know what libraries that part of code is using. The only thing I find hard to read is the "Effective Go" book on the same site.
Combined some Go plugins to work together ![](https://i.imgur.com/rEMGVka.png) happy with it.
your book is "The Go Programming Language", step by step from "initiated" to "initiated in Go"
Not sure why mozilla doesn't appear on the list given that they got 50k from them.
&gt; As of version 0.10.9, Caddy emits an HTTP response header, Caddy-Sponsors, which is similar to the Server header that Caddy already has, except that this one credits our sponsors who make it possible to keep Caddy free for personal use. This header cannot be removed by the Caddyfile, and its presence is required by the non-commercial EULA. This requirement is waived by the commercial license, so the header is not present in those binaries. &gt; You SHALL NOT, and shall not allow any third party, to: &gt; (o) block, hide, obscure, modify, or remove the promotional header field named "Caddy-Sponsors" (and any case variants) from HTTP responses; I know I can compile it from source with a patch, but yeeeesh, this feels gross....... I was considering writing a little dokku-like system with Caddy as a library and its import directive to replace the docker-compose setup I finished recently, but I guess I'll have to defer that until all this settles...
I would Also recommend you exercism.io platform for solving some well defined programming problems which then can be reviewed by some other devs (you are gaining access to theirs solutions as well). That was a path I have did :)
Typically you wouldn't return a pointer like this for a basic numeric type without a specific reason. I imagine you are returning a pointer because you want to mutate it, but you are returning the address of the variable "q" of int32 type, not a pointer to the address used by info.Quantity. Also although I doubt it will come up in practice, this does have the potential for integer overflow as well.
Woah, I hadn't seen traefik before. I hand wrote a bunch of configuration to do what it seems to let me specify in a docker-compose configuration. I'll have to look into it (once I'm no longer rate-limited by Let's Encrypt...).
Do you have specific IPC in mind? What kind of container environment are you using? Are you more interested in structuring the Dockerfile file? What kind of config model do you intend to use? A more opinionated go-project-template will be available soon to provide reference implementation for some of the things you are looking for. There are nor hard standards or well established patterns, so what works for some isn't great for others.
Effective Go is something to refer to as you begin to write your first projects in the language. If you're familiar with other programming languages, it may or may nor make sense to you before you've written a few hundred lines, depending on whether the topics they cover have natural parallels. I would not say that it's an article aimed at teaching you Go, but as a tool for programmers who are already familiar with the basics of the language to begin to understand how it was designed to be used, if that makes sense.
[removed]
"what kind of container environment are you using" -- what do you mean by that ? I am having such setup. I have web server in go which is not yet sure where exactly will be, and go clients on different platforms. Those client's has to communicate with other local services (different languages) as well as with remote server. So client is kind of broker. No IPC communication is currently implemented on any node. I was thinking of gRPC as a medium. The point is that I am trying to break huge monolith to have more configurable system. 
 Free software, as it stands in the software community, does not mean free-of-charge. https://www.gnu.org/philosophy/free-sw.en.html In my opinion, more business that is built on top of Go is a good thing for the Go ecosystem. If it's successful, there will be more sustainable investment into the development and more full-time jobs using Go. 
This is why it is called open **source**. If the license permits, anyone can build binaries from an open source project and try to sell them. This is not against the spirit of open source, and as /u/natefinch already pointed out multiple times, the source code is still under the Apache license, which means free as in free beer (you get it for $0) and free speech (you can fork it and modify it).
I'm still not sure what Fuchsia is for :). If it's for phones, I suppose it doesn't need hard real-time guarantees.
You'd hope so, or at least the people complaining about audio lag etc in Android would.
I think there is a definite split of concerns here: * Go source layout -&gt; relevant to the resulting binary only. * Dockerfile/docker-compose file/Kubernetes/etc -&gt; relevant to containerization and deployment. (And as a side note, the file layout proposed in the Medium post [received some criticism](https://www.reddit.com/r/golang/comments/6zih3o/go_project_layout_for_new_go_devs/), e.g. for proposing an empty /pkg package just for holding subpackages, which is a red flag to some people.)
Effective Go is a collection of the specialities that Go has (compared to other languages). As such, it is not a self-contained document but maybe more of a reference. The suggested learning sequence seems to be "Go Tour -&gt; How To Write Go Code -&gt; Effective Go -&gt; Language Spec" but IMHO this learning path is neither continuous nor a one-size-fits-all solution. (This is in no way meant to diminish the work of all the authors of these documents - the Go documentation is really awesome, no question. The Language Specification is my go-to document for about every question that I have about the core language while coding. My concern is that there is a difference between reference and tutorial, and the official Go documentation tends to be more of the latter. Insanely great for experienced developers but no as great for beginners.)
&gt; so I'm confused about why your API and routes are under your controllers. this template is lack of the View part. In most of the mvc framework it should be the html template that render on the server side. maybe a new View folder and use the stdlib https://golang.org/pkg/html/template/
p.s. it makes no sense to return pointers to ints in such a case. The pointer will be 64 bits while int32 itself would be 32. You might as well do the `&amp;` outside of the function call if you need a pointer, specifically...?
thanks for taking the time and being constructive.
Aye, the thing is that I'm working on something where we're trying to use the smallest servers possible to reduce costs, so we have about 600MB of RAM, and that allows you to run several Go applications that run very well, or basically 1 or 2 JVM applications...
That's more up to a better CPU scheduler. Using hard real time OS in a phone just to ensure no audio lags is like shooting mosquitoes with machine gun.
i thought i heard something about vr could be 100% mistaken edit: looks like an IoT hub?: http://www.pocket-lint.com/news/138518-google-fuchsia-os-what-s-the-story-so-far
I hate to be this direct, but you clearly don't understand even the basics of Free Software, so why do you persist in commenting about it.
Thanks for sharing :)
This already violates freedom 0. It's probably the most important part of free software, and it's described in your link. This is not free software.
&gt; Perhaps the core services being implemented don't need real-time guarantees? That's the impression I got. It looks like most of the micro kernel is in c/++ https://github.com/fuchsia-mirror/magenta
Thanks for providing this information! I stand corrected.
Where there's a troll, there's a way.
We have actually used go and react together while we were transitioning a dotnet shop to linux stack. Dotnet devs were so easily adapted to go and they quickly become productive. But there were some challenges around connecting to some legacy systems like oracle :) (where is this not a problem? :)) Other than that I highly recommend it. It is a very fast growing ecosystem and a beautiful language. 
It's the editor I've been using since I started using Go (4~ years ago).
In fact, the aforementioned `xgb` (+ `xgbutil`) libs by BurntSushi are the best X-comm libs I've ever used. And I've used all C/++, Python, Ruby, Lua ones, you name it.
By the way, you can also write frontend React code in Go by using [GopherJS](https://github.com/gopherjs/gopherjs)
I've been using Go for the back end services for a few years so I'll give a few observations. 1. The web page still needs JavaScript. However, it's been nice having one team able to focus on the presentation layer, and one on the data layer. For a smaller project this may be more of a burden. 2. Excel is a PITA and avoid it. Both companies I've used Go at had requirements to support Excel. In one company PHPExcel was used as an endpoint and openpyxl was used at the other. Most recently, we tried two Go Excel libraries and found them lacking. 3. I did a bit of Rails at my last job, but didn't feel hindered by a lack of ORM with Go. Even now, gorp is used mainly to fill in structs from queries. There are other options in development that generate ORM like structs and methods that might be interesting for a new project. 4. There are web frameworks, but like ORMs, aren't totally needed. Something like Beego or Buffalo may help ease people into it.It really depends on what you're after. It sounds like something like this may be more what you're comfortable with. My last job I went from Rails to Martini (which is Sinatra-like.) Now it's basically httptreemux, standard context, and a small function composition middleware. I don't know what type of timeline you have, but being able to do a prototype in each may make it easier to pick. I would most likely pick Go for most of my back end services, but a few times it has made sense to use other languages. 
No need for drama here, folks. If you are using Caddy non-commercially, you're done. Nothing changes. If you are using binary releases of Caddy in a commercial context, you should rename your Caddyfile to Wedgefile and use a binary from here instead: https://github.com/WedgeServer/wedge/releases If you are contributing to Caddy, continue doing so, and your changes will show up in Wedge. Do not contribute to Wedge in preference to Caddy; that will cause a true fork instead of just two choices for distribution of the same underlying system. Open source gives us choices. Caddy made a choice, which left us with other choices to make in response. -jeff PS: I do feel conflicted about taking a project "commercial" after taking a grant. I think organizations that give grants will need to consider how they want to respond if more things like this happen.
If your intention is to be able to update r.info.Quantity externally, this is the wrong approach. That code is just handing out a pointer to a copy of r.info.Quantity. Any modification to that copy will not be reflected inside r.info. func (r *system) Quantity() *int32 { // makes a copy on the heap q := int32(r.info.Quantity) // returns a point to the copy return &amp;q } ptr1 := r.Quantity() // attempt to update (*ptr1) += 1 ptr2 := r.Quantity() if *ptr1 != *ptr2 { // this will always print: fmt.Println("quantity was not updated!") } You would be better writing accessors: func (r *system) Quantity() int32 { return int32(r.info.Quantity) } func (r *system) SetQuantity(q int32) { r.info.Quantity = int(q) } // use like this: q := r.Quantity() r.SetQuantity(q + 1) This avoids exposing the internals of r.info, so in future r.info.Quantity could be changed to use an int64 or a float32 or even a struct, but external code can still continue to use Quantity() and SetQuantity() to access it as if it were an int32. 
You can already do that. In package A declare type Foo which is an interface. In package B declare type Foo which has the same interface definition as the one in A. 
Agree about syntax: ReasonML has better syntax. ReasonML is still Ocaml (just with other syntax). And I more concern about language semantic than of syntax. ReasonML is quite close to C syntax-wise. No? Rust has quite different semantic. It will be burdensome to implement Rust on top of Go. Ocaml/Reason matches Go's runtime much better.
if you are looking for some like RoR https://gobuffalo.io could fit your needs, other case looks at gokit
I can tell you one I make all the time. I always accidentally type :+ instead of := because of poor timing with the key combinations. But other than that, I usually have no problem with syntax. It's such a small spec, there isn't too much for me to mess up. I switched to C++ and accidentally defined the return type of a function at the end before the braces. 
I have to try this!
I really love Sublime for all things, so I always want to try my hardest to stay with it as my only editor. I've used GoSublime for a long time and more recently used AnacondaGo. I've had issues with both. GoSublime has had slow semi-abandoned maintenance and I have had pain trying to contribute. It also sometimes has flaky doc resolving. When I switched to AnacondaGo, it was really fast, but then started having all these issues with having to scan the packages, and complaining about talking to its json server process. I'm at the point where I am getting sick of the half working Go env in Sublime and finally tried Gogland. It just plain works. Honestly I just want something that solidly works when I need it so I don't have to dick around figuring out why I can't jump to defs or load docstrings. I may be using Gogland now unless that LSP plugin I just saw for Sublime works flawless. 
Yes. You will like it and you will hate using RoR again.
But ... now you returned a pointer to q and not to r.info.Quantity ... is that intended? You can neither manipulate r.info.Quantity with that pointer nor does it save you any memory. Why did you want a pointer in the first place?
If you are going to develop a server-side application which produces HTML, unless it is simple and small in scale, then Go might not be the best tool for the job. Really no language is. This architecture simply doesn't scale. RoR can help up to a certain point. But as soon as the rendered pages start becoming complex and increase in number you are going to start pulling your hair. On the other hand if you are going to develop an API which will be consumed by some Javascript frontend then I highly recommend Go.
I don't think you can truly have "isomorphism" unless you write everything in JavaScript. My recommendation is to keep the backend in pure Go and hone your skills in HTML/JavaScript/CSS for the frontend. There really is no other way. Everything else is just sweeping the problem (JavaScript) under the rug and pretending it doesn't exist.
The isomorphic aspect of React is that React, or [ReactDOMServer](https://facebook.github.io/react/docs/react-dom-server.html) rather, can be run on a Node.js server due to React's JavaScript codebase and output a string via `renderToString()` or `renderToStaticMarkup()` no? I'm still using the former with Koa, but... Wouldn't that mean that you'd be looking for ReactDOMServer code written in Go, if you would want to run that on the server? Quickly Googling for it gives me: &gt; **go-starter kit** This project contains a quick starter kit for Facebook React Single Page Apps with Golang server side render via goja javascript engine &gt; * [Github, olebedev/go-starter-kit](https://github.com/olebedev/go-starter-kit) But [goja](https://github.com/dop251/goja), used by go-starter kit, seems to come with the following caveat: &gt; It is not a replacement for V8 or SpiderMonkey or any other general-purpose JavaScript engine as it is much slower. 
You could choose a templating language that has Go and JavaScript ports, but it's highly likely you'll find the minor differences in production with unexpected bugs. 
&gt; Really no language is. I'm confused - what are you suggesting here if even RoR can only help to a certain point?
&gt; I'm confused - what are you suggesting here if even RoR can only help to a certain point? Separation of backend and frontend.
Hmm. I never deal with services that have server side templates, and people also talk about using it on the javascript side, so I'm potentially getting confused between many different contexts and applications of it.
I guess Caddy's new license is a… _lowers sunglasses_ …wedge issue.
&gt;I'll soon start working on a greenfield project and the only two language options (imposed by the company) are Node and Go. If those are your two options, definitely Go. With Node you'll constantly be dealing with library churn and the other issues of the Node ecosystem. (How's that fork going?)
&gt; ReasonML is still Ocaml (just with other syntax). And I more concern about language semantic than of syntax. Agreed &gt; ReasonML is quite close to C syntax-wise. No? Agreed, but not as close as Rust. Reason still lacks things like parenthesized function calls and such things. Not a big deal, but there's no need to settle since I'm writing my own parser/grammar anyway, right? &gt; Rust has quite different semantic. It will be burdensome to implement Rust on top of Go. Ocaml/Reason matches Go's runtime much better. I agree, but I'm not proposing compiling Rust to Go, but simply borrowing from Rust's syntax. The semantics will probably be very OCaml/Reason-like.
I can't believe people still write front end code in the back end. Just gross.
If you only allow the variable to be changed via functions that send such events, yes. Alternatively, you could spawn a goroutine that spun on the variable not changing, but that wouldn't be a good use of resources, and would have potential synchronization problems.
what's wrong with flags?
I've been using both Golang and Node.JS and I'm gonna make a short comparation: - in terms of packages, node.js beats go by far with npm, but now it depends what kind of packages you're looking for. I needed a good image processing package ( something like sharp in node) and I successfully found it in go. - in terms of productivity, node.js feels faster too me and now with es6 even faster. Go assertion is kinda boring sometimes - in terms of performance for web development I've heard that they do the same, but I doubt it since it's native code vs interpreted code. (Note: there's also fasthttp package which I also use it in production..) - in terms of ruby guy..well, it depends by a lot here, neither node.js nor go looks like ruby, but if you're doing the switch because ruby feels slow, there's also crystal language which was intented to be native ruby, but turned out in the compiler. Kemal ( like sinatra) and Amber( like rails) are very well mantained crystal web frameworks. Also note that the crystal itself hasn't reached v 1.0, but the http lib is pretty solid. Other than that, if performance si not a matter for you, go with Node.JS. We used node.js at our company to consume an API written in c#. If you're looking to design APIs, go with go, working with databases will be a pain so I sugest using some helper libs like xo (NOT an ORM). Good luck ;) 
I don't think that anyone has ever traded js react for gopherjs react in production.. Edit: Why? Simple, the devtools, the starter kits, bundlers etc..
I think it would be cool if they implemented this for error. Instead of having a bunch of if err != nil blocks, just a quick one liner like watch err return. Kind of like defer
This is correct and was confirmed by Matt here - &lt;https://twitter.com/mholt6/status/908041929438371840&gt; See &lt;https://www.calhoun.io/building-caddy-server-from-source/&gt; for info on how to build caddy from source. It is documented mostly in the caddy README, but I combined those instructions with details on how to remove the `Caddy-Sponsors` header as well to make everyone's lives easier.
this is the best answer so far. thanks
:)
It's probably a matter of time until we'll start to see more heavier ads in headers, not necessarily just in caddy, but in other software too... Imagine getting full page JS ads when you're browsing your logs in your cheap "web 3.0 single-page server logging app", because escaping rogue http headers is a "premium feature". Eww
Sometimes producing HTML server-side can be better. It really depends on the project requirements. But I tend to agree. With this architecture, when the project grows bigger and more complex, things start getting pretty gross.
I think gRPC could be great. My team has fairly junior members, so we stick to simple rest calls.
&gt;I am looking forward to reading the code for the network stack. I believe this is it: https://github.com/google/netstack
I'm using [neelance/graphql-go](https://github.com/neelance/graphql-go) to implement graphql, so according to the graphql spec it only uses int32, and the library requires an *int32 to be returned https://github.com/klud1/graphql-docker-api/blob/10dec106b3b9828af058198aa0522c9acc12be3b/resolver/system.go#L82
I'm using [neelance/graphql-go](https://github.com/neelance/graphql-go) to implement graphql, so according to the graphql spec it only uses int32, and the library requires an *int32 to be returned https://github.com/klud1/graphql-docker-api/blob/10dec106b3b9828af058198aa0522c9acc12be3b/resolver/system.go#L82
Me neither, but I think hard real-time is typically only used in really critical environments, where missing a deadline could be catastrophic.
Go is awesome for web backends, and most people find they don't need a framework. Get a router, maybe an auth library, and get moving. What kind of libraries are you looking for? Have you looked at Go's built in packages? They might seem limited, but they're quite robust. I came to Go from PHP framework world myself. But, after a few years of using Go almost exclusively for web backends, I've realized I don't need all that bloat. 
I love all jetbrains products
Same. Only criticisms I have is that the battery life on my laptop with Gogland isn't the best and that I get some random cursor bugs but all I have to do is click and it's fine again so no big deal.
Caddy is open source and free - https://github.com/mholt/caddy/blob/master/LICENSE.txt The binaries precompiled by the Caddy team are NOT free. These are not the entirety of caddy. They are something offered in addition to the source code, and attaching an EULA to these DOES NOT make caddy no longer free and open source. Unfortunately this was all lost in the announcement and should have been communicated much clearer.
&gt; This already violates freedom 0 It doesn't actually. You just have to build the binary yourself (which takes like 2 minutes tops) and then you can use it however you want. I get that this change is going to ruffle a few feathers, but the source code itself being free is very significant.
Would like to see one for sync.Pool too :)
To be clear, I completely respect Matt's right to try to monetize Caddy and turn it into something that is sustainable through licensing. I also recognize that most open source projects ARE NOT sustainable on sponsorships and donations alone. I likely wouldn't have chosen the same route for monetization (at least not exactly the same), but it is his project so he can do as he wishes. Unfortunately the license is too expensive for myself and for many of the students taking my course. Luckily (and thankfully), the source code is still Apache 2.0 licensed (free, open source), so by building caddy from source we can all continue using it as free open source software. And for those of you claiming that caddy is no longer free and open source because the binaries have an EULA, let me ask you this - if they didn't offer any binaries at all, meaning there was no EULA attached to any binaries and you just had to build the source yourself, would Caddy still be free, open source software? I would argue yes, that it would be. I don't see any reason why you have to provide a binary to be free open source software. Given that assumption, the binaries they provide can be looked at as a service separate from the software. Nobody claims that WordPress is NOT open source because wordpress.com offers a hosting service. Nobody claims that Ghost (https://ghost.org/pricing/) isn't open source because they offer a hosting service. So **how does it make sense to say that Caddy is not open source because they also provide the service of packaging and distributing the binaries?** That service is both separate and in addition to the open source software. It isn't the software itself.
Or you can use nginx, straight from precompiled binaries and a minimal configuration.
You can, but in my (limited to one day at this point) experience it is still faster, easier, and more secure to build caddy from source for my use case.
 type RegularIntMap struct { sync.RWMutex internal map[int]int } Just a gentle reminder that defining the `struct` this way does NOT keep the mutex internal, which means that consumers will have access to `RegularIntMap.RWMutex`, including the ability to `Lock`/`Unlock` as they wish. Most likely you'll want the mutex kept private as well by giving it a lowercased field name, e.g. type RegularIntMap struct { mu sync.RWMutex internal map[int]int }
&gt; That's not the point but in most of Europe most developers don't make $50.000 a year. Who cares? Matt lives in the U.S.
Please describe the use-case 
What's wrong with using the non-commercial license for a class?
Why not? I'm curious to find out his use-case. What's wrong with that?
I think the model doesn't make much sense for customers when people running a commercial site realize Nginx is better in its free edition. If Caddy provided a differentiator for a pro version (a new plugin or two that is premium only plus support) but had an unrestricted free edition, it would be more comfortable with the community. Personally, my company isn't going to contribute code to something they pay to use, and we're too frugal for support contracts. If all the companies that won't buy support go for Nginx instead of Caddy, development of plugins might slow way down. I also do a fair bit of freelance for the technical bits that WordPress developers can't handle (a huge target for Caddy usage) and I'm certain 0% would pay for support. With Caddy being the perfect simple solution for that huge community, an unrestricted free edition is quite beneficial for spreading Caddy's fame. Now do people need to be angry? Probably not, but they feel like they're losing something they already had.
I'm a linux guy, so I'm used to shitty battery life haha. I haven't had any cursor bugs on Ubuntu yet hmm.
I think you just volunteered ha
&gt; Now do people need to be angry? Probably not, but they feel like they're losing something they already had. Not angry, but annoyed. We've been using Caddy at work for well over a year because it just works™ and it has really good and sane defaults which helps keeping the Caddyfile simple and concise.
I get your intent in not wanting to make this about the choice between them, but I think it's valid to consider that even if you assume Caddy is better, whatever that might mean (and I do), then it still looks to most casual users researching options that Nginx has a free option for business while Caddy does not. Most developers won't have time to learn that they can compile Caddy for a free option and, if they do, might assume it's complex if they don't know the Go ecosystem.
One use case - I'm running 3-4 small web apps on a single server, each running on a different port. I use caddy to provide SSL, gzip, and proxy to the appropriate web server. This is like 2-3 lines of config for each new domain I add to the server and I get SSL and whatnot all for free without having to worry about renewing certs etc myself. I can set this up, even when building caddy from source, in very little time. With nginx this is all possible, but in the past it took more work to do and setting up auto-renewing certs etc always involved learning more so I knew I wasn't messing things up or setting up something insecurely. With caddy I don't worry as much about this because it has secure defaults for me. Again, not saying I *couldn't* use nginx, but that this license change (and me thus having to build from soruce) isn't reason enough for me to switch.
that would certainly be a very educational UNIX project. (and I guess that will probably be my X-mas project, if nobody jumps the gun)
I'm hoping Caddy sees the opportunity to keep the community large by taking a market approach much more like Nginx's model.
I'm on macOS so maybe that's why. It's not shitty, it's just not as good as Sublime. I don't have exact numbers to share though. Just something I've noticed. Also, my laptop gets significantly hotter.
In the first iteration of the videos for the course I talk about how caddy is open source and can be used for whatever project they are doing. Now that isn't the case, and I am going to have to go back and re-record the video. Not a huge deal, but it is a change I need to make. If I kept using caddy's binaries as I was, I would have to add disclaimers talking about how this only works for personal use and if you are looking to eventually offer a commercial product that what I'm teaching you is no longer applicable (at least without some slight changes). If the license changes, I may need to go update the videos yet again to make sure what I say is accurate. I might also have to field questions about what use cases do and do not constitute commercial use. I'll still encourage students to support caddy if they end up using it commercially (I never intended to suggest not supporting caddy), but I don't want to have to constantly keep up to date with the license used by caddy, and some students will eventually want to see how to build caddy from source so it seems easier to just do that from the onset.
I have a mac at work and I personally feel like the whole OS likes to lock up for like no reason fairly regularly haha. Lots of people have been praising VSCode lately... 
A minot nitpick: there's no type casts in Go, only type *conversions,* which are explicit. This might appears as a minor terminological stuff, but in fact type *casts* are like what `reinterpret_cast&lt;T&gt;`s in C++ are for -- they interpret bits in memory in another way. Conversions are explicit about what happens.
The frontend can be separated. It doesn't need to be served by the backend. The only two options are Go and Node.
I really like the structure a framework provides. Maybe because I'm seeing this through the eyes of a Rails developer.
You're right. I have a bad habit of using the two interchangeably. 
Beware. Writing a compliant terminal emulator is amazingly difficult.
It was just an opinion and it wasn't backed by any evidence or references. The empty /pkg directory is just placeholder in the repo. If you have no (public) libraries then delete it. If you have libraries put them there. This is exactly what Kubernetes does ( https://github.com/kubernetes/kubernetes/tree/master/pkg ) and that's one of the most popular Go projects.
That is correct and also true of sync.Map. It boils down to these collections ensure the container is free of data races not the item in it. If you store values then no mutation can occur as you are just working off copies. If you store pointers, while the pointer is copied, you must be careful no concurrent mutation happens against the item of which the pointer dereferences. If so, you must now synchronize that item. All trade-offs.
Who are those "some"? Where is it documented as an anti-pattern? Can you provide references? If several of the most popular Go projects (including Kubernetes, for example: https://github.com/kubernetes/kubernetes/tree/master/pkg ) are using the pattern maybe it's not an anti-pattern. Maybe it's the other way around :-)
"container environment": are you using or thinking about using Kubernetes, ECS, Nomad, docker-compose or something else? 
yes. I think I am aware that is difficult. (I probably don't know at what level of difficult it is. "Kid Chameleon (SEGA)" difficult, or regular difficult :})
This is a structure I use and post recently on gophers.slack.com#grpc ├── LICENSE ├── Makefile ├── README.md ├── ${scv}pb │ ├── Makefile │ ├── ${scv}.pb.go │ ├── ${scv}.pb.gw.go │ ├── ${scv}.proto │ ├── ${scv}.swagger.json │ └── swagger.go ├── bin │ └── ${project} ├── cmd │ ├── root.go │ ├── root_test.go │ ├── serve.go │ ├── version.go │ └── version_test.go ├── examples │ └── docker-compose │ ├── data │ │ └── shared │ │ └── README.md │ ├── docker-compose.yaml │ └── env │ └── common.env ├── images │ ├── alpine │ │ └── Dockerfile │ └── scratch │ └── Dockerfile ├── main.go ├── server │ └── server.go ├── vendor │ └── * └── version ├── latest.go ├── version.go └── version_test.go bin/* is ignored on the `.gitignore` file. 
You make good points, though I wasn't talking about pointers vs. values, I was referring to ensuring the Mutex isn't exposed as a public field of the struct. Both the original example and mine use a value, not a pointer, for the mutex, which should be fine as long as the RegularIntMap is always used as a pointer. Otherwise, the copied value of the RegularIntMap will have a fresh (unlocked) RWMutex, but have a map pointing to the same underlying data structure - that'd be bad, I think ;)
There are a lot of existing projects to learn from though.
https://golang.org/pkg/sync/#Cond
I just want to see a fork named "Shack Server".
By all means, start with Linux - and scale back the features until you hit the bare minimum and it's approachable, but then add things back once you get the start. However, port it to OSX and Windows and that'd be REAL legit. Esp for Windows.
Ah yes, it's definitely a great practice to not export the mutex in general and leave the lock semantics as internal operations. Much agreed.
What are you trying to test exactly? That the JSON contains all the data it should? Though it sounds like you're trying to validate the strict against the JSON, which seems the wrong way around.
A little repetition is better than a little dependency. Extract it to a function for a start. Or write a function factory that gives you back a preconfigured "client"
With those ridiculous prices? lolno. It's waaaaaay cheaper to maintain a slightly more complex nginx setup…
You loose some specific type-information. Like, I'd assume in error messages the type would appear as `interface{ Foo() }`, not as `Fooer`, if you declare it as `type Fooer = interface { Foo() }`. At the very least, it will not compile the type into the runtime - which *rarely* matters, but it does if you ever want to inspect methods of an interface via `reflect.ValueOf(&amp;v)`. The mising reflect information probably doesn't matter, but the bad error messages will.
I love Jetbrains products too, but here one is an IDE and does constant code analysis in the background using up CPU time, the other is an editor and doesn't do much of that unless through plugins that is why one runs significantly hotter than the other, even though both are Java apps it's like comparing apples and oranges.
There is nothing wrong with comparing IDEs to text editors. Each has their own set of benefits/drawbacks. I was just clarifying that Gogland isn't perfect.
Great job! That's the best write up I've seen in a while, and damn it, it was awesome to read to the end.
Yeah. Another idea would be to call them exception. 
Also, how am I supposed to control a third party? Lets say my request gets proxied by someone else, am I now responsible for them not removing the Caddy-Sponsors header from the response? How on earth is that supposed to work?
If I wanted I could spawn a build server, change the header as I wish and sell those binaries. Just like Matt does. Except I'd have to call it differently than "Caddy". Why could I do all that? I have the _freedom_ to do so, _because_ it is Open Source. I don't understand this drama. 
Is there a compelling reason to remove the sponsors header?
The use case is I have a library that uses a 3rd party api. The 3rd party api is still a little unstable in that they continually add more data in the json returned. From time to time I check by hand the json returned is covered by the struct but it's a bit tedious and I usually forget to do so until someone asks about a missing field in the struct. So I want a sanity check that I can run to ensure I have the fields returned by the api endpoint covered in my struct. In a perfect world I would control both endpoints but in this case I do not and this seems like the most logical way to inform me of changes to the json structure
Ok fair enough. I just had a discussion a few weeks back (related to Python) involving vim vs PyCharm and the reason I like IDEs so much is because I notice just how many mistakes vim users make in my teams because they don't get the constant feedback from the code as you go. Even just the typos alone, code riddled with hundreds of typos because no checking is going on. Now I suppose with Go it is a bit different because most of the little issues are generally picked up by the compiler anyway (not typos off course), but with PyCharm the constant feedback I get from static analysis is invaluable to me and helps me produce higher quality code. And I know Gogland/PyCharm aren't perfect but I would gladly trade up some extra CPU time and RAM to produce higher quality code with fewer problems.
And on a simpler level - if I were taking my own course this is what I would prefer to learn. That is honestly what dictates a lot of my choices; what would I prefer if I were taking the course?
Checkout [libp2p](https://github.com/libp2p/go-libp2p). It's pretty easy to use and robust. We're using it and it's working much better than our previous attempts.
Wow. That's huge and useful article for anyone who want to master his/her AST skills.
Agreed.
Re-reading my previous comment it becomes obvious to me that it sounds like direct criticism. That's definitely not what I intended. I am not against empty packages as part of the import path. I only observed that this is a controversial topic and wanted to make the OP aware of that. 
I'm trying to imagine if _anyone_ would be complaining if an entirely separate 3rd party released pre-compiled binaries of this open source software and charged for it. Somehow it's only a problem because the actual code author is doing it? That seems backwards.
The common name for a mutex field is `mu`.
You could potentially write a test that: - Unmarshals a golden file (last known good json response) into a `map[string]interface{}` - Create an instance of your struct, marshal it to JSON, unmarshal into `map[string]interface{}` - Iterate over the keys in the golden version plus the struct version and ensure the set of keys are equal Then, extend it by adding a `-update` flag to your test functions (of sorts) which, before unmarshaling the "golden" file makes an actual HTTP request to your endpoint, saves the response JSON as the new "golden" file, and then proceeds. Effectively, you would periodically run your test suite with the `-update` flag to pull down an updated version of the API response, and your normal test runs would verify that your struct fields line up with the API responses.
Thanks, updated
Here's my rule of thumb: Do not use `sync.Map` unless you can clearly explain the meaning of every single detail in the docs: &gt; It is optimized for use in concurrent loops with keys that are stable over time, and either few steady-state stores, or stores localized to one goroutine per key. If you can explain that, then you already know when you should use `sync.Map`.
I want to agree with you so bad and in principle I do, but the way Caddy has decided to structure and price its commercial licenses is so mind-numbingly obtuse that I just can't argue in their favor. I'm 100% in support of more open-source developers getting paid for the value they deliver to companies. But the structure of Caddy's pricing is not friendly at all. Caddy's pricing structure adds too much cognitive/process overhead: for company teams and for solo freelancers.
What's the point of all the goroutines, channels, and global variables here? This code looks extremely suspicious. https://github.com/deckarep/sync-map-analysis/blob/e64565c0c97cdced1bb68b7d713a63cc88b43026/bench_test.go#L181-L200
Wow, thanks!
&gt; This makes zero sense to me, in what way does a sponsor benefit from wasting bytes in each http request? It's an Ad. Those things to the right -&gt; They are Ads too, they too waste your bandwidth. Online advertising is a pretty established business model at this point :) (not saying I like that they sell advertising real-estate of their users)
&gt; If you are using Caddy non-commercially, you're done. Nothing changes. This is not really true, though. If you use their precompiled binaries, you are a) going to have to agree to their EULA and b) have to sell ad-space in a header. It's going to be interesting what e.g. Debian is going to make of this. This might become another Iceweasel-storyline…
But those ads on the right you'll actually see, you might even be tempted to click on one. An HTTP header you pretty much never will. It doesn't do your sponsors much good.
FWIW 50K is not a lot of money. I assume at this point Caddy is the full-time job of *at least* one engineer. 50K can pay one engineer for maybe half a year, if even that.
I suppose they could also just throw out the package. Considering how easy this is to build yourself that might be a viable strategy. Firefox is a bit more complicated in that regard.
&gt; That's not the point but in most of Europe most developers don't make $50.000 a year. Depends heavily what we mean by "developer" and what we mean by "make". Most people qualified to maintain a scalable web-server will make at least that much in most of Central/Western Europe. Fresh out of university. And that will be their base-pay. They will likely get additional bonuses/equity on top. And lastly, what a developer makes and what they cost are two different things. Usually they differ by at least a factor of 2. So, no. I don't think, even in Europe, 50K buys you more than maybe four months of developer time.
I'd just like to clarify. The binary is both not free and not free-of-charge (i.e. both licensing fees and limitations of use). The source is still free software and free-of-charge. Right now, the source matches the binary pretty closely (if not exactly), so it's easy to handwave this away. I doubt it will stay this way forever.
[Look at the list of sponsors](https://github.com/mholt/caddy/blob/ad973f1d125d4da9ba8bc21448dcd3de3fe79cbe/caddyhttp/httpserver/server.go#L346). The people those companies advertise to are looking at headers.
The point is to hoist results into package global variables to prevent the possibility of Go to eliminate dead code from variables that aren't properly used thus not actually measuring anything properly. The goroutines are there to actually exercise concurrent calls as part of the benchmark. See Dave Cheney's article on some of the benchmarking pitfalls on the subject of dead code elimination: https://dave.cheney.net/2013/06/30/how-to-write-benchmarks-in-go
It's 109 extra bytes in every response that have 0 purpose.
 _ = foo Is enough. It's used by the stdlib.
There's also https://github.com/WedgeServer/wedge
Right but is there a **compelling** reason to remove the sponsors header? 
This is pretty cool but they have already announced that Polymer 3 will throw away a lot of the declarative HTML syntax in favor of JavaScript literals and js imports. Are there plans to support the new changes?
I'm pretty conflicted about this. On one hand, I think we need a sustainable model to fund open source development. On the other, I don't like making this kind of change without the input of the community. I created and maintain the JWT plugin for Caddy. I spent a few hours this week, including staying up late, to work on and push a patch for a critical security vulnerability in Caddy. I do that because I think it's worth contributing to open source so that we can all benefit. But as a plugin maintainer, am I now expected to provide support to commercial license holders? Matt and company have done a lot of work to make Caddy easy to use, but so have a lot of plugin authors and maintainers, as well as contributors to Caddy. I'd be fine if they wanted to offer paid commercial support or offer paid plugins. I don't like this licensing model much as a business move or as a way to build a healthy open source community. 
If that third party got the Mozilla money, people would be complaining..
I don't even care if it's still legally open source or not; this is not a nice trick to pull, and *should* reflect poorly on them. Hell, almost all of the difficult stuff is in stdlib, not in caddy.
And people wonder why docker split into "moby" and "docker corp"
VR doesn't need hard real time either, it just needs to not miss frames in typical use.
Feel free to just add a couple 100 bytes to all of your headers. Is there any compelling reason not to do it?
only docker-compose for this project. Point is that here everything has to run in a private network within the designed system. It may change in future but now "this is what it is". Currently docker-compose is a convenient for me, because I can simply deliver entire infrastructure to my no-software team-members. In future clients will rather be hosted on native platforms (and again this is what i love in Go it's out of the box cross-compilation ability:))
I think you're taking my post the wrong way. Obviously, its 109 extra bytes with no purpose. In a practical sense, almost nobody is negatively affected by 109 extra bytes. In a similar vein, you could edit all sorts of software to reduce the size of their response headers, but how many people are actually removing the other HTTP headers that are not useful? I bet your web server still sends the "Server" header, even though it provides no benefit to you or your clients. But OK, whatever, these 109 bytes are different.
Well that's one of mine concerns actually. The more I read and learn about gRPC it looks like a PERFECT solution for almost all IPC communications between services which communicate by requests/commands. It is probably my personal trait but whenever I find something "perfect" a huge red bulb is lighting up on the back of my head :). So I keep digging 
Use [suckless-st](https://git.suckless.org/st/tree/) as starting point.
&gt; Kid Chameleon (SEGA) difficult, or regular difficult Dark Souls with 1 HP and 1 Stamina difficult... :)
The weird new licensing is for the *official binary distribution* only. If you build it from source, you are receiving it under the Apache 2.0 license (same as before), and can do whatever you want with the binaries you get from compiling it yourself (within the bounds of the Apache license). Now, unless I'm missing it somehow, Debian doesn't currently have Caddy in the main repos. Bit if it did, I guarantee you that they would be building it from source, even without this issue. So, as far as Debian cares, it's just plain Apache 2.0 -licensed.
Ive done quite a few sites with React and Go over the last few years. The best combo in my opinion is [chi](https://github.com/go-chi/chi) for a router and [sqlx](https://github.com/jmoiron/sqlx) for database access. You don't need much more than that.
Whoa I had no idea about this. Too bad. Caddy was a Go project that made me feel proud to be writing Go. Not anymore.
I have over 6 years of reddit gold, I don't see any ads. If I did I imagine I would fail to see the correlation between the user interface of a social media website I'm using for free and the injection of non-standard http header (Caddy-Sponsors - notice it doesn't even have a X-Caddy-Sponsors prefix) in a protocol used to serve computers built by 130+ contributors under the pretense it was open and free software.
Been checking it out. The "robust" part of it is actually neck breaking almost. The documentation seems lacking, or I'm possibly just missing some info somewhere.
I'm not sure what you mean about the robustness being "neck breaking". Sure, it could be better. I think the documentation in the repo is pretty good, the [examples](https://github.com/libp2p/go-libp2p/blob/master/examples/echo/main.go) are pretty thorough, and there's a good community on the [Discourse](https://discuss.ipfs.io/) chat and in the #ipfs channel on freenode. libp2p has been completely reliable for us; we're yet to experience an issue with it.
https://github.com/golang/go/issues/21866
TIL. Great article. It such format it was easy to absorb even by a such newbie as me :)
I believe a lot of it stems from not truly understanding the changes and being scared that this means the code will split drastically in the future, but I may be wrong.
I personally have no specific reason to do so, but many people have complained so I included it in the post. The one issue I can see is that it might give away version info which may be bad. Eg a bug is found in caddy, then a patch is released along with a new sponsor, and now would-be attackers know you have a vulnerable server. That said, I suspect they would just try the attack regardless of headers so it may be a moot point.
Great rule of thumb. Would you mind explaining it so that others may know where to start their learning? For example, I don't know what *stable* means with respect to keys stored in a map. I understand what *stable* means with regards to sorting, and with regards to generation, but what does it mean for a key to be *stable* with respect to a map? Everything else boils down to "limit concurrent modifications" essentially. EDIT [01:39 UTC]: After thinking about it... I think *stable* is referencing the *amount* of keys. So, N - the size of the map - should be stable over time, i.e., not grow. Correct me if I'm wrong. That doc sentence could be made clearer.
My interpretation is that you have a scenario where your map eventually becomes nearly static with how much it's changing relative to inserts/deletes which is why I mention a read heavy scenario or perhaps a bursty scenario where you may experience a lot of updates in a small window of time but then your elements eventually equalize. There's surely a better way to say this...but that's how I understand it.
Stable as in, the keys don't change (much). The content behind those keys can change, but there should be relatively few insertions and deletions. Think of it like this: `sync.Map` separates the key-&gt;thing mapping from a thing that can change its value. Changing the former costs a lot, the latter is cheaper. Example of a great use case for `sync.Map`: you have N worker goroutines each of whose lifetime is at least minutes. You want each to regularly export health metrics, and then publish those in a http handler.
Thats definitely not unheard of though. Another go project, drone ci had a host a great (community contributed) features (vault integration, LDAP, signed secrets) that are being stripped out for the sake of making the commercial offering more attractive. The issue then becomes a trust one, can your company take the risk of staying with upstream when the organisation that controls it is actively stalling development because a PR could maybe potentially affect profits.
I wrap packages all the time. I do this with the hash packages, rand, context, and others to remove things I repeat a lot. So long as you understand you may need to make changes later and don't make that impossible I find it works well and recommend it. Here is an older article I wrote that discussed it a bit more. It might help give you some ideas or even reasons not to listen to me :). https://www.calhoun.io/wrapping-packages-to-isolate-code-responsibility/
Absolutely, you are correct. I've skimmed the source of `sync.Map` and that's the primary use case it's built for. (Which is why I've said before on r/golang that I think `sync.Map` is poorly named, but that's a different story, haha.) I think they should rewrite the docs because it's not clear what stability means in context and it's not a well-defined term with respect to maps or map keys. In my eyes, stability could refer to either: (1) not updating keys' values, i.e., the keys are stable/static/unchanging but the values they refer to change frequently, (2) not inserting/deleting keys, i.e., the keyspace is dynamic/unstable -- as you're referring to, or (3) not increasing the size of the keyspace, i.e., the ratio of inserts:deletes is matched and thus the size of the keyspace remains stable. Ultimately, I feel this is an area of the docs where verbosity is appreciated. Right now, it's a little opaque.
My rule of thumb is that if there is a deficit in my knowledge then it's time to roll up my sleeves and get my hands dirty. This was my way of getting closer to not just being able to explain the sync.Map use case but to also to recognize when and when not to use it. It's part of the standard lib for a reason.
http://json-schema.org/implementations.html#libraries ?
&gt; made me feel proud to be writing Go. Not anymore. Perhaps a bit dramatic?
Actually you don't need any go binding. You should setup nodejs server alonh with go to conpile server side versions of templates, and I would expect nodejs to be the webserver itself. Go or any other language in this case is a separate API server which only ptovides data - not template rendering 
Hey, thanks for the reply mate. Bear with me, I've got a decent knowledge set for most things, but my p2p implementation knowledge is really limited. This ended up being a longer than planned post. It just seems way over complicated for an API. When I think "library" + go, I guess I imagine an API that simplifies everything. I actually couldn't even get that example working, and that is truly due to a lack of trying honestly. I get that it was modularized out of ipfs (great system :D) however I don't see why a metric boat load of imports should exist in the most basic example. That's probably the neck breaking part for me. I can't justify it because I can't find a clear overview that explains each part. That and the fact a simple 'go get' and 'go run' against the example failed. When I say there is a lack of documentation I kind of expect some docs for each package and a doc explaining how and why they tie together. (maybe I missed a page somewhere?) Don't get me wrong, not saying it's bad or good, I literally can't say. I'm aiming for something simplified that can just do some tasks and abstracts the net portion away without a while new way of writing an app. I'm writing a p2p system that does the work while making usage as easy as the http package. I just hope I'm not coding this from scratch and find out what I made already exists, ya know? I do plan to revisit libp2p periodically. Right now it seems that some of what I think is missing doc-wise might be due to how new it really is. Anyway, going to plus your comment because you're providing good deets. I might just need to spend more time learning libp2p and help with it. 
Great article ! Finally it's all clear to me now ! I was thinking whether to use the sync.Map or not. Now its clear that I should probably stay away from it. 
Maybe this video will shed some light https://www.youtube.com/watch?v=C1EtfDnsdDs slide: https://github.com/gophercon/2017-talks/blob/master/lightningtalks/BryanCMills-AnOverviewOfSyncMap/An%20Overview%20of%20sync.Map.pdf
Also, just wanted to kinda follow up and show what I am talking about with getting the package as a whole: [igknighted@server dir]$ go get github.com/libp2p/go-libp2p-conn # github.com/libp2p/go-libp2p-conn ../../github.com/libp2p/go-libp2p-conn/conn.go:90:17: c.maconn.SetDeadline undefined (type transport.Conn has no field or method SetDeadline) ../../github.com/libp2p/go-libp2p-conn/conn.go:93:17: c.maconn.SetReadDeadline undefined (type transport.Conn has no field or method SetReadDeadline) ../../github.com/libp2p/go-libp2p-conn/conn.go:97:17: c.maconn.SetWriteDeadline undefined (type transport.Conn has no field or method SetWriteDeadline) ../../github.com/libp2p/go-libp2p-conn/conn.go:126:2: not enough arguments to return ../../github.com/libp2p/go-libp2p-conn/conn.go:126:17: c.maconn.Read undefined (type transport.Conn has no field or method Read) ../../github.com/libp2p/go-libp2p-conn/conn.go:131:2: not enough arguments to return ../../github.com/libp2p/go-libp2p-conn/conn.go:131:17: c.maconn.Write undefined (type transport.Conn has no field or method Write) ../../github.com/libp2p/go-libp2p-conn/dial.go:121:9: maconn.SetReadDeadline undefined (type transport.Conn has no field or method SetReadDeadline) ../../github.com/libp2p/go-libp2p-conn/dial.go:123:32: cannot use maconn (type transport.Conn) as type io.ReadWriteCloser in argument to multistream.SelectProtoOrFail: transport.Conn does not implement io.ReadWriteCloser (missing Read method) ../../github.com/libp2p/go-libp2p-conn/dial.go:129:9: maconn.SetReadDeadline undefined (type transport.Conn has no field or method SetReadDeadline) ../../github.com/libp2p/go-libp2p-conn/dial.go:129:9: too many errors
These are not bindings to the polymer library. It's written from stretch in go.
[removed]
[removed]
Great article. Thanks for posting it. 
&gt; The weird new licensing is for the official binary distribution only. Yes. That is, why the statement "If you are using Caddy non-commercially, you're done. Nothing changes" is false. It would need *at least* to include an "and are building from source yourself". For people using precompiled binaries from them (as I said) things *are* changing. For people providing precompiled binaries for third-parties (e.g. distributions) things *might* change, depending on the amount of crack-downery the caddy folks are planning to do. &gt; Bit if it did, I guarantee you that they would be building it from source, even without this issue. Including the adware (yes, that term is inflammatory. It's also the correct term for an anti-feature showing ads)? Including their own patches? Will the caddy folks be fine with that? Who knows. * If you are building from source yourself, nothing changes. * If you are using their precompiled binaries, things do change. * If you are providing precompiled binaries for other people, or are using precompiled binaries by a third-party, things *might* change. This last one, FWIW, is really the crux of the matter. If the caddy folk want to keep making money, they will *have* to somewhat aggressively use the EULA/License-hammer they've built (see the whole "wedge" kerfuffle). Meaning the usual "I leave you alone if you leave me alone" mutually assured distruction of non-profit open source licensing starts to crumble in respect to caddy. Meaning some people (that worry about this because they have either too many or no lawyers) might reasonably decide to stay away from the danger. To a degree, at least, there is a chilling effect here. Personally, I tend to try to stay away from distributing/using code by people that are taking this whole Licensing thing too seriously - no matter what the actual license they're giving is. Because IANAL, I have no idea how to judge whether it's okay what I'm doing to that code.
I would imagine linux distros packaging caddy make it easy to install without being bound by the EULA.
Why wouldn't the academic use cover the students?
Did the licence also change? Edit: it seems that minio is not a sponsor anymore, ouch!
&gt; &gt; &gt; and the threats : &gt; &gt; https://github.com/WedgeServer/wedge/issues/2 I see no "threats" there; just a request to rename the stuff to comply with their trademark, which is a reasonable request. I am disapointed so few people in that thread seem to grasp the concept of trademarks...
Excellent write-up, thanks for taking the time to put this together! Methinks `fatih/structtag` should be part of stdlib, any plans there? One question re the post, though: in [this image](https://farslanblog.files.wordpress.com/2017/09/gomodifytags-0012.jpeg) shouldn't the output be `json` tags rather than `xml` or am I missing something?
Thanks! Yeah it should be json and not xml. Let me fix it :) On `structtag` no there are no plans for it on my side. 
If I may ask: why don't you know about your cols? Would it be easier to work something out with 'SHOW COLUMNS' maybe? You can range over your vals slice like this: ``` for _, value := range vals { fmt.Println(value) } ``` but you would need to convert the interface type to a proper type to be able to work with them IMO (depending on what you want to do with the values afterwards). 
[removed]
[removed]
The docs are open source I believe :)
*scratch
I always love seeing people on the Web Components train :D Have you checked out Stencil.js by chance? It's not a library or a framework, it's a compiler like Golymer https://stenciljs.com
Thanks this book explains everything in detail, with very good exercises which are just small enough for Go beginner to play with. I really like this book.
[removed]
If only it wasn't mac only...
I like it. Few question though. 1. What was a general reaction from #grpc ? 2. This is layout only for server ? how about the client, cause they have to have the same proto file isn't it ? 3. why main.go is in a project root dir ? 4. why you have different dir for server and different for cmd ? 5. This entire structure is normally under your $(GOPATH)/src/$(repo_host)/$(your_acc)/$(prj) directory tree ? or those things are not compatible with a "go get" idiom ? 
&gt;Anyway, we're sorry to see Minio go, as we think their team is great and so is their product. Minio stopped supporting Caddy? Seems like they did: https://caddyserver.com/sponsor
Take a look at [sqlx](https://github.com/jmoiron/sqlx), and [it's documentation](http://jmoiron.github.io/sqlx/). Generally, you'd want to scan query results into a structure that matches what you're querying. This would be a minimal (and very much shorter) example, of retrieving a multi-row query result: [github example](https://github.com/titpetric/books/blob/master/api-foundations/chapter6b/main_sqlx.go). The example is from [API Foundations in Go](https://leanpub.com/api-foundations). I'm using davecgh/go-spew to print the output, but you could use something as simple as a loop: for index, row := range databases { fmt.Printf("index %d, value %#v\n", index, row) } I like to use `%#v` here because it doesn't print only the value, but the type of the value as well. Here's a link to the std lib documentation for [Printf parameters](https://golang.org/pkg/fmt/#hdr-Printing). p.s. it's good you're learning go and very ambitious that you started with MySQL right away. But maybe you'll want to know about some more basic things so you get a feel for the programming language itself, before you try applying it to real world use cases. A good place to start and get a more complete experience is [Go by example](https://gobyexample.com).
&gt; it seems that minio is not a sponsor anymore, ouch! The author generated controversy with that absurd monetization model. It's well deserved I think.
yeeeh! It's a great book of programming **in general**, you don't need anything else, the rest is not funny.
At least for `chi` I know that https://github.com/disintegration/bebop project uses it. There must be a lot of projects using `gin`. Go to https://godoc.org/ Search for `chi` or `gin`, then navigate to the documentation of the package. For example https://godoc.org/github.com/go-chi/chi for `chi` package. Now scroll all the way down and find a single link that leads to list of packages that import this package. That's a starting point for further research. 
Note that it says "keys that are stable over time", not that values should be stable. Just having the map size be stable isn't the same as keys being stable. 
Check out https://github.com/mitchellh/mapstructure See ErrorUnused or the Metadata
poetic is in their name
I know, but I personally don't feel this is worth migrating to a completely new project over. Matt has a long history of being incredibly generous and has given a ton to the OS community in terms of dev time, support, etc. Even if I completely disagree with this change and thought it was a mistake, I believe Matt deserves our patience while they figure out a way to make Caddy sustainable long term. I have no proof that whoever forked caddy into wedge will support it long term. He/she just happens to be the first person to fork it after the announcement and start advertising it. It is just as likely that Wedge is maintained for a few months then stops getting proper attention. On the other hand, Matt has been doing support, updates, etc for quite some time now. There is clear evidence that he will continue doing an awesome job at it. I would rather work with him through this than jump ship to a project that could be effectively unmaintained in a few weeks. I also feel that we as a community of developers often act hastily and irrationally in situations like this. Everyone appears to disagree with the changes and the pricing, but nobody has presented a viable alternative, and as far as I can tell continuing as things were isn't that answer - it didn't provide enough money for caddy to be properly maintained and supported. Forking won't fix that long term, it just means someone new is required to maintain a project for free until they get burnt out and try to monetize it or just go AWOL.
Yes, many json libs offer a way to mark fields as required.
Well, they did try to notify the sponsors to check for concerns, they just did so in a silly way.
Yes! This is exactly what I was looking for, thanks!
You can try: https://github.com/casbin/casbin
Terms of Service does not override law, and that you allow people to fork stuff does not mean you waive any and all intellectual property rights. I'm fairly sure that you will lose this should it go to court ;-)
[removed]
The fork is not a _real_ fork though as commits in the Caddy repo will be merged in Wedge. It's not like the Wedge dev will maintain it. He'll just provide builds without the header. Though, Matt has decided to remove the header in Caddy itself.
Thank you