Your project uses a group-by-kind package structure. See this article for some other anti-patterns: [Idiomatic Go](https://about.sourcegraph.com/go/idiomatic-go/) &gt;Key takeaways: &gt; &gt;Package names have semantic meaning. &gt; &gt;Package names should describe the purpose of the package, not it’s contents. &gt; &gt;The only part of the package import path that matters is the right most name. &gt; &gt;util/helpers says nothing about the purpose of a package beyond a grouping of bits. I am working on a similar web api project; you can see the package structure here: [arkavo-com/secure-rest-server](https://github.com/arkavo-com/secure-rest-server])
Don't mind the downvotes. This thread is being targeted by the usual obnoxious basement dwellers at pcj: [https://www.reddit.com/r/programmingcirclejerk/comments/8zzojj/im\_in\_love\_with\_go\_literally\_3/e2mw2ip](https://www.reddit.com/r/programmingcirclejerk/comments/8zzojj/im_in_love_with_go_literally_3/e2mw2ip) It physically pains them when people enjoy Go.
&gt; code that isn't the same in vs. out of production What isn't the same though? This is a test, it shouldn't make it into production code. If the check has side effects that actually change runtime behavior, that is not at all a good thing.
What a great indicator of a missing compiler feature!
What a great indicator of a missing compiler feature!
I think interface can do that job!! I've used interface a lot as generics. I didn't find it difficult at all. Am I missing something?
You must live in one of the most expensive metro regions in the US.
I developed it as a bot to run in Stride from Atlassian (a HipChat replacement): [https://bitbucket.org/hackworks/psyche](https://bitbucket.org/hackworks/psyche) The idea was to add new features in the plugin directory. The code is rough since I implemented the whole thing in \~1.5 days (some minor cleanup later).
Wow, the cost of living at all three of these locations is insane. I'd love the opportunity, but the housing costs alone are a show stopper.
Reinventing the wheel is a term which I hate the most. I know some things should be in hands of experts like cryptography, DSA implementations, garbage collection etc. but other things on application layer should always be experimented with. There are so many people who have better libraries than the official ones. People should stop using this term way too much unnecessarily.
Google pays well enough to make it worth it financially, but living near Sunnyvale is terribly boring, you're stuck in suburban hell.
I'm a software engineer with 30 years of experience, I know and I worked with many languages, OO, Functional, Imperative, whatever. As much as I would love to like Go, I'm having a very hard time enjoying it, it's just boring to me. I'm now learning Haskell (for fun) and I find this language so profound and interesting then when I need to go back to Go for my daily job it's just not fun at all. I would love to hear why you guys love this language so much.
What you're looking for is called books.
Interfaces can't replace generics - an interface still has specific types. Imagine trying to write a go library that would let a user create a set (ie a list which never contains duplicates) of any type they like in the same way that you can make an array of any type in Go. Put simply: you can't. There's no way in Go to express a non-concrete type that might theoretically looks something like this if Go did support generics: type Set&lt;A&gt; interface { add(element A) remove(element A) contains(element A) bool } Where `A` is an intentionally nonspecific type, but anybody that implements the interface for any specific type (say: something implements all the right stuff for `string`) would have implemented a specific form of that interface. (Like, say, `Set&lt;string&gt;` would be the interface for the case of `A = string`, but other code could still implement `Set&lt;float64&gt;` or `Set&lt;byte&gt;` or whatever.)
I think these things mostly depend on your work. Go is really amazing for web development and microservices. Since its syntax is really easy like python, it can also be used at many other go to applications. With easy concurrency, it can also be used in network related applications.
Are these still the "generic" style interviews where your chances of passing are slim to none unless you've practiced 300 interview questions and can do dynamic programming questions in your sleep?
It's not supposed to be fun or interesting. It's supposed to be simple and boring. Get you rjollies.in the problems you solve not the way you solve them. (Says an unlikely advocate for Go, given my history...)
are these so called books offering bootcamps?
I'm using go in my twitch chat bot project. https://silhub.com Works pretty good And code seems readable for me
I'm using go in my twitch chat bot project. https://silhub.com Works pretty good And code seems readable for me
This check has no side effects. It's completely benign.
&gt; too bad i'm a secondrater and would never qualify There is no downside to applying (except ~3h of time).
[removed]
Last (and only) time I interviewed, the interviewers and/or their process seemed more concerned about how much you remembered from your CS classes. I decided I wasn't interested in the job if they weren't interested in professional growth and feet-on-the-ground problem solving. Don't get me wrong... I'd love to work with those guys, but the door trolls and I don't get along. 
The single main problem with this approach is that it's written by a JavaScript programmer dipping their toes into Go for the first time. Sure, the expected knee-jerk reaction to not having futures in this language is to go and add them ;-) The problem with this, is that no production Go code (and I mean _production_ code in systems like [k8s](https://k8s.io), [juju](https://jujucharms.com/), [upspin](https://upspin.io) and so forth) uses them. That's because this approach is not natural to Go. To understand why Go does not need furures or anything like this, please read [this classic essay](http://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/). To see your implementation in context, please watch [this short and fun talk by Blake Miserany](https://www.youtube.com/watch?v=yi5A3cK1LNA). ---- Of course, no one will prohibit you from using this approach in your own projects, but expect hard time attempting to using it in the projects of others ;-)
Yes, the compiler discards it. I always put these kind of compile time checks into the \`\_test.go\` files because IMHO they are tests and do not belong into the final binary. You can still say in the comment that type X implements Y.
You aren't literally *stuck* here, but it can start to feel that way unless you put in your own self-motivated effort to travel around. Unlike Los Angeles, the cities here don't sprawl together and they each feel like a separate real small town with something of their own character and ambiance. Much like Los Angeles, it can still take significant travel time to get to any of those other areas. Once you get to SF proper - and north across the Golden Gate - it's like entering a different world. 
Not every "library-ish" package needs to actively log, most shouldn't.. but if you're sure gojsonq should offer logging, why not _either_ have your minimalist logger interface exposed _or_ expose 2 func-typed vars for `Info` and `Err` (or more levels, or 1-for-all-levels) that default to no-op --- both approaches allowing users to hook-up/wire-in their own favourite/current logging infra (whether it's logrus they're in love with last month, zerolog this month, or someotherlog next month).
Good point, I shall add tests. Thanks sir
[removed]
I was talking about everyday life. The bay area bores me, I like city life, even SF is just not that much fun for me for a number of reasons. I've been to most of the US, I've lived on both coasts and in the Midwest. Please note these statements are very much opinions, the bay area is not for me personally. I'll be moving on eventually, I'm just doing it in a smart way.
I have tried [https://github.com/kitech/qt.go](https://github.com/kitech/qt.go) , with desktop and android support. And used about 1,000+ widgets. [https://github.com/envsh/tox-homeserver/tree/master/qofia-ffi](https://github.com/envsh/tox-homeserver/tree/master/qofia-ffi) Seems usable for this case.
Imagine you have an in-mem 'storage' service (or aspect) in your distributed-system, but now the "need" (real or perceived or imposed) comes up to have it run as multiple-instances (for scaling or fallover or why-ever). Raft algo is one (promising, popular, seemingly-proven-ish, etcd-popularized) that lets them synchronize each other robustly for consistency.
I have been doing software 30 years too. I also like learning every languages. Go is fun too me, because it is simple and fast, easy to express ideas in it. Go is not like C++ which is big and complicated, I love it too but it is like weightlifting when I use it. Go is also not like Haskell (or other funtional language), which I love too but it is like another weightlifting to write code in it.
Lack of remote option means terribly wrong processes at work. Red flag.
I blame node
The compiler/runtime position in Cambridge has me **ROCK HARD** right now. Too bad I live in SF :-(... actually all of the positions look incredible.
Is it compatible with neovim?
Most of it is, yes.
What's easy syntax? If you mean simple syntax, then Go isn't really simple, I'd say it's average. If you want a good example for simple syntax look at a Lisp. 
Well if you have been doing actual programming work instead of taking cs classes in the last decade you might need more than that to practice generic algorithm questions. 
In general I'd say Python would be more appropriate for *playing* with bots..
To be fair, working on a compiler and language standard library uses a hell of a lot that is taught in a 4 year undergrad CS program. It makes a lot more sense than hiring overqualified coders for proto-to-proto jobs
To get a nice API, it is common practice to misuse variadic arguments like this: This s a blatant lie if I ever saw one
https://godoc.org/google.golang.org/grpc/metadata#Pairs
 type KV map[string]interface{} Method(KV{"age", 12, "location", "NYC"}) good enough for me
Leaving aside whether this (admittedly popular) opinion reflects the truth: No one says you have to "practice generic algorithm questions". It might or might not increase your chances, but there is still no downside to applying even if you don't. On the contrary, I'd probably argue that you *don't* want to have a job if you need to specifically prepare for the interview. The point of the interview process is to check whether you're able to do your job. No one is helped if you can not do your job but fake your way through the interview by artificially inflating your abilities. You have to spend a couple hours to send in your CV and do a phone screen and you *might* have to spend a day doing onsite-interviews. Anything more is completely optional.
If you would love to work with those guys then just go ahead and study up on the fundamentals behind software maybe?
It can be better to make Retriable an interface, it will allow users to throw their own errors that implements it. Like that: https://play.golang.org/p/hg_tfWJWa93
Last time I talked to a google recruiter for emea he mentioned it was heavy on algo and ds and that I was required to do at least an itw in java. He was very nice in giving me extra time so i could learn the language before hand. I said no thanks.
Not that I'm dismissing your argument of _common_, I find it funny that I often use gRPC as a benchmark of what I should *avoid* lol. Their APIs tend to feel non-idiomatic, awkward and generally bad. The protobuf generated code from gRPC is especially "wtf" worthy.
Lol yeah :) it has so many ugly things in it. Abuse of the abuse on top of abuse.
In addition to ensuring the object on the right hand side conforms to the interface on the left hand side, I've also seen the same pattern used to keep an import "sticky" inside a go file during development, even if it's not needed, like: ``` import ( "errors" ) var _ = errors.New ``` in this case, you don't need to comment out the import when you're refactoring code here. It's also comfy when it comes to vendor-ing, because you know that some third party import might need to be included, even if it's currently not in use (developer dependencies, mostly). 
Yes, as per usual with big tech companies. It's a convenient way to filter in only recent CS grads.
I have seen this in a couple occasions but I consider this unidiomatic and bad api-design as makes implicit assumptions and undermines typesafty.
What this proposal should be really about: is
It helps me focus on the task to solve and get the job done. I'm way more productive than with languages like Java or C++ (for "traditional" ones) or with rust or haskell (for "fun" ones), because of the lack of ceremony and of the time you don't spend time wondering "what is the best abstraction I could use here". Python is even more productive, but it is often too slow and too dynamic. Go hits a sweet spot for me, regarding speed (fast enough 90% of the time) and type safety (typing almost never gets in your way for too long, but it still helps you when you refactor big / old code). When no other obvious factor is involved (an already existing codebase or mature libraries existing only in one language, for instance), I'm mainly using python when I don't care about speed and want a working prototype fast, c++ or rust when I need as much power as possible, and go in the other cases. Plus being able to compile and deploy executables for a different architecture in a heartbeat is pretty cool. I hate it when I have to configure a server for like hours, and fight with admins in the process, just to be able to make my program available to others.
I'd say a syntax is easy when you read a program in a language you don't know and pretty much understand what's happening.
Well, one needs to keep in mind that Go is, first and foremost, a corporate language, and this stays true no matter how much hipster hype and vague UNIX-esque nostalgia piles up around it. It was designed for purposes of a large corporation, one of the most important of which is the ability to hire faster and cheaper. People tend to forget this. In my mind (oh boy are gophers gonna hate this) Go is very very similar to early Java: - Designed by a corporation mostly for corporate purposes (as already mentioned) - Focus on mild learning curve (for easier hiring and proselytization) - Disregard for abstractions, pushes for design patterns instead - Doesn't enable or discourages customizations, pushes for unification of code - Aggressive PR, to the point of propaganda The only major difference from Java to me is that Go is compiled to native and has built-in coroutines. That's about it. The absence of OOP isn't much of a difference to me given how crazy Go is about interfaces and how crazy interface and struct implementation is (typed nil, multiple embedding, interface embedding). In any case, you can't really expect Go to be an exciting language just like Java wasn't for most of its prime time... 
&gt; It's not supposed to be fun or interesting. This. Why do people expect languages to be 'fun'? A good language is the one that gets the job done. A language that is both fun and gets the job done in production may not even be possible to exist. If you want to have fun go watch a movie, or try to widen your sexual horizons.
I think this is my favorite summary of why I'm not in love. With Go: &gt; Go is famously simple - there are anecdotes of people picking it up quickly. However, that becomes problematic as time goes by; Go code is hopelessly pedestrian - Go coders find themselves writing again and again the same things from an ant's vantage point because Go cannot abstract even the simplest notions or algorithms. Domains that are not already served by easy to glue libraries are difficult to get into. There is backlash from coders who have used Go for one project and wouldn't want to ever use it again. It would be great if Go made life better for repeat customers Andrei Alexandrescu (https://www.quora.com/Which-language-has-the-brightest-future-in-replacement-of-C-between-D-Go-and-Rust-And-Why)
Fwiw, I think the negativity on the idea of variadic maps is unfair. Variadic functions seem to be just as implicit as a proposed variadic map. It seems to me that if variadic functions are idiomatic, variadic maps are not unreasonable. With that said, the syntax in this post is awkward and I dislike it.
I'd take a slightly different tack. Given func X(map[string]interface{}) { ... } why is it not possible to allow a call of the form X({"a": 1, "b": "hello"}) Go allows a very select number of places to elide the type where it is unambiguous, but I haven't been able to figure out why that doesn't work in more places, and I find myself often not using this feature because remembering where it is allowed and where it isn't is a lot of cognitive effort for me. So is there some case I'm missing in my head where that call to X is somehow ambiguous, or there's a particular type it could take where it is ambiguous? Otherwise, there's several places, such as function call sites, where I could get some mileage out of Go allowing me to elide unambiguous types and inline construct a {} as if the type was there. In passing, that would solve this problem.
Man, idk. Ricky and Bubbles seem like they would be a hell of a lot of fun.
So, what does something like https://godoc.org/github.com/deckarep/golang-set not do that you’re looking for?
it's not typed at compile time. So it's not.
Just pushed some tests, do they look correct please?
[removed]
I think this metric is only relevant if you don't use the language a lot (like few times per year or so). It's basically, "How similar this new language's syntax to other languages I know" + "Do I already know the paradigms used?" And here I think the second part is more important. Picking up a new syntax is at most a few days. Learning a new paradigm is closer to a few months. (The third part would be library knowledge, but that's a bit more orthogonal to this topic) Sure many people has a background of C-like imperative languages, but that also means that Go is relatively similar to most of the languages from this aspect, thus being average on this front. Another interpretation I can imagine is "easy to use" syntax. I think this metric is more useful, if you use a language regularly. I'd call a syntax "easy to use" if there are no annoying things in it. For example: mandatory semicolons, lack of type inference in a typed language, mandatory return statement. And probably a few other (more subjective) things, in the categories of "_I have to type this useless thing every time, but sometimes I forget it and then it annoying_" and "_Do I really need to type this every time?_" Go does decently here, somewhat worse than some more modern languages like Scala, Kotlin, Clojure or Haskell, but it's better than the older mainstream languages (eg.: Java, C). 
I use it with nvim. I don't use most of the features of vim-go, but I haven't run into an issue yet. 
&gt; it's just boring to me That's exactly why I like it. I spend less time trying to find clever ways of doing something for future proofing and just do it. It also has pretty good readability. Even though it makes the code look a bit cluttered sometimes, I prefer handling errors vs throwing exceptions. And I love compiling something to a single native binary (I've had so many deployment issues over the years with Java, C#, and Ruby)
I just use this https://documentation.help/Golang/FAQ.html But I tend to collect links. https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk 
&gt; That's exactly why I like it. Well, I think we have two very different perspective on writing software and solve problem in general, that's totally fine, but I personally prefer the "clever way" than brute force. 
Thanks, these are very good reasons, even if I don't agree when you talk about haskell or lisp style languages as too "verbose" or they have too much "ceremony": It's just a very different way of thinking about problem solving. But eventually it all depends on what you need to accomplish and the requirements, and I think Go it's a good language in some context, for example embedded system and micro services. I woudn't say Go is a great language for everything though, just my personal opinion.
What is an itw?
I got your point, compared to C++ or even C it's definitely nicer, It's probably not very useful to compare it to Haskell or any functional languages, but that's not the point anyway. I don't want to compare it with anything else, I'm just trying to understand why some people loves it so much, and I think I'm starting to form an idea: please don't get me wrong when I say this but I think that Go is more for Artisan style developers, they have a job to do and they do it without too much hassle, Haskell is more for Artist style developers, they want to see beauty and elegance in the code, not only a fast executable, even if it takes longer doesn't matter, the journey is more important that the final destination :) 
I agree with you about web development and (small) microservices, Go has some very nice features that makes it perfect for this kind of things, even for embedded systems for example. The project that I'm working on is a ETL layer, it started "simple", with simple concept and now it's becoming a micro DSL. The code is not DRY, there is a lot of verbosity and the code base is big. Overall I think that for this project a language like Clojure or even Haskell would be way more productive, because you are de facto building an abstraction layer, and Go is not great on building abstractions.
Good for you! 
[removed]
This may depend on your relationship with your employer, but I would look at what are the reasons "you" would pay out of pocket to go to the conference. I was self employed when the first Gophercon happened and paid it out of pocket (granted it was much cheaper than now), my reason was: I wanted to connect with other gophers and see/learn how they were using Go at work. At the time, I wasn't using Go with my clients but wanted to see how it would fit. And it was a good investment, I got to see very good presentations (but now you can watch them online after a few weeks/months), and I made some contacts for future reference. Maybe post here your reasons, and then we can help you better present them to your employer.
Didn't you show him the mascot? 
Idk if the simplicity is in the syntax so much as in other aspects of the language. I find it easy/simple in a sense of 1. being a tiny and somewhat restricted language, meaning there aren't that many different ways of going about things 2. uniform formatting throughout the community, virtually all go code is formatted in the same way 3. it has a very high quality standard library, meaning most go devs are working with/familiar with the same tools
Would be interesting to add this to CoreDNS, you could leverage so many other things. And this would make CoreDNS perhaps a daemon folks would use on their laptops in addition to servers :)
One word: recruiting
Having some pretty intense CPU usage running this to tokenize text for detecting conjunctions. Have you seen this before?
Haskell is what I would like to use for my personal projects I don't care if anybody else has to read my code, or if it is _guaranteed_ that only other fairly smart programmers are going to be reading my code. Go is my current favorite choice for programming in an environment in which I am professionally obligated to leave code behind that can be understood by other people. It has very close to the right balance between power and comprehensibility for that environment. While I may not be able to convince you to "love" Go after learning Haskell, I will say my experiences with Haskell are part of the reason I am so comfortable with Go. Haskell is an exercise in learning how to program with a very restricted set of primitives, and squeezing everything you can out of them. Go actually has a very similar philosophy; it does not have all that many features, really, and you are expected to squeeze everything you can out of them. Pretty much none of the manifestations of that in Haskell translate directly into Go, but the _mindset_ does. (Including the mindset of, at times, saying "this can not be elegantly expressed in this language and I'm going to give up and take a completely different approach with the tools I actually have", i.e., in Haskell, you _can_ write imperative code but you learn not to because it is not elegant, in Go you learn that while you _can_ write inheritance based code you're _way_ better off using interfaces and perhaps some composition, etc. If you take the part of the Haskell mindset that says that sometimes you need to bend to the language a bit back to Go, you may be happier in Go, too.) Using Haskell can also train you in patterns of usage of variables and mutability that will also serve you well in Go, since as a shared-memory language, you can still get in lots of trouble in Go if you are not careful. In my case, I had several years of Erlang experience, and, again, while Go is not Erlang, the patterns I learned have served me very well in writing Go without the safety rails.
My personal reasons are to get more exposure to the community and find ways to push Go inside my organization. We have some major refactors coming up that Go could be a great fit for. Also getting a deeper knowledge of the language and people behind Docker and Kubernetes is a goal.
I hate that kind of questions too, but for this exact job description, strong data structure knowledge matters. The more talented Go people they hired, the sooner I get generics :D
After writing in Clojure for many years, I too find the simplicity of Go very refreshing. There's often just a few reasonable ways to write something, compared to dozens and dozens in a very clever language like Clojure. While I initially enjoyed the challenge of writing concise code in Clojure, or writing neat abstractions, these days I'd just rather get functioning code done quickly. Not having to consider an enormous space of possible ways to write things really helps focus on the task at hand. I also like that performance is somewhat more predictable. It's so crushing to write great code in Clojure, then realize that you need to optimize it for performance, and after that is done ending up with something that looks more like Java in Clojure than actual beautiful code.
Not use the `interface{}` pseudo-type which pushes a lot of work that would otherwise be compile time on to the runtime, and precludes strict typing. That package doesn't allow you to make a set of strings *and only strings*, and it doesn't allow you to make a binary which includes the optimizations possible for a set that will only ever contain strings. With full generics declaring something as a `Set&lt;string&gt;` would allow the compiler to recognize this is an error for example. s.Add("string one") s.Add("string two") s.Add(10)
Anyone who downvoted this just because they don't like the proposal needs to understand what a complete and utter fucking scumbag they are.
Any idea how it compares to https://github.com/ericlagergren/decimal ?
Performance is a great point for sure, I'm not sell on the Java-style Clojure code because I never had the need to use java interop too much, but my real word experience with the language is limited. From my perspective I'm still very much in love with it, but I have to agree with you that if you want something done quickly why bother using additional mental cycles. 99% of the building don't need Renzo Piano, they will be flat looking and boring eventually, but people can live inside anyway.
&gt;I'd probably argue that you don't want to have a job if you need to specifically prepare for the interview. The point of the interview process is to check whether you're able to do your job. This. Additionally, mid to mid/sr level jobs are hard to come by. I mostly see sr, and occasionally jr. What's with the polarity?
Go may be bad, but every other language manages to be even worse. I don't even use Go for networked services, which everybody seems to agree is its forte. What I really want is something like SML with a respectable developer community and tooling that is actually good.
That's great point, it's so true that learning languages like Haskell or a Lisp make you a better developer, because they force you to think in a different (and something harder) way. You are more comfortable with Go now because you learned and used Haskell and Erlang, and you can use your improved mindset with whatever language you use, including Go. From my limited experience with Haskell I can say that I love how you model the problem using the type system, it just makes me realize how easily a problem can be solved if you think of it that way: I was blown away when I saw the QuickSort implementation in Haskell, just beautiful and when you know Haskell, so simple to read. I know that many people don't care about beauty and elegance in their code but I do, and I find Haskell to be one of the most elegant language out there.
You could point to vgo and how it is going to become the future. I'm sure that there is going to be talks related to it. That said, I went to Gophercon a few years ago and didn't receive as much value as I expected from it. It was single-track back then, and I was not happy when multiple speakers said "I didn't have enough time to prepare my talk".
thanks for the feedback -- would you go with dark theme and all white text, all white background with black text, or something else? 
Interesting. I wasn't aware of that - I'll make some changes over the next few days.
Thanks for the feedback. Is it the fonts themselves, the spacing, contrast?
Thanks, appreciate the feedback. I'll take all this into account when making edits. 
Thanks, do you mind if I go through this list and add it to the article?
Thanks, I was thinking that might be the case. Something like a wiki ToC?
Thanks, I really had no idea that Golang was a slang term -- good stuff to know. I'll be making those changes over the next few days.
Haven't tested it, but would something like this work? func Get16Bit(img *image.RGBA) []byte { buf := new(bytes.Buffer) for p := 0; p &lt; len(img.Pix); p += 4 { buf.Write([]byte{ img.Pix[p] &gt;&gt; 3 &lt;&lt; 3, img.Pix[p+1] &gt;&gt; 3 &lt;&lt; 3, img.Pix[p+2] &gt;&gt; 3 &lt;&lt; 3, }) } return buf.Bytes() }
For Andrei Alexandrescu (who is notorious for his C++ work and, formerly, for being one of the D developers) Go is definitely on the other side of his views and beliefs about where programming languages should evolve. I dare to say Go is a rival, and much more successful, so his bias is more than justified and obvious. I also really doubt he was writing real-world Go programs (that solve problems, and not expose biases). This quote is full of desperate statement and I fail to see how it can summarize real-world experience with Go.
Why would anyone after 30 years of experience want to have "fun" language? I always thought that experience is a major factor for appreciation of simplicity and pragmatism in the languages.
I'm doing Go on daily basis for 5 years now, and I can tell you than this feeling "holy s..., this is exactly what I was looking in the programming languages, it's great and makes me bloody productive" hasn't gone, only intensified. I still have fun programming every day in Go, and really hope other languages and frameworks will pickup the core principles that made Go such a beast. So, welcome to the club.
Why would you only want recent CS grads? Aren't experienced developers more valuable?
&gt; itw A weird abbreviation for interview maybe?
There are a lot of other languages that are simple, pragmatic and also fun in my opinion, why sacrifice the fun part?
Experienced developers usually expect better pay, and they usually have families so they usually expect (and use) health benefits and looser working hours.
I've worked with Go for about a year now and still feel this quote embodies all my frustrations with the language. If you want proof, just look at the abomination that is the standard heap implementation: https://golang.org/pkg/container/heap/.
Thanks, but unfortunately it seems to save the bmp as a 32 bit
Experience developers are harder to abuse
As others have said, one of the main reasons I enjoy working with Go is because it allows me to solve complex problems, with simple solutions, faster than I have with other languages, and the product at the end is also usually extremely quick and reliable too. It is pretty "vanilla", but I've also got experience with languages like Scala. I did enjoy Scala a lot, and it's type system is extremely impressive, but it was too smart, there were too many ways to do things, too many abstractions. I like Go because it's not any of those things, I write code, it's easy for me to follow, easy for others to follow, consistent in style (definitely unlike Scala, and many other languages), and just generally lets me focus on the problem at hand, rather than battling with the language. That's not to say I think languages like Scala are bad by any means, I did enjoy working with Scala a lot. If I wanted to push myself in a different way, I'd look back towards something like Scala or Haskell because they're a challenge to work with, and very interesting. That's just not what I want from my daily workhorse language, or my personal "get shit done language".
I do have experience with Scala to and I feel your pain, it's so unopinionated and the type system is very complex and not user friendly, that you end up fighting with the type system all the time. I do not have this problem with Haskell though (but I have a much more limited experience with it), even if it's even more strict than Scala, it just makes sense to me. I picked up Go in no time, it's an easy language, no doubt, but also so plain and flat that I really had no aha moments, nothing to explore (expect the jungle of libraries), nothing that actually make me enjoy the journey of learning something new. Get shit done? Sure. Bored after one hour? Unfortunately yes. I think it's more a personal choice: if I have the possibility to learn something exiting and become a better developer/engineer, if necessary I would almost always choose the hard route over the plain one. I think that eventually it will pay out much more. 
So I should move my controllers into appropriate packages like `authentication` and have the functions named like `package.NewHandler()` Or should I just *skip* the object-instance design and just have package wide methods (which seems like bad design, but might just be me)
Of course, I'm one of those people who need a list and that's just how my brain works lol So I always share the link online and friends and tell them to take it and remake your own and always share. Which i believe you will so good. But yeah go through it, some are not up to date and well my example is proving a point but... It's not good practice like this. https://play.golang.org/p/IA09xBX7dYF It's sorta a play on types but you really shouldn't code that way. Kinda defeats the point. But yeah share away cause it's other people's work in those links. 
Have you ever looked into the interview process for Google, Facebook, Microsoft etc? They use generic CS class type algorithm questions in their first set of interviews and only want more applied coding in their last phase. Your argument about what *should* be done is a bit detached from the reality of what IS being done. &gt;You have to spend a couple hours to send in your CV and do a phone screen and you might have to spend a day doing onsite-interviews. Anything more is completely optiona You don't do an on site interview if you can't do generic code challenge type algorithms in the over the phone code interview.
Something like that. At the very least, an at-a-glance list of questions with anchor tags taking you to them.
This proposal is not awesome, but [this one](https://github.com/golang/go/issues/26459) which was linked in the comments solves the same problem in a much more elegant way. Most of the negative voices in that thread seem to have misunderstood the subltler points of the proposal. There certainly are some readability concerns, and more study is warranted, but I wouldn't be surprised if this were adopted for Go2. It seems very much in line with the type inference we already do with `:=` and constants. 
[removed]
Have you actually interviewed with a company like Google? Because unless you know someone on the inside who's put in the good word for you, prepare for idiotic bit-twiddling trivia and other "quiz" type questions which might not come up for 99/100 programmers out there even once in their careers. There's a reason books like "Cracking the Coding Interview" exist out there and sell well. That's my information from people who've interviewed with Google/FB and the like. 
jr programmers can be "molded" to fit the corporate culture. They don't know any better. I happen to know of a company I won't name where "standard dev practice" for certain teams is to ssh into a server and do your coding in a vim session for "security" reasons. If you're a starry-eyed college grad, you'll just accept that as "normal" and never question it. If you've had more than 1 year of experience, you'll laugh in their faces and find another job. 
black text on white background. You can always have it configurable.
Oh, I did, for two years, I hear you loud and clear, but again that's not a language contest that I'm looking for here
&gt; Have you actually interviewed with a company like Google? Yes. &gt; which might not come up for 99/100 programmers out there even once in their careers. We have different opinions on this. I use algorithmic thinking on the level required for these interviews (which is pretty basic IMO, it comes down to things like "do you know how and when to use a hash table" and "can you look at a function and count nested loops") on a daily basis. YMMV. I also don't think it's very important for this thread though, which is about whether or not there are any downsides to applying. Again, to re-emphasize: Even *if* you believe you should spend additional time learning the skills tested in the interview, you don't have to and even if you don't, the worst outcome is a couple of hours for the interviews and having to stomach a "no". People tend to not apply for fear of rejection. But I don't think that's a good reason not to apply. Not only are you likely underestimating your own abilities, you also have nothing to lose. If there's a job you'd like, go ahead and apply and leave it to other people to judge your ability to do so - if for no other reason than not wanting to do their job for them.
I hadn't seen that classic essay before. That's a great post!
&gt; Have you ever looked into the interview process for Google, Facebook, Microsoft etc? Yes. &gt; Your argument about what should be done is a bit detached from the reality of what IS being done. We disagree here. What you call "generic CS class type algorithm questions", I call "essential job skill tests". YMMV. But also, see [this](https://www.reddit.com/r/golang/comments/8zzinh/the_go_team_at_google_is_hiring/e2ow3o2/). I don't think it actually matters for the discussion at hand.
yes.
Sounds like they are discriminating against people with autism.
So, how much load does it balance?
Good luck dude. We use docker extensively and I couldn't even get them to send me to dockercon. 
For me the end result is the thing that I enjoy, with Go I feel I can reach it much faster and make it run like a quick and safe. Yes, the language itself is boring, but that's a good thing in my opinion, maybe I just have a complete different mindset.
Yeah, it is more flexible to use Retriable as an interface, and it is simple to use it as a type. You can throw your own errors like this: retry.Ensure(context.TODO(), func()error{ return Retriable(YouOwnError()) })
yes on appropriate packages See this article on functions (referred as package wide) vs methods. [Go Best Practices: Should you use a method or a function?](https://flaviocopes.com/golang-methods-or-functions/)
Yes! I love this. Same with arrays please. 
I convinced my previous employer to send me because they were an all Java shop and the key of the pitch was “when all you have is a hammer, everything is an all- we use java in many places where other languages, like Go, would be more suitable... broadening our exposure to other tech will help us choose the right tool for the job” Of course, I left before I could go and joined a Go shop that is “obviously” sending me to Gophercon, but that is neither here nor there :) but I had my manager’s buy in based on the above.
I don't know why so many people praise the use of "interface{}". It is a terrible thing to put in your code. It's like using a void* in C. You lose the ability to keep track of your types! Empty interfaces are not solutions, they are symptoms of a huge limitation. Apache Beam (used to build data pipelines) recently launched their Go SDK, and it has a big problem because Go doesn't have generics. In Java, for example, you use generics to specify what is passing through your pipeline: Is it PCollection&lt;String&gt;? Is it PCollection&lt;KV&lt;Customer, Number&gt;&gt;? With this you can keep track of how your data mutates in your pipeline and make sure all stages in will fit together perfectly. Since Go doesn't have generics, they had to use "interface{}" for the data type. Despite Go being typed, the type of your pipeline is just "PCollection" - totally useless. What is passing inside your pipeline is simply unknown. More information: https://docs.google.com/document/d/1yj0_hxq2J1iestjFUUrm_BVQLsFxQiiqtcFhgodzIgM/edit#heading=h.mgr8mrx81tnc
thanks, that may actually help. It is more my boss's boss that is giving the push back. He is a business guy... 
Tokenization is very regexp-heavy at the moment (a product of porting the Treebank tokenizer). I'm actually currently working on making this more efficient -- you can track the progress on the [itertok](https://github.com/jdkato/prose/tree/feat/itertok) branch.
Currently we don't have a benchmark test, but coming soon
Awesome! If you'd like the cpu profiles I took let me know. It was extremely easy to implement which we loved, just almost crashed some VMs after a few requests. 
Hmm perhaps focus on the business reasons why Go can be more suitable than Java? Depending on your industry, this might be performance, or cost savings via lower resource usage, or something else. Good luck!
A CoreDNS based alternative to this is Cloudflare's cloudflared - https://github.com/cloudflare/cloudflared
Why would I use this instead of something like traefik?
I want to make a lightweight load balancer with scalability and easy to customize. Traefik is more like one API gateway, GoLB focus on LB.
Dependency injection for injecting structs implementation without passing it to each class.
Exactly this is what i am doing, everything has interface with concrete implementation. DI helps in getting object without passing it everywhere while creating object from struct. I tried this : https://github.com/facebookgo/inject and found it interesting. Although this can be easily solved, was just looking for this to remove clutter.
Did you mean this? https://github.com/golang/go/issues/12854
Note that this now has modules support. :) Please try it out and file bugs.
Oops, yeah. Updating my previous post.
Check out https://github.com/golang/go/issues/12854 It's basically what you're suggesting.
I always mix up 'modules' with plugins, for me it's sort of the same. I don't know why. I find the naming here confusing and not "simple". Or what's the logic differentiation? Thanks for explaining
Yeah, someone linked to that on the proposal here too. It has the answer to the question I asked, which is nice. I can see why they cut this during development, but I think a reconsider is worth doing.
Agreed
haha, i am also adding [github.com/noypi/redux](https://github.com/noypi/redux) using combineReducers (still working on some ideas to be added to go). =)
This comment is quite generic but i would like to applaud this update and especially around the wasm stuff. 
How about this: An application is made of `modules`. `plugins` provide additional functionality to the application and can be removed without effect the main feature of it.
When I wrote "ceremony" and "verbosity", I thought about java and c++. My problem with Haskell (and lisp) is thhat I tend to abstract way too much (because it's fun to do) and that leads to code that is harder to understand, and as a consequence harder to maintain, ironically. No, sure, go is far from being a great language for everything.
So I good time to start delving into it, I guess :D
You want to see if go could be a good fit for what's done in your company, at least for internal tools (I mean, programs developed only to help developers / the service you work in, not your customers).
i am just curious from the comments, do you guys believe this post?
I'm surprised they are "not hiring remote employees at this time". I always thought the core team is mostly remote.
Finally official dependency management!
Can you name "a lot" of those, so we're on the same page? As for "sacrifice the fun" part – again, that's not the purpose of programming language. Language is a tool for solving problems, and should be simple, practical and to have as little magic as possible.
I fail to see "proof" here, it's bias.
I wrote a rather comprehensive bot for Discord in Go with the great [https://github.com/bwmarrin/discordgo/](https://github.com/bwmarrin/discordgo/). Was really easy and fun coding it, and it performs great. Very low CPU and mem usage. I have no Python knowledge, so I can't compare. I can imagine that I would have had a few problems if I used node.
Definitely! I'm sure adding DoH support to coredns will happen one way or another, if it hasn't already :) I'll look into it. Making coredns that much easier to run is another story (due to its flexibility, backwards compatibility consideration, etc.), but documentation and examples can go a very long way. One of the goals for dnss has been ease to install and use for small environments (laptops, home routers).
Intrusive containers are an antipattern I haven't seen outside of C programming. Why doesn't Go have generics yet?
My dream validation library would be reusable at client side too (wasm/js code generation).
\&gt; Intrusive containers are an antipattern Sorry, never appreciated pattern-based thinking. You can attack real pain points, but not the fact that something doesn't fit nicely into patterns you've learn from other languages (which do not translate equally to other languages). \&gt; Why doesn't Go have generics yet? I assume you're aware that Go does have "generics", just not the user-defined ones, and that term "generics" applies to a many things at once. I also hope you know the official answer – there is currently no vision how to add user-defined generics into language without making it suck. But I guess real answer is much more deeper, and (that's my subjective opinion) user-defined generics are one of those things that are beneficial for relatively small fraction of cases. In vast majority of other cases, they are simply detrimental, making not only code harder to understand and worsen performance, but also changing a way how people think about designing programs and algorithms. After working for years with advanced C++ developers who were using templates for even the simplest abstractions, it made clear to me that "generics" create incentives to be overused and in the long run make more harm than good. So when people start designing their code with the thought "I want it to work with any type, so I need generics", this makes little sense. Types in Go represent data abstractions, they're fundamental blocks of translating mental model of the problem into the code, and writing code "that can work with any type" is plain wrong. As Linus Torvalds put it "Bad programmers worry about the code, good programmers worry about data structures, and their relationships". **Code should be designed around the data types, not vice versa.** In real world there are almost always concrete types and algorithms that need to work with those types, exploit properties of those types and optimize for them. That's where Go's interfaces are really shine and help to create meaningful generic abstractions over concrete types, which result into extremely readable codebase, little bloat and more than decent performance. That said, I'm extremely happy that Go doesn't have generics. There are plenty of languages with generics, so there is no lack of choice if someone \*really\* need generics. But Go team is exploring options how to add this, without making it into the "&lt;lang&gt; generics sucks" company, and I hope their final solution will be something very different and will not incentivize people "write code that works with any type" without really serious reason.
Yeah, that's a good idea and I also have been thinking about it. Currently it has a form of library - I mean that it provides a convenient interface to build a schema in a source code. If we want to share validation schemas between services for now I see two options: 1) Create additional tooling that generates 
`models` as a package name is a code smell IMO, it's in line with `utils` and `services`. [More on that here too.] (https://github.com/golang/go/wiki/CodeReviewComments#package-names) Then there's also [this blog article](https://blog.golang.org/package-names) with a title sectioned "Bad package names" which also outlines the point I'm trying to make here well: &gt; Packages named util, common, or misc provide clients with no sense of what the package contains. This makes it harder for clients to use the package and makes it harder for maintainers to keep the package focused. Now I know `models` isn't listed in there above, but the list in that post isn't meant to be exhaustive. The same logic applies though; `models` doesn't tell you much about what's in it, and it makes your other types that you might want to include in there (such as a type that interacts with the database) more awkward to name (e.g. `models.UserGateway` instead of just `users.Gateway` for example. "MVC" as it's implemented in languages like Java and PHP aren't bad, but they're also not really idiomatic Go. Because of how package naming and usage works (i.e. package names provide the context for types where they're used, not where they're imported, unlike other languages like Java and PHP) it means that using a package like `models` doesn't make as much sense. &gt; Actually, it is a "models database" which is perfectly logical. The models interact with a database. Regardless, I made a mistake making it an exported field since the models.Datastore is the only thing the outside world sees. Okay, so I can understand where you're coming from here, hell, even `database/sql` has a type called `DB` in it that interacts with a database - but I feel pretty confident in saying _you have not implemented a database system in Go, and then put that in a package called models_. If you have, then well that's both quite impressive, but also even worse package naming. If what you've actually done is made some type that interacts with a database, then I would still argue that it's unclear. In my opinion, you should have some kind of type name that conveys that you're _interacting with a database_ **clearly**, not _implementing a database itself_. That's why I suggested Gateway as a suffix. Think of this another way; imagine you were making a different application, and instead of interacting with a database, you were interacting with an API. You still have your `models` package (still a bad idea too). Would you then make a type called `models.API` to interact with your API? Probably not, because it's unclear, and your `models.API` type isn't actually an API (I mean, even this is problematic because really we're talking about a web service probably). What you might use instead for a type name is `models.Client`, or even `models.APIClient`.
This is a library that I've been working on for a side project. Its API is heavily influenced by github.com/spf13/viper but the internals address the following issues that I have with viper: - it's large; there are a lot of transient dependencies that are not properly vendored and likely aren't even needed by most, which can make integrating with viper cumbersome - it's inflexible; you're stuck with the config precedence and remote providers that are built in To this end I kept venom at zero dependencies, supporting only functionality exposed by the standard library but with an API that allows for that functionality to be easily extended. Any feedback is welcome! 
I've been looking for a library that can validate the following: - Structured data such as JSON/CBOR/MsgPack/BSON - email addresses
What problems is your employer having that would be solved by switching to Go? Can you estimate the cost (not necessarily in $$; time or manpower estimates are good too) of making the switch? From there: how can Gophercon reduce the costs, or make it possible to try using go with minimal risk?
You didn't miss much.
Yeah, that's a good idea to take into account. But there are still pros and cons of this approach. Here's my first thoughts on this. Pros: \- Simplicity of sharing schemas between services \- Ability to generate documentation or even API based on schemas \- Generative testing Cons: \- Requires additional command line tooling \- It requires manual update of the services source code or additional complexity on build step \- Tightly coupled services \- And another small one: if we're talking about client side application and back end API couple, often user input (browser of mobile form) differs from the client request, as it could send data in a different format or even contain additional data like IDs that often hidden from the user experience. As an alternative solution I can put into discussion automatically generated APIs based on schemas that returns validation rules that could be used by another clients. There are still lots of things to think about, but I will keep it in mind.
Just a separate point actually, I want to tackle this: &gt; I agree with this, but in this case, since models.Datastore is whole reason that the models package exists (and the only exported interface) it makes sense for it to be defined with the models. Realistically, no other package will use models without using models.Datastore. There's another idiom in Go; ["accept interfaces, return structs"](https://www.google.co.uk/search?ei=YNNRW5TKBMvFgAbZlrfgCw&amp;q=golang+%22accept+interfaces%2C+return+structs%22&amp;oq=golang+%22accept+interfaces%2C+return+structs%22&amp;gs_l=psy-ab.3..0i7i10i30k1.2153.8226.0.8284.34.30.0.0.0.0.177.3189.18j12.30.0....0...1.1.64.psy-ab..16.18.1913...0j0i7i30k1j0i7i5i10i30k1j0i5i10i30k1j0i22i30k1j0i22i10i30k1j0i30k1.0.BcvB5zn5KkE), which I'd probably call "return concretions, accept interfaces" instead really for clarity (as not all types as structs, you can attach methods to a `type Foo int` if you want). If the "whole reason that the models package exists" is because of the `models.Datastore` type, then that's an issue (besides, that doesn't seem to be true, given you have a `User` type in there too?). You don't actually need this interface to exist at all. You could (and IMO should) expose your `db` type, then you can call that `models.Datastore`, and return it. Take a look here: https://gist.github.com/seeruk/75fe573d0add1d3325aee73d36fc1fac This example shows how I would tackle it, put the mock, and the interface where you're actually using the interface. It means you're not pointlessly making life more difficult for yourself with regards to naming, etc. Not having the unnecessary layers of abstraction in the models package makes this a little clearer here too.
1) By default it works with basic golang structures like map\[string\]interface{} and \[\]interface{} that could represent most of the structured data formats. From the first beta version JSON would be a first class citizen and I will take into account another popular communication formats. 2) Email validation is one of the first I've implemented in the library
I don't really have any extra opinions to add here, but am very interested in seeing an example of it's usage. Off of the back of that I may be able to make some suggestions I suppose? I've also had the same concerns as you (mainly around avoiding the use of struct tags for validation) in the past.
Yeah, I think they should have called it "projects". The meaning of module and package is now backwards to how it is in Python. :-/ Rust doesn't use "packages" but "crate" is more or less a synonym for package, and it also corresponds to the larger code unit. On the one hand, both "module" and "package" are generic words for "bunch of programming files", but on the other hand, it makes more sense to "package up" a bunch of smaller "modules" than vice versa. 
I think you've misunderstood me. I don't want the validator to _decode_ the structured data -- I want to validate that it conforms to the spec. In principle, this should be achievable with a regex.
Got you
I'd like easy integration with the standard http library, maybe using a declarative syntax
I'm curious, where do you see the drawbacks of my current goto validation library [https://github.com/asaskevich/govalidator](https://github.com/asaskevich/govalidator) ?
No, not really -- most universities would start with Python or JavaScript. 
Yes in short. Go will give you a good fundamental knowledge of programming, just don't get too caught up in the go-isms - some of them are for the better, some are just different, but every language has it's benefits and quirks. For the complete novice, I usually suggest python or ruby because they are easy to pick up quickly and get coding, but if you actually have the time to devote to learning something, Go is a great choice.
I think Python, Ruby, and JavaScript are the easiest first languages. There are more beginner resources available, and a quicker path towards your first simple project. That being said, if there's a specific reason you want to learn Go first, it will be fine. If you happen to have a friend who programs that you can ask questions to, I also recommend learning whatever language they know best.
I think it is an excellent choice, because the spec is simple enough for a beginner to not get lost learning languages features, so you can focus on learning programming. But it also exposes enough low level aspects that you \*really\* learn programming, and how memory works to a degree, which Ruby/Python hide from you. You might enjoy the video series I did a while back geared for beginners: [https://gameswithgo.org/](https://gameswithgo.org/)
I didn't know about this an love it.
Thank you so much 
Any of the general use languages are good languages to learn on. The key is to pick one, learn it, and then go learn 10 more. Master 1, then the rest will fall into place. Knowing multiple programming languages is essential to a firm understanding of computer science.
Seconded. Go’s a small and fairly simple language, but there isn’t the wealth of beginner-focussed tutorials and communities you have with a language like Python or JS. By and large, Go docs and tutorials tend to assume you’re only new to Go, not programming in general. Python in a good choice, as the community generally values clarity over cleverness.
I don't want to start a language war as always, I can give you my preferences if you want but that's not the point. I completely disagree with you on the "fun part" is secondary, yes a language is a tool to solve problems, like algebra is a tool to solve equations, you can choose to use abstraction (symbols) to solve equation or you can count using your fingers. Learning abstractions is harder and more difficult to read that count pebbles, but it's way more fun and, eventually, allows you to expand your knowledge. There is no magic in abstractions, it's actually the only way to manage complexity with our little brains. This is my main problem with Go, it's not good to create/manage abstractions (and please don't tell me that you can use interfaces). 
 Creating abstraction is a fundamental tool in human knowledge, without abstractions you wouldn't even have the computer you are using to type this message. As I said early in another message, my main problem with Go is that is not good language to create/manage abstractions. Of course in may 'programs' we create today are just dumb APIs with little to zero computation inside, for that Go it's fine. From my experience code is harder to maintain if: 1 - It's not optimized, and there are 100 lines of code that can be written in 10 if you know what you are going 2 - It's not DRY and eventually you forget something 3 - Functions/Methods are not referential transparent, this also make testing much harder 4 - You mutate state in unpredictable ways 
On the contrary, I think that lot of developers think the same way you do. I'm quite the opposite, if there is nothing interesting I get bored and my productivity goes down to zero.
i second the opinion that Python is a better language to learn as a beginner, primarily due to the high availability of beginner resources. Having said that if your heart is set on golang, I highly recommend the 'get programming with go' book https://www.manning.com/books/get-programming-with-go It's an easy and fun read geared towards beginners to programming.
Hey! There are several points. I would describe it in context of my primary case - REST API input validation. I think most issues I have is related to use of struct tags for validation: 1) At first, before validation you need to unmarshal json into struct it causes several issues: 1.1) **Can't check type.** If value comes in a wrong format I have to deal with json.Unmarshal() error. For example for whatever reason I expect "age" property to come as a string, when I receive request from the client and "age" is a number I would like to return error with message "Age must be a string". Now I will receive json.Unmarshal() error "json: cannot unmarshal number into Go struct field user.age of type string". [https://play.golang.org/p/cO6qBOU2-RS](https://play.golang.org/p/cO6qBOU2-RS) 1.2) **Fake required.** There is no way to check if value actually existed in a collection, because { "count": 0 } and { "count": null } and {} json produces exactly the same result on structure struct { Count int \`json:"count"\` }". [https://play.golang.org/p/IX\_BWHfIMxN](https://play.golang.org/p/IX_BWHfIMxN) 2) **Broken typing** \- you operate with a strings - no compiler time checks, only runtime fails. 3) **No way (at least easy way) to create a complex validation rules**. For example, property that could be in a one of a few formats or ability to compare values (validate "confirmPassoword" field value to equal "password") or conditional validation. Hope that would be enough as it's a very important limitations for me. Anyway next week I will release full documentation of my library. Hope you will check it and will write your opinion.
That's what I'm working on =)
I agree with others that Python is probably the best to start with. I guess it depends on what you really want to do. If you want to make websites then for a beginner I think Python/Django route is better then doing it in Go. If you want to do more backend software stuff then Go might be a good fit for you to start with. 
&gt;This is my main problem with Go &gt; &gt;and please don't tell me that you can use interfaces Ha, that sounds like "my problem with Tesla car is that I can't put petroleum inside, and don't tell me I can use electric power". Ok, then. &gt;I can give you my preferences It's not about preference, I asked to name "simple and pragmatic" languages, because I don't think there is even one language out there that was created with the same principles in mind as Go. Most languages really strive to "improve" existing features (better exceptions, better generics, better inheritance and so on), extend feature set with freshly born concepts, never battle tested in practice, sell to user with the promise of more sugar and magic. But apart of obvious reasons, that's usually loosely connected to social context of programming – something that you don't learn in universities or from textbook, only acquire by years and years of experience working in diverse set of teams with diverse set of problems. Go is a first language in history of programming languages that put this social context of programming on the top of its priorities, and that influenced design choices dramatically different from the rest of existing languages. It wasn't accidental weekend hack project that accidentally become a language (as it sometimes happens), it was thoroughly designed for a few years with those principles in mind, and I takes enormous amount of effort and intelligence to do so. Now, you simply saying that there are "a lot" of other languages like that, and I would love to learn about more awesome programming languages that put practical pragmatism and simplicity at the center of their design.
Sounds valid, thank you for this detailed list. :-) So far, we have managed to get around these. Required fields and nesting is validated upfront here via the graphql lib and see missing validation is done via this lib and some custom validators like "does this ID exist in the DB?"
I view it as what level of programming are you trying to learn. Lowest level languages force understandings on you, but also impose barriers if you don't have those understandings. Higher languages like Python, JavaScript/etc ignore many of the lower level concerns, so you can learn the principles of programming without as much understanding about how memory is handled, runtime cost, etc. Go I think is good, because it sits somewhere in the middle. It doesn't make you manage your own memory, but it's also more explicit about memory than Python/JS.
I feel that you are taking this personally, and that will make discussion bias by definition, and I'm sorry it need to go this way. I just want to understand why people like this language, because I just don't get it. Maybe I'm not social enough to appreciate it. 
I have the same experience as you, but I'm the opposite with Go. I really like the language and the simplicity.
awesome, let me know once it's released. I'm very interested
I think it’s a good language to start with. Just understand there will be a steeper learning curve than if you went with a language like JavaScript. On the one hand the syntax is simple and the spec is fairly small, but on the other hand you’ve got concepts like pointers and interfaces that will probably trip you up. One plus to learning go first is the excellent standard library. There a lot of things that go can do out of the box that you would have to implement yourself or bring in 3rd party libraries to do in other languages. 
Hah, maybe. 5 years ago, I was at the point in my career, when I was seriously thinking to abandon software engineering, because I stopped having fun doing it (and I started code at 6). I dealt mostly with networking performant and kinda-embedded software and had to choose between C/C++/Java/Python those days. Amount of accidental complexity to deal with was ridiculous. And then I discovered Go, and became productive in a laughable amount of time. Almost everything in Go was attacking the real pain points – clarity and unambiguity of the code, readability of standard library, stupidly short path from "I need to use library X" to having X installed and used in code, promise of compatibility, subsecond compilation, simple grammar (I really started loving writing static analysers), feeling that "you undertstand the language to the full extent" (you can literally memorize the spec), its builtin support for testing, benchmarking and docs, it's approach to the error handling (errors aren't special, they should be treated as any other variable), "native" integration with github and other vcs, automatic gofmt formatting (no more stupid style camps), mindblowing approach to concurrency (after spending years writing pthreads CSP was a balm), etc.etc. All that was SO different from where mainstream technology were going, so it really stand out. Less is more is not just a catchy phrase in Go world, it's the fundamental design principle. I can definitely say that Go has changed my life back then. I found fantastic teams to work with, joined world-changing projects, started a startup (simply because I could devote weekend writing software for it - thanks to Go. In any other language it would take 10x time, so I would never even tried it!) and generally feel happy every day writing and reading Go – every codebase in Go I touch is 99.9% readable and clean, 70% tested and documented, and writing Go is just the most pleasant experience I had in my coding life.
Just sharing a quick library we use for our smaller services. Makes it super simple to read config variables from the environment or optionally override them on the command line. There are obviously other much larger and more powerful libraries out there, but for simple services this feels like the right amount of power and flexibility.
Of course, he's author of "The Go Programming Language" book.
I wouldn't have gone for a solution that involves iterating through every single number for this. While I'm not a huge proponent of TDD for algorithm design, have you tried it? I'm referring to writing a unit test, and only writing just enough code to pass the test, then writing another test. 
Tools like this are (depending on what jurisdiction you are in) potentially illegal, likely against the TOS of the sites you are using and definitely mean you are being a bad net-citizen. Please don't.
i'm wrote bot which notify about new articles on site, i think this did not illegal
If the site-owner would approve of your usage, there wouldn't be a captcha. So, see above: At the very least you are intentionally ignoring the wishes of the person/company providing the content.
I think simplicity over complexity, when the difference in performance is allowable, is of much higher value than raw performance. Also, I think it makes sense for the solution to fit the problem when possible. For instance, I know the basic limits of how many total pages will be listed, and it returns plenty fast enough to warrant not implementing anything that's more complicated/performant. It would be simple enough to implement a check within the loop that if skipping ahead will still be below the third to last page, then we could just increase the iter variable by the skip amount each time and save time there. You could also implement another way of appending to the string and save more time there. There is a bit of a performance trick by using a boolean map to check the surrounding page numbers. In the end though, you gotta have some way of outputting the page numbers and ellipsis. While I agree it could be written to benchmark better, for the vast majority of use cases (anything around or less than 10k pages), it should be plenty fast.
Wow, it is really personal for you, good for you man, I hope you enjoy go for the rest of your professional career!
&gt;If you happen to have a friend who programs that you can ask questions to, I also recommend learning whatever language they know best. Very much agreed on that last point. On the rest, it sorta depends what you want to do with your hobby. If you specifically want make websites, JavaScript is the only right choice. If your interests are almost anything else, Python is a more simple and sane language overall, so it's much better as a first language. Ruby is ok, but personally I wouldn't recommend it over python.
no
It depends. If you want to start casually and see if you like coding I'd recommend Python. Other scripting languages like JavaScript and Lua would be fine too. Go is much more benevolent compared the C++ with manual memory management or Java that super bureaucratic, but it is definitely less casual than a scripting language. That said, IMO if you spend a year coding in Go you will end being a better programmer than if you had spent that time with JavaScript. Go will introduce you to types, pointers, concurrency, etc.
I can't believe most of the replies to this post. Which language is the best heavily depends on what you want to do. ALL languages will teach you basic syntax like variables, loops, etc. But what do you want to do? It's possible to program games in Go, but it's probably easier to get started with Python/Pygame. It's possible to program operating systems in Go, but it's probably better to learn C or Rust if that's your thing (it probably isn't). If you want to make a fancy app for iOS or MacOS, I would recommend Swift with a bit of Objective-C. etc... If you want to make websites: IGNORE ALL THE OTHER SUGGESTIONS IN THIS THREAD. USE GO! If you want to make a website, you SHOULD NOT start out with Ruby (on Rails) or Javascript. In RoR you'll see magic "Yay, I can create a blog application in 5 minutes!" and become incredibly frustrated, when you're unable to understand how to enhance that tutorial app. In Javascript you'll be in node.js and NPM hell. You'll follow guides and see hundreds of "stuff" being installed on your machine without understanding what's going on. Should you manage to make a website with these technologies, you'll find the road to deployment on an actual server incredibly long. Just take a long at one of the "easy to follow" guides: https://www.ralfebert.de/tutorials/rails-deployment/ You might use vanilla PHP. Millions of people have created production websites in PHP with a mySQL database. Deployment is done by copying some files. If you follow this road: STAY AWAY FROM THE FRAMEWORKS. You'll waste countless hours figuring out how Laravel, or Drupal or Phalcon or whatever the framework of the month is. And you'll probably end up confused and frustrated before you even find out where to add a new page in addition to the "Hello world" page the tutorial showed you. So, in short: If you want to dip your toe in the programming water without a specific purpose: Learn Python. If you want to do web development the old skool way: Learn vanilla PHP. If you want to do web development the modern way: Learn Go. (I know people will download me to hell for recommending vanilla PHP. A lot of crappy, insecure, bad, sucky websites have been created in that language... Yet, it enable a beginner to actually create something and learn bit by bit without being overwhelmed by ORM, dependency injection, dependency hell, etc..)
Good for you, I would like to be like you, I honestly hope to change my mind in the future about this language
Just out of curiosity, do you have any experience working with a functional language (that is not Scala)? Also what kind of project are you working on? I'm asking because one of my developers, great Go advocate, after spending months working on an ETL/DSL project that require a lot of abstraction, today he came back to me saying "why we didn't do this in Clojure"? Maybe Go is not the best language for everything?
Ive been ‘properly’ learning go as a first language and I have absolutely no regrets whatsoever and would recommend it. I attempted briefly to dabble with python a while back and whilst there are a hell of a lot of resources etc there is also way too much ‘magic’ for my liking. I found myself totally confused by the most basic concepts despite being able to produce something that ‘worked’ so I gave up. I was pointed towards go a while after this failed attempt with python and that is where my interest and passion really kicked off. I should say that I’m a person that very much enjoys understanding exactly how and why things are working and engaging with go does start to help you gain an understanding. I’ve been going for about a year now and find myself very comfortable with go, I’ve even returned to python (and even JavaScript) with an enhanced understanding of how things actually ‘work’, which has helped me infinitely. On the flip side, getting my head around topics like pointers have made languages such as C and C++ more approachable. Whilst I still have a hell of a lot to learn, I’ve found go the perfect language to get me going and really inspired into the world of programming. I took a somewhat silly route of picking up ‘The Go Programming Language’ by Donovan and Kernighan and battling through that. It is not a book aimed at beginners, but coupled with some other recourses out there it’s pretty powerful. Anyway, I hope my ramble in some way helps out - there are some great replies here but at the end of the day go with whatever language holds your interest! 
lol
What does this Golang program print? Program: https://pastebin.com/3FuwK6ur Check: https://play.golang.org/p/34_gmvTx4qa 
&gt; so that the customer can watch the page starting to render Sounds to me at least more like client-side rendering with js (ajax). The Go templateing system is pretty fast by itself. If you have trouble gathering all your data from a DB I suggest using a cache as this would speed-up server or client rendering. Else I can just link to the nested-template section of the template documentation: https://golang.org/pkg/text/template/#hdr-Nested_template_definitions
This link is dead for me. Anyone else?
No, if you want to code as a hobby go is not the right choice.
Do not send passwords over the wire unencrypted. Either setup a https server with lets say a 'let's encrypt' certificate or hash it client-side. And if you have got templates without parameters you can just serve them as static html.
Yeah, it says the author deleted the post.
"Computing with Scratch/Blocks is like trying to get to the moon by climbing a tree: the first 15 ft are really good, but then you're stuck" love bwk
If you are running modules with a GOPROXY you may bump into this issue with beta2 and head vgo. [https://github.com/golang/go/issues/26503](https://github.com/golang/go/issues/26503) They changed the proxy protocol and upstream proxy systems need to come into alignment. I know atleast JFrog is busted. 
Java to gen Go? Wut.
For anybody hoping to hear more about Go. OP's title summarizes it very elegantly. This is a handful of twitter questions to Brian and he is the focus.
Yeah, there is a project [go-swagger](https://github.com/go-swagger/go-swagger) which is is written in Go to generate Go client SDKs. I use [OpenAPI Generator](https://github.com/OpenAPITools/openapi-generator) written in Java because it can generate clients in 30 languages as listed below. This way ,if I ever need something for say Elm, TypeScript, etc., I'll be familiar with the tool already. ActionScript, Ada, Apex, Bash, C#, C++, Clojure, Dart, Elixir, Elm, Eiffel, Erlang, Go, Groovy, Haskell, Java, Kotlin, Lua, Node.js, Objective-C, Perl, PHP, PowerShell, Python, R, Ruby, Rust, Scala, Swift, TypeScript
also, it should allow to define new validators
Perhaps you thought mods meant modules, but mods which can be like plugins, means modifications.
Seems like such a nice guy.
Yet LabView exists...
From his wikipedia https://en.wikipedia.org/wiki/Brian_Kernighan you can tell that Go would fit right because he does seem to avoid languages with Generics.
&lt;burn&gt; (but oh so true)
Why you delete the post? 
For dependency management, I'd use [dep](https://github.com/golang/dep#installation) for now and switch to Go modules once Go 1.11 is released.
[removed]
[removed]
User's model and handle methods doesn't belong to main, move them into separate packages. Also, when making tutorial, don't use ORMs or at least explicitly say you're doing it. Do not use fmt package for loggin, use log package instead. You're also ignoring errors in few places, like [this](https://github.com/bajro17/golang-session-auth/blob/master/main.go#L72). If you don't want to check errors like [this](https://github.com/bajro17/golang-session-auth/blob/master/main.go#L30), you can create helper function, for example MustConnectDB, where you'll panic if there's any error with database.
Thank you so much 
&gt; What this proposal should be really about [...] What this comment should be really about, is what is proposed, not what you read into it. IMHO
What syntax would you prefer?
&gt; but this one which was linked in the comments solves the same problem Wrong.
From my point of view it is simply a question of readability. I want to see which type is passed without having to dig a lot of code / context.
If you really want to master it, JavaScript has a *much* stepper learning curve. Even knowing the implications of supposedly simple operators like `==`.
[removed]
[removed]
You're right, and I think the others are a bit too hasty with recommending Python, Ruby and JavaScript. I'm a JS dev myself, and I love the language, I've programmed in Python and Ruby before, but those three interpreted languages have some real problems due to the way they grew over time. It's easy to get a Hello World going with JavaScript due to the abundance of JS runtimes; it's easy to get going with Python due to the high availability of tutorials; but those languages implement so many high-level concepts which see constant misuse, especially in tutorials, and make learning programming really cumbersome to many people. As for Golang, I have yet to see a tutorial that really fucked things up. It's a syntactically easy language with lots of advanced concepts in a well sorted standard library, and the possibility to go pretty low-level, reminding you of the fact that you're actually programming a computer and not some virtual runtime that will try its best to handle your shitty code. @OP: totally continue with Golang if you want to get into general purpose programming. If you want to get into web development, learn JavaScript next - it's a great language with lots of quirks. If you're into science, try Python.
What amused you?
Ty
He is probably far more famous for another book: https://en.wikipedia.org/wiki/C_(programming_language)#K&amp;R_C
I use goa but only generate new code by hand when I make some change to the design. Why generate it all on each build ? It even seems problematic to me, because all action handlers will be reset each time goagen is called ? I configured goagen to write all root output (the action handlers) to a separate dir and only check for differences (meaning sometimes adding a new action handler). 
Imagine being so prominent in the programming community that if you use a new language, that's worthy of a reddit post with a decent number of up votes. 
&gt;Maybe Go is not the best language for everything? Definitely not, and I don't know personally any Go developer that claim that. I had long-time troubles with jumping into functional languages camp, mostly because: a) I don't clearly see real benefit from the switch ("you'll be better programmer" is ok, but not at that cost) b) they're mostly academia-born languages, hugely disconnected from practical and social reality of software engineering (I know things are getting better, but it's not in the design) c) cost of even trying and getting productive - most of my Haskell friends said it took them 3-4 years to get into decent confidence level (compare it to an average a week with Go). I simply don't have spare 3-4 years for mind bending for dubious reasons. d) performance (Go beats Haskell and Clojure easily) - it's important for the kind of software I usually do. Plus, coming from C/C++ background, I really want to "feel" what is happening in a program on a near-hardware level. Also, I have doubts that the whole functional approach is really aligned with neuroscience and how our brain works (imperative languages are naturally aligned, because of their empirical roots). Functional devs I know are super-smart but almost unemployable math geeks, with interesting biases, which I cannot truly appreciate. For example, "simplicity" for many of them means "ability to pack as many things as possible into one line of code", which just doesn't make sense to me. As for DSLs - Go is definitely not the best language for representing DSLs, but I don't think people write those a lot every day (and that's definitely good, because DSL bring tremendous amount of complexity in any project). I usually deal with high-performance network software, peer-to-peer protocols, lately with different blockchain implementations and performance-critical libraries used in mobile apps.
We also publish the CLI as a docker image, so you don't even need Java installed locally.
This reply is far too reasonable and well thought out to be on this sub.
he wants to sell as many books as possible probably? 
Of course you are downvoted, nobody here want to hear that word
I don't know... this seems like a very strange way to "filter" candidates. If you wanted to only hire recent grads, wouldn't you just... only hire recent grads? Why waste everyone's time with a lengthy process meant to filter for a type of candidate that you can filter for automatically via application? Wasting 6+ hours of engineering time to determine if someone is a recent graduate doesn't sound very "convenient" to me.
Have you done any analysis on the number distribution it creates? It would be nice to see that on the readme page.
These are all very good reasons, I have a completely different idea about FP, I see clear benefits of having a language that enforce immutability, referential transparency, and function composition. I don't see Clojure or Kotlin or Elixir as academic languages. I understand that learning Haskell is hard, but many FP languages are really easy to learn (not in a week as go of course). If extreme performance is not required (I would argue that Haskell can be as fast as go in same cases if well written, but that's another discussion) then I see clear benefits of using FP over Imperative/OO for complex problem like DSLs. Given your background and your requirements I think that Go it's a very good choice, I would choose it as well probably. Finally, I agree with you that imperative languages are more aligned with how we "think", but I also think that to manage complexity we need tools that enhance and augment the way we think, for the simple reason that some problems are too complex to be though in it's entirety. Some of this tools are not perfect (I'm thinking about category theory) but promising, and a language like Haskell it's a very good fit for them. Maybe I'm begin too abstract at this point, I apologies, but this is what drive my curiosity and my excitement more than having super fast executable. I promise to myself that I will continue to try to like Go and find a sweet spot where I can be less bored :). Thanks for your insight on this topic, very useful.
This isn't a Go specific thing but it sounds like you could benefit from the concepts from "clean architecure". Maybe I'm oversimplifying it, but you can see it as a way to design your applications such that the business logic is at the core and stuff like UI, RESTful API, Databases, and so on, all connect to your business logic like plugins. In your example, auth would be a layer that communicates to each application's business logic through THEIR well-defined public interface, not the other way around. You could also apply these ideas to the client-side to get the decoupling you are looking for.
His and Alan's book [The Go Programming Language](http://www.gopl.io) is my favorite programming book by far. Kernighan rules!
I see, so you first generate the code and then copy it to your src/ . What happens when you make a change to design/design.go? you have to re-generate right? 
That's OK if you don't like Go, nothing wrong with that. I appreciate that you at least try to understand what people found in it. May I ask why people so excited about immutability? To me this is an interesting mental exercise ("What if we aren't allowed to mutate object?"), but that's it. I can invent other mental exercises like "What if we have ternary system instead of binary?" or "What if we write software for highly-ionized environment (i.e. satellites) where memory is expected to fail with known probability?". Or, quantum computing is especially cool, but nobody in quantum computing world says that programming qubits is more superior way of programming than with classical bits. It's just a different approach that has benefits for very narrow and limited set of use-cases, most of them are under research (and gives exponential speed gain, loosing on everything else). I mean, that's interesting for educational purposes, and you definitely can come up with interesting solutions based on academic research, but the problems and downsides of immutability are on the surface and are obvious – major ones of them is, of course, huge performance/memory impact and mere fact that we don't think about world in the immutable concepts (as I write this text, I update state of the texteditor – I don't perceive it as I create new immutable copy of it on every keypress. it's just nonsense). So, what's so special about immutability that makes people to put it on top of their arguments list?
I want Go to get generics but I downvoted because comments like these in every thread aren’t helpful or interesting.
There are many benefits of immutability: programs are easier to reason about (especially when used together with referential transparent functions), race conditions are basically impossible, in some cases you have feature like "undo" for free, and others that you can easily find if you google it. As for performance, unless the language is very very bad, you never create a new copy of the whole data structure, under the hood they use what is called structural sharing (using tries) to void coping the part that is not changed. I can tell you that in many cases using immutable data structure makes the program faster, not slower.
You can embed the HTML, CSS and JavaScript code into the Go files [1]. Then you can do what you avoided in the first place: import the auth project as a package. [1] https://github.com/jteeuwen/go-bindata
Yes. Manually. I assume src/ is the root of your project. So goa will output all its generated files into src/models, src/swagger, src/tool etc (that is the default). Only for my main files will be saved into /src/main_latest/ to prevent those files (which contain my custom code !) to be overwritten. Something like: &amp;genmain.Generator{ API: design.Design, Target: "app", OutDir: "main_latest", Force: true, }, 
Ok, thanks, I see.
Great post. Decorator is my favourite pattern. ~~But please use a monospace-font for the examples.~~ ~~Edit: You can patch it yourself by adding the font of your choice (ex. 'Source Code Pro', 'Dejavu Sans Mono', Inconsolata) to line 13 of file custom.css.~~ Edit2: Sorry being stupid (I block js so font-fetching does not work for me)
Thanks. I will try that. Was thinking of going to GRPC and REST because they too have a DSL similar to goa. But maybe overkill. Is there anything similar to Goa: DSL which generates scaffolding and have swagger support?
That you so much!!! I’m certainly going to learn JavaScript first now. I’ll save go for the future 
Sounds like you want a [Composite UI](https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/architect-microservice-container-applications/microservice-based-composite-ui-shape-layout) . Is this what you are requesting? auth.go would be your micro service. The UI components would have to be independent, portable and preferably build on a UI framework.
No he talking about a go cli like angulars cli commands. The ones to create components. https://cli.angular.io Unfortunately no go doesn't have that like angular. Although there might be some code generators. 
But the project is written in Python, not Go.
To be fair Go is far not the best language in the world. No generics, no metaprogramming, 1,5mb hello world, no good GUI library (like Kivy or PyQt), no good web framework (like Django) and etc. It is usable for some tasks, but Python is more usable for everything.
if i post in 2 subbies i get more updoots right
I love this pattern. I mostly use it to add a caching layer. Last week I wrote a class that returns Google search results and decorated it with a class that caches the results to Redis. So clean and testable. :)
NewRequest is for when you want to modify the request before sending it.
Than
I think choosing Python was the wrong parable to express the stability and the maturity of a language as the team behind purposefully made some breaking changes when they introduce python 3.x (this was almost a decade ago and still lots of systems only use 2.7.x). PHP could have been a better example as it still embarks quirky functions from its early days (and tries to move on by marking some of those functions as deprecated when the dev team creates newer versions). 
In all honesty the main reason is age, community and support. Youre more likely to solve a coding challenge in python by just googling than even using your brain. Its also super easy to get started with. I'm a Go fan til death do us part, but ive been tasked with purely Python AWS lambdas recently, and coming back to Python.. everything feels so lazy, and much easier to do in one line and built in helper methods.
Go is growing fast, and is far better suited to modern environments, but yeah, it’s a language of the future. The same could have been said of Fortran -vs- Java at some point in the past. If you want a steady paycheck, feel free to choose any language-of-the-past you enjoy working in. If you want to stay current and build the future, feel free to choose any language-of-the-future you enjoy working in.
At my old employer, we went this same route with a separate package. We had a monorepo that made it easy to reuse across projects. I think it's a good approach.
Had this problem before at work for auth logic as well, across many micro services. Our solution is to extract the auth logic into its own Go package and we structure it as middleware pattern. This way, every Go project benefits.
Yeah that example lacks aesthetic but it's still interesting conceptually. Appreciate the list, it will make a fine addition to my collection. I'm curious, any reason you used a doc rather than a spreadsheet?
Tangent: it's so much better to just say 'monospace' and let my browser use the one I told it to use. Soooo sick of seeing crappy monospace fonts. I think fontconfig can be configured with overrides, but let's be real, I hardly use Linux these days. I'm pretty disappointed with the Go monospace font. It's basically Courier New. (There, back on topic.)
It also calls Do, meaning you can't add headers or otherwise modify the request before sending it. OP, your example is a bit misleading. The first return value of Post is a Response, not a Request as implied my the variable name.
I like it! Especially that it has no other dependencies. Thanks for sharing! 
It uses high quality permutation from cryptographically strong hash function. And generator construction is made to avoid presumable pitfalls of that permutation. I'm confident it will pass any statistical check. I've run part of practrand and diehard, and there were not found any fails. I will run full practrand, diehard and testu01. I just don't want to burn my notebook with them.
&gt; Also, many people from these other languages don't want to deal with types. Let's add some nuance, I don't to deal with a *braindead* typing system like go's. I don't see how a language that ignores decades of research in PLT can be considered futuristic.
Could you explain that a little more?
Also just ignoring the last 20 years in functional programming advancements.
Interesting statement but your 1.5mb hello world is a bit misunderstood. Golang is a compiled language and python is interpreted. Sure a python hello world script file is a few bytes. But do yourself a favor and make a hello world Docker image. It would be 20mb for alpine python or 350mb for a "full" python docker image. Also you cannot simply compile python to a single binary. If you share your python script the other person must have (possibly even the correct version of) python installed. Golang can natively compile to multiple platforms. So if you want to run on linux-amd64 you just compile it (even on windows) to a single binary, no external dependencies or golang installation needed.
I think yeoman might be useful to you: http://yeoman.io
Huh, not sure how I missed that. I need some sleep.
Ah, so for adding headers and such? Thanks!
&gt; I really want to to avoid $GOPATH/github.com/src because my current setup, I use docker to compile/build/test my code. What does one thing have to do with the other?
The Go Brand Book states: &gt; Note: When the Go font is not available, use Source Code Pro, available at fonts.google.com And I really quite like Code Pro so this is also why I suggested it first.
It's not age, it's the ease of various applications going well beyond "software engineering". Go will never compete with that.
so your myfile.go is simply a Stop its Stop program not a Go program, if this happens ;)
It was modeled after c for modern CPUs and concurrency. It was designed to be simple, fast and efficient. It was designed by brilliant people who understand and created modern Unix systems. I hardly see that as ignoring 20 years in functional programming advancements when there are plenty of other languages to choose from that hang their coat on those concepts.
Thanks. Any specific links or blog posts that cover these concepts/ideas.
With this approach I understand the the static (HTML, CSS, JS) files will become part of the binary. However, it is not clear to me how the path of these files is determined when I embed the auth package in another application that uses it. For which routes are these embedded files served, when within another application.
There is nothing to explain, the op is clearly ignorant of the research and reasons go designers made the decisions they did. It’s pretty much on every intro to go page / course as to why a strongly typed language was selected. Go wanted idiomatic type safety inherent in the language and the reasons are echoed through many of its built ins and functions. Both go and python are awesome so I’m bemused that there is hate for one another 
Go's strengths are its simplicity as a language, and the completeness and relative consistency and simplicity of its standard library.
Wow, this was a really good article! Well-written and great examples. The decorator pattern is completely new to me, but this write-up helped me wrap my head around the idea well. 
They are for different tasks, why would one replace the other?
Thanks. This could probably work. I need to spend time to absorb this, since it is all very new to me.
Thanks! What did you do with sign up / sign in views? Did you add them to the package too?
How could it have done this? It took Python *decades* to get this popular. Go is a tidy, moderately safe language with a powerful standard library and a lot of great support behind it and maybe in 20 years it will be super-popular too. For now it is less popular than Perl (according to TIOBE). But it is definitely the cutting edge language of DevOps tooling, which means the future is pretty bright.
I assume the CSS and JavaScript code is small enough to inline them in the page. If the code is so large that you need to put them into external files then I guess you can design a pattern to allow you to load the auth package from another project and pass variables indicating the directory and URL where these static files are supposed to live. Then, make the auth package write these files into that directory and pass the URL coming from the parent project to the HTML as the base for the `src` attributes.
Many web services are written in Python and many are written in Go. ???
thanks for good instructions!!
Yeah you kinda got me there. Umm idk I think it was another doc I seen that had those shaded headers and just liked it. Right now I'm trying to recreate the print methods which lead me down the path of sync.pool, which is just crazy. http://www.akshaydeo.com/blog/2017/12/23/How-did-I-improve-latency-by-700-percent-using-syncPool/ 
You should look into sync.pool. Neat stuff. http://www.akshaydeo.com/blog/2017/12/23/How-did-I-improve-latency-by-700-percent-using-syncPool/
I feel like this post is missing the forest for the trees, and it's a sentiment I see often in the golang community. I enjoy using Go as much as the next guy, but it's never going to be as popular as Python. They serve different purposes, they are different tools. It's like comparing a screwdriver to a hammer, they just don't compare 1 to 1. Python is excellent for writing web apps, quick prototyping, or in general just fast development. Go is slower and more verbose to write, and compiled languages are always going to feel more "punishing" than Python.
Yes, under templates directory, the idea is to use simple Go function to generate just enough HTML to be composed into the primary template.
But you can use in your pc. 
You got the negative site.someone does always you know.
Great point. And it shouldn’t ever try.
That last paragraph is what killed Python for me when it comes to building applications. It’s great for scripting, but as soon as you have to deploy or distribute your Python app, it’s hell. Docker has alleviated this in recent years but it’s too late for me.
The project is written in python but it doesn’t mean you can’t use on your pc.
But why would you post a python project in the golang subreddit?
If you're world class you're not applying via random job posting on the internet, you're getting a personal introduction from one of your peers. These are the people that can work remote, and it seems there are several on the Go team. 
Read carefully the comment above . This project is helpful for all kind of developer because you are notified without browsing github repo.
I have never had any issues deploying python... What kind of limitations are you working with????
There are plenty of places using go as their one language for everything; machine learning, lambdas, web services, batch processing, event processing.
Go is an opinionated language, it would hard to as popular as python.
Enterprise environments that have been doing Java forever and have firewalls and proxies etc that make pip and friends a huge pain in the ass on production servers. Fortunately those times are behind me but nothing beats deploying a standalone binary. 
It takes courage to leave a language of comfort and familiarity and try a language that is not only new to you but new to the world. This road less travelled is a bumpy one, lined with bugs that only early adopters are familiar with. It includes unexpected errors, spotty or missing documentation, and a lack of established libraries to use. This is the path of a trailblazer, a pioneer. If you are reading this now, you aren't too late, start learning **Go** today.
&gt; wrap my head around the idea I see you
This is my favorite method, I setup a config package which houses general constants, environment variables and logging settings. Makes it easier for others to find and use!
I would understand your point about Nim or Crystal which are in it's infancy, but Go is way past the early adopter phase.
&gt; everything feels so lazy, and much easier to do in one line and built in helper methods You mean this as a compliment to python, right? It certainly should be, but I can't quite tell...
NewRequest returns a pointer to a request struct. But the request has not been sent over the wire yet. You can modify it, add headers, do what you need and when you are ready to send it, do so with http.Client Do method. http.Post sends a post request and returns a response and an error. 
Technology lock-in is a business problem, not a development problem and it's here to stay, no matter the language. Business decisions have to consider the broader risks, not just the immediate technology, so they are often naturally conservative once a technology is committed do. It happens with hardware as well as software. Just as many new projects starting today are starting with Go, that's just tomorrow's technology lock-in problem. Same thing, different decade.
I don't need generics because they're too hard and Rob said so. Also copy paste.
Yup, I shouldnt have to write a function to find something if somethings in a slice.. and lambda (anonymous) functions are one liners in python. Go just isnt beginner efficient unless you wish to type more. But where Go shines is code organisation, concurrency and ease of deployment... in the long term it does pay off.
I mostly lurk and I've only read through the startup docs for golang a couple times (never wrote "real" software with it) so please do forgive my naïveté, but what is it about golang that makes it a "language of the future" and python a "language of the past" besides their respective birth dates?
there is some merit to your comment, but I found it quite hostile. Additionally, I find one of your \_fundamental flaws\_ a mere inconvenience that has never cause me any pain. The other I consider a feature. If my code compiles I feel relatively confident that I can leave it running for months with out checking on it. Python (which I also enjoy) doesn't give me the same confidence.
Cool, thanks for clarifying!
You made 0 arguments as to why lol. You just sound like a fanatic. How about elixir? How about kotlin? What about rust? If you’re so good at predicting the future, are you a millionaire yet? I bet that you write mostly Go so like to convince yourself you’re visionary for having made the right choice. Go read the elixir o rust subreddit and people also say the same shit with very little backing and more importantly very little comparison with other potential candidates (let alone Lang’s that don’t exist yet).... I don’t mean to be mean but I think each language has pitfall, and believing one is superior to all others is simplistic and wrong. (I love go too though :) )
Great article. The thing that still hangs me up and I cannot find good examples of this is what happens if your Adder interface decides it needs a new method. How do all of your middleware need to change to handle a new method? ie you've got Add(x, y int) say as a (bad) example you want a method AddFloat(x, y float32). How do you modify your middleware to handle that? Your WrapCache and WrapLogger methods explicitly invoke interface.Add(). 
On every C/C++ project I've worked on we treated warning as error so none of them would go in the build. Before each build the CI would run Klocwork to check for other errors, level 1-3 errors means build failed. C/C++ has nasty behavior if you're not playing careful. I think this is standard industry practice and Go just enables this by default.
No. That doesn't make sense. If that was the case Google would never have used Go to _replace_ its own existing services.
A C hello world requires a few kilobytes. But we should not forget that Go programs will always have the runtime (scheduler) for goroutines and that `fmt` requires a few packages that are used in all programs anyway. Implying the growth from 1.5 MB onwards is much slower as fewer new things come into play. And packing all of the above into a 1.5 MB binary is awesome.
&gt; But if you've ever done any serious development you'll have, on occasion, commented out a function or a block of code to see the effect or to hunt down the piece of code causing a bug. And often C/C++ would issue a warning that an earlier declared variable was no longer used - but it would still let you compile. No it doesn't if you add the right compiler flag. I worked on projects with over 2 million lines of code written in C/C++. Compiler flag: -Werror : Make all warnings into errors. 
Pretty much everything! Go (and rust) is a low (or lowish-mid?) lvl compiled, statically typed language with ‘garbage collection’ (kinda) and memory safety. It is like a C - Python hybrid. Every time I develope software in golang I feel like im cheating. Its like using a a language with a simplicity of a high lvl language and with the power of a low level one. It is super easy (at least for me) to organize my code and the ‘go get’ tool is pretty much built around git technology which helps building good programming and organizing habits. The go environment is a bit tricky to set, escpecially if you are using multiple building environments, but once you got it set up it is very easy to use. Cross platform compile is very simple compared to C++ which is also a big help for developers. Over all the language feels polished and organized. Every task I do in go feels like using a shortcut compared to other compiled languages. It feels like using a *next gen* programming language, so yeah, it is futuristic (at least for me).
Isn’t more low level control over performance also a benefit to Python?
PHP suffers from the same problem as Javascript to a lesser extent, where they want to be as much backwards compatible as possible, to avoid breaking changes when upgrading. For Javascript this is even worse as you have no control over what browser the user is running, going so far as they chose the name Array.contains instead of Array.includes because some third party libraries already used includes...
how is this the case?
``` func validateFile(file os.FileInfo) bool { if !file.Mode().IsRegular() { return false } return true } ``` This double negation almost makes me angry, how about ... ``` func isRegularFile(file os.Fileinfo) bool { return file.Mode().IsRegular() } ``` In the endless loop you define a label and use it for `break`. Why not for the `continue`'s? That's irritating. Inside the loop you select on several channels and check if the channels are closed. Why do you need to check for closed channels? That feels wrong. If the channel is closed (`ok` is false), then to do a `continue` is certainly wrong: You'll burn tons of CPU cycles! The worker indeed closes channels when done. Why? There are a lot of file system walkers, one of them in the std lib. How does your solution differ and perfom?
Be very careful when you do this this can violate both the 'Single responsibility principal' and the 'Dependency inversion principal'. 1. Structure things together that change for the same reasons. 2. Base your program on abstractions not concretions. And keep the Go proverbs in mind. Depending on the size of your work "A little copying is better than a little dependency". Always go for strong decoupling. And also follow the 'Interface segregation principal': Only require the functionality you are actually using.
Came here for this. I applaud you for your speed.
For instance the ability to use pointers directly. Not saying python is slow btw, just that compiled, lower level languages have a slight edge in doing optimizations.
Sure and there's people who program everything in Ruby, doesn't make it the right tool for those jobs
Your comment seemed to imply that python has more low level control than go
Nothing prevents from packaging virtualenv folder to archive or os specific package. We did package whole ruby bundled (with bundler) application into rpm package, and that worked great.
Oh I meant it the other way around. The scentence was phrased a bit weird by me.
In the current approach it is required to only have a single method for the interface. When the method changes the middleware changes with it, there is no easy way around this. However, instead of using the HandlerFunc approach the interface can be implemented on a struct which implements the Adder and the loggin and propagates the call to an embedded Adder after the loggin is fired. This way when methods are added the middleware can implement the new method. Im not close to my computer but will try to create some example code for this. 
Nice article, although I would suggest replacing "Adder" with something more real-world. Real-world examples are easier to grasp when you are completely new to a concept.
I wrote a twitter &amp; reddit bot in go, and worked out great. The easiness of spinning up multiple threads were great, since I could have a single application work on both reddit and twitter :-) 
Hey BTW I just increased the max git objects to 250k so you should be able to load your project now... I'll monitor it and dial it back if I see GKE restarts. I think 30k was a bit over-conservative. Let me know how it goes!
The most under-rated comment in this thread.
GoLang has the potential to be a universal robotics / embedded devices platform. It's easier to understand and code than C++, it's modern and integrates with existing services (eg: GitHub) and is much faster than Python.
I post here a lot, use Go as my first choice at work, but still use Python pretty often. It's not a bad language. It used to be my favorite. But over the years I've learned that while it is easy to get a program out, there's a crossover point somewhere around a week where dynamic typing goes from advantage to disadvantage. The whole program freezes up and becomes very difficult to refactor, because"what is calling what" doesn't fit in your head anymore. So instead of making the code right as your understanding of the problem improves, you instead make it so that every function and method is reverse compatible with every call that might ever have been made. This becomes inconvenient and an impediment to programming very quickly, and strangles your program slowly over the next couple of weeks. Of course, it takes some maturity and experience to notice this is happening. But I find it nearly inevitable. Programs are complex, and eventually, you _will_ need tool support to manipulate it, even just a simple type system like Go, and Python is basically designed to not work that way. The end result of even a very, very well-done dynamic scripting code base is the same each time... it becomes harder and harder to actually remove anything. It may be easy to add, but you can't ever remove. This property is reflected in the final code bases, once you learn what you're looking for.
What happens in [this line](https://github.com/StirlingMarketingGroup/mysql-get-url-param/blob/d49d05660487d0469b99545c9b599f228bdb9f15/main.go#L60): ``` argsArgs := (*[1 &lt;&lt; 30]*C.char)(unsafe.Pointer(args.args))[:2:2] ``` My understanding is that `(*[1 &lt;&lt; 30]*C.char)` allocates an array with length 1 &lt;&lt; 30 of C.char pointers which means it'd take 64 GigaBit of RAM. Which clearly is not happening here, or you wouldn't report that this was faster than native MySQL. 
Hashing it client side won't do anything. 
&gt; You made 0 arguments as to why lol. You just sound like a fanatic. Sorry, didn't realize you were looking for an argument. &gt; How about elixir? &gt; How about kotlin? &gt; What about rust? All three may have a place in the future too. &gt; If you’re so good at predicting the future, are you a millionaire yet? I wasn't attempting to predict the future, and being a millionaire isn't what it used to be... The reason I believe Go has a place in the future is that it has a place in the present. It is a simple language that is lower-level than most languages and compiles to static binaries. In my 40 years of experience, that's been a very popular position for C &amp; C++. The reason I'm most bullish on Go is that it's very good at concurrency and processor core count is increasing quickly. Languages like JavaScript, Python, Ruby, etc. that can only run on a single core are going to appear increasingly hampered by that limitation for many use cases and I'm confident Go will continue to pick up adherents for it's very nice ability to soak up CPU cycles efficiently.
All of those things plus a native concurrency model that scales nicely on modern processors with core counts growing like weeds AND is easish to reason about. Languages that cannot effectively utilize multiple cores like Python, Ruby and JavaScript are going to need to solve that problem or go the way of the Dodo in time.
"The huge array is just so that the go compiler will accept any valid size, but it's not actually allocated (see some other examples here https://github.com/golang/go/wiki/cgo)." https://stackoverflow.com/questions/27532523/how-to-convert-1024c-char-to-1024byte/27532888#comment43494814_27532888
[removed]
I didn't say it was, just that it is happening. I think a modern Dev shop, at least one that is doing more than just basic CRUD apps, should be polyglot so they can use the right tools for each problem they solve. I think that also means developers need to be polyglot, too.
I have used this before, but only when writing a function that will be called from an HTML/template where constructing a map just isn't possible without some sort of helper function. Generally speaking if you can accept a map I agree that you should just do that. 
You could always just look inside the code: https://golang.org/src/net/http/client.go#L736 ``` // net/http/client.go func (c *Client) Post(url string, contentType string, body io.Reader) (resp *Response, err error) { req, err := NewRequest("POST", url, body) ... ```
https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1
You can do profile using pprof to check the performance hit
I'll definitely try this. The idea just popped in my head. 10 hours (including transportation time) destined to work start to look unhealthy.
&gt;I'll definitely try this. The idea just popped in my head. 10 hours (including transportation time) destined to work start to look unhealthy. For me, work in person for a company, it makes no sense. Tank you so much for the feedback!
Every effort that is possible to change the culture and teach the advantages of the remote work that I can do, I will do.
Take a look at some articles and videos by Uncle Bob. You can use this as a starting guide: https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html
Ironically, one cannot select by Go, because the search results are too small. Mistake: "Which languages do you want to work (with)" Good idea. Nice and simple.
Tanks for the tips. This website have only 4 days living, util the end of the month, we will have much more jobs with Go. :)
So in practice, when you have multiple environments like dev, staging (integ) and prod you’d have a config class that stores all the runtime configuration (like your SQL DSN). You can then set an ENV var like ‘COMPANY_ENV=production’ which would affect which config file is loaded and serialized into your config class. For instance, we have: base.yaml dev.yaml production.yaml In my dev.yaml I have a set of nested structures: ‘datastore.mysql.dsn’ In my main this file is loaded and turned into a config struct that is passed around (similar to your app type) and in my db.go I use Gorm to either create a local SQLite DB for dev or give it a remote connection string for staging/production. For integration tests you probably want to use the same SQL server as production so you’d need a separate SQL database available in your staging environment. When you start the test suite you can bootstrap the DB and schemas- the only difference is you’d pass in a staging config struct then execute the code you want to test and verify the expected result. 
There is also this site: https://weworkremotely.com/ I think they do a good job of keeping the listings legit by charging as much as they do to list a job.
I've written multiple in-house apps using: [https://github.com/go-chi/chi](https://github.com/go-chi/chi) and [https://github.com/olahol/melody](https://github.com/olahol/melody) never really had any issues that weren't caused by me. Melody works with the standard library though, so chi is simply a nice to have. 
Well, this site works with a lot of professions. Eastvox, is only for developers. 
Could you please point to an example of making use of the above libraries? I'm particularly looking for a chat app with groups(rooms) and friends, or a multiplayer game played between two players.
Thanks for this site, I will try.
Tank you so much for the feedback.
Python is wildly slower than go, and consumes far more memory. Why would someone write backend with it? For that matter, why use Python for web dev over JS (which, with V8, is also much faster than python)
Love it!!! Thank you Keep making them!
Mate, it’s nearly 10 years old, with the feature set that’s been around for many decades.
[removed]
Awesome site and great idea. Im unable to search for Go via the search bar (only altering the URL then I can). Second, I think a location field should be added and be filterable. I'm in the US and might not be able to work for a country outside of the US. 
I can't point you at the in-house apps, they are held on a private git server and used in an in-house capacity. The melody docs have a few examples of chat though: [https://github.com/olahol/melody/tree/master/examples](https://github.com/olahol/melody/tree/master/examples)
I did the same thing, especially when I started hitting multi-second performance hitches in ST3 beta and the weird native-look menus in the code completion stuff. The only thing to get used to in VSCode was the alt key instead of control.
Ok, I'd run [dieharder](https://raw.githubusercontent.com/funny-falcon/go-rando/master/test.out/dieharder.out), [practrand](https://raw.githubusercontent.com/funny-falcon/go-rando/master/test.out/practrand.out), [BigCrush](https://raw.githubusercontent.com/funny-falcon/go-rando/master/test.out/bigcrush.out)
 &gt;And what is the good req/s for a service? There is no universal number. It depends on what your requests actually do. If a request had to send 100mb of data each time, you can't imagine 75k/s being reasonable. You can start with a baseline (what you have) and then profile to see if there are bottlenecks. 
Im seriously thinking about you are talking (about location) , is a really good feedback! And sorry for the bug, i will fix. Tank you!
No problem, thanks again for helping me in my job search!!! And the mobile site is perfect. Godspeed on your site!
Try using the [DAO pattern](https://en.wikipedia.org/wiki/Data_access_object). The basic idea is that your database object should be wrapped in an interface that exposes business-logic operations. For instance: type DAO interface { FetchWidget() (*Widget, error) NewWidget() (*Widget, error) StoreWidget(*Widget) error } You would then implement something like a `postgresDAO` that satsifies `DAO`. The win for you is that you can create implementations of your DAO for testing. These don't have to be backed with databases at all (which, is preferable in many cases).
Have you considered using docker? You could stand up a docker env and populate the db with sample data to run your tests. This would just get destroyed every time and keep your live db safe. There is obviously a lot more detail to this and setting it up would require you to familiarize with docker, docker-compose, and maybe write a bash script. The end result is a good way to reproduce a similar env as what your production env looks like and allow you to keep the live db clean.
I believe there are some serious issues in the architecture of your project which contribute to the difficulty of testing. Firstly, you put you entity `Movie` and the data access code `func (m *movieRepo) Read() ([]Movie, error)` in the same layer of the system. This is generally a bad design since `Movie` is the business logic and `func (m *movieRepo) Read() ([]Movie, error)` is a detail (data access). They should be put into separated packages (at least). The second issue is that your data access code is tightly coupled with package `app`. This is not desirable since your data access code is already a low level module and deals with I/O. In your case, you cannot instantiate a repository unless you instantiate an `App`. However, you `App` is really just a connection to the database. I would question if adding such a layer of abstraction is necessary. I believe your data access code should be structured like this: `package dataaccess` `type PostgresMovieRepository struct {` `Database *sql.DB` `}` `func (m PostgresMovieRepository) Read() ([]Movie, error) {` `// query movies` `return movies, nil` `}` In your test code, you can do something like this: `package dataaccess_test` `var movieRepo = dataaccess.PostgresMovieRepository{` `Database: CreateYourDBConnectionHere(),` `}` `func TestPostgresMovieRepository_Read(t *testing.T) {` `movies, err :=` [`movieRepo.Read`](https://movieRepo.Read)`()` `// add your assertion statements here` `}` Note that your connection can be a actual DB connection or a mock connection. I would suggest looking into dependency inversion principle (the D in SOLID principle). This principle can guide you how to structure your code.
• The official documentation — https://golang.org/doc/ • The official "Tour of Go" — https://tour.golang.org/ • The official Blog — https://blog.golang.org/ • Go by Example — https://gobyexample.com/
IMO, Golang is not the best introductory language for someone with no prior programming experience unless you have a specific reason for choosing this as your first language. I would suggest Python as your starting language and for learning the fundamentals of programming in general. Learn a concept in Python, then try and apply it Golang, do both at once if you want. I feel there is more of a beginner community surrounding Python given that it is often taught as an introductory language to people with no prior experience such as yourself. If you're set on Golang though, the links in u/unix15e8's post are a good place to start. Good luck!
buy an udemy course
whee! thanks. I'll be showing it to the snapd team this week. Let me know if we break it!
I feel like the average commute for a lot of jobs around my area reaches a total time of 11 hours. From suburbia to Chicago, I will never do that unless I actually was overjoyed for the type of work.
https://docs.google.com/document/d/1Zb9GCWPKeEJ4Dyn2TkT-O3wJ8AFc-IMxZzTugNCjr-8/edit?usp=drivesdk If I were you, I'd learn how to parse types first. It is a statically typed language. Lots of people from js and python complain about this but the types give you a lot but yeah you need to type check everything.
Some kind of epidemic flu is going to wipe out all engineers in open offices and it will be up to the remote workers to keep the internet operational. 
Go version has bugs which make it produce incorrect results. I don't have it in front of me, but I'll post them next time I do. Caveat emptor.
[https://github.com/raspi/dirscanner/blob/master/worker.go#L68](https://github.com/raspi/dirscanner/blob/master/worker.go#L68) Don't use [errors.New](https://errors.New)(fmt.Sprintf....), it is cleaner to use fmt.Errorf 
So it’s like https://remoteok.io/ ? 😊 I know you’ll say it’s just for developers, but this one is primarily developers, too. 
It's supposed to be the fastest parser, not the most correct one!
I'm just getting into docker myself and wondered how you give the app access to a docker container. Do you just setup docker on a specified port and have a static DB URL where the app checks for the database?
&gt; IMO, Golang is not the best introductory language for someone with no prior programming experience unless you have a specific reason for choosing this as your first language. &gt; I would suggest Python as your starting language and for learning the fundamentals of programming in general. Learn a concept in Python, then try and apply it Golang, do both at once if you want. I feel there is more of a beginner community surrounding Python given that it is often taught as an introductory language to people with no prior experience such as yourself. I would say the opposite. I don't know Python (I looked at it once), but I'd recommend learning it as long as you're going for "results-oriented learning" vs "method-oriented learning"[1] as the language is very simple and (unlike modern Python) still lives with the motto that "there should be one way, and only one way, to do something". So ... 1. You won't accidentally bump into things like list comprehension. 2. You'll still have to deal with types in Python. It's just that they're not explicit. The only problem is that if you're learning programming to find a job, Python is a _lot_ better a language to have on your CV than Go at the moment. [1]. It's hard to define, but the main difference I'd call "learn to write a server," "learn to write a game," "learn to write an OS," or "learn to write a compiler" as "results-oriented learning", while "learn Object Oriented style" or "learn Functional style" or "learn dependency injection" is a "method-oriented learning" 
&gt; go mod instead of vgo That's a huge relief. "vgo" is a horrible, goshdarn imbecilic idea. go mod sticks with the standard of, you know, using "go".
Thanks for the link, this is a useful guide
I like your language filtering, it's a good addition
What are you talking about, lol
I assume you mean via the experimental golang.org/x/sys/unix package? That seems to match the method names you mention. The interface to sysctls are not standardized and are sadly very OS-specific. On Linux they are just presented as magic files in /proc/sys, but I'm guessing you are referring to a BSD instead given the mention of mib-mapping. Where are you seeing the incomplete list of query strings? On Darwin at least, nametomib() (https://github.com/golang/sys/blob/master/unix/syscall_darwin.go#L53) does a syscall to look up the name, which I would not expect to be incomplete.
The proposal was never actually called vgo, vgo was just a tooling prototype. For some reason the community latched onto it as the name of the proposal.
&gt; Do you just setup docker on a specified port and have a static DB URL where the app checks for the database? This is pretty much how it works. Docker containers can bind to ports on the host network, so a postgres container can bind to port 5432 or any other port you want to specify, and your app will just connect to it like any other database endpoint.
It's not as fancy as grc, but some bash aliasing may be able to achieve similar results with [https://github.com/augustoroman/highlight](https://github.com/augustoroman/highlight).
I have a cluster with 3 nodes. Is it possible to extract the statistics of all 3 nodes using just one client?
15 here going to the loop, which is why I work remotely 3-4 days a week (and that's when Metra is on time, which is like saying, "when property taxes go down" around here). If I have internet and a computer I can do my job. Physical presence is required for micromanagers and nothing else. (I've been working remote for a decade and my current job requires the most time in office - which is funny since my entire team is in the UK and India.)
I’m glad to see that vendor is not being uses anymore. Didn’t know that before and didn’t like it being checked into vcs.
Funny, this is exactly the same hierarchy in which my [start](https://github.com/christophberger/start) package fetches options - first, try the command line flag; if it does not exist, look for env var, TOML file entry, and finally the hard-coded default value.
Thanks for sharing. Tip: If you want people to find your project on GitHub (and understand what it is about), describe your project in the readme, and give it a meaningful tag line. 
Thanks for this useful guide to understand the module system in GO.
&gt; For some reason To be fair if the community as a whole latched into it, the reason was probably the way it was presented to the community.
Fair enough. I am also the kind of person who cringes when the language is called "golang", which is a similar story. 
Isn't that mostly for search engines?
The official "Tour of Go" is really simple to understand even if you're new to programmation. You can try [http://exercism.io/](http://exercism.io/) it has many exercises for all level and you can see others people implementations that can help, good luck !
While I can see that it streamlines this language to the behavior of others, I do not like it at all in go. Having the vendors inside the own cvs made it very easy to spot important changes in vendors, made audits simpler, you could skim over updated examples since the last vendor update and much more, not detailing into speeding up and easing ci work.
Thanks. Fixed.
That `validateFile` is just an example. Updated now for your version. Now there's `Close()` for closing channels. Of course it's performance is a bit lower than std libs, that's a bit weird argument. But when comparing how fast files can be sent to be processed, it's faster. The goal is to decouple scanning directories and file processing and thus creating cleaner code. Main idea is to start your own file processing workers before the loop and send paths created by the scanner channel to your workers. This way it's easy to change the processing pipeline. Otherwise this would be coupled with std lib walker and harder to read recursive functions which are passing application specific information around. With `dirscanner` channels you just create easy to read pipelines. 
plaintext ssh passwords in config? i know you want automatic login but please dont use plaintext passwords 
As /u/Cabraca says - and DO use public/private key-pairs to login to a server "without a password". That is the _only_ right way to do it. Here's a good article about it: https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server
private key supported also. It is the private tool.
That is one approach. You can also create a docker network but that may be more than what you need. I would definitely recommend reading the the latest docker docs. I would also say be careful with some of the tutorial people post. Not that they are bad but be mindful of the version of docker-compose they use. There have been added features that change the ideal work flow with docker-compose. So I would try to stick with the official docs or anything that is at least posted very recent.
It looks like `melody` is not actively maintained!
Yes, use key-pairs is the good practices. But consider: if there have a spy application which reads your \~/.ssh/xxx files, you lose everything. so i think, random strong plain password is good too. and also you have to protect your data, DO NOT run the app you do not trusted.
People accidentally commit their passwords all the time - committing a path to your private key is not a problem, though. privkey: ~/.ssh/id_rsa Committing this line to a repository would not mean anything. Committing a line with a password _would_.
I have not had time to explore this yet. This would completely replace dep though correct? Pretty cool.
Ideally, you would _not_ commit your `vendor/` directory, only your package and lock files (e.g. `Gopkg.toml` and `Gopkg.lock` for `dep`). The whole idea behinde the lock-files is that you do not need to commit the actual package files, as they will be installed when you run `dep ensure` later, after cloning a repository.
the config file located at \~/.sshw
I didn’t check them in, however many projects did in case the source of the library went down. 
If they didn't, and the source went down, you'd have a useless project anyway. I don't see the problem, really. I've been on projects where we checked `node_modules` in as well, because it was an old project and we had already lost some of the old versions that were used.
Well, i see a lot of diferences. If just the same thing, i would not create another website. But, thanks for all.
Thank you.
Not sure honestly, it's not something I've thought much about _(unlike improving error handling)_
I promised to make an example. When using structs it's easier to add new methods because the wrapper functions don't need to change For example: ``` type loggerMiddleware struct { logger *log.Logger next Adder } // Execute propogates the execute call to the embedded next service, loggin all the input and output values func (lm *loggerMiddleware) Add(x, y int) (result int) { defer func(t time.Time) { lm.logger.Printf("took=%v, x=%v, y=%v, result=%v", time.Since(t), x, y, result) }(time.Now()) return lm.next.Add(x, y) } // NewLogginMiddleware returns a adapted version of s where everything from the arguments to the results are logged with the given logger func WrapLogger(l *log.Logger) AdderMiddleware { return func(a Adder) Adder { return &amp;loggerMiddleware{ logger: l, next: a, } } } ``` When new methods are added to the `Adder` it is only required to implement them on the `loggerMiddleware`. I hope this answers your question.
I think Go is a great introductory programming language. The language spec is simple, but it is low level enough that you learn how computers actually work as well. I did a series of videos a while back aimed at beginners, you may enjoy it, its free: [https://gameswithgo.org/](https://gameswithgo.org/)
Then GitLab or GitHub needs a way to ignore the folders in de diffs.
It was only `vgo` so that you weren't replacing your Go 1.10 binary with a prototype tool. It was never going to stay as `vgo`.
There's probably still a lot more material aimed to those that know some other programming language, and plan to learn Go as a second (or third, or whatever). It's much easier for an author to start from that perspective than to start from a complete beginner.
How is interface okay? You lose type safety/autocomplete
A bit of a Go proverb is "accept interfaces, return concretions". You could avoid importing the `testapp` package altogether in your `clients` package if you didn't reference the interface in there unnecessarily. It can help you avoid circular dependencies, and make your code clearer. Plus, it frees you up to use interfaces in a better way, by [defining interfaces where they'll be used](https://github.com/golang/go/wiki/CodeReviewComments#interfaces). This makes testing easier, and makes your fakes / mocks smaller to write too, and once again can help you avoid circular dependencies. IMO having a `mocks` package is a bad idea, you can just make an `exports_test.go` file with your mocks in for a specific package. If you combine all of this, your interfaces and subsequently mocks will be smaller, and your code will be less brittle.
[removed]
the mongodb approach.
It would be great if this can use configuration files from grc [https://github.com/garabik/grc/tree/master/colourfiles](https://github.com/garabik/grc/tree/master/colourfiles)
I always check in `node_modules`. I don't trust npmjs.com and I don't want the fate of whether or not my project can be built in their hands.
If you can do some task 75 times a second and then you change the task to be 15 times as much work, you're only going to be able to do it 5 times as second. It's just math.
Yeah that's the package I meant. The platform I have been using is OpenBSD, I didn't realise there was such variation in how sysctl's are implemented. The OpenBSD `nametomib()` function is [here](https://github.com/golang/sys/blob/master/unix/syscall_openbsd.go#L36). The lookup table used by that function is [here](https://github.com/golang/sys/blob/master/unix/zsysctl_openbsd_amd64.go#L13). The entire source file containing the lookup table seems to be generated by a [perl script](https://github.com/golang/sys/blob/master/unix/mksysctl_openbsd.pl). That table for example doesn't include the entire **hw.sensors** section for accessing information from hardware sensors. As far as I can tell there is no way to just send a blank sysctl name and then put the entire mib in the "args" array. Would this be the kind of thing where it would be useful to submit a patch.
Considering the track record of the NPM Registry, I wouldn't scold anyone for doing that - quite the contrary.
If the project went away but the vendor dir was in vcs, why would their project be useless?
Thanks for the writeup. I added a longer comment on the post itself, but please note that one very important command is missing: 'go get'. 
I have a contrary opinion (currently). When Google Code shutdown go-snappy moved and broke a building a bunch of other 3rd party packages we're using that depended on it. I swore never again and started vendoring everything. Go modules are only part of the solution. Until there is a canonical source of packages (and/or modules) ie rubygems, crates, npm it will not eliminate the need to vendor packages for availability. Yes, I am aware of the 'set up a proxy argument' and that I can use a file:// url effectively giving us a vendor folder, but it remains to be seen how clunky this will be in practice . Note we're not switching until Go 1.12 time frame (we're using gb at the moment and it works for us just fine) we'll know before then probably.
Thanks for putting together the gist. Looking at it I still see "handlers" and "models" monolithic packages which you seem to warn against. I also see the actual code dealing with "users" split up between two packages which doesn't seem to be correct either. At the same time, spiting up the models package into book,user,comment,25x more packages etc... seems like it would greatly reduce the amount of boilerplate code required to share the database pool with the packages and share the package http handlers with the main.
A lot of this critique makes sense, but I have been unsuccessful in figuring out a structure that can accommodate all this while still being easy to use and test. Can you provide an example of a better package design to satisfy these requirements?
_Ideally_. I totally understand and agree with the practice of committing vendor directories when it makes sense, but _ideally_ we shouldn't have to. The fact that is is sometimes necessary is a symptom of a broken source of packages. 
Just found a good article that discusses package structure: https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1 
Agree 100%
If you _did not_ commit the vendor directory to your VCS and the source of any vendor library went down, your project would be useless unless you could procure a compatible version or write one yourself.
Completely understood, I've given it a description closer to the style of the title of this post, and a full readme with examples and very thoroughdescription :) [https://github.com/StirlingMarketingGroup/mysql-get-url-param](https://github.com/StirlingMarketingGroup/mysql-get-url-param)
[removed]
I guess that depends mainly on the implementation of the writer. in general, `*os.File` should be safe in the sense of "your program won't crash" but probably not in the sense of "the contents of the file afterwards make sense". For other writers, all bets are off. It's pretty easy to wrap any `io.Writer` safely though: type muWriter struct { mu sync.Mutex w io.Writer } func (w *muWriter) Write(p []byte) (int, error) { w.mu.Lock() defer w.mu.Unlock() return w.w.Write(p) } 
If I understand correctly... If you have 2 separately instantiated loggers that both happen to point to the same underlying file, they will write on top of each other. This isn’t an issue of thread safety but a lower level OS thing. They have both grabbed a handle on the same file.
I like how it uses github.com/emersion/go-imap. There is a list of "Missing Features", but it doesn't include search. Is this something that could be added?
I have the same, what do I need to do?
There are multiple ways to do it. The simplest is probably to do something like type Feed struct { XName string `xml:"Name"` XLanguage string `xml:"Language"` } func (f *Feed) Name() string { return f.Name } // ... Another way would be, to have two structs: One struct that you use for unmarshalling and which is a field in a second struct which you use to implement the interface.
This sounds great, nice work !
London is a strong market and definitely, I've seen positions for junior gophers. Keep looking, they are there. (Or perhaps they've all moved to the continent due to the Brexit...) With that said, keep your options open and look for other programming languages, like Python and C.
You should be able to get around the `Sysctl` function by using generic `Syscall`, like this: ``` func sysctl(mib []int32, out unsafe.Pointer, n uintptr) syscall.Errno { _, _, e := unix.Syscall6( unix.SYS___SYSCTL, uintptr(unsafe.Pointer(&amp;mib[0])), uintptr(len(mib)), uintptr(out), uintptr(unsafe.Pointer(&amp;n)), uintptr(unsafe.Pointer(nil)), 0, ) return e } ``` where `out` is a `unsafe.Pointer` to a struct you want to get out (defined as on C side, might get tricky at times) and `n` is its' size (in bytes, `unsafe.Sizeof` might be of help). FYI: I've done it this way in my [battery package](https://github.com/distatus/battery/blob/master/battery_openbsd.go), because (at least at the time I was writing it), the aforementioned Perl script was whitespace specific and one of the MIBs I needed had different spacing in the header than the others. Dunno if it was fixed on either side. It was related to `hw.sensors`, too, I think, so it's possible you're hitting the same issue, but I don't remember the gory details ATM.
I will add a credits-section to the README. The project wouldn't be posisble without that library (and the MIME-parser). I've written MIME-related code before, in C++, for a console-based client. It is not easy.
I found a full-time Go developer job after applying for a C++ position. During the interviews, I asked my now co-workers why were they advertising the job as a C++ position, they were surprised and after a quick call with HR they realized that both the hiring manager and recruiters misunderstood the phrase _"[…] Go with C++ experience"_ as _"[…] go with C++ experience"_ _(notice the lowercase "go")_. The recruiters thought that the company wanted a C++ programmer rather than a Go developer with some C++ experience.
My 2 cents: don't "devote" yourself to any particular language. Sure, everyone has a favorite at a given point in time, but at the end of the day what makes you a good engineer is understanding concepts, seeing recurring patterns and figuring out what works best in what scenario. Any reasonable company won't give a damn about how idiomatic your code in languages X, Y or Z is, as long as you are able to learn as you go. Now, with that said: play around with a lot of languages. Lean on what their main features/ecosystems are strong at to learn key concepts: Java has great tools for Dependency Injection; Go is an awesome way to learn concurrency using message passing, while Elixir is great for learning actor-based concurrency (Scala+Akka is another option but Elixir is tiny in comparison); Python can teach you concepts such as generators and yield/await based concurrency; cranky old man C is great at forcing you to learn memory management; etc. etc. etc. So, it's perfectly fine for you to love and enjoy Go, but also learn one of the languages that you perceive as easier to get you in the market. You can always convince C programmers to move to Go, and Python programmers are low-hanging fruit too, hehe.
I would say none, and get The Go Programming Language book instead. Perhaps different people have different preferences, but for me personally, I don't understand why people would learn programming languages from a video course.
Good project, but this subreddit is for programs written in golang specifically, not programs written in a different language that will help with golang
Where at in NC? 
&gt; Which Udemy course I should get ? None of them. Taking a look at the curriculum of those two courses, I wouldn't pay $25+ for that. I would invest that money in one of these two books instead — https://www.golang-book.com Learning about concurrency, error handling, basic data structures, and things like that _(which seem to be the main topics of those two courses on Udemy)_ is easier if you read the information available in the official documentation website — https://golang.org/doc/ — which includes much more accurate information about the language and all its features.
So. Much. This. Never call yourself a &lt;language&gt; programmer. You're a programmer. Language is a tool. 
Lol I don't pay in USD currency so courses are relatively cheap for me. But I guess I look into boks you guys recommended.
&gt; Thanks for putting together the gist. Looking at it I still see "handlers" and "models" monolithic packages which you seem to warn against. I also see the actual code dealing with "users" split up between two packages which doesn't seem to be correct either. Do you mean because the mock is in the handlers package? That is intentional. One other way to look at this is; what if your concrete type was a larger, and had say 3 or 4 methods? Maybe you only use one of those in that handler, or in any handler for that matter. With the interface defined in the handlers package, along with the mock (which also will only be compiled into test code too), you can define an interface that satisfies only the methods on your concretion that you use. This keeps your mock smaller, and your tests simpler as a result. With regards to `models`, I only chose to use that here to keep it closer to your example. I think `handlers` can be okay, but it depends on the size of your application, and whether or not it's under another package that gives even more context in that case. &gt; At the same time, spiting up the models package into book,user,comment,25x more packages etc... seems like it would greatly increase the amount of boilerplate code required to share the database pool with the packages and share the package http handlers with the main. That is an interesting concern. It sounds like this application you're making is quite complex. Perhaps having more packages then is just part of having a more complex application? There would be overhead in terms of having to write more types and constructors, etc. But at least your types would all have their own concerns. I'd argue that splitting all of those types out will make it clearer what is going on in your application. For example, when you actually came to use some of those 25 different packages, if you were pulling those together to be used in another type like a handler, then you'd probably be making a constructor that takes a dependency from each of them, like: // Note: You'd probably be using interfaces here, // but then again, maybe you don't need to? func NewFooHandler( booksGateway *books.Gateway, usersGateway *users.Gateway, commentsGateway *comments.Gateway // ... so on ) *FooHandler { // ... } This might be verbose, but it's also very clear and explicit about what types of data it's accessing. Contrast that with: func NewFooHandler(gateway *models.Gateway) *FooHandler { // ... } You couldn't tell me look at that constructor what types of data are being accessed there. (Not sure if this is a more extreme example here, maybe you do still have a bunch of different types, but in that case, I'd argue that the boilerplate is much more minimal, as it's basically just about making a new package in that case).
Most likely this will be platform dependent as your application would be relying on the OS's filesystem handling of concurrent writes. I suggest writing a concurrent safe `io.Writer` which ensures the writing to the underlying content is safe. While you're at it you should consider if it makes sense to just implement a custom `log.Logger` if you're only using multiple Logger's for their prefix capability.
Are there Go meetups in London? Perhaps you can find out where other folks work and whether they have junior positions.
After receiving feedback on my original [application layout](https://www.reddit.com/r/golang/comments/8zn2ti/how_to_handle_dependency_injection_and_mocking/) I have created this sample application to give more flesh to the articles and recommendations. I am looking for feedback on the design of this system which is based on the [Standard Package Layout](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1).
I'm going through the second course (by Stephen Grider). I think he's a pretty good teacher. I haven't tried the first. He goes through a small application (a card game), then goes through syntax. It's maybe 6-8 hours total (I'm still not finished though). You can probably search for a coupon to get it for less (US $10).
Thank you, I created a new repository to attempt to [put some of this to practice](https://www.reddit.com/r/golang/comments/91a54y/proper_structure_for_a_dependencyinjection_based/).
[removed]
👍
I’ve done the second one by Stephen Grider too, I’ve done a couple of his other courses too and found them to have a good pace and explanations
Avoid Todd Mcleod. I got his course (in the past I've found Udemy pretty good). He made me want to punch something (preferably him) - incredibly huge amounts of waffle. A lot of talk for very little content (I got about a third of the way in and we hadn't done much more than setup and hello world) - he makes a big deal out of being spontaneous. I see how this would he a strength in a classroom, where you adjust to what the class needs. But on a video course it comes across like he couldn't be bothered to plan or edit. He often doesn't cover what he said he would in a video, for example. - he has the camera on him. A lot. It takea up a quarter or more of the screen. This means you often can't see all of the slide or code. - he likes to say "balls", and then laugh like a frat boy. I went and got SAMs 24hr golang book. It also has its weaknesses, but if you're after a quick race through the basics, nicely structured for you, it's good enough (assuming you've programmed before). And it didn't make me want to commit random acts of violence.
75k / 15 = 5k Whatever is happening in that loop is certainly the culprit.
Like most things in life you may have to start out not doing what you 100% want to. Get your foot in the door with whatever language you can and go (no pun intended) from there. To be honest it's kinda weird to only focus on one language though, you should be able to code in whatever you need to to get the job done. Go is a great language but it's just a tool. Use the right tool for the right job, don't be a one trick pony.
Second this. I work at Red Ventures and we’re actually in quite a hiring boom right now for developers.
Thanks for feedback, unfortunately Charlotte is 3 hours away from me, since I'm in Raleigh. If possible, can you say what exactly you are looking for in Go devs? Go is not the only thing I know, but it's still kind of daunting looking at job descriptions of some of the job ads.
Or you could consider the code in there important and actually understand what you are adding to your code base.
Well, I don’t work with recruiting or anything, so I can’t tell you officially what they look for, but from what I’ve seen, and my own experience there, we’re not nearly as concerned about your experience with Go specifically as we are with your development experience overall. In terms of specific Go things it’s nice to have some experiencing building API’s and building them clean and testable (onion architecture, dependency injection, etc.) Its nice to have enough experience with Go to know what you don’t like about it and would change, beyond the general stuff people squabble about (“no generics”, etc.) Even if you specifically apply for “Golang Engineer” they’re still gonna be more worried about your overall development skill than anything else, like, “given this type of app, how would you model and store the data?” “Would you split this app into micro services, and what might that look like?” Etc.
All sources outside your vendor dir are broken at one point or another.
I ended up taking your advice and implemented a custom logger. I also forced it to accept a wrapped version of a writer that implements a mutex so that those handles can be passed around to other loggers without fear of creating implicit nested mutex's. package concurrent import ( "io" "sync" ) type Writer struct { w io.Writer mu sync.Mutex } func NewWriter(w io.Writer) *Writer { return &amp;Writer{w: w} } func (w *Writer) Write(p []byte) (int, error) { w.mu.Lock() n, err := w.w.Write(p) w.mu.Unlock() return n, err } type Logger struct { w *Writer } func NewLogger(w *Writer) *Logger { return &amp;Logger{w: w} } // ... Info, Error, etc. 
Looks like the [mattermost project](https://github.com/mattermost/mattermost-server/) uses a [store interface to wrap all their individual entity store interfaces](https://github.com/mattermost/mattermost-server/blob/master/store/store.go).
I think you are misusing interfaces in your example. They are used to provide behaviour, not simple getters (since there's no relation to state). So, I'd consider the following example: [https://play.golang.org/p/skbqioJVEsd](https://play.golang.org/p/skbqioJVEsd) Now you can pass your Feed around as an object and have access to its fields and it's creation is completely separated (and implementation-agnostic) in reusable manner.
I took this course about 1.5 years ago and really liked it. He was pretty good about keeping it updated, so you should be good to go. https://www.udemy.com/learn-how-to-code/
"ContextInjector" should probably be named something like "BooksService", "BooksContext", "AppContext", "AppData", or "ServerState". It may fulfill an interface called "ContextInjector", so in a way it may be a ContextInjector, but there may also be a UsersService which is also a ContextInjector that holds an entirely different set of contextual data than BooksContext. It's incidental whether the hypothetical BooksService and UsersService are served from the same HTTP service. On that note (and I'm likely to take flak for this), I would have preferred that the http.Server type been named http.Service, and the http.Handler interface been named http.Server. Naming is difficult, but it's helpful to name things such that there is emphasis on structures being state containers and interfaces being classifications of behavior (which, for interfaces, is the current guideline). Generally avoiding the naming of a data structure by it's behavior can be a great help down the road.
There are very, very few Go programmers for whom Go is their first language. So "entry-level Go programmer" is mostly not a role that exists in organizations.
I don't have a "ContextInjector" in my codebase, so unfortunately I am not sure what you are referring to. I agree with the struct/interface naming not totally be worked out yet, I was just trying to get a shell into place for "structural" review of the code. 
This sounds really cool. Looking forward to seeing a few more of those checkboxes getting ticket on the README. I plan to evaluate Kafka for a project at some point and I am hoping Liftbridge has made more progress by that point (3-4 months) 
What do you view as senior level skill requirements?
Ah, right, sorry. That was a link from your readme.
Todd Mcleod's courses at the greatercommons.com are updated versions of his udemy courses and are much more concise and better overall. I highly recommend them. I also recommend the book 'Getting programming with Go' from manning publications for beginners. My other two go to Golang books are 'The Go Programming Language' by Alan A. A. Donovan and Brian W. Kernighan and 'Introducing Go' by Caleb Doxsey. 
Out of curiosity, which items on that list (or not on that list) are of particular importance to you?
This is a chat service that when the server is running it allows you to access a dashboard through the browser: https://www.igniterealtime.org Also stuff like phpMyAdmin comes to mind. 
I'd equal senior level skills as experience learned with time? \- High scalability &amp; availability \- Distributed systems \- X+ years of experience with Y in production environment
You should not be using two loggers in the same package. It is entirely implementation dependent if they are thread safe but as long as they can take an io.Writer you can implement thread safety yourself easily.
My eyes may have been playing tricks on me but I swear that when I just looked earlier, configurable acks was not yet checked :) Configurable acks, Log retention by message age (message TTLs), Log compaction by key Embedded nats.io server sounds pretty useful for being able to spin up a cluster of Liftbridge nodes that provide their own nats cluster under the hood, and not have to also run the nats cluster 
I've been doing just this in all of my projects and have not only not had any issues, but vgo has resolved some sporadic issues I'd been having with upstream breakages in one of my projects with deep dependency trees.
Hey, I just messaged you. I write Go at RV and happen to be one of the technical interviewers.
Cool, i'll try this out sometime, I still use Squirrelmail, lul. I'm running Dovecot too so will try it with that.
I mean, gorilla websockets, github.com/gorilla/websocket, is imo the defacto one to use. Really simple straightforward way to upgrade a connection, and at that point it's standard sockets. I use it at work for writing real-time (not like hard real time but obviously websocket real time a la streams) interfaces for one of our pieces of software. 
That helps! It's more to showcase the idea. Thanks!
I was happily surprised to see almost not external dependencies. Good work! I'm interested in trying this out in a few weeks when I finally get some time!
I've got an allergy to PHP, so I'm running something called [Prayer](https://packages.debian.org/prayer).
Not sure about microsoft policy and strategy for Github... But I expect, no change. Because, seriously why should be? It's like you would consider that your can't run chrome on macOS as it use Safari as a main web browser. 
Hmm, interesting work. can you exmplain to me here exactly whats happening?
Isn't hte op talking about change of import paths when moving projects from Github to Gitlab. In reality I don't think many projects (at least that I know of) moved, I moved my own projects but they had very little users, my most popular projects was only around 43 stars.
I’m sort of meh about the whole thing. If they decide to screw everyone over projects *will* migrate away to something else. I don’t trust Microsoft any more or less necessarily than Google etc. It just comes down to trusting open source and open standards and moving and forking when it’s not working out anymore. If I were Google I’d be looking to make a strategic move off of it I guess. But what do I know. I’m just a cog. :)
But there was any move from Microsoft around Github policy that you decide to make that move? 
Also, back in the day Go used to be on Mercurial and then Google’s Git and then GitHub. The project just kept on moving forward through the change. Whatever happens it’ll work out.
Go to Run | Edit Configurations... | the confirmation you currently have | Kind and select Package. Or right-click on the directory that contains the files and choose Run.
It wont affect anything, stop this unfounded panic that Microsoft will some how fuck up GitHub..
\&gt; Should UserService become a monolithic StoreService or should we add 20+ more \_\_\_Service interfaces? If you create \`\_\_\_Service\` then you can swap out a database type for each data type. This might be nice if a KV-store is more performant for storing some domain objects. And I don't think adding all the functions on one type is simpler/easier that having 20+ types. Creating 20+ types sounds like a lot of effort, but creating one object with 80 functions does not sound like fun either.
Yeah, I think I can do that, but the structure isn't quite the same. I'll see what I can do this weekend.
I think your searchable keywords shouldn't be hardcoded. Until then, we'll be getting "javascript developer" jobs which are actually postings for Rails, and "Java Script" instead of "javascript" as a potenital search query, and no ability to search for things that users actually want to search for, like "go"
I love the simplicity (from a consumer's perspective) of NATS and NATS Streaming, so I will keep an eye on this project. However, I'm not sure what benefit this brings over NATS Streaming -- even though there are some words about it in the README.
Navision, aQuantive, Nokia and some others want to talk to you, but cannot reach you through your Skype account, somehow.
I think they are doing this more for IoT and embedded systems, or the new ARM Windows laptops with Qualcomm chips. They already have an IoT version of Windows 
I'm not sure if I fully understand your question, I have my reasons why I moved and you don't have to agree with them but since you asked, I just have a really hard time trusting Microsoft due to their actions in the past, but also I don't really believe their recent "love" for open source and think it is somewhat fake, especially if they are still actively pursuing patent threats against companies that simply use Linux. I think last one was January 2018 so it's also happening under the "new" Microsoft as well. Also WSL is doing damage to Linux growth somewhat and the next generation of developers and people aren't really noticing it, what I am seeing is the next generation of developers staying on Windows while they could and should be moving to Linux. On Reddit python every second developer is asking how to install Python libraries on Windows or how to turn their Python program into an exe and that makes me somewhat sad. Going back to the original question, it's personal but I have been working very hard to be "Microsoft free" and was devastated when they purchased Github, I simply felt if I did not move my repositories I was cheating myself. I don't use VSCode, don't use TypeScript, shut down my Microsoft account, Skype account, but they keep coming back... it's really difficult to be Microsoft free.
*beep beep* Hi, I'm JobsHelperBot, your friendly neighborhood jobs helper bot! My job in life is to help you with your job search but I'm just 309.4 days old and I'm still learning, so please tell me if I screw up. *boop* It looks like you're asking about job search advice. But, I'm only ~18% sure of this. Let me know if I'm wrong! Have you checked out Forbes, LiveCareer, TalentWorks? They've got some great resources: * https://www.forbes.com/sites/karstenstrauss/2017/03/07/job-hunting-tips-for-2017/#794febea5c12 * https://www.livecareer.com/quintessential/15-job-hunting-tips * https://talent.works/automate-your-job-search
In my city, Tokyo, there are few gopher jobs in long-established companies but in young one, some jobs exist even for non-graduated. So, there is more possibility in younger companies.
What is the justification for the separate mock directory? It doesn't seem intuitive to have all mocks separate from the interfaces they implement along with the tests. A mock is just an implementation of the interface, in this case storage, so why not just place it using the same convention as mysql/sqlite/redis etc?
I'm an novice, so I want to know an question for future use. Why you separate commander and boilerplate as other repositories? Recently, I often see \`repo/cmd/foo\` directory strucutre in some projects.
I wanted to separate them so the boilerplate is not fetched when including the dependency in your project.
Thanks for the pointers here. That function is basically what I was looking for as a generic alternative. I'll be using that in place of what I was initially trying to do for this project. Its also a good excuse to investigate the unsafe package.
Thanks!
Thanks for that. If this helps I am not a fun of Microsoft either, yet I need to give them credits for VSCode.
I've played around with it a bit with 1.11beta2 by converting a couple of my projects over to it. It's definitely looking nice, although they're are a few things I could complain about. I think my biggest problem right now is that tying the version to git tags makes it kind of difficult to have multiple modules in one repo.
Knew about the first one but not the second one. Cheers!
I haven't scaled this up to "huge" yet, but I don't immediately see a reason why it wouldn't. My app structure makes heavy use of composition and "environment objects". I have a core environment object shared by everything that defines logging, the top-level supervisor (since I use my suture library), the top-level HTTP ServeMux/router/framework/whatever you like, the top-level time abstraction, database connectivity (but _not_ any database querying, just the connection), and a handful of other things. This environment objects gets a function that constructs the null/mock/logging/test version of the object. (Usually it's obvious what to do; logging -&gt; either print it or ignore it, http -&gt; go ahead and instantiate the router, time -&gt; use the test time object, etc.) I then break my app up into functional pieces. Each of those pieces then defines its own environment, which composes in the core environment and adds anything else it may need. If I need specific DB queries or functionality, I wrap those things behind an interface, so I can swap that out via DI. (If I can, I like to get that into a separate module in a subdir below the module using it, to make the interface into the DB clear to both the user and the compiler and ensure I have a very, very sharp delineation between my storage and my logic.) In fact, I may well declare an interface per method, and mix &amp; match for each function, so to test a something that needs to "query the user's name and then post the comment with their name" I may very well declare an interface that contains exactly those two functions, so in the test code I can easily provide a test object that does exactly that. I also have a function that creates a "default testing" environment. These modules I keep as small as possible, and provide a clean API out of them. Since I'm mostly doing REST interfaces, I often end up with a "handlers.go" file. These handlers are _just_ dealing with HTTP; what type of request? What type of form? All they do is unpack the HTTP request somehow, and then call the appropriate implementation that lives in another method with the right environment, and then handles returning the output to the user. As little logic as possible lives in the handlers, because the handlers are much more annoying to test. Plus logic in the handlers is where you get security issues; if all their "actions" actually pass through a small, carefully-defined internal API interface you have a clear view of what's going on from a security perspective. In theory nothing would stop further subdivisions into modules that may then compose their own environmental things in, though I don't have to do that very often. Frontend I handle as a separate project; I've only had REST so I don't have solutions for templates or images or whatever. In many other languages, this sort of fully top-down configuration, where the very first thing you do is construct your environment with your services in it, and it gets passed to everything, is a foreign concept because it's quite inconvenient in an OO language that lacks composition as a first-class feature. (For reasons that got too long when I typed them out, inheritance doesn't quite fit, which is evidenced by the way it isn't used for this.) In Go, it's really quite easy to have this sort of top-down, tree-based configuration and environment. The primary job my "main.go" files have is assembling the runtime environment and starting up the services that way. With this approach, I can "unit test" almost everything in my system. The unit tests consist of: 1. Set up the core &amp; supplementary environment using the function that creates the test versions. 2. Modify the environment with any of the "real" services I may need, or injected dependencies. 3. Run the tests. 1 &amp; 2 can easily be refactored out as simple functions if you do the same setup over and over again. Integration tests get messier, but I often still have the same pattern as before, it's just that 1 &amp; 2 may get more complicated by loading a real database with sample data [1] or something. Usually you can still just use normal factoring to isolate this into a function or set of functions so the tests have only a handful of lines of "prelude" before they are doing non-trivial tests. [1]: One of the things I do with databases is only _ever_ create them via code, so I can always create a new one in the tests and tear them back down. I also _always_ add an abstraction layer so that I have a mapping layer between the names of the tables/schemas/whatever that my code uses, and the actual names in the DB. I can always bring up a database that has all of its interconnections and relations (or whatever is appropriate), but is independent of everything else. So I can run integration tests in parallel. Often this keeps them fast enough to run at least as part of my commit hook. `SELECT whatever FROM table WHERE ...` is a code smell anywhere that appears in your code and `table` is hard-coded! (In MySQL, you may be able to change database, but since you can only have one default DB at a time for a connection, I often just write the mapping layer to go ahead and provide the full `database.table` for everything anyhow.) Having done this for the past couple of years, let me tell you, this mapping table _ought_ to be a default feature in any sort of DB access library! It is just _awesome_ to be able to run eight integration tests simultaneously on one DB. If creating tables/schemas is slow in your DB, adding a function to nuke an existing DB setup and empty it out is great, too. DB integration tests are ultimately inherently slower than a unit test, true, but they don't actually _have_ to all be tests that empty all the tables, restart the database server, create all the tables from scratch, and finally start doing the integration testing, _and_ have to be run sequentially to prevent them from stomping on each other. My current DB integration tests have a roughly 5 second up-front fee to create the tables, then they all run pretty quickly on their fresh tests, and I am confident in my cleaning code because the list of tables to clean out between tests comes from the same list of tables that it created in the first place. I'm on Cassandra here, so no relations; just TRUNCATEing them in order works. YMMV on relational DBs. At the moment I'm just living with the 5 second startup, but I've also considered hashing the table creation statement and storing the hash in the table metadata, so the test suites can start up, notice the table they were going to create is already there, and use those instead, at which point I'd have "database integration" tests that essentially function at unit test speeds, as far as the human is concerned.
I think that modules offer an improved path with the "replace" directive, and the support for proxies (https://github.com/gomods/athens). That said, I think that the level of fear mongering and paranoia are a little excessive, especially if you're getting sad that people want to use Python on windows (it's been under-supported for years by people who've honestly been quite dismissive of a whole segment of users and needs).
I'm the second top contributor to NATS Streaming, so Liftbridge was applying a lot of the things I learned while working on that. I would say the biggest difference is that Liftbridge augments NATS instead of replacing it. With NATS Streaming, it's a separate message namespace. This also means Liftbridge supports wildcards since it's just NATS (NATS Streaming does not). The other big thing is scalability. NATS Streaming does replication to the entire cluster through a single Raft group. If you have 10 servers and 1000 channels, they are replicated to all 10 servers. Liftbridge allows replicating to a subset of servers and does not have a single consensus group. If you have 10 servers and 1000 channels, you could have each channel replicated to 3 servers and balanced among the cluster.
event.go: There are a series of if statements that are comparing the same value, header.Key. A switch case seems appropriate. Starting here: [event.go#L24](https://github.com/sysco-middleware/commander/blob/master/event.go#L24) switch header.Key { case ActionHeader: event.Action = string(header.Value) case KeyHeader: ...
Thanks! I changed it to a switch statement. [https://github.com/sysco-middleware/commander/commit/a42f933c554228c565042da3be365ea2cfa8ec7b](https://github.com/sysco-middleware/commander/commit/a42f933c554228c565042da3be365ea2cfa8ec7b)
To be fair, any healthy area/topic has various alternatives / competitors. It already existing is not a reason to not make something similar/better. If it didn't, you'd be putting all yours eggs in one basket.
I have been using go for a few hours now and decided the best way to learn is write a small package. Any comments suggestions on my code would be much appreciated. I don't know what the best practices are for writing go modules so I am very interested in the feedback!
This was based on the recommendation by "Standard Package Layout". I think the goal in this case is not a one-off mock, but mocking an entire dependancy. For example, while testing code that uses a database/store (like UserService) you can use the real `/mysql` package or you can use the `/mock` package. (which probably should be `mock/db or some better name)
Three quick ones: • Remove the getters, they are superfluous if the fields are exported (also think of a more descriptive name for the Get func) • Don’t log.Fatal in Get. Return the error instead. • Run gofmt on your code
This is great. Thanks for your contributions and explanations!
How can I return the error if the function is expected a return of type Stock?
The idiomatic way is to have multiple return valeus, i.e. changing the return signature of the function to `ReturnT, error`
Thank you for taking the time to write all this out. I'm going to have to read it over again as I think about what you mention. Do you have any examples of this tree of nested packages, grouped by function, and setup by environment objects? For me, figuring out how to setup a supervisor or environmental object is probably the biggest challenge in organizing each module, but especially the "root".
Gonum has you covered for many of these ops: https://github.com/gonum/gonum Native BLAS impl (with bits and pieces vectorized). I think for complex128 it is not native rn unfortunately https://github.com/gonum/gonum/tree/master/blas
[CloudFlare has covered this pretty thoroughly](https://blog.cloudflare.com/exposing-go-on-the-internet/).
This is ok, but don't forget to close the pipe writer wt the end, after io.Copy.
Tank you for share your point of view. I completely agree.
Yeah, this is a dummy implementation for illustrative purposes. 👍
Biggest problem for me is that editor tools have no idea how to work with modules. Goimports seems to croak when seeing a versioned import, and will not add an import to a module you have in your mod file
Please don't use leading underscores in variable or type names. This provides no benefits and only makes your code look ugly.
Lol, I was going to link to that when I click through.
I don't have a public example because it's all private. [Suture](https://github.com/thejerf/suture) was originally written to be like Erlang supervisor trees, but one of the nice side effects of using it is that it provides a modular way to add "services" to a program coherently. A module's initialization process (creation of its sub-environment) can add any run-time services it needs through a common interface. I [document the environment object here](http://www.jerf.org/iri/post/2929). Bear in mind it's a term of my own devising, more or less. The real trick is just following through. The first couple of times, you sort of sigh as you have to add it to three functions to get it to the right place, but eventually it all tends to fall into place. Once you start composing the environment into the local object, using its functions in a method just becomes something like `obj.Logger(...)`, and once you get over the hump to that point, it becomes quite easy. I don't just mean "easy because you're used to it", but actually, _easy_. You aren't sitting there chasing chasing down "what's my logger", for almost all methods it's just _right there_, and it's easier to use something off the environment object than to use a global logger instance. I found it was very similar to changing to use the context object pervasively. It's much the same process. (If you use both at the same time, I usually put the environment in the context, so I don't have to have both in my function parameters all the time.)
I was wondering the same thing last week (as I was writing a drone plugin as a linter for some json data), and did some googling, found [this issue](https://github.com/golang/go/issues/15314), which has link to [the actual change](https://golang.org/cl/74830).
I‘m kind of in the same situation and I would also be interested in an online camp or something similar. 
Yep, that's basically the main thing holding me back from using modules. None of the dev tooling supports it.
Yes, it contains one direct external dependency, but only for unit tests :)
That's really good thanks. 
Reading the blog post it still seems like you have to use DI to pass the params to setup the environment and don't really gain anything by having a `Env{}` struct embedded in your package struct. Maybe I'm not following correctly. Consider the following example struct that is supposed to setup your HTTP handlers (or something). It requires a `*Store` instance and can either set it on embedded `Env` struct or itself type Handler struct { *Env UserHandler *UserHandler ... } NewHandler(s *Store) (h *Handler) { h.UserHandler = &amp;UserHandler{} h.Env.s = s return } vs type Handler struct { s *Store UserHandler *UserHandler ... } NewHandler(s *Store) (h *Handler) { h.UserHandler = &amp;UserHandler{} h.s = s return }
Here is a fixed version of your code: type Stock struct { Symbol string CompanyName string PrimaryExchange string Sector string Open float64 Close float64 High float64 Low float64 LatestVolume int LatestPrice float64 Change float64 ChangePercent float64 AvgTotalVolume int MarketCap int PeRatio float64 Week52High float64 Week52Low float64 YtdChange float64 } func Get(ticker string) (s *Stock, err error) { url := fmt.Sprintf("https://api.iextrading.com/1.0/stock/%s/quote", ticker) var resp http.Response resp, err = http.Get(url) if err != nil { return } defer resp.Close() err = json.NewDecoder(resp.Body).Decode(&amp;s) return } 
True, but I'm sure it'll get updated at some point. This is still technically a beta release, so lack of support in external, if official, tools isn't particularly surprising.
&gt; Reading the blog post it still seems like you have to use DI to pass the params to setup the environment and don't really gain anything by having a Env{} struct embedded in your package struct. I wouldn't claim I don't use DI. DI is a fundamental tool in Go. This is just a way of organizing it. But the advantage of an environment takes more than a blog post or a little code sample to see. It's when you use it throughout your code that you start seeing the advantages. Having a formalized "this is ALL my dependencies for this package", which is basically all an environment object is, makes it easy to manipulate them, and to completely avoid global variables.
Using goroutines in Go is cheap, they way you're doing it is correct, remeber the io.Pipe returns a synchronous reader/writer you might want some buffering there. On a side note, this utility [https://github.com/timocompose/docker-image-tools](here) let's you do you differential saves of docker images. So if you use a common base Dockerfile that installs for example Ubuntu with some packages, you can backup that image to s3. And then you create an app Dockerfile that uses the base in it's `FROM` that installs you app files, you can do backups of that image don't include the whole base filesystem. You just untar the app tar on top of the base tar to get the complete image.
hasn't the failed promise of ORMs being portable dissuaded us from things like this?
In RTP the companies using Go (off the top of my head): Epic Games (Cloud deployment team?) pendo.io UserVoice I think they all want senior developers, though. If you find more, please update the list
Does it work with local modules as well?
Yes but ORMs are tricky beasts at the best of times - add a field in the database and see the joy of all your automatically generated code fall to pieces. These objects are a little more tangible to work from, oddly enough today I finished the first cut of a BucketClient that would write blobs to GCP, AWS, and Minio buckets without the calling functions needing to care why type of bucket they're writing to. There was very little difference between the three bucket types. So I can get behind the thinking in what they're saying here. 
&gt; Using goroutines in Go is cheap, they way you're doing it is correct I know they're cheap; just feels wrong to unnecessarily involve the scheduler. But as long as this is the recommended way, the performance isn't too bad. &gt; remeber the io.Pipe returns a synchronous reader/writer you might want some buffering there. Hmm, good point. I'll play around.
Running disposable databases and other things sounds really useful for setting up integration tests. Anyone have articles for actually developing your apps inside a container or small fleet of containers for multiple micro services? 
&gt; failed promise of ORMs I'm not sure who you've been talking to, but ORMs haven't failed by any stretch of the imagination. Have you ever seen a Ruby on Rails app that doesn't use ActiveRecord, or a Django app that only uses raw SQL queries? Rust has Diesel, which is proving to be quite robust in powering [crates.io](https://crates.io), and it can actually perform better than raw SQL due to all the compile time information that is available to the compiler because of Diesel. ORMs definitely haven't failed. The way to implement an ORM in Go has significant runtime performance penalities due to limitations in the language, so it's obviously going to be less "in vogue" here. None of this means ORMs have failed, or that Go Cloud is a bad idea. It actually seems quite nice.
I use PyCharm and GoLand and am happy to pay for these as they make me very productive and makes me push out higher quality code with less bugs. I personally don't like VSCode because they practically took what Atom had developed (embrace) and improved it (extend) and now practically every developer is switching over to it now from Atom (extinguish). They say that Atom will still stick around, but just look at the Go community, everyone seems to be using VSCode and almost nobody Atom anymore. It is kinda Atoms screwup though by being too much reliant on plugins, people like VSCode in the Go community because it understands the Go language without having to install a lot of plugins, code completion, etc.
I need a slice of complex128. Gonum does not support this (yet) I think.
&gt; ORMs haven't failed by any stretch of the imagination You go on to mention Ruby AR, which is a particular pain point of mine. As I'm sure you know, especially in the sense of table joins, ORM reading workloads (mostly) have been a tremendous failure. Just because something works for 80%+ use cases, doesn't mean that it's a good fit for the remaining 20%-. I have burned myself on ORMs, because they just simply can't cope with relational data a few levels deep, and in the end you're just fighting the ORM instead of writing out that SQL query (as it should be). Maybe, most of what people need are [relatively generic insert/replace/update/delete functions](https://github.com/titpetric/factory/blob/master/database.go) that would take their struct and put it into the database. The rest should be hand written SQL queries for reading data. SQL is an abstraction already, having ORM as an additional abstraction over that is definitely detrimental. If ORMs haven't failed for you, it was mostly because you either: 1) work around their quirks (which I notice to be very common), 2) are writing simple CRUD apps that don't really have significant requirements. So, yeah, for those CRUD cases, ORM is a great fit. As long as you can keep the actual relational part of RDBMS thin or non-existant. I mean, at some point, a key-value store is also great and not a failure, until you try to use it for things it just wasn't meant for. ORMs have their place, and it's somewhere between SQL and NoSQL, unfortunately people don't realize that if you're leaning to one or the other side, ORM becomes the wrong choice twice, while SQL in turn is about half as bad (if we consider that data-warehousing / OLAP or Hadoop map/reduce is the next step up from SQL.). The thing is, using SQL is really simple. There are at least three or four database choices today that are free or open source, and support the biggest workloads, from any kind of social network or public service you imagine (uber, facebook, tumblr, stackoverflow...). It feels to me that ORM is really just a crutch for people who want to build stuff fast, but also outgrow ORM really fast as well. Beyond using it for the cases mentioned so far, it seems the main wheelhouse for ORM is ORM-first design (like RoR), or just prototyping. TL;DR - while ORM isn't a complete failure, it has a more limited application than SQL itself (which is already an abstraction). Since SQL is easy to get into, ORM is mostly a crutch for people who take shortcuts.
I don't know about articles, but I've been using docker-compose to run my integration tests for a while. It doesn't really help a lot when it comes to running Go code inside of the container (there's always going to be a certain amount of added pain), but it sure helps with setting up an environment with all kinds of emulators (pubsub, S3, etc.) and a test database.
The Google Next session is starting soon: https://cloud.withgoogle.com/next18/sf/my-schedule/session/156871 Here are some more general recent articles on the thought process: https://cloud.google.com/open-cloud/ https://cloudplatform.googleblog.com/2018/06/why-google-believes-in-open-cloud.html
ORMs _do_ handle the 80% (or even 95%) case. Having to write _some_ raw SQL doesn't make ORMs a failure, they still make life easier for the majority of the time. You should really look at what [Diesel](http://diesel.rs/) can do. It can make strong guarantees at compile time that your code will work, in addition to avoiding the overhead of needing to dynamically decode the response of the SQL queries, both of which are things that raw SQL can't do. A strong ORM like Diesel can be the foundation for building a more robust application. &gt; while ORM isn't a complete failure The industry still uses ORMs widely. I think it's pretty clear that they are successful, it isn't just "not a complete failure". The ORM concept has been very successful.
leading underscores as of convention are used to signal unused or hidden fields. If you clash with an already defined parameter use a trailing underscore or better a different name (lowercase).
That's like saying all API contracts like protobufs are dumb because WSDL sucked
https://github.com/gonum/gonum/blob/master/blas/cblas128/cblas128.go
It's funny you bring up Django. As primarily a Django develop, I say Django absolutely *sucks* for the 20% of tasks that don't fit perfectly into the expectations of the framework. It's fantastic for the first 60-80%, but is nothing but headaches the rest of the time.
I don't personally have much experience with Django, but writing raw queries [doesn't look too bad?](https://docs.djangoproject.com/en/2.0/topics/db/sql/)
Coming from NodeJS land, are Go Modules similar to how we would initialise a new project with a `package.json` file, and pull in dependencies which are project-specific into a dedicated folder within the project vs. having it all float in the GOPATH?
I'm not just talking the ORM, the whole bloody framework is very opinionated on what you're able to accomplish with it effectively without jumping through complex hoops. And I agree, the raw querying isn't bad at all, and it's often not needed. 
Personally, I've found that using jsonschema to validate the input data (optionally, using https://github.com/alecthomas/jsonschema to generate the schema) is a really good way to avoid this kind of issue. I'n not sure how performant it'd be for parsing a lot of JSON (for example, if you use JSON for message passing) but it's definitely made using JSON as a configuration format much more solid for me.
You are probably better off using Udemy with Todd McLeod's courses or Stephen Grider's intro course, and stack overflow. I'm a boot camp graduate that learned full stack JavaScript at an online boot camp. The things that I've done and learned with a mentor could've easily been done through stack overflow, or talking with people at meetups. The only thing I felt that I really gained is from career grooming/advice. I am currently learning Go on the fly with help from Udemy resources, the well written docs and the Go Language book. Although Go is really hot right now, I don't think a lot of boot camps currently have it in their curriculum because of the following: 1. It's still relatively new compared to Python, Ruby, and JS 2. It's a simple language (simple as in there's not as many oddities or inclusive helper methods, or weirdness like JS, which can add complexities to the language). 3. Volume of Jobs in the market (someone posted a great quora Q/A in here) I know this is probably not the answer you're looking for, but as a boot camp graduate myself, I believe there is a wealth of knowledge available to you from resources currently available.
Have you met my friend [fog](https://github.com/fog/fog)?
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://github.com/fog/fog) - Previous text "fog" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20ID_HERE) 
Many of Tyler's comments resonated with the NATS team as well. Especially integration with plain NATS, wildcards etc. We have a design in progress for JetStream which addresses many of these concerns. Also thanks to Tyler for the name, he came up with it ;) 
Go is newer than Python and Ruby, but let's not pretend like it was creates a few years ago. Go is now a mature programming language with a vast amount of online resources to help you learn. If you can't find them, then it's more on you. Go is not a simple language. It might have a simpler syntax than C/C++/Rust, etc, but do not mistake it. It is a systems language, and it can be incredibly complicated, especially when using the unsafe package. If you think Go is simpler than Python..then you have lots of learning to do!
Thank you so much for all suggestions I really appreciate it. I will try to fix this all 
great for the tips :)
I can take a more detailed look later, as I’m on mobile right now, but the first thing I see is hard coding dB credentials. This should for sure be avoided. Look into using environment variables, whether they are added to the terminal session or read from a config file. Also I’m in a very similar place as you in terms of approaching Go, so maybe we can learn a bit from each other! I’m specifically working on figuring out the best way to handle database connections with models. I see that you’re passing in a reference to the database connection when calling one of your utility methods, but I feel like there has to be a better way. Have you tried any other ways to organize that?
I am moving back to Django after a few years away, and I still mostly like it, but I agree that, for example, its forms and admin are great for simple stuff but should be dropped like a brick for anything complicated. 
What you have here seems fine to start with just a few comments. * No tests * Obviously you won't want to leave your db username / password / server address hard coded like that * You return true from db.CreateNewBlogPost but never consume it. If you aren't returning an ID for the consumer of the API, my gut says you should only return an error. * You're doing the right things with go fmt, linting, etc [https://goreportcard.com/report/github.com/chrisgreg/jott](https://goreportcard.com/report/github.com/chrisgreg/jott) * On another note /newBlogPost as your resource doesn't seem very RESTful to me. consider /posts, get should return a list of posts, a HTTP Post should add one. 
Django is my favorite framework for quick and simple CRUDey REST APIs using DRF, it's so simple! But yeah, forms and the godawful *template* framework. Uhg. We have an application that was originally *supposed* to be simple but they keep tacking on new requirements and it's to a point where I don't want to touch the UI at all anymore. 
[removed]
I like this better func (model *Model) UnmarshalJSON(data []byte) error { type LocalModel Model var me struct { LocalModel Other *string } dec := json.NewDecoder(bytes.NewReader(data)) dec.DisallowUnknownFields() // Force errors if err := dec.Decode(&amp;me); err != nil { return err } *model = Model(me.LocalModel) return nil }
1. Apply anyway if a job looks appealing to you. Businesses list their laundry list of 'requirements' on job ads to help protect themselves should they get into a hiring discrimination lawsuit. It's not there for you, it is there for lawyers. You can safely ignore it. 2. Senior skills are gained simply through the experience of writing software. That doesn't have to mean working for someone else. If you hold becoming a senior developer as being appealing, just start programming. You'll get there sooner than you think.
You can put the database As a package level variable in dbutil and open it in the package init function. This will totally encapsulate the db connection.
Will this redefine the type for every unmarshall call, then have to clean it up in garbage collection? I don’t know how garbage collection of types defined inside a function is handled. 
Yeah, json schema is also really useful for building clients in other languages and making sure they conform. But given go structs already define a lot of that information I don’t like having to define it in two places. 
[removed]
Hey mate! Don't you think its a bit risky to make your own websockets server for production? Scale would be a nightmare right? Why would you choose a home made solution rather than deffering to aws or something similar?
ELI5?
[GitHub!](https://github.com/recoilme/tgram)
Scale isn't an issue, internal use only, and using a vps / csp is prohibited in my group. So for our case fairly obvious choice to build it ourself. I think websockets aren't something that scary as long as you maintain scope and strenuous authentication. 
Hello, i write blog platform too: https://github.com/recoilme/tgram and it's open source and jwt based. You may grab some ideas here If it looks to complex for you - take a look at https://github.com/recoilme/golang-gin-realworld-example-app this is medium clone backend on golang, and it's jwt based to
This is also how I do it. I like this more because it only requires a new 'local' type. Local as in only in the scope of the function.
Thanks for putting this together and happy to learn that this area is evolving. I've done it myself (though not as re-usable and generic as you did) and shared some thoughts about it in [Container Assisted Testing](https://medium.com/@mhausenblas/container-assisted-testing-b76ee74278b7). KUTGW!
Yeah the hard coded variables are just temp while I dev on it. I’ll move them to a .env file for release 
Great idea, I’ll do that!
Thanks for looking! Tests will come after I solidify some functionality The DB values are just there temporarily while I dev at the beginning Good point, ill only return an error. I plan on making the endpoints restful, this was just done so I could easily hit a dB entry as a test. Should the dB utils be an interface??
I've made a proposal where you could get rid of the switch all together [https://github.com/sysco-middleware/commander/pull/4/files](https://github.com/sysco-middleware/commander/pull/4/files) Switches tend to grow longer and longer as time goes by. This approach allows for individual testing of the separate handlers, and scales well.
My concerns are less about security but with scale, from what you say scale isnt an issue in your case. Its faily hard to scale out websockets as far as i know, to hold the pool of connection and share them acrossm machines would be a bunch of engineering right?? I found [this](https://goroutines.com/10m) article shwoing that 10mil req is possible with enough memory. 
This seems to be a glorified usecase of interfaces.
Wouldn't it be trivial to write a simple adapter that implements this streaming by translating read calls to write calls? 
* https://github.com/chrisgreg/jott/blob/master/db/utils.go#L9 * https://github.com/chrisgreg/jott/blob/master/db/utils.go#L14 - use DB.Exec directly. * I would probably create an interface into server with `type DB interface { CreatePost(userId int64, title, subtitle string) (int64, error)`.
The init function there was a remnant of me checking I was importing the package correctly. I assume DB.Exec will protect the code from injection? If I make a DB interface like that - where do I actually create the DB and pass it in? I was planning on using the init function?
they haven't been rejected, but they also failed to deliver. I guess this is what stays behind any wave of hype
Here's one way https://gist.github.com/egonelbre/f80d09be4874db602f3bba72e6600727. Yes, `db.Exec` is semantically equivalent to `stmt := db.Prepare ...; stmt.Exec`.
&gt; https://gist.github.com/egonelbre/f80d09be4874db602f3bba72e6600727 Amazing, thanks!
I'm personally doing ssl termination (let's encrypt) with Traefik in a Docker container. Basically Traefik is a reverse proxy that automatically creates it's backends and frontend rules from the currently running docker containers. It's nice because you can avoid the whole _'I update my haproxy.cfg, I stop haproxy, I run the start command I cross my fingers'_ situation. You can stop/start apps and services without impacting nor causing downtimes to the others. And, humm, well. Traefik is made in Go. I just have to write a simple `docker-compose.yml` file that looks like that: version: '3' services: my-service: image: 'my-go-app' networks: [traefik] labels: - 'traefik.enable=true' - 'traefik.docker.network=traefik' - 'traefik.frontend.rule=Host:mysubdomain.mydomain.com' networks: traefik: external: name: traefik - Whenever I stop the container, Traefik removes the associated backend/frontend. - Whenever I start the container, it creates them back. - When I try to access a subdomain that does not have a certificate yet, it automatically does all the let's encrypt certificate request for me. Here is a git with my complete setup : https://gist.github.com/Nicnl/895102d27a3215990b22ef78390f62e1
Show us your code! Guessing is boring
Here is the code: package main import ( "crypto/tls" "fmt" "log" "net/http" "golang.org/x/crypto/acme/autocert" ) func main() { log.Println("Runs...") mux := http.NewServeMux() mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, "Hello Secure World") }) certManager := autocert.Manager{ Prompt: autocert.AcceptTOS, Cache: autocert.DirCache("certs"), HostPolicy: autocert.HostWhitelist("mywebsite.com"), } go http.ListenAndServe(":80", certManager.HTTPHandler(nil)) server := &amp;http.Server{ Addr: ":443", Handler: mux, TLSConfig: &amp;tls.Config{ GetCertificate: certManager.GetCertificate, }, } log.Fatal(server.ListenAndServeTLS("", "")) }
From a quick glance, your code looks sound. The only possible issue I see, is potential permission / path confusion by using a relative path for the DirCache. But you should see errors if that is an issue. Could it be a firewall or routing/forwarding problem? Is your server responding on both ports? Maybe a DNS problem? What is the real domain name? No point in keeping it secret. Once you apply for a certificate it goes into the public certificate logs for everyone to see.
I'll stick to... Thank you Unstructured binary (blob) storage Variables that change at runtime (configuration) Server startup and diagnostics: request logging, tracing, and health checking 
The domain name is gobymedia.com When I try port 80 (http), I get refused connection in the browser. I don't have the program running currently, I'm afraid of hitting the limit of 20 certificate requests per month. What would be the problem on the DNS side of things? I don't think I even have a firewall set up at this time as I'm just using it for testing at the moment until I get CI/CD set up with docker.
Is this essentially another openFaaS? What's new about this?
[Github link](https://github.com/The-King-of-Toasters/httpman) if you hate freedom. Also, please feel free to rip into my work if you find anything wrong.
Tests will come after I solidify some functionality * Forgive me for being obvious, but testing isn't something you do after solidification. Testing helps solidify. I am not advocating a completely test drive approach, but testing early and often is a solid choice. Should the dB utils be an interface?? * I am going to get flack for this but no, it should not. Go interfaces aren't like Java or C# interfaces, you don't create them to encapsulate something like DB interaction, instead you create them to encapsulate functionality. My interface would be something more like this ```type BlogCreator interface { CreatePost(title, description string) error } ``` And that should be declared at the receiver, IE where it is used, not where it is implemented. In general interfaces should have no more than 1 or 2 functions declared and they should make no assumption about the underlying implementation. What I mean by that is that if the functions declared in the interface have implied inter-dependency you should re-think. My final thought is that when testing, I might consider more of a integration test pattern here, it would be so easy to use docker compose to spin up a new db and service for testing that you might find it better just to use the http test lib to perform all testing for a project of this scope. 
Sorry about the wall of text, I was on mobile and my formatting options sucked.
I don't really mean solidify functionality - I wrote this last night before I went to bed and it was my first time writing any SQL in Go - I literally wanted to see it work and it did - I will add tests as I add functionality but I didn't want to write lots of Go only to post it on here and have everyone tell me it was wrong. I'll think about what you said with the interface usage and the docker idea for spinning up a DB sounds like a great idea!
It has the names Google and IBM attached to it. That's pretty much it.
Can you point to some examples? I'm reading up on what I think you're describing, but seeing some actual code is always worth it's weight in gold. Thanks for the reply, also :)
As far as I can tell, it's quite tricky/error-prone (managing the internal buffer, especially without accidentally loading everything into memory; making sure that there are no cases where we return io.EOF before the last bit of data has been compressed and returned; etc). It's quite a lot easier just to use `io.Pipe()`. But maybe I'm overcomplicating it and you have a simple solution off-hand?
IIRC it was a change in TIOBE methodology.
Hey, just an FYI this was just submitted yesterday [here](https://www.reddit.com/r/golang/comments/91mc73/wire_automated_initialization_in_go/).
Whoops, I missed that. Apologies. 
Did you consider simply writing actual man pages?
If this wasn't google, or rather, the Go team behind go-cloud I would be suspicious of code generation for DI. Even with hundreds of injections, is adding an extra build step + artifacts really worth it? This looks like the kind of magic that Go frowns upon. I can see the use of generators for [tedious spec files](https://github.com/google/protobuf), or JSON-to-struct, SQL-to-struct, and even [getting a shell project going](https://github.com/gobuffalo/buffalo/blob/master/generators). 
I've honestly still never come to a point where manual wiring has been painful. I'm not building monoliths, and even in reasonably complex applications (take something like upspin as an example, or etcd) you can get by with manual wiring and it works fine, and has (like you said) less magic.
Funny enough he did write a man page for the program. It's a little weird, but whatever, I'm happy that people write weird little tools. 
Technically I took the info from a guy who hand ripped em' from MDN. The man pages were going to have to be generated one way or another.
&gt; But I expect, no change Yeah right. Expect changes that you can't see: telemetry, data mining, and whatever other purposes Microsoft has in store for Github -- probably to train AI models or something to write code automatically -- basically whatever the most obvious, sinister reason you could think about it is probably the reason. 
Seriously, these newfound M$ fanboys are driving me crazy. People never learn. They absolutely do not deserve our trust, _ever_. Oh well, these young whippersnappers will learn the hard way, I guess. 
hn discussion -- https://news.ycombinator.com/item?id=17602377
If you check out the pcf related projects on github you will find that Pivotal engineers are writing a lot of go. Most of that is building of the platform itself rather than apps that run on the platform, but nonetheless Pivotal is using a lot of go. Ive been curious to look into how Pivotal engineering structures their pipelines around go code ... if you want to identify best practices and convince your boss, I would look into how Pivotal uses go, certainly if the creators of the spring framework use it in a relevant way that could convince your boss and at the same time find good practices for distributed systems architectures that can leverage both spring and go. 
&gt; If this wasn't google, or rather, the Go team behind go-cloud I would be suspicious of code generation for DI. One thing that makes me *much* prefer this over other approaches I've seen in the past is the static safety of things. If your DI isn't correct/complete, instead of crapping out at runtime (potentially late in the process lifecycle), you get a compilation error. I ran into this with [guice](https://github.com/google/guice), where we would get paged and the cause turned out to be incorrect wiring of dependencies that got only discovered at runtime.
So you are saying that for the Java app, guice was the solution to bugs caused by manual wiring of dependencies?
It's simple: TIOBE index is meaningless. Do not try to find meaning in it.
I believe that he is saying the exact opposite, that the use of Guice actually introduced bugs because of its runtime DI
Looks cool, like the in memory, disk persistent DB too. Only one post on tgr.am tho :).
Yes, they change continuously the TIOBE algorithm, but take a look to the direction. After the rough decline it is going up and don't stop.
Don't search for "Go developer" because that's the senior or experienced position, this is why is called Go developer, because they know Go well. Search for "Backend developer", "Software developer", and you will find different kind of jobs with other fields where Go is "just" a side or optional technology. That's the entry level for Go.
vim
Thank you! 
File watchers stores the configured File Watchers in the IDE settings and allows you to share them among different projects using the Project and Global options Best change here. And dot-imports should be forbidden but thats just my opinion.
Problem is it's so zen a random visitor would have no idea what this is. Even github's readme is *way* clearer.
If you are sitting in a restaurant, and across the room another guest has their steak delivered to their table, do you walk up to them, stand there, and state "Salad." ? 
Yes! Been longing for this change.
+1 on forbidding dot imports.
If I'm sitting in a restaurant, and across the room another guest is about to click buy on a paid ide I walk up to them throw their computer across the restaurant, and whisper in their ear, "Vim".
There should be a way to enable test-cert mode, which will disable the 20 req/month limit.
I don't use GoLand, but I think dot-imports could be allowed in special cases (for example: test code using its own package and dot-import the main package), but it should be forbidden in most of the cases.
It's not that manual wiring is painful, it's just that it may be anything from 1 to X dependencies, and you're not going to want to modify function signatures every time you decide to add a dependency. And if you put it into structs, it's a bother tracking unused dependencies, because you don't really know which function uses what without reading the first few lines. I personally, at least for the things which I know that are "universal", provide a package API that returns some dependency that I need. If I need a database, I get it from calling a GetDatabase() call or something similar. I don't pass a `*sql/sqlx.DB` around from main() all the way to the god forsaken depths of http handlers or worse and i invert this responsibility. I want my leaf-code to get a dependency, from *somewhere*. The issue is that *somewhere* shouldn't really be context.WithValue, but you can set up a completely type-safe way of getting whatever you need at the edge, without explicitly passing it along. I so much want to mention `codegangsta/inject`, which was a great find, once upon a time. There was some web framework using it, [go-martini/martini](https://github.com/go-martini/martini), and it's plagued with non-idiomatic code and magic... but guess what? Some people like magic. And for lots of casual developers, DI works. I also wrote a few articles on the subject, back in the day: - [Dependency injection patterns in Go](https://scene-si.org/2016/06/16/dependency-injection-patterns-in-go/), - [Dependency injection continued](https://scene-si.org/2016/07/07/dependency-injection-continued/) The last article also discusses the factory pattern for declaring dependencies, which is something I use to this day. It doesn't always make sense, but for something I can't just pass along in a function call or a struct field, factories are a terrific pattern that's type safe and documented. At least, it's just as good or better as dependencies in some struct - slightly better, I could argue.
username checks out
How is this different from logrus? Just looking at the examples it looks pretty much exactly the same. Given that there quite a few logging libraries around, it would be nice to learn more about your motivations for this one
Django makes simple things simple and not simple things not simple. But it (usually) gives you a simpler than normal way to do the not simple things. If you're talking web frameworks, I'll take Django over any other any day of the week because it gives you more rope to hang yourself than most do and I see that as a good thing. I'd definitely use it over Rails. The problem is, as your use case gets more complicated you quickly find areas where not having used a web framework at all would have made your life a lot easier. Usually it's about the time you realize you shouldn't be building a monolith.
What's wrong with Django Templates? It's basically the same as Jinja2 which, as far as I know, is one of the most highly regarded templating frameworks there is.
vscode
No, guice was the DI framework used and it caused bugs because it is dynamic, not static. i.e. wire seems like a much better solution than other DI mechanisms. Not much better than non-solutions. TBH "manual wiring is just fine" is a bit tone-deaf to people who are complaining about the pain. You might be fine with it (and obviously, don't use wire then), I am too. But if customers/users of Go complain that they feel pain due to the lack of a DI solution, it's not a very satisfying answer.
After reading your eloquent, thoughtful explanation of things, I must say I am thoroughly convinced of... absolutely nothing. Why bother posting?
&gt; It's not that manual wiring is painful, it's just that it may be anything from 1 to X dependencies, and you're not going to want to modify function signatures every time you decide to add a dependency. And if you put it into structs, it's a bother tracking unused dependencies, because you don't really know which function uses what without reading the first few lines. Actually, I do want to modify function signatures when something has a new dependency. If by function signatures you mean the signature of constructors. If some new dependency is introduced, and I forget to update something to use that new dependency then I want it to fail _at compile time_. None of these runtime, reflection-based DI container things like facebook-go/inject, uber-go/dig, and also codegangsta/inject are properly type safe, and you can always run into runtime panics by using them improperly... and usually it's also quite easy to use them improperly. I wrote about the pattern that I use on [my blog over here](https://www.elliotdwright.com/2018/02/27/how-i-structure-some-of-my-projects/). This pattern has been working very well for me. There are a couple of comments on the post that also contribute to the discussion well. &gt; I personally, at least for the things which I know that are "universal", provide a package API that returns some dependency that I need. If I need a database, I get it from calling a GetDatabase() call or something similar. I don't pass a *sql/sqlx.DB around from main() all the way to the god forsaken depths of http handlers or worse and i invert this responsibility. Yeah, that sounds quite similar to the pattern in my blog post in a way, except you maybe push the responsibility for creating those instances to something in the package where you define the type? (Not sure, maybe you can expand on that one more). Not sure what you mean about passing around the types through the depths of your application. I normally find my dependency wiring to be quite flat really, especially with the pattern in that blog post above. I have a type that needs dependencies, so I get those, and only those. When I get those dependencies, they're already set up with their dependencies too. Each type is independently constructed, making it nice and flat. &gt; I so much want to mention codegangsta/inject, which was a great find, once upon a time. There was some web framework using it, go-martini/martini, and it's plagued with non-idiomatic code and magic... but guess what? Some people like magic. And for lots of casual developers, DI works. It's funny really. Once upon a time I went looking for this. That probably has something to do with my background in languages like Java, Scala, and PHP where there are things do autowiring and DIC's like Symfony's. It didn't take too long for me to realise that in Go, there's just no point. Either you have a small app where manual wiring is super easy, or you have something slightly larger where it gets a bit messier, so maybe you use a pattern like the one I describe, or maybe you have a large application - but that pattern I wrote about can stretch to support those applications too if you just have multiple resolver types (hopefully you've read the post by now... heh). The issues with these DI "frameworks" are too great. I just cannot justify giving up that compile time type safety and code clarity. I don't want to ever see another panic in an application I develop in because of one of these frameworks. I will also point out, DI in general - great pattern. These magic DI "containers" or "frameworks", IMO, not a great plan. I just want to point that out, not because I think you don't understand that, but because if anyone else fairly new comes along then they may be confused when you say "DI" when you mean "DI frameworks", or "DI containers", etc. &gt; The last article also discusses the factory pattern for declaring dependencies, which is something I use to this day. It doesn't always make sense, but for something I can't just pass along in a function call or a struct field, factories are a terrific pattern that's type safe and documented. Comparatively, it's better than struct fields with dependencies, and with smart use of embedding or interfaces, you could fully document which dependencies are used in your structs. (*edit: added those last few lines here) Just had a look over this now. I'm not too sure about that factory pattern. I think the embedding could be slightly confusing. Personally, I just prefer having bog-standard constructors that accept the dependencies my type needs. If I need to, I can define an interface next to the constructor for some concretion I'm using. That factory pattern is a least definitely not service location, which is an easy trap to fall into for developers that are new to DI in general (again, I've seen you around on this subreddit loads, I know that's not you). Don't get me wrong about using the general factory pattern, factories are a very useful type in many situations. That resolver pattern can behave a lot like a factory in some ways (being able to always create new instances of a type, or using a shared instance, or by passing in parameters when asking for a dependency, etc.) I'm not sure why, but I seem to have seen tons of posts about things to solve this DI "problem" in Go. Admittedly, this is the first one I've seen for a while that looks like it would be worth a try, but even then, the code you have to write before you generate the code using the tool is pretty lame. I'd rather have both compile time type safety, and good IDE support. The best way to achieve that IMO is by using plain Go, and manual wiring. It really doesn't take much effort in the end.
I gotta be honest, Goland has made me use Go more and more since it was in beta. Really happy with this product.
&gt; the failed promise of ORMs You didn't get the complete quote or the OP edited it, but the OP actually said `the failed promise of ORMs being portable` at least at the time I accessed it. 
The resolver is an interesting idea and relates to another question I had about https://www.reddit.com/r/golang/comments/91a54y/proper_structure_for_a_dependencyinjection_based/ My concern with the "resolver" approach is that building mock environments for testing could get a little more confusing or disordered than it needs too. 
Wow. Presentations looks good but there is no slides and you cannot see the demo in the video. Makes it very hard to follow. 
You'd have two options there the way I see it. One is to use separate config, maybe that's all you need. The other is to make a separate resolver for your testing. Embedding might work for that purpose, I should try that out though actually.
Another great **free** ide
It makes no sense to post one-word alternative products whenever a given product posts updates. You have an opinion just like many others that use alternatives to JetBrains products. Some are free and some are paid. Saying "vim" doesn't add any value to the thread. Just like interrupting someone at a restaurant with single "free alternative food" word is not helpful.
We're working to get it corrected either by re-editing the video or proving an accompanying video of the demo along with the slides.
Tighter integrations with k8s/istio and being backed by Google and IBM instead of VMware. You can leverage envoy instead of the openfaas API gateway and I assume the crd/controller implementation is more robust and generalized compared to the openfaas crd and watchdog. 
Templates themselves are *fine*. Most of my complaints stem from the way we did things. We load a ton of data into the page using the templates, and that *isn't* the greatest way to do things. On some larger datasets we'll hit timeouts on dev machines. If I were to redo it, I'd make minimal use of the templates and move as much of the data loading and processing over to async REST calls and probably use React to drive everything.
Is it good to be high or low in this chart?
Yup, I totally agree! I really like Django for a lot of things! And on the micro-service suggestion, the whole application is basically one giant data cache system that has to combine info from several different systems and display it before feeding into another system for processing. There isn't a whole lot that be split up unfortunately :)
It looks like it's going down for me, Go is soon going to disappear from the top languages if it continues like this.
Both are text editors. Not IDEs. You can't be expected to appreciate the tools you don't know how to use. 
Incorrect hank. They are only text editors if you don’t know how to use them. Nice try though Jetbrains.
It makes no sense whatsoever to spam up the golang subreddit with product updates. They should just pay for reddit ads. If they are going to post their spam then I should be able to spam their post with free alternatives.
There are definitely situations where a text editor like vim is the preferred option but if you are working on enterprise applications with CI/CD pipelines IDE's are going to save you a ton of time and generally make life easier for you. I have one coworker who insists on doing everything in vim and at the end of the day, he wastes more time with miscellaneous tasks than the rest of us. I never understood the mentality of people who purposefully choose a more arduous method with no apparent benefit. Use the best tool for the job. Sticking with one ship is a great way to end up sinking. 
Whoa now. With a few vim addons vim can be a pretty powerful golang IDE. Maybe your coworker just can’t vim right. If you learn it correctly it will ultimately save time. Use what ever works for you though. VScode is another great free choice.
It isn't spam. Its directly related to Go development. Is it spam for open source projects to post new releases, or is it a double standard for a commercial Go product vs an Open Source Go product? I was very happy to see this posting, as a user of GoLand, even before I got back to work and checked for updates in my IDE.
We don't spam reddit with product announcements, and we make it clear that we work for JetBrains when we post. We do tools for developers and some like them, some don't. We can't prevent our users to link to us either. As a way to measure this, look at how many posts about the IDE updates I have in the last year. I would also hope that our users are not spamming posts like Faith's vim update one with comments like "GoLand".
Thanks. Please let us know how we can improve your experience.
Faiths vim plug-in is free. A gift to the community. Not that I see any where near the amount of post about his plugin as I see coming from you guys. I just think you should buy ads instead of abusing community spaces like this one.
We give the IDE for free to students, teachers, open source contributors, user groups and others. As for blaming us for what our users post, it won't help your argument. We do in fact buy ads in different places from time to time, including reddit.
A few notes: - don't load files in init(); you can't do any real error handling and nobody can prevent init functions from running, and it's not even clear when or where it is running; in general don't do "real work" in init() - don't specify that YAMLFILE is a string - don't make YAMLFILE all caps; constants should be camel case - the log package basically does what you've done with error and critError, so maybe use that instead (for CLI apps you can remove the default flags for nicer formatting) - I'd probably dispense with the YAML file and just put it in the binary, probably in a map literal or something; YAML is actually very difficult to parse and users won't want a separate file for it A lot of this stuff would be caught by tools like `go lint` and `go vet`.
Allowing a few people to use your ide does not make it free. For all I know most "users" posting about goland are just bought and paid for by JetBrains if not JetBrains Marketing staff themselves. We just need a no spam rule in this subreddit or make a better subreddit that bans spam post like this one.
They are literally both text editors no matter how you use them. You can synthesize features all you want, but you aren't integrating (the I in IDE) with your compiler. Stop trying to be a coolvimguy.
In no universe is a vim guy cool. I disagree because once you have all the features of an ide it is an ide. vscode is a more advanced 'IDE' than any ide that existed in the 90's. 
I know my colleagues very well and they have better things to do than hide behind usernames or buy posts from users. You don't like our tools and that's fine. But please don't make up things which are not true just because of that.
Do you have both port 80 and port 443 in your firewall open? If you get connection refused on 80, this is the most likely issue. You connect on 443, autocert tries to get a certificate, Let's Encrypt can't validate the challenge over 80 because of firewall and so the connection hangs until it times out.
Yeah I have no reason to believe some one who makes a profit off their post. This is a spam ad. Why don't you guys make a goland subredit that can be filled with post like " version 5.4.2.1 released this update we fixed a typo please give us more money."
Also: I never said I didn't like your tools, I just don't like be littered with your spam. IntellIJ is a good ide and worth the money. Goland is probably a waste of money but what ev. 
I don't understand why it matters if its free or not. Its a tool to benefit the Go community and its great to know that they are being active in listening to what users want, and letting the community know that there are new tools to make their lives better. It isn't clean to me if you are saying that there should be a double standard, where open source projects can notify all they want, but products that are at least partially commercial should be banned. There are lots of posts on this reddit that aren't of interest to me... so you know what I do? Skip them.
So I telneted into port 80 and it created a connection. However, telnet on port 443 hangs. I used netstat and it appears my server is listening on ports 22, 80, &amp; 443. 
 There's nothing wrong with paid software. A lot of the people in this subreddit are likely programmers by profession. If nobody (consumers, advertisers, *somebody*) paid for the fruits of our code, all of us would be bankrupt.
Because spam is annoying. Spam is people posting crap all over the place to try to make more money. There is a place for that and it’s called ads. If one person keeps posting links to their free open source project I will also say it’s spam even without them making a profit. The fact that this post generates money and it’s literally nothing but a link to a product is double infuriating. There is no double standard anyway. I almost never see post about free IDE’s but ai I always see JetBrain spam on this sub.
OK, I ended up solving this, it really was the firewall. For some reason, it was allowing traffic on port 80, even though no rules were set for it, which confused me. But I had to explicitly set rules in ufw to get it to work. Works great now! 
I like how we all talk on this sub and have corrections and arguments about go and other languages and then Google shows up fully loaded and we all sit back in aw.
It doesn't matter whether you agree or not. IDE means something. Text editors are not IDEs. Ultimately it doesn't matter. You have your preferred development environment and others have theirs. Just don't try to make people feel stupid for paying for a quality product that works for them. 
Is this the kind of post where some mysterious force gives gold to every commenter?
GitHub jumped the shark long before being acquired by Microsoft, when it started inserting communist propaganda banners on top of everyone's work.
Dot imports should be forbidden in the code that is built into the binary, but certainly not when using test frameworks like Ginkgo or DSLs like Goa. 
It is strictly worse than Jinja2 though. All of the ways it differs from Jinja2 are like… oh, I guess you could do it that way, but why? Still not bad, but not as good as the best. 
Great work. This IDE saves me a boatload of time, particularly around building tests. Live templates FTW. Delve and go:generate support are also huge. My only “gripe” is that the gofmt file watcher should be enabled by default, with the -s option. It takes a whole 5 seconds to set that up, but I’m lazy.
&gt;but a link to a product is double infuriating To be fair, its a link to a blog post, which is interesting. Its not like they are linking you to their "buy now" button. &gt; I almost never see post about free IDE’s but ai I always see JetBrain spam on this sub Paid IDE posts, no. But tons of posts about projects releasing a new version (Hugo recently, amongst others). Its nice to see activity in popular projects that help the community. Paid or not.
I have my preferred integrated development environment yes and that’s usually VScode or vim with nerdtree and faiths go plug in. I’m not trying to make anyone feel stupid. Just pointing out this is a spam post and VScode is basically just as good and vim is even better at something’s 
I just completely disagree. It’s not nice to see a post for every minor version. If it’s new sure. If it’s some radical feature that nothing else has then ok maaaaybe. But this is a 100% spam post. It’s not nice. It’s just trash in the way of interesting content when I already have to scroll past ads.
Please learn something. 
I am new to Go and I think I understand what you mean type interface Post { NewPost(title string, content string) } and then the actual implementation func (p Post) NewPost(title string, content string) { // handle post creation } Is this somewhat the actual approach for these kind of things?
I agree with most of what you said. Additionally, Microsoft has repeatedly acquired, and then ruined, products in the past. Bad actors have a higher bar to meet to gain trust, and Microsoft has a *lot* of proving to overcome its technological incompetence, its enmity toward open source, and its demonstrated attitude to anything it views as even remotely competitive. I do **not** trust Microsoft at all with control over anything it might decide to consider a threat to their commercial enterprises. Why do you?
If you want an example of the whole process being done in Go, take a look at the source to my webpage's reverse proxy, https://github.com/smasher164/akhil.cc/blob/1c43228537269cc87babd52d7c2958b5a806e2d2/main.go. It's a single file ~110 lines, where I tried to follow Cloudflare's guide on exposing Go to the internet.
Alpha Go (the go game engine) might have to do with the spike in march 2016
Who said that I trust them? I share same prejudice to Google/Facebook and so on. I might have little less "sympathy" to Microsoft, but since I am using gmail even though "google" can spy me, I don't want to be paranoiac (by my book) about github. Probably because I am not a "big fish" and I don't have anything there yet to sell, in future, I might revisit my statement (as they will try to mess sth with policy etc.). 
Please tell me any other editor currently supporting Go modules (aka vgo) out of the box, or move refactoring which let's you move types across packages. Our developers put a lot of work into each release, and you calling this a trash is just sad and petty. I wonder if your employer, which probably pays you money to develop the applications you work on, would be happy knowing you consider other people's work trash. How would you feel if people would speak the same about your work? It's easy to hide behind your reddit handle, isn't it?
Our builtin formatter is getting better with every release so hopefully on-save formatting will be a thing of the past as we'll have proper, on the fly, formatting. As for the -s option, you can now set the watcher only once so hopefully you won't ever need to have a watcher configured again after this release :D
[https://github.com/chrisgreg/jott/blob/master/db/utils.go#L13](https://github.com/chrisgreg/jott/blob/master/db/utils.go#L13) I don't think returning (bool, error) is required, just return error
Can you please explain "By returning concretions it prevents the resolver from being passed around, and stops you from using it as a service locator. The rule of returning concretions and accepting interfaces works well for this pattern." ? If my http handler requires a db or a logger, will I not be passing the resolver to my http handler so that it can resolve a db and a logger? Do you have an actual app that would explain this better than your small snippets of code?
Excellent thank you. 
You're the second person to mention that to me. Interesting :) but I don't think it would sustain the rise like that for so long. I could easily be mistaken though.
Threatening to doxx someone is really unprofessional. The other commenter said nothing about your work, only about the promo blog posts. Very disappointed in JetBrains today. 
How did I threaten to doxx him/her? How is that even a threat in what I wrote? Maybe I'm missing something obvious, but asking someone to apply their own actions to their own person is not doxxing, last time I checked.
You should've put it on GitHub, with some examples (output etc.)
Why not run in Playground with live sample? (Modified a bit of the code to show the image instead of saving to a file) https://play.goland.org/p/Hh49Evi2VmV
The readme is quite lengthy and makes me feel that this package is an over-engineered solution to a not-so-complex problem, but despite its length it fails to explain its use cases. When would I want to use this package?
Hi, The masterplan of astroflow is to provide an universally (for all languages) consistant high performance logging library without compromise on the UX. It's true that the UX of astroflow in go is almost the same as logrus, but performances are far better (eg: for an event with 10 fields, logrus makes 54 allocs while astroflow 13 and rs/zerolog 6). Some things are not yet implemented (like async logging), but the goal is to provide all the features of an advanced logging library (unlike logrus, like async and sampling) without sacrifices on the UX (unlike uber-go/zap).
yes, you got it right
We Need To Go Deeper there are no visitors on the site)
[removed]
[https://www.youtube.com/watch?time\_continue=2&amp;v=sX8r6zATHGU](https://www.youtube.com/watch?time_continue=2&amp;v=sX8r6zATHGU)
Hi /u/ESBDB, what you've described at the end of your comment there is what I would call service location. You'd be passing something that can create a lot of, if not all of the dependencies of your application to a type that only needs a handful of them. There are a few drawbacks to that approach, the most prominent of which I believe is that you'd be making it less clear which types your handler actually depends on in that case. &gt; By returning concretions it prevents the resolver from being passed around, and stops you from using it as a service locator. The rule of returning concretions and accepting interfaces works well for this pattern. What I mean by this is that because your resolver type can (and IMO should) return concretions, if you were to pass your resolver to your other types, it'd be quite painful to use, because you wouldn't be able to mock it. If you _don't_ pass the resolver to your dependencies, you can just write a test resolver if you want one. Or if you're unit testing, make fakes, mocks, stubs, whatever, and just inject them into your dependencies. I'm going to just whip up an example of this pattern with an HTTP server. I'll edit this comment with it when I'm done.
I've made a basic example of this pattern in response to another comment, if you're interested: https://github.com/seeruk/resolver-example It doesn't alleviate the concerns you've mentioned here, but I may expand upon it so that it can do by adding some tests. For unit tests, the resolver doesn't even get involved - you just make your test and wire things up as you need. For integration tests, you are more likely to wire up things with "realistic" dependencies, and just run your application like normal, so again - no problems there with the resolver. I'm still going to investigate making a unit-testing-ready resolver nonetheless using embedding, but usually test code needs more configuration, so it might get too complex.
Look at https://github.com/avelino/awesome-go#iot-internet-of-things Use interfaces for mock real pins implementation.
See godoc for documentation: [https://godoc.org/github.com/dwlnetnl/worker](https://godoc.org/github.com/dwlnetnl/worker).
This is a really cool and very ambitious project! I have one nitpick, which is the Titlecase package/folder/file names - these should be lowercase. Running a linter will turn up other nitpicks, such as all those exported methods without comments. I haven't looked at the code in enough detail to pick up anything more significant. 
yes it does
You *can* post free alternatives, I found out about neovim through here
Well, I got the update automatically through Ubuntu's snap channels, but still I wished to see their changelog. So it is not spamming, just an information about one of the most valuable tools.
You are correct, but I bet if a small indie developer posted every update to his paid golang tool it might get flagged as spam pretty fast. 
Congrats on the release /u/sdboyer! For a while now, the last remaining pain point for us was the slowness of `dep ensure`, which is *significantly* faster with 0.5.0 and I no longer have anything to complain about :)
Good talk. But the stuff on generics - lol!
Once go 1.11 is out, I will uninstall `dep` and use go modules instead. Reason is simple: `dep` doesn't support my workflow (Projects outside of GOPATH, or inside of GOPATH but symlinked somewhere else). My projects are structured the same for all other languages, go isn't going that special snowflake on my machine, it worked fine until I tried using `dep`. https://github.com/golang/dep/issues/1899 I'm not going to set an env var each time when going into a project, and it probably will not work with IDE / editors. Symlinks are a basic feature on operating systems, it should be 100% supported. At least there is a workaround (I provided a small patch in the above issue that fixes the problem for me, but the way I see symlinks are something that doesn't exist for this project so it won't be looked at).
Sure. I've also found GOPATH constricting, and I like that aspect of vgo. It's also an odd thing to hold dep responsible for, though, as it's something we fundamentally couldn't fix from outside the tool chain. We tried with symlinks for a while, but every change we made created some new problem, and it was pretty quickly occupying a large percentage of my time, and taking away from major features. It should be noted that vgo actually has LESS support for symlinks in other areas - they are stripped out of any dependency modules. (I haven't verified that that's the case, but I know it was the express design intent) Also, if you have an IDE invoking dep, setting an env var can just be done with a prefix: DEPPROJECTROOT=foo dep ensure
Looking at the last chapter of this release doc : &gt; As we believe that the current incarnation of modules will be harmful to the Go community, we intend to continue with dep's development, moving towards an alternative prototype for the versioning behavior that currently undergirds the modules system. And maybe an answer ? https://threadreaderapp.com/thread/1022164586122887168.html It's very fun to continue to experiment in every directions, like Dep was, but i found it very confusing to keep the same name and in the official golang repository. I believe Dep should stay like it is and just help to make the transition to go modules as smooth as possible and a new Dep2 can born to continue to experiment. It'll be a lot easier for Dep2 to start independently with free hands from the legacy, and I'm sure it will help to improve go modules, if not for Go 1, could be for Go 2. As user we experimented since years, we need now one obvious way, standard, simple, opinionated : boring ! go modules is still an experiment to 1.12 but at least the transition will be guaranteed. 
Oh, I can see how that might confuse a bit. The changes I'm talking about are really just ones that were always planned. There's not much plan to rock the boat with dep as-is. But, as we'll be reusing the engine (GPS) in the alternative prototype, I want those paths to run together for as long as is feasible.
The only feedback I have right now is that the web UI is beautiful. Very well designed.
Ah, sure, sure. Jinja2 is definitely better.
How about disabling dep when you open a project? I have a project with subcomponents which means I end up running 5-6 dep ensures every time i open the project (even when I haven't added any new packages).
For sure, that's definitely where you usually get with an application that outgrows the monolith.
The IDE should run dep status in order to check for the dependencies status. This is needed in order ensure that nothing has changed when the IDE was not active in the project. However running this multiple times is not expected. Can you please describe a way to reproduce the issue? Thank you.
I haven't read completely through the Pipeline section, but maybe give some love to Concourse CI
Ultimately, I'm going to try to adopt Go modules, and I hope that most people do the same. If there are fundamental flaws in practice, then I'll see what the community decides to do at the time. I just hope that we don't end up with several different ways of doing the same thing. The fragmentation is harmful enough already. Congratulations on the new release, I'll still be using dep for a while yet no doubt, so I'm keen to try it out.
Ok I guess it's dep status then but anyway it takes forever to finish (and if I close the editor it'll take forever again...). The issue is that I have a project like this (I know it's not optimal and I'm changing it but it is what it is atm): /package /package/worker/{Gopkg.toml,vendor} /package/server/{Gopkg.toml,vendor} /package/api/{Gopkg.toml,vendor} /package/.../{Gopkg.toml,vendor} So dep status is run for each of them which means I have equal amount of background processes running and these slow the editor so much I can't really do anything but either wait or stop the processes by hand. So I guess in my case it's expected and works as it should but I'd really wish I could disable it somehow. 
You did a great job documenting that example application. I like how you provided examples of something more complex like handling graceful-shutdown + mux when setting up a `http.Server{}`. Thinking about it more, I can see how the resolver would probably only be needed for real applications or *almost real* integration tests. Regular unit tests should be decoupled enough that you can wire up dependancies yourself.
Thanks for the update. As a quick note, you can disable the dep integration completely and then just use dep from the command line. I'll ask my colleagues to have a look at it and hopefully they'll have a better idea than mine.
I think the two year split plan is: - Start a frontend project. Feed it using the Django app. Have it only tackle one or two views at first. - Start a new backend project. Start storing/aggregating the data in a way that makes sense for the new frontend. - Eventually all of the old Django views are replaced by the new thing. 
I just did some unscientific timings for my vg repo: https://github.com/GetStream/vg (which I've just updated to make use of these new improvements as well) Here are the numbers when running `time dep ensure -v` on my laptop in different situations (vg has 26 dependencies) with dep 0.4.1: 1. 21-26s when inputs-digest is removed from Gopkg.lock (rest is kept the same) 2. 1.5-6s when input-digest is up to date (and the rest of Gopkg.lock as well) with dep 0.5.0: 1. 5-6s when converting from an old Gopkg.lock with the inputs-digest removed (so same setup as above) 2. 0.1-0.2s when running it with an up to date Gopkg.lock So that's some serious speed improvements. Well done /u/sdboyer!!!
You might want to take a look at: [https://gobot.io](https://gobot.io)
I struggled with the same thing. I read a lot of articles and still didn't come up with something I liked. I found an article by Ben Johnson on Medium that described what he thinks the standard package layout should be. [https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1](https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1) He came back later and wrote a couple additional articles describing how it should be implemented. [https://medium.com/wtf-dial/wtf-dial-domain-model-9655cd523182](https://medium.com/wtf-dial/wtf-dial-domain-model-9655cd523182) That article has a link to his github account that shows his process for creating a project using his standard package layout. After reading those articles demoing how to use his package structure, I looked through the repo and looked at a PR that he had added in the walk through. While reading through the comments, a guy, billbell73, asked the question that I had been thinking of. Here's the page, the question is about halfway down. I wasn't sure how to link directly to that question. [https://github.com/benbjohnson/wtf/pull/8](https://github.com/benbjohnson/wtf/pull/8) After reading all of those articles, I went to look through Ben's repo's to see if I could find anything that he had created that showed a real example of how he would use the package structure, and I found this repo. [https://github.com/benbjohnson/peapod](https://github.com/benbjohnson/peapod) Hopefully those sources are enough to help you figure out how you want to do your package layout. I've been using that at work since reading the articles, and it has made a world of difference.
Does this support modification of Kubernetes deployments such as upgrades or addition/deletion of nodes?
I'm curious as to what the value proposition is supposed to be. I love the idea of built-in CI/CD, akin to what the guys at codefresh.io are doing, but that's not here and faces some tough competition. What differentiates Containerum from the other Kubernetes frontends like Rancher, Tectonic, OpenShift, PKS, Nirmata? Just tried to install on our test cluster. New install feedback: have `permissions`, `resource`, and `user-manager` components in `CrashLoopBackOff`. Appears to be connection issues with the database. Yay.
Hi everyone, We are currently building a somewhat larger application with several micro-services, a single-page-app frontend and graphql as endpoint. This is the structure that we currently have and that has worked quite well for us (the complete project is now about 50'000 lines of code and 3500 hours working time). All services are built and run in docker containers, which makes development and deployment very reproducible and sane. project // the none source code things - cmd/ // for all command utilities that we need (i.e. database setup, testing, deployment) - design/ // design mockups and source files for icons and images - documentation/ // documentation for the project - operations/ // non-sensitive configurations and binaries required for the productive environment // the code repositories - frontend/ // directory for frontend development - docker-compose.yml // docker file to run a web pack server server for development - docker-compose.build.yml // additional information to build the service - build/ // all build information required to run the service - src/ // frontend source code - graphql/ // graphql backend service - build/ // build directory (exemplary for every service) - bin/ // build go binary - public/ // public files - Dockerfile // docker configuration to build a container - build.sh // build script to build the container and push it to our docker registry - src/ // source of the graphql service - domain/ // all domain models - internal/ // packages only used by this service - auth/ // authentication package - environment/ // environment configuration - resolver/ // graphql resolvers (github.com/graph-gophers/graphql-go) - schema/ // graphql schema definition (will be copied on build into the build dir) - services/ // client specification for grpc services - main.go // main file to startup the graphql server with the respective grpc clients - routes.go // basic routing configuration for frontend and graphql endpoints - docker-compose.yml // hot-reload go container for development - docker-compose.build.yml // additional configuration to build the container (also used by ci-service) - services/ // rpc-services (implemented with grpc) - example-service/ // example grpc service - build/ // build directory with all required information to run the service - bin/ // bin directory for the go binary - envoy/ // configuration for envoyproxy which is deployed as sidecar in the container - Dockerfile // dockerfile to build the container - build.sh // build script to build the binary and container and push it to the registry - proto/ // proto file directory - build.sh // build script to build the proto definitions into the src/domain directory - service.proto // rpc service definition - request.proto // rpc request definitions (each rpc-method has a unique request definition) - models.proto // models definition for the service - src/ // source code of the service - domain/ // domain specification of the service with all models - service.pb.go // files from proto-build - ... // additional domain models if required - internal/ // packages only used in this service - repository/ // repository methods to persist and query the service database - usecase/ // use case definitions implementing all grpc-service-methods - main.go // entrypoint for the service - test/ // testing directory for integration testing (unit-tests are in the usecase dir) - packages/ // packages that are used across all services - logger/ - email/ - .. - vendor/ // vendor directory that is used for all code in the project - .. // the vendor and package directory are mapped into the respective docker // containers of each service 
gofmt really was a great choice. Spending time configuring, setting up, and arguing about linter configurations has cost companies thousands. I've been part of it. In addition, digesting new libraries is much faster with Go because they are all written the by the machine (`go fmt`) and look the same. Readability of 3rd party code is greatly improved. 
You can either write a Trim function [1][2], use Regular Expressions [3] or a Mapper [4]. [1] https://golang.org/pkg/bytes/#TrimFunc [2] https://golang.org/pkg/strings/#TrimFunc [3] https://golang.org/pkg/regexp/#Regexp.ReplaceAllFunc [4] https://www.rosettacode.org/wiki/Strip_a_set_of_characters_from_a_string#Go
 import "strings" ... strings.TrimFunc("abc123", func(r rune) bool { return unicode.IsNumber(r) })
Have you inspected the output? Hint: There seems to be a bug in your code so that each line written continusly grows.
Oops. I inserted “rec = nil” at the beginning of the for loop to fix it.
Btw, how do you run this benchmark? If you run it with `go run`, be aware that this involves compiling the actual program. A better way to benchmark would be to use the benchmark facilities in the `testing`-package.
I'm indeed running it 'go run'
Building first should shave off ~1 s.
And I bet the http get will account for most of the rest of the 0.5s, in both examples. Ie there is no way to tell how this will scale from the measurements you have given.
In general Go is a faster language than Python; owing mostly to the fact that Python is an interpreted language and Go is a compiled language. However, unless either your Python or Go code is absurdly slow, the biggest bottle neck will be your I/O operations. In your case the HTTP request you are making to an API endpoint. If we assume you get a typical latency to the API endpoint somewhere around 50 ms, the difference between your Python code taking 5ms to run and your Go code taking less than 1ms to run won't matter. If you are going to be doing lots of these HTTP calls then you could possibly start utilizing asynchronous operations or threading to make things scale. All that said, I think a better concern when making this decision is portability. You can compile Go to a standalone executable that doesn't require an interpreter or runtime environment on a host to work. If you use Python, you have to consider what version of Python is available on the host you intend to run it on. This isn't as terrible of a problem with Python as people sometimes make it out to be but it is worth consideration. Also, as others have mentioned, you should be comparing the performance of you compiled executable when you use go instead of go run. The go run command will compile your code and then run it. This adds extra time to the execution of the program. 
Checkout go-crazy It runs go on a raspberry pi without Linux, just go and a kernel
This reminds me a little of jenkinsX. Is this a competing product or meant to achieve something different?
And in the python example, the heavy work (json, csv) is written in C anyway.
My guess will be like 95% web io, 4% local io, 1% actual work, most of which happens outside of your reach in optimized, compiled code.
While nowhere near as "slow" as go's compilation, python's startup time is pretty significant when used for things like tab completion in CLI. Probably measurable portion of those 0.5s.
You'll also get a decent boost in speed (once you're doing this at scale), by not using append since you know the size in advance, and then just assigning to the indices directly: var hs []Headline // ... _ = json.Unmarshal(data, &amp;hs) // ... var rec = make([]string, len(hs), len(hs)) for i := 0; i &lt; len(hs); i++ { rec[0] = hs[i].Datetime rec[1] = hs[i].Headline rec[2] = hs[i].Source rec[3] = hs[i].URL rec[4] = hs[i].Summary w.Write(rec) }
would it be possible to add support for importing any repo, private or not to dep like glide does? we're still using glide because of that and it looks `go mod` won't support it either so we are kind of stuck glide allows you to specify the vcs and the repo ssh url 
it'd be possible if we did a thing where you could specify the vcs and proto in the scheme, e. g. https+git://. i would absolutely accept contributions to this end, though it's not the highest priority right now because registries/proxies are gonna become a thing soon, and they are a far better solution for almost every case for `source` that I'm aware of. 
FYI: Go 1.11 beta2 is out with modules. This is much simpler than using \`dep\` because there are no new tools to install, no need to set GOPATH, no need to run 'go get', etc. It's also much simpler to understand, since the logic doesn't involve a complex solver that is hard to troubleshoot. In fact, I predict go modules will influence other languages to switch to simpler solvers. The way I see the trade-off: Dep is much more expressive when pinning down versions to a specific range, while go modules are much less expressive (can only specify a minimum). This sounds like a feature for dep, but it's really just a cop out to work around dumb choices made elsewhere. Go modules will put pressure on libraries not break things, and expose codebases that do break things. At first, the library authors will see this as "extra work". But down the road, the entire community will be able to move faster without breaking things, and those library authors will find that their dependencies work better, and they easily can create new major versions without causing general breakage.
It seems some people are threatening to learn Rust. I think it can only be good thing if people use languages with 'right' module system and eventually write some software. Also Sam remain deeply upset about treatment meted out to dep or to him personally. He will leave remain party pooper whenever discussion about go module comes in as is evidenced by his comment on thread https://groups.google.com/forum/?fromgroups#!topic/golang-dev/a5PqQuBljF4 "i'll be speaking at GoSF next week with a tl;dr of why i believe this is a sad milestone" Lastly I can count on Larry Garfield to give most amazing insights that internet can offer.
I've kind of given up on this. I used `gb` for a while and enjoyed that, but development has stalled. At this point, I'm using `make` and setting my `GOPATH` at the beginning of the makefile. Then I manually use git submodules to "vendor" and manage dependencies. It seems to work alright for my purposes. No non-standard tools and it seems to have the same capabilities.
That's a great reason to use and based on your other replies, where the business boss is pushing back. Depending on your current language at work, migrating to Go could reduce server resources, which result is less money going to servers. It is also easier to teach Go to new developers that are totally new to Go. At work we use Scala and there the difference is huge in both areas, memory/cpu resource and getting new people productive quick. And getting to know people face to face in the community is huge, they may help you with guidance on your migration.
Thats a good point. I didn't even think about that. Also OP, if you are intending on making a CLI program in Python, check out the [argparse](https://docs.python.org/3/library/argparse.html#module-argparse) module included with Python's standard library.
When you wish to define an interface for testing via dependency injection and/or future flexibility, like a package you don’t control, and perhaps wish to scope it to a subset of the full interface of said package.
Take the [image](https://golang.org/pkg/image/) package for example. It defines various image types, with differing capabilities. Their common set of features is expressed by the [image.Image](https://golang.org/pkg/image/#Image) interface, but there are no interfaces for the remaining functions. For example, only some images allow you to set individual pixels. If I wanted to write a library that can draw onto images, I'd want to accept any type that provides the `Set(x, y int, c color.Color)` method. In fact, that's what [image/draw](https://golang.org/pkg/image/draw) does: https://golang.org/pkg/image/draw/#Image The image package doesn't have to be aware of this. Libraries provide the building blocks, you define your use case. Libraries don't have to anticipate all the possible interfaces anyone would ever want. Heck, your interface might span types in different libraries that weren't aware of each other but happen to implement the same behaviour.
Is there any summary of the drama behind this? I'm just getting into Go dev now and don't have a lot of the backstory.
Just ignore it, it’s irrelevant. Use `dep` now and keep an eye on modules in the next 6mo–1y.
dep as of today has gotten seriously faster.
Call me crazy, but I prefer Go without modules/versioning. I like the “fail forward” mantra. It pushes people to stay on top of packages and keep things fixed. I feel that Git is the domain for these concerns. Fork a repo, keep it up to date with upstream. Send pull requests back. Cherry pick changes. Whatever you want to do at that point. No “leftpad” issues. No bloat. You don’t need a bunch of copies of the same thing. I’ll be said one day if there ends up being a ton of excess and issues due to this. Look at your typical node_modules directory for example. Not uncommon to have hundred+ megabytes in there. Why???? It’s a double edged sword here plain and simple. Sure, there are some benefits...but I just see more drawbacks. I also feel it’s a problem that’s better solved through other means.
Yep, I very much prefer go mods as well. I really hope sdboyer's crusade doesn't cause too much damage and fragmentation in the community once 1.11 is officially released.
I guess it depends on what you want to do, but as usual in Go, just some simple bits may cut it. At work I'm developing a Pi Zero based gateway for an agriculture network with XBees, and so far I've used these packages for gpios, serial (gateways can be attached to a local device directly, without an xbee) and xbee communications: https://github.com/stianeikeland/go-rpio https://github.com/jacobsa/go-serial https://github.com/pauleyj/gobee Each of them is pretty simple and probably could be done by yourself, but they'll save you some hours of work.
It makes the “no circular imports” rule practical. With explicit interfaces, you’d need to jump through more hoops to keep imports acyclic. 
Node dependencies are out of control because JavaScript has almost no standard library whatsoever. It’s a language made specifically for the web that has [questionable support for manipulating URL query strings](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams). Leftpad was created because [Internet Explorer doesn’t support `padStart`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart).
That's great news considering it taking super long was why it seemed useless to me. I think I ran it overnight once and then decided to never try it again when it hadn't finished by morning. I'm sure by then it was stuck in a loop or something, but when it threw errors, those were unclear too, so it was painful. And no response to an important issue I opened on the repo. Hmm, I guess it was more than one thing.
Python’s CSV module is also written in C, and in the last benchmark I saw was faster than Go’s, which is not very optimized.
The Sprintf calls are redundant. 
The use of learning Rust as a threat is one of the most ridiculous things I've ever heard of.
`dep` has been working great for me for a quite a while now. What made you want to switch? If you haven't tried it in the last 6 months or so, you should give it a shot.
Sorry, in my haste I was pretty unclear. I haven't really used dep. I gave up trying to figure out which official tool to use and ended up reverting to git sub modules instead. I really like working with gb, but other folks on my team don't like it. Go + make + sub modules seems to work pretty well so far. 
Sorry but I get lost. It is official that we have the very first Go shitstorm already, or not yet? 'vgo' will be an experiment for go1.11 so no harm done. If it will be the success so what? There are any constraints for still use DEP as personal choice? Both parties seem to thought things through, and for most certain have 0 hidden goals to sabotage community.
Thanks for the voice of reason. 
Honestly, `dep` isn't that different from submodules. The advantage is that it's a real dependency manager, i.e. you can specify dependencies in config, override sub-dependencies, use your own fork of a dependency without having to change any imports, etc. [Install it](https://golang.github.io/dep/docs/installation.html), then run this in the root of your repo: dep init That will [parse your imports and initialize them in the `vendor` folder](https://golang.github.io/dep/docs/migrating.html). If you have any dependencies locked to older versions, [you would have to put those constraints in your `Gopkg.toml` file](https://golang.github.io/dep/docs/Gopkg.toml.html). 
If you're looking for something like [pauleyj/gobee](https://github.com/pauleyj/gobee), but at a slightly higher level, I wrote [one such library](https://github.com/ebusto/xbee).
I ran it overnight and it still didn't complete so I stopped it and haven't tried since. Might be nice to try again.
Sam Boyer was the main person behind dep. He isn't happy about vgo and is writing fairly continuously that he things Russ is wrong. https://sdboyer.io/vgo/intro/ https://sdboyer.io/vgo/failure-modes/
Hi! I saw your library, but I was dealing with Series 2 XBees, so it didn't seem like a match, a least from the readme.
Pivotal, SAP and Red Hat are also involved. I work on it for Pivotal.
Just making your db package something like this package db import ( "database/sql" ) var db *sql.DB const ( dbHost = "tcp(localhost:8889)" dbName = "jott" dbUser = "root" dbPass = "root" ) func init() { dsn := dbUser + ":" + dbPass + "@" + dbHost + "/" + dbName + "?charset=utf8" var err error db, err = sql.Open("mysql", dsn) if err != nil { panic(err) } } // CreateNewBlogPost Insert new blog post for user func CreateNewBlogPost(userID int, title string, subtitle string) (bool, error) { stmtIns, err := db.Prepare("INSERT INTO Blog VALUES(null, ?, ?, ?, null)") if err != nil { return false, err } defer stmtIns.Close() _, err = stmtIns.Exec(userID, title, subtitle) if err != nil { return false, err } return true, nil } 
If `dep ensure -v` freezes for more than a minute or so, you've either encountered a bug, you're missing a tool like `hg` on your system, or your dependency graph is _extraordinarily_ unique. The first and last condition warrant posting an issue to the repo.
This is like the CEO sending out a memo saying "I have a great idea", hearing from a few customers "your idea isn't that great" and then responding with "it must be good because none of my employees disagreed with me." The only admission here is that he didn't dictate his plan earlier.
Wasn't the first one back when people got mad about the concept of a code of conduct?
He makes quite a few salient points, one of which being that dep has had months/years of customer feedback whereas vgo has basically just not been argued against. Personally, I'm not even using any vendoring solution (yet), but having used Python/PIP in the past I can't help but feel like vgo's solution is pretty half baked and something I am biased towards hating for some reason.
I agree. That's like threatening to use C++.
thanks your suggestion, I will do some improvement :)
Why would it, projects will use whichever and as long as they are semver who cares. The only stink is go modules sticking major version in the path which most sane people won't do.
I really get the impression that Russ just enjoys forcing his ideas on people regardless of how many object. He needs to take a back seat for a while.
I find it hard to imagine that anything could be less baked than pip. Between the mess of trying to get it to work across different platforms (various Ubuntu versions, non-Debian Linux, OSX, Homebrewed OSX etc which have different flags &amp; behaviours), weird shenanigans some packages try to pull at runtime and crap like pkg_resources, I'd rather have pretty much anything I've ever seen for Go. Having said that, I've never found dep especially easy or satisfying. I'm optimistic for vgo, although for now we've got a solution in-house so I can wait and see how it all shakes out. 
The middle one too. If a missing binary causes a freeze, that's a bug.
I would like to contribute. But this seems like a very large endeavor. Where can I start? It might make sense to file features as issues that people can take up? I must say I don’t have much knowledge about query processing, but I am good with systems design and go, so can contribute there!
[removed]
Thanks a lot!
I also remember one about type aliases...
I have been using go-rpio so far and it's pretty good. I ended up forking it to make it more mockable/usable cross-plaform but in general it's about the level I'm looking for. https://github.com/warmans/go-rpio The only issue I had was that I couldn't get a DHT11 temp/humidity sensor to work. These sensors have a serial communication protocol which seems relatively simple but I ported a working Python implementation to Go and couldn't get it to work. I also ported a cgo implementation to Go and also didn't work. No idea why - maybe something to do with the precise timings needed to initiate the transfer - but it made I a bit suspicious of the library.
Thank you for the idea, we'll take it into consideration!
See https://aws.amazon.com/sdk-for-go/ for some of the documentation on the sdk for go and what's supported
you can support private repos using Go modules and GOPROXY; r/https://github.com/golang/go/blob/bd98a81dc27a740f4c4192cc8799884da62c4bad/src/cmd/go/internal/modfetch/proxy.go#L27-L83
No, it will be tricky. But the thing is, it's _quite_ reusable. It can be used with and io.Reader and io.Writer pair, so it may be worth it to invest a little time testing and writing it.
For me this is a rather buggy release. I run Ubuntu 16.04LTSx64 and today snap updated GoLand to v 2018.2. Now I cannot use the IDE. My custom highlighting is gone and the IDE does strange things (like not refresh the screen, does not show the location of my cursor or allow any kid of code editing) when it cant resolve packages or experiences any kind of syntax that will cause a compile error! Had to manually install 2018.1.5 in order to continue working, quite surprised that this kind of bug slipped through. Its not only my pc, there is a team of 6 people all running ubuntu and all experience the exact same bug. Tried reinstalling, installing --edge version, nothing helped (( Hope it is fixed soon
Have you tried either dep or Go modules?
[removed]
Don't use `go run`, build your code first, then run it.
I really like that Go is maintained by a small team many of whom have been there since the beginning. A thriving community is great but a democracy would destroy Go as a product. I like that we have a better, well-thought solution that fits well with Go and not (a truly great) re-implementation of Yarn or Cargo. I like that while designing vgo, thought was put into what happens to software when it grows too big and also when it needs to be maintained for a long time. IMO Dep on the other hand (probably unintentionally) focused more on software development experience with average sized and actively maintained projects which IMHO is a dangerous mindset to have. Of dep authors have not claimed to think this but that's how I see it.
[removed]
[removed]
Is there a way to speed up version resolving if I don't have the lock file? These improvements shaved off seconds for me, but full ensure takes anywhere from 10 to 20 minutes. How do CIs bypass this? Local caches? Proxying from public Github API to a private one?
Looks to me that the dep people ignored more than once warnings and doubts from Russ. If the backstory was public from the beginning all this drama would have probably not happen.
To be fair, python is fairly more complex in this as it regularly interfaces with modules that have to be built in advance by a different environment. One which differs greatly across platforms (gcc, msbuild, ...).
Like within the last few weeks? dep is basically unusable in China. dep ensure takes about 10 minutes (with ~50 dependencies). When it actually completes. It’s so bad that whenever I have to bring in a new dependency, I just give up and switch to something else for a couple days.
[removed]
Please don't tell people to ignore Go modules. If anything, we need more people to test them out and report bugs. It's of course fine to stick to stable software like govendor or dep for important projects. But ignoring modules for a year is not sound advice.
Looks really decent! Great job, definitely going to follow. 
As I understand it, Amazon generates their SDKs from an underlying specification, so broadly speaking, they either support a language or they don't. Barring maybe some of the newest stuff where maybe there's an uneven rollout, there's no great advantage or disadvantage to using Java or Go that I know of. The SDK is a bit non-idiomatic to Go, but I would be surprised if it weren't a bit non-idiomatic for Java as well. That's what happens with these generated APIs. Eyeballing the supported services through the ones starting with "a" and "b", they match the Java and the Go API. I fully expect that unless you are doing something exceedingly strange and very cutting edge that the Go APIs are all there. Along with everything else they support.
You don't need to wrap the `func(rune) bool` with a `func(rune) bool`: strings.TrimFunc("abc123", unicode.IsNumber) 
I think the advice was to ignore drama, not modules.
Oh, my bad if that's the case. Still, telling people to simply use dep isn't great - we should be encouraging more people to give modules a try, in particular once the 1.11 release candidates are out.
Thanks for the detailed feedback! Codefresh.io is really great, but we are trying to do a platform that combines CI/CD with container management features associated with platforms like Rancher and other great guys. It is possible to use Containerum with any CI platform - we'll add instructions soon. And we are working on some other interesting features, I hope we can announce them soon. Yes, unfortunately we had an issue due to some error in the `permissions` component, but now it's fixed. Now helm installs the latest stable release, I've just checked - it works. Thanks again!
So in the end the go vendor itself did choose to not use a community build project into their official binaries and therefore avoid taking care and responsibility of said code. Where is the drama? I do not care, I can choose for myself if I want to use dep or vgo or fuckitallandunzip. The go core team does core work, if dependency managment goes into core, they need to take care of it. I never expected dep to become official in the first place.
Well idk about how it runs on different os's but for language syntax you should try to re-engineer core packages. Really opens your eyes to what's going on. Heck even rewriting the basic print functions is interesting. https://golang.org/src/fmt/print.go#L263 Never thought about an error and fatal property before and they make use of pool.sync get(). Tons of stuff online for that. Just go through packages and the types they use. Try to make a package without using a package. There's gold all around.
Thanks!
Dep 0.5.0 was released and others are reporting a 5x speedup when using it. http://reddit.com/r/golang/comments/921knu/dep_v050_has_been_released/e32vcdz 
Maybe I'm being too optimistic, but I'm kinda glad this sorta drama happened. I think the fallout would've been worse if Go was in version 2.x and the same thing happened. Go is still new and there's still a lot of kinks to straighten out, so I can give Russ a pass on this one. Let's just hope that Russ takes this as a lesson and prevents this from happening again. Again, props to Russ for admitting he's in the wrong and actively trying to make things right (At least from the outside looking in.). 
But that same CEO doesn't go back and say he was wrong so that's how I see your example compared to reality.
after reading the drama for the fun of it. it boils down to butt hurt. some people thought they could force design decisions because they were there first. Go team is not forcing you to use their tool. Dep team can continue ship their product. Which will everyone use, I am sure both. People like being diffferent. These arguments belong in one place only, on 4chan where the anons can troll it and make fun of it. P.S. I personally find russ's political views to Politically correct. fuck being PC.
One use of implicitly satisfied interfaces is to re-widen a narrow interface when it's possible. Suppose that you have a net.Conn and you want to call CloseWrite() on it if the underlying concrete type supports this (which it often will). The simple way to do this is to define your own interface that contains just CloseWrite() and then try to typecast your net.Conn to your new interface type. If this succeeds, you can now call CloseWrite() and you didn't have to know a big (and potentially changing) list of concrete connection types that support CloseWrite(). (If you say that you know all of those concrete types, did you remember tls.Conn? I'm sure there will be or are others, some of them in third party packages that implement, eg, QUIC.)
As of yet, Containerum doesn't support adding/deleting nodes, but we are considering this for future development.
I second this, reading the source code of go is one (best?) way to understand internals
Low level like how the CPU works? Depending on what you already know, I would learn in the following order: program counter, thread context, interrupts, mutex, then you will have a better understanding of how channels or any other synchronization primitives work. 
https://github.com/teh-cmc/go-internals
I made \[something to scrape [WhiteHouse.gov](https://WhiteHouse.gov) and provide the list of signed legislation as an RSS feed\](r/https://www.gitbhub.com/DeedleFake/signage), but I haven't really been maintaining and it doesn't seem to be working right now.
This is definitely not correct. I’ll post a longer response later today.
How do you suggest that people contribute to your project if they want to? Obviously, you could just take go-critic, errcheck, and maybe other linters for a spin and fix those for start, but what in particular are your goals for the project in the future? ('anything' is a bit broad) :)
uint8=byte Use int.
Coming from 1990's scripting languages, I always felt like I had to code with one eye open. Go is really refreshing, much of that comes from the high level of experience and insight provided by the Go team. It's tiring to have to find (not just expect, *find*) the bugs/poor design choices in other languages packages. 
https://golang.org/pkg/encoding/json/#Marshal &gt; Array and slice values encode as JSON arrays, except that []byte encodes as a base64-encoded string, and a nil slice encodes as the null JSON value.
So, as the docs quoted in other replies say, a byte slice is marshaled as a base64 encoded string, and byte is an alias for uint8. You can either use int instead of uint8, or define custom type based on uint8 and an appropriate `MarshalJSON()` method for that type. Example: https://play.golang.org/p/f1q4jzPiAqT 
All this drama boils down to some random guys wanting so hard to have their work integrated in Go upstream regardless of the possible bad outcomes in the long run. Glad to see that Go is not a democracy, and solid engineering has the last word.
I love it when people threaten to learn Rust. Next time there is an argument on the Rust internals forum, I'm going to threaten to learn Go.
Good! Regardless of the outcome (or my preference) I really want to hear both sides. I hope it helps in settling this quickly, and we can go back to spend energies in a more productive way.
Might be a bit late here, but I didn't see this answer, so here goes. One possible explanation is that Ethereum was getting a little bit of traction in 2016 and they have a Go implementation of their node in Go. Crypto also attracts lots of computer science type people, so that could be a part of the explanation (though tiobe changing their algorithm seems likely too).
Does anyone else read "Twitter thread" and think, "nah, I'd rather not read that format"?
That's a straight forward with no sugar coating way to say it. That being said, it would have been great if the core team was more closely involved in \`dep\`'s decision making and development. Russ admitted it, and I think the next big project for Go will be much better as a result. I understand it is frustrating to work so passionately on a tool that would shape Go such as \`dep\` only to have it be shutdown as hardly as it did (with some lessons transferred to go modules). Community-wise that was not cool and plainly frustrating the more involved you are with \`dep\`'s development. For Go itself, it wasn't all that important and is probably better the core modules tool be implemented and maintained by the core team, like you said.
Sounds like picking a programming language is like picking sports team to some.
I see, thanks for the explanation. I'll keep an eye on it and maybe check it out should I require logging in a performance critical environment.
They generate the baseline SDK automatically, but add language-idiomatic helper libraries on top. Go's libraries are fairly immature, but not completely horrible... You're just dealing mostly with the generated input/output structs for everything, which are pretty annoying to use.
Yeah but honestly... what was the expectation from the get go? That a complex vendor system will become a part of go, mainly done by an "outsider" that will not be recruited into the company and have the language itself sport official "support" for it? Not gonna happen here, very rarely happening elsewhere. Not seeing this in cstd lib, erlang core, node core, python, php or any other language. Smaller patches, fixes, pull requests with tests sure. I'm not sure if the expectation was primarily to become "core", what should've been a bad motiviation from the start. There is no harm in being a 3rd party vendor, that you can load into or compile into your system yourself, almost any other language works the same way. You can still build a better vendor system, without being in core. Thats way we have go get in the first place or not? Maybe I'm just into the topic enough but the expectation just seems way to disconnected with the OSS world.
I recommend letting the godoc be the godoc, and using the valuable README.md space to describe the package more conceptually.
&gt; I hope . . . we can go back to spend energies in a more productive way. Yeah, 1000% on that.
Thanks a lot, that works perfectly! The only issue is that I'm using it with the [postgresql](https://github.com/lib/pq) lib and when I try and scan values in the database to the type X it throws the error: \&gt; unsupported Scan, storing driver.Value type \[\]uint8 into type \*\[\]main.X Even though they're the same type it doesn't seem to allow it, I also tried converting the \[\]uint8 value to \*\[\]main.X but no luck there either. Sorry for the stupid questions but I'm not sure what else to try
Just read Go runtime code. BTW, channels has not relations to epoll. The channel select mechanism is more like traditional linux net/select. You can read [this article](https://go101.org/article/channel.html) for some explanations.
Sorry for the bit of a lead time with the reply. The factory pattern I use (for the Database, particularly) is on https://github.com/titpetric/factory - I declare all the possible database configurations in main(), and then simply get individual db connections with `factory.Database.Get(name ...string)` (takes first parameter or uses "default" - most of my microservices interface with just one database). Compile time safety included. There's some other helper stuff in there, but mostly it's about the database. I have only one caveat about it, and that it's just a step away from packaged global values. It's not a huge concern in the sense of responsibility, but when you start to mix other things into the factory object, it does tend to get a bit polluted. I definitely didn't want to refactor it into `factory/database` because that package name is just super wrong. Having factory structs in a factory-named package seems to work out OK. Using `db := factory.Database.MustGet()` is explicit enough for me, and with the possible name argument, works well to differentiate database connections to different hosts. It's also a pitfall of codegangsta/inject, if you need two database dependencies, it just provides you two of the same (the inject tag there could have a name parameter, or use the field name as well). That's a very common DI issue. 
Hope somebody can find the words to stop this drama that will let us go forward. There is only one things we are sure is that both rsc and sdboyer are very great people who work very hard at a high level.
They were not some random guys, though. The tool the dep guys created was based on experience building other tools, input from the community, and input from the Go core team Not sure why your uncharitable and dismissive comment is so highly upvoted. 
the way the README was worded i honestly thought the core team WAS very involved in decision making or at least doing lots of feedback to evovle it into the official standard. It sounds like that wording should have been called out? I'm really surprised no one made a fuss about it. https://github.com/golang/dep/commit/7ae1fda48dd9da628c37a086b1ab1dd862830211#diff-04c6e90faac2675aa89e2176d2eec7d8 "dep is the official experiment"
Thank you for sharing! 
You are right, sorry if it was not fair. Edited, but the meaning doesn't change: as a regular Go user that sees the language as a brilliant tool to solve actual problems (I'm not into any community process), it looks like that some devs hoped to see their work merged despite warnings. Don't get me wrong, it's perfectly understandable, I would have done the same, for sure.
https://threadreaderapp.com/thread/1022588240501661696.html
https://threadreaderapp.com/thread/1022588240501661696.html
I second this a lot. Languages are tools, not sport teams or political parties, otherwise you will end up using the wrong tool for the wrong task.
emf
I still fail to find any proof that the workgroup was to work towards the final dependency management solution. Every public thread that I can find clearly talks about experiment or "first step towards". We can all agree that the Go team could do more to welcome more meaningful contributions, and that this wasn't handled very well. But that still doesn't explain why dep should become something that it was never explicitly designed to do. Can anyone provide proof of a plan for dep to be merged into Go in some form? Either approved by the team or by the community, although I'm not clear on how the latter would happen.
Every mistake in node_modules is rm -rf away. The leftpad stuff has everything to do with npm the company/registry and nothing to do with node modules as a concept and even npm as manager. It was a consequence of people using stupidly small libraries and the registry allowing for way too much rights to publishers. 
dep was started precisely because nobody on the core team was giving the problem any attention. We made continuous appeals throughout the committee's lifetime, to open lines of communication and talk about "a plan for [what would become] dep to be merge into Go in some form". It's worth noting that we were were appealing for communication well before dep was a thing, when we were just starting out, and doing research about the design space. The first meaningful response to those appeals was when Russ began speaking to us, which was well after dep had become usable. Maybe we shouldn't have expected to just go off and do our own thing and have our research accepted, our decisions affirmed. That's valid. But then how can _anyone_ move the Go ball forward, if the core team doesn't have bandwidth to think about a particular problem? It seems that Go's development progress is gated by the core team. And that's fine!! But if that's true, if the community can't make substantial contributions autonomously, then it's not a community project, you know?
&gt; And if the community has been in a crisis mode for lack of a standard solution for just as long? I think community can be in crisis if there is no solution at all rather than lack of standard solution. &gt; Maybe some of you are reading this and thinking to yourself, “well, no duh, Peter, that should be obvious.” True for any language. If it is any consolation Rust also dumped dependency management tool developed before Cargo. Java developers at Oracle had protracted fight with 'open source community leaders' who wanted to push OSGI as module system for Java. Swift team at Apple dumped the efforts of Swift-server-group and developed swift-nio in-house. I can't say I know future but whenever I hear more and more about committees, advisory groups , focus groups, strategic teams etc in regard to software development, the output of it will be either vaporware or ultimately abandoned.
&gt; whenever I hear more and more about committees, advisory groups , focus groups, strategic teams etc in regard to software development, the output of it will be either vaporware or ultimately abandoned. Yeah, lesson learned.
Thanks for the reply, this does clarify some things. &gt; It's worth noting that we were were appealing for communication well before dep was a thing Was a proposal draft ever published? For many years, that has been the way to get input and approval on large changes to the Go language and tools. I don't understand why all of this was done in a non-public way. &gt; Russ began speaking to us, which was well after dep had become usable. I think this is the entire misunderstanding right here - dep took a life of its own that was never discussed nor approved by neither the team nor community in a public place. &gt; if the core team doesn't have bandwidth to think about a particular problem? I simply don't think this is true, at all. Very, very large contributions have been made to Go from the outside, following the existing process. Wasm is a very good recent example. Windows support is almost entirely the work of someone from outside, I think. x/mobile is also a good example, and it's a beast of its own. You can't say that "these were easy because the team agreed with them", though. Simply because dep, as it is today, was never even proposed and reviewed. So it wasn't even rejected.
&gt; Was a proposal draft ever published? All of the commitee's work was public, including all of the design decisions we made along the way. So, yes, essentially. &gt; dep took a life of its own that was never discussed nor approved by neither the team nor community in a public place. `dep` was tacitly approved by the community as a function of how it was born. We were actively appealing for approval, or guidance, from the core team from day one. So I don't think this really works as a criticism. &gt; You can't say that "these were easy because the team agreed with them", though. Simply because dep, as it is today, was never even proposed and reviewed. So it wasn't even rejected. `dep` is categorically different than support for a new architecture, or a new package. It interfaces with the language ecosystem at a much higher level. It wouldn't have been coherent to make a proposal until we could talk with the core team about their ideas for integration. The core team never gave us a chance to do that. Of course, this is all irrelevant. We were entering uncharted waters when we tried to tackle this problem, both technically and politically. Now with this feailure we have a better map of the territory, I hope it helps those that come after us.
An interesting read and clearly the committee wasn’t as empowered to solve the problem as they imagined. The summary at the end is a bit broad though. I think the lesson isn’t that the core team must design everything, but rather, they can’t *disagree* with the design. The article briefly mentions a huge red flag: known fundamental disagreements between Sam and Russ on the approach. Obviously I wasn’t there, so this is based purely on the wording in the article: I’m guessing it felt a bit backwards to Russ for a non-core team to say “no thanks” to a design requirement from him. That’s where the lack of true empowerment revealed itself. Ultimately the dep group could suggest change, but not really implement it. Any way you slice it mistakes were made by the core team and it sounds like at least some of them are already acknowledged. I appreciate the work done by the dep mgmt working group and I know it sucks to see something you’ve worked hard on get tossed aside. Let’s just hope in 6 months modules are flourishing and this problem is behind us all. 
&gt; The summary at the end is a bit broad though. I think the lesson isn’t that the core team must design everything, but rather, they can’t disagree with the design. The article briefly mentions a huge red flag: known fundamental disagreements between Sam and Russ on the approach. Yep, this feels more correct to me, too. Would you mind if I included it in an edit? &gt; I’m guessing it felt a bit backwards to Russ for a non-core team to say “no thanks” to a design requirement from him. That’s where the lack of true empowerment revealed itself. Ultimately the dep group could suggest change, but not really implement it. This also rings true. &gt; Any way you slice it mistakes were made by the core team and it sounds like at least some of them are already acknowledged. I appreciate the work done by the dep mgmt working group and I know it sucks to see something you’ve worked hard on get tossed aside. Let’s just hope in 6 months modules are flourishing and this problem is behind us all. Thank you.
&gt; dep was tacitly approved by the community as a function of how it was born. We were actively appealing for approval, or guidance, from the core team from day one. You seem to be mixing team and community here. I'd like to think I'm an active contributor and member of the community, and I never approved any dep roadmap or design. &gt; It wouldn't have been coherent to make a proposal until we could talk with the core team about their ideas for integration. This seems to be built on assumptions. The team never intended for the experiment to be integrated, so in a way it makes sense that such discussion wasn't taking place. In my eyes, a proposal draft here would have clarified things for everyone. &gt; I hope it helps those that come after us. I honestly think it's great if the team learns from this on how to handle workgroups and experiments in the future. And I do hope that this doesn't happen again. However, the fact that the team made a mistake doesn't give dep the right to follow its roadmap and be merged into the tree. As of today, it still hasn't been proposed and accepted by the formal process that has existed for many years. So, like any other large change, it should simply be rejected unless it's properly proposed.
&gt;Yep, this feels more correct to me, too. Would you mind if I included it in an edit? No problem.
&gt; This is somewhat disingenous. The course correction also surprised the package management group collectively, because until the vgo papers appeared, we had every hope and expectation that the core team would continue to work with us and dep to get it to an acceptable place, rather than propose something altogether new. I don't get this. I really don't. Even before Russ' most recent tweets, I was under a pretty firm impression that he had been closely collaborating with Sam for months before he published anything about vgo. His tweets and published docs now confirm, that it was even 6 months before *that*. The post he links to from June 2017 contains many, if not most of the ideas behind vgo's design already. I just don't get where the narrative is coming from, that vgo was a surprise. It was a surprise to us, in the peanut gallery, but the package management group seemingly was aware of vgo at least 8 months before it's publishing. And it baffled me at the time and still baffles me, that Sam could be under the impression that his talk at Gophercon 2017 was *at all* in line with the communication from Russ. Like, I'm trying really hard to be fair here and give everyone the benefit of a doubt. I can understand that you didn't *receive* the message and to a degree that definitely is Russ' responsibility. But I just don't understand why this narrative is continually upheld, that the message wasn't *sent*. And personally, I don't see how it could've been much clearer. &gt; Pathological conditions exist, but advocates for SAT have never claimed otherwise. FWIW, it's not *just* about pathological conditions. IMO SAT solvers are bad *in the common case*. They are slow, their solutions are inexplainable and when they fail, they fail horribly and confusingly. This is something I find in general. The more powerful an algorithm is, the worse it is degrading when failing. And it seems very Go-ish to intentionally restrict power for introspectability. Go's syntax and type inference for example, are intentionally kept simple - not because the language team is lazy and doesn't want to implement complex grammars and type systems, but because it makes for cleaner, more understandable failure modes. &gt; Russ’s technical arguments were certainly not ignored; we debated them extensively. They simply failed to convince Sam and the committee. Rather than refine the arguments to be more convincing, or work with the committee to hammer out a compromise position, Russ decided to implement his ideas on his own, and make a proposal without us, and without telling us that’s what he was doing until it was essentially done. To be clear: as technical lead on the Go project, Russ certainly has the power to do all of these things. But what image does that project? Really, this seems to be the crux of the matter - still. What do we do, when consensus with a broad group simply *can not be reached*? I have the same experience you have - the other way around. I've seen the arguments against vgo and they are just *failing to convince me*, just like they failed to convince Russ. And that's not because they are bad or phrased badly or Sam didn't put enough effort into his blog posts and the discussions. It's because, at the end of the day, a lot of it comes down to matters of opinion, predictions and subjective aesthetic taste. What to do in that case? I'd argue it's not just Russ' "power" to resolve such an impasse, but it's his responsibility. Literally the job of a tech lead. And note, that at least according to him, he didn't actually make the decision, but deferred it to the usual committee. Now, there's certainly some truth to them being biased in the matter. But IMO there's also a lot of truth to the idea that vgo's design simply fits better into Go. And TBQH, if it comes down to getting a bad design with the community or a good design against it, personally, I'd choose the latter. Of course it would be preferable to get a good design *with* the community, but as you point out yourself - that wasn't happening. There was an impasse. &gt; The community of contributors to dep were ready, willing, able, and eager to evolve it to satisfy whatever was necessary for go command integration. Where you though? Didn't you just say the opposite? That you did not agree with Russ and weren't willing to change things until you felt convinced? It's an inconvenient fact, that most of the time there *is* no objectively correct way or a formula to resolve an argument and most of the time, a decision has to be made. And most of the time, the people who that decision goes against will feel that they weren't listened to and that they had good arguments (I certainly feel like that very often). Frankly, I admire Russ for being able to be the person who makes and sticks to that decision, however unpopular it may be (and frankly, it doesn't actually seem unpopular to me, to the best of my knowledge the majority of the Go community likes the vgo design).
&gt; But if that's true, if the community can't make substantial contributions autonomously, then it's not a community project, you know? There are various types of community projects. It's not a binary (community or not community), but a spectrum. Different government styles also produce different results (similar to Conway's law).
Yes, I'm on board with this.
By building and assigning to the indices directly, as well as writing about 100 rows: Go - 0.35s Python - 0.5s
Reading Russ's thread, it appears that he values logical exploration of the design space as valuable work, and throwing away a particular implementation/approach as a relatively casual part of that. It may be partly a difference of perspective.
Anyone have a TL;DR for the Twitter thread?
&gt; `dep` was tacitly approved by the community as a function of how it was born. Not to split hairs, but I'm not sure we have good definition of who the community is and how to measure it's approval. My impression was that the main driver behind dep's acceptance was Sam's talk at Gophercon, where he sold it (intentionally or not) as ready, the next thing and officially endorsed. But I'm biased in that perception, of course - again, we don't have a terribly good measure of these things.
Yeah some function taking in an unexpected type. Hmm what does that remind me of??...🤔 Are you sure you are not separating types and their logic? You are coming from a dynamic language right? And so you chose a type strict language to do it right?
You have to use this: [https://goswagger.io/](https://goswagger.io/) Alternatively, have you considered using this? [https://github.com/xeipuuv/gojsonschema](https://github.com/xeipuuv/gojsonschema) It's much more powerful than swagger, which currently only supports the latest OpenAPI standard draft. Alternatively, there is also this: [https://github.com/swaggo/swag](https://github.com/swaggo/swag)
Go modules will be npm. The standard dependency manager that comes with the language. In time I expect the majority will be on it. But there is a small window where you could estalbish dep to be yarn! An alternative to the standard tooling that resinates with significant chunk of the community. But for that to happen /u/sdboyer and the committee needs to not slink off to lick their wounds. You need to recognize the landscape has changed. Go modules have some pretty serious warts right now. If you want dep to survive identify and target them. Be responsive to your community. Move fast. Take feedback. Encourage contribution. OR you all go the way of bower. Where people run into your files and go ugh your still using bower?? Warts. https://github.com/golang/dep/issues/1959#issuecomment-408108743
I've followed this saga very closely, and I'm firmly in the Russ camp. Dep is just barely OK - it's a second rate tool that provides a second rate experience, especially when compared to the state of the art in other languages. Russ is a first-rate engineer, who is ultimately responsible for making sure the Go project doesn't fall behind. Dep wasn't converging on an acceptable solution, so he stepped in and did it himself. Look at the checklist in this post - advisory groups, secondary advisory groups, half a year spent collecting user feedback, "consensus on all major decisions", and above all painstaking documentation of all of the above. I've never, ever seen a good design come out of a bureaucratic process like this. Moreover, it's completely antithetical to Go's personality, which is built on sharp-elbowed, opinionated, pragmatic decisions. The truth is that a bunch of dudes worked hard on dep, we learned a bunch of things, but it didn't pan out. 
To support one thing /u/peterbourgon wrote, for what it's worth, vgo did surprise the package management committee, and that was entirely my fault. As you can see in the notes from the July 2017 conference call, I'd been up front that my plan all along was to figure out what go command integration should look like and prototype it bolted onto the go command (in those notes I called it 'xgo' x for experimental), but I didn't even start on that until quite late. After the disaster of a meeting about import versioning in November 2017, I told everyone I'd meet with Sam directly instead, since he was the main objector and it seemed more productive to talk directly and not force the others to watch. And even at that point there was no actual software. I switched to meeting with Sam ~twice a week. Sam knew in that time, from early December 2017 to mid-February 2018, that I was working on both blog posts on import versioning and minimal version selection and the "bolted" prototype, but I didn't realize until just a few days before the public posts that I'd never closed the circle and gone back to the larger package management committee (Peter, Jess, Ed, Andrew, Sam). At that point I sent a PDF of the draft posts and a link to a private repo with the implementation sketch. I know that was jarring for them, since I'd only been meeting with Sam since early December. That was entirely my fault to forget to loop them back in more gracefully. Another mistake avoidable by being much more public with all the communication. My apologies.
That's fair. I mean that everyone involved in dep came from the community, including all the authors of dep mgmt tools until that point, and that all of our work was public, documented, and open for discussion in a lot of different venues. Notably, it all began over a year before Sam's talk at GopherCon. Once can definitely say "well _my_ specific needs weren't reflected in the result" or etc., but given that the mandate is "self-organize a solution from a large community" I don't know how we could have done any better than we did. I talk about this in the last section of the blog post. 
&gt; Look at the checklist in this post - advisory groups, secondary advisory groups, half a year spent collecting user feedback, "consensus on all major decisions", and above all painstaking documentation of all of the above. I've never, ever seen a good design come out of a bureaucratic process like this. Yep, fair, but given the constraints at the time, I judged it to be the best chance we had at success. Mea culpa, won't make that mistake again.
Named return parameters are for documentation. Naked returns are for pissing off your coworkers. The first is frequently used without the second.
Naked returns are almost always less clear than explicitly specifying what is being returned.
thank you greatly.
&gt; Dep was tacitly approved by the community as a function of how it was born. Yes but it doesn't mean the design of Dep was accepted. I remember that we was a lot to prefer a more Goish approach (even if impossible to describe).
&gt; I know that was jarring for them, since I'd only been meeting with Sam since early December. That was entirely my fault to forget to loop them back in more gracefully. Another mistake avoidable by being much more public with all the communication. My apologies. I'm not entirely convinced that "more public communication" is the answer. FWIW, I mostly abstained from the discussion about versioning and dep-mgmt when the committee started (after being at times relatively vocal on the topic before - arguably *too vocal*) because there was *too much* public information already. It seemed infeasible to survey it all and counterproductive to engage in the discussion without doing that. There seems to be a widely held belief that more public discussion is better and more democratic Personally, I don't think that's the case - on the contrary, the extensive noise often makes individual voices *quieter*. And FWIW, personally, I agree with [what you say here](https://twitter.com/_rsc/status/1022591332441890816) - in the end, I trust the Go team to own its development and to continue to make it the great language I fell in love with. So, personally, I'd hope that that's kind of the model that we as a community can use for these things. There can be discussions and people should be heard, but in the end, the decision is simply owned by the Go team. They've shown good judgement, even when lots of people disagreed.
There are other things that bother me about your post, Peter. You sling about words like "disingenuous" very liberally. That's a serious accusation in a professional context, and you seem to use it even when the most likely explanation is misunderstanding or miscommunication. The entire tenor of your post, Matt Farina's contributions and Sam Boyer's own writings is peevish and petulant (dare I say butthurt?). You guys seem to be willing to try to burn community goodwill to salve your own egos, and it's not a good look. You tried something, it didn't work out. It's not like dep was perfect, or even very good. Why defend it? Just learn from it and move on. 
I would add, this ethos is one major reason I use Go. C# copied Java, after all, that's how you made a programming language. Go is familiar to C++, Java, and C# developers, but fundamentally different and built up from principles. It doesn't need to be that way, but that makes Go, well, Go more then anything else. Go doesn't call libc, even though practically everything else does, after all, a car is a car. Go doesn't use make files or project files, why do something different? Maybe we should take a developer survey to see if Go should add Generics, that sounds like a good idea, just make it like C#'s generic's, right? Yes, Russ' attitude is the thing that makes Go, well, Go. As a community member and an "adviser" on that dependency committee Peter talks about, I'm very happy with Go modules. &gt; I think the lesson isn’t that the core team must design everything, but rather, they can’t disagree with the design. Yep.
It doesn't mean it was a mistake, it was a very valuable experiment ! How many time we throw away a bunch of our own code the next day ? How many time we just implement an idea alone just to see if it works like did rsc ? And finally if it works, it's the best way to show his idea.
I think it's fair to say that Russ comes from a pretty formal computer science research background (at Bell Labs) where that's exactly it; provided you (and those around you) learn from the research you do, any prototypes can be discarded and that's fine. Honestly, it's something I'd like to see more of in the industry.
&gt; I mean that everyone involved in dep came from the community, including all the authors of dep mgmt tools until that point, and that all of our work was public, documented, and open for discussion in a lot of different venues. Agreed. &gt; I don't know how we could have done any better than we did. Neither do I. That's pretty much why I'm unhappy with the situation. I don't think there really was a lot of individual failing on any of your parts - but the thing is, I also don't see as much of individual failing *on Russ' part* as you. As a relative outsider, it is obvious that you, Sam and the rest of the dep-mgmt working group did your best and feel honestly steam-rolled and I believe I understand why. But as a relative outsider, I *also* distinctly remember sitting in the GopherCon auditorium thinking "ouch" during the talk™, because what I heard seemed to clearly contradict what little I've read about the discussion (mainly the first couple of posts of the infamous "dep go-tool integration roadmap" thread). I'm having trouble plainly pointing the finger at the Go team for not communicating clearly, if someone as tangentially familiar with the subject as me got the message. If in doubt, I tend to put the responsibility on the sender of a message, not the receiver too. But it still seems to me that at least in part, a bit of contemplation about *why* "you" didn't see this when others did might help too.
I *never* use naked returns (I think their inclusion was categorically a mistake). But I use naked returns. For either of two reasons: 1. Documentation. They appear in godoc and *sometimes* help documenting. 2. Changing them in a defer'ed function.
&gt; but in order to re-use it I would like to actually change the import path from "github.com/myusername/mypackage/whatever" to "./whatever". Why? Doesn't seem more reusable to me, but less. Having the thing once and sharing it between all your packages vs. copying it to each individual repo? Seems the former is better. &gt; Generally my idea is just to "clone from the github" project and start coding with my own boilerplate system/code. Personally, a `sed -i s@myusername/boilerplate@myusername/mypackage/boilerplate@` **/*.go` (or, worst case, putting that into a skript/command that uses a more robust logic, if needed) doesn't seem too much of an ordeal to add to that.
Somewhat a tangent, but I really have the default to v0/v1 in the vgo design. That will create a lot of problems that can never be undone once this design becomes official.
in parser.go for c := n.FirstChild; c != nil; c = n.NextSibling in main.go for c := n.FirstChild; c != nil; c = c.NextSibling parser.go should be c = c.NextSibling
holy crap, man! GREAT eye! Thank you, thank you, thank you! I can go home and have a good weekend now! You won't believe the level of frustration I've been experiencing over the last few hours! 
Terraform is written in go, which should give you some confidence in the Go SDK for AWS :)
An enlightened despotism? (Sorry, I might know better but I stopped at the first Civilizations by Sid Meyers)
do you have an example? here are some related issues btw: https://github.com/golang/go/issues/26134 https://github.com/golang/go/issues/26145
Totally agree. I have seen this groups, committees driven development in large enterprise projects where besides architect astronauts and there are whole bunch of contractors/consultants billing clients and spinning yarn about executive steering committee taking stakeholders input in an offsite meeting.
Ya, I agree. I haven't documented most things and I wasn't sure who was going to look at it, so I figured a glance at the important bits was good for now.
dep developers/advisors are extremely unhappy (surprise!) about vgo/ Go module solution.
Perhaps the worst “feature” of the language, IMNHO. Nobody bats 1,000. 🙂
Totally agree with you. Especially in this situation, I think it's perfectly fine for the core team to own all decisions regarding the future direction of the language, including refusing to integrate work that doesn't make sense given the roadmap. That's kind of their job and I hope that they continue to operate this way.